L;
                  DLGPROC lpProc = (DLGPROC) MakeProcInstance((WINPROCTYPE) FindDlgProc, hInst);
                  if (lpProc)
                    {
                    char *pszFind = NULL;
                    windiff_UI(TRUE);
                    nRet = (BOOL) DialogBoxParam(hInst, (LPCTSTR) IDD_FIND, hwndClient, lpProc, 0L);
                    windiff_UI(FALSE);
                    FreeProcInstance(lpProc);
                    }
                  }
                  break;

                case IDM_FINDNEXT:
                  {
                  const LONG iCol = (view_isexpanded(current_view)) ? 2 : 1;
                  FindString(hWnd, iCol, NULL, 1, 0);
                  break;
                  }

                case IDM_FINDPREV:
                  {
                  const LONG iCol = (view_isexpanded(current_view)) ? 2 : 1;
                  FindString(hWnd, iCol, NULL, -1, 0);
                  break;
                  }

                case IDM_GOTOLINE:
                  {
                  if (!view_getrowcount(current_view))
                    {
                    MessageBox(hWnd, LoadRcString(IDS_GOTOLINE_NOLINES), szWinDiff, MB_OK|MB_ICONSTOP|MB_TASKMODAL);
                    }
                  else
                    {
                    DLGPROC lpProc = (DLGPROC) MakeProcInstance((WINPROCTYPE)GoToLineDlgProc, hInst);
                    if (lpProc)
                      {
                      windiff_UI(TRUE);
                      DialogBoxParam(hInst, (LPCTSTR) IDD_GOTOLINE, hwndClient, lpProc, 0L);
                      windiff_UI(FALSE);
                      FreeProcInstance(lpProc);
                      }
                    }
                  }
                  break;

                case IDM_EDITCOPY:
                    {
                        unsigned long cb = 0;
                        LPCSTR pszText = NULL;
                        long iRow = 0;
                        const BOOL fOutline = !view_isexpanded(current_view);

                        /* first count total data size */
                        for (iRow = 0; iRow < selection_nrows; iRow++) {
                            if (fOutline) {
                                pszText = view_gettext(current_view, selection + iRow, 1);
                                if (!pszText)
                                    break;
                                cb += (lstrlen(pszText) + 3) * sizeof(char);
                            }

                            pszText = view_gettext(current_view, selection + iRow, 2);
                            if (!pszText)
                                break;
                            cb += (lstrlen(pszText)) * sizeof(char);
                        }

                        if (cb && OpenClipboard(NULL)) {
                            /* space for trailing nul char */
                            cb++;

                            /* copy data to clipboard */
                            if (EmptyClipboard()) {
                                HGLOBAL hData = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, cb);

                                if (hData) {
                                    void *pv = GlobalLock(hData);
                                    if (!pv) {
                                        GlobalFree(hData);
                                    }
                                    else {
                                        LPSTR pszBuf = (LPSTR) pv;
                                        memset(pv, 0, cb);

                                        for (iRow = 0; iRow < selection_nrows; iRow++) {
                                            if (fOutline) {
                                                pszText = view_gettext(current_view, selection + iRow, 1);
                                                if (!pszText)
                                                    break;

                                                lstrcpy(pszBuf, pszText);
                                                pszBuf += lstrlen(pszBuf);
                                                *(pszBuf++) = '\t';
                                                *pszBuf = 0;
                                            }

                                            pszText = view_gettext(current_view, selection + iRow, 2);
                                            if (!pszText)
                                                break;

                                            lstrcpy(pszBuf, pszText);
                                            pszBuf += lstrlen(pszBuf);

                                            if (fOutline) {
                                                *(pszBuf++) = '\r';
                                                *(pszBuf++) = '\n';
                                                *pszBuf = 0;
                                            }
                                        }

                                        GlobalUnlock(hData);
                                        SetClipboardData(CF_TEXT, hData);
                                    }
                                }
                            }
                            CloseClipboard();
                        }
                    }
                    break;

                case IDM_MARK:
                    {
                        BOOL bChanged = FALSE;
                        int i;

                        // toggle the mark on the current selection
                        // note that the selection could be multiple rows
                        for (i = 0; i < selection_nrows; i++) {

                            if (view_setmarkstate(current_view, selection + i,
                                                  !view_getmarkstate(current_view, selection + i))) {

                                bChanged = TRUE;
                            }
                        }

                        if (bChanged) {
                            // yes the mark state was changed - need
                            // to rebuild the view.
                            if (!view_isexpanded(current_view)) {
                                view_changeviewoptions(current_view);
                            }
                        }
                        break;
                    }

                case IDM_TOGGLEMARK:
                    // toggle the state of all files: unmark all
                    // marked files and vice versa
                    complist_togglemark(view_getcomplist(current_view));

                    // rebuild view
                    if (!view_isexpanded(current_view)) {
                        view_changeviewoptions(current_view);
                    }
                    break;

                case IDM_MARKPATTERN:
                    // dialog to query the pattern, then set a mark on
                    // all compitems whose title matches that pattern
                    // returns TRUE if anything was changed
                    if (complist_markpattern(view_getcomplist(current_view))) {

                        // rebuild view
                        if (!view_isexpanded(current_view)) {
                            view_changeviewoptions(current_view);
                        }
                    }
                    break;

                case IDM_EXPAND:

                    /* show the expanded view of the
                     * selected file
                     */
                    if (current_view != NULL) {
                        ToExpand(hWnd);
                    }

                    break;

                case IDM_OUTLINE:
                    /* return to the outline view (list of filenames) */
                    ToOutline(hWnd);

                    break;

                case IDM_FCHANGE:
                    /* find the next line in the current view
                     * that is not the same in both files -
                     * in outline view, finds the next filename that
                     * is not identical
                     */
                    FindNextChange();
                    break;

                case IDM_FPCHANGE:
                    /* same as IDM_FCHANGE, but going backwards from
                     * current position
                     */
                    FindPrevChange();
                    break;

                case IDM_FCHANGE_LAURIE:
                    /* same as IDM_FCHANGE, but tries to keep cursor on same
                     * line.
                     */
                    _FindNextChange(TRUE, FALSE);
                    break;

                case IDM_FPCHANGE_LAURIE:
                    /* same as IDM_FPCHANGE, but tries to keep cursor on same
                     * line.
                     */
                    _FindPrevChange(TRUE, FALSE);
                    break;

                    // given a line that has been moved, jump to the
                    // other representation of the same line.
                    // this used to be available just through double-click
                    // but now is also available from a context menu
                case IDM_TOMOVED:
                    ToMoved(hWnd, TRUE);
                    break;
            }
            break;

        case WM_SIZE:
            DoResize(hWnd);
            break;

        case WM_SETFOCUS:
            /* set the focus on the table class so it can process             
	     * page-up /pagedown keys etc.
             */
            SetFocus(hwndRCD);
            break;

        case WM_KEYDOWN:
            /* although the table window has the focus, he passes
             * back to us any keys he doesn't understand
             * We handle escape here to mean 'return to outline view'
             */
            if (wParam == VK_ESCAPE) {
                ToOutline(hWnd);

            } else if (wParam == VK_APPS) {
	      // Handle the context menu keyboard key

	      POINT posCursor;
	      GetCursorPos(&posCursor);
	      ScreenToClient(hwndRCD, &posCursor);
	      OnRightClick(hWnd, posCursor.x, posCursor.y);
	    }
            break;

	    
        case WM_RBUTTONDOWN:
            /*
             * the table window handles this by performing the
             * selection and then passing the message to us, allowing
             * us to put up a context menu.
             */
            OnRightClick(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CLOSE:
            /* experiment: DO close anyway */
            SendMessage(hWnd, WM_COMMAND, IDM_EXIT, 0);   /* brutal */
            return TRUE;

            /* don't allow close when busy - process this message in
             * order to ensure this
             */
            break;

        case WM_DESTROY:

            DeleteTools();
            WinHelp(hWnd, "windiff.hlp", HELP_QUIT, 0);
            PostQuitMessage(0);
            break;

        case TM_CURRENTVIEW:
            /* allow other people such as the bar window to query the
             * current view
             */
            return((INT_PTR) current_view);

#ifdef LATER
#ifdef WM_MOUSEWHEEL
        case WM_MOUSEWHEEL:
            if (LOWORD(wParam) & MK_MBUTTON) {
                if ((short)HIWORD(wParam) < 0) {
                    // The next occurence
                    _FindNextChange(FALSE, TRUE);
                }
                else {
                    _FindPrevChange(FALSE, TRUE);
                }
            }
            break;
#endif
#endif

        case WM_QUERYENDSESSION:
            if (IsBusy())
                return FALSE;
            return TRUE;

        case WM_ENDSESSION:
            SendMessage(hWnd, WM_CLOSE, 0, 0);
            break;

        default:
            /* handle registered table messages */
            if (message == table_msgcode) {
                ret = TableServer(hWnd, wParam, lParam);
                return(ret);
            }
            return(DefWindowProc(hWnd, message, wParam, lParam));
    }
    return(0);
}

/***************************************************************************
 * Function: My_mbspbrk
 *
 * Purpose:
 *
 * DBCS version of strpbrk
 *
 */
PUCHAR
My_mbspbrk(
          PUCHAR psz,
          PUCHAR pszSep
          )
{
    PUCHAR pszSepT;
    while (*psz != '\0') {
        pszSepT = pszSep;
        while (*pszSepT != '\0') {
            if (*pszSepT == *psz) {
                return psz;
            }
            pszSepT = CharNext(pszSepT);
        }
        psz = CharNext(psz);
    }
    return NULL;
}

/***************************************************************************
 * Function: My_mbsstr
 *
 * Purpose:
 *
 * DBCS version of strstr
 *
 */
PUCHAR
My_mbsstr(
         PUCHAR str1,
         PUCHAR str2,
         PUCHAR *pstrEnd
         )
{
  PUCHAR cp = (PUCHAR) str1;
  PUCHAR s1, s2;

  if (!*str2)
    return ((PUCHAR) str1);

  while (*cp)
    {
    s1 = cp;
    s2 = (PUCHAR) str2;

    while (*s1 && *s2)
      {
      if (*s1 - *s2)
        break;

      if (IsDBCSLeadByte(*s1) && (++(*s1) - ++(*s2)))
        break;

      s1++;
      s2++;
      }

    if (!*s2)
      {
      if (pstrEnd)
        *pstrEnd = s1;
      return cp;
      }

    cp = CharNext(cp);
    }

  return NULL;
}

/***************************************************************************
 * Function: My_mbsistr
 *
 * Purpose:
 *
 * DBCS version of case-independent strstr
 *
 */
PUCHAR
My_mbsistr(
          PUCHAR str1,
          PUCHAR str2,
          PUCHAR *pstrEnd
          )
{
  PUCHAR cp = (PUCHAR) str1;
  PUCHAR s1, s2;

  if (!*str2)
    return ((PUCHAR) str1);

  while (*cp)
    {
    s1 = cp;
    s2 = (PUCHAR) str2;

    while (*s1 && *s2)
      {
      if (IsDBCSLeadByte(*s1))
        {
        if ((*s1 - *s2) || (++(*s1) - ++(*s2)))
          break;
        }
      else if (toupper(*s1) - toupper(*s2))
        {
        break;
        }

      s1++;
      s2++;
      }

    if (!*s2)
      {
      if (pstrEnd)
        *pstrEnd = s1;
      return cp;
      }

    cp = CharNext(cp);
    }

  return NULL;
}

/***************************************************************************
 * Function: My_mbschr
 *
 * Purpose:
 *
 * DBCS version of strchr
 *
 */
LPSTR
My_mbschr(
          LPCSTR psz,
          unsigned short uiSep
          )
{
    while (*psz != '\0' && *psz != uiSep) {
        psz = CharNext(psz);
    }
    return (LPSTR)(*psz == uiSep ? psz : NULL);
}

/***************************************************************************
 * Function: My_mbsncpy
 *
 * Purpose:
 *
 * DBCS version of strncpy
 *
 */
LPSTR
My_mbsncpy(
           LPSTR psz1,
           LPCSTR psz2,
           size_t nLen
           )
{
    LPSTR pszSv = psz1;
    int Length = (int)nLen;

    while (0 < Length) {
        if (*psz2 == '\0') {
            *psz1++ = '\0';
            Length--;
        } else if (IsDBCSLeadByte(*psz2)) {
            if (Length == 1) {
                *psz1 = '\0';
            } else {
                *psz1++ = *psz2++;
                *psz1++ = *psz2++;
            }
            Length -= 2;
        } else {
            *psz1++ = *psz2++;
            Length--;
        }
    }
    return pszSv;
}

/***************************************************************************
 * Function: My_mbsrchr
 *
 * Purpose:
 *
 * DBCS version of strrchr
 *
 */
LPSTR
My_mbsrchr(
           LPCSTR psz,
           unsigned short uiSep
           )
{
    unsigned const char *pszHead;

    pszHead = psz;

    while (*psz != '\0') {
        psz++;
    }
    if (uiSep == '\0') {
        return (LPSTR)psz;
    }

    while (psz > pszHead) {
        psz = CharPrev(pszHead, psz);
        if (*psz == uiSep) {
            break;
        }
    }
    return (LPSTR)(*psz == uiSep ? psz : NULL);
}

/***************************************************************************
 * Function: My_mbsncmp
 *
 * Purpose:
 *
 * DBCS version of strncmp
 * If 'nLen' splits a DBC, this function compares the DBC's 2nd byte also.
 *
 */
int
My_mbsncmp(
           LPCSTR psz1,
           LPCSTR psz2,
           size_t nLen
           )
{
    int Length = (int)nLen;

    while (0 < Length) {
        if ('\0' == *psz1 || '\0' == *psz2) {
            return *psz1 - *psz2;
        }
        if (IsDBCSLeadByte(*psz1) || IsDBCSLeadByte(*psz2)) {
            if (*psz1 != *psz2 || *(psz1+1) != *(psz2+1)) {
                return *psz1 - *psz2;
            }
            psz1 += 2;
            psz2 += 2;
            Length -= 2;
        } else {
            if (*psz1 != *psz2) {
                return *psz1 - *psz2;
            }
            psz1++;
            psz2++;
            Length--;
        }
    }
    return 0;
}

/***************************************************************************
 * Function: My_mbsnicmp
 *
 * Purpose:
 *
 * DBCS version of strncmp
 * If 'nLen' splits a DBC, this function compares the DBC's 2nd byte also.
 *
 */
int
My_mbsnicmp(
           PUCHAR psz1,
           PUCHAR psz2,
           size_t nLen
           )
{
    int Length = (int)nLen;

    while (0 < Length) {
        if ('\0' == *psz1 || '\0' == *psz2) {
            return *psz1 - *psz2;
        }
        if (IsDBCSLeadByte(*psz1) || IsDBCSLeadByte(*psz2)) {
            if (*psz1 != *psz2 || *(psz1+1) != *(psz2+1)) {
                return *psz1 - *psz2;
            }
            psz1 += 2;
            psz2 += 2;
            Length -= 2;
        } else {
            if (toupper(*psz1) != toupper(*psz2)) {
                return *psz1 - *psz2;
            }
            psz1++;
            psz2++;
            Length--;
        }
    }
    return 0;
}

/***************************************************************************
 * Function: LoadRcString
 *
 * Purpose: Loads a resource string from string table and returns a pointer
 *          to the string.
 *
 * Parameters: wID - resource string id
 *
 */

LPTSTR
APIENTRY
LoadRcString(
             UINT wID
             )
{
    static TCHAR szBuf[512];

    LoadString((HANDLE)GetModuleHandle(NULL),wID,szBuf,sizeof(szBuf));
    return szBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\dbg.h ===
/*
 * Debugging utilities header
 */
#if DBG

extern char szAsrtFmt[];
extern unsigned long BreakFlags;
extern unsigned long TraceFlags;

ULONG __cdecl DbgPrint( LPSTR Format, ...);
VOID DbgAssert(LPSTR file, int line);
VOID DbgTrace(DWORD tf, LPSTR lpstr);
VOID DbgBreak(DWORD bf, LPSTR file, int line);
VOID DbgPrint1(DWORD tf, LPSTR fmt, LPSTR p1);
VOID DbgEnter(LPSTR funName);
VOID DbgLeave(LPSTR funName);
VOID DbgTraceMessage(LPSTR funName, LPSTR msgName);
VOID DbgTraceDefMessage(LPSTR funName, WORD msgId);

// BreakFlags flags

#define BF_WM_CREATE            0x02000000
#define BF_DEFMSGTRACE          0x04000000
#define BF_MSGTRACE             0x08000000

#define BF_PARMTRACE            0x20000000
#define BF_PROCTRACE            0x40000000
#define BF_START                0x80000000

#undef ASSERT
#define ASSERT(fOk)             ((!(fOk)) ? DbgAssert(__FILE__, __LINE__) : ((void)0))
#define FBREAK(bf)              DbgBreak(bf, __FILE__, __LINE__)
#define TRACE(tf, lpstr)        DbgTrace(tf, lpstr)
#define PRINT(tf, fmt, p1)      DbgPrint1(tf, fmt, (LPSTR)(p1))
#define MSG(funName, msgName)   DbgTraceMessage(funName, msgName)
#define DEFMSG(funName, wMsgId) DbgTraceDefMessage(funName, wMsgId)

#define ENTER(funName)          DbgEnter(funName)
#define LEAVE(funName)          DbgLeave(funName)


#else // !DBG

#ifndef ASSERT
#define ASSERT(fOk)             ((void)0)
#endif

#define FBREAK(bf)
#define TRACE(tf, lpstr)
#define PRINT(tf, fmt, p1)
#define MSG(funName, msgName)
#define DEFMSG(funName, wMsgId)
#define ENTER(funName)
#define LEAVE(funName)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\windiff.h ===
/*

 * windiff - file and directory comparisons
 *              FOR INTRODUCTORY NOTES ON IMPLEMENTATION SEE WINDIFF.C
 *
 *      windiff.h - user-interface definitions, and application-wide global
 *                  declarations.
 */

/* application-wide variables -------------------------------------*/

/* this is the section name in the win.ini file to which we
 * write profile info
 */
#define APPNAME szWinDiff
extern const CHAR szWinDiff[];

/* Map profile calls to the registry
 */
#include "profile.h"

/* a gmem_init() heap shared by the app. call gmem_get to alloc. */
extern HANDLE hHeap;

/* the instance handle for this app. needed by anyone who uses resources
 * such as dialogs
 */
extern HINSTANCE hInst;

extern HWND hwndClient;
extern HWND hwndRCD;

/* global option flags-------------------------------------------  */

/* which files do we show in outline mode ? all, changed... */
extern int outline_include;

/* which files do we show in expand mode ? all, different, moved... */
extern int expand_include;

/* outline_include is an OR of the following */
#define INCLUDE_SAME            0x01
#define INCLUDE_DIFFER          0x02
#define INCLUDE_LEFTONLY        0x04
#define INCLUDE_RIGHTONLY       0x08

/* expand_include is an OR of the previous (except for INCLUDE_DIFFER)
   AND the following */
#define INCLUDE_MOVEDLEFT       0x10
#define INCLUDE_MOVEDRIGHT      0x20
#define INCLUDE_SIMILARLEFT     0x40
#define INCLUDE_SIMILARRIGHT    0x80

/* bitwise OR of all flags */
#define INCLUDE_ALL             0xFF

/* do we ignore blanks during the line-by-line diff ? */
extern BOOL ignore_blanks;

/* do we show whitespace characters ? */
extern BOOL show_whitespace;

/* which line numbers do we show - left original, right original or none ?*/
extern int line_numbers;

/* what lines do we show in expand mode - all, left only, right only ? */
extern int expand_mode;

/* TRUE if marked compitems are to be excluded from the view */
extern BOOL hide_markedfiles;


// tab expansion width in characters
extern int g_tabwidth;

extern BOOL TrackLeftOnly;
extern BOOL TrackRightOnly;
extern BOOL TrackDifferent;
extern BOOL TrackSame;
extern BOOL TrackReadonly;
extern BOOL TrackSlmFiles;

/*--- colour scheme ----------------------------------------------  */

/* outline */
extern DWORD rgb_outlinehi;

/* expand view */
extern DWORD rgb_leftfore;
extern DWORD rgb_leftback;
extern DWORD rgb_rightfore;
extern DWORD rgb_rightback;
extern DWORD rgb_mleftfore;
extern DWORD rgb_mleftback;
extern DWORD rgb_mrightfore;
extern DWORD rgb_mrightback;

/* bar window */
extern DWORD rgb_barleft;
extern DWORD rgb_barright;
extern DWORD rgb_barcurrent;

extern BOOL bJapan;  /* TRUE if primary language is Japanese */
extern BOOL bDBCS;   /* TRUE if primary language is Japanese/Korean/Chinese */

/* -- display layout constants---------------------------------------*/

/* percentage of width of window taken by bar display (when visible) */
#define BAR_WIN_WIDTH   10

/* following are horizontal positions within the bar window, expressed
 * in percent of the width of the bar window
 */
#define L_POS_START     10      /* start of left position marker */
#define L_POS_WIDTH     5       /* width of left position marker */
#define R_POS_START     80      /* start of right position marker */
#define R_POS_WIDTH     5       /* width of right position marker */

#define L_UNMATCH_START 30      /* start of left bar for unmatched section */
#define L_UNMATCH_WIDTH 10      /* width of above */
#define R_UNMATCH_START 60      /* start of right bar for unmatch section */
#define R_UNMATCH_WIDTH 10      /* width of right unmatched section marker */
#define L_MATCH_START   30      /* start of left bar for matched section */
#define L_MATCH_WIDTH   10      /* width of left bar for matched section */
#define R_MATCH_START   60      /* start of right bar for matched section */
#define R_MATCH_WIDTH   10      /* width of right bar for matched section */




/* windiff.c functions */

#ifdef trace
void APIENTRY Trace_File(LPSTR msg);     /* dump msg into Windiff.trc */
#endif


/* if you are about to put up a dialog box or in fact process input in any way
   on any thread other than the main thread - or if you MIGHT be on a thread other
   than the main thread, then you must call this function with TRUE before doing
   it and with FALSE immediately afterwards.  Otherwise you will get one of a
   number of flavours of not-very-responsiveness
*/
void windiff_UI(BOOL bAttach);

/* peek the message queue. return TRUE if an abort request is pending */
BOOL Poll(void);                /* true if abort pending */

/* set the text for the 'names' field (central box) on the status bar */
void SetNames(LPSTR names);

/* set the status field (left field) on the status bar */
void SetStatus(LPSTR state);

/* dlg procs */
int FAR PASCAL FindDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
int FAR PASCAL GoToLineDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/* in bar.c */
BOOL InitBarClass(HINSTANCE hInstance);
void BarDrawPosition(HWND hwndBar, HDC hdcIn, BOOL bErase);

/*-- private messages -- */

/* send this to the main window. return value is the VIEW handle */
#define TM_CURRENTVIEW  WM_USER


/* --- synchronisation ----------------------------------------- */

/*
 * the WIN32 version spawns worker threads to do time-consuming actions.
 * this causes a possible conflict with the UI thread when accessing the
 * BUSY flag.
 *
 * to protect against this we have a critical section. The UI thread
 * will get this before checking/changing the Busy flag,
 * The worker thread will get this before Busy flag* changes.
 *
 */

CRITICAL_SECTION CSWindiff;
/* IF EVER YOU MIGHT ACQUIRE BOTH CSWindiff AND CSView, THEN DO SO IN
   THE ORDER:  FIRST GET CSWindiff  THEN GET CSView
   else risk deadlock when an idm_exit happens!
*/
#define WDEnter()       EnterCriticalSection(&CSWindiff);
#define WDLeave()       LeaveCriticalSection(&CSWindiff);

BOOL __BERR;

#define TRACE_ERROR(msg,flag) ( windiff_UI(TRUE),                      \
                                __BERR = Trace_Error(hwndClient, msg, flag),       \
                                windiff_UI(FALSE),                     \
                                __BERR                                 \
                              )

__inline BOOL IsDepotPath(LPCSTR path)
{
    return path[0] == '/' && path[1] == '/';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\dlg.h ===
#define IDD_OBJATTRS    6000

#define IDS_NAME        6010
#define IDS_TYPE        6001
#define IDS_OTHERLABEL  6011
#define IDS_OTHERTEXT   6012

#define IDCB_INHERIT    6002
#define IDCB_PERMANENT  6003
#define IDCB_EXCLUSIVE  6004

#define IDS_PAGEDCHARGE    6005
#define IDS_NONPAGEDCHARGE 6006

#define IDS_COUNT           6100
#define IDS_HANDLES         6101
#define IDS_TOTALHANDLES    6102
#define IDS_POINTERS        6103
#define IDS_TOTALPOINTERS   6104
#define IDS_CREATIONTIME    6105
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\dbg.c ===
/*
 * Debugging utilities
 */

#if DBG

    #include <winfile.h>

char szAsrtFmt[] = "Assertion Failure in %s at %d";
unsigned long TraceFlags = 0
                           // | BF_START
                           // | BF_PROCTRACE
                           // | BF_PARMTRACE
                           // | BF_MSGTRACE
                           // | BF_DEFMSGTRACE
                           ;     // set these to print on TRACEs

unsigned long BreakFlags = 0
                           // | BF_START
                           ;     // set these to break on TRACEs

VOID
DbgAssert(
         LPSTR file,
         int line
         )
{
    DbgPrint(szAsrtFmt, file, line);
    DebugBreak();
}


VOID
DbgTrace(
        DWORD tf,
        LPSTR lpstr
        )
{
    if (tf & TraceFlags) {
        DbgPrint("%s\n", lpstr);
        if (tf & BreakFlags) {
            DebugBreak();
        }
    }
}


VOID
DbgBreak(
        DWORD bf,
        LPSTR file,
        int line
        )

{
    if (bf & BreakFlags) {
        DbgPrint("BREAK at %s:%d\n", file, line);
        DebugBreak();
    }
}


VOID
DbgPrint1(
         DWORD tf,
         LPSTR fmt,
         LPSTR p1
         )
{
    if (tf & TraceFlags) {
        DbgPrint(fmt, p1);
        DbgPrint("\n");
    }
    if (tf & BreakFlags) {
        DebugBreak();
    }
}


VOID
DbgEnter(
        LPSTR funName
        )
{
    DbgPrint1(BF_PROCTRACE, "> %s", funName);
}

VOID
DbgLeave(
        LPSTR funName
        )
{
    DbgPrint1(BF_PROCTRACE, " <%s", funName);
}


VOID
DbgTraceMessage(
               LPSTR funName,
               LPSTR msgName
               )
{
    if (BF_MSGTRACE & TraceFlags) {
        DbgPrint("MSG: %s - %s\n", funName, msgName);
    }
    if (BF_MSGTRACE & BreakFlags) {
        DebugBreak();
    }
}

VOID
DbgTraceDefMessage(
                  LPSTR funName,
                  WORD msgId
                  )
{
    if (BF_DEFMSGTRACE & TraceFlags) {
        DbgPrint("MSG: %s - default(0x%x)\n", funName, msgId);
    }
    if (BF_DEFMSGTRACE & BreakFlags) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\fontsel.c ===
#include "windows.h"
#include <port1632.h>
#include "fontsel.h"

#define TA_LOWERCASE	0x01	// taken from winfile.h!
#define TA_BOLD		0x02
#define TA_ITALIC	0x04

extern HANDLE hAppInstance;
extern BOOL wTextAttribs;
extern HWND hwndFrame;
extern WORD wHelpMessage;

typedef struct {
    HWND hwndLB;
    HDC hdc;
} ENUM_FONT_DATA, *LPENUM_FONT_DATA;


INT APIENTRY FontSizeEnumProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD nFontType, LPARAM lpData);
INT APIENTRY FontFaceEnumProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD nFontType, LPARAM lpData);
INT_PTR APIENTRY FontDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

INT  APIENTRY GetHeightFromPointsString(LPSTR sz);
VOID  APIENTRY WFHelp(HWND hwnd);


BOOL
APIENTRY
MyChooseFont(
            LPMYCHOOSEFONT lpcf
            )
{
    INT_PTR ret;

    ret = DialogBoxParam(hAppInstance, MAKEINTRESOURCE(FONTDLG), lpcf->hwndOwner, FontDlgProc, (LPARAM)lpcf);

    return ret == IDOK;
}

INT
APIENTRY
FontFaceEnumProc(
                const LOGFONT *lplf,
                const TEXTMETRIC *lptm,
                DWORD nFontType,
                LPARAM lParam
                )
{
    LPENUM_FONT_DATA lpData = (LPENUM_FONT_DATA) lParam;

    if (lplf->lfCharSet == ANSI_CHARSET) {
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)lplf->lfFaceName);
    }
    return TRUE;
}

LPSTR
NEAR
PASCAL
GetPointString(
              LPSTR buf,
              HDC hdc,
              INT height
              )
{
    wsprintf(buf, "%d", MulDiv((height < 0) ? -height : height, 72, GetDeviceCaps(hdc, LOGPIXELSY)));

    return buf;
}

INT
APIENTRY
FontSizeEnumProc(
                const LOGFONT *lplf,
                const TEXTMETRIC *lptm,
                DWORD nFontType,
                LPARAM lParam
                )
{
    INT height;
    CHAR buf[20];
    LPENUM_FONT_DATA lpData = (LPENUM_FONT_DATA) lParam;

    if (!(nFontType & RASTER_FONTTYPE)) {
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"6");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"8");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"10");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"12");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"14");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"18");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"24");
    } else {
        height = lptm->tmHeight - lptm->tmInternalLeading;
        GetPointString(buf, lpData->hdc, height);
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)buf);
    }

    return TRUE;
}


VOID
NEAR
PASCAL
EnumFontSizes(
             HWND hDlg,
             HDC hdc,
             LPSTR szFace,
             INT height
             )
{
    ENUM_FONT_DATA data;
    CHAR szTemp[10];

    SendDlgItemMessage(hDlg, IDD_PTSIZE, CB_RESETCONTENT, 0, 0L);

    data.hwndLB = GetDlgItem(hDlg, IDD_PTSIZE);
    data.hdc = hdc;

    EnumFonts(hdc, szFace, FontSizeEnumProc, (LPARAM)&data);

    GetPointString(szTemp, hdc, height);
    if ((INT)SendDlgItemMessage(hDlg, IDD_PTSIZE, CB_SELECTSTRING, -1, (LPARAM)szTemp) < 0)
        SendDlgItemMessage(hDlg, IDD_PTSIZE, CB_SETCURSEL, 0, 0L);

}



// needs to be exported of course

INT_PTR
APIENTRY
FontDlgProc(
           HWND hDlg,
           UINT wMsg,
           WPARAM wParam,
           LPARAM lParam
           )
{
    LOGFONT lf;
    ENUM_FONT_DATA data;
    HDC hdc;
    CHAR szTemp[80];
    INT sel;
    static LPMYCHOOSEFONT lpcf;

    switch (wMsg) {
        case WM_INITDIALOG:

            lpcf = (LPMYCHOOSEFONT)lParam;

            hdc = GetDC(NULL);  // screen fonts

            data.hwndLB = GetDlgItem(hDlg, IDD_FACE);
            data.hdc = hdc;

            EnumFonts(hdc, NULL, FontFaceEnumProc, (LPARAM)&data);

            sel = (INT)SendDlgItemMessage(hDlg, IDD_FACE, CB_SELECTSTRING, -1, (LPARAM)(lpcf->lpLogFont)->lfFaceName);
            if (sel < 0) {
                SendDlgItemMessage(hDlg, IDD_FACE, CB_SETCURSEL, 0, 0L);
                sel = 0;
            }

            GetDlgItemText(hDlg, IDD_FACE, szTemp, sizeof(szTemp));

            EnumFontSizes(hDlg, hdc, szTemp, lpcf->lpLogFont->lfHeight);

            ReleaseDC(NULL, hdc);

            CheckDlgButton(hDlg, IDD_ITALIC, lpcf->lpLogFont->lfItalic);
            CheckDlgButton(hDlg, IDD_BOLD, (WORD)(lpcf->lpLogFont->lfWeight > 500));
            CheckDlgButton(hDlg, IDD_LOWERCASE, (WORD)(wTextAttribs & TA_LOWERCASE));

            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDD_FACE:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                        case CBN_SELCHANGE:
                            GetDlgItemText(hDlg, IDD_FACE, szTemp, sizeof(szTemp));

                            hdc = GetDC(NULL);  // screen fonts
                            EnumFontSizes(hDlg, hdc, szTemp, lpcf->lpLogFont->lfHeight);
                            ReleaseDC(NULL, hdc);
                            break;
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    if (IsDlgButtonChecked(hDlg, IDD_LOWERCASE))
                        wTextAttribs |= TA_LOWERCASE;
                    else
                        wTextAttribs &= ~TA_LOWERCASE;

                    if (IsDlgButtonChecked(hDlg, IDD_ITALIC))
                        wTextAttribs |= TA_ITALIC;
                    else
                        wTextAttribs &= ~TA_ITALIC;

                    if (IsDlgButtonChecked(hDlg, IDD_BOLD))
                        wTextAttribs |= TA_BOLD;
                    else
                        wTextAttribs &= ~TA_BOLD;

                    GetDlgItemText(hDlg, IDD_FACE, (LPSTR)lf.lfFaceName, sizeof(lf.lfFaceName));

                    GetDlgItemText(hDlg, IDD_PTSIZE, szTemp, sizeof(szTemp));
                    lf.lfHeight = (SHORT)GetHeightFromPointsString(szTemp);
                    lf.lfWeight = (SHORT)(IsDlgButtonChecked(hDlg, IDD_BOLD) ? 800 : 400);
                    lf.lfItalic = (BYTE)IsDlgButtonChecked(hDlg, IDD_ITALIC);
                    lf.lfWidth = 0;
                    lf.lfEscapement = 0;
                    lf.lfOrientation = 0;
                    lf.lfUnderline = 0;
                    lf.lfStrikeOut = 0;
                    lf.lfCharSet = ANSI_CHARSET;
                    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
                    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
                    lf.lfQuality = DEFAULT_QUALITY;
                    lf.lfPitchAndFamily = DEFAULT_PITCH;

                    *(lpcf->lpLogFont) = lf;

                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\fontsel.h ===
typedef struct _MYCHOOSEFONT {
	HWND		hwndOwner;
	HDC		hdc;
	LPLOGFONT 	lpLogFont;
	DWORD		Flags;
	FARPROC		lpfnHook;
} MYCHOOSEFONT, FAR *LPMYCHOOSEFONT;

#define MYCF_SCREENFONTS	0x00000001L
#define MYCF_PRINTERFONTS	0x00000002L
#define MYCF_BOTH		(MYCF_MYCF_SCREENFONTS | MYCF_PRINTERFONTS)

BOOL  APIENTRY MyChooseFont(LPMYCHOOSEFONT lpcf);

//---------------------- private ----------------------------

#define IDD_FACE	100
#define IDD_PTSIZE	101
#define IDD_WEIGHT	102
#define IDD_TREATMENT	103
#define IDD_BOLD	104
#define IDD_ITALIC	105
#define IDD_LOWERCASE	106
#define IDD_HELP	254

#define FONTDLG			145
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\dosfunc.h ===
/* docfunc.h
 *
 *  declares dos functions used by file manager
 */

BOOL   APIENTRY DosFindFirst(LPDOSDTA, LPSTR, WORD);
BOOL   APIENTRY DosFindNext(LPDOSDTA);
BOOL   APIENTRY DosDelete(LPSTR);
//WORD   APIENTRY GetFileAttributes(LPSTR);
//WORD   APIENTRY SetFileAttributes(LPSTR, WORD);
DWORD  APIENTRY GetFreeDiskSpace(WORD);
DWORD  APIENTRY GetTotalDiskSpace(WORD);
INT    APIENTRY GetVolumeLabel(INT, LPSTR, BOOL);
INT    APIENTRY MySetVolumeLabel(INT, BOOL, LPSTR);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\object.h ===
VOID DisplayObjectInformation(HWND hwndParent, LPSTR lpstrObject);
LONG CalcAttributes(PUNICODE_STRING);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\object.c ===
/* object.c -
 *
 * Handles display of object attributes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>

#include "winfile.h"
#include "object.h"

INT_PTR APIENTRY ObjectAttributesDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL    ObjectInformationDlgInit(HWND, LPSTR);
HANDLE  OpenObject(HWND, LPSTR);
BOOL    GetObjectInfo(HWND, HANDLE);
VOID    CloseObject(HANDLE);

VOID    StripObjectPath(LPSTR lpszPath);
VOID    StripObjectSpec(LPSTR lpszPath);


// Define known object type names

#define DIRECTORYTYPE   L"Directory"
#define SYMLINKTYPE     L"SymbolicLink"
#define ADAPTERTYPE     L"Adapter"
#define CONTROLLERTYPE  L"Controller"
#define DEVICETYPE      L"Device"
#define DRIVERTYPE      L"Driver"
#define EVENTTYPE       L"Event"
#define EVENTPAIRTYPE   L"EventPair"
#define FILETYPE        L"File"
#define MUTANTTYPE      L"Mutant"
#define PORTTYPE        L"Port"
#define PROFILETYPE     L"Profile"
#define SECTIONTYPE     L"Section"
#define SEMAPHORETYPE   L"Semaphore"
#define TIMERTYPE       L"Timer"
#define TYPETYPE        L"Type"
#define PROCESSTYPE     L"Process"



VOID
DisplayObjectInformation(
                        HWND    hwndParent,
                        LPSTR   lpstrObject
                        )
{
    WNDPROC lpProc;
    HANDLE  hInst = hAppInstance;

    DialogBoxParam(hInst,(LPSTR)IDD_OBJATTRS, hwndParent, ObjectAttributesDlgProc, (LPARAM)lpstrObject);
}


INT_PTR
APIENTRY
ObjectAttributesDlgProc(
                       HWND hDlg,
                       UINT message,
                       WPARAM wParam,
                       LPARAM lParam
                       )
{
    switch (message) {

        case WM_INITDIALOG:

            if (!ObjectInformationDlgInit(hDlg, (HANDLE)lParam)) {
                // Failed to initialize dialog, get out
                EndDialog(hDlg, FALSE);
            }

            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    // we're done, drop through to quit dialog....

                case IDCANCEL:

                    //MainDlgEnd(hDlg, LOWORD(wParam) == IDOK);

                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;
}



BOOL
ObjectInformationDlgInit(
                        HWND    hwnd,
                        LPSTR   lpstrObject
                        )
{
    HANDLE      ObjectHandle;
    BOOL        Result;

    ObjectHandle = OpenObject(hwnd, lpstrObject);
    if (ObjectHandle == NULL) {
        return(FALSE);
    }

    Result = GetObjectInfo(hwnd, ObjectHandle);

    CloseObject(ObjectHandle);

    return(Result);
}


/* Open the object given only its name.
 * First find the object type by enumerating the directory entries.
 * Then call the type-specific open routine to get a handle
 */
HANDLE
OpenObject(
          HWND    hwnd,
          LPSTR   lpstrObject
          )
{
#define BUFFER_SIZE 1024

    NTSTATUS    Status;
    HANDLE      DirectoryHandle;
    ULONG       Context = 0;
    ULONG       ReturnedLength;
    CHAR        Buffer[BUFFER_SIZE];
    ANSI_STRING AnsiString;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR       ObjectNameBuf[MAX_PATH];
    UNICODE_STRING ObjectName;
    WCHAR       ObjectTypeBuf[MAX_PATH];
    UNICODE_STRING ObjectType;
    HANDLE      ObjectHandle;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING DirectoryName;
    IO_STATUS_BLOCK IOStatusBlock;

    //DbgPrint("Open object: raw full name = <%s>\n", lpstrObject);

    // Remove drive letter
    while ((*lpstrObject != 0) && (*lpstrObject != '\\')) {
        lpstrObject ++;
    }

    //DbgPrint("Open object: full name = <%s>\n", lpstrObject);

    // Initialize the object type buffer
    ObjectType.Buffer = ObjectTypeBuf;
    ObjectType.MaximumLength = sizeof(ObjectTypeBuf);

    // Initialize the object name string
    strcpy(Buffer, lpstrObject);
    StripObjectPath(Buffer);
    RtlInitAnsiString(&AnsiString, Buffer);

    ObjectName.Buffer = ObjectNameBuf;
    ObjectName.MaximumLength = sizeof(ObjectNameBuf);

    Status = RtlAnsiStringToUnicodeString(&ObjectName, &AnsiString, FALSE);
    ASSERT(NT_SUCCESS(Status));

    //DbgPrint("Open object: name only = <%wZ>\n", &ObjectName);

    //
    //  Open the directory for list directory access
    //

    strcpy(Buffer, lpstrObject);
    StripObjectSpec(Buffer);

    RtlInitAnsiString(&AnsiString, Buffer);
    Status = RtlAnsiStringToUnicodeString( &DirectoryName, &AnsiString, TRUE);
    ASSERT(NT_SUCCESS(Status));

    InitializeObjectAttributes( &Attributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //DbgPrint("Open object: dir only = <%wZ>\n", &DirectoryName);

    if (!NT_SUCCESS( Status = NtOpenDirectoryObject( &DirectoryHandle,
                                                     STANDARD_RIGHTS_READ |
                                                     DIRECTORY_QUERY |
                                                     DIRECTORY_TRAVERSE,
                                                     &Attributes ) )) {

        if (Status == STATUS_OBJECT_TYPE_MISMATCH) {
            DbgPrint( "%wZ is not a valid Object Directory Object name\n",
                      &DirectoryName );
        } else {
            DbgPrint("OpenObject: failed to open directory, status = 0x%lx\n\r", Status);
        }

        RtlFreeUnicodeString(&DirectoryName);

        MessageBox(hwnd, "Unable to open object", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        return NULL;
    }

    RtlFreeUnicodeString(&DirectoryName);


    //
    //  Query the entire directory in one sweep
    //
    ObjectType.Length = 0;

    for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                          Buffer,
                                          sizeof(Buffer),
                                          // LATER FALSE,
                                          TRUE, // one entry at a time for now
                                          TRUE,
                                          &Context,
                                          &ReturnedLength );
        ObjectType.Length == 0;
        Status = NtQueryDirectoryObject( DirectoryHandle,
                                         Buffer,
                                         sizeof(Buffer),
                                         // LATER FALSE,
                                         TRUE, // one entry at a time for now
                                         FALSE,
                                         &Context,
                                         &ReturnedLength ) ) {
        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status != STATUS_NO_MORE_ENTRIES) {
                DbgPrint("OpenObject: failed to query directory object, status = 0x%lx\n\r", Status);
            }
            break;
        }

        //
        //  For every record in the buffer compare name with the one we're
        // looking for
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

        while (DirInfo->Name.Length != 0) {

            //
            //  Compare with object we're searching for
            //

            //DbgPrint("Found object <%wZ>\n", &(DirInfo->Name));

            if (RtlEqualString((PSTRING)&ObjectName, (PSTRING)&(DirInfo->Name), TRUE)) {
                RtlCopyString((PSTRING)&ObjectType, (PSTRING)&DirInfo->TypeName);
                break;
            }

            //
            //  Advance DirInfo to the next entry
            //

            DirInfo ++;
        }
    }

    if (ObjectType.Length == 0) {
        DbgPrint("Object not found in directory\n\r");
        MessageBox(hwnd, "Unable to open object", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        return(NULL);
    }

    // We now have the type of the object in ObjectType
    // We still have the full object name in lpstrObject
    // Use the appropriate open routine to get a handle

    ObjectHandle = NULL;

    RtlInitString(&AnsiString, lpstrObject);
    Status = RtlAnsiStringToUnicodeString(&ObjectName, &AnsiString, TRUE);
    ASSERT(NT_SUCCESS(Status));

    InitializeObjectAttributes(&Attributes,
                               &ObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    switch (CalcAttributes(&ObjectType)) {

        case ATTR_SYMLINK:
            Status = NtOpenSymbolicLinkObject(&ObjectHandle,
                                              READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                              &Attributes);
            break;

        case ATTR_EVENT:
            Status = NtOpenEvent(&ObjectHandle,
                                 READ_CONTROL,
                                 &Attributes);
            break;

        case ATTR_EVENTPAIR:
            Status = NtOpenEventPair(&ObjectHandle,
                                     READ_CONTROL,
                                     &Attributes);
            break;

        case ATTR_FILE:
            Status = NtOpenFile(&ObjectHandle,
                                READ_CONTROL,
                                &Attributes,
                                &IOStatusBlock,
                                FILE_SHARE_VALID_FLAGS,
                                0);
            break;

        case ATTR_MUTANT:
            Status = NtOpenMutant(&ObjectHandle,
                                  READ_CONTROL,
                                  &Attributes);
            break;

        case ATTR_SECTION:
            Status = NtOpenSection(&ObjectHandle,
                                   READ_CONTROL,
                                   &Attributes);
            break;

        case ATTR_SEMAPHORE:
            Status = NtOpenSemaphore(&ObjectHandle,
                                     READ_CONTROL,
                                     &Attributes);
            break;

        case ATTR_TIMER:
            Status = NtOpenTimer(&ObjectHandle,
                                 READ_CONTROL,
                                 &Attributes);
            break;

        case ATTR_PROCESS:
            Status = NtOpenProcess(&ObjectHandle,
                                   READ_CONTROL,
                                   &Attributes,
                                   NULL);
            break;

        default:
            DbgPrint("No open routine for this object type\n\r");
            MessageBox(hwnd, "I don't know how to open an object of this type", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
            Status = 0;
            break;
    }

    if (!NT_SUCCESS(Status)) {
        DbgPrint("Type specific open failed, status = 0x%lx\n\r", Status);
        MessageBox(hwnd, "Object open failed", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        ObjectHandle = NULL;
    }

    RtlFreeUnicodeString(&ObjectName);

    return(ObjectHandle);
}


VOID
CloseObject(
           HANDLE  ObjectHandle
           )
{
    NtClose(ObjectHandle);
}


BOOL
GetObjectInfo(
             HWND    hwnd,
             HANDLE  ObjectHandle
             )
{
    NTSTATUS    Status;
    OBJECT_BASIC_INFORMATION    BasicInfo;
    OBJECT_TYPE_INFORMATION    TypeInfo;
    WCHAR TypeName[ 64 ];
#define BUFFER_SIZE 1024
    CHAR        Buffer[BUFFER_SIZE];
    STRING      String;
    TIME_FIELDS TimeFields;
    WCHAR       UnicodeBuffer[BUFFER_SIZE];
    UNICODE_STRING UnicodeString;

    //
    // Name
    //

    Status = NtQueryObject(ObjectHandle, ObjectNameInformation,
                           (PVOID)Buffer, sizeof(Buffer), NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("GetObjectInfo: Failed to get name info, status = 0x%lx\n\r", Status);
        return(FALSE);
    }

    Status = RtlUnicodeStringToAnsiString(&String, &(((POBJECT_NAME_INFORMATION)Buffer)->Name), TRUE);
    ASSERT(NT_SUCCESS(Status));

    SetDlgItemText(hwnd, IDS_NAME, String.Buffer);

    RtlFreeAnsiString(&String);


    //
    // Type
    //

    Status = NtQueryObject(ObjectHandle, ObjectTypeInformation,
                           (PVOID)Buffer, sizeof(Buffer), NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("GetObjectInfo: Failed to get type info, status = 0x%lx\n\r", Status);
        return(FALSE);
    }

    Status = RtlUnicodeStringToAnsiString(&String, &(((POBJECT_TYPE_INFORMATION)Buffer)->TypeName), TRUE);
    ASSERT(NT_SUCCESS(Status));

    SetDlgItemText(hwnd, IDS_TYPE, String.Buffer);

    RtlFreeAnsiString(&String);


    //
    // Symbolic link target if this is a symlink
    //

    RtlInitUnicodeString(&UnicodeString, SYMLINKTYPE);

    if (RtlEqualString((PSTRING)&UnicodeString,
                       (PSTRING)&(((POBJECT_TYPE_INFORMATION)Buffer)->TypeName), TRUE)) {

        ShowWindow(GetDlgItem(hwnd, IDS_OTHERLABEL), SW_SHOWNOACTIVATE);
        ShowWindow(GetDlgItem(hwnd, IDS_OTHERTEXT), SW_SHOWNOACTIVATE);

        UnicodeString.Buffer = UnicodeBuffer;
        UnicodeString.MaximumLength = sizeof(UnicodeBuffer);

        Status = NtQuerySymbolicLinkObject(ObjectHandle, &UnicodeString, NULL);

        if (!NT_SUCCESS(Status)) {
            DbgPrint("GetObjectInfo: Failed to query symbolic link target, status = 0x%lx\n\r", Status);
            return(FALSE);
        }

        RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);

        SetDlgItemText(hwnd, IDS_OTHERTEXT, String.Buffer);

        RtlFreeAnsiString(&String);
    }


    //
    // Basic info
    //

    Status = NtQueryObject(ObjectHandle, ObjectBasicInformation,
                           (PVOID)&BasicInfo, sizeof(BasicInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("GetObjectInfo: Failed to get basic info, status = 0x%lx\n\r", Status);
        return(FALSE);
    }

    TypeInfo.TypeName.Buffer = TypeName;
    TypeInfo.TypeName.MaximumLength = sizeof( TypeName );
    Status = NtQueryObject(ObjectHandle, ObjectTypeInformation,
                           (PVOID)&TypeInfo, sizeof(TypeInfo) + TypeInfo.TypeName.MaximumLength, NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("GetObjectInfo: Failed to get type info, status = 0x%lx\n\r", Status);
        return(FALSE);
    }

    CheckDlgButton(hwnd, IDCB_INHERIT, (BasicInfo.Attributes & OBJ_INHERIT) != 0);
    CheckDlgButton(hwnd, IDCB_PERMANENT, (BasicInfo.Attributes & OBJ_PERMANENT) != 0);
    CheckDlgButton(hwnd, IDCB_EXCLUSIVE, (BasicInfo.Attributes & OBJ_EXCLUSIVE) != 0);

    SetDlgItemInt(hwnd, IDS_PAGEDCHARGE, BasicInfo.PagedPoolCharge, FALSE);
    SetDlgItemInt(hwnd, IDS_NONPAGEDCHARGE, BasicInfo.NonPagedPoolCharge, FALSE);
    SetDlgItemInt(hwnd, IDS_HANDLES, BasicInfo.HandleCount, FALSE);
    SetDlgItemInt(hwnd, IDS_TOTALHANDLES, TypeInfo.TotalNumberOfHandles, FALSE);
    SetDlgItemInt(hwnd, IDS_POINTERS, BasicInfo.PointerCount, FALSE);
    SetDlgItemInt(hwnd, IDS_TOTALPOINTERS, 0, FALSE);
    SetDlgItemInt(hwnd, IDS_COUNT, TypeInfo.TotalNumberOfObjects, FALSE);

    RtlTimeToTimeFields(&BasicInfo.CreationTime, &TimeFields);

    sprintf(Buffer, "%hd/%hd/%hd @ %02hd:%02hd:%02hd",
            TimeFields.Year, TimeFields.Month, TimeFields.Day,
            TimeFields.Hour, TimeFields.Minute, TimeFields.Second);

    SetDlgItemText(hwnd, IDS_CREATIONTIME, Buffer);

    return(TRUE);
}


/* Converts the type-name into an attribute value */

LONG
CalcAttributes(
              PUNICODE_STRING Type
              )
{
    UNICODE_STRING  TypeName;

    RtlInitUnicodeString(&TypeName, DIRECTORYTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DIR;
    }
    RtlInitUnicodeString(&TypeName, SYMLINKTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_SYMLINK;
    }
    RtlInitUnicodeString(&TypeName, ADAPTERTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_ADAPTER;
    }
    RtlInitUnicodeString(&TypeName, CONTROLLERTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_CONTROLLER;
    }
    RtlInitUnicodeString(&TypeName, DEVICETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DEVICE;
    }
    RtlInitUnicodeString(&TypeName, DRIVERTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DRIVER;
    }
    RtlInitUnicodeString(&TypeName, EVENTTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_EVENT;
    }
    RtlInitUnicodeString(&TypeName, EVENTPAIRTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_EVENTPAIR;
    }
    RtlInitUnicodeString(&TypeName, FILETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_FILE;
    }
    RtlInitUnicodeString(&TypeName, MUTANTTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_MUTANT;
    }
    RtlInitUnicodeString(&TypeName, PORTTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_PORT;
    }
    RtlInitUnicodeString(&TypeName, PROFILETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_PROFILE;
    }
    RtlInitUnicodeString(&TypeName, SECTIONTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_SECTION;
    }
    RtlInitUnicodeString(&TypeName, SEMAPHORETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_SEMAPHORE;
    }
    RtlInitUnicodeString(&TypeName, TIMERTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_TIMER;
    }
    RtlInitUnicodeString(&TypeName, TYPETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_TYPE;
    }
    RtlInitUnicodeString(&TypeName, PROCESSTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_PROCESS;
    }
    return(0);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripObjectSpec() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Remove the filespec portion from a path (including the backslash). */

VOID
StripObjectSpec(
               LPSTR lpszPath
               )
{
    LPSTR     p;

    p = lpszPath + lstrlen(lpszPath);
    while ((*p != '\\') && (p != lpszPath))
        p = AnsiPrev(lpszPath, p);

    /* Don't strip backslash from root directory entry. */
    if ((p == lpszPath) && (*p == '\\')) {
        p++;
    }

    *p = '\000';
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripObjectPath() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Extract only the filespec portion from a path. */

VOID
StripObjectPath(
               LPSTR lpszPath
               )
{
    LPSTR     p;

    p = lpszPath + lstrlen(lpszPath);
    while ((*p != '\\') && (p != lpszPath))
        p = AnsiPrev(lpszPath, p);

    if (*p == '\\')
        p++;

    if (p != lpszPath)
        lstrcpy(lpszPath, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\treectl.h ===
/* Tree Node Flags. */
#define TF_LASTLEVELENTRY   0x01
#define TF_HASCHILDREN	    0x02
#define TF_EXPANDED	    0x04
#define TF_DISABLED	    0x08
#define TF_LFN		    0x10

typedef struct tagDNODE
  {
    struct tagDNODE  *pParent;
    BYTE	    wFlags;
    BYTE	    nLevels;
    INT             iNetType;
    CHAR	    szName[1];	// variable length field
  } DNODE;
typedef DNODE *PDNODE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\lfn.h ===
/* lfn.h -
 *
 *  declaration of lfn aware functions
 */

#define CCHMAXFILE  260         // max size of a long name

#define FILE_83_CI  0
#define FILE_83_CS  1
#define FILE_LONG   2

#define ERROR_OOM   8

/* we need to add an extra field to distinguish DOS vs. LFNs
 */
typedef struct
{
    HANDLE hFindFile;           // handle returned by FindFirstFile()
    DWORD dwAttrFilter;         // search attribute mask.
    DWORD err;                  // error info if failure.
    WIN32_FIND_DATA fd;         // FindFirstFile() data strucrure;
} LFNDTA, FAR * LPLFNDTA, * PLFNDTA;

VOID  APIENTRY LFNInit( VOID );
VOID  APIENTRY InvalidateVolTypes( VOID );

WORD  APIENTRY GetNameType(LPSTR);
BOOL  APIENTRY IsLFN(LPSTR pName);
//BOOL  APIENTRY IsLFNDrive(WORD);

BOOL  APIENTRY WFFindFirst(LPLFNDTA lpFind, LPSTR lpName, DWORD dwAttrFilter);
BOOL  APIENTRY WFFindNext(LPLFNDTA);
BOOL  APIENTRY WFFindClose(LPLFNDTA);

BOOL  APIENTRY WFIsDir(LPSTR);
BOOL  APIENTRY LFNMergePath(LPSTR,LPSTR);

BOOL  APIENTRY IsLFNSelected(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\treectl.c ===
/****************************************************************************/
/*                                                                          */
/*  TREECTL.C -                                                             */
/*                                                                          */
/*      Windows Directory Tree Window Proc Routines                         */
/*                                                                          */
/****************************************************************************/

#define PUBLIC           // avoid collision with shell.h
#include "winfile.h"
#include "treectl.h"
#include "lfn.h"
#include "winnet.h"
#include "wfcopy.h"

#define WS_TREESTYLE (WS_CHILD | WS_VISIBLE | LBS_NOTIFY | WS_VSCROLL | WS_HSCROLL | LBS_OWNERDRAWFIXED | LBS_NOINTEGRALHEIGHT | LBS_WANTKEYBOARDINPUT | LBS_DISABLENOSCROLL)

WORD    cNodes;
// BOOL    bCancelTree; .......... moved to winfile.c


VOID  RectTreeItem(HWND hwndLB, register INT iItem, BOOL bFocusOn);
VOID  GetTreePathIndirect(PDNODE pNode, register LPSTR szDest);
VOID  GetTreePath(PDNODE pNode, register LPSTR szDest);
VOID  ScanDirLevel(PDNODE pParentNode, LPSTR szPath, DWORD view);
INT   InsertDirectory(HWND hwndTreeCtl, PDNODE pParentNode, WORD iParentNode, LPSTR szName, PDNODE *ppNode);
BOOL  ReadDirLevel(HWND hwndTreeCtl, PDNODE pParentNode, LPSTR szPath,
                     WORD nLevel, INT iParentNode, DWORD dwAttribs, BOOL bFullyExpand, LPSTR szAutoExpand);
VOID  FillTreeListbox(HWND hwndTreeCtl, LPSTR szDefaultDir, BOOL bFullyExpand, BOOL bDontSteal);
WORD  FindItemFromPath(HWND hwndLB, LPSTR lpszPath, BOOL bReturnParent, PDNODE *ppNode);

VOID  APIENTRY CheckEscapes(LPSTR);


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetTreePathIndirect() -                                                 */
/*                                                                          */
/*  build a complete path for a given node in the tree by recursivly        */
/*  traversing the tree structure                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetTreePathIndirect(
                   PDNODE pNode,
                   register LPSTR szDest
                   )
{
    register PDNODE    pParent;

    pParent = pNode->pParent;

    if (pParent)
        GetTreePathIndirect(pParent, szDest);

    lstrcat(szDest, pNode->szName);

    if (pParent)
        lstrcat(szDest, "\\");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetTreePath() -                                                         */
/*                                                                          */
/*  build a complete path for a given node in the tree                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetTreePath(
           PDNODE pNode,
           register LPSTR szDest
           )
{
    szDest[0] = 0L;
    GetTreePathIndirect(pNode, szDest);

    /* Remove the last backslash (unless it is the root directory). */
    if (pNode->pParent)
        szDest[lstrlen(szDest)-1] = 0L;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ScanDirLevel() -                                                        */
/*                                                                          */
/*  look down to see if this node has any sub directories                   */
/*
/*--------------------------------------------------------------------------*/
// szPath is ANSI

VOID
ScanDirLevel(
            PDNODE pParentNode,
            LPSTR szPath,
            DWORD view
            )
{
    BOOL bFound;
    LFNDTA lfndta;

    ENTER("ScanDirLevel");

    /* Add '*.*' to the current path. */
    lstrcpy(szMessage, szPath);
    AddBackslash(szMessage);
    lstrcat(szMessage, szStarDotStar);

    /* Search for the first subdirectory on this level. */
    // FixAnsiPathForDos(szMessage);
    bFound = WFFindFirst(&lfndta, szMessage, ATTR_DIR | view);

    while (bFound) {
        /* Is this not a '.' or '..' directory? */
        if ((lfndta.fd.cFileName[0] != '.') && (lfndta.fd.dwFileAttributes & ATTR_DIR)) {
            pParentNode->wFlags |= TF_HASCHILDREN;
            bFound = FALSE;
        } else
            /* Search for the next subdirectory. */
            bFound = WFFindNext(&lfndta);
    }

    WFFindClose(&lfndta);

    LEAVE("ScanDirLevel");
}



// wizzy cool recursive path compare routine
//
// p1 and p2 must be on the same level (p1->nLevels == p2->nLevels)

INT
ComparePath(
           PDNODE p1,
           PDNODE p2
           )
{
    INT ret;

    if (p1 == p2) {
        return 0;       // equal (base case)
    } else {

        ret = ComparePath(p1->pParent, p2->pParent);

        if (ret == 0) {
            // parents are equal

            ret = lstrcmp(p1->szName, p2->szName);
#if 0
            {
                CHAR buf[200];
                wsprintf(buf, "Compare(%s, %s) -> %d\r\n", (LPSTR)p1->szName, (LPSTR)p2->szName, ret);
                OutputDebugString(buf);
            }
#endif
        }

        // not equal parents, propagate up the call tree
        return ret;
    }
}


INT
CompareNodes(
            PDNODE p1,
            PDNODE p2
            )
{
    PDNODE p1save, p2save;
    INT ret;

    ENTER("CompareNodes");

    ASSERT(p1 && p2);

    PRINT(BF_PARMTRACE, "IN: p1=%s", p1->szName);
    PRINT(BF_PARMTRACE, "IN: p2=%s", p2->szName);

    p1save = p1;
    p2save = p2;

    // get p1 and p2 to the same level

    while (p1->nLevels > p2->nLevels)
        p1 = p1->pParent;

    while (p2->nLevels > p1->nLevels)
        p2 = p2->pParent;

    // compare those paths

    ret = ComparePath(p1, p2);

    if (ret == 0)
        ret = (INT)p1save->nLevels - (INT)p2save->nLevels;

    LEAVE("CompareNodes");
    return ret;
}


//
// InsertDirectory()
//
// wizzy quick n log n binary insert code!
//
// creates and inserts a new node in the tree, this also sets
// the TF_LASTLEVELENTRY bits to mark a branch as being the last
// for a given level as well as marking parents with
// TF_HASCHILDREN | TF_EXPANDED to indicate they have been expanded
// and have children.
//
// Returns iNode and fills ppNode with pNode.
//

INT
InsertDirectory(
               HWND hwndTreeCtl,
               PDNODE pParentNode,
               WORD iParentNode,
               LPSTR szName,
               PDNODE *ppNode
               )
{
    WORD  len, x;
    PDNODE pNode, pMid;
    HWND  hwndLB;
    INT   iMin;
    INT   iMax;
    INT   iMid;

    ENTER("InsertDirectory");
    PRINT(BF_PARMTRACE, "IN: pParentNode=%lx", pParentNode);
    PRINT(BF_PARMTRACE, "IN: iParentNode=%d", iParentNode);
    PRINT(BF_PARMTRACE, "IN: szName=%s", szName);

    len = (WORD)lstrlen(szName);

    pNode = (PDNODE)LocalAlloc(LPTR, sizeof(DNODE)+len);
    if (!pNode) {
        if (ppNode) {
            *ppNode = NULL;
        }
        return 0;
    }

    pNode->pParent = pParentNode;
    pNode->nLevels = pParentNode ? (pParentNode->nLevels + (BYTE)1) : (BYTE)0;
    pNode->wFlags  = (BYTE)NULL;
    pNode->iNetType = -1;
    if (IsLFN(szName)) {
        pNode->wFlags |= TF_LFN;
    }

    lstrcpy(pNode->szName, szName);

    if (pParentNode)
        pParentNode->wFlags |= TF_HASCHILDREN | TF_EXPANDED;      // mark the parent

    hwndLB = GetDlgItem(hwndTreeCtl, IDCW_TREELISTBOX);

    // computing the real text extent is too slow so we aproximate
    // with the following (note, we don't keep this on a per tree
    // basis so it is kinda bogus anyway)

    x = (WORD)(len + 2 * pNode->nLevels) * (WORD)dxText;

    if (x > xTreeMax) {
        xTreeMax = x;
    }

    iMax = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    if (iMax > 0) {

        // do a binary insert

        iMin = iParentNode + 1;
        iMax--;         // last index

        do {
            iMid = (iMax + iMin) / 2;

            SendMessage(hwndLB, LB_GETTEXT, iMid, (LPARAM)&pMid);

            if (CompareNodes(pNode, pMid) > 0)
                iMin = iMid + 1;
            else
                iMax = iMid - 1;

        } while (iMax > iMin);

        SendMessage(hwndLB, LB_GETTEXT, iMax, (LPARAM)&pMid);
        if (CompareNodes(pNode, pMid) > 0)
            iMax++;         // insert after this one
    }

    // now reset the TF_LASTLEVEL flags as appropriate

    // look for the first guy on our level above us and turn off
    // his TF_LASTLEVELENTRY flag so he draws a line down to us

    iMid = iMax - 1;

    while (iMid >= 0) {
        SendMessage(hwndLB, LB_GETTEXT, iMid--, (LPARAM)&pMid);
        if (pMid->nLevels == pNode->nLevels) {
            pMid->wFlags &= ~TF_LASTLEVELENTRY;
            break;
        } else if (pMid->nLevels < pNode->nLevels)
            break;
    }

    // if no one below me or the level of the guy below is less, then
    // this is the last entry for this level

    if (((INT)SendMessage(hwndLB, LB_GETTEXT, iMax, (LPARAM)&pMid) == LB_ERR) ||
        (pMid->nLevels < pNode->nLevels))
        pNode->wFlags |=  TF_LASTLEVELENTRY;

    SendMessage(hwndLB, LB_INSERTSTRING, iMax, (LPARAM)pNode);
    if (ppNode) {
        *ppNode = pNode;
    }

    LEAVE("InsertDirectory");
    return iMax;
}


// this yeilds control to other apps and allows us to process
// messages and user input.  to avoid overrunning the stack
// from multiple tree reads being initiated at the same time
// we check how much space we have on the stack before we yield

extern WORD end;        // C compiler end of static data symbol
extern WORD pStackTop;


WORD
StackAvail(VOID)
{
#ifdef LATER
    _asm    mov ax,sp
    _asm    sub ax,pStackTop
    if (0) return 0;  // get rid of warning, optimized out
#endif

    return 0x7fff;  // Hack. shouldn't really matter. StackAvail in NT is a NOP
}


VOID
APIENTRY
wfYield()
{
    MSG msg;
#ifdef LATER
    WORD free_stack;
    free_stack = StackAvail();
#endif


#if 0
    {
        CHAR buf[30];

        wsprintf(buf, "free stack: %d\r\n", free_stack);
        OutputDebugString(buf);
    }
#endif

#if LATER
    if (free_stack < 1024*4) {
        CHAR buf[40];
        wsprintf(buf, "not enough stack %d\r\n", free_stack);
        OutputDebugString(buf);
        return;
    }
#endif

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!TranslateMDISysAccel(hwndMDIClient, &msg) &&
            (!hwndFrame || !TranslateAccelerator(hwndFrame, hAccel, &msg))) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}


// INT iReadLevel = 0;     ...............Moved to winfile.c


//--------------------------------------------------------------------------
//
// ReadDirLevel() -
//
// this does a depth first search of the dir tree.  note, a bredth
// first implementation did not perform any better.
//
// szPath               a directory path that MUST EXIST long enough
//                      to hold the full path to the largest directory
//                      that will be found (MAXPATHLEN).  this is an
//                      ANSI string.  (ie C:\ and C:\FOO are valid)
// nLevel               level in the tree
// iParentNode          index of parent node
// dwAttribs            attributes to filter with
// bFullyExpand         TRUE means expand this node fully
// szAutoExpand         list of directories to autoexpand ANSI
//                      (eg. for "C:\foo\bar\stuff"
//                      "foo" NULL "bar" NULL "stuff" NULL NULL)
//
// returns:
//      TRUE            tree read sucessful
//      FALSE           user abort or bogus tree read
//--------------------------------------------------------------------------

BOOL
ReadDirLevel(
            HWND  hwndTreeCtl,
            PDNODE pParentNode,
            LPSTR  szPath,
            WORD  nLevel,
            INT   iParentNode,
            DWORD dwAttribs,
            BOOL  bFullyExpand,
            LPSTR  szAutoExpand
            )
{
    LPSTR      szEndPath;
    LFNDTA    lfndta;
    INT       iNode;
    BOOL      bFound;
    PDNODE     pNode;
    BOOL      bAutoExpand;
    BOOL      bResult = TRUE;
    WORD      view;
    HWND      hwndParent;
    HWND      hwndDir;
    HANDLE    hDTA;
    LPMYDTA   lpmydta;
    INT       count;
    RECT rc;

    ENTER("ReadDirLevel");
    PRINT(BF_PARMTRACE, "IN: szPath=%s", szPath);
    PRINT(BF_PARMTRACE, "IN: nLevel=%d", (LPSTR)nLevel);
    PRINT(BF_PARMTRACE, "IN: bFullyExpand=%d", IntToPtr(bFullyExpand));
    PRINT(BF_PARMTRACE, "IN: szAutoExpand=%s", szAutoExpand);

    if (StackAvail() < 1024*2)
        return(TRUE);

    hwndParent = GetParent(hwndTreeCtl);

    view = (WORD)GetWindowLong(hwndParent, GWL_VIEW);

    // we optimize the tree read if we are not adding pluses and
    // we find a directory window that already has read all the
    // directories for the path we are about to search.  in this
    // case we look through the DTA structure in the dir window
    // to get all the directories (instead of calling FindFirst/FindNext).
    // in this case we have to disable yielding since the user could
    // potentialy close the dir window that we are reading, or change
    // directory.

    hDTA = NULL;

    if (!(view & VIEW_PLUSES)) {

        if ((hwndDir = HasDirWindow(hwndParent)) &&
            (GetWindowLong(hwndParent, GWL_ATTRIBS) & ATTR_DIR)) {

            SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szMessage), (LPARAM)szMessage);
            StripBackslash(szMessage);

            if (!lstrcmpi(szMessage, szPath)) {
                SendMessage(hwndDir, FS_GETFILESPEC, sizeof(szMessage), (LPARAM)szMessage);

                if (!lstrcmp(szMessage, szStarDotStar)) {
                    hDTA = (HANDLE)GetWindowLongPtr(hwndDir, GWLP_HDTA);
                    lpmydta = (LPMYDTA)LocalLock(hDTA);
                    count = (INT)lpmydta->my_nFileSizeLow; // holds number of entries, NOT size.
                }
            }
        }
    }

    SetWindowLong(hwndTreeCtl, GWL_READLEVEL, GetWindowLong(hwndTreeCtl, GWL_READLEVEL) + 1);
    iReadLevel++;         // global for menu code

    szEndPath = (LPSTR)(szPath + lstrlen(szPath));

    /* Add '\*.*' to the current path. */
    AddBackslash(szPath);
    lstrcat(szPath, szStarDotStar);

    if (hDTA) {
        // steal the entry from the dir window
        lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);

        // search for any "real" directories

        while (count > 0 && (!(lpmydta->my_dwAttrs & ATTR_DIR) || (lpmydta->my_dwAttrs & ATTR_PARENT))) {
            lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);
            count--;
        }

        if (count > 0) {
            bFound = TRUE;
            memcpy(&(lfndta.fd.dwFileAttributes), &(lpmydta->my_dwAttrs), IMPORTANT_DTA_SIZE);
            lstrcpy(lfndta.fd.cFileName, lpmydta->my_cFileName);
        } else
            bFound = FALSE;
    } else {
        // get first file from DOS
        lstrcpy(szMessage, szPath);
        FixAnsiPathForDos(szMessage);
        bFound = WFFindFirst(&lfndta, szMessage, dwAttribs);
    }

    // for net drive case where we can't actually see what is in these
    // direcotries we will build the tree automatically

    if (!bFound && *szAutoExpand) {
        LPSTR p;

        p = szAutoExpand;
        szAutoExpand += lstrlen(szAutoExpand) + 1;

        iNode = InsertDirectory(hwndTreeCtl, pParentNode, (WORD)iParentNode, p, &pNode);
        pParentNode->wFlags |= TF_DISABLED;

        /* Construct the path to this new subdirectory. */
        *szEndPath = 0;           // remove old stuff
        AddBackslash(szPath);
        lstrcat(szPath, p);

        if (pNode)
            ReadDirLevel(hwndTreeCtl, pNode, szPath, (WORD)(nLevel+1), iNode, dwAttribs, bFullyExpand, szAutoExpand);
    }

    while (bFound) {

        wfYield();

        if (bCancelTree) {
            bResult = FALSE;
            if (bCancelTree == 2)
                PostMessage(hwndFrame, WM_COMMAND, IDM_EXIT, 0L);
            goto DONE;
        }

        /* Is this not a '.' or '..' directory? */
        if ((lfndta.fd.cFileName[0] != '.') && (lfndta.fd.dwFileAttributes & ATTR_DIR)) {

            if (!hDTA)
                OemToAnsi(lfndta.fd.cFileName, lfndta.fd.cFileName);

            // we will try to auto expand this node if it matches

            if (*szAutoExpand && !lstrcmpi(szAutoExpand, lfndta.fd.cFileName)) {
                bAutoExpand = TRUE;
                szAutoExpand += lstrlen(szAutoExpand) + 1;
            } else {
                bAutoExpand = FALSE;
            }

            iNode = InsertDirectory(hwndTreeCtl, pParentNode, (WORD)iParentNode, lfndta.fd.cFileName, &pNode);

            if (bStatusBar && ((cNodes % 7) == 0)) {

                // make sure we are the active window before we
                // update the status bar

                if (hwndParent == (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L)) {
                    wsprintf(szStatusTree, szDirsRead, cNodes);
                    // stomp over the status bar!
                    GetClientRect(hwndFrame, &rc);
                    rc.top = rc.bottom - dyStatus;
                    InvalidateRect(hwndFrame, &rc, FALSE);
                    // force the paint because we don't yield
                    UpdateWindow(hwndFrame);
                }
            }
            cNodes++;

            /* Construct the path to this new subdirectory. */
            *szEndPath = 0L;
            AddBackslash(szPath);
            lstrcat(szPath, lfndta.fd.cFileName);         // cFileName is ANSI now


            // either recurse or add pluses

            if (pNode) {
                if (bFullyExpand || bAutoExpand) {
                    if (!ReadDirLevel(hwndTreeCtl, pNode, szPath, (WORD)(nLevel+1), iNode, dwAttribs, bFullyExpand, szAutoExpand)) {
                        bResult = FALSE;
                        goto DONE;
                    }
                } else if (view & VIEW_PLUSES) {
                    ScanDirLevel(pNode, szPath, dwAttribs & ATTR_HS);
                }
            }
        }

        if (hDTA) {       // short cut, steal data from dir window
            count--;
            lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);
            while (count > 0 && (!(lpmydta->my_dwAttrs & ATTR_DIR) || (lpmydta->my_dwAttrs & ATTR_PARENT))) {
                lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);
                count--;
            }

            if (count > 0) {
                bFound = TRUE;
                memcpy(&(lfndta.fd.dwFileAttributes), &(lpmydta->my_dwAttrs), IMPORTANT_DTA_SIZE);
                lstrcpy(lfndta.fd.cFileName, lpmydta->my_cFileName);
            } else
                bFound = FALSE;
        } else {
            bFound = WFFindNext(&lfndta); // get it from dos
        }
    }

    *szEndPath = 0L;    // clean off any stuff we left on the end of the path

    DONE:

    if (!hDTA) {
        WFFindClose(&lfndta);
    } else {
        LocalUnlock(hDTA);
    }

    SetWindowLong(hwndTreeCtl, GWL_READLEVEL, GetWindowLong(hwndTreeCtl, GWL_READLEVEL) - 1);
    iReadLevel--;

    LEAVE("ReadDirLevel");
    return bResult;
}


// this is used by StealTreeData() to avoid alias problems where
// the nodes in one tree point to parents in the other tree.
// basically, as we are duplicating the tree data structure we
// have to find the parent node that coorisponds with the parent
// of the tree we are copying from in the tree that we are building.
// since the tree is build in order we run up the listbox, looking
// for the parent (matched by it's level being one smaller than
// the level of the node being inserted).  when we find that we
// return the pointer to that node.

PDNODE
FindParent(
          INT iLevelParent,
          INT iStartInd,
          HWND hwndLB
          )
{
    PDNODE pNode;

    while (TRUE) {
        if (SendMessage(hwndLB, LB_GETTEXT, iStartInd, (LPARAM)&pNode) == LB_ERR)
            return NULL;

        if (pNode->nLevels == (BYTE)iLevelParent) {
            SendMessage(hwndLB, LB_GETTEXT, iStartInd, (LPARAM)&pNode);
            return pNode;
        }

        iStartInd--;
    }
}



BOOL
StealTreeData(
             HWND hwndTC,
             HWND hwndLB,
             LPSTR szDir
             )
{
    HWND hwndSrc, hwndT;
    CHAR szSrc[MAXPATHLEN];
    WORD wView;
    DWORD dwAttribs;

    ENTER("StealTreeData");

    // we need to match on these attributes as well as the name

    wView    = (WORD)(GetWindowLong(GetParent(hwndTC), GWL_VIEW) & VIEW_PLUSES);
    dwAttribs = (DWORD)GetWindowLong(GetParent(hwndTC), GWL_ATTRIBS) & ATTR_HS;

    // get the dir of this new window for compare below

    for (hwndSrc = GetWindow(hwndMDIClient, GW_CHILD); hwndSrc;
        hwndSrc = GetWindow(hwndSrc, GW_HWNDNEXT)) {

        // avoid finding ourselves, make sure has a tree
        // and make sure the tree attributes match

        if ((hwndT = HasTreeWindow(hwndSrc)) &&
            (hwndT != hwndTC) &&
            !GetWindowLong(hwndT, GWL_READLEVEL) &&
            (wView  == (WORD)(GetWindowLong(hwndSrc, GWL_VIEW) & VIEW_PLUSES)) &&
            (dwAttribs == (DWORD)(GetWindowLong(hwndSrc, GWL_ATTRIBS) & ATTR_HS))) {

            SendMessage(hwndSrc, FS_GETDIRECTORY, sizeof(szSrc), (LPARAM)szSrc);
            StripBackslash(szSrc);

            if (!lstrcmpi(szDir, szSrc))     // are they the same?
                break;                  // yes, do stuff below
        }
    }

    if (hwndSrc) {

        HWND hwndLBSrc;
        PDNODE pNode, pNewNode, pLastParent;
        INT i;

        hwndLBSrc = GetDlgItem(hwndT, IDCW_TREELISTBOX);

        // don't seal from a tree that hasn't been read yet!

        if ((INT)SendMessage(hwndLBSrc, LB_GETCOUNT, 0, 0L) == 0) {
            LEAVE("StealTreeData");
            return FALSE;
        }

        pLastParent = NULL;

        for (i = 0; SendMessage(hwndLBSrc, LB_GETTEXT, i, (LPARAM)&pNode) != LB_ERR; i++) {

            if (pNewNode = (PDNODE)LocalAlloc(LPTR, sizeof(DNODE)+lstrlen(pNode->szName))) {

                *pNewNode = *pNode;                             // dup the node
                lstrcpy(pNewNode->szName, pNode->szName);       // and the name

                // accelerate the case where we are on the same level to avoid
                // slow linear search!

                if (pLastParent && pLastParent->nLevels == (pNode->nLevels - (BYTE)1)) {
                    pNewNode->pParent = pLastParent;
                } else {
                    pNewNode->pParent = pLastParent = FindParent(pNode->nLevels-1, i-1, hwndLB);
                }

                PRINT(BF_PARMTRACE, "(stolen)Inserting...0x%lx", pNewNode);
                PRINT(BF_PARMTRACE, "   at %d", IntToPtr(i));
                SendMessage(hwndLB, LB_INSERTSTRING, i, (LPARAM)pNewNode);
                ASSERT((PDNODE)SendMessage(hwndLB, LB_GETITEMDATA, i, 0L) == pNewNode);
            }
        }

        LEAVE("StealTreeData");
        return TRUE;    // successful steal
    }

    LEAVE("StealTreeData");
    return FALSE;
}



VOID
FreeAllTreeData(
               HWND hwndLB
               )
{
    INT nIndex;
    PDNODE pNode;

    ENTER("FreeAllTreeData");

    // Free up the old tree (if any)

    nIndex = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
    while (--nIndex >= 0) {
        SendMessage(hwndLB, LB_GETTEXT, nIndex, (LPARAM)&pNode);
        LocalFree((HANDLE)pNode);
    }
    SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

    LEAVE("FreeAllTreeData");
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FillTreeListbox() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
// szDefaultDir is ANSI

VOID
FillTreeListbox(
               HWND hwndTC,
               LPSTR szDefaultDir,
               BOOL bFullyExpand,
               BOOL bDontSteal
               )
{
    PDNODE pNode;
    INT   iNode;
    DWORD dwAttribs;
    CHAR  szTemp[MAXPATHLEN];
    CHAR  szExpand[MAXPATHLEN];
    LPSTR  p;
    HWND  hwndLB;

    ENTER("FillTreeListbox");

    hwndLB = GetDlgItem(hwndTC, IDCW_TREELISTBOX);

    FreeAllTreeData(hwndLB);

    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);

    bDontSteal = TRUE; // Force recalc for now

    if (bDontSteal || bFullyExpand || !StealTreeData(hwndTC, hwndLB, szDefaultDir)) {

        wsprintf(szTemp, "\\", DRIVEID(szDefaultDir) + 'A');
        iNode = InsertDirectory(hwndTC, NULL, 0, szTemp, &pNode);

        if (pNode) {

            dwAttribs = ATTR_DIR | (GetWindowLong(GetParent(hwndTC), GWL_ATTRIBS) & ATTR_HS);
            cNodes = 0;
            bCancelTree = FALSE;

            if (szDefaultDir) {
                lstrcpy(szExpand, szDefaultDir+3);      // skip "X:\"

                p = szExpand;

                while (*p) {                            // null out all slashes

                    while (*p && *p != '\\')
                        p = AnsiNext(p);

                    if (*p)
                        *p++ = 0L;
                }
                p++;
                *p = 0L;      // double null terminated
            } else
                *szExpand = 0;

            if (!ReadDirLevel(hwndTC, pNode, szTemp, 1, 0, dwAttribs, bFullyExpand, szExpand)) {
                lFreeSpace = -2L;
            }

        }
    }

    SendMessage(hwndLB, LB_SETHORIZONTALEXTENT, xTreeMax, 0L);

    if (szDefaultDir) {
        FindItemFromPath(hwndLB, szDefaultDir, FALSE, &pNode);
    }

    SendMessage(hwndLB, LB_SELECTSTRING, -1, (LPARAM)pNode);

    UpdateStatus(GetParent(hwndTC));  // Redraw the Status Bar

    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);

    InvalidateRect(hwndLB, NULL, TRUE);
    UpdateWindow(hwndLB);                 // make this look a bit better

    LEAVE("FillTreeListbox");
}


//
// FindItemFromPath()
//
// find the PDNODE and LBIndex for a given path
//
// in:
//      hwndLB          listbox of tree
//      lpszPath        path to search for (ANSI)
//      bReturnParent   TRUE if you want the parent, not the node
//
//
// returns:
//      listbox index (0xFFFF if not found)
//      *ppNode is filled with pNode of node, or pNode of parent if bReturnParent is TRUE
//

WORD
FindItemFromPath(
                HWND hwndLB,
                LPSTR lpszPath,
                BOOL bReturnParent,
                PDNODE *ppNode
                )
{
    register WORD     i;
    register LPSTR     p;
    PDNODE             pNode;
    PDNODE             pPreviousNode;
    CHAR              szElement[1+MAXFILENAMELEN+1];

    ENTER("FindItemFromPath");

    if (lstrlen(lpszPath) < 3) {
        LEAVE("FindItemFromPath");
        return -1;
    }
    if (IsDBCSLeadByte( lpszPath[0] ) || lpszPath[1] != ':') {
        LEAVE("FindItemFromPath");
        return -1;
    }

    i = 0;
    pPreviousNode = NULL;

    while (*lpszPath) {
        /* NULL out szElement[1] so the backslash hack isn't repeated with
         * a first level directory of length 1.
         */
        szElement[1] = 0L;

        /* Copy the next section of the path into 'szElement' */
        p = szElement;
        while (*lpszPath && *lpszPath != '\\') {
            *p++ = *lpszPath;
            if (IsDBCSLeadByte( *lpszPath ))
                *p++ = lpszPath[1];     // copy 2nd byte of DBCS char.
            lpszPath = AnsiNext( lpszPath );
        }

        /* Add a backslash for the Root directory. */
        if ( !IsDBCSLeadByte( szElement[0] ) && szElement[1] == ':' )
            *p++ = '\\';

        /* NULL terminate 'szElement' */
        *p = 0L;

        /* Skip over the path's next Backslash. */
        if (*lpszPath)
            lpszPath = AnsiNext(lpszPath);
        else if (bReturnParent) {
            /* We're at the end of a path which includes a filename.  Return
             * the previously found parent.
             */
            if (ppNode) {
                *ppNode = pPreviousNode;
            }
            LEAVE("FindItemFromPath");
            return i;
        }

        while (TRUE) {
            /* Out of LB items?  Not found. */
            if (SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&pNode) == LB_ERR)
                return -1;

            if (pNode->pParent == pPreviousNode) {
                if (!lstrcmpi(szElement, pNode->szName)) {
                    /* We've found the element... */
                    pPreviousNode = pNode;
                    break;
                }
            }
            i++;
        }
    }
    if (ppNode) {
        *ppNode = pPreviousNode;
    }

    LEAVE("FindItemFromPath");
    return i;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RectTreeItem() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
RectTreeItem(
            HWND hwndLB,
            INT iItem,
            BOOL bFocusOn
            )
{
    INT           dx;
    INT           len;
    HDC           hdc;
    RECT          rc;
    RECT          rcClip;
    BOOL          bSel;
    WORD          wColor;
    PDNODE         pNode;
    HBRUSH        hBrush;
    HFONT hOld;
    CHAR          szPath[MAXPATHLEN];

    ENTER("RectTreeItem");

    if (iItem == -1) {
        LEAVE("RectTreeItem");
        return;
    }

    /* Are we over ourselves? (i.e. a selected item in the source listbox) */
    bSel = (BOOL)SendMessage(hwndLB, LB_GETSEL, iItem, 0L);
    if (bSel && (hwndDragging == hwndLB)) {
        LEAVE("RectTreeItem");
        return;
    }

    SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM)&pNode);

    SendMessage(hwndLB, LB_GETITEMRECT, iItem, (LPARAM)&rc);

    hdc = GetDC(hwndLB);

    len = lstrlen(pNode->szName);
    lstrcpy(szPath, pNode->szName);

    if ((wTextAttribs & TA_LOWERCASE) && !(pNode->wFlags & TF_LFN))
        AnsiLower(szPath);

    hOld = SelectObject(hdc, hFont);
    MGetTextExtent(hdc, szPath, len, &dx, NULL);
    dx += dyBorder;
    if (hOld)
        SelectObject(hdc, hOld);
    rc.left = pNode->nLevels * dxText * 2;
    rc.right = rc.left + dxFolder + dx + 4 * dyBorderx2;

    GetClientRect(hwndLB, &rcClip);
    IntersectRect(&rc, &rc, &rcClip);

    if (bFocusOn) {
        if (bSel) {
            wColor = COLOR_WINDOW;
            InflateRect(&rc, -dyBorder, -dyBorder);
        } else
            wColor = COLOR_WINDOWFRAME;
        if (hBrush = CreateSolidBrush(GetSysColor(wColor))) {
            FrameRect(hdc, &rc, hBrush);
            DeleteObject(hBrush);
        }
    } else {
        InvalidateRect(hwndLB, &rc, TRUE);
        UpdateWindow(hwndLB);
    }
    ReleaseDC(hwndLB, hdc);
    LEAVE("RectTreeItem");
}


// return the drive of the first window to respond to the FS_GETDRIVE
// message.  this usually starts from the source or dest of a drop
// and travels up until we find a drive or hit the MDI client

INT
APIENTRY
GetDrive(
        HWND hwnd,
        POINT pt
        )
{
    CHAR chDrive;

    chDrive = 0L;
    while (hwnd && (hwnd != hwndMDIClient)) {
        chDrive = (CHAR)SendMessage(hwnd, FS_GETDRIVE, 0, MAKELONG((WORD)pt.x, (WORD)pt.y));

        if (chDrive)
            return chDrive;

        hwnd = GetParent(hwnd); // try the next higher up
    }

    return 0;
}

BOOL
IsNetPath(
         PDNODE pNode
         )
{
    CHAR szPath[MAXPATHLEN];
    INT i;

    if (pNode->iNetType == -1) {

        GetTreePath(pNode, szPath);

        if (WNetGetDirectoryType((LPSTR)szPath, (LPDWORD)&i, TRUE) == WN_SUCCESS)
            pNode->iNetType = i;
        else
            pNode->iNetType = 0;
    }
    return pNode->iNetType;
}


VOID
TCWP_DrawItem(
             LPDRAWITEMSTRUCT lpLBItem,
             HWND hwndLB,
             HWND hWnd
             )
{
    INT               x, y, dx, dy;
    INT               nLevel;
    HDC               hdc;
    WORD              len;
    RECT              rc;
    BOOL              bHasFocus, bDrawSelected;
    PDNODE            pNode, pNTemp;
    DWORD             rgbText;
    DWORD             rgbBackground;
    HBRUSH            hBrush, hOld;
    INT iBitmap;
    WORD view;
    CHAR      szPath[MAXPATHLEN];

    ENTER("TCWP_DrawItem");

    if (lpLBItem->itemID == (DWORD)-1) {
        return;
    }

    hdc = lpLBItem->hDC;
    pNode = (PDNODE)lpLBItem->itemData;

    lstrcpy(szPath, pNode->szName);
    if ((wTextAttribs & TA_LOWERCASE) && !(pNode->wFlags & TF_LFN))
        AnsiLower(szPath);

    len = (WORD)lstrlen(szPath);
    MGetTextExtent(hdc, szPath, len, &dx, NULL);
    dx += dyBorder;

    rc = lpLBItem->rcItem;
    rc.left = pNode->nLevels * dxText * 2;
    rc.right = rc.left + dxFolder + dx + 4 * dyBorderx2;

    if (lpLBItem->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {

        // draw the branches of the tree first

        nLevel = pNode->nLevels;

        x = (nLevel * dxText * 2) - dxText + dyBorderx2;
        dy = lpLBItem->rcItem.bottom - lpLBItem->rcItem.top;
        y = lpLBItem->rcItem.top + (dy/2);

        if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT))) {

            hOld = SelectObject(hdc, hBrush);

            if (pNode->pParent) {
                /* Draw the horizontal line over to the (possible) folder. */
                PatBlt(hdc, x, y, dyText, dyBorder, PATCOPY);

                /* Draw the top part of the vertical line. */
                PatBlt(hdc, x, lpLBItem->rcItem.top, dyBorder, dy/2, PATCOPY);

                /* If not the end of a node, draw the bottom part... */
                if (!(pNode->wFlags & TF_LASTLEVELENTRY))
                    PatBlt(hdc, x, y+dyBorder, dyBorder, dy/2, PATCOPY);

                /* Draw the verticals on the left connecting other nodes. */
                pNTemp = pNode->pParent;
                while (pNTemp) {
                    nLevel--;
                    if (!(pNTemp->wFlags & TF_LASTLEVELENTRY))
                        PatBlt(hdc, (nLevel * dxText * 2) - dxText + dyBorderx2,
                               lpLBItem->rcItem.top, dyBorder,dy, PATCOPY);

                    pNTemp = pNTemp->pParent;
                }
            }

            if (hOld)
                SelectObject(hdc, hOld);

            DeleteObject(hBrush);
        }

        bDrawSelected = (lpLBItem->itemState & ODS_SELECTED);
        bHasFocus = (GetFocus() == lpLBItem->hwndItem);

        // draw text with the proper background or rect

        if (bHasFocus && bDrawSelected) {
            rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
            rgbBackground = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
        }

        ExtTextOut(hdc, x + dxText + dxFolder + 2 * dyBorderx2,
                   y-(dyText/2), ETO_OPAQUE, &rc,
                   szPath, len, NULL);

        // draw the bitmaps as needed

        // HACK: Don't draw the bitmap when moving

        if (fShowSourceBitmaps || (hwndDragging != hwndLB) || !bDrawSelected) {

            // Blt the proper folder bitmap

            view = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);

            if (bNetAdmin && IsNetPath(pNode)) {
                // we need this bitmap from lisa
                if (bDrawSelected)
                    iBitmap = BM_IND_OPENDFS;
                else
                    iBitmap = BM_IND_CLOSEDFS;

            } else if (!(view & VIEW_PLUSES) || !(pNode->wFlags & TF_HASCHILDREN)) {
                if (bDrawSelected)
                    iBitmap = BM_IND_OPEN;
                else
                    iBitmap = BM_IND_CLOSE;
            } else {
                if (pNode->wFlags & TF_EXPANDED) {
                    if (bDrawSelected)
                        iBitmap = BM_IND_OPENMINUS;
                    else
                        iBitmap = BM_IND_CLOSEMINUS;
                } else {
                    if (bDrawSelected)
                        iBitmap = BM_IND_OPENPLUS;
                    else
                        iBitmap = BM_IND_CLOSEPLUS;
                }
            }
            BitBlt(hdc, x + dxText + dyBorder, y-(dyFolder/2), dxFolder, dyFolder,
                   hdcMem, iBitmap * dxFolder, (bHasFocus && bDrawSelected) ? dyFolder : 0, SRCCOPY);
        }

        // restore text stuff and draw rect as required

        if (bDrawSelected) {
            if (bHasFocus) {
                SetTextColor(hdc, rgbText);
                SetBkColor(hdc, rgbBackground);
            } else {
                HBRUSH hbr;
                if (hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT))) {
                    FrameRect(hdc, &rc, hbr);
                    DeleteObject(hbr);
                }
            }
        }


    }

    if (lpLBItem->itemAction == ODA_FOCUS)
        DrawFocusRect(hdc, &rc);

}

/* A helper for both ExpandLevel and TreeCtlWndProc.TC_COLLAPSELEVEL.
 * Code moved from TreeCtlWndProc to be shared.  EDH 13 Oct 91
 */
VOID
CollapseLevel(
             HWND hwndLB,
             PDNODE pNode,
             INT nIndex
             )
{
    DWORD_PTR dwTemp;
    PDNODE pParentNode = pNode;
    INT nIndexT = nIndex;

    /* Disable redrawing early. */
    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);

    nIndexT++;

    /* Remove all subdirectories. */

    while (TRUE) {
        /* Make sure we don't run off the end of the listbox. */
        if (SendMessage(hwndLB, LB_GETTEXT, nIndexT, (LPARAM)&dwTemp) == LB_ERR)
            break;

        pNode = (PDNODE)dwTemp;

        if (pNode->nLevels <= pParentNode->nLevels)
            break;

        LocalFree((HANDLE)pNode);

        SendMessage(hwndLB, LB_DELETESTRING, nIndexT, 0L);
    }

    pParentNode->wFlags &= ~TF_EXPANDED;
    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);

    InvalidateRect(hwndLB, NULL, TRUE);

}


VOID
ExpandLevel(
           HWND hWnd,
           WORD wParam,
           INT nIndex,
           PSTR szPath
           )
{
    HWND hwndLB;
    DWORD_PTR dwTemp;
    PDNODE pNode;
    INT iNumExpanded;
    INT iBottomIndex;
    INT iTopIndex;
    INT iNewTopIndex;
    INT iExpandInView;
    INT iCurrentIndex;
    RECT rc;

    if (GetWindowLong(hWnd, GWL_READLEVEL))
        return;

    hwndLB = GetDlgItem(hWnd, IDCW_TREELISTBOX);

    if (nIndex == -1)
        if ((nIndex = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L)) == LB_ERR)
            return;

    SendMessage(hwndLB, LB_GETTEXT, nIndex, (LPARAM)&dwTemp);
    pNode = (PDNODE)dwTemp;

    // collapse the current contents so we avoid doubling existing "plus" dirs

    if (pNode->wFlags & TF_EXPANDED) {
        if (wParam)
            CollapseLevel(hwndLB, pNode, nIndex);
        else
            return;
    }

    GetTreePath(pNode, szPath);

    StripBackslash(szPath);   // remove the slash

    cNodes = 0;
    bCancelTree = FALSE;

    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);   // Disable redrawing.

    iCurrentIndex = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
    iNumExpanded = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
    iTopIndex = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
    GetClientRect(hwndLB, &rc);
    iBottomIndex = iTopIndex + (rc.bottom+1) / dyFileName;

    if (IsTheDiskReallyThere(hWnd, szPath, FUNC_EXPAND))
        ReadDirLevel(hWnd, pNode, szPath, (WORD)(pNode->nLevels + 1), nIndex,
                     (DWORD)(ATTR_DIR | (GetWindowLong(GetParent(hWnd), GWL_ATTRIBS) & ATTR_HS)),
                     (BOOL)wParam, szNULL);

    // this is how many will be in view

    iExpandInView = (iBottomIndex - (INT)iCurrentIndex);

    iNumExpanded = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L) - iNumExpanded;

    if (iNumExpanded >= iExpandInView) {

        iNewTopIndex = min((INT)iCurrentIndex, iTopIndex + iNumExpanded - iExpandInView + 1);

        SendMessage(hwndLB, LB_SETTOPINDEX, (WORD)iNewTopIndex, 0L);
    }

    SendMessage(hwndLB, LB_SETHORIZONTALEXTENT, xTreeMax, 0L);

    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);

    if (iNumExpanded)
        InvalidateRect(hwndLB, NULL, TRUE);

    // Redraw the Status Bar

    UpdateStatus(GetParent(hWnd));
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  TreeControlWndProc() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* WndProc for the directory tree control. */

INT_PTR
APIENTRY
TreeControlWndProc(
                  register HWND hWnd,
                  UINT wMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    WORD      iSel;
    INT       i, j;
    WPARAM    nIndex;
    DWORD     dwTemp;
    PDNODE     pNode, pNodeNext;
    HWND      hwndLB;
    CHAR      szPath[MAXPATHLEN];

    STKCHK();

    hwndLB = GetDlgItem(hWnd, IDCW_TREELISTBOX);

    switch (wMsg) {
        case FS_GETDRIVE:
            MSG("TreeControlWndProc", "FS_GETDRIVE");
            return (GetWindowLong(GetParent(hWnd), GWL_TYPE) + 'A');

        case TC_COLLAPSELEVEL:
            MSG("TreeControlWndProc", "TC_COLLAPSELEVEL");
            {
                PDNODE     pParentNode;

                if (wParam)
                    nIndex = wParam;
                else {
                    nIndex = SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                    if (nIndex == LB_ERR)
                        break;
                }

                SendMessage(hwndLB, LB_GETTEXT, nIndex, (LPARAM)&pParentNode);

                // short circuit if we are already in this state

                if (!(pParentNode->wFlags & TF_EXPANDED))
                    break;

                CollapseLevel(hwndLB, pParentNode, (int)nIndex);

                break;
            }

        case TC_EXPANDLEVEL:
            MSG("TreeControlWndProc", "TC_EXPANDLEVEL");
            ExpandLevel(hWnd, (WORD)wParam, (INT)-1, szPath);
            break;

        case TC_TOGGLELEVEL:
            MSG("TreeControlWndProc", "TC_TOGGLELEVEL");

            // don't do anything while the tree is being built

            if (GetWindowLong(hWnd, GWL_READLEVEL))
                return 1;

            SendMessage(hwndLB, LB_GETTEXT, (WPARAM)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L), (LPARAM)&pNode);

            if (pNode->wFlags & TF_EXPANDED)
                wMsg = TC_COLLAPSELEVEL;
            else
                wMsg = TC_EXPANDLEVEL;

            SendMessage(hWnd, wMsg, FALSE, 0L);
            break;

        case TC_GETDIR:
            // get a full path for a particular dir
            // wParam is the listbox index of path to get
            // lParam LOWORD is PSTR to buffer to fill in

            MSG("TreeControlWndProc", "TC_GETDIR");

            SendMessage(hwndLB, LB_GETTEXT, wParam, (LPARAM)&pNode);
            GetTreePath(pNode, (LPSTR)lParam);
            break;

        case TC_SETDIRECTORY:
            MSG("TreeControlWndProc", "TC_SETDIRECTORY");
            // set the selection in the tree to that for a given path

            {
                INT i;

                i = (INT)FindItemFromPath(hwndLB, (LPSTR)lParam, wParam ? TRUE : FALSE, NULL);

                if (i != -1)
                    SendMessage(hwndLB, LB_SETCURSEL, i, 0L);

                break;
            }

        case TC_SETDRIVE:
#define fFullyExpand    LOBYTE(wParam)
#define fDontSteal      HIBYTE(wParam)
#define szDir           (LPSTR)lParam  // NULL -> default == window text.

            MSG("TreeControlWndProc", "TC_SETDRIVE");

            {
                RECT rc;

                if (GetWindowLong(hWnd, GWL_READLEVEL))
                    break;

                // is the drive/dir specified?

                if (szDir) {
                    lstrcpy(szPath, szDir);                  // yes, use it
                } else {
                    SendMessage(GetParent(hWnd), FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath); // no, use current
                    StripBackslash(szPath);
                }


                AnsiUpperBuff(szPath, 1);     // make sure

                SetWindowLong(GetParent(hWnd), GWL_TYPE, 2);

                // resize for new vol label

                GetClientRect(GetParent(hWnd), &rc);
                SendMessage(GetParent(hWnd), WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));

                // ensure the disk is available if the whole dir structure is
                // to be expanded

                if (!fFullyExpand || IsTheDiskReallyThere(hWnd, szPath, FUNC_EXPAND))
                    FillTreeListbox(hWnd, szPath, fFullyExpand, fDontSteal);

                // and force the dir half to update with a fake SELCHANGE message

                SendMessage(hWnd, WM_COMMAND, GET_WM_COMMAND_MPS(IDCW_TREELISTBOX, hWnd, LBN_SELCHANGE));
                break;
#undef fFullyExpand
#undef fDontSteal
#undef szDir
            }

        case WM_CHARTOITEM:
            MSG("TreeControlWndProc", "WM_CHARTOITEM");
            {
                WORD      w;
                CHAR      szB[2];
                INT       cItems;
                CHAR      ch;
                PDNODE     pNode;

                if (GET_WM_CHARTOITEM_CHAR(wParam, lParam) == '\\')   // backslash means the root
                    return 0L;

                cItems = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
                i = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);

                ch = GET_WM_CHARTOITEM_CHAR(wParam, lParam);
                if (i < 0 || ch <= ' ')       // filter all other control chars
                    return -2L;

                szB[1] = 0L;
                ch &= 255;

                for (j=1; j < cItems; j++) {
                    SendMessage(hwndLB, LB_GETTEXT, (i+j) % cItems, (LPARAM)&pNode);
                    szB[0] = pNode->szName[0];

                    /* Do it this way to be case insensitive. */
                    w = ch;
                    if (!lstrcmpi((LPSTR)&w, szB))
                        break;
                }

                if (j == cItems)
                    return -2L;

                SendMessage(hwndLB, LB_SETTOPINDEX, (i+j) % cItems, 0L);
                return((i+j) % cItems);
            }

        case WM_DESTROY:
            MSG("TreeControlWndProc", "WM_DESTROY");
            if (hwndLB == GetFocus()) {
                HWND hwnd;

                if (hwnd = HasDirWindow(GetParent(hWnd)))
                    SetFocus(hwnd);
                else
                    SetFocus(HasDrivesWindow(GetParent(hWnd)));
            }
            FreeAllTreeData(hwndLB);
            break;

        case WM_CREATE:
            TRACE(BF_WM_CREATE, "TreeControlWndProc - WM_CREATE");
            // create the owner draw list box for the tree
            {
                HWND hwnd;

                hwnd = CreateWindowEx(0L, szListbox, NULL, WS_TREESTYLE | WS_BORDER,
                                      0, 0, 0, 0, hWnd, (HMENU)IDCW_TREELISTBOX, hAppInstance, NULL);

                if (!hwnd)
                    return -1L;

                SendMessage(hwnd, WM_SETFONT, (WPARAM)hFont, 0L);

                SetWindowLong(hWnd, GWL_READLEVEL, 0);
                break;
            }

        case WM_DRAWITEM:
            MSG("TreeControlWndProc", "WM_DRAWITEM");
            TCWP_DrawItem((LPDRAWITEMSTRUCT)lParam, hwndLB, hWnd);
            break;

        case WM_FILESYSCHANGE:
            MSG("TreeControlWndProc", "WM_FILESYSCHANGE");
            {
                HWND hwndParent;
                PDNODE pNodePrev;
                PDNODE pNodeT;

                if (!lParam || wParam == FSC_REFRESH)
                    break;

                nIndex = FindItemFromPath(hwndLB, (LPSTR)lParam, wParam == FSC_MKDIR, &pNode);

                if (nIndex == 0xFFFF)   /* Did we find it? */
                    break;

                lstrcpy(szPath, (LPSTR)lParam);
                StripPath(szPath);

                switch (wParam) {
                    case FSC_MKDIR:

                        // auto expand the branch so they can see the new
                        // directory just created

                        if (!(pNode->wFlags & TF_EXPANDED) &&
                            (nIndex == (WPARAM)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L)))
                            SendMessage(hWnd, TC_EXPANDLEVEL, FALSE, 0L);

                        // make sure this node isn't already here


                        if (FindItemFromPath(hwndLB, (LPSTR)lParam, FALSE, NULL) != 0xFFFF)
                            break;

                        // Insert it into the tree listbox

                        dwTemp = InsertDirectory(hWnd, pNode, (WORD)nIndex, szPath, &pNodeT);

                        // Add a plus if necessary

                        hwndParent = GetParent(hWnd);
                        if (GetWindowLong(hwndParent, GWL_VIEW) & VIEW_PLUSES) {
                            lstrcpy(szPath, (LPSTR)lParam);
                            ScanDirLevel((PDNODE)pNodeT, szPath, ATTR_DIR |
                                         (GetWindowLong(hwndParent, GWL_ATTRIBS) & ATTR_HS));

                            // Invalidate the window so the plus gets drawn if needed

                            if (((PDNODE)pNodeT)->wFlags & TF_HASCHILDREN)
                                InvalidateRect(hWnd, NULL, FALSE);
                        }

                        // if we are inserting before or at the current selection
                        // push the current selection down

                        nIndex = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                        if ((INT)LOWORD(dwTemp) <= nIndex) {
                            SendMessage(hwndLB, LB_SETCURSEL, nIndex + 1, 0L);
                        }

                        break;

                    case FSC_RMDIR:
                        if (nIndex == 0)      /* NEVER delete the Root Dir! */
                            break;

                        if (pNode->wFlags & TF_LASTLEVELENTRY) {
                            // We are deleting the last subdirectory.
                            // If there are previous sibling directories, mark one
                            // as the last, else mark the parent as empty and unexpanded.
                            // It is necessary to do these checks if this bit
                            // is set, since if it isn't, there is another sibling
                            // with TF_LASTLEVELENTRY set, and so the parent is nonempty.
                            //
                            // Find the previous entry which has a level not deeper than
                            // the level of that being deleted.
                            i = (int)nIndex;
                            do {
                                SendMessage(hwndLB, LB_GETTEXT, --i, (LPARAM)&pNodePrev);
                            } while (pNodePrev->nLevels > pNode->nLevels);

                            if (pNodePrev->nLevels == pNode->nLevels) {
                                // The previous directory is a sibling... it becomes
                                // the new last level entry.
                                pNodePrev->wFlags |= TF_LASTLEVELENTRY;
                            } else {
                                // In order to find this entry, the parent must have
                                // been expanded, so if the parent of the deleted dir
                                // has no listbox entries under it, it may be assumed that
                                // the directory has no children.
                                pNodePrev->wFlags &= ~(TF_HASCHILDREN | TF_EXPANDED);
                            }
                        }

                        // Are we deleting the current selection?
                        // if so we move the selection to the item above the current.
                        // this should work in all cases because you can't delete
                        // the root.

                        if ((WPARAM)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L) == nIndex) {
                            SendMessage(hwndLB, LB_SETCURSEL, nIndex - 1, 0L);
                            SendMessage(hWnd, WM_COMMAND, GET_WM_COMMAND_MPS(0, 0, LBN_SELCHANGE));
                        }

                        SendMessage(hWnd, TC_COLLAPSELEVEL, nIndex, 0L);
                        SendMessage(hwndLB, LB_DELETESTRING, nIndex, 0L);

                        LocalFree((HANDLE)pNode);
                        break;
                }
                break;
            }

        case WM_COMMAND:
            {
                WORD id;

                id = GET_WM_COMMAND_ID(wParam, lParam);
                switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                    case LBN_SELCHANGE:
                        MSG("TreeControlWndProc", "LBN_SELCHANGE");
                        {
                            HWND hwndParent;
                            HWND hwndDir;
                            INT CurSel;

                            hwndParent = GetParent(hWnd);

                            CurSel = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                            SendMessage(hWnd, TC_GETDIR, CurSel,(LPARAM)szPath);
                            AddBackslash(szPath);
                            SendMessage(hwndParent, FS_GETFILESPEC,  sizeof(szPath) - lstrlen(szPath), (LPARAM)szPath+lstrlen(szPath));

                            if (hwndDir = HasDirWindow(hwndParent)) {
                                // update the dir window

                                id = CD_PATH;

                                // don't allow abort on first or last directories


                                if (CurSel > 0 &&
                                    CurSel != ((INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L) - 1)) {
                                    id = CD_PATH | CD_ALLOWABORT;

                                }
                                SendMessage(hwndDir, FS_CHANGEDISPLAY, id, (LPARAM)szPath);

                            } else {
                                SetMDIWindowText(hwndParent, szPath);
                            }

                            UpdateStatus(hwndParent);
                            break;
                        }

                    case LBN_DBLCLK:
                        MSG("TreeControlWndProc", "LBN_DBLCLK");
                        SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_OPEN, 0, 0));
                        break;

                    case LBN_SETFOCUS:
                        MSG("TreeControlWndProc", "LBN_SETFOCUS");
                        SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)GET_WM_COMMAND_HWND(wParam, lParam));
                        UpdateSelection(GET_WM_COMMAND_HWND(wParam, lParam));
                        UpdateStatus(GetParent(hWnd));  // update the status bar
                        break;

                    case LBN_KILLFOCUS:
                        MSG("TreeControlWndProc", "LBN_KILLFOCUS");
                        SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, 0);
                        UpdateSelection(GET_WM_COMMAND_HWND(wParam, lParam));
                        SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)GET_WM_COMMAND_HWND(wParam, lParam));
                        break;
                }
            }
            break;


        case WM_LBTRACKPOINT:
            MSG("TreeControlWndProc", "WM_LBTRACKPOINT");
            // wParam is the listbox index that we are over
            // lParam is the mouse point

            /* Return 0 to do nothing, 1 to abort everything, or 2 to abort just dblclicks. */

            {
                HDC       hdc;
                INT       dx;
                INT       xNode;
                MSG       msg;
                RECT      rc;
                HFONT     hOld;
                POINT     pt;
                DRAGOBJECTDATA dodata;

                /* Someone clicked somewhere in the listbox. */

                // don't do anything while the tree is being built

                if (GetWindowLong(hWnd, GWL_READLEVEL))
                    return 1;

                /* Get the node they clicked on. */
                SendMessage(hwndLB, LB_GETTEXT, wParam, (LPARAM)&pNode);
                lstrcpy(szPath, pNode->szName);
                if ((wTextAttribs & TA_LOWERCASE) && !(pNode->wFlags & TF_LFN))
                    AnsiLower(szPath);

                //        if (pNode->wFlags | TF_DISABLED)
                //              return 2L;

                // too FAR to the left?

                i = LOWORD(lParam);

                xNode = pNode->nLevels * dxText * 2;
                if (i < xNode)
                    return 2; // yes, get out now

                // too FAR to the right?

                hdc = GetDC(hwndLB);
                hOld = SelectObject(hdc, hFont);
                MGetTextExtent(hdc, szPath, lstrlen(szPath), &dx, NULL);
                dx += (dyBorderx2*2);
                if (hOld)
                    SelectObject(hdc, hOld);
                ReleaseDC(hwndLB, hdc);

                if (i > xNode + dxFolder + dx + 4 * dyBorderx2)
                    return 2; // yes

                // Emulate a SELCHANGE notification and notify our parent
                SendMessage(hwndLB, LB_SETCURSEL, wParam, 0L);
                SendMessage(hWnd, WM_COMMAND, GET_WM_COMMAND_MPS(0, hwndLB, LBN_SELCHANGE));

                // make sure mouse still down

                if (!(GetKeyState(VK_LBUTTON) & 0x8000))
                    return 1;

                MPOINT2POINT(MAKEMPOINT(lParam), pt);
                ClientToScreen(hwndLB, (LPPOINT)&pt);
                ScreenToClient(hWnd, (LPPOINT)&pt);


                SetRect(&rc, pt.x - dxClickRect, pt.y - dyClickRect,
                        pt.x + dxClickRect, pt.y + dyClickRect);

                SetCapture(hWnd);
                while (GetMessage(&msg, NULL, 0, 0)) {

                    DispatchMessage(&msg);
                    if (msg.message == WM_LBUTTONUP)
                        break;

                    MPOINT2POINT(MAKEMPOINT(msg.lParam), pt);

                    if (GetCapture() != hWnd) {
                        msg.message = WM_LBUTTONUP;
                        break;
                    }

                    if ((msg.message == WM_MOUSEMOVE) && !(PtInRect(&rc, pt)))
                        break;
                }
                ReleaseCapture();

                /* Did the guy NOT drag anything? */
                if (msg.message == WM_LBUTTONUP)
                    return 1;

                /* Enter Danger Mouse's BatCave. */
                SendMessage(GetParent(hWnd), FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                StripBackslash(szPath);
                hwndDragging = hwndLB;
                iCurDrag = SINGLECOPYCURSOR;
                dodata.pch = szPath;
                dodata.hMemGlobal = 0;
                DragObject(hwndMDIClient, hWnd, (UINT)DOF_DIRECTORY, (DWORD)(ULONG_PTR)&dodata, LoadCursor(hAppInstance, MAKEINTRESOURCE(iCurDrag)));
                hwndDragging = NULL;
                fShowSourceBitmaps = TRUE;
                InvalidateRect(hwndLB, NULL, FALSE);

                return 2;
            }

        case WM_DRAGSELECT:
            MSG("TreeControlWndProc", "WM_DRAGSELECT");
            /* WM_DRAGSELECT is sent whenever a new window returns TRUE to a
             * QUERYDROPOBJECT.
             */
            iSelHilite = LOWORD(((LPDROPSTRUCT)lParam)->dwControlData);
            RectTreeItem(hwndLB, iSelHilite, (BOOL)wParam);
            break;

        case WM_DRAGMOVE:
            MSG("TreeControlWndProc", "WM_DRAGMOVE");

            /* WM_DRAGMOVE is sent when two consequetive TRUE QUERYDROPOBJECT
             * messages come from the same window.
             */

            /* Get the subitem we are over. */
            iSel = LOWORD(((LPDROPSTRUCT)lParam)->dwControlData);

            /* Is it a new one? */
            if (iSel == (WORD)iSelHilite)
                break;

            /* Yup, un-select the old item. */
            RectTreeItem(hwndLB, iSelHilite, FALSE);

            /* Select the new one. */
            iSelHilite = iSel;
            RectTreeItem(hwndLB, iSel, TRUE);
            break;

        case WM_DRAGLOOP:
            MSG("TreeControlWndProc", "WM_DRAGLOOP");

            // wParam     TRUE on dropable target
            //            FALSE not dropable target
            // lParam     lpds
            {
                BOOL bCopy;

#define lpds ((LPDROPSTRUCT)lParam)

                /* Are we over a drop-able sink? */
                if (wParam) {
                    if (GetKeyState(VK_CONTROL) < 0)      // CTRL
                        bCopy = TRUE;
                    else if (GetKeyState(VK_MENU)<0 || GetKeyState(VK_SHIFT)<0)   // ALT || SHIFT
                        bCopy = FALSE;
                    else
                        bCopy = (GetDrive(lpds->hwndSink, lpds->ptDrop) != GetDrive(lpds->hwndSource, lpds->ptDrop));
                } else {
                    bCopy = TRUE;
                }

                if (bCopy != fShowSourceBitmaps) {
                    RECT  rc;

                    fShowSourceBitmaps = bCopy;

                    iSel = (WORD)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);

                    if (!(BOOL)SendMessage(hwndLB, LB_GETITEMRECT, iSel, (LPARAM)&rc))
                        break;

                    InvalidateRect(hwndLB, &rc, FALSE);
                    UpdateWindow(hwndLB);

                    // hack, set the cursor to match the move/copy state
                    if (wParam)
                        SetCursor(GetMoveCopyCursor());
                }
                break;
            }

        case WM_QUERYDROPOBJECT:
            MSG("TreeControlWndProc", "WM_QUERYDROPOBJECT");
            // wParam     TRUE on NC area
            //            FALSE on client area
            // lParam     lpds

            // Do nothing
            return(FALSE);

#define lpds ((LPDROPSTRUCT)lParam)

            /* Check for valid format. */
            switch (lpds->wFmt) {
                case DOF_EXECUTABLE:
                case DOF_DOCUMENT:
                case DOF_DIRECTORY:
                case DOF_MULTIPLE:
                    if (fShowSourceBitmaps)
                        i = iCurDrag | 1;       // copy
                    else
                        i = iCurDrag & 0xFFFE;
                    break;

                default:
                    return FALSE;
            }

            /* Must be dropping on the listbox client area. */
            if (lpds->hwndSink != hwndLB)
                return FALSE;

            if (LOWORD(lpds->dwControlData) == 0xFFFF)
                return FALSE;

            return (INT_PTR)GetMoveCopyCursor();

        case WM_DROPOBJECT:       // tree being dropped on do your thing
#define lpds ((LPDROPSTRUCT)lParam) // BUG: WM_DROPOBJECT structure packing!

            // Do nothing
            return(TRUE);

            MSG("TreeControlWndProc", "WM_DROPOBJECT");

            // dir (search) drop on tree:
            //    HIWORD(dwData)  0
            //    LOWORD(dwData)  LPSTR to files being dragged
            //
            // tree drop on tree:
            //    HIWORD(dwData)  index of source drag
            //    LOWORD(dwData)  LPSTR to path

            {
                LPSTR      pFrom;

                nIndex = LOWORD(lpds->dwControlData);
                pFrom = (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch);

                // Get the destination

                SendMessage(hWnd, TC_GETDIR, nIndex, (LPARAM)szPath);
                CheckEscapes(szPath);

                // if source and dest are the same make this a NOP

                if (!lstrcmpi(szPath, pFrom))
                    return TRUE;

                AddBackslash(szPath);
                lstrcat(szPath, szStarDotStar);

                DMMoveCopyHelper(pFrom, szPath, fShowSourceBitmaps);

                RectTreeItem(hwndLB, (int)nIndex, FALSE);
            }
            return TRUE;
#undef lpds

        case WM_MEASUREITEM:
            MSG("TreeControlWndProc", "WM_MEASUREITEM");
#define pLBMItem ((LPMEASUREITEMSTRUCT)lParam)

            pLBMItem->itemHeight = (WORD)dyFileName;
            break;

        case WM_VKEYTOITEM:
            MSG("TreeControlWndProc", "WM_VKEYTOITEM");
            if (wParam == VK_ESCAPE) {
                bCancelTree = TRUE;
                return -2L;
            }

            i = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
            if (i < 0)
                return -2L;

            j = 1;
            SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&pNode);

            switch (GET_WM_VKEYTOITEM_ITEM(wParam, lParam)) {
                case VK_LEFT:
                    while (SendMessage(hwndLB, LB_GETTEXT, --i, (LPARAM)&pNodeNext) != LB_ERR) {
                        if (pNode == pNode->pParent)
                            return(i);
                    }
                    goto SameSelection;

                case VK_RIGHT:
                    if ((SendMessage(hwndLB, LB_GETTEXT, i+1, (LPARAM)&pNodeNext) == LB_ERR)
                        || (pNodeNext->pParent != pNode)) {
                        goto SameSelection;
                    }
                    return(i+1);

                case VK_UP:
                    j = -1;
                    /** FALL THRU ***/

                case VK_DOWN:
                    /* If the control key is not down, use default behavior. */
                    if (GetKeyState(VK_CONTROL) >= 0)
                        return(-1L);

                    while (SendMessage(hwndLB, LB_GETTEXT, i += j, (LPARAM)&pNodeNext) != LB_ERR) {
                        if (pNodeNext->pParent == pNode->pParent)
                            return(i);
                    }

                    SameSelection:
                    MessageBeep(0);
                    return(-2L);

                case VK_F6:       // like excel
                case VK_TAB:
                    {
                        HWND hwndDir, hwndDrives;
                        BOOL bDir;

                        GetTreeWindows(GetParent(hWnd), NULL, &hwndDir, &hwndDrives);

                        // Check to see if we can change to the directory window

                        if (hwndDir) {
                            HWND hwndLB; /* Local scope ONLY */

                            hwndLB = GetDlgItem (hwndDir,IDCW_LISTBOX);
                            if (hwndLB) {
                                SendMessage (hwndLB,LB_GETTEXT,0, (LPARAM) &pNode);
                                bDir = pNode ? TRUE : FALSE;
                            }
                        }

                        if (GetKeyState(VK_SHIFT) < 0)
                            SetFocus(hwndDrives);
                        else
                            if (bDir)
                            SetFocus (hwndDir);
                        else
                            SetFocus (hwndDrives);
                        return -2L;   // I dealt with this!
                    }

                case VK_BACK:
                    {
                        BYTE nStartLevel;

                        if (i <= 0)
                            return -2L;     // root case

                        nStartLevel = pNode->nLevels;

                        do {
                            SendMessage(hwndLB, LB_GETTEXT, --i, (LPARAM)&pNodeNext);
                        } while (i > 0 && pNodeNext->nLevels >= nStartLevel);

                        return i;
                    }

                default:
                    if (GetKeyState(VK_CONTROL) < 0)
                        return SendMessage(GetDlgItem(GetParent(hWnd), IDCW_DRIVES), wMsg, wParam, lParam);
                    return -1L;
            }
            break;

        case WM_SETFOCUS:
        case WM_LBUTTONDOWN:
            MSG("TreeControlWndProc", "WM_LBUTTONDOWN");
            SetFocus(hwndLB);
            break;

        case WM_SIZE:
            MSG("TreeControlWndProc", "WM_SIZE");
            if (!IsIconic(GetParent(hWnd))) {
                INT iMax;

                MoveWindow(hwndLB, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);

                iMax = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                if (iMax >= 0) {
                    RECT rc;
                    INT top, bottom;

                    GetClientRect(hwndLB, &rc);
                    top = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
                    bottom = top + rc.bottom / dyFileName;
                    if (iMax < top || iMax > bottom)
                        SendMessage(hwndLB, LB_SETTOPINDEX, iMax - ((bottom - top) / 2), 0L);
                }
            }
            break;

        default:
            DEFMSG("TreeControlWndProc", (WORD)wMsg);
            return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\lfn.c ===
/* lfn.c -
 *
 *  This file contains code that combines winnet long filename API's and
 *  the DOS INT 21h API's into a single interface.  Thus, other parts of
 *  Winfile call a single piece of code with no worries about the
 *  underlying interface.
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "winfile.h"
#include "object.h"
#include "lfn.h"                            // lfn includes
#include "dosfunc.h"
#include "winnet.h"
#include "wnetcaps.h"           // WNetGetCaps()
#include "wfcopy.h"

BOOL  APIENTRY IsFATName(LPSTR pName);

#define CDRIVEMAX       26

#define BUFSIZE         2048                // ff/fn buffer size

#define MAXFILES        1024

/* this is the internal buffer maintained for ff/fn operations
 */
typedef struct _find {
    HANDLE hDir;                    // search handle
    WORD cbBuffer;                  // buffer size
    WORD nEntriesLeft;              // remaining entries
    WORD ibEntry;                   // offset of next entry to return
    FILEFINDBUF2 rgFindBuf[1];      // array of find entries
} FIND, * LPFIND;


/* this structure contains an array of drives types (ie, unknown, FAT, LFN)
 * and a pointer to each of the driver functions.  It is declared this way
 * in order to get function prototypes.
 */
typedef struct _lfninfo {
    UINT hDriver;
    INT rgVolType[CDRIVEMAX];
    FARPROC lpfnQueryAbort;
    WORD ( APIENTRY *lpFindFirst)(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
    WORD ( APIENTRY *lpFindNext)(HANDLE,LPINT,WORD,PFILEFINDBUF2);
    WORD ( APIENTRY *lpFindClose)(HANDLE);
    WORD ( APIENTRY *lpGetAttribute)(LPSTR,LPINT);
    WORD ( APIENTRY *lpSetAttribute)(LPSTR,WORD);
    WORD ( APIENTRY *lpCopy)(LPSTR,LPSTR,PQUERYPROC);
    WORD ( APIENTRY *lpMove)(LPSTR,LPSTR);
    WORD ( APIENTRY *lpDelete)(LPSTR);
    WORD ( APIENTRY *lpMKDir)(LPSTR);
    WORD ( APIENTRY *lpRMDir)(LPSTR);
    WORD ( APIENTRY *lpGetVolumeLabel)(WORD,LPSTR);
    WORD ( APIENTRY *lpSetVolumeLabel)(WORD,LPSTR);
    WORD ( APIENTRY *lpParse)(LPSTR,LPSTR,LPSTR);
    WORD ( APIENTRY *lpVolumeType)(WORD,LPINT);
} LFNINFO, * PLFNINFO;

/* pointer to lfn information, so we don't take up a lot of space on a
 * nonlfn system
 */
PLFNINFO pLFN = NULL;


VOID HandleSymbolicLink(HANDLE  DirectoryHandle, PCHAR ObjectName);


/* WFFindFirst -
 *
 * returns:
 *      TRUE for success - lpFind->fd,hFindFileset,attrFilter set.
 *      FALSE for failure
 *
 *  Performs the FindFirst operation and the first WFFindNext.
 */

BOOL
APIENTRY
WFFindFirst(
           LPLFNDTA lpFind,
           LPSTR lpName,
           DWORD dwAttrFilter
           )
{
    // We OR these additional bits because of the way DosFindFirst works
    // in Windows. It returns the files that are specified by the attrfilter
    // and ORDINARY files too.

#define BUFFERSIZE  1024



#define Error(N,S) {                \
    DbgPrint(#N);                    \
    DbgPrint(" Error %08lX\n", S);   \
    }

    CHAR    Buffer[BUFFERSIZE];
    NTSTATUS    Status;
    HANDLE DirectoryHandle;
    ULONG Context = 0;
    ULONG ReturnedLength;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    INT     length;

    lpFind->hFindFile = INVALID_HANDLE_VALUE;
    //DbgPrint("Find first : <%s>\n", lpName);

    // Remove drive letter
    while ((*lpName != 0) && (*lpName != '\\')) {
        lpName ++;
    }
    strcpy(Buffer, lpName);
    length = strlen(Buffer);
    length -= 4;    // Remove '\'*.*
    if (length == 0) {
        length = 1; // Replace the '\'
    }
    Buffer[length] = 0; // Truncate the string at the appropriate point

    //DbgPrint("Find first modified : <%s>\n\r", Buffer);


#define NEW
#ifdef NEW


    //
    //  Open the directory for list directory access
    //

    {
        OBJECT_ATTRIBUTES Attributes;
        ANSI_STRING DirectoryName;
        UNICODE_STRING UnicodeString;


        RtlInitAnsiString(&DirectoryName, Buffer);
        Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                               &DirectoryName,
                                               TRUE );
        ASSERT( NT_SUCCESS( Status ) );
        InitializeObjectAttributes( &Attributes,
                                    &UnicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );
        if (!NT_SUCCESS( Status = NtOpenDirectoryObject( &DirectoryHandle,
                                                         STANDARD_RIGHTS_READ |
                                                         DIRECTORY_QUERY |
                                                         DIRECTORY_TRAVERSE,
                                                         &Attributes ) )) {

            RtlFreeUnicodeString(&UnicodeString);

            if (Status == STATUS_OBJECT_TYPE_MISMATCH) {
                DbgPrint("%Z is not a valid Object Directory Object name\n",
                         &DirectoryName );
            } else {
                DbgPrint("%Z - ", &DirectoryName );
                Error( OpenDirectory, Status );
            }
            return FALSE;
        }

        RtlFreeUnicodeString(&UnicodeString);
    }

    Status = NtQueryDirectoryObject( DirectoryHandle,
                                     &Buffer,
                                     BUFFERSIZE,
                                     TRUE,
                                     TRUE,
                                     &Context,
                                     &ReturnedLength );
    if (!NT_SUCCESS( Status )) {
        Error(Find_First_QueryDirectory, Status);
        return (FALSE);
    }

    //
    //  For every record in the buffer type out the directory information
    //

    //
    //  Point to the first record in the buffer, we are guaranteed to have
    //  one otherwise Status would have been No More Files
    //

    DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

    //
    //  Check if there is another record.  If there isn't, then get out
    //  of the loop now
    //

    if (DirInfo->Name.Length == 0) {
        DbgPrint("FindFirst - name length = 0\n\r");
        return (FALSE);
    }

    {
        ANSI_STRING AnsiString;
        AnsiString.Buffer = lpFind->fd.cFileName;
        AnsiString.MaximumLength = sizeof(lpFind->fd.cFileName);

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &(DirInfo->Name), FALSE);
        ASSERT(NT_SUCCESS(Status));
    }

    //DbgPrint("FindFirst returning <%s>\n\r", lpFind->fd.cFileName);

    // Calculate the attribute field

    lpFind->fd.dwFileAttributes = CalcAttributes(&DirInfo->TypeName);

    #ifdef LATER
    if (lpFind->fd.dwFileAttributes == ATTR_SYMLINK) {
        HandleSymbolicLink(DirectoryHandle, lpFind->fd.cFileName);
    }

    // Label an unknown object type
    if (lpFind->fd.dwFileAttributes == 0) { // Unknown type
        strncat(lpFind->fd.cFileName, " (", MAX_PATH - strlen(lpFind->fd.cFileName));
        strncat(lpFind->fd.cFileName, DirInfo->TypeName.Buffer,
                MAX_PATH - strlen(lpFind->fd.cFileName));
        strncat(lpFind->fd.cFileName, ")", MAX_PATH - strlen(lpFind->fd.cFileName));
    }
    #endif

    // Save our search context

    lpFind->hFindFile = DirectoryHandle;
    lpFind->err = Context;

    return (TRUE);

#else
    dwAttrFilter |= ATTR_ARCHIVE | ATTR_READONLY | ATTR_NORMAL;
    lpFind->hFindFile = FindFirstFile(lpName, &lpFind->fd);
    if (lpFind->hFindFile != (HANDLE)0xFFFFFFFF) {
        lpFind->dwAttrFilter = dwAttrFilter;
        if ((~dwAttrFilter & lpFind->fd.dwFileAttributes) == 0L ||
            WFFindNext(lpFind)) {
            PRINT(BF_PARMTRACE, "WFFindFirst:%s", &lpFind->fd.cFileName);
            return (TRUE);
        } else {
            lpFind->err = GetLastError();
            WFFindClose(lpFind);
            return (FALSE);
        }
    } else {
        return (FALSE);
    }
#endif

}



/* WFFindNext -
 *
 *  Performs a single file FindNext operation.  Only returns TRUE if a
 *  file matching the dwAttrFilter is found.  On failure WFFindClose is
 *  called.
 */
BOOL
APIENTRY
WFFindNext(
          LPLFNDTA lpFind
          )
{
    CHAR    Buffer[BUFFERSIZE];
    NTSTATUS    Status;
    HANDLE DirectoryHandle = lpFind->hFindFile;
    ULONG Context = lpFind->err;
    ULONG ReturnedLength;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;

#ifdef NEW

    //ASSERT(lpFind->hFindFile != (HANDLE)0xFFFFFFFF);

    Status = NtQueryDirectoryObject( DirectoryHandle,
                                     &Buffer,
                                     BUFFERSIZE,
                                     TRUE,
                                     FALSE,
                                     &Context,
                                     &ReturnedLength );
    if (!NT_SUCCESS( Status )) {
        if (Status != STATUS_NO_MORE_ENTRIES) {
            Error(FindNext_QueryDirectory, Status);
        }

        return (FALSE);
    }

    //
    //  For every record in the buffer type out the directory information
    //

    //
    //  Point to the first record in the buffer, we are guaranteed to have
    //  one otherwise Status would have been No More Files
    //

    DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

    //
    //  Check if there is another record.  If there isn't, then get out
    //  of the loop now
    //

    if (DirInfo->Name.Length == 0) {
        DbgPrint("FindNext - name length = 0\n\r");
        return (FALSE);
    }

    {
        ANSI_STRING AnsiString;
        AnsiString.Buffer = lpFind->fd.cFileName;
        AnsiString.MaximumLength = sizeof(lpFind->fd.cFileName);

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &(DirInfo->Name), FALSE);
        ASSERT(NT_SUCCESS(Status));
    }

    //DbgPrint("FindNext returning <%s>\n\r", lpFind->fd.cFileName);

    // Calculate the attribute field

    lpFind->fd.dwFileAttributes = CalcAttributes(&DirInfo->TypeName);

    #ifdef LATER
    if (lpFind->fd.dwFileAttributes == ATTR_SYMLINK) {
        HandleSymbolicLink(DirectoryHandle, lpFind->fd.cFileName);
    }

    // Label an unknown object type
    if (lpFind->fd.dwFileAttributes == 0) { // Unknown type
        strncat(lpFind->fd.cFileName, " (", MAX_PATH - strlen(lpFind->fd.cFileName));
        strncat(lpFind->fd.cFileName, DirInfo->TypeName.Buffer,
                MAX_PATH - strlen(lpFind->fd.cFileName));
        strncat(lpFind->fd.cFileName, ")", MAX_PATH - strlen(lpFind->fd.cFileName));
    }
    #endif

    // Save our search context

    lpFind->err = Context;

    return (TRUE);

#else
    #ifdef DBG
    if (lpFind->hFindFile == (HANDLE)0xFFFFFFFF) {
        DebugBreak();
        return (FALSE);
    }
    #endif
    while (FindNextFile(lpFind->hFindFile, &lpFind->fd)) {
        if ((lpFind->fd.dwFileAttributes & ~lpFind->dwAttrFilter) != 0)
            continue;           // only pick files that fit attr filter
        PRINT(BF_PARMTRACE, "WFFindNext:%s", &lpFind->fd.cFileName);
        return (TRUE);
    }
    lpFind->err = GetLastError();
    return (FALSE);
#endif

}


/* WFFindClose -
 *
 *  performs the find close operation
 */
BOOL
APIENTRY
WFFindClose(
           LPLFNDTA lpFind
           )
{
    HANDLE DirectoryHandle = lpFind->hFindFile;
    BOOL bRet;

#ifdef NEW
    if (lpFind->hFindFile != INVALID_HANDLE_VALUE) {
        (VOID) NtClose( DirectoryHandle );
        lpFind->hFindFile = INVALID_HANDLE_VALUE;
    }

    return (TRUE);

#else
    ENTER("WFFindClose");
//    ASSERT(lpFind->hFindFile != (HANDLE)0xFFFFFFFF);
    #ifdef DBG
    if (lpFind->hFindFile == (HANDLE)0xFFFFFFFF) {
        PRINT(BF_PARMTRACE, "WFFindClose:Invalid hFindFile = 0xFFFFFFFF","");
        return (FALSE);
    }
    #endif

    bRet = FindClose(lpFind->hFindFile);
    #ifdef DBG
    lpFind->hFindFile = (HANDLE)0xFFFFFFFF;
    #endif

    LEAVE("WFFindClose");
    return (bRet);
#endif

}


VOID
HandleSymbolicLink(
                  HANDLE  DirectoryHandle,
                  PCHAR   ObjectName
                  ) // Assumes this points at a MAX_PATH length buffer
{
    NTSTATUS    Status;
    OBJECT_ATTRIBUTES   Object_Attributes;
    HANDLE      LinkHandle;
    STRING      String;
    WCHAR       UnicodeBuffer[MAX_PATH];
    UNICODE_STRING UnicodeString;
    INT         Length;

    RtlInitString(&String, ObjectName);
    Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                           &String,
                                           TRUE );
    ASSERT( NT_SUCCESS( Status ) );

    InitializeObjectAttributes(&Object_Attributes,
                               &UnicodeString,
                               0,
                               DirectoryHandle,
                               NULL
                              );

    // Open the given symbolic link object
    Status = NtOpenSymbolicLinkObject(&LinkHandle,
                                      GENERIC_ALL,
                                      &Object_Attributes);

    RtlFreeUnicodeString(&UnicodeString);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("HandleSymbolicLink : open symbolic link failed, status = %lx\n\r", Status);
        return;
    }


    strcat(ObjectName, " => ");
    Length = strlen(ObjectName);

    // Set up our String variable to point at the remains of the object name buffer
    String.Length = 0;
    String.MaximumLength = (USHORT)(MAX_PATH - Length);
    String.Buffer = &(ObjectName[Length]);

    // Go get the target of the symbolic link
    UnicodeString.Buffer = UnicodeBuffer;
    UnicodeString.MaximumLength = sizeof(UnicodeBuffer);

    Status = NtQuerySymbolicLinkObject(LinkHandle, &UnicodeString, NULL);

    NtClose(LinkHandle);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("HandleSymbolicLink : query symbolic link failed, status = %lx\n\r", Status);
        return;
    }

    // Copy the symbolic target into return buffer
    Status = RtlUnicodeStringToAnsiString(&String, &UnicodeString, FALSE);
    ASSERT(NT_SUCCESS(Status));

    // Add NULL terminator
    String.Buffer[String.Length] = 0;

    return;
}


/* WFIsDir
 *
 *  Determines if the specified path is a directory
 */
BOOL
APIENTRY
WFIsDir(
       LPSTR lpDir
       )
{
    DWORD attr = GetFileAttributes(lpDir);

    if (attr & 0x8000)  // BUG: what is this constant???
        return FALSE;

    if (attr & ATTR_DIR)
        return TRUE;

    return FALSE;
}


/* LFNQueryAbort -
 *
 *  wraps around WFQueryAbort and is exported/makeprocinstanced
 */

BOOL
APIENTRY
LFNQueryAbort(
             VOID
             )
{
    return WFQueryAbort();
}

/* LFNInit -
 *
 *  Initializes stuff for LFN access
 */

VOID
APIENTRY
LFNInit()
{
    INT i;

    /* find out if long names are supported.
     */
    if (!(WNetGetCaps(WNNC_ADMIN) & WNNC_ADM_LONGNAMES))
        return;

    /* get the buffer
     */
    pLFN = (PLFNINFO)LocalAlloc(LPTR,sizeof(LFNINFO));
    if (!pLFN)
        return;

    /* get the handle to the driver
     */
    if (!(pLFN->hDriver = WNetGetCaps((WORD)0xFFFF))) {
        LocalFree((HANDLE)pLFN);
        pLFN = NULL;
        return;
    }

    /* set all the volume types to unknown
     */
    for (i = 0; i < CDRIVEMAX; i++) {
        pLFN->rgVolType[i] = -1;
    }
}

/* GetNameType -
 *
 *  Shell around LFNParse.  Classifies name.
 *
 *  NOTE: this should work on unqualified names.  currently this isn't
 *        very useful.
 */
WORD
APIENTRY
GetNameType(
           LPSTR lpName
           )
{
    if (*(lpName+1) == ':') {
        if (!IsLFNDrive(lpName))
            return FILE_83_CI;
    } else if (IsFATName(lpName))
        return FILE_83_CI;

    return (FILE_LONG);
}

BOOL
APIENTRY
IsFATName(
         LPSTR pName
         )
{
    INT  cdots = 0;
    INT  cb;
    INT  i;
    INT  iFirstDot;


    cb = lstrlen(pName);
    if (cb > 12) {
        return FALSE;
    } else {
        for (i = 0; i < cb; i++) {
            if (pName[i] == '.') {
                iFirstDot = cdots ? iFirstDot : i;
                cdots++;
            }
        }

        if (cdots == 0 && cb <= 8)
            return TRUE;
        else if (cdots != 1)
            return FALSE;
        else if (cdots == 1 && iFirstDot > 8)
            return FALSE;
        else
            return TRUE;
    }

}

BOOL
APIENTRY
IsLFN(
     LPSTR pName
     )
{
    return !IsFATName(pName);
}

BOOL
APIENTRY
LFNMergePath(
            LPSTR pTo,
            LPSTR pFrom
            )
{
    PRINT(BF_PARMTRACE, "LFNMergePath:basically a NOP", "");
    pTo; pFrom;
    return (FALSE);
}

/* InvalidateVolTypes -
 *
 *  This function sets all drive types to unknown.  It should be called
 *  whenever the drive list is refreshed.
 */

VOID
APIENTRY
InvalidateVolTypes( VOID )
{
    INT i;

    if (!pLFN)
        return;

    for (i = 0; i < CDRIVEMAX; i++)
        pLFN->rgVolType[i] = -1;
}


/* WFCopy
 *
 *  Copies files
 */
WORD
APIENTRY
WFCopy(
      PSTR pszFrom,
      PSTR pszTo
      )
{
    WORD wRet;

    Notify(hdlgProgress, IDS_COPYINGMSG, pszFrom, pszTo);

    wRet = FileCopy(pszFrom,pszTo);

    if (!wRet)
        ChangeFileSystem(FSC_CREATE,pszTo,NULL);

    return wRet;
}

/* WFRemove
 *
 *  Deletes files
 */
WORD
APIENTRY
WFRemove(
        PSTR pszFile
        )
{
    WORD wRet;

    wRet = FileRemove(pszFile);
    if (!wRet)
        ChangeFileSystem(FSC_DELETE,pszFile,NULL);

    return wRet;
}

/* WFMove
 *
 *  Moves files on a volume
 */
WORD
APIENTRY
WFMove(
      PSTR pszFrom,
      PSTR pszTo
      )
{
    WORD wRet;

    wRet = FileMove(pszFrom,pszTo);
    if (!wRet)
        ChangeFileSystem(FSC_RENAME,pszFrom,pszTo);

    return wRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfcomman.c ===
/****************************************************************************/
/*                                                                          */
/*  WFCOMMAN.C -                                                            */
/*                                                                          */
/*      Windows File System Command Proc                                    */
/*                                                                          */
/****************************************************************************/
#include <nt.h>


#include <ntrtl.h>


#include <nturtl.h>



#include "winfile.h"
#include "object.h"
#include "lfn.h"
#include "wfcopy.h"
#include "winnet.h"
#include "wnetcaps.h"           // WNetGetCaps()
#define HELP_PARTIALKEY 0x0105L   /* call the search engine in winhelp */


HWND LocateDirWindow(LPSTR pszPath, BOOL bDirOnly);
VOID AddNetMenuItems(VOID);

VOID InitNetMenuItems(VOID);



VOID
NotifySearchFSC(
               PSTR pszPath,
               WORD wFunction
               )
{
    CHAR szPath[MAXPATHLEN];

    if (!hwndSearch)
        return;

    SendMessage(hwndSearch, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);

    if (DRIVEID(pszPath) == DRIVEID(szPath)) {
        SendMessage(hwndSearch, WM_FILESYSCHANGE, wFunction, 0L);
    }
}




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  LocateDirWindow() -                                                     */
/*                                                                          */
// bDirOnly     TRUE if pszPath does not contain a filespec
/*--------------------------------------------------------------------------*/

HWND
LocateDirWindow(
               LPSTR pszPath,
               BOOL bDirOnly
               )
{
    register HWND hwndT;
    HWND hwndDir;
    LPSTR pT2;
    CHAR szTemp[MAXPATHLEN];
    CHAR szPath[MAXPATHLEN];

    pT2 = pszPath;

    /* Only work with well-formed pathes. */
    if (lstrlen(pT2) < 3)
        return NULL;

    if (IsDBCSLeadByte( pT2[0] ) || pT2[1] != ':')
        return NULL;

    lstrcpy(szPath, pT2);

    if (!bDirOnly)                // remove extension stuff
        StripFilespec(szPath);

    for (hwndT = GetWindow(hwndMDIClient, GW_CHILD);
        hwndT;
        hwndT = GetWindow(hwndT, GW_HWNDNEXT)) {

        if (hwndDir = HasDirWindow(hwndT)) {

            // Get the Window's path information, remove the extension file spec

            GetMDIWindowText(hwndT, szTemp, sizeof(szTemp));
            StripFilespec(szTemp);

            /* No need to worry about the window's filespec. */
            if (!lstrcmpi(szTemp, szPath))
                break;
        }
    }

    return hwndT;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  EnableFSC() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
EnableFSC()
{
    HWND hwnd;

    if (--cDisableFSC)
        return;

    for (hwnd = GetWindow(hwndMDIClient,GW_CHILD);
        hwnd;
        hwnd = GetWindow(hwnd,GW_HWNDNEXT)) {
        // a tree or search window

        if (!GetWindow(hwnd, GW_OWNER) && GetWindowLong(hwnd,GWL_FSCFLAG))
            SendMessage(hwnd,WM_FILESYSCHANGE,FSC_REFRESH,0L);
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DisableFSC() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
DisableFSC()
{
    cDisableFSC++;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ChangeFileSystem() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* There are two sources of FileSysChange messages.  They can be sent from
 * the 386 WinOldAp or they can be posted by WINFILE's callback function (i.e.
 * from Kernel).  In both cases, we are free to do processing at this point.
 * For posted messages, we have to free the buffer passed to us as well.
 *
 * we are really in the other tasks context when we get entered here.
 * (this routine should be in a DLL)
 *
 * the file names are partially qualified, they have at least a drive
 * letter and initial directory part (c:\foo\..\bar.txt) so our
 * QualifyPath() calls should work.
 */

VOID
APIENTRY
ChangeFileSystem(
                register WORD wFunction,
                LPSTR lpszFile,
                LPSTR lpszTo
                )
{
    HWND                 hwnd, hwndTC;
    HWND          hwndOld;
    CHAR          szFrom[MAXPATHLEN];
    CHAR          szTo[MAXPATHLEN];
    CHAR          szTemp[MAXPATHLEN];
    CHAR          szPath[MAXPATHLEN + MAXPATHLEN];

    ENTER("ChangeFileSystem");
    OemToAnsi(lpszFile,szFrom);
    QualifyPath(szFrom);  // already partly qualified

    /* Handle cases where we're passed a DOS function number rather
     * than an FSC index (for the Kernel callback).
     */
    if (wFunction & 0x8000) {
        switch (wFunction & 0x7FFF) {
            case 0x56:
                wFunction = FSC_RENAME;
                break;

            case 0x3C:
            case 0x5A:
            case 0x5B:
            case 0x6C:
                wFunction = FSC_CREATE;
                break;

            case 0x41:
                wFunction = FSC_DELETE;
                break;

            case 0x43:
                wFunction = FSC_ATTRIBUTES;
                break;

            case 0x39:
                wFunction = FSC_MKDIR;
                break;

            case 0x3A:
                wFunction = FSC_RMDIR;
                break;
        }
    }

    bFileSysChanging = TRUE;

    // as FSC messages come in from outside winfile
    // we set a timer, and when that expires we
    // refresh everything.  if another FSC comes in while
    // we are waiting on this timer we reset it so we
    // only refresh on the last operations.  this lets
    // the timer be much shorter

    if (cDisableFSC == 0 || bFSCTimerSet) {
        if (bFSCTimerSet)
            KillTimer(hwndFrame, 1);                // reset the timer
        if (SetTimer(hwndFrame, 1, 1000, NULL)) {       // 1 second

            bFSCTimerSet = TRUE;
            if (cDisableFSC == 0)                   // only disable once
                DisableFSC();
        }
    }

    switch (wFunction) {
        case FSC_RENAME:
            OemToAnsi(lpszTo,szTo);
            QualifyPath(szTo);    // already partly qualified

            NotifySearchFSC(szFrom, wFunction);

            /* Update the original directory window (if any). */
            if (hwndOld = LocateDirWindow(szFrom, FALSE))
                SendMessage(hwndOld, WM_FILESYSCHANGE, wFunction, (LPARAM)szFrom);

            NotifySearchFSC(szTo, wFunction);

            /* Update the new directory window (if any). */
            if ((hwnd = LocateDirWindow(szTo, FALSE)) && (hwnd != hwndOld))
                SendMessage(hwnd, WM_FILESYSCHANGE, wFunction, (LPARAM)szTo);

            /* Are we renaming a directory? */
            lstrcpy(szTemp, szTo);
            FixAnsiPathForDos(szTemp);
            if (GetFileAttributes(szTemp) & ATTR_DIR) {

                for (hwnd = GetWindow(hwndMDIClient, GW_CHILD);
                    hwnd;
                    hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                    if (hwndTC = HasTreeWindow(hwnd)) {

                        // if the current selection is szFrom, we update the
                        // selection after the rename occurs

                        SendMessage(hwnd, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                        StripBackslash(szPath);

                        // add the new name first

                        SendMessage(hwndTC, WM_FILESYSCHANGE, FSC_MKDIR, (LPARAM)szTo);

                        // update the selection if necessary, also
                        // change the window text in this case to
                        // reflect the new name

                        if (!lstrcmpi(szPath, szFrom)) {
                            SendMessage(hwndTC, TC_SETDIRECTORY, FALSE, (LPARAM)szTo);

                            lstrcpy(szPath, szTo);

                            // update the window title

                            AddBackslash(szPath);
                            SendMessage(hwnd, FS_GETFILESPEC, MAXPATHLEN, (LPARAM)szPath + lstrlen(szPath));
                            // if (wTextAttribs & TA_LOWERCASE)
                            //         AnsiLower(szPath);

                            SetMDIWindowText(hwnd, szPath);
                        }

                        SendMessage(hwndTC, WM_FILESYSCHANGE, FSC_RMDIR, (LPARAM)szFrom);
                    }
                }
            }
            break;

        case FSC_RMDIR:
            /* Close any open directory window. */
            if ((hwnd = LocateDirWindow(szFrom, TRUE)) && !HasTreeWindow(hwnd))
                SendMessage(hwnd, WM_CLOSE, 0, 0L);
            /*** FALL THRU ***/

        case FSC_MKDIR:
            {
                HWND hwnd;
                HWND hwndTree;
                /* Update the tree. */

                for (hwnd = GetWindow(hwndMDIClient, GW_CHILD);
                    hwnd;
                    hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                    if (hwndTree = HasTreeWindow(hwnd)) {

                        SendMessage(hwndTree, WM_FILESYSCHANGE, wFunction, (LPARAM)szFrom);
                    }
                }
            }
            /*** FALL THRU ***/

        case FSC_DELETE:
        case FSC_CREATE:
        case FSC_REFRESH:
        case FSC_ATTRIBUTES:

            lFreeSpace = -1L;     // cause this stuff to be refreshed


            if (hwnd = LocateDirWindow(szFrom, FALSE))
                SendMessage(hwnd, WM_FILESYSCHANGE, wFunction, (LPARAM)szFrom);

            NotifySearchFSC(szFrom, wFunction);

            break;
    }

    bFileSysChanging = FALSE;
    LEAVE("ChangeFileSystem");
}

//
// HWND  APIENTRY CreateTreeWindow(LPSTR szPath, int dxSplit)
//
// creates a tree window with all the extras
//
// in:
//      szPath  fully qualified ANSI path name WITH filespec
//      dxSplit split position of tree and dir windows, if this is
//              less than the threshold a tree will not be created,
//              if it is more then a dir will not be created.
//              0 to create a dir only
//              very large number for tree only
//              < 0 to have the split put in the middle
// returns:
//      the hwnd of the mdi child created
//

HWND
APIENTRY
CreateTreeWindow(
                LPSTR szPath,
                INT dxSplit
                )
{
    MDICREATESTRUCT MDICS;
    HWND hwnd;

    ENTER("CreateTreeWindow");
    PRINT(BF_PARMTRACE, "szPath=%s", szPath);
    PRINT(BF_PARMTRACE, "dxSplit=%ld", IntToPtr(dxSplit));

    // if (wTextAttribs & TA_LOWERCASE)
    //         AnsiLower(szPath);

    // Create the Directory Tree window

    MDICS.szClass = szTreeClass;
    MDICS.szTitle = szPath;
    MDICS.hOwner = hAppInstance;

    MDICS.style = 0L;
    MDICS.x  = CW_USEDEFAULT;
    MDICS.y  = 0;
    MDICS.cx = CW_USEDEFAULT;
    MDICS.cy = 0;

    MDICS.lParam = MAKELONG(dxSplit, 0);    // pass the split parameter
                                            // on down

    hwnd = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwnd && GetWindowLong(hwnd, GWL_STYLE) & WS_MAXIMIZE)
        MDICS.style |= WS_MAXIMIZE;

    hwnd = (HWND)SendMessage(hwndMDIClient, WM_MDICREATE, 0L, (LPARAM)&MDICS);

    if (hwnd) {

        SetMDIWindowText(hwnd, szPath);
#if 0
        HMENU hMenu;
        hMenu = GetSystemMenu(hwnd, FALSE);
        AppendMenu(hMenu, MF_SEPARATOR, 0, NULL);
        AppendMenu(hMenu, MF_STRING, SC_SPLIT, "Sp&lit");
#endif
    }
    PRINT(BF_PARMTRACE, "OUT: hwndTree=%d", hwnd);
    LEAVE("CreateTreeWindow");
    return hwnd;
}



//
// HWND  APIENTRY CreateDirWindow(register LPSTR szPath, BOOL bStartUp)
//
// in:
//      szPath          fully qualified path with no filespec
//      bReplaceOpen    default replacement mode, shift always toggles this
//      hwndActive      active mdi child that we are working on
//                      on open flag
// returns:
//      hwnd of window created or of existing dir window that we
//      activated or replaced if replace on open was active
//

HWND
APIENTRY
CreateDirWindow(
               register LPSTR szPath,
               BOOL bReplaceOpen,
               HWND hwndActive
               )
{
    register HWND     hwndT;
    CHAR szFileSpec[MAXPATHLEN];

    // shift toggels 'replace on open'

    if (GetKeyState(VK_SHIFT) < 0)
        bReplaceOpen = !bReplaceOpen;

    /* Is a window with this path already open? */
    if (!bReplaceOpen && (hwndT = LocateDirWindow(szPath, TRUE)) && !HasTreeWindow(hwndT)) {

        SendMessage(hwndMDIClient, WM_MDIACTIVATE, GET_WM_MDIACTIVATE_MPS(0, 0, hwndT));
        if (IsIconic(hwndT))
            SendMessage(hwndT, WM_SYSCOMMAND, SC_RESTORE, 0L);
        return hwndT;
    }


    // Are we replacing the contents of the currently active child?

    if (bReplaceOpen) {

        // update the tree if necessary, before we throw on the filespec

        if (hwndT = HasTreeWindow(hwndActive))
            SendMessage(hwndT, TC_SETDIRECTORY, FALSE, (LPARAM)szPath);

        SendMessage(hwndActive, FS_GETFILESPEC, sizeof(szFileSpec), (LPARAM)szFileSpec);

        AddBackslash(szPath);                   // need to add this stuff to the path
        lstrcat(szPath, szFileSpec);

        SendMessage(GetDlgItem(hwndActive, IDCW_DIR), FS_CHANGEDISPLAY, CD_PATH, (LPARAM)szPath);


        return hwndActive;
    }

    AddBackslash(szPath);                   // default to all files
    lstrcat(szPath, szStarDotStar);

    return CreateTreeWindow(szPath, 0);     // dir only tree window
}



VOID
OpenSelection(
             HWND hwndActive
             )
{
    LPSTR p;
    BOOL bDir;
    WORD ret;
    HCURSOR hCursor;
    CHAR szTemp[MAXPATHLEN];

    CHAR szPath[MAXPATHLEN];
    HWND hwndTree, hwndDir, hwndDrives, hwndFocus;

    // Is the active MDI child minimized? if so restore it!

    if (IsIconic(hwndActive)) {
        SendMessage(hwndActive, WM_SYSCOMMAND, SC_RESTORE, 0L);
        return;
    }

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    // set the current directory

    SetWindowDirectory();

    // get the relavant parameters

    GetTreeWindows(hwndActive, &hwndTree, &hwndDir, &hwndDrives);
    if (hwndTree || hwndDir)
        hwndFocus = GetTreeFocus(hwndActive);
    else
        hwndFocus = NULL;

    if (hwndDrives && hwndFocus == hwndDrives) {

        // open a drive by sending a <CR>

        SendMessage(hwndDrives, WM_KEYDOWN, VK_RETURN, 0L);

        goto OpenExit;
    }


    /* Get the first selected item. */
    p = (LPSTR)SendMessage(hwndActive, FS_GETSELECTION, TRUE, (LPARAM)&bDir);

    if (!*p)
        goto OpenExit;


    GetNextFile(p, szPath, sizeof(szPath));
    LocalFree((HANDLE)p);

    if (!szPath[0])
        goto OpenExit;

    if (bDir) {

        if (hwndDir && hwndFocus == hwndDir) {

            if (hwndTree)
                SendMessage(hwndTree, TC_EXPANDLEVEL, FALSE, 0L);

            CreateDirWindow(szPath, TRUE, hwndActive);

            SetFocus(hwndDir);      // undo some things that happen in TC_EXPANDLEVEL

        } else if (hwndTree) {

            // this came through because of
            // SHIFT open a dir only tree

            if (GetKeyState(VK_SHIFT) < 0) {
                CreateDirWindow(szPath, TRUE, hwndActive);
            } else {
                SendMessage(hwndTree, TC_TOGGLELEVEL, FALSE, 0L);
            }
        }

    } else {
        // Display the object information

        GetSelectedDirectory(0, szTemp);

        AddBackslash(szTemp);

        strcat(szTemp, szPath);

        DisplayObjectInformation(hwndFrame, szTemp);
    }

    OpenExit:
    ShowCursor(FALSE);
    SetCursor(hCursor);
}




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AppCommandProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
AppCommandProc(
              register WORD id
              )
{
    WORD          wFlags;
    BOOL          bMaxed;
    HMENU         hMenu;
    register HWND hwndActive;
    BOOL          bTemp;
    HWND          hwndT;
    CHAR          szPath[MAXPATHLEN];
    INT           ret;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
        bMaxed = 1;
    else
        bMaxed = 0;


    dwContext = IDH_HELPFIRST + id;

    switch (id) {
        case IDM_SPLIT:
            MSG("AppCommandProc", "IDM_SPLIT");
            SendMessage(hwndActive, WM_SYSCOMMAND, SC_SPLIT, 0L);
            break;

        case IDM_TREEONLY:
        case IDM_DIRONLY:
        case IDM_BOTH:
            MSG("AppCommandProc", "IDM_TREEONLY/IDM_DIRONLY/IDM_BOTH");
            {
                RECT rc;
                INT x;

                if (hwndActive != hwndSearch) {

                    GetClientRect(hwndActive, &rc);

                    if (id == IDM_DIRONLY)
                        x = 0;
                    else if (id == IDM_TREEONLY)
                        x = rc.right;
                    else
                        x = rc.right / 2;

                    if (ResizeSplit(hwndActive, x))
                        SendMessage(hwndActive, WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));
                }
                break;
            }

        case IDM_OPEN:
            MSG("AppCommandProc", "IDM_OPEN");
            if (GetKeyState(VK_MENU) < 0)
                PostMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_ATTRIBS, 0, 0));
            else
                OpenSelection(hwndActive);
            break;

        case IDM_ASSOCIATE:
            MSG("AppCommandProc", "IDM_ASSOCIATE");
            DialogBox(hAppInstance, MAKEINTRESOURCE(ASSOCIATEDLG), hwndFrame, AssociateDlgProc);
            break;

        case IDM_SEARCH:
            MSG("AppCommandProc", "IDM_SEARCH");
            DialogBox(hAppInstance, MAKEINTRESOURCE(SEARCHDLG), hwndFrame, SearchDlgProc);
            break;

        case IDM_RUN:
            MSG("AppCommandProc", "IDM_RUN");
            DialogBox(hAppInstance, MAKEINTRESOURCE(RUNDLG), hwndFrame, RunDlgProc);
            break;

        case IDM_SELECT:

            MSG("AppCommandProc", "IDM_SELECT");
            // push the focus to the dir half so when they are done
            // with the selection they can manipulate without undoing the
            // selection.

            if (hwndT = HasDirWindow(hwndActive))
                SetFocus(hwndT);

            DialogBox(hAppInstance, MAKEINTRESOURCE(SELECTDLG), hwndFrame, SelectDlgProc);
            break;

        case IDM_MOVE:
        case IDM_COPY:
        case IDM_RENAME:
            MSG("AppCommandProc", "IDM_MOVE/IDM_COPY/IDM_RENAME");
            wSuperDlgMode = id;
            DialogBox(hAppInstance, MAKEINTRESOURCE(MOVECOPYDLG), hwndFrame, SuperDlgProc);
            break;

        case IDM_PRINT:
            MSG("AppCommandProc", "IDM_PRINT");
            wSuperDlgMode = id;
            DialogBox(hAppInstance, MAKEINTRESOURCE(MYPRINTDLG), hwndFrame, SuperDlgProc);
            break;

        case IDM_DELETE:
            MSG("AppCommandProc", "IDM_DELETE");
            wSuperDlgMode = id;
            DialogBox(hAppInstance, MAKEINTRESOURCE(DELETEDLG), hwndFrame, SuperDlgProc);
            break;

        case IDM_UNDELETE:
            MSG("AppCommandProc", "IDM_UNDELETE");

            if (lpfpUndelete) {
                SendMessage(hwndActive, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                StripBackslash(szPath);
                if ((*lpfpUndelete)(hwndActive, (LPSTR)szPath) == IDOK)
                    RefreshWindow(hwndActive);
            }
            break;

        case IDM_ATTRIBS:
            MSG("AppCommandProc", "IDM_ATTRIBS");
            {
                LPSTR pSel, p;
                INT count;

                // should do the multiple or single file properties

                pSel = GetSelection(FALSE);

                if (!pSel)
                    break;

                count = 0;
                p = pSel;

                while (p = GetNextFile(p, szPath, sizeof(szPath)))
                    count++;

                LocalFree((HANDLE)pSel);

                if (count == 0)
                    break;          // nothing selected

                if (count > 1)
                    DialogBox(hAppInstance, MAKEINTRESOURCE(MULTIPLEATTRIBSDLG), hwndFrame, AttribsDlgProc);
                else
                    DialogBox(hAppInstance, MAKEINTRESOURCE(ATTRIBSDLG), hwndFrame, AttribsDlgProc);

                break;
            }

        case IDM_MAKEDIR:
            MSG("AppCommandProc", "IDM_MAKEDIR");
            DialogBox(hAppInstance, MAKEINTRESOURCE(MAKEDIRDLG), hwndFrame, MakeDirDlgProc);
            break;

        case IDM_SELALL:
        case IDM_DESELALL:

            MSG("AppCommandProc", "IDM_SELALL/IDM_DESELALL");
            // FIX31: this code could be replace with calls to
            // DSSetSelection()
            {
                INT       iSave;
                HWND      hwndLB;
                LPMYDTA lpmydta;

                hwndActive = HasDirWindow(hwndActive);

                if (!hwndActive)
                    break;

                hwndLB = GetDlgItem(hwndActive, IDCW_LISTBOX);

                if (!hwndLB)
                    break;

                SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);

                iSave = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                SendMessage(hwndLB, LB_SETSEL, (id == IDM_SELALL), -1L);

                if (id == IDM_DESELALL)
                    SendMessage(hwndLB, LB_SETSEL, TRUE, (LONG)iSave);
                else if (GetParent(hwndActive) != hwndSearch) {
                    /* Is the first item the [..] directory? */
                    SendMessage(hwndLB, LB_GETTEXT, 0, (LPARAM)&lpmydta);
                    if (lpmydta->my_dwAttrs & ATTR_PARENT)
                        SendMessage(hwndLB, LB_SETSEL, 0, 0L);
                }
                SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
                InvalidateRect(hwndLB, NULL, FALSE);

                /* Emulate a SELCHANGE notification. */
                SendMessage(hwndActive, WM_COMMAND, GET_WM_COMMAND_MPS(0, hwndActive, LBN_SELCHANGE));

            }
            break;

        case IDM_EXIT:

            MSG("AppCommandProc", "IDM_EXIT");
            if (iReadLevel) {
                bCancelTree = 2;
                //break;
            }

            SheChangeDir(szOriginalDirPath);

            if (bSaveSettings)
                SaveWindows(hwndFrame);

            return FALSE;
            break;

        case IDM_LABEL:
            MSG("AppCommandProc", "IDM_LABEL");
            DialogBox(hAppInstance, MAKEINTRESOURCE(DISKLABELDLG), hwndFrame, DiskLabelDlgProc);
            break;

        case IDM_DISKCOPY:

            MSG("AppCommandProc", "IDM_DISKCOPY");
            if (nFloppies == 1) {

                iCurrentDrive = iFormatDrive = rgiDrive[0];
            } else {

                wSuperDlgMode = id;
                ret = (int)DialogBox(hAppInstance, MAKEINTRESOURCE(CHOOSEDRIVEDLG), hwndFrame, ChooseDriveDlgProc);

                if (ret < 1)
                    break;
            }

            if (bConfirmFormat) {
                LoadString(hAppInstance, IDS_DISKCOPYCONFIRMTITLE, szTitle, sizeof(szTitle));
                LoadString(hAppInstance, IDS_DISKCOPYCONFIRM, szMessage, sizeof(szMessage));
                if (MessageBox(hwndFrame, szMessage, szTitle, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES)
                    break;
            }

            if (CopyDiskette(hwndFrame, (WORD)iCurrentDrive, (WORD)iFormatDrive) <= 0) {
                if (!bUserAbort) {
                    LoadString(hAppInstance, IDS_COPYDISKERR, szTitle, sizeof(szTitle));
                    LoadString(hAppInstance, IDS_COPYDISKERRMSG, szMessage, sizeof(szMessage));
                    MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                }
            }
            break;

        case IDM_FORMAT:
            MSG("AppCommandProc", "IDM_FORMAT");
            FormatDiskette(hwndFrame);
            break;

        case IDM_SYSDISK:
            MSG("AppCommandProc", "IDM_SYSDISK");
            /*** FIX30: This ASSUMEs that A: is the first floppy drive in the system! ***/
            if (nFloppies == 1) {
                iFormatDrive = rgiDrive[0];
                LoadString(hAppInstance, IDS_SYSDISK, szTitle, sizeof(szTitle));
                LoadString(hAppInstance, IDS_SYSDISKRUSURE, szPath, sizeof(szPath));
                wsprintf(szMessage, szPath, 'A'+iFormatDrive);
                if (MessageBox(hwndFrame, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
                    break;
            } else {
                wSuperDlgMode = id;
                if (DialogBox(hAppInstance, MAKEINTRESOURCE(CHOOSEDRIVEDLG), hwndFrame, ChooseDriveDlgProc) < 1)
                    break;
            }


            bUserAbort = FALSE;

            /* Display the Format dialog. */
            hdlgProgress = CreateDialog(hAppInstance, MAKEINTRESOURCE(SYSDISKPROGRESSDLG), hwndFrame, ProgressDlgProc);
            if (!hdlgProgress)
                goto SysDiskExit;

            EnableWindow(hwndFrame, FALSE);

            LoadString(hAppInstance, IDS_SYSDISKERR, szTitle, sizeof(szTitle));

            if (MakeSystemDiskette((WORD)iFormatDrive, FALSE)) {
                if (!bUserAbort) {
                    LoadString(hAppInstance, IDS_SYSDISKADDERR, szMessage, sizeof(szMessage));
                    MessageBox(hdlgProgress, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                }
            }
            SysDiskExit:
            if (hdlgProgress) {
                EnableWindow(hwndFrame, TRUE);
                DestroyWindow(hdlgProgress);
                hdlgProgress = NULL;
            }
            break;

        case IDM_CONNECTIONS:
            MSG("AppCommandProc", "IDM_CONNECTIONS");
            ret = WNetConnectionDialog(hwndFrame, RESOURCETYPE_DISK);

            if ( ret == WN_SUCCESS )
                UpdateConnections();
            else if ( ret == WN_NO_NETWORK || ret == WN_NOT_SUPPORTED ) {
                DialogBox(hAppInstance, MAKEINTRESOURCE(CONNECTDLG), hwndFrame, ConnectDlgProc);
            } else if ( ret != WN_CANCEL ) {
                WNetErrorText((WORD)ret, szMessage, (WORD)sizeof(szMessage));
                LoadString(hAppInstance, IDS_NETERR, szTitle, sizeof(szTitle));
                MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONSTOP);
            }
            break;

        case IDM_EXPONE:
            MSG("AppCommandProc", "IDM_EXPONE");
            if (hwndT = HasTreeWindow(hwndActive))
                SendMessage(hwndT, TC_EXPANDLEVEL, FALSE, 0L);
            break;

        case IDM_EXPSUB:
            MSG("AppCommandProc", "IDM_EXPSUB");
            if (hwndT = HasTreeWindow(hwndActive))
                SendMessage(hwndT, TC_EXPANDLEVEL, TRUE, 0L);
            break;

        case IDM_EXPALL:
            MSG("AppCommandProc", "IDM_EXPALL");
            if (hwndT = HasTreeWindow(hwndActive))
                SendMessage(hwndT, TC_SETDRIVE, MAKEWORD(TRUE, 0), 0L);
            break;

        case IDM_COLLAPSE:
            MSG("AppCommandProc", "IDM_COLLAPSE");
            if (hwndT = HasTreeWindow(hwndActive))
                SendMessage(hwndT, TC_COLLAPSELEVEL, 0, 0L);
            break;

        case IDM_VNAME:
            MSG("AppCommandProc", "IDM_VNAME");
            wFlags = (WORD)(VIEW_NAMEONLY | (GetWindowLong(hwndActive, GWL_VIEW) & VIEW_PLUSES));
            id = CD_VIEW;
            goto ChangeDisplay;

        case IDM_VDETAILS:
            MSG("AppCommandProc", "IDM_VDETAILS");
            wFlags = (WORD)(VIEW_EVERYTHING | (GetWindowLong(hwndActive, GWL_VIEW) & VIEW_PLUSES));
            id = CD_VIEW;
            goto ChangeDisplay;

        case IDM_VOTHER:
            MSG("AppCommandProc", "IDM_VOTHER");
            DialogBox(hAppInstance, MAKEINTRESOURCE(OTHERDLG), hwndFrame, OtherDlgProc);
            break;

        case IDM_BYNAME:
        case IDM_BYTYPE:
        case IDM_BYSIZE:
        case IDM_BYDATE:
            MSG("AppCommandProc", "IDM_BYNAME/IDM_BYTYPE/IDM_BYSIZE/IDM_BYDATE");
            wFlags = (WORD)((id - IDM_BYNAME) + IDD_NAME);
            id = CD_SORT;

            ChangeDisplay:

            if (hwndT = HasDirWindow(hwndActive)) {
                SendMessage(hwndT, FS_CHANGEDISPLAY, id, MAKELONG(wFlags, 0));
            } else if (hwndActive == hwndSearch) {
                SetWindowLong(hwndActive, GWL_VIEW, wFlags);
                InvalidateRect(hwndActive, NULL, TRUE);
            }

            break;

        case IDM_VINCLUDE:
            MSG("AppCommandProc", "IDM_VINCLUDE");
            DialogBox(hAppInstance, MAKEINTRESOURCE(INCLUDEDLG), hwndFrame, IncludeDlgProc);
            break;

        case IDM_CONFIRM:
            MSG("AppCommandProc", "IDM_CONFIRM");
            DialogBox(hAppInstance, MAKEINTRESOURCE(CONFIRMDLG), hwndFrame, ConfirmDlgProc);
            break;


        case IDM_STATUSBAR:
            MSG("AppCommandProc", "IDM_STATUSBAR");
            {
                RECT      rc;

                bTemp = bStatusBar = !bStatusBar;
                WritePrivateProfileBool(szStatusBar, bStatusBar);

                GetClientRect(hwndFrame, &rc);
                SendMessage(hwndFrame, WM_SIZE, SIZENORMAL, MAKELONG(rc.right, rc.bottom));
                UpdateStatus(hwndActive);
                InvalidateRect(hwndFrame, NULL, TRUE);

                goto CHECK_OPTION;

                break;
            }

        case IDM_FONT:
            MSG("AppCommandProc", "IDM_FONT");
            dwContext = IDH_FONT;
            NewFont();
            break;

        case IDM_ADDPLUSES:
            MSG("AppCommandProc", "IDM_ADDPLUSES");
            {
                HWND hwnd;
                WORD view;

                if (!(hwnd = HasTreeWindow(hwndActive)))
                    break;

                // toggle pluses view bit

                view = (WORD)(GetWindowLong(hwndActive, GWL_VIEW) ^ VIEW_PLUSES);

                SetWindowLong(hwndActive, GWL_VIEW, view);

                if (view & VIEW_PLUSES) {
                    // need to reread the tree to do this

                    SendMessage(hwndActive, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                    SendMessage(hwnd, TC_SETDRIVE, MAKEWORD(FALSE, 0), (LPARAM)szPath);
                } else {
                    // repaint only
                    InvalidateRect(hwnd, NULL, FALSE);
                }

                bTemp = view & VIEW_PLUSES;
                goto CHECK_OPTION;
            }

        case IDM_SAVESETTINGS:
            MSG("AppCommandProc", "IDM_SAVESETTINGS");
            bTemp = bSaveSettings = !bSaveSettings;
            WritePrivateProfileBool(szSaveSettings, bSaveSettings);
            goto CHECK_OPTION;

        case IDM_MINONRUN:
            MSG("AppCommandProc", "IDM_MINONRUN");
            bTemp = bMinOnRun = !bMinOnRun;
            WritePrivateProfileBool(szMinOnRun, bMinOnRun);

            CHECK_OPTION:
            /* Check/Uncheck the menu item. */
            hMenu = GetSubMenu(GetMenu(hwndFrame), IDM_OPTIONS + bMaxed);
            CheckMenuItem(hMenu, id, (bTemp ? MF_CHECKED : MF_UNCHECKED));
            break;

        case IDM_NEWWINDOW:
            MSG("AppCommandProc", "IDM_NEWWINDOW");
            NewTree((INT)SendMessage(hwndActive, FS_GETDRIVE, 0, 0L) - 'A', hwndActive);
            break;

        case IDM_CASCADE:
            MSG("AppCommandProc", "IDM_CASCADE");
            SendMessage(hwndMDIClient, WM_MDICASCADE, 0L, 0L);
            break;

        case IDM_TILE:
            MSG("AppCommandProc", "IDM_TILE");
            SendMessage(hwndMDIClient, WM_MDITILE,
                        GetKeyState(VK_SHIFT) < 0 ? 0 : 1, 0L);
            break;

        case IDM_ARRANGE:
            MSG("AppCommandProc", "IDM_ARRANGE");
            SendMessage(hwndMDIClient, WM_MDIICONARRANGE, 0L, 0L);
            break;

        case IDM_REFRESH:
            MSG("AppCommandProc", "IDM_REFRESH");
            {
                INT i;

                for (i = 0; i < iNumExtensions; i++) {
                    (extensions[i].ExtProc)(hwndFrame, FMEVENT_USER_REFRESH, 0L);
                }

                InvalidateVolTypes();
                RefreshWindow(hwndActive);
                lFreeSpace = -1L;             // update free space
                UpdateStatus(hwndActive);
                AddNetMenuItems();

                break;
            }

        case IDM_HELPINDEX:
            MSG("AppCommandProc", "IDM_HELPINDEX");
            wFlags = HELP_INDEX;
            goto ACPCallHelp;

        case IDM_HELPKEYS:
            MSG("AppCommandProc", "IDM_HELPKEYS");
            wFlags = HELP_PARTIALKEY;
            goto ACPCallHelp;

        case IDM_HELPHELP:
            MSG("AppCommandProc", "IDM_HELPHELP");
            wFlags = HELP_HELPONHELP;
            goto ACPCallHelp;

            ACPCallHelp:
            SheChangeDir(szOriginalDirPath);
            if (!WinHelp(hwndFrame, szWinObjHelp, wFlags, (ULONG_PTR)szNULL)) {
                MyMessageBox(hwndFrame, IDS_WINFILE, IDS_WINHELPERR, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
            }
            break;

        case IDM_ABOUT:
            MSG("AppCommandProc", "IDM_ABOUT");
            LoadString(hAppInstance, IDS_WINFILE, szTitle, sizeof(szTitle));
            ShellAbout(hwndFrame, szTitle, NULL, NULL);
            break;

        case IDM_DRIVESMORE:
            MSG("AppCommandProc", "IDM_DRIVESMORE");
            DialogBox(hAppInstance, MAKEINTRESOURCE(DRIVEDLG), hwndFrame, DrivesDlgProc);
            break;

        default:
            DEFMSG("AppCommandProc", id);
            {
                INT i;

                for (i = 0; i < iNumExtensions; i++) {
                    WORD delta = extensions[i].Delta;

                    if ((id >= delta) && (id < (WORD)(delta + 100))) {
                        (extensions[i].ExtProc)(hwndFrame, (WORD)(id - delta), 0L);
                        break;
                    }
                }

            }
            return FALSE;
    }

    return TRUE;
}


VOID
AddNetMenuItems(VOID)

{
    HMENU hMenu;


    hMenu = GetMenu(hwndFrame);


    // add only if net menuitems do not already exist

    if ((GetMenuState(hMenu, IDM_CONNECT, MF_BYCOMMAND) == -1) &&

        (GetMenuState(hMenu, IDM_CONNECTIONS, MF_BYCOMMAND) == -1)) {

        InitNetMenuItems();
    }
}





VOID
InitNetMenuItems(VOID)

{

    HMENU hMenu;

    UINT i;

    INT iMax;

    CHAR szValue[MAXPATHLEN];

    HWND hwndActive;





    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)

        iMax = 1;

    else

        iMax = 0;

    hMenu = GetMenu(hwndFrame);



    // No. Now add net items if net has been started.



    i = (WORD)WNetGetCaps(WNNC_DIALOG);

    bConnect    = i & WNNC_DLG_ConnectDialog;     // note, these should both

    bDisconnect = i & WNNC_DLG_DisconnectDialog;  // be true or both false



    // use submenu because we are doing this by position



    hMenu = GetSubMenu(hMenu, IDM_DISK + iMax);



    if (i)

        InsertMenu(hMenu, 5, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);



    if (bConnect && bDisconnect) {



        // lanman style double connect/disconnect



        LoadString(hAppInstance, IDS_CONNECT, szValue, sizeof(szValue));

        InsertMenu(hMenu, 6, MF_BYPOSITION | MF_STRING, IDM_CONNECT, szValue);

        LoadString(hAppInstance, IDS_DISCONNECT, szValue, sizeof(szValue));

        InsertMenu(hMenu, 7, MF_BYPOSITION | MF_STRING, IDM_DISCONNECT, szValue);

    } else if (WNetGetCaps(WNNC_CONNECTION)) {



        // our style



        LoadString(hAppInstance, IDS_CONNECTIONS, szValue, sizeof(szValue));

        InsertMenu(hMenu, 6, MF_BYPOSITION | MF_STRING, IDM_CONNECTIONS, szValue);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfcopy.h ===
/****************************************************************************/
/*                                      */
/*  WFCOPY.H -                                  */
/*                                      */
/*  Include for WINFILE's File Copying Routines             */
/*                                      */
/****************************************************************************/

#define FIND_DIRS       0x0010

#define CNF_DIR_EXISTS      0x0001
#define CNF_ISDIRECTORY     0x0002

#define BUILD_TOPLEVEL      0
#define BUILD_RECURSING     1
#define BUILD_NORECURSE     2

#define FUNC_MOVE       0x0001
#define FUNC_COPY       0x0002
#define FUNC_DELETE     0x0003
#define FUNC_RENAME     0x0004

/* These should not be used in the move/copy code;
 * only for IsTheDiskReallyThere */
#define FUNC_SETDRIVE       0x0005
#define FUNC_EXPAND     0x0006
#define FUNC_LABEL      0x0007

#define OPER_MASK       0x0F00
#define OPER_MKDIR      0x0100
#define OPER_RMDIR      0x0200
#define OPER_DOFILE     0x0300
#define OPER_ERROR      0x0400

#define CCHPATHMAX      260
#define MAXDIRDEPTH     20      // arbitrary limit

#define COPYMAXBUFFERSIZE 0xFFFF
#define COPYMINBUFFERSIZE  4096 /* Minimum buffer size for FileCopy */
#define COPYMAXFILES         10 /* Maximum number of source files to open */
#define COPYMINFILES          1 /* Minimum number of source files to open */
#define CARRY_FLAG            1 /* Carry flag mask in status word */
#define ATTR_ATTRIBS      0x200 /* Flag indicating we have file attributes */
#define ATTR_COPIED       0x400 /* we have copied this file */
#define ATTR_DELSRC       0x800 /* delete the source when done */

typedef struct TAGCopyQueue {
   CHAR szSource[MAXPATHLEN];
   CHAR szDest[MAXPATHLEN];
   INT hSource;
   INT hDest;
   FILETIME ftLastWriteTime;
   DWORD wAttrib;
} COPYQUEUEENTRY, *PCOPYQUEUE, *LPCOPYQUEUE;

typedef struct _copyroot
  {
    BOOL    fRecurse;
    WORD    cDepth;
    LPSTR   pSource;
    LPSTR   pRoot;
    CHAR cIsDiskThereCheck[26];
    CHAR    sz[MAXPATHLEN];
    CHAR    szDest[MAXPATHLEN];
    LFNDTA  rgDTA[MAXDIRDEPTH];
  } COPYROOT, *PCOPYROOT;

typedef struct _getnextqueue
  {
    char szSource[MAXPATHLEN];
    char szDest[MAXPATHLEN];
    int nOper;
    LFNDTA SourceDTA;
  } GETNEXTQUEUE, *PGETNEXTQUEUE, *LPGETNEXTQUEUE;

/* WFFILE.ASM */
BOOL IsSerialDevice(INT hFile);
BOOL IsDirectory(LPSTR szPath);
WORD  APIENTRY FileMove(LPSTR, LPSTR);
WORD  APIENTRY FileRemove(LPSTR);
WORD  APIENTRY MKDir(LPSTR);
WORD  APIENTRY RMDir(LPSTR);
BOOL APIENTRY WFSetAttr(LPSTR lpFile, DWORD dwAttr);

VOID APIENTRY QualifyPath(LPSTR);
VOID APIENTRY AppendToPath(LPSTR,LPSTR);
VOID APIENTRY RemoveLast(LPSTR pFile);
VOID APIENTRY Notify(HWND,WORD,PSTR,PSTR);

extern BOOL bCopyReport;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdisk.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDISK.C -                                                              */
/*                                                                          */
/*      Ported code from wfdisk.asm                                         */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"

DWORD
APIENTRY
LongShift(
         DWORD dwValue,
         WORD wCount
         )
{
    return (dwValue >> wCount);
}


VOID
APIENTRY
SetDASD(
       WORD drive,
       BYTE dasdvalue
       )
{
    // only used by diskette copy.
}


LPDBT
APIENTRY
GetDBT()
{
    return (0);  // only used by format.
}

VOID
APIENTRY
DiskReset()
{
}


INT
APIENTRY
IsHighCapacityDrive(
                   WORD iDrive
                   )
{
    return (0);  // only use for format and make system diskette.
}


WORD
APIENTRY
GetDPB(
      WORD drive,
      PDPB pDPB
      )
{
    return (0);  // used by hasSystemFiles() and IsSYSable()
}


VOID
APIENTRY
SetDPB(
      WORD drive,
      PBPB pBPB,
      PDPB pDPB
      )
{               // only used by Format()
}


INT
APIENTRY
ModifyDPB(
         WORD drive
         )
{
    return (0);  // only used by IsSYSAble()
}


INT
APIENTRY
MyInt25(
       WORD drive,
       LPSTR buffer,
       WORD count,
       WORD sector
       )
{
    return (0);          // only used for formatting and sys disk
}


INT
APIENTRY
MyReadWriteSector(
                 LPSTR lpBuffer,
                 WORD function,
                 WORD drive,
                 WORD cylinder,
                 WORD head,
                 WORD count
                 )
{
    return (0);  // only used by DiskCopy()
}


INT
APIENTRY
FormatTrackHead(
               WORD drive,
               WORD track,
               WORD head,
               WORD cSec,
               LPSTR lpTrack
               )
{
    return (0);  // only used for formatting
}


INT
APIENTRY
MyGetDriveType(
              WORD drive
              )
{
    return (0);  // only used for formatting
}


INT
APIENTRY
WriteBootSector(
               WORD srcDrive,
               WORD dstDrive,
               PBPB pBPB,
               LPSTR lpBuf
               )
{
    return (0);  // only used for formatting and syssing.
}


DWORD
APIENTRY
ReadSerialNumber(
                INT iDrive,
                LPSTR lpBuf
                )
{
    return (0);  // only used for syssing.
}


INT
APIENTRY
ModifyVolLabelInBootSec(
                       INT iDrive,
                       LPSTR lpszVolLabel,
                       DWORD lSerialNo,
                       LPSTR lpBuf
                       )
{
    return (0); // only used for syssing.
}


/*
 * Note: returned value must not be written to or freed
 */
LPSTR
GetRootPath(
           WORD wDrive
           )
{
    static CHAR rp[] = "A:\\";

    rp[0] = 'A' + wDrive;
    return (rp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfcopy.c ===
/****************************************************************************/
/*                                                                          */
/*  WFCOPY.C -                                                              */
/*                                                                          */
/*      Windows File System File Copying Routines                           */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "wnetcaps.h"			// WNetGetCaps()
#include "lfn.h"
#include "wfcopy.h"

#ifdef TRACECOPY
    #define dbg(x) DebugF x
#else
    #define dbg(x)
#endif

BOOL *pbConfirmAll;
CHAR szSpace[] = " ";
INT ManySource;

INT nCopyNumQueue;      // # of items in the queue
INT nCopyMaxQueue;      // size of the queue
PCOPYQUEUE pCopyQueue;      // copy queue buffer
BOOL bCopyReport;       // do notifications? bogus


LPSTR lpCopyBuffer;     // global memory for FileCopy() buffer
WORD wCopyBufferSize;       // size of this buffer

VOID APIENTRY wfYield(VOID);

INT  CopyMoveRetry(PSTR, INT);
VOID CopyError(PSTR, PSTR, INT, WORD, INT);
BOOL IsRootDirectory(PSTR pPath);
BOOL IsDirectory(PSTR pPath);

WORD ConfirmDialog(
                  HWND hDlg, WORD dlg,
                  LPSTR pFileDest, PLFNDTA pDTADest,
                  LPSTR pFileSource, PLFNDTA pDTASource,
                  BOOL bConfirmByDefault, BOOL *pbAll);

VOID MergePathName(LPSTR pPath, LPSTR pName);
BOOL IsInvalidPath(register LPSTR pPath);
WORD GetNextPair(register PCOPYROOT pcr, LPSTR pFrom, LPSTR pToPath, LPSTR pToSpec, WORD wFunc);
INT  CheckMultiple(LPSTR pInput);
VOID DialogEnterFileStuff(register HWND hwnd);
WORD SafeFileRemove(LPSTR szFileOEM);
BOOL IsWindowsFile(LPSTR szFileOEM);

INT_PTR APIENTRY ReplaceDlgProc(register HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);


BOOL
APIENTRY
IsValidChar(
           BYTE ch,
           BOOL fPath
           )
{
    switch (ch) {
        case ';':       // terminator
        case ',':       // terminator
        case '|':       // pipe
        case '>':       // redir
        case '<':       // redir
        case '"':       // quote
            return FALSE;

        case '?':       // wc           we only do wilds here because they're
        case '*':       // wc           legal for qualifypath
        case '\\':      // path separator
        case ':':       // drive colon
        case '/':       // path sep
            return fPath;
    }

    // cannot be a control character or space
    return ch > ' ';
}



//--------------------------------------------------------------------------
//
// StripColon() -
//
// removes trailing colon if not a drive letter.
// this is to support DOS character devices (CON:, COM1: LPT1:).  DOS
// can't deal with these things having a colon on the end (so we strip it).
//
//--------------------------------------------------------------------------

PSTR
StripColon(
          register PSTR pPath
          )
{
    register INT cb = lstrlen(pPath);

    dbg(("StripColon(%s)\r\n",(LPSTR)pPath));

    {
        LPSTR pTailp = AnsiPrev( pPath, &(pPath[cb]) );
        if (cb > 2 && *pTailp == ':')
            *pTailp = 0;
    }

    return pPath;
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  FindFileName() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Returns a pointer to the last component of a path string. */

PSTR
FindFileName(
            register PSTR pPath
            )
{
    register LPSTR pT;

    dbg(("FindFileName(%s);\r\n",(LPSTR)pPath));

    for (pT=pPath; *pPath; pPath=(LPSTR)AnsiNext(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':') && pPath[1])
            pT = pPath+1;
    }

    return (pT);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  AppendToPath() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Appends a filename to a path.  Checks the \ problem first
 *  (which is why one can't just use lstrcat())
 * Also don't append a \ to : so we can have drive-relative paths...
 * this last bit is no longer appropriate since we qualify first!
 *
 * is this relative junk needed anymore?  if not this can be
 * replaced with AddBackslash(); lstrcat()
 */

VOID
APIENTRY
AppendToPath(
            PSTR pPath,
            PSTR pMore
            )
{

    dbg(("AppendToPath(%s,%s);\r\n",(LPSTR)pPath,(LPSTR)pMore));

    /* Don't append a \ to empty paths. */
    if (*pPath) {
        LPSTR pPathBase = pPath;
        BYTE ch;

        while (*pPath)
            pPath++;

        ch = *AnsiPrev(pPathBase, pPath );
        if (ch != '\\')
            *pPath++='\\';
    }

    /* Skip any initial terminators on input. */
    while (*pMore == '\\')
        pMore = (LPSTR)AnsiNext(pMore);

    lstrcpy(pPath, pMore);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  RemoveLast() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Deletes the last component of a filename in a string. */

VOID
APIENTRY
RemoveLast(
          PSTR pFile
          )
{
    PSTR pT;

    dbg(("RemoveLast(%s);\r\n",(LPSTR)pFile));

    for (pT=pFile; *pFile; pFile=(LPSTR)AnsiNext(pFile)) {
        if (*pFile == '\\')
            pT = pFile;
        else if (*pFile == ':') {
            if (pFile[1] =='\\')
                pFile++;
            pT = pFile + 1;
        }
    }
    *pT = TEXT('\0');
}




// qualify a DOS (or LFN) file name based on the currently active window.
// this code is not careful to not write more than MAXPATHLEN characters
// into psz
//
// in:
//      psz     path to be qualified (of at least MAXPATHLEN characters)
//              ANSI string
//
// out:
//      psz     fully qualified version of input string based
//              on the current active window (current directory)
//

VOID
APIENTRY
QualifyPath(
           PSTR psz
           )
{
    INT cb, nSpaceLeft;
    CHAR szTemp[MAXPATHLEN];
    INT iDrive = 0;
    LPSTR pOrig;
    BOOL flfn = FALSE;

    STKCHK();

    dbg(("QualifyPath(%s);\r\n",(LPSTR)psz));

    /* Save it away. */
    strncpy(szTemp, psz, sizeof(szTemp));
    CheckSlashies(szTemp);
    StripColon(szTemp);

    nSpaceLeft = MAXPATHLEN;

    pOrig = szTemp;

    if (pOrig[0] == '\\' && pOrig[1] == '\\') {
        // leave the \\ in the buffer so that the various parts
        // of the UNC path will be qualified and appended.  Note
        // we must assume that UNCs are FAT's.
        psz[2] = 0;
        nSpaceLeft -= 3;
        goto GetComps;
    }

    if (pOrig[0] && pOrig[1]==':' && !IsDBCSLeadByte(pOrig[0])) {
        iDrive = DRIVEID(pOrig);

        /* Skip over the drive letter. */
        pOrig += 2;
    } else
        iDrive = GetSelectedDrive();

    flfn = IsLFNDrive(pOrig);
    #ifdef DEBUG
    if (flfn)
        dbg(("lfn qualify!\r\n"));
    else
        dbg(("normal qualify!\r\n"));
    #endif

    // on FAT devices, replace any illegal chars with underscores
    if (!flfn)
    {
        LPSTR pT;

        for (pT = pOrig; *pT; pT = (LPSTR)AnsiNext(pT));
        {
            if (!IsValidChar(*pT,TRUE))
                *pT = '_';
        }
    }

    if (pOrig[0]=='\\') {
        psz[0] = (CHAR)iDrive + (CHAR)'A';
        psz[1] = ':';
        psz[2] = '\\';
        psz[3] = 0;
        nSpaceLeft -= 4;
        pOrig++;
    } else {
        /* Get current dir of drive in path.  Also returns drive. */
        GetSelectedDirectory((WORD)(iDrive+1), psz);
        nSpaceLeft -= (lstrlen(psz) + 1);
    }

    GetComps:

    while (*pOrig && nSpaceLeft > 0) {
        /* If the component is parent dir, go up one dir.
         * If its the current dir, skip it, else add it normally
         */
        if (pOrig[0] == '.') {
            if (pOrig[1] == '.')
                RemoveLast(psz);
            else if (pOrig[1] && pOrig[1] != '\\')
                goto addcomponent;

            while (*pOrig && *pOrig != '\\')
                pOrig = (LPSTR)AnsiNext(pOrig);

            if (*pOrig)
                pOrig++;
        } else {
            LPSTR pT, pTT = NULL;

            addcomponent:
            AddBackslash(psz);
            nSpaceLeft--;

            pT = psz + lstrlen(psz);

            if (flfn) {
                // copy the component
                while (*pOrig && *pOrig != '\\') {
                    nSpaceLeft--;
                    if (IsDBCSLeadByte(*pT++ = *pOrig++)) {
                        if (nSpaceLeft <= 0) {
                            pT--;
                        } else {
                            *pT++ = *pOrig++;
                            nSpaceLeft--;
                        }
                    }
                }
            } else {
                // copy the filename (up to 8 chars)
                for (cb = 0; *pOrig && *pOrig != '\\' && *pOrig != '.' && nSpaceLeft > 0;) {
                    if (cb < 8) {
                        cb++;
                        nSpaceLeft--;
                        if (IsDBCSLeadByte(*pT++ = *pOrig++)) {
                            if (nSpaceLeft <= 0) {
                                pT--;
                            } else {
                                cb++;
                                *pT++ = *pOrig++;
                                nSpaceLeft--;
                            }
                        }
                    } else {
                        pOrig = AnsiNext(pOrig);
                    }
                }

                // if there's an extension, copy it, up to 3 chars
                if (*pOrig == '.' && nSpaceLeft > 0) {
                    *pT++ = '.';
                    nSpaceLeft--;
                    pOrig++;
                    for (cb = 0; *pOrig && *pOrig != '\\' && nSpaceLeft > 0;) {
                        if (*pOrig == '.')
                            cb = 3;

                        if (cb < 3) {
                            cb++;
                            nSpaceLeft--;
                            if (IsDBCSLeadByte(*pT++ = *pOrig++)) {
                                if (nSpaceLeft <= 0) {
                                    pT--;
                                } else {
                                    cb++;
                                    *pT++ = *pOrig++;
                                    nSpaceLeft--;
                                }
                            }
                        } else {
                            pOrig = AnsiNext(pOrig);
                        }
                    }
                }
            }

            // skip the backslash

            if (*pOrig)
                pOrig++;

            // null terminate for next pass...
            *pT = 0;

        }
    }

    StripBackslash(psz);

    // remove any trailing dots

    if (*(psz + lstrlen(psz) - 1) == '.')
        *(psz + lstrlen(psz) - 1) = 0;

}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsRootDirectory() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
IsRootDirectory(
               register LPSTR pPath
               )
{
    if (!IsDBCSLeadByte( *pPath )) {
        if (!lstrcmpi(pPath+1, ":\\"))
            return (TRUE);
        if (!lstrcmpi(pPath+1, ":"))
            return TRUE;
    }
    if (!lstrcmpi(pPath, "\\"))
        return (TRUE);
    return (FALSE);
}

// returns:
//  TRUE    if pPath is a directory, including the root and
//      relative paths "." and ".."
//  FALSE   not a dir

BOOL
IsDirectory(
           PSTR pPath
           )
{
    PSTR pT;
    CHAR szTemp[MAXPATHLEN];

    STKCHK();

    if (IsRootDirectory(pPath))
        return TRUE;

    // check for "." and ".."

    pT = FindFileName(pPath);
    if (pT[0] == '.') {
        if (!pT[1] || pT[1] == '.')
            return TRUE;
    }

    lstrcpy(szTemp, pPath);
    FixAnsiPathForDos(szTemp);

    return WFIsDir(szTemp);
}


//
// note: this has the side effect of setting the
// current drive to the new disk if it is successful
//

WORD
APIENTRY
IsTheDiskReallyThere(
                    HWND hwnd,
                    register LPSTR pPath,
                    WORD wFunc
                    )
{
    INT           i;
    register INT  drive;
    CHAR szTemp[MAXPATHLEN];
    INT err = 0;
    WORD wError;

    STKCHK();

#ifdef DEBUG
    {
        char szMsg[200];

        wsprintf(szMsg, "IsTheDiskReallyThere(%s)\r\n",(LPSTR)pPath);
        OutputDebugString(szMsg);
    }
#endif

    if (pPath[1]==':' && !IsDBCSLeadByte( *pPath ))
        drive = DRIVEID(pPath);
    else
        return TRUE;

Retry:

    err = SheGetDir(drive + 1, szTemp);

    if (err)
        goto DiskNotThere;

    return TRUE;

    DiskNotThere:
    wError = (WORD)GetExtendedError();

    if (wError == 0x15) {
        // drive not ready (no disk in the drive)

        LoadString(hAppInstance, IDS_COPYERROR + wFunc, szTitle, sizeof(szTitle));
        LoadString(hAppInstance, IDS_DRIVENOTREADY, szTemp, sizeof(szTemp));
        wsprintf(szMessage, szTemp, drive + 'A');
        if (MessageBox(hwnd, szMessage, szTitle, MB_ICONEXCLAMATION | MB_RETRYCANCEL) == IDRETRY)
            goto Retry;
        else
            return FALSE;
    } else if (wError == 0x1F) {
        // general failue (disk not formatted)

        LoadString(hAppInstance, IDS_COPYERROR + wFunc, szTitle, sizeof(szTitle));
        LoadString(hAppInstance, IDS_UNFORMATTED, szTemp, sizeof(szTemp));
        wsprintf(szMessage, szTemp, drive + 'A');
        if (MessageBox(hwnd, szMessage, szTitle, MB_ICONEXCLAMATION| MB_YESNO) == IDYES) {
            HWND hwndSave;

            // this is ugly: hdlgProgress is a global that is used
            // by the copy code and the format code.  this should
            // be rewritten so it is not a global (hdlgProgress should
            // be passed to all QueryAbort() functions, etc)

            hwndSave = hdlgProgress;
            nLastDriveInd = 0;
            for (i = 0; i < cDrives; i++) {
                if (IsRemovableDrive(rgiDrive[i])) {
                    if (rgiDrive[i] == drive)
                        break;
                    nLastDriveInd++;
                }
            }
            fFormatFlags |= FF_ONLYONE;     // alow only one format

            if (FormatDiskette(hwnd) != TRUE) {
                hdlgProgress = hwndSave;
                return FALSE;
            }
            hdlgProgress = hwndSave;
            goto Retry;
        } else
            return FALSE;
    }

    LoadString(hAppInstance, IDS_COPYERROR + wFunc, szTitle, 32);
    LoadString(hAppInstance, IDS_NOSUCHDRIVE, szTemp, sizeof(szTemp));
    wsprintf(szMessage, szTemp, drive + 'A');
    MessageBox(hwnd, szMessage, szTitle, MB_ICONHAND);

    return FALSE;
}



VOID
BuildDateLine(
             LPSTR szTemp,
             PLFNDTA plfndta
             )
{
    wsprintf(szTemp, szBytes, plfndta->fd.nFileSizeLow);
    lstrcat(szTemp, szSpace);
    PutDate(&plfndta->fd.ftLastWriteTime, szTemp + lstrlen(szTemp));
    lstrcat(szTemp, szSpace);
    PutTime(&plfndta->fd.ftLastWriteTime, szTemp + lstrlen(szTemp));
}


typedef struct {
    LPSTR pFileDest;
    LPSTR pFileSource;
    PLFNDTA plfndtaDest;
    PLFNDTA plfndtaSrc;
    INT bWriteProtect;
} PARAM_REPLACEDLG, *LPPARAM_REPLACEDLG;


VOID
SetDlgItemPath(
              HWND hDlg,
              INT id,
              LPSTR pszPath
              )
{
    RECT rc;
    HDC hdc;
    HFONT hFont;
    CHAR szPath[MAXPATHLEN+1];      // can have one extra char
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, id);

    if (!hwnd)
        return;

    lstrcpy(szPath, pszPath);

    GetClientRect(hwnd, &rc);

    hdc = GetDC(hDlg);
    hFont = (HANDLE)SendMessage(hwnd, WM_GETFONT, 0, 0L);
    if (hFont = SelectObject(hdc, hFont)) {
        CompactPath(hdc, szPath, (WORD)rc.right);
        SelectObject(hdc, hFont);
    }
    ReleaseDC(hDlg, hdc);
    SetWindowText(hwnd, szPath);
}



INT_PTR
APIENTRY
ReplaceDlgProc(
              register HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    STKCHK();

    switch (wMsg) {
        case WM_INITDIALOG:
            {
#define lpdlgparams ((LPPARAM_REPLACEDLG)lParam)

                if (lpdlgparams->bWriteProtect) {
                    LoadString(hAppInstance, IDS_WRITEPROTECTFILE, szMessage, sizeof(szMessage));
                    SetDlgItemText(hDlg, IDD_STATUS, szMessage);
                }

                EnableWindow(GetDlgItem(hDlg, IDD_YESALL), !lpdlgparams->bWriteProtect && ManySource);

                lstrcpy(szMessage, lpdlgparams->pFileSource);
                lstrcat(szMessage, "?");
                SetDlgItemPath(hDlg, IDD_FROM, szMessage);

                if (lpdlgparams->pFileDest) {
                    BuildDateLine(szMessage, lpdlgparams->plfndtaSrc);
                    SetDlgItemText(hDlg, IDD_DATE2, szMessage);

                    SetDlgItemPath(hDlg, IDD_TO, lpdlgparams->pFileDest);
                    BuildDateLine(szMessage, lpdlgparams->plfndtaDest);
                    SetDlgItemText(hDlg, IDD_DATE1, szMessage);
                }

                break;
            }

        case WM_COMMAND:
            {
                WORD id;

                id = GET_WM_COMMAND_ID(wParam, lParam);
                switch (id) {
                    case IDD_HELP:
                        goto DoHelp;

                    case IDD_FLAGS:
                        break;

                    case IDD_YESALL:
                        *pbConfirmAll = TRUE;
                        id = IDYES;
                        // fall through
                    case IDYES:
                        // fall through
                    default:        // this is IDNO and IDCANCEL
                        EndDialog(hDlg, id);
                        return FALSE;
                }
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}





WORD
ConfirmDialog(
             HWND hDlg, WORD dlg,
             LPSTR pFileDest, PLFNDTA plfndtaDest,
             LPSTR pFileSource, PLFNDTA plfndtaSrc,
             BOOL bConfirmByDefault,
             BOOL *pbAll
             )
{
    INT w;
    PARAM_REPLACEDLG params;

    params.pFileDest = pFileDest;
    params.pFileSource = pFileSource;
    params.plfndtaDest = plfndtaDest;
    params.plfndtaSrc = plfndtaSrc;
    params.bWriteProtect = FALSE;

    pbConfirmAll = pbAll;         // set global for dialog box

    if (plfndtaDest->fd.dwFileAttributes & (ATTR_READONLY | ATTR_SYSTEM | ATTR_HIDDEN)) {
        DWORD dwSave = dwContext;

        dwContext = IDH_DLGFIRST + dlg;

        params.bWriteProtect = TRUE;
        w = (INT)DialogBoxParam(hAppInstance, MAKEINTRESOURCE(dlg), hDlg, ReplaceDlgProc, (LPARAM)&params);
        dwContext = dwSave;

        if (w == IDYES) {
            lstrcpy(szMessage, pFileDest ? (LPSTR)pFileDest : (LPSTR)pFileSource);
            FixAnsiPathForDos(szMessage);
            WFSetAttr(szMessage, plfndtaDest->fd.dwFileAttributes & ~(ATTR_READONLY|ATTR_HIDDEN|ATTR_SYSTEM));
        }

    } else if (!bConfirmByDefault || *pbConfirmAll) {
        w = IDYES;
    } else {
        DWORD dwSave = dwContext;

        dwContext = IDH_DLGFIRST + dlg;
        w = (INT)DialogBoxParam(hAppInstance, MAKEINTRESOURCE(dlg), hDlg, ReplaceDlgProc, (LPARAM)&params);
        dwContext = dwSave;
    }

    if (w == -1)
        w = DE_INSMEM;

    return (WORD)w;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  NetCheck() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* check rmdirs and mkdirs with the net driver
 */

WORD
APIENTRY
NetCheck(
        LPSTR pPath,
        WORD wType
        )
{
    UNREFERENCED_PARAMETER(pPath);
    UNREFERENCED_PARAMETER(wType);

    return WN_SUCCESS;
}



/*** FIX30: This "could use some cleaning up." ***/
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MergePathName() -                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  Used to generate destination filenames given a pattern and an original
 *  source name.  ? is replaced by the corresponding character in the source,
 *  and * is replaced by the remainder of the source name.
 *
 *  pPath   path with wildcards to be expanded
 *  pName   mask used to expand pName
 *
 * DBCS by 07/21/90 - Yukinin
 *
 */

VOID
MergePathName(
             LPSTR pPath,
             LPSTR pName
             )
{
    INT   i;
    INT   cch;
    LPSTR pWild, p2, pEnd;
    BOOL  bNoDir  = FALSE;
    CHAR  szWildPart[13];

    // if there are no wild cards the destination path does not need merging.
    if (!IsWild(pPath))
        return;

    if (LFNMergePath(pPath,pName))
        return;

    // copy only 8.3... this part may not be fully qualified for rename
    pWild = FindFileName(pPath);

    for (p2=szWildPart,i=0; *pWild && *pWild != '.' && i<8; i++, pWild++, p2++) {
        *p2 = *pWild;
        if (IsDBCSLeadByte(*pWild)) {
            if (i == 7)
                break;
            *(++p2) = *(++pWild);
            i++;
        }
    }

    while (*pWild && *pWild != '.')
        pWild = (LPSTR)AnsiNext(pWild);

    if (*pWild == '.') {
        *p2++ = '.';
        pWild++;
        for (i=0; *pWild && i < 3; i++, pWild++, p2++) {
            *p2 = *pWild;
            if (IsDBCSLeadByte( *pWild )) {
                if (i == 2)
                    break;
                *(++p2) = *(++pWild);
                i++;
            }
        }
    }
    *p2 = 0;

    // szWildPart now has the 8.3 form of the wildcard mask

    RemoveLast(pPath);
    AddBackslash(pPath);
    for (pEnd = pPath; *pEnd; pEnd++);    // point to end of string

    pWild = szWildPart;
    cch = 8;

    merge:

    for (i=0; i < cch; i+=(IsDBCSLeadByte(*pWild)?2:1), pWild=AnsiNext(pWild)) {
        switch (*pWild) {
            case '\0':
            case ' ':
            case '.':
                break;

            case '*':
                pWild--;
                /*** FALL THRU ***/

            case '?':
                if (*pName && *pName!='.')
                    *pEnd++ = *pName++;
                continue;

            default:
                *pEnd++ = *pWild;
                if (IsDBCSLeadByte(*pWild)) {
                    *pEnd++ = pWild[1];
                    if (*pName && *pName != '.')
                        pName++;
                }
                continue;
        }
        break;
    }

    while (*pName && *pName != '.')
        pName = AnsiNext(pName);
    if (*pName)
        pName++;

    while (*pWild && *pWild != '.')
        pWild = AnsiNext(pWild);
    if (*pWild)
        pWild++;

    if (*pWild) {
        *pEnd++ = '.';
        cch = 3;
        goto merge;       // do it for the extension part now
    } else {
        if (pEnd[-1]=='.')
            pEnd[-1]=0;
        else
            pEnd[0] = TEXT('\0');
    }

    QualifyPath(pPath);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsInvalidPath() -                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Checks to see if a file spec is an evil character device or if it is
 * too long...
 */

BOOL
IsInvalidPath(
             register LPSTR pPath
             )
{
    CHAR  sz[9];
    INT   n = 0;

    if (lstrlen(pPath) >= MAXPATHLEN-1)
        return (TRUE);

    pPath = FindFileName(pPath);

    while (*pPath && *pPath != '.' && *pPath != ':' && n < 8) {
        if (IsDBCSLeadByte( *pPath )) {
            if (n == 7)
                break;
            sz[n++] = *pPath;
        }
        sz[n++] = *pPath++;
    }

    sz[n] = TEXT('\0');

    if (!lstrcmpi(sz,"CON"))
        return (TRUE);

    if (!lstrcmpi(sz,"MS$MOUSE"))
        return (TRUE);

    if (!lstrcmpi(sz,"EMMXXXX0"))
        return (TRUE);

    if (!lstrcmpi(sz,"CLOCK$"))
        return (TRUE);

    return (FALSE);
}


PLFNDTA CurPDTA(PCOPYROOT pcr)
{
    if (pcr->cDepth) {
        return (pcr->rgDTA + pcr->cDepth - 1);
    } else {
        return pcr->rgDTA;
    }
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetNextCleanup() -                          */
/*                                      */
/*--------------------------------------------------------------------------*/

VOID
GetNextCleanup(
              PCOPYROOT pcr
              )
{
    while (pcr->cDepth) {
        WFFindClose(CurPDTA(pcr));
        pcr->cDepth--;
    }
}


/* GetNameDialog
 *
 *  Runs the dialog box to prompt the user for a new filename when copying
 *  or moving from HPFS to FAT.
 */

WORD GetNameDialog(WORD, LPSTR, LPSTR);
INT_PTR  APIENTRY GetNameDlgProc(HWND,UINT,WPARAM,LPARAM);

WORD wDialogOp;
LPSTR pszDialogFrom;
LPSTR pszDialogTo;

INT_PTR
APIENTRY
GetNameDlgProc(
              HWND hwnd,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    CHAR szT[14];
    LPSTR p;
    INT i, j, cMax, fDot;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            // inform the user of the old name
            SetDlgItemText(hwnd, IDD_FROM, pszDialogFrom);

            // generate a guess for the new name
            p = FindFileName(pszDialogFrom);
            for (i = j = fDot = 0, cMax = 8; *p; p++) {
                if (*p == '.') {
                    // if there was a previous dot, step back to it
                    // this way, we get the last extension
                    if (fDot)
                        i -= j+1;

                    // set number of chars to 0, put the dot in
                    j = 0;
                    szT[i++] = '.';

                    // remember we saw a dot and set max 3 chars.
                    fDot = TRUE;
                    cMax = 3;
                } else if (j < cMax && IsValidChar(*p,FALSE)) {
                    if (IsDBCSLeadByte(*p)) {
                        szT[i] = *p++;
                        if (++j >= cMax)
                            continue;
                        ++i;
                    }
                    j++;
                    szT[i++] = *p;
                }
            }
            szT[i] = 0;
            SetDlgItemText(hwnd, IDD_TO, szT);
            SendDlgItemMessage(hwnd,IDD_TO,EM_LIMITTEXT,13,0L);

            // directory the file will go into
            RemoveLast(pszDialogTo);
            SetDlgItemText(hwnd, IDD_DIR, pszDialogTo);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    GetDlgItemText(hwnd,IDD_TO,szT,14);
                    AppendToPath(pszDialogTo,szT);
                    QualifyPath(pszDialogTo);
                    EndDialog(hwnd,IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hwnd,IDCANCEL);
                    break;

                case IDD_HELP:
                    goto DoHelp;

                case IDD_TO:
                    GetDlgItemText(hwnd,IDD_TO,szT,14);
                    for (p = szT; *p; p=AnsiNext(p))
                    {
                        if (!IsValidChar(*p,FALSE))
                            break;
                    }

                    EnableWindow(GetDlgItem(hwnd,IDOK),((!*p) && (p != szT)));
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hwnd);
                return TRUE;
            }
            return FALSE;
    }

    return TRUE;
}

WORD
GetNameDialog(
             WORD wOp,
             LPSTR pFrom,
             LPSTR pTo
             )
{
    WORD wRet = -1;
    DWORD dwSave;

    dwSave = dwContext;
    dwContext = IDH_DLGFIRST + LFNTOFATDLG;

    wDialogOp = wOp;
    pszDialogFrom = pFrom;
    pszDialogTo = pTo;

    wRet = (WORD)DialogBox(hAppInstance, MAKEINTRESOURCE(LFNTOFATDLG), hdlgProgress, GetNameDlgProc);
    dwContext = dwSave;
    return wRet;
}

/*============================================================================
;
; GetNextPair
;
; The following function determines the next pair of files to copy, rename,
; move, or delete.
;
; Parameters:
;
; pcr     - Pointer to structure for recursing directory tree
; pFrom   - Source file or directory to copy
; pToPath - Path to destination file or directory
; pToSpec - Raw destination file or directory name
; wFunc   - Operation being performed.  Can be one of:
;
;           FUNC_DELETE - Delete files in pFrom
;           FUNC_RENAME - Rename files (same directory)
;           FUNC_MOVE   - Move files in pFrom to pTo (different disk)
;           FUNC_COPY   - Copy files in pFrom to pTo
;
; Return Value:  Type of operation to perform.  Can be one of:
;
;                OPER_ERROR  - Error processing filenames
;                OPER_DOFILE - Go ahead and copy, rename, or delete file
;                OPER_MKDIR  - Make a directory specified in pTo
;                OPER_RMDIR  - Remove directory
;                0           - No more files left
;
; Revision History:
;
; Modified by C. Stevens, August, 1991.  Added logic so that we would call
; IsTheDiskReallyThere only once per drive.  Also changed some of the code
; to minimize the number of calls which access the disk.
;
============================================================================*/

WORD
GetNextPair(
           PCOPYROOT pcr,
           PSTR pFrom,
           PSTR pToPath,
           PSTR pToSpec,
           WORD wFunc
           )

{
    PSTR pT;                  /* Temporary pointer */
    WORD wOp;                 /* Return value (operation to perform */
    PLFNDTA pDTA;             /* Pointer to file DTA data */
    CHAR szOEM[MAXPATHLEN+1]; /* OEM version of string */

    STKCHK();
    *pFrom = TEXT('\0');
    dbg(("GetNextPair(-,-,%s,%s,%d);\r\n", (LPSTR)pToPath, (LPSTR)pToSpec, wFunc));

    /* Keep recursing directory structure until we get to the bottom */

    while (TRUE) {
        dbg (("    top of loop....\r\n"));
        if (pcr->cDepth) {

            /* The directory we returned last call needs to be recursed. */

            pDTA = pcr->rgDTA + pcr->cDepth - 1;   // use this DTA below

            dbg (("    pcr->cDepth=%d\r\n",pcr->cDepth));

            if (pcr->fRecurse && pcr->cDepth == 1 && !pcr->rgDTA[0].fd.cFileName[0])
                /* The last one was the recursion root. */
                goto BeginDirSearch;

            if (pcr->cDepth >= (MAXDIRDEPTH - 1)) {    // reached the limit?
                wOp = OPER_ERROR | DE_PATHTODEEP;
                goto ReturnPair;
            }

            if (pcr->fRecurse && (pDTA->fd.dwFileAttributes & ATTR_DIR) &&
                !(pDTA->fd.dwFileAttributes & ATTR_RETURNED)) {

                /* Was returned on last call, begin search. */

                pDTA->fd.dwFileAttributes |= ATTR_RETURNED;

                pcr->cDepth++;
                pDTA++;

                BeginDirSearch:

                /* Search for all subfiles in directory. */

                dbg (("    BeginDirSearch\r\n"));
                AppendToPath (pcr->sz,szStarDotStar);
                goto BeginSearch;
            }

            SkipThisFile:

            /* Search for the next matching file. */

            dbg (("    SkipThisFile:\r\n"));
            if (!WFFindNext (pDTA)) {
                dbg (("    FindNext() fails\r\n"));
                WFFindClose (pDTA);

                LeaveDirectory:

                /* This spec has been exhausted... */

                pcr->cDepth--;

                /* Remove the child file spec. */

                RemoveLast (pcr->sz);
                RemoveLast (pcr->szDest);

                if (pcr->fRecurse) {

                    /* Tell the move/copy driver it can now delete
                       the source directory if necessary. */

                    wOp = OPER_RMDIR;
                    goto ReturnPair;
                }

                /* Not recursing, get more stuff. */

                continue;
            }

            ProcessSearchResult:

            /* Got a file or dir in the DTA which matches the wild card
                originally passed in...  */

            dbg (("     ProcessSearchResult:\r\n"));
            dbg (("     found %s\r\n",(LPSTR)pDTA->fd.cFileName));
            if (pDTA->fd.dwFileAttributes & ATTR_DIR) {

                /* Ignore directories if we're not recursing. */

                if (!pcr->fRecurse)
                    goto SkipThisFile;

                /* Skip the current and parent directories. */

                if (pDTA->fd.cFileName[0]=='.') {
                    if (!pDTA->fd.cFileName[1] || pDTA->fd.cFileName[1] == '.')
                        goto SkipThisFile;
                }

                /* We need to create this directory, and then begin searching
                   for subfiles. */

                wOp = OPER_MKDIR;
                RemoveLast (pcr->sz);
                OemToAnsi (pDTA->fd.cFileName,pDTA->fd.cFileName);
                AppendToPath (pcr->sz,pDTA->fd.cFileName);
                AppendToPath (pcr->szDest,pDTA->fd.cFileName);
                goto ReturnPair;
            }

            if (pcr->fRecurse || !(pDTA->fd.dwFileAttributes & ATTR_DIR)) {

                /* Remove the original spec. */

                RemoveLast (pcr->sz);

                /* Replace it. */

                AppendToPath (pcr->sz,pDTA->fd.cFileName);

                /* Convert to ANSI. */

                pT = FindFileName (pcr->sz);
                OemToAnsi (pT,pT);

                /* If its a dir, tell the driver to create it
                   otherwise, tell the driver to "operate" on the file. */

                wOp = (WORD)((pDTA->fd.dwFileAttributes & ATTR_DIR) ? OPER_RMDIR : OPER_DOFILE);
                goto ReturnPair;
            }
            continue;
        } else {

            /* Read the next source spec out of the raw source string. */

            pcr->fRecurse = 0;
            pcr->pSource = GetNextFile (pcr->pSource,pcr->sz,sizeof(pcr->sz));
            pcr->szDest[0] = 0;
            if (!pcr->pSource)
                return (0);

            /* Fully qualify the path */

            QualifyPath(pcr->sz);

            /* Ensure the source disk really exists before doing anything.
               Only call IsTheDiskReallyThere once for each drive letter.
               Set pcr->cIsDiskThereCheck[DRIVEID] after disk has been
               checked.  Modified by C. Stevens, August 1991 */

            if (pcr->sz[1]==':' && !pcr->cIsDiskThereCheck[DRIVEID (pcr->sz)]) {
                if (!IsTheDiskReallyThere(hdlgProgress, pcr->sz, wFunc))
                    return (0);
                pcr->cIsDiskThereCheck[DRIVEID (pcr->sz)] = 1;
            }

            /* Classify the input string. */

            if (IsWild (pcr->sz)) {

                /* Wild card... operate on all matches but not recursively. */

                pcr->cDepth = 1;
                pDTA = pcr->rgDTA;
                pcr->pRoot = NULL;

                BeginSearch:

                dbg (("   BeginSearch: (on %s)\r\n",(LPSTR)pcr->sz));

                /* Quit if pcr->sz gets too big. */

                if (lstrlen (pcr->sz) - lstrlen (FindFileName (pcr->sz)) >= MAXPATHLEN)
                    goto SearchStartFail;

                lstrcpy (szOEM,pcr->sz);
                FixAnsiPathForDos (szOEM);

                /* Search for the wildcard spec in pcr->sz. */

                if (!WFFindFirst(pDTA, szOEM, ATTR_ALL)) {

                    SearchStartFail:

                    dbg(("   StartSearchFail:\r\n"));
                    if (pcr->fRecurse) {

                        /* We are inside a recursive directory delete, so
                           instead of erroring out, go back a level */

                        goto LeaveDirectory;
                    }
                    lstrcpy (pFrom,pcr->sz);

                    /* Back up as if we completed a search. */

                    RemoveLast (pcr->sz);
                    pcr->cDepth--;

                    /* Find First returned an error.  Return FileNotFound. */

                    wOp = OPER_ERROR | DE_FILENOTFOUND;
                    goto ReturnPair;
                }
                goto ProcessSearchResult;
            } else {

                /* This could be a file or a directory.  Fill in the DTA
                   structure for attrib check */

                if (!IsRootDirectory(pcr->sz)) {
                    lstrcpy(szOEM,pcr->sz);
                    FixAnsiPathForDos(szOEM);
                    if (!WFFindFirst(pcr->rgDTA, szOEM, ATTR_ALL)) {
                        wOp = OPER_ERROR | DE_FILENOTFOUND;
                        goto ReturnPair;
                    }
                    WFFindClose(pcr->rgDTA);
                }

                /* Now determine if its a file or a directory */

                pDTA = pcr->rgDTA;
                if (IsRootDirectory(pcr->sz) || (pDTA->fd.dwFileAttributes & ATTR_DIR)) {

                    /* Process directory */

                    if (wFunc == FUNC_RENAME) {
                        if (IsRootDirectory (pcr->sz))
                            wOp = OPER_ERROR | DE_ROOTDIR;
                        else
                            wOp = OPER_DOFILE;
                        goto ReturnPair;
                    }

                    /* Directory: operation is recursive. */

                    pcr->fRecurse = TRUE;
                    pcr->cDepth = 1;
                    pDTA->fd.cFileName[0] = 0;
                    pcr->pRoot = FindFileName (pcr->sz);
                    lstrcpy (pcr->szDest,pcr->pRoot);
                    wOp = OPER_MKDIR;
                    goto ReturnPair;
                } else {

                    /* Process file */

                    pcr->pRoot = NULL;
                    wOp = OPER_DOFILE;
                    goto ReturnPair;
                }
            }
        }
    }

    ReturnPair:

    /* The source filespec has been derived into pcr->sz
       that is copied to pFrom.  pcr->sz and pToSpec are merged into pTo. */

    dbg(("    ReturnPair:\r\n"));
    if (!*pFrom)
        lstrcpy(pFrom,pcr->sz);
    QualifyPath(pFrom);

    if (wFunc != FUNC_DELETE) {
        if (wFunc == FUNC_RENAME && !*pToPath) {
            lstrcpy(pToPath, pFrom);
            RemoveLast(pToPath);
            AppendToPath(pToPath, pToSpec);
        } else {
            AppendToPath(pToPath,pcr->szDest);
            if (wOp == OPER_MKDIR)
                RemoveLast(pToPath);
            AppendToPath(pToPath,pToSpec);
        }

        if ((wOp == OPER_MKDIR || wOp == OPER_DOFILE) &&
            (!IsLFNDrive(pToPath) && IsLFNDrive(pFrom))  &&
            IsLFN (FindFileName (pFrom)) &&
            (IsWild(pToSpec) || IsLFN(pToSpec))) {

            if (GetNameDialog(wOp, pFrom, pToPath) != IDOK)
                return 0;   /* User cancelled the operation, return failure */

            /* Update the "to" path with the FAT name chosen by the user. */

            if (wOp == OPER_MKDIR) {
                RemoveLast(pcr->szDest);
                AppendToPath(pcr->szDest, FindFileName(pToPath));
            }
        } else
            MergePathName(pToPath, FindFileName(pFrom));
    }

    if (wOp == OPER_MKDIR) {

        /* Make sure the new directory is not a subdir of the original... */

        while (*pFrom && *pFrom == *pToPath) {
            pFrom++;
            pToPath++;
        }
        if (!*pFrom && (!*pToPath || *pToPath == '\\')) {

            /* The two fully qualified strings are equal up to the end of the
               source directory ==> the destination is a subdir.Must return
               an error. */

            wOp = OPER_ERROR | DE_DESTSUBTREE;
        }
    }

    return wOp;
}


VOID
CdDotDot (
         PSTR szOrig
         )
{
    CHAR szTemp[MAXPATHLEN];

    STKCHK();

    lstrcpy(szTemp, szOrig);
    StripFilespec(szTemp);
    SheChangeDir(szTemp);
}

/* p is a fully qualified ANSI string. */

BOOL
IsCurrentDirectory (
                   PSTR p
                   )
{
    CHAR szTemp[MAXPATHLEN];

    STKCHK();

    SheGetDir(DRIVEID(p) + 1, szTemp);
    OemToAnsi(szTemp, szTemp);
    return (lstrcmpi(szTemp, p) == 0);
}


//
// test input for "multiple" filespec
//
// examples:
//  0   foo.bar         (single non directory file)
//  1   *.exe           (wild card)
//  1   foo.bar bletch.txt  (multiple files)
//  2   c:\         (directory)
//
// note: this may hit the disk in the directory check
//

INT
CheckMultiple(
             register PSTR pInput
             )
{
    PSTR pT;
    CHAR szTemp[MAXPATHLEN];

    /* Wildcards imply multiple files. */
    if (IsWild(pInput))
        return 1;     // wild card

    /* More than one thing implies multiple files. */
    pT = GetNextFile(pInput, szTemp, sizeof(szTemp));
    if (!pT)
        return 0;     // blank string

    StripBackslash(szTemp);

    if (IsDirectory(szTemp))
        return 2;     // directory

    pT = GetNextFile(pT, szTemp, sizeof(szTemp));

    return pT ? 1 : 0;    // several files, or just one
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DialogEnterFileStuff() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Prevents the user from diddling anything other than the cancel button. */

VOID
DialogEnterFileStuff(
                    register HWND hwnd
                    )
{
    register HWND hwndT;

    /* set the focus to the cancel button so the user can hit space or esc
     */
    if (hwndT = GetDlgItem(hwnd, IDCANCEL)) {
        SetFocus(hwndT);
        SendMessage(hwnd,DM_SETDEFID,IDCANCEL,0L);
    }

    /* disable the ok button and the edit controls
     */
    if (hwndT = GetDlgItem(hwnd, IDOK))
        EnableWindow(hwndT, FALSE);

    if (hwndT = GetDlgItem(hwnd, IDD_TO))
        EnableWindow(hwndT, FALSE);

    if (hwndT = GetDlgItem(hwnd, IDD_FROM))
        EnableWindow(hwndT, FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Notify() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Sets the status dialog item in the modeless status dialog box. */

// used for both the drag drop status dialogs and the manual user
// entry dialogs so be careful what you change

VOID
Notify(
      HWND hDlg,
      WORD idMessage,
      PSTR szFrom,
      PSTR szTo
      )
{
    CHAR szTemp[40];

    if (!bCopyReport)
        return;

    if (idMessage) {
        LoadString(hAppInstance, idMessage, szTemp, sizeof(szTemp));
        SetDlgItemText(hDlg, IDD_STATUS, szTemp);
        SetDlgItemPath(hDlg, IDD_NAME, szFrom);
    } else {
        SetDlgItemText(hDlg, IDD_STATUS, szNULL);
        SetDlgItemText(hDlg, IDD_NAME, szNULL);
    }

    // is this the drag/drop status dialog or the move/copy dialog

    SetDlgItemPath(hDlg, IDD_TONAME, szTo);

}

//
// BOOL IsWindowsFile(LPSTR szFileOEM)
//
// this is a bit strange.  kernel strips off the path info so he
// will match only on the base name of the file.  so if the base
// name matches a currently open windows file we get the full
// path string and compare against that.  that will tell
// us that we have a file that kernel has open.
//
// LFN: detect long names and ignore them?

BOOL
IsWindowsFile(
             LPSTR szFileOEM
             )
{
    HANDLE hMod;
    CHAR szModule[MAXPATHLEN];

    STKCHK();

    /* kernel can't load an lfn...
     */
    if (GetNameType(szFileOEM) == FILE_LONG)
        return FALSE;

    // kernel won't accept long paths

    lstrcpy(szModule, szFileOEM);
    StripPath(szModule);

    hMod = GetModuleHandle(szModule);

    // check for one cause that's what's returned if its MSDOS
    // but it isn't really loaded because of xl 2.1c kernel hack
    if (!hMod || hMod == (HANDLE)1)
        return FALSE;

    GetModuleFileName(hMod, szModule, sizeof(szModule));

    if (!lstrcmpi(szFileOEM, szModule))     // they are both OEM & we
        return TRUE;                    // just care about equality
    else
        return FALSE;
}


WORD
SafeFileRemove(
              LPSTR szFileOEM
              )
{
    if (IsWindowsFile(szFileOEM))
        return DE_WINDOWSFILE;
    else
        return WFRemove(szFileOEM);
}


INT
APIENTRY
WF_CreateDirectory(
                  HWND hwndParent,
                  LPSTR szDestOEM
                  )
{
    INT ret = 0;
    CHAR szTemp[MAXPATHLEN + 1];    // +1 for AddBackslash()
    LPSTR p;
    BOOL bCheckPath = IsRemoteDrive(DRIVEID(szDestOEM));

    STKCHK();

#ifdef DEBUG
    if (szDestOEM[1] != ':')
        OutputDebugString("CreateDirectory() with non qualified path\r\n");
#endif

    // now create the full dir tree on the destination

    strncpy(szTemp, szDestOEM, sizeof(szTemp)-1);

    AddBackslash(szTemp); // for the loop below

    p = szTemp + 3;   // assume we have 'X:\' to start

    // create each part of the dir in order

    while (*p) {
        while (*p && *p != '\\')
            p = AnsiNext(p);

        if (*p) {

            *p = 0;

            if (!(ret = MKDir(szTemp))) {
                if (bCheckPath) {
                    static CHAR szTempTemp[] = "temptemp.tmp";

                    BOOL bFoundFile = FALSE;
                    PSTR pEnd;
                    CHAR szTempFile[MAXPATHLEN+sizeof(szTempTemp)];
                    LFNDTA DTA;
                    HDC hDC;
                    INT fh;

                    /* Note that this assumes the dir has just been created,
                     * so it is empty (except possibly for "." and "..")
                     */
                    lstrcpy(szTempFile, szTemp);
                    pEnd = szTempFile + lstrlen(szTempFile);
                    *pEnd++ = '\\';
                    lstrcpy(pEnd, szTempTemp);
                    if (fh=_lcreat(szTempFile, 0)!= -1) {
                        _lclose(fh);
                        lstrcpy(pEnd, szStarDotStar);
                        if (WFFindFirst(&DTA, szTempFile, ATTR_ALL&(~ATTR_DIR))) {
                            do {
                                if (!lstrcmpi(DTA.fd.cFileName, szTempTemp)) {
                                    bFoundFile = TRUE;
                                    break;
                                }
                            } while (WFFindNext(&DTA)) ;
                            WFFindClose(&DTA);
                        }
                        lstrcpy(pEnd, szTempTemp);
                        WFRemove(szTempFile);
                    }

                    if (!bFoundFile) {
                        *(pEnd-1) = '\0';
                        hDC = GetDC(NULL);
                        CompactPath(hDC, szTempFile, (WORD)(GetSystemMetrics(SM_CXSCREEN)/2));
                        ReleaseDC(NULL, hDC);

                        LoadString(hAppInstance, IDS_CREATELONGDIR,
                                   szTitle, sizeof(szTitle));
                        wsprintf(szMessage, szTitle, (LPSTR)szTempFile);
                        LoadString(hAppInstance, IDS_CREATELONGDIRTITLE,
                                   szTitle, sizeof(szTitle));

                        if (MessageBox(hwndParent, szMessage, szTitle,
                                       MB_ICONHAND|MB_YESNO) != IDYES) {
                            RMDir(szTemp);
                            return (DE_OPCANCELLED);
                        }
                    }
                }

                /* Allow the WM_FILESYSCHANGE messages to be processed
                 */
                wfYield();
            }

            *p++ = '\\';
        }
    }

    return ret;   // return the last error code
}

/*============================================================================
;
; WFMoveCopyDriver
;
; The following function is the mainline function for COPYing, RENAMEing,
; DELETEing, and MOVEing single or multiple files.
;
; Parameters:
;
; pFrom - String containing list of source specs
; pTo   - String containing destination specs
; wFunc - Operation to be performed.  Possible values are:
;         FUNC_DELETE - Delete files in pFrom
;         FUNC_RENAME - Rename files (same directory)
;         FUNC_MOVE   - Move files in pFrom to pTo (different disk)
;         FUNC_COPY   - Copy files in pFrom to pTo
;
; Return Value: A 0 indicates success.
;
; Modification History:
;
; August 1991 - Modified by C. Stevens.  Added code to allow us to queue
;               calls to GetNextPair.  The purpose of this is to examine as
;               many source files at once as possible.  This keeps the source
;               disk spinning, so we don't suffer from having to wait for the
;               source disk to speed up every time we call GetNextPair.  Also
;               see the comments for WFCopy and FileCopy.  I have changed the
;               code here so we can queue the copy operations.  This allows
;               us to open several source and destination files in one go,
;               minimizing seek time to the directory track.
;
============================================================================*/

WORD
APIENTRY
WFMoveCopyDriver(
                PSTR pFrom,
                PSTR pTo,
                WORD wFunc
                )
{
    INT i;                             // Counter
    WORD ret = 0;                      // Return value from WFMoveCopyDriver
    PSTR pSpec;                        // Pointer to file spec
    WORD wAttr;                        // File attributes
    WORD oper = 0;                     // Disk operation being performed
    CHAR szDestSpec[MAXFILENAMELEN+1]; // Dest file spec
    CHAR szDest[MAXPATHLEN];           // Dest file (ANSI string)
    CHAR szDestOEM[MAXPATHLEN];        // OEM version of above
    CHAR szSource[MAXPATHLEN];         // Source file (ANSI string)
    CHAR szSourceOEM[MAXPATHLEN];      // OEM version of above
    LFNDTA DTADest;                    // DTA block for reporting dest errors
    PLFNDTA pDTA;                      // DTA pointer for source errors
    PCOPYROOT pcr;                 // Structure for searching source tree
    BOOL bReplaceAll = FALSE;          // Replace all flag
    BOOL bSubtreeDelAll = FALSE;       // Delete entire subtree flag
    BOOL bDeleteAll = FALSE;           // Delete all files flag
    BOOL bFalse = FALSE;               // For cases that aren't disableable
    INT nNumQueue;                     // Number of calls to GetNextPair
    PGETNEXTQUEUE pGetNextQueue = NULL;// Pointer to GetNextPair queue buffer
    INT CurIDS = 0;            // Current string displayed in status

    /* Initialization stuff.  Disable all file system change processing until
       we're all done */

    STKCHK();

    bCopyReport = TRUE;
    szDest[0] = szSource[0] = 0;
    DisableFSC();

    /* Change all '/' characters to '\' characters in dest spec */

    CheckSlashies(pFrom);
    bUserAbort = FALSE;

    /* Check for multiple source files */

    ManySource = CheckMultiple(pFrom);

    /* Allocate buffer for searching the source tree */

    pcr = (PCOPYROOT)LocalAlloc(LPTR, sizeof(COPYROOT));
    if (!pcr) {
        ret = DE_INSMEM;
        goto ShowMessageBox;
    }

    /* Allocate a buffer so we can queue calls to GetNextPair. */

    pGetNextQueue = (PGETNEXTQUEUE)LocalAlloc(LPTR, COPYMAXFILES * sizeof (GETNEXTQUEUE));
    if (!pGetNextQueue) {
        ret = DE_INSMEM;
        goto ShowMessageBox;
    }

    /* Skip destination specific processing if we are deleting files */

    if (wFunc != FUNC_DELETE) {

        // it is an error condition if there are multiple files
        // specified as the dest (but not a single directory)

        pSpec = GetNextFile(pTo, szMessage, MAXPATHLEN);

        if (GetNextFile(pSpec, szMessage, MAXPATHLEN) != NULL) {
            // move, copy specified with multiple destinations
            // not allowed, error case
            ret = DE_MANYDEST;
            goto ShowMessageBox;
        }

        lstrcpy(pTo, szMessage);
        QualifyPath(pTo);

        if (wFunc == FUNC_RENAME) {
            // don't let them rename multiple files to one single file

            if ((ManySource == 1) && !IsWild(pTo)) {
                ret = DE_MANYSRC1DEST;
                goto ShowMessageBox;
            }

        } else {

            /* We are either executing FUNC_COPY or FUNC_MOVE at this point.
               Check that the destination disk is there.  NOTE: There's a disk
               access here slowing us down. */

            if (!IsTheDiskReallyThere(hdlgProgress,pTo,wFunc))
                goto CancelWholeOperation;

            // deal with case where directory is implicit in source
            // move/copy: *.* -> c:\windows, c:\windows -> c:\temp
            // or foo.bar -> c:\temp

            if (!IsWild(pTo) && (ManySource || IsDirectory(pTo))) {
                AddBackslash(pTo);
                lstrcat(pTo, szStarDotStar);
            }
        }

        /* FUNC_RENAME or FUNC_MOVE FUNC_COPY with a file name dest
           (possibly including wildcards).  Save the filespec and the path
           part of the destination */

        pSpec = FindFileName(pTo);
        lstrcpy(szDestSpec,pSpec);
        lstrcpy(szDest,pTo);
        RemoveLast(szDest);

        pSpec = szDest + lstrlen(szDest);
    }
    pcr->pSource = pFrom;

    /* Disable all but the cancel button on the notify dialog */

    DialogEnterFileStuff(hdlgProgress);

    /* Set up arguments for queued copy commands */

    lpCopyBuffer = NULL;
    pCopyQueue = NULL;

    while (pcr) {

        /* Allow the user to abort the operation */

        if (WFQueryAbort())
            goto CancelWholeOperation;

        /* Now queue up a bunch of GetNextPair calls. */

        for (nNumQueue = 0; nNumQueue < COPYMAXFILES; nNumQueue++) {

            /* Clean off the last filespec for multiple file copies */

            if (wFunc != FUNC_DELETE) {
                *pSpec = TEXT('\0');
            }

            oper = GetNextPair(pcr,szSource,szDest,szDestSpec,wFunc);

            /* Check for no operation or error */

            if (!oper) {
                LocalFree((HANDLE)pcr);
                pcr = NULL;
                break;
            }
            if ((oper & OPER_MASK) == OPER_ERROR) {
                ret = LOBYTE (oper);
                oper = OPER_DOFILE;
                goto ShowMessageBox;
            }

            pGetNextQueue[nNumQueue].nOper = oper;
            lstrcpy(pGetNextQueue[nNumQueue].szSource, szSource);
            lstrcpy(pGetNextQueue[nNumQueue].szDest, szDest);
            pGetNextQueue[nNumQueue].SourceDTA = *CurPDTA(pcr);
        }

        /* Execute the queued GetNextPair calls */

        for (i = 0; i < nNumQueue; i++) {

            /* Allow the user to abort the operation */

            if (WFQueryAbort())
                goto CancelWholeOperation;

            oper = (WORD)pGetNextQueue[i].nOper;
            lstrcpy(szSource, pGetNextQueue[i].szSource);
            lstrcpy(szDest, pGetNextQueue[i].szDest);
            pDTA = &pGetNextQueue[i].SourceDTA;

            dbg(("Gonna do OPER:%x FUNC:%x '%s' and '%s'.\r\n",oper,wFunc, (LPSTR)szSource, (LPSTR)szDest));

            /* Fix up source spec */

            lstrcpy (szSourceOEM,szSource);
            FixAnsiPathForDos (szSourceOEM);
            if (IsInvalidPath (szSource)) {
                ret = DE_ACCESSDENIED;
                goto ShowMessageBox;
            }

            if (wFunc != FUNC_DELETE) {

                /* Fix up dest spec */

                lstrcpy(szDestOEM, szDest);
                FixAnsiPathForDos(szDestOEM);
                if (!lstrcmpi(szSource, szDest)) {
                    ret = DE_SAMEFILE;
                    goto ShowMessageBox;
                } else if (IsInvalidPath (szDest)) {
                    ret = DE_ACCESSDENIED | ERRORONDEST;
                    goto ShowMessageBox;
                }

                /* Check to see if we are overwriting an existing file.  If so,
                   better confirm */

                if (oper == OPER_DOFILE) {

                    // we can avoid this expensive call on dos 4.0 and up
                    // by using the extended open don't replace option

                    if (WFFindFirst(&DTADest, szDestOEM, ATTR_ALL)) {
                        WFFindClose(&DTADest);

                        if (wFunc == FUNC_RENAME) {
                            ret = DE_RENAMREPLACE;
                            goto ShowMessageBox;
                        }

                        // we need to check if we are trying to copy a file
                        // over a directory and give a reasonable error message

                        switch (wAttr = ConfirmDialog (hdlgProgress,CONFIRMREPLACE,
                                                       szDest,&DTADest,szSource,
                                                       pDTA,bConfirmReplace,
                                                       &bReplaceAll)) {

                            case IDYES: /* Perform the delete */

                                if ((wFunc == FUNC_MOVE) &&
                                    (DRIVEID(szSource) == DRIVEID(szDest))) {

                                    /* For FUNC_MOVE we need to delete the
                         * destination first.  Do that now. */

                                    if (DTADest.fd.dwFileAttributes & ATTR_DIR) {
                                        if (IsCurrentDirectory(szDestOEM))
                                            CdDotDot(szDestOEM);

                                        switch (NetCheck(szDest, WNDN_RMDIR)) {

                                            case WN_SUCCESS:

                                                /* Remove directory */

                                                ret = RMDir(szDestOEM);
                                                break;

                                            case WN_CONTINUE:
                                                break;

                                            case WN_CANCEL:
                                                goto CancelWholeOperation;
                                        }
                                    } else {
                                        ret = SafeFileRemove (szDestOEM);
                                    }
                                    if (ret) {
                                        ret |= ERRORONDEST;
                                        goto ShowMessageBox;
                                    }
                                }
                                break;

                            case IDNO:

                                /* Don't perform operation on current file */

                                continue;

                            case IDCANCEL:
                                goto CancelWholeOperation;

                            default:
                                ret = (WORD) wAttr;
                                goto ShowMessageBox;
                        }
                    }
                }
            }

            /* Now determine which operation to perform */

            switch (oper | wFunc) {

                case OPER_MKDIR | FUNC_COPY:  // Create destination directory
                case OPER_MKDIR | FUNC_MOVE:  // Create dest, verify source delete

                    CurIDS = IDS_CREATINGMSG;
                    Notify(hdlgProgress, IDS_CREATINGMSG, szDest, szNULL);

                    switch (NetCheck(szDest, WNDN_MKDIR)) {
                        case WN_SUCCESS:
                            break;

                        case WN_CONTINUE:
                            goto SkipMKDir;

                        case WN_CANCEL:
                            goto CancelWholeOperation;
                    }

                    ret = (WORD)WF_CreateDirectory(hdlgProgress, szDestOEM);

                    if (!ret)
                        /* set attributes of dest to source (not including the
                           subdir and vollabel bits) */
                        WFSetAttr(szDestOEM, pDTA->fd.dwFileAttributes & ~(ATTR_DIR|ATTR_VOLUME));

                    // if it already exits ingore the error return
                    if (ret == DE_ACCESSDENIED)
                        ret = 0;

                    if (ret)
                        ret |= ERRORONDEST;

                    /* set attributes of new directory to those of the source */

                    SkipMKDir:
                    break;

                case OPER_MKDIR | FUNC_DELETE:

                    /* Confirm removal of directory on this pass.  The directories
                       are actually removed on the OPER_RMDIR pass */

                    /* We can't delete the root directory, so don't bother
                       confirming it */

                    if (IsRootDirectory(szSource))
                        break;

                    switch (wAttr = ConfirmDialog (hdlgProgress,CONFIRMRMDIR,
                                                   NULL,pDTA,szSource, NULL,
                                                   bConfirmSubDel,
                                                   &bSubtreeDelAll)) {

                        case IDYES:
                            break;

                        case IDNO:
                        case IDCANCEL:
                            goto CancelWholeOperation;

                        default:
                            ret = (WORD) wAttr;
                            goto ShowMessageBox;
                    }
                    break;

                case OPER_RMDIR | FUNC_MOVE:
                case OPER_RMDIR | FUNC_DELETE:

                    CurIDS = IDS_REMOVINGDIRMSG;
                    Notify(hdlgProgress, IDS_REMOVINGDIRMSG, szSource, szNULL);
                    if (IsRootDirectory (szSource))
                        break;
                    if (IsCurrentDirectory (szSource))
                        CdDotDot (szSource);

                    /* We already confirmed the delete at MKDIR time, so attempt
                       to delete the directory */

                    switch (NetCheck (szSource,WNDN_RMDIR)) {

                        case WN_SUCCESS:
                            ret = RMDir (szSourceOEM);
                            break;

                        case WN_CONTINUE:
                            break;

                        case WN_CANCEL:
                            goto CancelWholeOperation;
                    }
                    break;

                case OPER_RMDIR | FUNC_COPY:
                    break;

                case OPER_DOFILE | FUNC_COPY:

                    if (IsWindowsFile(szDestOEM)) {
                        ret = DE_WINDOWSFILE | ERRORONDEST;
                        break;
                    }

                    TRY_COPY_AGAIN:

                    /* Now try to copy the file.  Do extra error processing only
                       in 2 cases:

                       1) If a floppy is full let the user stick in a new disk
                       2) If the path doesn't exist (the user typed in
                          and explicit path that doesn't exits) ask if
                          we should create it for him.

                       NOTE:  This processing is normally done by WFCopy.  But in
                              the case where LFN copy support is invoked, we have
                              to support this error condition here.  Modified by
                              C. Stevens, August 1991 */

                    ret = WFCopy(szSourceOEM, szDestOEM);

                    if (bUserAbort)
                        goto CancelWholeOperation;

                    if ((((ret & ~ERRORONDEST) == DE_NODISKSPACE) &&
                         IsRemovableDrive(DRIVEID(szDestOEM))) ||
                        ((ret & ~ERRORONDEST) == DE_PATHNOTFOUND)) {

                        ret = (WORD)CopyMoveRetry(szDestOEM, (INT)ret);
                        if (!ret)
                            goto TRY_COPY_AGAIN;
                        else
                            goto CancelWholeOperation;
                    }

                    break;

                case OPER_DOFILE | FUNC_RENAME:
                    {
                        CHAR save1,save2;
                        PSTR p;

                        if (CurIDS != IDS_RENAMINGMSG) {
                            CurIDS = IDS_RENAMINGMSG;
                            Notify(hdlgProgress, IDS_RENAMINGMSG, szNULL, szNULL);
                        }

                        /* Get raw source and dest paths.  Check to make sure the
                           paths are the same */

                        p = FindFileName(szSource);
                        save1 = *p;
                        *p = TEXT('\0');
                        p = FindFileName(szDest);
                        save2 = *p;
                        *p = TEXT('\0');
                        ret = (WORD)lstrcmpi(szSource, szDest);
                        szSource[lstrlen(szSource)] = save1;
                        szDest[lstrlen(szDest)] = save2;
                        if (ret) {
                            ret = DE_DIFFDIR;
                            break;
                        }
                        goto DoMoveRename;
                    }

                case OPER_DOFILE | FUNC_MOVE:

                    if (CurIDS != IDS_MOVINGMSG) {
                        CurIDS = IDS_MOVINGMSG;
                        Notify(hdlgProgress, IDS_MOVINGMSG, szNULL, szNULL);
                    }
                    DoMoveRename:

                    /* Don't allow the user to rename from or to the root
                       directory */

                    if (IsRootDirectory(szSource)) {
                        ret = DE_ROOTDIR;
                        break;
                    }
                    if (IsRootDirectory(szDest)) {
                        ret = DE_ROOTDIR | ERRORONDEST;
                        break;
                    }

                    if (IsCurrentDirectory(szSource))
                        CdDotDot(szSource);

                    /* Confirm the rename */

                    switch (wAttr = ConfirmDialog (hdlgProgress,
                                                   (WORD)(wFunc == FUNC_MOVE ?
                                                          CONFIRMMOVE : CONFIRMRENAME),
                                                   NULL,pDTA,szSource,NULL,FALSE,
                                                   (BOOL *)&bFalse)) {

                        case IDYES:
                            break;

                        case IDNO:
                            continue;

                        case IDCANCEL:
                            goto CancelWholeOperation;

                        default:
                            ret = (WORD) wAttr;
                            goto ShowMessageBox;
                    }

                    if (IsWindowsFile(szSourceOEM)) {
                        ret = DE_WINDOWSFILE;
                    } else {
                        if (DRIVEID(szSource) == DRIVEID(szDest)) {
                            ret = WFMove(szSourceOEM, szDestOEM);
                            if (!ret)
                                /* set attributes of dest to those of the source */
                                WFSetAttr(szDestOEM, pDTA->fd.dwFileAttributes);
                        } else {
                            // we must force all copies to go through
                            // straight so we can remove the source
                            // and have the
                            ret = WFCopy(szSourceOEM, szDestOEM);

                            if (!ret) {
                                ret = EndCopy();
                                if (!ret)
                                    WFRemove(szSourceOEM);
                            }
                            if (bUserAbort)
                                goto CancelWholeOperation;
                        }
                    }
                    break;

                case OPER_DOFILE | FUNC_DELETE:

                    if (CurIDS != IDS_DELETINGMSG) {
                        CurIDS = IDS_DELETINGMSG;
                        Notify(hdlgProgress,IDS_DELETINGMSG,szNULL, szNULL);
                    }

                    /* Confirm the delete first */

                    switch (wAttr = ConfirmDialog (hdlgProgress,CONFIRMDELETE,
                                                   NULL,pDTA,szSource,NULL,
                                                   bConfirmDelete,&bDeleteAll)) {

                        case IDYES:
                            break;

                        case IDNO:
                            continue;

                        case IDCANCEL:
                            goto CancelWholeOperation;

                        default:
                            ret = (WORD)wAttr;
                            goto ShowMessageBox;
                    }

                    /* make sure we don't delete any open windows
                       apps or dlls (lets hope this isn't too slow) */

                    ret = SafeFileRemove(szSourceOEM);
                    break;

                default:
                    ret = DE_HOWDIDTHISHAPPEN;   // internal error
                    break;
            }

            /* Report any errors which have occurred */

            if (ret) {

                ShowMessageBox:

                CopyError(szSource, szDest, ret, wFunc, oper);

                /* Continue the operation where one file is a windows file
                   in use */

                if ((ret & ~ERRORONDEST) != DE_WINDOWSFILE) {

                    CancelWholeOperation:

                    /* Force a CopyAbort in case there are any files in the
                       copy queue */

                    bUserAbort = TRUE;
                    goto ExitLoop;
                }
            }
        }
    }

    ExitLoop:

    /* Copy any outstanding files in the copy queue */

    if (!bUserAbort) {

        if (EndCopy())
            CopyAbort();
    } else
        CopyAbort();

    // this happens in error cases where we broke out of the pcr loop
    // without hitting the end

    if (pcr) {
        GetNextCleanup(pcr);
        LocalFree((HANDLE)pcr);
    }

    if (pGetNextQueue)
        LocalFree((HANDLE)pGetNextQueue);

    /* goofy way to make sure we've gotten all the WM_FILESYSCHANGE messages */
    WFQueryAbort();

    EnableFSC();

    return ret;
}


/*--------------------------------------------------------------------------*/
/*                                          */
/*  DMMoveCopyHelper() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Used by Danger Mouse to do moves and copies. */

WORD
APIENTRY
DMMoveCopyHelper(
                register LPSTR pFrom,
                register LPSTR pTo,
                BOOL bCopy
                )
{
    WORD      iStatus;

    dbg(("DMMoveCopyHelper(%s,%s);\r\n",(LPSTR)pFrom,(LPSTR)pTo));

    /* Confirm mouse operations. */
    if (bConfirmMouse) {
        LoadString(hAppInstance, IDS_MOUSECONFIRM, szTitle, sizeof(szTitle));
        LoadString(hAppInstance,
                   bCopy ? IDS_COPYMOUSECONFIRM : IDS_MOVEMOUSECONFIRM,
                   szMessage, sizeof(szMessage));

        if (MessageBox(hwndFrame, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
            return DE_OPCANCELLED;
    }

    hdlgProgress = CreateDialog(hAppInstance, MAKEINTRESOURCE(DMSTATUSDLG), hwndFrame, ProgressDlgProc);
    if (!hdlgProgress) {
        return DE_INSMEM;
    }

    /* Set the destination directory in the dialog.
     * use IDD_TONAME 'cause IDD_TO gets disabled....
     */
    // SetDlgItemText(hdlgProgress, IDD_TONAME, pTo);

    /* The dialog title defaults to "Moving..." */
    if (bCopy) {
        LoadString(hAppInstance, IDS_COPYINGTITLE, szMessage, sizeof(szMessage));
        SetWindowText(hdlgProgress, szMessage);
    }

    /* Display and paint the status dialog. */
    EnableWindow(hwndFrame,FALSE);
    ShowWindow(hdlgProgress, SW_SHOW);
    UpdateWindow(hdlgProgress);

    /* Move/Copy things. */
    iStatus = WFMoveCopyDriver(pFrom, pTo, (WORD)(bCopy ? FUNC_COPY : FUNC_MOVE));

    /* Destroy the status dialog. */
    EnableWindow(hwndFrame,TRUE);
    DestroyWindow(hdlgProgress);

    return (iStatus);
}

WORD
APIENTRY
FileRemove(
          PSTR pSpec
          )
{
    if (DeleteFile(pSpec))
        return (WORD)0;
    else
        return (WORD)GetLastError();
}


WORD
APIENTRY
FileMove(
        PSTR pFrom,
        PSTR pTo
        )
{
    WORD result;

    TryAgain:

    if (MoveFile(pFrom, pTo))
        result = 0;
    else
        result = (WORD)GetLastError();

    // try to create the destination if it is not there

    if (result == DE_PATHNOTFOUND) {
        result = (WORD)CopyMoveRetry(pTo, (INT)result);
        if (!result)
            goto TryAgain;
        else
            return result;
    }
    return 0;
}


/*============================================================================
;
; FileCopy
;
; The following function replaces the old FileCopy function which performed
; single file copies.  This function queues copies.  The function StartCopy
; is called to initialize the copy queue if required.  If the queue is full,
; the function EndCopy is called to purge the copy queue before queueing
; up new copy commands.  Note that the function EndCopy must be called to
; purge the copy queue.
;
; Parameters:
;
; pszSource - Fully qualified source path
; pszDest   - Fully qualifies destination path
;
; returns:
;   0   success
;   dos error code for failure
;
============================================================================*/

WORD
APIENTRY
FileCopy(
        PSTR pszSource,
        PSTR pszDest
        )
{
    WORD ret;

    if (ret = StartCopy())
        return ret;       // failure

    // if the queue is full we must empty it first

    if (nCopyNumQueue >= nCopyMaxQueue) {

        // queue is full, now we empty it by really doing copies

        if (ret = EndCopy())
            return ret;    // failure

        if (ret = StartCopy())
            return ret;    // failure
    }

    // add this to the queue

    lstrcpy(pCopyQueue[nCopyNumQueue].szSource, pszSource);
    lstrcpy(pCopyQueue[nCopyNumQueue].szDest, pszDest);
    pCopyQueue[nCopyNumQueue].hSource = -1;
    pCopyQueue[nCopyNumQueue].hDest   = -1;
    pCopyQueue[nCopyNumQueue].ftLastWriteTime.dwLowDateTime = 0;
    pCopyQueue[nCopyNumQueue].ftLastWriteTime.dwHighDateTime = 0;

    nCopyNumQueue++;
    return 0;        // success
}

/*============================================================================
;
; StartCopy
;
; The following function is called automatically by WFCopy to initialize the
; copy queue.  The function is called each time by WFCopy, but will only
; initialize the first time.  The function allocates a buffer for reading and
; writing, and a buffer for storing the source and destination filenames,
; handles, and time stamps.  The function EndCopy must be called to flush the
; copy queue, and perform the actual disk transfer.
;
; Parameters: None
;
; return:
;   0   success
;   != 0    dos error code (DE_ value)
;
; Written by C. Stevens, August 1991
;
============================================================================*/

WORD
APIENTRY
StartCopy(VOID)
{
    WORD wSize;     /* Buffer size */
    register INT i; /* Counter */

    // have we already been called?

    if (lpCopyBuffer && pCopyQueue)
        return 0;     // success, buffers already allocated

    /* Allocate and lock buffer for reading and writing */

    wSize = COPYMAXBUFFERSIZE;
    while (!lpCopyBuffer) {
        lpCopyBuffer = GlobalAllocPtr(GHND, (DWORD)wSize);
        if (!lpCopyBuffer) {
            wSize /= 2;
            if (wSize < COPYMINBUFFERSIZE)
                return DE_INSMEM;   // memory failure
        }
    }
    wCopyBufferSize = wSize;

    /* Allocate and lock buffer for copy queue.  Note that magic +5 below is
       because we always have stdin, stdout, stderr, and AUX files open all
       the time, and we can't count them as available file handles */

    // someone opens files on our psp, leave them 2 handles
    // so we don't run on in the midst of copying

    nCopyMaxQueue = min(SetHandleCount(11 * 2) / 2 - 1, 10);

#ifdef DEBUG
    {
        char buf[80];
        wsprintf(buf, "SetHandleCount() -> %d\r\n", nCopyMaxQueue);
        OutputDebugString(buf);
    }
#endif

    wSize = (WORD)(nCopyMaxQueue * sizeof(COPYQUEUEENTRY));
    while (!pCopyQueue) {
        pCopyQueue = (PCOPYQUEUE)LocalAlloc(LPTR,wSize);
        if (!pCopyQueue) {
            wSize /= 2;
            if (wSize < (COPYMINFILES * sizeof(COPYQUEUEENTRY))) {
                GlobalFreePtr(lpCopyBuffer);
                lpCopyBuffer = NULL;
                return DE_INSMEM;   // memory failure
            }
        }
    }

    /* Initialize other Copy Queue variables and return success */

    nCopyMaxQueue = (int) wSize / sizeof (COPYQUEUEENTRY);
    nCopyNumQueue = 0;
    for (i = 0; i < nCopyMaxQueue; i++) {
        pCopyQueue[i].szSource[0] = 0;
        pCopyQueue[i].szDest[0]   = 0;
        pCopyQueue[i].hSource = -1;
        pCopyQueue[i].hDest   = -1;
    }
    return 0;        // success
}

// in:
//  pszFile     file to open/create
//  wAttrib     attributes to use on create
//
// returns:
//  flags register  (carry set on error)
//  *pfh        file handle or dos error code


WORD
OpenDestFile(
            PSTR pszFile,
            WORD wAttrib,
            INT *pfh
            )
{
    INT fh;
    WORD wStatus = 0;
    OFSTRUCT ofs;

    // use new extended open on dos > 4

    if (wDOSversion >= 0x0400) {
        if (wAttrib & ATTR_ATTRIBS)
            wAttrib &= ATTR_USED;
        else
            wAttrib = ATTR_ARCHIVE;

        {
            fh = OpenFile(pszFile, &ofs,
                          OF_READWRITE  | OF_SHARE_DENY_WRITE | OF_CREATE);
            if (fh == (INT)-1) {
                fh = GetLastError();
                wStatus |= CARRY_FLAG;
            } else {
                wStatus = 0;
                SetFileAttributes(pszFile, wAttrib);
            }

            // fh now contains a file handle or error code
        }

    } else {
        {
            fh = OpenFile(pszFile, &ofs,
                          OF_READWRITE  | OF_SHARE_DENY_WRITE | OF_CREATE);
            if (fh == (INT)-1) {
                fh = GetLastError();
                wStatus |= CARRY_FLAG;
            } else
                wStatus = 0;
        }
    }
    *pfh = fh;

    return wStatus;
}


/*============================================================================
;
; EndCopy
;
; The following function flushes the copy queue, attempting to copy all files
; in the queue.  The function ALWAYS frees global memory and flushes the
; queue and reports it's own errors.
;
; strategy:
;   we will do as many operations on one drive as we can, thus
;   avoiding disk spin up time (really bad on floppies).
;
; Parameters: None
;
; returns:
;   0   successful operation
;   != 0    dos error code (DE_OPCANCELLED) failure
;
; use like:
;
;    loop {
;   ret = WFCopy();
;   if (ret) {
;     ReportError(ret);
;     goto Error;
;   }
;    }
;
;    ret = EndCopy();
;    if (ret)
;      goto Error;
;
;    return success;
;
;Error:
;    CopyAbort();
;    ReportError(ret);
;
============================================================================*/

WORD
APIENTRY
EndCopy(VOID)
{
    INT i, j;           /* Counter */
    PSTR pTemp;         /* Pointer to source or dest filename */
    INT  fh;        /* File handle for DOS calls */
    WORD wStatus;       /* Status flags returned from DOS calls */
    DWORD wRead;         /* Number of bytes read from source file */
    DWORD wWrite;        /* Number of bytes written to destination file */
    FILETIME ftLastWriteTime; /* Source file date and time */
    DWORD wAttrib;       /* File attributes */

#ifdef DEBUG
    {
        char buf[80];
        wsprintf(buf, "EndCopy() nCopyNumQueue == %d\r\n", nCopyNumQueue);
        OutputDebugString(buf);
    }
#endif

    /* Open as many source files as possible.  Note we are assuming here
       that nCopyNumQueue < nCopyMaxQueue.  This should always be true
       because WFCopy calls EndCopy to purge the queue if it becomes full.
       We should never get an out of handles error opening source files or
       destination files.  If we do get an out of handles error opening
       source files, cause a fatal error and abort the copy. */

    // open all source files

    Notify(hdlgProgress, IDS_OPENINGMSG, szNULL, szNULL);

    for (i = 0; i < nCopyNumQueue; i++) {

        if (WFQueryAbort())
            return DE_OPCANCELLED;

        pTemp = pCopyQueue[i].szSource;
        {
            OFSTRUCT ofs;

            fh = OpenFile(pTemp, &ofs, OF_READ);
            if (fh == (INT)-1)
                fh = OpenFile(pTemp, &ofs, OF_SHARE_DENY_WRITE);
        }

        if (fh == (INT)-1) {

            CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, fh, FUNC_COPY, OPER_DOFILE);

            return DE_OPCANCELLED; // error already reported

        } else
            pCopyQueue[i].hSource = fh;

        /* Get the source file date, time, and attributes if necessary */

        fh = pCopyQueue[i].hSource;
        if (!IsSerialDevice(fh)) {
            {
                FILETIME ft;

                // Call DOS Get Date/Time of File.
                if (GetFileTime((HANDLE)LongToHandle(fh), NULL, NULL, (LPFILETIME)&ft))
                    pCopyQueue[i].ftLastWriteTime = ft;
            }

            pTemp = pCopyQueue[i].szSource;
            {
                // Call DOS Get File Attributes
                wAttrib = GetFileAttributes(pTemp);
                if (wAttrib != (DWORD)-1)
                    pCopyQueue[i].wAttrib |= (wAttrib | ATTR_ATTRIBS);
            }
        }
    }

    /* Now open as many destination files as possible.  If we get an out of
       handles error, cause a fatal abort because we already called
       Windows SetHandleCount to ensure we had enough.

       Note:  We are assuming the files do not exist when we try to open
              them, although for DOS 4.0 and above files WILL be replaced
              if they do happen to exist. */

    // open all destination files

    for (i = 0; i < nCopyNumQueue; i++) {

        if (WFQueryAbort())
            return DE_OPCANCELLED;

        TryOpen:

        wStatus = OpenDestFile(pCopyQueue[i].szDest, (WORD)pCopyQueue[i].wAttrib, (INT *)&fh);

        if (wStatus & CARRY_FLAG) {

            // error operning/creating destinaton file

            if (fh == DE_PATHNOTFOUND) {
                TryOpenDestAgain:
                // ask the user to stick in another disk

                fh = CopyMoveRetry(pCopyQueue[i].szDest, fh);
                if (!fh) {
                    goto TryOpen;
                } else {
                    // didn't happen, abort this copy

                    CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, (WORD)fh | ERRORONDEST, FUNC_COPY, OPER_DOFILE);
                    return DE_OPCANCELLED;   // error already reported
                }

            } else {
                // some other error condition

                CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, (WORD)fh | ERRORONDEST, FUNC_COPY, OPER_DOFILE);
                return DE_OPCANCELLED;  // error already reported
            }

        } else {
            pCopyQueue[i].hDest = fh;  // dest file open success
        }
    }

    /* Now copy between the open files */

    for (i = 0; i < nCopyNumQueue; i++) {

        Notify(hdlgProgress, IDS_COPYINGMSG, pCopyQueue[i].szSource, pCopyQueue[i].szDest);

        wRead = wCopyBufferSize;

        do {

            if (WFQueryAbort())
                return DE_OPCANCELLED;

            fh = pCopyQueue[i].hSource;
            {

                wRead = _lread(fh, lpCopyBuffer, wCopyBufferSize);
                if (wRead == (DWORD)-1) {
                    wStatus |= CARRY_FLAG;
                    wRead = GetLastError();
                } else
                    wStatus = 0;

                // wRead is either # bytes read or error code
            }
            if (wStatus & CARRY_FLAG) {

                // Error during file read

                CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, wRead, FUNC_COPY, OPER_DOFILE);

                return DE_OPCANCELLED;   // error already reported
            }

            fh = pCopyQueue[i].hDest;
            {

                // size can be zero to terminate file

                wWrite = _lwrite(fh, lpCopyBuffer, wRead);
                if (wWrite == (DWORD)-1) {
                    wStatus |= CARRY_FLAG;
                    wWrite = GetLastError();
                } else
                    wStatus = 0;

                // wWrite is either # bytes read or error code
            }
            if (wStatus & CARRY_FLAG) {

                CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, wWrite | ERRORONDEST, FUNC_COPY, OPER_DOFILE);

                return DE_OPCANCELLED;   // error already reported
            }

            // write did not complete and removable drive?

            if (wRead != wWrite) {

                if (IsRemovableDrive(DRIVEID(pCopyQueue[i].szDest)) &&
                    (DRIVEID(pCopyQueue[i].szDest) != DRIVEID(pCopyQueue[i].szSource))) {

                    // destination disk must be full. delete the destination
                    // files, give the user the option to insert a new disk.

                    for (j = i; j < nCopyNumQueue; j++) {

                        _lclose(pCopyQueue[j].hDest);
                        pCopyQueue[j].hDest = -1;

                        pTemp = pCopyQueue[j].szDest;
                        DeleteFile(pTemp);
                    }
                    fh = DE_NODISKSPACE;
                    goto TryOpenDestAgain;  // and try to create the destiations
                } else {

                    // not removable, error condition
                    CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, DE_NODISKSPACE | ERRORONDEST, FUNC_COPY, OPER_DOFILE);

                    return DE_OPCANCELLED;  // error already reported
                }

            }
            // we have moved all the data, so don't delete this on
            // clean up.

            if (!wRead)
                pCopyQueue[i].wAttrib |= ATTR_COPIED;

        } while (wRead);
    }

    // Close all destination files, set date time attribs

    Notify(hdlgProgress, IDS_CLOSINGMSG, szNULL, szNULL);

    for (i = 0; i < nCopyNumQueue; i++) {

        fh = pCopyQueue[i].hDest;
        if (!IsSerialDevice(fh)) {
            ftLastWriteTime = pCopyQueue[i].ftLastWriteTime;
            if (ftLastWriteTime.dwLowDateTime &&
                ftLastWriteTime.dwHighDateTime) {
                SetFileTime((HANDLE)LongToHandle(fh), NULL, NULL, (LPFILETIME)&ftLastWriteTime);
            }
        }

        _lclose(pCopyQueue[i].hDest);
        pCopyQueue[i].hDest = -1;

        /* Now set the file attributes if necessary */

        if (wDOSversion < 0x0400) {

            pTemp = pCopyQueue[i].szDest;
            wAttrib = pCopyQueue[i].wAttrib;

            // only set attribs if necessary (this is slow)

            if (wAttrib & ATTR_ATTRIBS) {
                wAttrib &= ATTR_USED;
                SetFileAttributes(pTemp, wAttrib);
            }
        }
    }

    // Close all source files (and delete them if necessary)


    if (pCopyQueue && (pCopyQueue[0].wAttrib & ATTR_DELSRC))
        Notify(hdlgProgress, IDS_REMOVINGMSG, szNULL, szNULL);

    for (i = 0; i < nCopyNumQueue; i++) {

        _lclose(pCopyQueue[i].hSource);
        pCopyQueue[i].hSource = -1;

        if (pCopyQueue[i].wAttrib & ATTR_DELSRC) {
            WFRemove(pCopyQueue[i].szSource);
        }
    }


    if (lpCopyBuffer) {
        GlobalFreePtr(lpCopyBuffer);
        lpCopyBuffer = NULL;
    }
    if (pCopyQueue) {
        LocalFree((HANDLE)pCopyQueue);
        pCopyQueue = NULL;
    }

    nCopyMaxQueue = 0;
    nCopyNumQueue = 0;

    return 0;        // success
}


/*============================================================================
;
; CopyError
;
; The following function reports an error during a file copy operation
;
; Parameters
;
; lpszSource - Source file name
; lpszDest   - Destination file name
; nError     - dos (or our exteneded) error code
;          0xFFFF for special case NET error
; wFunc      - Operation being performed during error.  Can be one of:
;              FUNC_DELETE - Delete files in pFrom
;              FUNC_RENAME - Rename files (same directory)
;              FUNC_MOVE   - Move files in pFrom to pTo (different disk)
;              FUNC_COPY   - Copy files in pFrom to pTo
; nOper      - Operation being performed.  Can be one of:
;              OPER_ERROR  - Error processing filenames
;              OPER_DOFILE - Go ahead and copy, rename, or delete file
;              OPER_MKDIR  - Make a directory specified in pTo
;              OPER_RMDIR  - Remove directory
;              0           - No more files left
;
; Return Value: None
;
; Written by C. Stevens, August 1991
;
============================================================================*/

VOID
CopyError(
         PSTR pszSource,
         PSTR pszDest,
         INT nError,
         WORD wFunc,
         INT nOper
         )
{
    CHAR szVerb[70];    /* Verb describing error */
    CHAR szReason[200]; /* Reason for error */
    BOOL bDest;

    bDest = nError & ERRORONDEST;    // was dest file cause of error
    nError &= ~ERRORONDEST;      // clear the dest bit

    if (nError == DE_OPCANCELLED)    // user abort
        return;

    if (!bCopyReport)        // silent, don't report errors
        return;

    LoadString(hAppInstance, IDS_COPYERROR + wFunc, szTitle, sizeof(szTitle));

    // get the verb string

    if (nOper == OPER_DOFILE || !nOper) {

        if (nError != 0xFFFF && bDest)
            // this is bogus, this could be IDS_CREATING as well...
            LoadString(hAppInstance, IDS_REPLACING, szVerb, sizeof(szVerb));
        else
            LoadString(hAppInstance, IDS_VERBS + wFunc, szVerb, sizeof(szVerb));

    } else {
        LoadString(hAppInstance, IDS_ACTIONS + (nOper >> 8), szVerb, sizeof(szVerb));
    }

    // get the reason string

    if (nError == 0xFFFF) {
        // special case LFN net error
        WNetErrorText(WN_NET_ERROR, szReason, sizeof(szReason));
    } else {
        // transform some error cases

        if (bDest) {
            if (nError != DE_ACCESSDENIED && GetFreeDiskSpace((WORD)DRIVEID(pszDest)) == 0L)
                nError = DE_NODISKSPACE;
        } else {
            if (nError == DE_ACCESSDENIED)
                nError = DE_ACCESSDENIEDSRC;    // soruce file access denied
        }

        LoadString(hAppInstance, IDS_REASONS + nError, szReason, sizeof(szReason));
    }

    // use the files names or "Selected files" if file list too long

    if (!nOper && (lstrlen(pszSource) > 64))
        LoadString(hAppInstance, IDS_SELECTEDFILES, pszSource, 32);

    wsprintf(szMessage, szVerb, (LPSTR)(bDest ? pszDest : pszSource), (LPSTR)szReason);

    MessageBox(hdlgProgress, szMessage, szTitle, MB_OK | MB_ICONSTOP);
}

/*============================================================================
;
; CopyAbort
;
; The following function aborts a queued copy operation.  The function closes
; all source and destination files, deleteing all destination files
; including and following the specified index.
;
; Parameters:
;
; nIndex - Index of first destination file to delete
;
; Return Value: None
;
; Written by C. Stevens, August 1991
;
============================================================================*/

VOID
APIENTRY
CopyAbort(VOID)
{
    INT i;
    PSTR pTemp;

    // close all source files

    for (i = 0; i < nCopyMaxQueue; i++) {
        if (pCopyQueue[i].hSource != -1)
            _lclose(pCopyQueue[i].hSource);
    }

    // close and delete (if necessary) destination files

    for (i = 0; i < nCopyMaxQueue; i++) {
        if (pCopyQueue[i].hDest != -1) {
            _lclose(pCopyQueue[i].hDest);

            if (!(pCopyQueue[i].wAttrib & ATTR_COPIED)) {
                pTemp = pCopyQueue[i].szDest;
                DeleteFile(pTemp);
            }
        }
    }

    if (lpCopyBuffer) {
        GlobalFreePtr(lpCopyBuffer);
        lpCopyBuffer = NULL;
    }
    if (pCopyQueue) {
        LocalFree((HANDLE)pCopyQueue);
        pCopyQueue = NULL;
    }

    nCopyMaxQueue = 0;   /* Clear other Copy Queue variables */
    nCopyNumQueue = 0;
}

/*============================================================================
;
; CopyMoveRetry
;
; The following function is used to retry failed move/copy operations
; due to out of disk situations or path not found errors
; on the destination.
;
; NOTE: the destination drive must be removable or this function
;   does not make a whole lot of sense
;
; Parameters:
;
; pszDest   - Fully qualified path to destination file
; nError    - Type of error which occured: DE_NODISKSPACE or DE_PATHNOTFOUND
;
; returns:
;   0   success (destination path has been created)
;   != 0    dos error code including DE_OPCANCELLED
;
============================================================================*/

INT
CopyMoveRetry(
             PSTR pszDest,
             INT nError
             )
{
    CHAR szReason[128]; /* Error message string */
    PSTR pTemp;         /* Pointer into filename */
    WORD wFlags;        /* Message box flags */
    INT  result;        /* Return from MessageBox call */

    do {     // until the destination path has been created

        GetWindowText(hdlgProgress, szTitle, sizeof(szTitle));

        if (nError == DE_PATHNOTFOUND) {

            LoadString(hAppInstance, IDS_PATHNOTTHERE, szReason, sizeof(szReason));

            /* Note the -1 below here is valid in both SBCS and DBCS because
               pszDest is fully qualified and the character preceding the
               file name must be a backslash */

            pTemp = FindFileName(pszDest) - 1;
            *pTemp = 0;
            wsprintf(szMessage, szReason, (LPSTR)pszDest);
            *pTemp = '\\';
            wFlags = MB_ICONEXCLAMATION | MB_YESNO;
        } else {
            wFlags = MB_ICONEXCLAMATION | MB_RETRYCANCEL;
            LoadString(hAppInstance, IDS_DESTFULL, szMessage, sizeof(szMessage));
        }

        result = MessageBox(hdlgProgress,szMessage,szTitle,wFlags);

        if (result == IDRETRY || result == IDYES) {

            // Allow the disk to be formatted
            if (!IsTheDiskReallyThere(hdlgProgress, pszDest, FUNC_COPY))
                return DE_OPCANCELLED;

            pTemp = FindFileName(pszDest) - 1;
            *pTemp = 0;
            result = WF_CreateDirectory(hdlgProgress, pszDest);
            *pTemp = '\\';

            // only as once if creating the destionation failed

            if (result == DE_OPCANCELLED)
                return DE_OPCANCELLED;
            if (result && (nError == DE_PATHNOTFOUND))
                return result | ERRORONDEST;
        } else
            return DE_OPCANCELLED;

    } while (result);

    return 0;        // success
}

BOOL
IsSerialDevice(
              INT hFile
              )
{
    UNREFERENCED_PARAMETER(hFile);
    return FALSE;  // BUG BUG. How to findout if its a serialdevice
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdirsrc.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDIRSRC.C -                                                            */
/*                                                                          */
/*      Routines Common to the Directory and Search Windows                 */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"

#define DO_DROPFILE 0x454C4946L
#define DO_PRINTFILE 0x544E5250L
#define DO_DROPONDESKTOP 0x504D42L

HWND hwndGlobalSink = NULL;

VOID SelectItem(HWND hwndLB, WPARAM wParam, BOOL bSel);
VOID ShowItemBitmaps(HWND hwndLB, BOOL bShow);
DWORD GetSearchAttribs(HWND hwndLB, WORD wIndex);

HCURSOR
APIENTRY
GetMoveCopyCursor()
{
    if (fShowSourceBitmaps)
        // copy
        return LoadCursor(hAppInstance, MAKEINTRESOURCE(iCurDrag | 1));
    else
        // move
        return LoadCursor(hAppInstance, MAKEINTRESOURCE(iCurDrag & 0xFFFE));
}


DWORD
GetSearchAttribs(
                HWND hwndLB,
                WORD wIndex
                )
{
    DWORD dwAttribs;
    HANDLE hDTA;
    LPDTASEARCH lpschdta;

    hDTA = (HANDLE)GetWindowLongPtr(GetParent(hwndLB), GWLP_HDTASEARCH);
    lpschdta = (LPDTASEARCH)LocalLock(hDTA);
    dwAttribs = lpschdta[(INT)SendMessage(hwndLB, LB_GETITEMDATA, wIndex, 0L)].sch_dwAttrs;
    LocalUnlock(hDTA);

    return dwAttribs;
}


// match a DOS wild card spec against a dos file name
// both strings are ANSI and Upper case

BOOL
MatchFile(
         LPSTR szFile,
         LPSTR szSpec
         )
{
    ENTER("MatchFile");
    PRINT(BF_PARMTRACE, "IN:szFile=%s", szFile);
    PRINT(BF_PARMTRACE, "IN:szSpec=%s", szSpec);

#define IS_DOTEND(ch)   ((ch) == '.' || (ch) == 0)

    if (!lstrcmp(szSpec, "*") ||            // "*" matches everything
        !lstrcmp(szSpec, szStarDotStar))    // so does "*.*"
        return TRUE;

    while (*szFile && *szSpec) {

        switch (*szSpec) {
            case '?':
                szFile++;
                szSpec++;
                break;

            case '*':

                while (!IS_DOTEND(*szSpec))     // got till a terminator
                    szSpec = AnsiNext(szSpec);

                if (*szSpec == '.')
                    szSpec++;

                while (!IS_DOTEND(*szFile))     // got till a terminator
                    szFile = AnsiNext(szFile);

                if (*szFile == '.')
                    szFile++;

                break;

            default:
                if (*szSpec == *szFile) {
                    if (IsDBCSLeadByte(*szSpec)) {
                        szFile++;
                        szSpec++;
                        if (*szFile != *szSpec)
                            return FALSE;
                    }
                    szFile++;
                    szSpec++;
                } else
                    return FALSE;
        }
    }
    return !*szFile && !*szSpec;
}


VOID
APIENTRY
DSSetSelection(
              HWND hwndLB,
              BOOL bSelect,
              LPSTR szSpec,
              BOOL bSearch
              )
{
    WORD            i;
    WORD            iMac;
    HANDLE          hMem;
    LPMYDTA         lpmydta;
    CHAR            szTemp[MAXPATHLEN];

    AnsiUpper(szSpec);

    iMac = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    if (bSearch)
        hMem = (HANDLE)GetWindowLongPtr(GetParent(hwndLB), GWLP_HDTASEARCH);
    else
        hMem = (HANDLE)GetWindowLongPtr(GetParent(hwndLB), GWLP_HDTA);

    LocalLock(hMem);

    for (i = 0; i < iMac; i++) {

        if (bSearch) {
            SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)szTemp);
            StripPath(szTemp);
        } else {

            SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&lpmydta);

            if (lpmydta->my_dwAttrs & ATTR_PARENT)
                continue;

            lstrcpy(szTemp, lpmydta->my_cFileName);
        }

        AnsiUpper(szTemp);

        if (MatchFile(szTemp, szSpec))
            SendMessage(hwndLB, LB_SETSEL, bSelect, MAKELONG(i, 0));
    }

    LocalUnlock(hMem);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowItemBitmaps() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
ShowItemBitmaps(
               HWND hwndLB,
               BOOL bShow
               )
{
    INT       iSel;
    RECT      rc;

    if (bShow == fShowSourceBitmaps)
        return;

    fShowSourceBitmaps = bShow;

    /* Invalidate the bitmap parts of all visible, selected items. */
    iSel = (WORD)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);

    while (SendMessage(hwndLB, LB_GETITEMRECT, iSel, (LPARAM)&rc) != LB_ERR) {
        /* Is this item selected? */
        if ((BOOL)SendMessage(hwndLB, LB_GETSEL, iSel, 0L)) {
            /* Invalidate the bitmap area. */
            rc.right = rc.left + dxFolder + dyBorderx2 + dyBorder;
            InvalidateRect(hwndLB, &rc, FALSE);
        }
        iSel++;
    }
    UpdateWindow(hwndLB);
}


INT
CharCountToTab(
              LPSTR pStr
              )
{
    LPSTR pTmp = pStr;

    while (*pStr && *pStr != '\t') {
        pStr = AnsiNext(pStr);
    }

    return (INT)(pStr-pTmp);
}


// this only deals with opaque text for now

VOID
RightTabbedTextOut(
                  HDC hdc,
                  INT x,
                  INT y,
                  LPSTR pLine,
                  WORD *pTabStops,
                  INT x_offset
                  )
{
    INT len, cch;
    INT x_ext;
    INT x_initial;
    RECT rc;

    len = lstrlen(pLine);

    // setup opaquing rect (we adjust the right border as we
    // output the string)

    rc.left = x;
    rc.top  = y;
    rc.bottom = y + dyText; // global max char height

    x_initial = x;

    cch = CharCountToTab(pLine);
    MGetTextExtent(hdc, pLine, cch, &x_ext, NULL);

    // first position is left alligned so bias initial x value
    x += x_ext;

    while (len) {

        len -= cch + 1;

        rc.right = x;
        ExtTextOut(hdc, x - x_ext, y, ETO_OPAQUE, &rc, pLine, cch, NULL);

        if (len <= 0)
            return;

        rc.left = rc.right;
        pLine += cch + 1;

        cch = CharCountToTab(pLine);
        MGetTextExtent(hdc, pLine, cch, &x_ext, NULL);

        x = *pTabStops + x_offset;
        pTabStops++;
    }
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DrawItem() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/


VOID
APIENTRY
DrawItem(
        LPDRAWITEMSTRUCT lpLBItem,
        LPSTR szLine,
        DWORD dwAttrib,
        BOOL bHasFocus,
        WORD *pTabs
        )
{
    INT x, y;
    CHAR ch;
    LPSTR psz;
    HDC hDC;
    BOOL bDrawSelected;
    HWND hwndLB;
    INT iBitmap;

    hwndLB = lpLBItem->hwndItem;

    bDrawSelected = (lpLBItem->itemState & ODS_SELECTED);

    hDC = lpLBItem->hDC;

    if (bHasFocus && bDrawSelected) {
        SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
    }

    if (lpLBItem->itemAction == ODA_FOCUS)
        goto FocusOnly;

    /* Draw the black/white background. */
    ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &lpLBItem->rcItem, NULL, 0, NULL);

    x = lpLBItem->rcItem.left + 1;
    y = lpLBItem->rcItem.top + (dyFileName/2);

    if (fShowSourceBitmaps || (hwndDragging != hwndLB) || !bDrawSelected) {

        if (dwAttrib & ATTR_DIR) {
            if (dwAttrib & ATTR_PARENT) {
                iBitmap = BM_IND_DIRUP;
                szLine = szNULL;  // no date/size stuff!
            } else
                iBitmap = BM_IND_CLOSE;
        } else {

            // isolate the name so we can see what type of file this is

            psz = szLine + CharCountToTab(szLine);
            ch = *psz;
            *psz = 0;

            if (dwAttrib & (ATTR_HIDDEN | ATTR_SYSTEM))
                iBitmap = BM_IND_RO;
            else if (IsProgramFile(szLine))
                iBitmap = BM_IND_APP;
            else if (IsDocument(szLine))
                iBitmap = BM_IND_DOC;
            else
                iBitmap = BM_IND_FIL;

            *psz = ch;                           // resore the old character
        }

        BitBlt(hDC, x + dyBorder, y-(dyFolder/2), dxFolder, dyFolder, hdcMem,
               iBitmap * dxFolder, (bHasFocus && bDrawSelected) ? dyFolder : 0, SRCCOPY);
    }

    x += dxFolder + dyBorderx2;

    if ((wTextAttribs & TA_LOWERCASE) && !(dwAttrib & ATTR_LFN))
        AnsiLower(szLine);

    RightTabbedTextOut(hDC, x, y-(dyText/2), szLine, (WORD *)pTabs, x);

    if (lpLBItem->itemState & ODS_FOCUS)
        FocusOnly:
        DrawFocusRect(hDC, &lpLBItem->rcItem);    // toggles focus (XOR)


    if (bDrawSelected) {
        if (bHasFocus) {
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        } else {
            HBRUSH hbr;
            RECT rc;

            if (hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT))) {
                rc = lpLBItem->rcItem;
                rc.right = rc.left + (INT)SendMessage(hwndLB, LB_GETHORIZONTALEXTENT, 0, 0L);

                if (lpLBItem->itemID > 0 &&
                    (BOOL)SendMessage(hwndLB, LB_GETSEL, lpLBItem->itemID - 1, 0L))
                    rc.top -= dyBorder;

                FrameRect(hDC, &rc, hbr);
                DeleteObject(hbr);
            }
        }
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SelectItem() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
SelectItem(
          HWND hwndLB,
          WPARAM wParam,
          BOOL bSel
          )
{
    /* Add the current item to the selection. */
    SendMessage(hwndLB, LB_SETSEL, bSel, (DWORD)wParam);

    /* Give the selected item the focus rect and anchor pt. */
    SendMessage(hwndLB, LB_SETCARETINDEX, wParam, 0L);
    SendMessage(hwndLB, LB_SETANCHORINDEX, wParam, 0L);
}


//
// void  APIENTRY DSDragLoop(register HWND hwndLB, WPARAM wParam, LPDROPSTRUCT lpds, BOOL bSearch)
//
// called by for the directory and search drag loops. this must handle
// detecting all kinds of different destinations.
//
// in:
//      hwndLB  source listbox (either the dir or the sort)
//      wParam  same as sent for WM_DRAGLOOP (TRUE if we are on a dropable sink)
//      lpds    drop struct sent with the message
//      bSearch TRUE if we are in the search listbox
//

VOID
APIENTRY
DSDragLoop(
          HWND hwndLB,
          WPARAM wParam,
          LPDROPSTRUCT lpds,
          BOOL bSearch
          )
{
    BOOL          bTemp;
    BOOL          bShowBitmap;
    LPMYDTA       lpmydta;
    HWND          hwndMDIChildSink, hwndDir;


    // bShowBitmap is used to turn the source bitmaps on or off to distinguish
    // between a move and a copy or to indicate that a drop can
    // occur (exec and app)

    // hack: keep around for drop files!
    hwndGlobalSink = lpds->hwndSink;

    bShowBitmap = TRUE;   // default to copy

    if (!wParam)
        goto DragLoopCont;        // can't drop here

    // Is the user holding down the CTRL key (which forces a copy)?
    if (GetKeyState(VK_CONTROL) < 0) {
        bShowBitmap = TRUE;
        goto DragLoopCont;
    }

    // Is the user holding down the ALT or SHIFT key (which forces a move)?
    if (GetKeyState(VK_MENU)<0 || GetKeyState(VK_SHIFT)<0) {
        bShowBitmap = FALSE;
        goto DragLoopCont;
    }

    hwndMDIChildSink = GetMDIChildFromDecendant(lpds->hwndSink);

    // Are we over the source listbox? (sink and source the same)

    if (lpds->hwndSink == hwndLB) {

        // Are we over a valid listbox entry?
        if (LOWORD(lpds->dwControlData) == 0xFFFF) {
            goto DragLoopCont;
        } else {
            /* Yup, are we over a directory entry? */
            if (bSearch) {

                bTemp = (GetSearchAttribs(hwndLB, (WORD)(lpds->dwControlData)) & ATTR_DIR) != 0L;

            } else {

                SendMessage(hwndLB, LB_GETTEXT, (WORD)(lpds->dwControlData), (LPARAM)&lpmydta);

                bTemp = lpmydta->my_dwAttrs & ATTR_DIR;

            }
            if (!bTemp)
                goto DragLoopCont;
        }
    }

    /* Now we need to see if we are over an Executable file.  If so, we
     * need to force the Bitmaps to draw.
     */

    /* Are we over a directory window? */

    if (hwndMDIChildSink)
        hwndDir = HasDirWindow(hwndMDIChildSink);
    else
        hwndDir = NULL;

    if (hwndDir && (hwndDir == GetParent(lpds->hwndSink))) {

        // Are we over an occupided part of the list box?

        if (LOWORD(lpds->dwControlData) != 0xFFFF) {

            // Are we over an Executable?

            SendMessage(lpds->hwndSink, LB_GETTEXT, (WORD)(lpds->dwControlData), (LPARAM)&lpmydta);

            bTemp = IsProgramFile(lpmydta->my_cFileName);

            if (bTemp)
                goto DragLoopCont;
        }
    }

    // Are we dropping into the same drive (check the source and dest drives)

    bShowBitmap = ((INT)SendMessage(GetParent(hwndLB), FS_GETDRIVE, 0, 0L) !=
                   GetDrive(lpds->hwndSink, lpds->ptDrop));

    DragLoopCont:

    ShowItemBitmaps(hwndLB, bShowBitmap);

    // hack, set the cursor to match the move/copy state
    if (wParam)
        SetCursor(GetMoveCopyCursor());
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DSRectItem() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
DSRectItem(
          HWND hwndLB,
          INT iItem,
          BOOL bFocusOn,
          BOOL bSearch
          )
{
    RECT      rc;
    RECT      rcT;
    HDC       hDC;
    BOOL      bSel;
    WORD      wColor;
    HBRUSH    hBrush;
    LPMYDTA   lpmydta;
    CHAR      szTemp[MAXPATHLEN];

    /* Are we over an unused part of the listbox? */
    if (iItem == 0xFFFF)
        return;

    /* Are we over ourselves? (i.e. a selected item in the source listbox) */
    bSel = (BOOL)SendMessage(hwndLB, LB_GETSEL, iItem, 0L);
    if (bSel && (hwndDragging == hwndLB))
        return;

    /* We only put rectangles around directories and program items. */
    if (bSearch) {
        SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM)szTemp);

        // this is bused, we must test this as attributes

        if (!(BOOL)(GetSearchAttribs(hwndLB, (WORD)iItem) & ATTR_DIR) && !IsProgramFile((LPSTR)szTemp))
            return;
    } else {
        SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM)&lpmydta);

        if (!(lpmydta->my_dwAttrs & ATTR_DIR) &&
            !IsProgramFile(lpmydta->my_cFileName)) {
            return;
        }
    }

    /* Turn the item's rectangle on or off. */

    SendMessage(hwndLB, LB_GETITEMRECT, iItem, (LPARAM)&rc);
    GetClientRect(hwndLB,&rcT);
    IntersectRect(&rc,&rc,&rcT);

    if (bFocusOn) {
        hDC = GetDC(hwndLB);
        if (bSel) {
            wColor = COLOR_WINDOW;
            InflateRect(&rc, -1, -1);
        } else
            wColor = COLOR_WINDOWFRAME;

        if (hBrush = CreateSolidBrush(GetSysColor(wColor))) {
            FrameRect(hDC, &rc, hBrush);
            DeleteObject(hBrush);
        }
        ReleaseDC(hwndLB, hDC);
    } else {
        InvalidateRect(hwndLB, &rc, FALSE);
        UpdateWindow(hwndLB);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DropFilesOnApplication() -                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* this function will determine whether the application we are currently
 * over is a valid drop point and drop the files
 */

WORD
DropFilesOnApplication(
                      LPSTR pszFiles
                      )
{
    POINT pt;
    HWND hwnd;
    RECT rc;
    HANDLE hDrop,hT;
    LPSTR lpList;
    WORD cbList = 2;
    OFSTRUCT ofT;
    WORD cbT;
    LPDROPFILESTRUCT lpdfs;
    CHAR szFile[MAXPATHLEN];

    if (!(hwnd = hwndGlobalSink))
        return 0;

    hwndGlobalSink = NULL;

    GetCursorPos(&pt);

    cbList = 2 + sizeof (DROPFILESTRUCT);
    hDrop = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE|GMEM_ZEROINIT,cbList);
    if (!hDrop)
        return 0;

    lpdfs = (LPDROPFILESTRUCT)GlobalLock(hDrop);

    GetClientRect(hwnd,&rc);
    ScreenToClient(hwnd,&pt);
    lpdfs->pt = pt;
    lpdfs->fNC = !PtInRect(&rc,pt);
    lpdfs->pFiles = sizeof(DROPFILESTRUCT);

    GlobalUnlock(hDrop);

    while (pszFiles = GetNextFile(pszFiles, szFile, sizeof(szFile))) {

        MOpenFile(szFile, &ofT, OF_PARSE);

        cbT = (WORD)(lstrlen(ofT.szPathName)+1);
        hT = GlobalReAlloc(hDrop,cbList+cbT,GMEM_MOVEABLE|GMEM_ZEROINIT);
        if (!hT)
            break;
        hDrop = hT;
        lpList = GlobalLock(hDrop);
        OemToAnsi(ofT.szPathName, lpList+cbList-2);
        GlobalUnlock(hDrop);
        cbList += cbT;
    }

    PostMessage(hwnd, WM_DROPFILES, (WPARAM)hDrop, 0L);

    return 1;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DSTrackPoint() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Return 0 for normal mouse tracking, 1 for no mouse single-click processing,
 * and 2 for no mouse single- or double-click tracking.
 */

INT
APIENTRY
DSTrackPoint(
            HWND hWnd,
            HWND hwndLB,
            WPARAM wParam,
            LPARAM lParam,
            BOOL bSearch
            )
{
    UINT       iSel;
    MSG       msg;
    RECT      rc;
    WORD      wAnchor;
    DWORD     dwTemp;
    LPSTR      pch;
    BOOL      bDir;
    BOOL      bSelected;
    BOOL      bSelectOneItem;
    BOOL      bUnselectIfNoDrag;
    CHAR      szFileName[MAXPATHLEN+1];
    INT iNoYieldCount;
    WORD wYieldFlags;
    POINT     pt;
    HANDLE hHackForHDC = NULL;    // hDC Express editor relies on this
    DRAGOBJECTDATA dodata;

    bSelectOneItem = FALSE;
    bUnselectIfNoDrag = FALSE;

    bSelected = (BOOL)SendMessage(hwndLB, LB_GETSEL, wParam, 0L);

    if (GetKeyState(VK_SHIFT) < 0) {
        /* What is the state of the Anchor point? */
        wAnchor = (WORD)SendMessage(hwndLB, LB_GETANCHORINDEX, 0, 0L);
        bSelected = (BOOL)SendMessage(hwndLB, LB_GETSEL, wAnchor, 0L);

        /* If Control is up, turn everything off. */
        if (!(GetKeyState(VK_CONTROL) < 0))
            SendMessage(hwndLB, LB_SETSEL, FALSE, -1L);

        /* Select everything between the Anchor point and the item. */
        SendMessage(hwndLB, LB_SELITEMRANGE, bSelected, MAKELONG(wParam, wAnchor));

        /* Give the selected item the focus rect. */
        SendMessage(hwndLB, LB_SETCARETINDEX, wParam, 0L);
    } else if (GetKeyState(VK_CONTROL) < 0) {
        if (bSelected)
            bUnselectIfNoDrag = TRUE;
        else
            SelectItem(hwndLB, wParam, TRUE);
    } else {
        if (bSelected)
            bSelectOneItem = TRUE;
        else {
            /* Deselect everything. */
            SendMessage(hwndLB, LB_SETSEL, FALSE, -1L);

            /* Select the current item. */
            SelectItem(hwndLB, wParam, TRUE);
        }
    }

    if (!bSearch)
        UpdateStatus(GetParent(hWnd));

    LONG2POINT(lParam, pt);
    ClientToScreen(hwndLB, (LPPOINT)&pt);
    ScreenToClient(hWnd, (LPPOINT)&pt);

    // See if the user moves a certain number of pixels in any direction

    SetRect(&rc, pt.x - dxClickRect, pt.y - dyClickRect,
            pt.x + dxClickRect, pt.y + dyClickRect);

    SetCapture(hWnd);
    wYieldFlags = PM_NOYIELD | PM_REMOVE;
    iNoYieldCount = 50;
    for (;;) {
#if 0
        {
            CHAR szBuf[80];

            wsprintf(szBuf, "Message %4.4X\r\n", msg.message);
            OutputDebugString(szBuf);
        }
#endif

        if (PeekMessage(&msg, NULL, 0, 0, wYieldFlags))
            DispatchMessage(&msg);

        if (iNoYieldCount <= 0)
            wYieldFlags = PM_REMOVE;
        else
            iNoYieldCount--;

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop

        if (GetCapture() != hWnd) {
            msg.message = WM_LBUTTONUP;   // don't proceed below
            break;
        }

        if (msg.message == WM_LBUTTONUP)
            break;

        LONG2POINT(msg.lParam, pt);
        if ((msg.message == WM_MOUSEMOVE) && !(PtInRect(&rc, pt)))
            break;
    }
    ReleaseCapture();

    /* Did the guy NOT drag anything? */
    if (msg.message == WM_LBUTTONUP) {
        if (bSelectOneItem) {
            /* Deselect everything. */
            SendMessage(hwndLB, LB_SETSEL, FALSE, -1L);

            /* Select the current item. */
            SelectItem(hwndLB, wParam, TRUE);
        }

        if (bUnselectIfNoDrag)
            SelectItem(hwndLB, wParam, FALSE);

        // notify the appropriate people

        SendMessage(hWnd, WM_COMMAND,
                    GET_WM_COMMAND_MPS(0, hwndLB, LBN_SELCHANGE));

        return 1;
    }

    /* Enter Danger Mouse's BatCave. */
    if ((WORD)SendMessage(hwndLB, LB_GETSELCOUNT, 0, 0L) == 1) {
        /* There is only one thing selected.
         * Figure out which cursor to use.
         */
        if (bSearch) {
            SendMessage(hwndLB, LB_GETTEXT, wParam, (LPARAM)szFileName);
            bDir = (BOOL)(GetSearchAttribs(hwndLB, (WORD)wParam) & ATTR_DIR);
        } else {
            LPMYDTA lpmydta;

            SendMessage(hwndLB, LB_GETTEXT, wParam, (LPARAM)&lpmydta);

            lstrcpy(szFileName, lpmydta->my_cFileName);
            bDir = lpmydta->my_dwAttrs & ATTR_DIR;

            // avoid dragging the parrent dir

            if (lpmydta->my_dwAttrs & ATTR_PARENT) {
                return 1;
            }
        }

        if (bDir) {
            iSel = DOF_DIRECTORY;
        } else if (IsProgramFile(szFileName)) {
            iSel = DOF_EXECUTABLE;
            goto HDC_HACK_FROM_HELL;
        } else if (IsDocument(szFileName)) {
            iSel = DOF_DOCUMENT;
            HDC_HACK_FROM_HELL:
            hHackForHDC = GlobalAlloc(GHND | GMEM_DDESHARE, sizeof(OFSTRUCT));
            if (hHackForHDC) {
                LPOFSTRUCT lpof;

                lpof = (LPOFSTRUCT)GlobalLock(hHackForHDC);
                QualifyPath(szFileName);
                lstrcpy(lpof->szPathName, szFileName);
                GlobalUnlock(hHackForHDC);
            }
        } else
            iSel = DOF_DOCUMENT;

        iCurDrag = SINGLECOPYCURSOR;
    } else {
        /* Multiple files are selected. */
        iSel = DOF_MULTIPLE;
        iCurDrag = MULTCOPYCURSOR;
    }


    /* Get the list of selected things. */
    pch = (LPSTR)SendMessage(hWnd, FS_GETSELECTION, FALSE, 0L);

    /* Wiggle things around. */
    hwndDragging = hwndLB;
    dodata.pch = pch;
    dodata.hMemGlobal = hHackForHDC;
    dwTemp = DragObject(GetDesktopWindow(),hWnd,(UINT)iSel,(DWORD)(ULONG_PTR)&dodata,GetMoveCopyCursor());

    if (hHackForHDC)
        GlobalFree(hHackForHDC);

    SetWindowDirectory();

    if (dwTemp == DO_PRINTFILE) {
        // print these 
        hdlgProgress = NULL;
        WFPrint(pch);
    } else if (dwTemp == DO_DROPFILE) {
        // try and drop them on an application
        DropFilesOnApplication(pch);
    }

    LocalFree((HANDLE)pch);

    if (IsWindow(hWnd))
        ShowItemBitmaps(hwndLB, TRUE);

    hwndDragging = NULL;

    if (!bSearch && IsWindow(hWnd))
        UpdateStatus(GetParent(hWnd));

    return 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdisk.h ===
#define FF_CAPMASK  0x00FF
#define FF_SAVED    0x0100
#define FF_MAKESYS  0x0200
#define FF_QUICK    0x0400
#define FF_HIGHCAP  0x0800
#define FF_ONLYONE  0x1000

#define MS_720      0
#define MS_144      4
#define MS_288      6

#define SS48        2   // indexs into bpbList[] and cCluster[]
#define DS48        3
#define DS96        4
#define DS720KB     5
#define DS144M      6
#define DS288M      7

#define FAT_READ    1
#define FAT_WRITE   2

#define BOOTSECSIZE 512

/* FormatTrackHead() Error Codes */
#define DATAERROR       0x1000
#define ADDMARKNOTFOUND     0x0200
#define SECTORNOTFOUND      0x0400

#define IOCTL_FORMAT        0x42
#define IOCTL_SETFLAG       0x47
#define IOCTL_MEDIASSENSE   0x68
#define IOCTL_GET_DPB       0x60
#define IOCTL_SET_DPB       0x40
#define IOCTL_READ      0x61
#define IOCTL_WRITE     0x41

/* Media descriptor values for different floppy drives */
// NOTE: these are not all unique!
#define  MEDIA_160  0xFE    /* 160KB */
#define  MEDIA_320  0xFF    /* 320KB */
#define  MEDIA_180  0xFC    /* 180KB */
#define  MEDIA_360  0xFD    /* 360KB */
#define  MEDIA_1200 0xF9    /* 1.2MB */
#define  MEDIA_720  0xF9    /* 720KB */
#define  MEDIA_1440 0xF0    /* 1.44M */
#define  MEDIA_2880 0xF0    /* 2.88M */

#define  DOS_320    0x314   /* DOS version # 3.20 */

#define DRIVEID(path) ((path[0] - 'A')&31)


/* IOCTL_Functions() error codes */
#define NOERROR         0
#define SECNOTFOUND     0x1B
#define CRCERROR        0x17
#define GENERALERROR        0x1F

/*--------------------------------------------------------------------------*/
/*  BIOS Parameter Block Structure -                        */
/*--------------------------------------------------------------------------*/

typedef struct tagBPB
  {
    WORD    cbSec;      /* Bytes per sector         */
    BYTE    secPerClus;     /* Sectors per cluster      */
    WORD    cSecRes;        /* Reserved sectors         */
    BYTE    cFAT;       /* FATS             */
    WORD    cDir;       /* Root Directory Entries       */
    WORD    cSec;       /* Total number of sectors in image */
    BYTE    bMedia;     /* Media descriptor         */
    WORD    secPerFAT;      /* Sectors per FAT          */
    WORD    secPerTrack;    /* Sectors per track        */
    WORD    cHead;      /* Heads                */
    WORD    cSecHidden;     /* Hidden sectors           */
  } BPB;
typedef BPB         *PBPB;
typedef BPB FAR         *LPBPB;


/*--------------------------------------------------------------------------*/
/*  Drive Parameter Block Structure -                       */
/*--------------------------------------------------------------------------*/

typedef struct tagDPB
  {
    BYTE    drive;
    BYTE    unit;
    WORD    sector_size;
    BYTE    cluster_mask;
    BYTE    cluster_shift;
    WORD    first_FAT;
    BYTE    FAT_count;
    WORD    root_entries;
    WORD    first_sector;
    WORD    max_cluster;
    BYTE    FAT_size;
    WORD    dir_sector;
    LONG    reserved1;
    BYTE    media;
    BYTE    first_access;
    BYTE    reserved2[4];
    WORD    next_free;
    WORD    free_cnt;
    BYTE    DOS4_Extra; /*  FAT_size field is a WORD in DOS 4.X.
             * To compensate for it, we have one extra byte
             */
  } DPB;
typedef DPB         *PDPB;
typedef DPB FAR         *LPDPB;

#define MAX_SEC_PER_TRACK   40

/*--------------------------------------------------------------------------*/
/*  Device Parameter Block Structure -                      */
/*--------------------------------------------------------------------------*/

typedef struct tagDevPB
  {
    CHAR    SplFunctions;
    CHAR    devType;
    CHAR    reserved1[2];
    INT     NumCyls;
    CHAR    bMediaType;  /* 0=>1.2MB and 1=>360KB */
    BPB     BPB;
    CHAR    reserved3[MAX_SEC_PER_TRACK * 4 + 2];
  } DevPB, NEAR *PDevPB, FAR *LPDevPB;

#define TRACKLAYOUT_OFFSET  (7+31)  /* Offset of tracklayout
                         * in a Device Parameter Block */


/*--------------------------------------------------------------------------*/
/*  Disk Base Table Structure -                         */
/*--------------------------------------------------------------------------*/

typedef struct tagDBT
  {
    CHAR    SRHU;
    CHAR    HLDMA;
    CHAR    wait;
    CHAR    bytespersec;
    CHAR    lastsector;
    CHAR    gaplengthrw;
    CHAR    datalength;
    CHAR    gaplengthf;
    CHAR    datavalue;
    CHAR    HeadSettle;
    CHAR    MotorStart;
  } DBT;
typedef DBT         *PDBT;
typedef DBT FAR         *LPDBT;


/*--------------------------------------------------------------------------*/
/*  Directory Entry Structure -                         */
/*--------------------------------------------------------------------------*/

typedef struct tagDIRTYPE
  {
    CHAR     name[11];
    BYTE     attr;
    CHAR     pad[10];
    WORD     time;
    WORD     date;
    WORD     first;
    LONG     size;
  } DIRTYPE;
typedef DIRTYPE FAR *LPDIRTYPE;


/*--------------------------------------------------------------------------*/
/*  MS-DOS Boot Sector Structure -                      */
/*--------------------------------------------------------------------------*/

typedef struct tagBOOTSEC
  {
    BYTE    jump[3];        /* 3 byte jump */
    CHAR    label[8];       /* OEM name and version */
    BPB     BPB;        /* BPB */
    BYTE    bootdrive;      /* INT 13h indicator for boot device */
    BYTE    dontcare[BOOTSECSIZE-12-3-sizeof(BPB)];
    BYTE    phydrv;
    WORD    signature;
  } BOOTSEC;


/*--------------------------------------------------------------------------*/
/*  Disk Information Structure -                        */
/*--------------------------------------------------------------------------*/

typedef struct tagDISKINFO
  {
    WORD    wDrive;
    WORD    wCylinderSize;
    WORD    wLastCylinder;
    WORD    wHeads;
    WORD    wSectorsPerTrack;
    WORD    wSectorSize;
  } DISKINFO;
typedef DISKINFO     *PDISKINFO;
typedef DISKINFO FAR *LPDISKINFO;


/*--------------------------------------------------------------------------*/
/*  DOS Disk Transfer Area Structure -                      */
/*--------------------------------------------------------------------------*/

typedef struct tagDOSDTA
  {
    BYTE        Reserved[21];           /* 21 */
    BYTE        Attrib;             /* 22 */
    WORD        Time;               /* 24 */
    WORD        Date;               /* 26 */
    DWORD       Length;             /* 30 */
    CHAR        szName[MAXDOSFILENAMELEN];      /* 43 */
    CHAR        dummy[1];               /* 44 */
// we do WORD move of 22 words so pad this out by 1 byte
  } DOSDTA;
typedef DOSDTA       *PDOSDTA;
typedef DOSDTA   FAR *LPDOSDTA;


// this is the structure used to store file information in the
// directory window.  these are variable length blocks.  the
// first entry is a dummy that holds the number of entries in
// the whole block in the Length field.  use the wSize field
// to give you a pointer to the next block

typedef struct tagMYDTA
  {
    WORD        wSize;          // size of this structure (cFileName is variable)
    SHORT       iBitmap;
    INT         nIndex;

    DWORD       my_dwAttrs;     // must match WIN32_FIND_DATA from here down!
    FILETIME    my_ftCreationTime;
    FILETIME    my_ftLastAccessTime;
    FILETIME    my_ftLastWriteTime;
    DWORD       my_nFileSizeHigh;
    DWORD       my_nFileSizeLow;
    CHAR        my_cFileName[];
  } MYDTA;
typedef MYDTA     *PMYDTA;
typedef MYDTA FAR *LPMYDTA;

#define IMPORTANT_DTA_SIZE \
    (sizeof(MYDTA) - \
    sizeof(INT) - \
    sizeof(WORD) - \
    sizeof(SHORT))

#define GETDTAPTR(lpStart, offset)  ((LPMYDTA)((LPSTR)lpStart + offset))

// stuff used by the search window

typedef struct tagDTASEARCH {
    DWORD       sch_dwAttrs;    // must match WIN32_FIND_DATA
    FILETIME    sch_ftCreationTime;
    FILETIME    sch_ftLastAccessTime;
    FILETIME    sch_ftLastWriteTime;
    DWORD       sch_nFileSizeHigh;
    DWORD       sch_nFileSizeLow;
} DTASEARCH, FAR *LPDTASEARCH;


/*--------------------------------------------------------------------------*/
/*  DOS Extended File Control Block Structure -                 */
/*--------------------------------------------------------------------------*/

typedef struct tagEFCB
  {
    BYTE        Flag;
    BYTE        Reserve1[5];
    BYTE        Attrib;
    BYTE        Drive;
    BYTE        Filename[11];
    BYTE        Reserve2[5];
    BYTE        NewName[11];
    BYTE        Reserve3[9];
  } EFCB;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdir.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDIR.C -                                                               */
/*                                                                          */
/*      Windows File System Directory Window Proc Routines                  */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "wfcopy.h"

#define MAXDIGITSINSIZE 8

#define DATEMASK        0x001F
#define MONTHMASK       0x01E0
#define MINUTEMASK      0x07E0
#define SECONDSMASK     0x001F

#define DATESEPERATOR   '-'
#define TIMESEPERATOR   ':'

CHAR    szAttr[]        = "RHSA";
INT     iLastSel = -1;

INT_PTR APIENTRY DirWndProc(register HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

LPSTR DirGetSelection(HWND hwndDir, HWND hwndLB, INT iSelType, BOOL *pfDir);
VOID DirGetAnchorFocus(register HWND hwndLB, HANDLE hDTA, LPSTR szAnchor, LPSTR szCaret, LPSTR szTopIndex);
VOID FillDirList(HWND hWnd, HANDLE hDirEntries);
VOID DrawItemFast(HWND hWnd, LPDRAWITEMSTRUCT lpLBItem, LPMYDTA lpmydta, BOOL bHasFocus);
INT GetPict(CHAR ch, LPSTR szStr);
INT DirFindIndex(HWND hwndLB, HANDLE hDTA, LPSTR szFile);
INT CompareDTA(register LPMYDTA item1, LPMYDTA item2, WORD wSort);
VOID CreateLBLine(register WORD wLineFormat, LPMYDTA lpmydta, LPSTR szBuffer);
HANDLE CreateDTABlock(HWND hWnd, LPSTR pPath, DWORD dwAttribs, BOOL bAllowAbort, BOOL bDontSteal);
BOOL SetSelection(HWND hwndLB, HANDLE hDTA, LPSTR pSel);
INT CreateDate(WORD *wValArray, LPSTR szOutStr);
INT CreateTime(WORD * wValArray, LPSTR szOutStr);
VOID GetDirStatus(HWND hWnd, LPSTR szMsg1, LPSTR szMsg2);
INT GetMaxExtent(HWND hwndLB, HANDLE hDTA);
BOOL CheckEarlyAbort(VOID);
BOOL SetDirFocus(HWND hwndDir);

VOID  APIENTRY CheckEscapes(LPSTR);
VOID SortDirList(HWND, LPMYDTA, WORD ,LPMYDTA *);




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DrawItemFast() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
DrawItemFast(
            HWND hWnd,
            LPDRAWITEMSTRUCT lpLBItem,
            LPMYDTA lpmydta,
            BOOL bHasFocus
            )
{
    INT x, y, i;
    HDC hDC;
    BOOL bDrawSelected;
    HWND hwndLB;
    RECT rc;
    DWORD rgbText, rgbBackground;
    CHAR szBuf[MAXFILENAMELEN+2];

    hWnd;

    ENTER("DrawItemFast");

    hDC = lpLBItem->hDC;
    hwndLB = lpLBItem->hwndItem;

    bDrawSelected = (lpLBItem->itemState & ODS_SELECTED);

    if (bHasFocus && bDrawSelected) {
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        rgbBackground = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
    }

    if (lpLBItem->itemAction == ODA_FOCUS)
        goto FocusOnly;

    /* Draw the black/white background. */

    x = lpLBItem->rcItem.left + 1;
    y = lpLBItem->rcItem.top + (dyFileName/2);

    lstrcpy(szBuf, lpmydta->my_cFileName);
    if ((wTextAttribs & TA_LOWERCASE) && !(lpmydta->my_dwAttrs & ATTR_LFN))
        AnsiLower(szBuf);

    ExtTextOut(hDC, x + dxFolder + dyBorderx2 + dyBorder, y-(dyText/2),
               ETO_OPAQUE, &lpLBItem->rcItem, szBuf, lstrlen(szBuf), NULL);

    if (fShowSourceBitmaps || (hwndDragging != hwndLB) || !bDrawSelected) {

        LONG    ySrc;

        i = lpmydta->iBitmap;

        if (i & 0x40) {
            // It's an object type bitmap
            ySrc = (dyFolder * 2) + dyDriveBitmap;
            i = i & (~0x40);
            while (i >= 16) {
                i -= 16;
                ySrc += (dyFolder * 2);
            }
        } else {
            ySrc = 0;
        }

        ySrc += (bHasFocus && bDrawSelected) ? dyFolder : 0;

        BitBlt(hDC, x + dyBorderx2, y-(dyFolder/2), dxFolder, dyFolder, hdcMem,
               i * dxFolder, ySrc, SRCCOPY);
    }

    if (lpLBItem->itemState & ODS_FOCUS)
        FocusOnly:
        DrawFocusRect(hDC, &lpLBItem->rcItem);    // toggles focus (XOR)

    /* Restore the normal drawing colors. */
    if (bDrawSelected) {
        if (bHasFocus) {
            SetTextColor(hDC, rgbText);
            SetBkColor(hDC, rgbBackground);
        } else {
            HBRUSH hbr;
            if (hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT))) {
                rc = lpLBItem->rcItem;
                rc.left += dyBorder;
                rc.right -= dyBorder;

                if (lpLBItem->itemID > 0 &&
                    (BOOL)SendMessage(hwndLB, LB_GETSEL, lpLBItem->itemID - 1, 0L))
                    rc.top -= dyBorder;

                FrameRect(hDC, &rc, hbr);
                DeleteObject(hbr);
            }
        }
    }
    LEAVE("DrawItemFast");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FillDirList() -                                                         */
/*                                                                          */
/* HANDLE       hDirEntries;                     Array of directory entries */
/*--------------------------------------------------------------------------*/

VOID
FillDirList(
           HWND hWnd,
           HANDLE hDTA
           )
{
    register WORD count;
    LPMYDTA       lpmydta;
    LPMYDTA  *alpmydtaSorted;
    WORD          i;

    lpmydta = (LPMYDTA)LocalLock(hDTA);
    count = (WORD)lpmydta->my_nFileSizeLow;

    if (count == 0) {
        SendMessage(hWnd, LB_ADDSTRING, 0, 0L); // tolken for no items
    } else {

        alpmydtaSorted = (LPMYDTA *)LocalAlloc(LMEM_FIXED,
                                                   sizeof(LPMYDTA) * count);
        if (alpmydtaSorted != NULL) {
            SortDirList(hWnd, lpmydta, count, alpmydtaSorted);

            for (i = 0; i < count; i++) {
                alpmydtaSorted[i]->nIndex = i;
                SendMessage(hWnd, LB_INSERTSTRING,(WPARAM)-1, (LPARAM)alpmydtaSorted[i]);
            }
            LocalFree((HANDLE)alpmydtaSorted);
        }
    }

    LocalUnlock(hDTA);
}



BOOL
CheckEarlyAbort()
{
    MSG msg;

    if (PeekMessage(&msg, NULL, WM_KEYDOWN, WM_KEYDOWN, PM_NOREMOVE | PM_NOYIELD)) {

        if (msg.wParam == VK_UP ||
            msg.wParam == VK_DOWN) {
            return TRUE;
        }
    }
    return FALSE;
}



HANDLE
CopyDTABlock(
            HANDLE hDTASrc
            )
{
    LPMYDTA lpmydtaSrc, lpmydtaDst;
    HANDLE hDTADst;
    SIZE_T dwSize;

    lpmydtaSrc = (LPMYDTA)LocalLock(hDTASrc);

    dwSize = LocalSize(hDTASrc);

    if (hDTADst = LocalAlloc(LPTR, dwSize)) {

        lpmydtaDst = (LPMYDTA)LocalLock(hDTADst);

        memcpy(lpmydtaDst, lpmydtaSrc, (size_t)dwSize);

        LocalUnlock(hDTASrc);
        LocalUnlock(hDTADst);

        return hDTADst;

    } else {
        LocalUnlock(hDTASrc);
        return NULL;
    }
}


HANDLE
StealDTABlock(
             HWND hWnd,
             LPSTR pPath,
             DWORD dwAttribs
             )
{
    HWND hwnd;
    HWND hwndDir;
    HANDLE hDTA;
    CHAR szPath[MAXPATHLEN];

    ENTER("StealDTABlock");

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd;
        hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

        if ((hwndDir = HasDirWindow(hwnd)) && (hwndDir != hWnd)) {

            GetMDIWindowText(hwnd, szPath, sizeof(szPath));

            if ((dwAttribs == (DWORD)GetWindowLong(hwnd, GWL_ATTRIBS)) &&
                !lstrcmpi(pPath, szPath) &&
                (hDTA = (HANDLE)GetWindowLongPtr(hwndDir, GWLP_HDTA))) {
                LEAVE("StealDTABlock");
                return CopyDTABlock(hDTA);
            }
        }
    }

    LEAVE("StealDTABlock");

    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateDTABlock() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Builds a global memory block full of DTAs for the path 'pPath'.          */

/* Returns:
 *      An unlocked global memory handle to DTA block with first DTA
 *      my_nFileSizeLow field indicating the number of DTA blocks that follow
 *
 * This builds a global memory block that has DTA entries for all
 * of the files with dwAttributes in pPath.  The first DTA entry's
 * my_nFileSizeLow field indicates the number of actual DTA areas found
 */

HANDLE
CreateDTABlock(
              HWND hWnd,
              LPSTR pPath,
              DWORD dwAttribs,
              BOOL bAllowAbort,
              BOOL bDontSteal
              )
{
    register LPSTR pName;
    WORD wPathLen;
    BOOL bDoc, bProgram;
    DWORD dwCurrentSize, dwBlockSize;
    WORD wSize, wLastSize;
    LFNDTA lfndta;
    HANDLE hMem;
    LPMYDTA lpmydta, lpStart;
    CHAR szPathOEM[MAXPATHLEN];
    DWORD iBitmap;
    WORD wDrive;

    ENTER("CreateDTABlock");
    PRINT(BF_PARMTRACE, "IN: pPath=%s", pPath);
    PRINT(BF_PARMTRACE, "IN: dwAttribs=0x%lx", UlongToPtr(dwAttribs));
    PRINT(BF_PARMTRACE, "IN: bDontSteal=%d", IntToPtr(bDontSteal));

#define BLOCK_SIZE_GRANULARITY  512     // must be larger than MYDTA

    // get the drive index assuming path is
    // fully qualified...
    wDrive = (WORD)((*pPath - 'A') & 31);

    if (bAllowAbort && CheckEarlyAbort()) {
        PRINT(BF_PARMTRACE, "OUT: hDTA=-1", 0);
        LEAVE("CreateDTABlock");
        return (HANDLE)-1;
    }

    if (!bDontSteal && (hMem = StealDTABlock(hWnd, pPath, dwAttribs))) {
        PRINT(BF_PARMTRACE, "OUT: hDTA=0x%lx", hMem);
        LEAVE("CreateDTABlock");
        return hMem;
    }

    dwBlockSize = BLOCK_SIZE_GRANULARITY;
    hMem = LocalAlloc(LPTR, (DWORD)dwBlockSize);
    if (!hMem) {
        PRINT(BF_PARMTRACE, "OUT: hDTA=NULL", 0);
        LEAVE("CreateDTABlock");
        return NULL;
    }

    lpmydta = lpStart = (LPMYDTA)LocalLock(hMem);
    lpStart->my_nFileSizeLow = 0;
    wLastSize = sizeof(MYDTA) * sizeof(CHAR);
    wLastSize = (WORD)DwordAlign(wLastSize);
    lpStart->wSize = wLastSize;
    dwCurrentSize = (DWORD)wLastSize;

    lstrcpy(szPathOEM, pPath);

    FixAnsiPathForDos(szPathOEM);

    wPathLen = (WORD)(lstrlen(szPathOEM)-3);        /* Ignore '*.*' */

    if (!WFFindFirst(&lfndta, szPathOEM, (dwAttribs | ATTR_DIR) & ATTR_ALL)) {

        // Try again if the disk is available

        if (!IsTheDiskReallyThere(hWnd, pPath, FUNC_EXPAND) ||
            !WFFindFirst(&lfndta, szPathOEM, (dwAttribs | ATTR_DIR) & ATTR_ALL))
            goto CDBDone;
    }

    while (TRUE) {

        pName = lfndta.fd.cFileName;
        OemToAnsi(pName, pName);

        // be safe, zero unused DOS dta bits

        lfndta.fd.dwFileAttributes &= ATTR_USED;

        // filter unwanted stuff here based on current view settings

        if (!(lfndta.fd.dwFileAttributes & ATTR_DIR)) {

            bProgram = IsProgramFile(pName);
            bDoc     = IsDocument(pName);
        }

        // figure out the bitmap type here

        if (lfndta.fd.dwFileAttributes & ATTR_DIR) {

            // ignore the "." directory

            if (pName[0] == '.' && pName[1] != '.')
                goto CDBCont;

            // parent ".." dir

            if (pName[0] == '.') {

                pName = szNULL;

                iBitmap = BM_IND_DIRUP;
                lfndta.fd.dwFileAttributes |= ATTR_PARENT;      // mark this!

            } else {

                // We always include DIRs so that the .. is
                // included.  Now we filter other dirs off.

                if (!(dwAttribs & ATTR_DIR))
                    goto CDBCont;

                iBitmap = BM_IND_CLOSE;
            }

        } else if (lfndta.fd.dwFileAttributes & ATTR_TYPES) {
            iBitmap = ((lfndta.fd.dwFileAttributes & ATTR_TYPES) >> 16) | 0x40;
        } else {
            iBitmap = BM_IND_DOC;
        }

        //
        // calc the size of this portion
        //
        // pName is assumed to be ANSI re: OemToAnsi() call,
        // so lstrlen() should be size in bytes.  We just need to add one
        // for the terminating NULL


        wSize = (WORD)(sizeof(MYDTA) + lstrlen(pName) + sizeof('\0'));
        wSize = (WORD)DwordAlign(wSize);

        if ((wSize + dwCurrentSize) > dwBlockSize) {
            DWORD dwDelta;

            // grow the block

            dwBlockSize += BLOCK_SIZE_GRANULARITY;
            LocalUnlock(hMem);
            dwDelta = (DWORD)((LPBYTE)lpmydta - (LPBYTE)lpStart);

            if (!(hMem = LocalReAlloc(hMem, dwBlockSize, LMEM_MOVEABLE)))
                goto CDBMemoryErr;

            lpStart = (LPMYDTA)LocalLock(hMem);
            lpmydta = (LPMYDTA)((LPBYTE)lpStart + dwDelta);
        }

        lpStart->my_nFileSizeLow++;
        dwCurrentSize += wSize;

        // now it is safe to advance the pointer

        lpmydta = GETDTAPTR(lpmydta, wLastSize);
        wLastSize = lpmydta->wSize = wSize;
        lpmydta->my_dwAttrs = lfndta.fd.dwFileAttributes;
        lpmydta->my_ftLastWriteTime = lfndta.fd.ftLastWriteTime;
        lpmydta->my_nFileSizeLow = lfndta.fd.nFileSizeLow;
        lpmydta->my_nFileSizeHigh = lfndta.fd.nFileSizeHigh;
        lpmydta->iBitmap = (SHORT)iBitmap;

        if (IsLFN(pName)) {
            lpmydta->my_dwAttrs |= ATTR_LFN;
        }
        lstrcpy(lpmydta->my_cFileName, pName);

        CDBCont:
        if (bAllowAbort && CheckEarlyAbort()) {
            LocalUnlock(hMem);
            LocalFree(hMem);
            WFFindClose(&lfndta);
            PRINT(BF_PARMTRACE, "OUT: hDTA=-1", 0);
            LEAVE("CreateDTABlock");
            return (HANDLE)-1;
        }

        if (!WFFindNext(&lfndta)) {
            break;
        }
    }

    CDBDone:
    LocalUnlock(hMem);
    WFFindClose(&lfndta);
    PRINT(BF_PARMTRACE, "OUT: hDTA=0x%lx", hMem);
    LEAVE("CreateDTABlock");
    return hMem;

    CDBMemoryErr:
    WFFindClose(&lfndta);
    MyMessageBox(hwndFrame, IDS_OOMTITLE, IDS_OOMREADINGDIRMSG, MB_OK | MB_ICONEXCLAMATION);
    PRINT(BF_PARMTRACE, "OUT: hDTA=0x%lx", hMem);
    LEAVE("CreateDTABlock");
    return hMem;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DirGetSelection() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Takes a Listbox and returns a string containing the names of the selected
 * files seperated by spaces.
 *
 * bSingle == 1 return only the first file
 * bSingle == 2 test for LFN files in the selection, doesn't return string
 * bSingle == 3 return fully qualified names
 *
 * returns:
 *      if (bSingle == 1)
 *              TRUE/FALSE if LFN is in the selection
 *      else
 *              pointer to the list of names (ANSI strings)
 *              (must be freed by caller!)
 *              *pfDir -> bool indicating directories are
 *              contained in the selection (or that LFN names are present)
 *
 * NOTE: The caller must free the returned pointer!
 */

LPSTR
DirGetSelection(
               HWND hwndDir,
               HWND hwndLB,
               INT  iSelType,
               BOOL *pfDir
               )
{
    LPSTR p, pT;
    WORD i;
    WORD          cch;
    WORD          iMac;
    LPMYDTA       lpmydta;
    CHAR          szFile[MAXPATHLEN];
    CHAR          szPath[MAXPATHLEN];
    BOOL          bDir, bPropertyDialog;
    LPINT         lpSelItems;

    BOOL          bLFNTest;

    if (bLFNTest = (iSelType == 2)) {
        // determine if the directory it self is long...
        iSelType = FALSE;
        SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
        StripBackslash(szPath);
        if (IsLFN(szPath))
            if (pfDir) {
                *pfDir = TRUE;
            }
        return NULL;
    }

    if (bPropertyDialog = (iSelType == 3)) {
        iSelType = FALSE;
    }

    bDir = FALSE;

    if (!bLFNTest) {
        cch = 1;
        p = (LPSTR)LocalAlloc(LPTR, cch);
        if (!p)
            return NULL;
        *p = '\0';
    }
    #ifdef DEBUG
    else
        p = (LPSTR)0xFFFF;       // force a GP fault with bogus p use below
    #endif


    iLastSel = -1;

    iMac = (WORD)SendMessage(hwndLB, LB_GETSELCOUNT, 0, 0L);
    lpSelItems = LocalAlloc(LMEM_FIXED, sizeof(INT) * iMac);
    if (lpSelItems == NULL)
        return NULL;
    iMac = (WORD)SendMessage(hwndLB, LB_GETSELITEMS, (WPARAM)iMac, (LPARAM)lpSelItems);
    for (i=0; i < iMac; i++) {


        if (iLastSel == -1)   // remember the first selection
            iLastSel = lpSelItems[i];

        SendMessage(hwndLB, LB_GETTEXT, lpSelItems[i], (LPARAM)&lpmydta);

        if (!lpmydta)
            break;

        lstrcpy(szFile, (LPSTR)lpmydta->my_cFileName);

        if (lpmydta->my_dwAttrs & ATTR_DIR) {  // is this a dir

            SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);

            if (lpmydta->my_dwAttrs & ATTR_PARENT) {       // parent dir?

                // if we are getting a full selection don't
                // return the parent ".." entry (avoid deleting
                // and other nasty operations on the parent)

                if (!iSelType)
                    continue;

                StripBackslash(szPath);       // trim it down
                StripFilespec(szPath);

            } else {
                lstrcat(szPath, szFile);      // fully qualified
            }

            lstrcpy(szFile, szPath);
            bDir = TRUE;
        }

        if (bPropertyDialog)
            QualifyPath(szFile);

        if (bLFNTest && lpmydta->my_dwAttrs & ATTR_LFN) {
            return (LPSTR)TRUE;
        }

        CheckEscapes(szFile);

        if (!bLFNTest) {
            cch += lstrlen(szFile) + 1;
            pT = (LPSTR)LocalReAlloc((HANDLE)p, cch, LMEM_MOVEABLE | LMEM_ZEROINIT);
            if (!pT)
                goto GDSExit;
            p = pT;
            lstrcat(p, szFile);
        }

        if (iSelType)
            goto GDSExit;

        if (!bLFNTest)
            lstrcat(p, szBlank);
    }

    GDSExit:
    LocalFree(lpSelItems);

    if (bLFNTest) {
        if (pfDir) {
            *pfDir = FALSE;
        }
        return NULL;
    }

    if (pfDir) {
        *pfDir = bDir;
    }
    return p;
}



// compute the max extent of all the files in this DTA block
// and update the case to match (wTextAttribs & TA_LOWERCASE)

INT
GetMaxExtent(
            HWND hwndLB,
            HANDLE hDTA
            )
{
    LPMYDTA lpmydta;
    HDC hdc;
    INT nItems;
    INT maxWidth = 0;
    INT wWidth;
    HFONT hOld;
    CHAR szPath[MAXPATHLEN];

    lpmydta = (LPMYDTA)LocalLock(hDTA);
    nItems = (INT)lpmydta->my_nFileSizeLow;

    hdc = GetDC(hwndLB);

    hOld = SelectObject(hdc, hFont);

    while (nItems-- > 0) {
        lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);

        lstrcpy(szPath, lpmydta->my_cFileName);

        // set the case of the file names here!
        if (!(lpmydta->my_dwAttrs & ATTR_LFN)) {
            if (wTextAttribs & TA_LOWERCASE)
                AnsiLower(szPath);
            else
                AnsiUpper(szPath);
        }

        MGetTextExtent(hdc, szPath, lstrlen(szPath), &wWidth, NULL);

        maxWidth = max(wWidth, maxWidth);
    }

    if (hOld)
        SelectObject(hdc, hOld);

    ReleaseDC(hwndLB, hdc);

    LocalUnlock(hDTA);

    return maxWidth + 3;    // pad it out
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DirFindIndex() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
DirFindIndex(
            HWND hwndLB,
            HANDLE hDTA,
            LPSTR szFile
            )
{
    register INT i;
    INT           nSel;
    LPMYDTA       lpmydta;

    lpmydta = (LPMYDTA)LocalLock(hDTA);
    nSel = (INT)lpmydta->my_nFileSizeLow;

    for (i = 0; i < nSel; i++) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)i, (LPARAM)&lpmydta);

        if (!lstrcmpi(szFile, (LPSTR)lpmydta->my_cFileName))
            goto DFIExit;
    }
    i = -1;               // not found, return this

    DFIExit:
    LocalUnlock(hDTA);
    return i;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DirGetAnchorFocus() -                                                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
DirGetAnchorFocus(
                 register HWND hwndLB,
                 HANDLE hDTA,
                 LPSTR szAnchor,
                 LPSTR szCaret,
                 LPSTR szTopIndex
                 )
{
    register INT      iSel, iCount;
    LPMYDTA           lpmydta;

    hDTA;                                      // fix compiler warning
    iSel = (INT)SendMessage(hwndLB, LB_GETANCHORINDEX, 0, 0L);

    iCount = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    if (iCount == 1) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)iSel, (LPARAM)&lpmydta);
        if (!lpmydta) {
            *szAnchor = 0L;
            *szCaret = 0L;
            *szTopIndex = 0L;
            return;
        }
    }
    if (iSel >= 0 && iSel < iCount) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)iSel, (LPARAM)&lpmydta);

        lstrcpy(szAnchor, (LPSTR)lpmydta->my_cFileName);
    } else
        *szAnchor = 0L;

    iSel = (INT)SendMessage(hwndLB, LB_GETCARETINDEX, 0, 0L);
    if (iSel >= 0 && iSel < iCount) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)iSel, (LPARAM)&lpmydta);
        lstrcpy(szCaret, (LPSTR)lpmydta->my_cFileName);
    } else
        *szCaret = 0L;

    iSel = (WORD)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
    if (iSel >= 0 && iSel < iCount) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)iSel, (LPARAM)&lpmydta);
        lstrcpy(szTopIndex, (LPSTR)lpmydta->my_cFileName);
    } else
        *szTopIndex = 0L;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SetSelection() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
SetSelection(
            HWND hwndLB,
            HANDLE hDTA,
            LPSTR pSel
            )
{
    INT i;
    CHAR szFile[MAXPATHLEN];
    BOOL bDidSomething = FALSE;

    while (pSel = GetNextFile(pSel, szFile, sizeof(szFile))) {

        i = DirFindIndex(hwndLB, hDTA, (LPSTR)szFile);

        if (i != -1) {
            SendMessage(hwndLB, LB_SETSEL, TRUE, (DWORD)i);
            bDidSomething = TRUE;
        }
    }
    return bDidSomething;
}


/*** FIX30: Why do we use LONG buffer ptrs here? ***/

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetPict() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  This gets the number of consecutive chrs of the same kind.  This is used
 *  to parse the time picture.  Returns 0 on error.
 */

INT
GetPict(
       CHAR ch,
       LPSTR szStr
       )
{
    register INT  count;

    count = 0;
    while (ch == *szStr++)
        count++;

    return(count);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateDate() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  This picks up the values in wValArray, converts them
 *  in a string containing the formatted date.
 *  wValArray should contain Month-Day-Year (in that order).
 */

INT
CreateDate(
          WORD *wValArray,
          LPSTR szOutStr
          )

{
    INT           i;
    INT           cchPictPart;
    WORD          wDigit;
    WORD          wIndex;
    WORD          wTempVal;
    register LPSTR pszPict;
    register LPSTR pszInStr;

    pszPict = szShortDate;
    pszInStr = szOutStr;

    for (i=0; i < 3; i++) {
        cchPictPart = GetPict(*pszPict, pszPict);
        switch (*pszPict) {
            case 'M':
                wIndex = 0;
                goto CDDoIt;

            case 'D':
                wIndex = 1;
                goto CDDoIt;

            case 'Y':
                wIndex = 2;
                if (cchPictPart == 4) {
                    *pszInStr++ = '1';
                    *pszInStr++ = '9';
                }
                CDDoIt:
                /* This assumes that the values are of two digits only. */
                wTempVal = wValArray[wIndex];

                wDigit = wTempVal / (WORD)10;
                if (wDigit)
                    *pszInStr++ = (CHAR)(wDigit + '0');
                else if (cchPictPart > 1)
                    *pszInStr++ = '0';
#if 0
                else {
                    *pszInStr++ = ' ';
                    *pszInStr++ = ' ';
                }
#endif

                *pszInStr++ = (CHAR)((wTempVal % 10) + '0');

                pszPict += cchPictPart;

                /* Add the separator. */
                if (*pszPict)
                    *pszInStr++ = *pszPict;

                break;
        }
        pszPict++;
    }

    *pszInStr = 0L;

    return(lstrlen(szOutStr));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateTime() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  This picks up the values in wValArray, converts them
 *  in a string containing the formatted time.
 *  wValArray should contain Hour-Min-Sec (in that order).
 */

INT
CreateTime(
          WORD * wValArray,
          LPSTR szOutStr
          )
{
    INT           i;
    BOOL          bAM;
    WORD          wHourMinSec;
    register WORD wDigit;
    register LPSTR pszInStr;

    pszInStr = szOutStr;

    wDigit = wValArray[0];
    bAM = (wDigit < 12);

    if (!iTime) {
        if (wDigit >= 12)
            wDigit -= 12;

        if (!wDigit)
            wDigit = 12;
    }

    wValArray[0] = wDigit;

    for (i=0; i < 3; i++) {
        wHourMinSec = wValArray[i];

        /* This assumes that the values are of two digits only. */
        wDigit = wHourMinSec / (WORD)10;

        if (i > 0)
            *pszInStr++ = (CHAR)(wDigit + '0');
        else if (wDigit || iTLZero)
            *pszInStr++ = (CHAR)(wDigit + '0');
#if 0
        else {
            /* NOTE: 2 blanks is the same width as one digit. */
            // wrong!
            *pszInStr++ = ' ';
            *pszInStr++ = ' ';
        }
#endif

        *pszInStr++ = (CHAR)((wHourMinSec % 10) + '0');

        if (i < 2)
            *pszInStr++ = *szTime;     /* Assumes time sep. is 1 char long */
    }

    // *pszInStr++ = ' ';

    if (bAM)
        lstrcpy(pszInStr, sz1159);
    else
        lstrcpy(pszInStr, sz2359);

    return lstrlen(szOutStr);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PutSize() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
PutSize(
       DWORD dwSize,
       LPSTR szOutStr
       )
{
    // LPSTR szStr;
    // int  cBlanks;
    // char szTemp[30];

    // Convert it into string

    return wsprintf(szOutStr, "%lu", dwSize);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PutDate() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
PutDate(
       LPFILETIME lpftDate,
       LPSTR szStr
       )
{
    WORD  wValArray[3];
    WORD wDate, wTime;

    if (FileTimeToDosDateTime(lpftDate, &wDate, &wTime)) {
        wValArray[0] = (WORD)((wDate & MONTHMASK) >> 5);              /* Month */
        wValArray[1] = (WORD)((wDate & DATEMASK));                    /* Date  */
        wValArray[2] = (WORD)((wDate >> 9) + 80);                     /* Year  */
        return(CreateDate((WORD *)wValArray, szStr));
    } else {
        return 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PutTime() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
PutTime(
       LPFILETIME lpftTime,
       LPSTR szStr
       )
{
    WORD wValArray[3];
    WORD wDate, wTime;

    if (FileTimeToDosDateTime(lpftTime, &wDate, &wTime)) {
        wValArray[0] = (wTime >> 0x0B);
        wValArray[1] = (WORD)((wTime & MINUTEMASK) >> 5);
        wValArray[2] = (WORD)((wTime & SECONDSMASK) << 1);
    
        return(CreateTime((WORD *)wValArray, szStr));
    } else {
        return 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PutAttributes() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
PutAttributes(
             register DWORD dwAttribute,
             register LPSTR pszStr
             )
{
    WORD  i;
    INT   cch = 0;

    for (i=0; i < 4; i++) {
        if (dwAttribute & 1) {  // BUG hardcoded.
            *pszStr++ = szAttr[i];
            cch++;
        } else {
#if 0
            *pszStr++ = '-';
            *pszStr++ = '-';
            cch += 2;
#endif
        }

        if (i == 2)
            dwAttribute >>= 3;                 /* Skip next two bits */
        else
            dwAttribute >>= 1;                 /* Goto next bit */
    }
    *pszStr = 0;
    return(cch);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateLBLine() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This creates a character string that contains all the required
 * details of a file;  (Name, Size, Date, Time, Attr)
 */

VOID
CreateLBLine(
            register WORD wLineFormat,
            LPMYDTA lpmydta,
            LPSTR szBuffer
            )
{
    register LPSTR pch;
    DWORD dwAttr;

    pch = szBuffer;

    dwAttr = lpmydta->my_dwAttrs;

    /* Copy the file name. */
    lstrcpy(pch, lpmydta->my_cFileName);
    pch += lstrlen(pch);

    *pch = 0L;

    /* Should we show the size? */
    if (wLineFormat & VIEW_SIZE) {
        *pch++ = TABCHAR;
        if (!(dwAttr & ATTR_DIR))
            pch += PutSize(lpmydta->my_nFileSizeLow, pch);
        else
            *pch = 0;
    }

    /* Should we show the date? */
    if (wLineFormat & VIEW_DATE) {
        *pch++ = TABCHAR;
        pch += PutDate(&lpmydta->my_ftLastWriteTime, pch);
    }

    /* Should we show the time? */
    if (wLineFormat & VIEW_TIME) {
        *pch++ = TABCHAR;
        pch += PutTime(&lpmydta->my_ftLastWriteTime, pch);
    }

    /* Should we show the attributes? */
    if (wLineFormat & VIEW_FLAGS) {
        *pch++ = TABCHAR;
        pch += PutAttributes(dwAttr, pch);
    }

    //  *pch = 0L;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CompareDTA() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
CompareDTA(
          register LPMYDTA lpItem1,
          LPMYDTA lpItem2,
          WORD wSort
          )
{
    register INT  ret;


    if (lpItem1->my_dwAttrs & ATTR_PARENT) {
        ret = -1;
        goto CDDone;
    }

    if (lpItem2->my_dwAttrs & ATTR_PARENT) {
        ret = 1;
        goto CDDone;
    }

    if ((lpItem1->my_dwAttrs & ATTR_DIR) > (lpItem2->my_dwAttrs & ATTR_DIR)) {
        ret = -1;
        goto CDDone;
    } else if ((lpItem1->my_dwAttrs & ATTR_DIR) < (lpItem2->my_dwAttrs & ATTR_DIR)) {
        ret = 1;
        goto CDDone;
    }

    switch (wSort) {
        case IDD_TYPE:
            {
                LPSTR ptr1;
                LPSTR ptr2;

                // BUG: should use strrchr for long file names.
                for (ptr1 = lpItem1->my_cFileName; *ptr1 && *ptr1 != '.'; ptr1++)
                    ;
                for (ptr2 = lpItem2->my_cFileName; *ptr2 && *ptr2 != '.'; ptr2++)
                    ;

                ret = lstrcmpi(ptr1, ptr2);

                if (ret == 0)
                    goto CompareNames;
                break;
            }

        case IDD_SIZE:
            if (lpItem1->my_nFileSizeLow > lpItem2->my_nFileSizeLow)
                ret = -1;
            else if (lpItem1->my_nFileSizeLow < lpItem2->my_nFileSizeLow)
                ret = 1;
            else
                goto CompareNames;
            break;

        case IDD_DATE:
            {
                DWORD d1High, d1Low;
                DWORD d2High, d2Low;

                d1High = lpItem1->my_ftLastWriteTime.dwHighDateTime;
                d2High = lpItem2->my_ftLastWriteTime.dwHighDateTime;

                if (d1High > d2High) {
                    ret = -1;
                } else if (d1High < d2High) {
                    ret = 1;
                } else {
                    d1Low = lpItem1->my_ftLastWriteTime.dwLowDateTime;
                    d2Low = lpItem2->my_ftLastWriteTime.dwLowDateTime;

                    if (d1Low > d2Low)
                        ret = -1;
                    else if (d1Low < d2Low)
                        ret = 1;
                    else
                        goto CompareNames;

                }
                break;
            }

        case IDD_NAME:
            CompareNames:
            ret = lstrcmpi(lpItem1->my_cFileName, lpItem2->my_cFileName);
            break;
    }

    CDDone:
    return ret;
}


// load the status buffers with the appropriate stuff and invalidates
// the status area causing it to repaint.

VOID
APIENTRY
UpdateStatus(
            HWND hWnd
            )
{
    CHAR szTemp[128];
    WCHAR szNumBuf1[40];
    WCHAR szNumBuf2[40];
    WORD wDrive;
    HWND hwndDir;
    RECT rc;

    if (!bStatusBar)
        return;

    if (hWnd != (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L))
        return;

    hwndDir = HasDirWindow(hWnd);

    szStatusTree[0] = 0L;

    if (hwndDir)
        GetDirStatus(hwndDir, szStatusTree, szStatusDir);
    else
        szStatusDir[0] = 0L;

    // force the status area to update

    GetClientRect(hwndFrame, &rc);
    rc.top = rc.bottom - dyStatus;
    InvalidateRect(hwndFrame, &rc, FALSE);
}


HWND
GetDirSelData(
             HWND hWnd,
             DWORD *pdwSelSize,
             INT *piSelCount,
             DWORD *pdwTotalSize,
             INT *piTotalCount
             )
{
    INT i;
    LPMYDTA lpmydta;
    HWND hwndLB;
    INT countSel, countTotal;
    LPINT lpSelItems, lpSelItemsT;
    HANDLE hDTA;

    if (!(hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX))) {       // fast scroll
        return NULL;
    }

    *pdwSelSize = *pdwTotalSize = 0L;
    *piSelCount = *piTotalCount = 0;
    countSel = (INT)SendMessage(hwndLB, LB_GETSELCOUNT, 0, 0L);
    lpSelItems = LocalAlloc(LMEM_FIXED, sizeof(INT) * countSel);
    if (lpSelItems == NULL)
        return NULL;
    countSel = (INT)SendMessage(hwndLB, LB_GETSELITEMS, (WPARAM)countSel, (LPARAM)lpSelItems);

    hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTA);
    if (hDTA == NULL)
        return NULL;

    lpmydta = (LPMYDTA)LocalLock(hDTA);
    countTotal = (INT)lpmydta->my_nFileSizeLow;


    lpSelItemsT = lpSelItems;
    for (i = 0; i < countTotal; i++) {

        lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);

        if (lpmydta->my_dwAttrs & ATTR_PARENT)
            continue;

        if (countSel && *lpSelItems == lpmydta->nIndex) {
            (*piSelCount)++;
            *pdwSelSize += lpmydta->my_nFileSizeLow;
            countSel--;
            lpSelItems++;
        }
        (*piTotalCount)++;
        *pdwTotalSize += lpmydta->my_nFileSizeLow;
    }


    LocalUnlock(hDTA);
    LocalFree(lpSelItemsT);
    return hwndLB;

}



VOID
GetDirStatus(
            HWND hWnd,
            LPSTR szMessage1,
            LPSTR szMessage2
            )
{
    INT iSelCount, iCount;
    DWORD dwSelSize, dwSize;
    CHAR szNumBuf[40];
    HWND hwndLB;

    szMessage2[0] = 0;

    hwndLB = GetDirSelData(hWnd, &dwSelSize, &iSelCount, &dwSize, &iCount);

    if (LoadString(hAppInstance, IDS_STATUSMSG, szMessage, sizeof(szMessage)))
        wsprintf(szMessage2, szMessage, iCount);

    if ((HWND)GetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS) == hwndLB) {
        if (LoadString(hAppInstance, IDS_STATUSMSG2, szMessage, sizeof(szMessage)))
            wsprintf(szMessage1, szMessage, iSelCount);
    }
}


// given a descendant of an MDI child (or an MDI child) return
// the MDI child in the descendant chain.  returns NULL if not
// found.


HWND
APIENTRY
GetMDIChildFromDecendant(
                        HWND hwnd
                        )
{
    HWND hwndT;

    while (hwnd && ((hwndT = GetParent(hwnd)) != hwndMDIClient))
        hwnd = hwndT;

    return hwnd;
}



// setup the defTabStops[] array for subsequent TabbedTextOut() calls.
//
// in:
//      iMaxWidthFileName       the largest dx width of files to be
//                              displayed
//
// returns:
//      total extent of the "File Details" view.  used to
//      set scroll extents


INT
APIENTRY
FixTabsAndThings(
                HWND hwndLB,
                WORD *pwTabs,
                INT iMaxWidthFileName,
                WORD wViewOpts
                )
{
    INT i;
    HDC hdc;
    HFONT hOld;
    CHAR szBuf[30];
    INT  ixExtent = 0;

    i = iMaxWidthFileName;  // the widest filename

    if (pwTabs == NULL)
        return i;

    hdc = GetDC(NULL);
    hOld = SelectObject(hdc, hFont);

    // max size digits field
    if (wViewOpts & VIEW_SIZE) {
        MGetTextExtent(hdc, "99999999", 8, &ixExtent, NULL);
        i += ixExtent + dxText;
        *pwTabs++ = (WORD)i;  // Size
    }

    if (wViewOpts & VIEW_DATE) {
        FILETIME filetime;

        DosDateTimeToFileTime((WORD)((19 << 9) | (12 << 5) | 30), (WORD)0xFFFF, &filetime);
        PutDate(&filetime, szBuf);
        // max date digits
        MGetTextExtent(hdc, szBuf, lstrlen(szBuf), &ixExtent, NULL);
        i += ixExtent + dxText;
        *pwTabs++ = (WORD)i;  // Date
    }

    // max time digits
    if (wViewOpts & VIEW_TIME) {
        FILETIME filetime;

        DosDateTimeToFileTime((WORD)((19 << 9) | (12 << 5) | 30), (WORD)0xFFFF, &filetime);
        PutTime(&filetime, szBuf);
        MGetTextExtent(hdc, szBuf, lstrlen(szBuf), &ixExtent, NULL);
        i += ixExtent + dxText;
        *pwTabs++ = (WORD)i;  // Time
    }

    // max attris digits
    if (wViewOpts & VIEW_FLAGS) {
        PutAttributes(ATTR_ALL, szBuf);
        MGetTextExtent(hdc, szBuf, lstrlen(szBuf), &ixExtent, NULL);
        i += ixExtent + dxText;
        *pwTabs++ = (WORD)i;  // Attributes
    }

    if (hOld)
        SelectObject(hdc, hOld);

    ReleaseDC(NULL, hdc);

    SendMessage(hwndLB, LB_SETHORIZONTALEXTENT,
                i + dxFolder + 4 * dyBorderx2, 0L);

    return i;               // total extent
}


// sets the font and adjusts the dimension parameters for the
// new font
//
// in:
//      hWnd            hwnd of a dir window
//      hwndLB          and it's listbox
//      hFont           the font to set
//
// uses:
//      dyFileName      GLOBAL; set based on new font height
//      GWL_VIEW        window word of hWnd for either full or name view
//      GWL_HDTA        to compute the max extent given the new font
//
// sets:
//  Listbox tabs array
//      LB_SETCOLUMNWIDTH
//      or
//      LB_SETHORIZONTALEXTENT


VOID
APIENTRY
SetLBFont(
         HWND hWnd,
         HWND hwndLB,
         HANDLE hNewFont
         )
{
    INT dxMaxExtent;
    HANDLE hDTA;
    WORD wViewFlags = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);

    SendMessage(hwndLB, WM_SETFONT, (WPARAM)hNewFont, 0L);

    // this is needed when changing the font. when creating
    // the return from WM_MEASUREITEM will set the cell height

    SendMessage(hwndLB, LB_SETITEMHEIGHT, 0, (LONG)dyFileName);

    hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTA);

    dxMaxExtent = (INT)GetMaxExtent(hwndLB, hDTA);

    // if we are in name only view we change the width

    if ((VIEW_EVERYTHING & wViewFlags) == VIEW_NAMEONLY) {
        SendMessage(hwndLB, LB_SETCOLUMNWIDTH, dxMaxExtent + dxFolder + dyBorderx2, 0L);
    } else {
        FixTabsAndThings(hwndLB,(WORD *)GetWindowLongPtr(hWnd, GWLP_TABARRAY),
                         dxMaxExtent, wViewFlags);
    }
}

VOID
APIENTRY
UpdateSelection(
               HWND hwndLB
               )
{
    INT count, i;
    RECT rc;

    count = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
    for (i=0; i < count; i++) {

        if ((BOOL)SendMessage(hwndLB, LB_GETSEL, i, 0L)) {
            SendMessage(hwndLB, LB_GETITEMRECT, i, (LPARAM)&rc);
            InvalidateRect(hwndLB, &rc, TRUE);
        }
    }
}



LONG
CreateFSCChangeDisplayMess(
                          HWND hWnd,
                          UINT wMsg,
                          WPARAM wParam,
                          LPARAM lParam
                          )
{
    CHAR         szCaret[MAXFILENAMELEN+1];
    CHAR         szAnchor[MAXFILENAMELEN+1];
    CHAR         szTopIndex[MAXFILENAMELEN+1];
    CHAR         szPath[256];
    HCURSOR  hCursor;
    HWND     hwndLB, hwndT;
    HANDLE   hDTA;
    LPMYDTA lpmydta;
    DWORD ws;
    LPSTR  pSel;
    INT   iSel, iTop=0;
    RECT  rc;
    BOOL  bResetFocus;
    WORD *pwTabs;

    hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX);

    switch (wMsg) {

        case WM_FILESYSCHANGE:
            if (cDisableFSC) {
                // I need to be updated
                SetWindowLong(GetParent(hWnd), GWL_FSCFLAG, TRUE);
                break;
            }

            wParam = CD_PATH;
            lParam = 0L;
            /*** FALL THRU ***/

        case FS_CHANGEDISPLAY:

            // We dont want to reset the flag, if the operation is not CD_PATH.
            // This is because, only the operation CD_PATH implies a true
            // refresh. The operations CD_VEIW and CD_SORT are not refresh
            // operations. They merely reformat the existing contents of a dir
            // window. The flag is now reset in 'case CD_PATH:'.

            //SetWindowLong(GetParent(hWnd), GWL_FSCFLAG, FALSE);

            hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            ShowCursor(TRUE);

            pSel = NULL;          // init this

            bResetFocus = (GetFocus() == hwndLB);

            hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTA);

            switch (wParam) {
                case CD_SORT:

                    // change the sort order of the listbox

                    // we want to save the current selection and things here
                    // and restore them once the listbox has been rebuilt

                    // But first, save a list of the selected items FIX31

                    pSel = (LPSTR)DirGetSelection(hWnd, hwndLB, 0, NULL);
                    DirGetAnchorFocus(hwndLB, hDTA, szAnchor, szCaret, szTopIndex);
                    iTop = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);

                    SetWindowLong(GetParent(hWnd), GWL_SORT, LOWORD(lParam));

                    SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

                    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
                    FillDirList(hwndLB, hDTA);

                    goto ResetSelection;

                case CD_VIEW:
                    {
                        WORD      wCurView;

                        // change the view type (name only, vs full details)
                        // Warning! Convoluted Code!  We want to destroy the
                        // listbox only if we are going between Name Only view
                        // and Details view.

                        wNewView = LOWORD(lParam);
                        wCurView = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);

                        if (wNewView == wCurView)
                            break;    // NOP

                        // special case the long and partial view change
                        // this doesn't require us to recreate the listbox

                        if ((VIEW_EVERYTHING & wNewView) && (VIEW_EVERYTHING & wCurView)) {
                            SetWindowLong(GetParent(hWnd), GWL_VIEW, wNewView);
                            FixTabsAndThings(hwndLB,(WORD *)GetWindowLongPtr(hWnd, GWLP_TABARRAY),
                                             GetMaxExtent(hwndLB, hDTA), wNewView);

                            InvalidateRect(hwndLB, NULL, TRUE);
                            break;
                        }


                        /* Things are a changing radically.  Destroy the listbox. */

                        // But first, save a list of the selected items

                        pSel = (LPSTR)DirGetSelection(hWnd, hwndLB, 0, NULL);
                        DirGetAnchorFocus(hwndLB, hDTA, szAnchor, szCaret, szTopIndex);
                        iTop = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
                        lstrcpy(szTopIndex, szCaret);

                        if ((HWND)GetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS) == hwndLB)
                            SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, 0L);

                        DestroyWindow(hwndLB);

                        /* Create a new one (preserving the Sort setting). */
                        wNewSort = (WORD)GetWindowLong(GetParent(hWnd), GWL_SORT);
                        dwNewAttribs = (DWORD)GetWindowLong(GetParent(hWnd), GWL_ATTRIBS);

                        goto CreateLB;
                    }

                case CD_PATH | CD_ALLOWABORT:
                case CD_PATH:
                case CD_PATH_FORCE:

                    // bad things happens if we change the path
                    // while we are reading the tree.  bounch this
                    // in that case.  this causes the steal data
                    // code in the tree to barf because we would
                    // free the hDTA while it is being traversed
                    // (very bad thing)

                    // we set the GWL_FSCFLAG to true, if we could not refresh.
                    // else we set it to FALSE. However if the flag was previously
                    // TRUE we set lParam to NULL. lParam = NULL implies 'forced'
                    // refresh.

                    hwndT = HasTreeWindow(GetParent(hWnd));
                    if (hwndT && GetWindowLong(hwndT, GWL_READLEVEL)) {
                        SetWindowLong(GetParent(hWnd), GWL_FSCFLAG, TRUE);
                        break;
                    } else {
                        if (SetWindowLong(GetParent(hWnd), GWL_FSCFLAG, FALSE))
                            lParam = 0L;
                    }

                    // change the path of the current directory window (basically
                    // recreate the whole thing)

                    // if lParam == NULL this is a refresh, otherwise
                    // check for short circut case to avoid rereading
                    // the directory

                    GetMDIWindowText(GetParent(hWnd), szPath, sizeof(szPath));

                    if (lParam) {

                        // get out early if this is a NOP

                        if ((wParam != CD_PATH_FORCE) &&
                            !lstrcmpi(szPath, (LPSTR)lParam))
                            break;

                        lstrcpy(szPath, (LPSTR)lParam);

                        iLastSel = -1;          // invalidate the last selection
                    }

                    // if this is a refresh save the current selection, anchor stuff, etc

                    if (!lParam) {
                        pSel = (LPSTR)DirGetSelection(hWnd, hwndLB, 0, NULL);
                        iTop = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
                        DirGetAnchorFocus(hwndLB, hDTA, szAnchor, szCaret, szTopIndex);
                    }

                    // Create a new one (preserving the Sort setting)

                    wNewSort = (WORD)GetWindowLong(GetParent(hWnd), GWL_SORT);
                    wNewView = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);
                    dwNewAttribs = GetWindowLong(GetParent(hWnd), GWL_ATTRIBS);

                    if (hDTA) {     // fast scroll case
                        LocalFree(hDTA);
                        hDTA = NULL;
                        SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);
                    }
                    goto CreateNewPath;
            }

            SetCursor(hCursor);
            ShowCursor(FALSE);
            break;

        case WM_CREATE:
            TRACE(BF_WM_CREATE, "CreateFSCChangeDisplayMess - WM_CREATE");

            // wNewView, wNewSort and dwNewAddribs define the viewing
            // parameters of the new window (GLOBALS)
            // the window text of the parent window defines the
            // filespec and the directory to open up

            hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            ShowCursor(TRUE);

            wParam = 0;           // don't allow abort in CreateDTABlock()
            lParam = 1L;          // allow DTA steal optimization
            pSel = NULL;          // no selection to restore
            bResetFocus = FALSE;  // no focus to restore

            // get the dir to open from our parent window text

            GetMDIWindowText(GetParent(hWnd), szPath, sizeof(szPath));

            if ((pwTabs = (WORD *)LocalAlloc(LPTR,sizeof(WORD) * 4)) == NULL)
                return -1L;

            SetWindowLongPtr(hWnd, GWLP_TABARRAY, (ULONG_PTR)pwTabs);

            CreateNewPath:

            // at this point szPath has the directory to read.  this
            // either came from the WM_CREATE case or the
            // FS_CHANGEDISPLAY (CD_PATH) directory reset

#ifdef DEBUG
            {
                char buf[80];

                wsprintf(buf, "attribs %4.4X\r\n", dwNewAttribs);
                OutputDebugString(buf);

            }
#endif

            if (!dwNewAttribs)
                dwNewAttribs = ATTR_DEFAULT;

            hDTA = CreateDTABlock(hWnd, szPath, dwNewAttribs, wParam & CD_ALLOWABORT ? TRUE : FALSE, lParam == 0L);

            // check for user abort (fast scroll case)

            if (hDTA == (HANDLE)-1) {
                SetWindowLongPtr(hWnd, GWLP_HDTA, 0L);
                goto FastScrollExit;
            }

            // for the FS_CHANGEDISPLAY case we set this now, to avoid
            // multiple title repaints when the user is fast scrolling

            if (wMsg != WM_CREATE)
                SetMDIWindowText(GetParent(hWnd), szPath);

            SetWindowLongPtr(hWnd, GWLP_HDTA, (LONG_PTR)hDTA);

            if (!hDTA)
                goto CDAbort;

            if (wMsg != WM_CREATE)
                goto SkipWindowCreate;

            CreateLB:
            if ((wNewView & VIEW_EVERYTHING) == VIEW_NAMEONLY)
                ws = WS_DIRSTYLE | LBS_MULTICOLUMN | WS_HSCROLL | WS_VISIBLE | WS_BORDER | LBS_DISABLENOSCROLL;
            else
                ws = WS_DIRSTYLE | WS_HSCROLL | WS_VSCROLL |  WS_VISIBLE | WS_BORDER | LBS_DISABLENOSCROLL;

            GetClientRect(hWnd, &rc);

            // the border stuff is for the non initial create case
            // I don't know why

            hwndLB = CreateWindowEx(0L, szListbox, NULL, ws,
                                    dyBorder, dyBorder,
                                    rc.right - 2*dyBorder, rc.bottom - 2*dyBorder,
                                    hWnd, (HMENU)IDCW_LISTBOX,
                                    hAppInstance, NULL);

            if (!hwndLB) {
                if (hDTA)
                    LocalFree(hDTA);

                if (wMsg != WM_CREATE)
                    SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                CDAbort:
                ShowCursor(FALSE);
                SetCursor(hCursor);
                return -1L;
            }

            // set all the view/sort/include parameters here

            SetWindowLong(GetParent(hWnd), GWL_VIEW, wNewView);
            SetWindowLong(GetParent(hWnd), GWL_SORT, wNewSort);
            SetWindowLong(GetParent(hWnd), GWL_ATTRIBS, dwNewAttribs);

            // restore the last focus stuff if we are recreating here
            if (!GetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS))
                SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LONG_PTR)hwndLB);

            // set the font and dimensions here

            SkipWindowCreate:
            SetLBFont(hWnd, hwndLB, hFont);

            SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            FillDirList(hwndLB, hDTA);

            if (pSel) {
                BOOL bDidSomething;

                ResetSelection:
                /* Give the selected item the focus rect and anchor pt. */
                bDidSomething = SetSelection(hwndLB, hDTA, pSel);
                LocalFree((HANDLE)pSel);

                if (!bDidSomething)
                    goto SelectFirst;

                iSel = DirFindIndex(hwndLB, hDTA, szTopIndex);
                if (iSel == -1)
                    iSel = 0;
                SendMessage(hwndLB, LB_SETTOPINDEX, iSel, 0L);

                iSel = DirFindIndex(hwndLB, hDTA, szAnchor);
                if (iSel == -1)
                    iSel = 0;
                SendMessage(hwndLB, LB_SETANCHORINDEX, iSel, 0L);

                iSel = DirFindIndex(hwndLB, hDTA, szCaret);
                if (iSel == -1)
                    iSel = 0;
                /* SETCARETINDEX will scroll item into view */
                SendMessage(hwndLB, LB_SETCARETINDEX, iSel, 0L);

            } else {
                INT iLBCount;
                SelectFirst:
                iLBCount = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

                if (iLastSel != -1 && (iLastSel <= iLBCount)) {

                    iSel = iLastSel;

                    // check the case of the last item being deleted

                    if (iSel == iLBCount)
                        iSel--;

                    SendMessage(hwndLB, LB_SETSEL, TRUE, (DWORD)iSel);

                } else {

                    // Select the first non-directory item

                    iSel = 0;
                    while (iSel < iLBCount) {

                        SendMessage(hwndLB, LB_GETTEXT, iSel, (LPARAM)&lpmydta);
                        if (!lpmydta)
                            break;
                        if (!(lpmydta->my_dwAttrs & ATTR_PARENT)) {
                            iTop = iSel;
                            break;
                        }
                        iSel++;
                    }
                    LocalUnlock(hDTA);

                    if (iSel == iLBCount)
                        iSel = 0;
                }

                SendMessage(hwndLB, LB_SETTOPINDEX, iTop, 0L);
                // and select this item if no tree window
                if (!HasTreeWindow(GetParent(hWnd)))
                    SendMessage(hwndLB, LB_SETSEL, TRUE, (DWORD)iSel);
                SendMessage(hwndLB, LB_SETANCHORINDEX, iSel, 0L);
                /* SETCARETINDEX will scroll item into view */
                SendMessage(hwndLB, LB_SETCARETINDEX, iSel, 0L);
            }

            if (bResetFocus)
                if (SetDirFocus(hWnd))
                    SetFocus(hWnd);

            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);

            InvalidateRect(hwndLB, NULL, TRUE);

            lFreeSpace = -1;              // force status update
            UpdateStatus(GetParent(hWnd));

            FastScrollExit:

            ShowCursor(FALSE);
            SetCursor(hCursor);
            break;
    }

    return 0L;
}


INT_PTR
APIENTRY
DirWndProc(
          HWND hWnd,
          UINT wMsg,
          WPARAM wParam,
          LPARAM lParam
          )
{
    INT      iSel, i;
    LPSTR    pSel;
    HWND     hwndLB;
    HANDLE   hDTA;
    LPMYDTA lpmydta;
    CHAR szTemp[MAXPATHLEN] = {0};
    CHAR szSourceFile[MAXPATHLEN];

    static HWND       hwndOwnerDraw = NULL;

    STKCHK();

    /* Here we generate OWNERDRAWBEGIN and OWNERDRAWEND messages
     * to speed up the painting operations.  We do the expensive stuff
     * at the beginning instead of on every DRAWITEM message.
     */

    if (hwndOwnerDraw == hWnd && wMsg != WM_DRAWITEM) {
        hwndOwnerDraw = NULL;
        SendMessage(hWnd, WM_OWNERDRAWEND, 0, 0L);
    } else if (wMsg == WM_DRAWITEM && hwndOwnerDraw != hWnd) {
        SendMessage(hWnd, WM_OWNERDRAWBEGIN, wParam, lParam);
        hwndOwnerDraw = hWnd;
    }

    hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX);

    switch (wMsg) {
        // returns in lParam upper case ANSI directory string with
        // a trailing backslash.  if you want to do a SetCurrentDirecotor()
        // you must first StripBackslash() the thing!

        case FS_GETDIRECTORY:
            MSG("DirWndProc", "FS_GETDIRECTORY");

            GetMDIWindowText(GetParent(hWnd), (LPSTR)lParam, (INT)wParam);        // get the string

            StripFilespec((LPSTR)lParam); // Remove the trailing extention

            AddBackslash((LPSTR)lParam);  // terminate with a backslash

            //AnsiUpper((LPSTR)lParam);     // and upper case
            break;

        case FS_GETDRIVE:
            MSG("DirWndProc", "FS_GETDRIVE");
            // Returns the letter of the corresponding directory

            GetWindowText(GetParent(hWnd), szTemp, sizeof(szTemp));
            AnsiUpper(szTemp);
            return szTemp[0];     // first character

        case FS_GETFILESPEC:
            MSG("DirWndProc", "FS_GETFILESPEC");
            // returns the current filespec (from View.Include...).  this is
            // an uppercase ANSI string

            GetMDIWindowText(GetParent(hWnd), (LPSTR)lParam, (INT)wParam);
            StripPath((LPSTR)lParam);
            //AnsiUpper((LPSTR)lParam);     // and upper case
            break;

        case FS_SETSELECTION:
            MSG("DirWndProc", "FS_SETSELECTION");
            // wParam is the select(TRUE)/unselect(FALSE) param
            // lParam is the filespec to match against

            SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            DSSetSelection(hwndLB, wParam ? TRUE : FALSE, (LPSTR)lParam, FALSE);
            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
            InvalidateRect(hwndLB, NULL, TRUE);
            break;

        case FS_GETSELECTION:
            // return = pszDir
#define pfDir       (BOOL *)lParam
#define fSingleSel  (BOOL)wParam
            MSG("DirWndProc", "FS_GETSELECTION");

            return (INT_PTR)DirGetSelection(hWnd, hwndLB, fSingleSel, pfDir);
#undef pfDir
#undef fSingleSel

        case WM_CREATE:
        case WM_FILESYSCHANGE:
        case FS_CHANGEDISPLAY:
            TRACE(BF_WM_CREATE, "DirWndProc - WM_CREATE");
            return CreateFSCChangeDisplayMess(hWnd, wMsg, wParam, lParam);


        case WM_DESTROY:
            MSG("DirWndProc", "WM_DESTROY");
            {
                HANDLE hMem;
                HWND hwnd;

                if (hwndLB == GetFocus())
                    if (hwnd = HasTreeWindow(GetParent(hWnd)))
                        SetFocus(hwnd);

                if (hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_TABARRAY))
                    LocalFree(hMem);
            }
            break;

        case WM_CHARTOITEM:
            MSG("DirWndProc", "WM_CHARTOITEM");
            {
                WORD      i, j;
                WORD      cItems;
                CHAR      ch[2];

                if ((ch[0] = GET_WM_CHARTOITEM_CHAR(wParam, lParam)) <= ' ')
                    return(-1L);

                i = GET_WM_CHARTOITEM_POS(wParam, lParam);
                cItems = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

                szTemp[1] = 0L;
                ch[0] &= 255;
                ch[1] = '\0';

                for (j=1; j <= cItems; j++) {
                    SendMessage(hwndLB, LB_GETTEXT, (i + j) % cItems, (LPARAM)&lpmydta);

                    szTemp[0] = lpmydta->my_cFileName[0];

                    /* Do it this way to be case insensitive. */
                    if (!lstrcmpi((LPSTR)ch, szTemp))
                        break;
                }

                if (j > cItems)
                    return -2L;

                return(MAKELONG((i + j) % cItems, 0));
            }

        case WM_COMPAREITEM:
            MSG("DirWndProc", "WM_COMPAREITEM");
            {
#define lpci ((LPCOMPAREITEMSTRUCT)lParam)

                return (LONG)CompareDTA((LPMYDTA)lpci->itemData1,
                                        (LPMYDTA)lpci->itemData2,
                                        (WORD)GetWindowLong(GetParent(hWnd), GWL_SORT));
            }

        case WM_NCDESTROY:
            MSG("DirWndProc", "WM_NCDESTROY");

            if (hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTA)) {
                LocalFree(hDTA);
            }

            break;

        case WM_DRAGLOOP:
            MSG("DirWndProc", "WM_DRAGDROP");
            /* WM_DRAGLOOP is sent to the source window as the object is moved.
             *
             *    wParam: TRUE if the object is currently over a droppable sink
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGLOOP is used to turn the source bitmaps on/off as we drag. */

            DSDragLoop(hwndLB, wParam, (LPDROPSTRUCT)lParam, FALSE);
            break;

        case WM_DRAGSELECT:
            MSG("DirWndProc", "WM_DRAGSELECT");
            /* WM_DRAGSELECT is sent to a sink whenever an new object is dragged
             * inside of it.
             *
             *    wParam: TRUE if the sink is being entered, FALSE if it's being
             *            exited.
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGSELECT is used to turn our selection rectangle on or off. */

#define lpds ((LPDROPSTRUCT)lParam)

            iSelHilite = LOWORD(lpds->dwControlData);
            DSRectItem(hwndLB, iSelHilite, (BOOL)wParam, FALSE);
            break;

        case WM_DRAGMOVE:
            MSG("DirWndProc", "WM_DRAGMOVE");
            /* WM_DRAGMOVE is sent to a sink as the object is being dragged
             * within it.
             *
             *    wParam: Unused
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGMOVE is used to move our selection rectangle among sub-items. */

#define lpds ((LPDROPSTRUCT)lParam)

            /* Get the subitem we are over. */
            iSel = LOWORD(lpds->dwControlData);

            /* Is it a new one? */
            if (iSel == iSelHilite)
                break;

            /* Yup, un-select the old item. */
            DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);

            /* Select the new one. */
            iSelHilite = iSel;
            DSRectItem(hwndLB, iSel, TRUE, FALSE);
            break;

        case WM_OWNERDRAWBEGIN:
#define lpLBItem ((LPDRAWITEMSTRUCT)lParam)

            MSG("DirWndProc", "WM_OWNERDRAWBEGIN");

            /* Set the default bk and text colors. */
            SetTextColor(lpLBItem->hDC, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(lpLBItem->hDC, GetSysColor(COLOR_WINDOW));

#undef lpLBItem
            break;

        case WM_OWNERDRAWEND:
            MSG("DirWndProc", "WM_OWNERDRAWEND");
            break;

        case WM_DRAWITEM:
#define lpLBItem ((LPDRAWITEMSTRUCT)lParam)

            MSG("DirWndProc", "WM_DRAWITEM");
            {
                WORD wViewFlags;
                LPMYDTA lpmydta;

                /* Don't do anything to empty listboxes. */
                if (lpLBItem->itemID == -1)
                    break;

                if (lpLBItem->itemData == (DWORD)0) {

                    LoadString(hAppInstance, IDS_NOFILES, szTemp, sizeof(szTemp));
                    TextOut(lpLBItem->hDC,
                            lpLBItem->rcItem.left,
                            lpLBItem->rcItem.top,
                            szTemp, lstrlen(szTemp));
                } else {

                    lpmydta = (LPMYDTA)lpLBItem->itemData;
                    wViewFlags = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);

                    if (wViewFlags & VIEW_EVERYTHING) {

                        // if any of the wViewFlags bits set, we are in slow mode

                        CreateLBLine(wViewFlags, lpmydta, szTemp);
                        DrawItem(lpLBItem, szTemp, lpmydta->my_dwAttrs, (HWND)GetFocus()==lpLBItem->hwndItem,
                                 (WORD *)GetWindowLongPtr(hWnd, GWLP_TABARRAY));
                    } else
                        DrawItemFast(hWnd, lpLBItem, lpmydta,
                                     (HWND)GetFocus()==lpLBItem->hwndItem);
                }
            }
#undef lpLBItem
            break;

        case WM_DROPOBJECT:
            MSG("DirWndProc", "WM_DROPOBJECT");
            {
                WORD      ret;
                LPSTR      pFrom;
                DWORD     dwAttrib = 0;       // init this to not a dir
                WORD      iSelSink;

#define lpds  ((LPDROPSTRUCT)lParam)

                // Do nothing - but remove selection rectangle
                DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);
                return(TRUE);

                /* WM_DROPOBJECT is sent to a sink when the user releases an
                 * acceptable object over it
                 *
                 *    wParam: TRUE if over the non-client area, FALSE if over the
                 *            client area.
                 *    lParam: LPDROPSTRUCT
                 */

                // this is the listbox index of the destination
                iSelSink = LOWORD(lpds->dwControlData);

                /* Are we dropping onto ourselves? (i.e. a selected item in the
                 * source listbox OR an unused area of the source listbox)  If
                 * so, don't do anything. */

                if (hWnd == lpds->hwndSource) {
                    if ((iSelSink == 0xFFFF) || SendMessage(hwndLB, LB_GETSEL, iSelSink, 0L))
                        return TRUE;
                }

                // set the destination, assume move/copy case below (c:\foo\)
                SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);

                // Are we dropping on a unused portion of some listbox?
                if (iSelSink == 0xFFFF)
                    goto NormalMoveCopy;

                // check for drop on a directory
                SendMessage(hwndLB, LB_GETTEXT, iSelSink, (LPARAM)&lpmydta);
                lstrcpy(szSourceFile, lpmydta->my_cFileName);
                dwAttrib = lpmydta->my_dwAttrs;

                if (dwAttrib & ATTR_DIR) {
                    if (dwAttrib & ATTR_PARENT) {      // special case the parent
                        StripBackslash(szTemp);
                        StripFilespec(szTemp);
                    } else {
                        lstrcat(szTemp, szSourceFile);
                    }
                    goto DirMoveCopy;
                }

                // dropping on a program?

                if (!IsProgramFile(szSourceFile))
                    goto NormalMoveCopy;              // no, normal stuff

                // directory drop on a file? this is a NOP

                if (lpds->wFmt == DOF_DIRECTORY) {
                    DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);
                    break;
                }

                // We're dropping a file onto a program.
                // Exec the program using the source file as the parameter.

                // set the directory to that of the program to exec

                SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);
                StripBackslash(szTemp);
                FixAnsiPathForDos(szTemp);
                SheChangeDir(szTemp);

                // get the selected file

                pSel = (LPSTR)SendMessage(lpds->hwndSource, FS_GETSELECTION, TRUE, 0L);

                if (lstrlen(pSel) > MAXPATHLEN)   // don't blow up below!
                    goto DODone;

                if (bConfirmMouse) {

                    LoadString(hAppInstance, IDS_MOUSECONFIRM, szTitle, sizeof(szTitle));
                    LoadString(hAppInstance, IDS_EXECMOUSECONFIRM, szTemp, sizeof(szTemp));

                    wsprintf(szMessage, szTemp, (LPSTR)szSourceFile, (LPSTR)pSel);
                    if (MessageBox(hwndFrame, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
                        goto DODone;
                }


                // create an absolute path to the argument (search window alaready
                // is absolute)

                if (lpds->hwndSource == hwndSearch) {
                    szTemp[0] = 0L;
                } else {
                    SendMessage(lpds->hwndSource, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);
                }

                lstrcat(szTemp, pSel);        // this is the parameter to the exec

                // put a "." extension on if none found
                if (*GetExtension(szTemp) == 0)
                    lstrcat(szTemp, ".");

                FixAnsiPathForDos(szSourceFile);
                FixAnsiPathForDos(szTemp);
                ret = ExecProgram(szSourceFile, szTemp, NULL, FALSE);

                if (ret)
                    MyMessageBox(hwndFrame, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

                DODone:
                DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);
                LocalFree((HANDLE)pSel);
                return TRUE;

                NormalMoveCopy:
                /* Make sure that we don't move into same dir. */
                if (GetParent(hWnd) == (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L))
                    return TRUE;
                DirMoveCopy:

                // the source filename is in the loword
                pFrom = (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch);
                // SetSourceDir(lpds);

                AddBackslash(szTemp);
                lstrcat(szTemp, szStarDotStar);   // put files in this dir

                CheckEscapes(szTemp);
                ret = DMMoveCopyHelper(pFrom, szTemp, fShowSourceBitmaps);

                DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);

                if (ret)
                    return TRUE;

                if (!fShowSourceBitmaps)
                    SendMessage(lpds->hwndSource, WM_FILESYSCHANGE, FSC_REFRESH, 0L);

                // we got dropped on, but if this is a dir we don't need to refresh

                if (!(dwAttrib & ATTR_DIR))
                    SendMessage(hWnd, WM_FILESYSCHANGE, FSC_REFRESH, 0L);

                return TRUE;
            }

#if 0
        case WM_GETTEXT:
            MSG("DirWndProc", "WM_GETTEXT");
            {
                HDC       hDC;
                RECT      rc;

                /* This is where we make sure that the Directory's caption fits
                 * inside the caption bar.
                 */

                /* Get the full path name. */
                DefWindowProc(hWnd, wMsg, wParam, lParam);

                GetClientRect(hWnd, (LPRECT)&rc);
                hDC = GetDC(hWnd);
                CompactPath(hDC, (LPSTR)lParam, rc.right-rc.left-(dxText * 6));
                ReleaseDC(hWnd, hDC);

                return((LONG)lstrlen((LPSTR)lParam)); /* Don't call DefWindowProc()! */
            }
#endif

        case WM_LBTRACKPOINT:
            MSG("DirWndProc", "WM_LBTRACKPOINT");
            return DSTrackPoint(hWnd, hwndLB, wParam, lParam, FALSE);

        case WM_MEASUREITEM:
            MSG("DirWndProc", "WM_MEASUREITEM");
#define pLBMItem ((LPMEASUREITEMSTRUCT)lParam)

            pLBMItem->itemHeight = dyFileName;    // the same as in SetLBFont()
            break;

        case WM_QUERYDROPOBJECT:
            MSG("DirWndProc", "WM_QUERYDROPOBJECT");

            // lParam LPDROPSTRUCT
            //
            // return values:
            //    0       don't accept (use ghost buster)
            //    1       accept, use cursor from DragObject()
            //    hCursor accept, change to this cursor
            //

            /* Ensure that we are dropping on the client area of the listbox. */
#define lpds ((LPDROPSTRUCT)lParam)

            /* Ensure that we can accept the format. */
            switch (lpds->wFmt) {
                case DOF_EXECUTABLE:
                case DOF_DIRECTORY:
                case DOF_DOCUMENT:
                case DOF_MULTIPLE:
                    if (lpds->hwndSink == hWnd)
                        lpds->dwControlData = (DWORD)-1L;

                    return (INT_PTR)GetMoveCopyCursor();
            }
            return FALSE;

        case WM_SETFOCUS:

            // Fall through

        case WM_LBUTTONDOWN:
            MSG("DirWndProc", "WM_SETFOCUS/WM_LBUTTONDOWN");
            SetFocus(hwndLB);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                case LBN_DBLCLK:
                    MSG("DirWndProc", "LBN_DBLCLK");
                    /* Double-click... Open the blasted thing. */
                    SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_OPEN, 0, 0));
                    break;

                case LBN_SELCHANGE:
                    MSG("DirWndProc", "LBN_SELCHANGE");
                    for (i = 0; i < iNumExtensions; i++) {
                        (extensions[i].ExtProc)(hwndFrame, FMEVENT_SELCHANGE, 0L);
                    }
                    UpdateStatus(GetParent(hWnd));
                    break;

                case LBN_SETFOCUS:
                    MSG("DirWndProc", "LBN_SETFOCUS");

                    // Make sure there are files in this window.  If not, set
                    // the focus to the tree or drives window.  Note:  This
                    // message was caused by a mouse click and not an
                    // accelerator, because these were handled in the window
                    // routine that was losing the focus.
                    if (SetDirFocus(hWnd)) {
                        SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)GET_WM_COMMAND_HWND(wParam, lParam));
                        UpdateSelection(GET_WM_COMMAND_HWND(wParam, lParam));
                    }
                    break;

                case LBN_KILLFOCUS:
                    MSG("DirWndProc", "LBN_KILLFOCUS");
                    SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, 0L);
                    UpdateSelection(GET_WM_COMMAND_HWND(wParam, lParam));
                    SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)GET_WM_COMMAND_HWND(wParam, lParam));
                    break;
            }
            break;

        case WM_VKEYTOITEM:
            MSG("DirWndProc", "WM_VKEYTOITEM");
            switch (GET_WM_VKEYTOITEM_ITEM(wParam, lParam)) {
                case VK_ESCAPE:
                    bCancelTree = TRUE;
                    return -2L;

                case 0xBF:        /* Ctrl-/ */
                    SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_SELALL, 0, 0));
                    return -2;

                case 0xDC:        /* Ctrl-\ */
                    SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_DESELALL, 0, 0));
                    return -2;

                case VK_F6:       // like excel
                case VK_TAB:
                    {
                        HWND hwndTree, hwndDrives;

                        GetTreeWindows(GetParent(hWnd), &hwndTree, NULL, &hwndDrives);

                        if (GetKeyState(VK_SHIFT) < 0)
                            SetFocus(hwndTree ? hwndTree : hwndDrives);
                        else
                            SetFocus(hwndDrives);
                        break;
                    }

                case VK_BACK:
                    SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);

                    // are we already at the root?
                    if (lstrlen(szTemp) <= 3)
                        return -1;

                    StripBackslash(szTemp);
                    StripFilespec(szTemp);

                    CreateDirWindow(szTemp, TRUE, GetParent(hWnd));
                    return -2;

                default:
                    {
                        HWND hwndDrives;

                        // check for Ctrl-[DRIVE LETTER] and pass on to drives
                        // window
                        if ((GetKeyState(VK_CONTROL) < 0) && (hwndDrives = HasDrivesWindow(GetParent(hWnd)))) {
                            return SendMessage(hwndDrives, wMsg, wParam, lParam);
                        }
                        break;
                    }
            }
            return -1;

        case WM_SIZE:
            MSG("DirWndProc", "WM_SIZE");
            if (!IsIconic(GetParent(hWnd))) {
                INT iMax;

                MoveWindow(hwndLB, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);


                iMax = (INT)SendMessage(hwndLB, LB_GETCARETINDEX, 0, 0L);
                if (iMax >= 0) // scroll item into view
                    /* SETCARETINDEX will scroll item into view */
                    SendMessage(hwndLB, LB_SETCARETINDEX, iMax, 0L);
                //MakeItemVisible(iMax, hwndLB);

            }
            break;

        default:
            DEFMSG("DirWndProc", (WORD)wMsg);
            return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}



VOID
SortDirList(
           HWND hWnd,
           LPMYDTA lpmydta,
           WORD count,
           LPMYDTA *lplpmydta
           )
{
    INT i, j;
    WORD wSort;
    INT iMax, iMin, iMid;

    wSort = (WORD)GetWindowLong(GetParent(GetParent(hWnd)), GWL_SORT);
    for (i = 0; i < (INT)count; i++) {
        // advance to next
        lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);
        if (i == 0) {
            lplpmydta[i] = lpmydta;
        } else {

            // do a binary insert

            iMin = 0;
            iMax = i-1;       // last index

            do {
                iMid = (iMax + iMin) / 2;
                if (CompareDTA(lpmydta, lplpmydta[iMid], wSort) > 0)
                    iMin = iMid + 1;
                else
                    iMax = iMid - 1;

            } while (iMax > iMin);

            if (iMax < 0)
                iMax = 0;

            if (CompareDTA(lpmydta, lplpmydta[iMax], wSort) > 0)
                iMax++;         // insert after this one
            if (i != iMax) {
                for (j = i; j > iMax; j--)
                    lplpmydta[j] = lplpmydta[j-1];
            }
            lplpmydta[iMax] = lpmydta;
        }

    }
}


BOOL
SetDirFocus(
           HWND hwndDir
           )
/*
    Set the focus to whoever deserves it if not the directory window.
    Return whether focus needs to be set to directory window.
*/
{
    DWORD dwTemp;
    HWND hwndLB = GetDlgItem(hwndDir, IDCW_LISTBOX);

    SendMessage (hwndLB,LB_GETTEXT,0,(LPARAM) &dwTemp);

    if (!dwTemp) {
        HWND hwndFocus,hwndTree,hwndDrives,hwndParent = GetParent(hwndDir);

        GetTreeWindows(hwndParent,&hwndTree,NULL,&hwndDrives);

        if ((hwndFocus = GetTreeFocus(hwndParent)) == hwndDir)
            SetFocus(hwndTree ? hwndTree : hwndDrives);
        else
            SetFocus(hwndFocus);

        return FALSE;
    } else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdlgs.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDLGS.C -                                                              */
/*                                                                          */
/*      Windows File System Dialog procedures                               */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "wfcopy.h"
#include "commdlg.h"
#include "dlgs.h"

typedef BOOL (APIENTRY *LPFNFONTPROC)(HWND, UINT, DWORD, LONG);

VOID
APIENTRY
SaveWindows(
            HWND hwndMain
            )
{
    CHAR szPath[MAXPATHLEN];
    CHAR buf2[MAXPATHLEN + 6*12];
    CHAR key[10];
    INT dir_num;
    UINT sw;
    HWND hwnd;
    BOOL bCounting;
    POINT ptIcon;
    RECT rcWindow;
    LONG view, sort, attribs;

    // save main window position

    sw = GetInternalWindowPos(hwndMain, &rcWindow, &ptIcon);

    wsprintf(buf2, "%d,%d,%d,%d, , ,%d", rcWindow.left, rcWindow.top,
             rcWindow.right - rcWindow.left, rcWindow.bottom - rcWindow.top, sw);

    WritePrivateProfileString(szSettings, szWindow, buf2, szTheINIFile);

    // write out dir window strings in reverse order
    // so that when we read them back in we get the same Z order

    bCounting = TRUE;
    dir_num = 0;

    DO_AGAIN:

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {
        HWND ht = HasTreeWindow(hwnd);
        INT nReadLevel = ht? GetWindowLong(ht, GWL_READLEVEL) : 0;

        // don't save MDI icon title windows or search windows,
        // or any dir window which is currently recursing

        if ((GetWindow(hwnd, GW_OWNER) == NULL) &&
            GetWindowLong(hwnd, GWL_TYPE) != TYPE_SEARCH)
        //nReadLevel == 0)
        {
            if (bCounting) {
                dir_num++;
                continue;
            }

            sw = GetInternalWindowPos(hwnd, &rcWindow, &ptIcon);
            view = GetWindowLong(hwnd, GWL_VIEW);
            sort = GetWindowLong(hwnd, GWL_SORT);
            attribs = GetWindowLong(hwnd, GWL_ATTRIBS);

            GetMDIWindowText(hwnd, szPath, sizeof(szPath));

            wsprintf(key, szDirKeyFormat, dir_num--);

            // format:
            //   x_win, y_win,
            //   x_win, y_win,
            //   x_icon, y_icon,
            //   show_window, view, sort, attribs, split, directory

            wsprintf(buf2, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%s",
                     rcWindow.left, rcWindow.top,
                     rcWindow.right, rcWindow.bottom,
                     ptIcon.x, ptIcon.y,
                     sw, view, sort, attribs,
                     GetSplit(hwnd),
                     (LPSTR)szPath);

            // the dir is an ANSI string (?)

            WritePrivateProfileString(szSettings, key, buf2, szTheINIFile);
        }
    }

    if (bCounting) {
        bCounting = FALSE;

        // erase the last dir window so that if they save with
        // fewer dirs open we don't pull in old open windows

        wsprintf(key, szDirKeyFormat, dir_num + 1);
        WritePrivateProfileString(szSettings, key, NULL, szTheINIFile);

        goto DO_AGAIN;
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  OtherDlgProc() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
OtherDlgProc(
             register HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    LONG          wView;
    register HWND hwndActive;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    switch (wMsg) {
        case WM_INITDIALOG:

            wView = GetWindowLong(hwndActive, GWL_VIEW);
            CheckDlgButton(hDlg, IDD_SIZE,  wView & VIEW_SIZE);
            CheckDlgButton(hDlg, IDD_DATE,  wView & VIEW_DATE);
            CheckDlgButton(hDlg, IDD_TIME,  wView & VIEW_TIME);
            CheckDlgButton(hDlg, IDD_FLAGS, wView & VIEW_FLAGS);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    {
                        HWND hwnd;

                        wView = GetWindowLong(hwndActive, GWL_VIEW) & VIEW_PLUSES;

                        if (IsDlgButtonChecked(hDlg, IDD_SIZE))
                            wView |= VIEW_SIZE;
                        if (IsDlgButtonChecked(hDlg, IDD_DATE))
                            wView |= VIEW_DATE;
                        if (IsDlgButtonChecked(hDlg, IDD_TIME))
                            wView |= VIEW_TIME;
                        if (IsDlgButtonChecked(hDlg, IDD_FLAGS))
                            wView |= VIEW_FLAGS;

                        EndDialog(hDlg, TRUE);

                        if (hwnd = HasDirWindow(hwndActive))
                            SendMessage(hwnd, FS_CHANGEDISPLAY, CD_VIEW, (DWORD)wView);
                        else if (hwndActive == hwndSearch) {
                            SetWindowLong(hwndActive, GWL_VIEW, wView);
                            InvalidateRect(hwndActive, NULL, TRUE);
                        }

                        break;
                    }

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IncludeDlgProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
IncludeDlgProc(
               HWND hDlg,
               UINT wMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    DWORD dwAttribs;
    HWND hwndActive;
    CHAR szTemp[MAXPATHLEN];
    CHAR szInclude[MAXFILENAMELEN];
    HWND hwndDir;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    switch (wMsg) {
        case WM_INITDIALOG:

            SendMessage(hwndActive, FS_GETFILESPEC, sizeof(szTemp), (LPARAM)szTemp);
            SetDlgItemText(hDlg, IDD_NAME, szTemp);
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, MAXFILENAMELEN-1, 0L);

            dwAttribs = (DWORD)GetWindowLong(hwndActive, GWL_ATTRIBS);

            CheckDlgButton(hDlg, IDD_DIR,        dwAttribs & ATTR_DIR);
            CheckDlgButton(hDlg, IDD_PROGRAMS,   dwAttribs & ATTR_PROGRAMS);
            CheckDlgButton(hDlg, IDD_DOCS,       dwAttribs & ATTR_DOCS);
            CheckDlgButton(hDlg, IDD_OTHER,      dwAttribs & ATTR_OTHER);
            CheckDlgButton(hDlg, IDD_SHOWHIDDEN, dwAttribs & ATTR_HIDDEN);

            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    GetDlgItemText(hDlg, IDD_NAME, szInclude, sizeof(szInclude));

                    if (szInclude[0] == 0L)
                        lstrcpy(szInclude, szStarDotStar);

                    dwAttribs = 0;
                    if (IsDlgButtonChecked(hDlg, IDD_DIR))
                        dwAttribs |= ATTR_DIR;
                    if (IsDlgButtonChecked(hDlg, IDD_PROGRAMS))
                        dwAttribs |= ATTR_PROGRAMS;
                    if (IsDlgButtonChecked(hDlg, IDD_DOCS))
                        dwAttribs |= ATTR_DOCS;
                    if (IsDlgButtonChecked(hDlg, IDD_OTHER))
                        dwAttribs |= ATTR_OTHER;
                    if (IsDlgButtonChecked(hDlg, IDD_SHOWHIDDEN))
                        dwAttribs |= ATTR_HS;

                    if (!dwAttribs)
                        dwAttribs = ATTR_EVERYTHING;

                    EndDialog(hDlg, TRUE);        // here to avoid exces repaints

                    // we need to update the tree if they changed the system/hidden
                    // flags.  major bummer...  FIX31

                    if (hwndDir = HasDirWindow(hwndActive)) {
                        SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);
                        lstrcat(szTemp, szInclude);
                        SetWindowText(hwndActive, szTemp);
                        SetWindowLong(hwndActive, GWL_ATTRIBS, dwAttribs);
                        SendMessage(hwndDir, FS_CHANGEDISPLAY, CD_PATH, 0L);
                    }

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


INT_PTR
APIENTRY
SelectDlgProc(
              HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam)
{
    HWND hwndActive, hwnd;
    CHAR szList[128];
    CHAR szSpec[MAXFILENAMELEN];
    LPSTR p;

    switch (wMsg) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szList)-1, 0L);
            SetDlgItemText(hDlg, IDD_NAME, szStarDotStar);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:      // select
                case IDYES:     // unselect

                    // change "Cancel" to "Close"

                    LoadString(hAppInstance, IDS_CLOSE, szSpec, sizeof(szSpec));
                    SetDlgItemText(hDlg, IDCANCEL, szSpec);

                    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

                    if (!hwndActive)
                        break;

                    GetDlgItemText(hDlg, IDD_NAME, szList, sizeof(szList));

                    if (hwndActive == hwndSearch)
                        hwnd = hwndSearch;
                    else
                        hwnd = HasDirWindow(hwndActive);

                    if (hwnd) {

                        p = szList;

                        while (p = GetNextFile(p, szSpec, sizeof(szSpec)))
                            SendMessage(hwnd, FS_SETSELECTION, (BOOL)(GET_WM_COMMAND_ID(wParam, lParam) == IDOK), (LPARAM)szSpec);
                    }

                    UpdateStatus(hwndActive);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


UINT_PTR
FontHookProc(
             HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            CheckDlgButton(hDlg, chx3, wTextAttribs & TA_LOWERCASE);
            break;

        case WM_COMMAND:
            switch (wParam) {
                case pshHelp:
                    SendMessage(hwndFrame, wHelpMessage, 0, 0L);
                    break;

                case IDOK:
                    if (IsDlgButtonChecked(hDlg, chx3))
                        wTextAttribs |= TA_LOWERCASE;
                    else
                        wTextAttribs &= ~TA_LOWERCASE;
                    break;
            }
    }
    return FALSE;
}

#define abs(x) ((x < 0) ? -x : x)

VOID
APIENTRY
NewFont()
{
    HFONT hOldFont;
    HANDLE hOld;
    HWND hwnd, hwndT;
    HDC hdc;
    RECT rc;
    LOGFONT lf;
    CHOOSEFONT cf;
    CHAR szBuf[10];
    INT res;
    WORD iOld,iNew;

#define MAX_PT_SIZE 36

    GetObject(hFont, sizeof(lf), (LPSTR)(LPLOGFONT)&lf);
    iOld = (WORD)abs(lf.lfHeight);

    cf.lStructSize    = sizeof(cf);
    cf.hwndOwner      = hwndFrame;
    cf.lpLogFont      = &lf;
    cf.hInstance      = hAppInstance;
    cf.lpTemplateName = MAKEINTRESOURCE(FONTDLG);
    cf.lpfnHook       = FontHookProc;
    cf.nSizeMin       = 4;
    cf.nSizeMax       = 36;
    cf.Flags          = CF_SCREENFONTS | CF_ANSIONLY | CF_SHOWHELP |
                        CF_ENABLEHOOK | CF_ENABLETEMPLATE |
                        CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;

    res = ChooseFont(&cf);

    if (!res)
        return;

    wsprintf(szBuf, "%d", cf.iPointSize / 10);
    iNew = (WORD)abs(lf.lfHeight);

    // Set wTextAttribs BOLD and ITALIC flags

    if (lf.lfWeight == 700)
        wTextAttribs |= TA_BOLD;
    else
        wTextAttribs &= ~TA_BOLD;
    if (lf.lfItalic != 0)
        wTextAttribs |= TA_ITALIC;
    else
        wTextAttribs &= ~TA_ITALIC;

    WritePrivateProfileString(szSettings, szFace, lf.lfFaceName, szTheINIFile);
    WritePrivateProfileString(szSettings, szSize, szBuf, szTheINIFile);
    WritePrivateProfileBool(szLowerCase, wTextAttribs);

    hOldFont = hFont;

    hFont = CreateFontIndirect(&lf);

    if (!hFont) {
        DeleteObject(hOldFont);
        return;
    }

    // recalc all the metrics for the new font

    hdc = GetDC(NULL);
    hOld = SelectObject(hdc, hFont);
    GetTextStuff(hdc);
    if (hOld)
        SelectObject(hdc, hOld);
    ReleaseDC(NULL, hdc);

    // now update all listboxes that are using the old
    // font with the new font

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd;
        hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

        if (GetWindow(hwnd, GW_OWNER))
            continue;

        if ((INT)GetWindowLong(hwnd, GWL_TYPE) == TYPE_SEARCH) {
            SendMessage((HWND)GetDlgItem(hwnd, IDCW_LISTBOX), WM_SETFONT, (WPARAM)hFont, 0L);
            SendMessage((HWND)GetDlgItem(hwnd, IDCW_LISTBOX), LB_SETITEMHEIGHT, 0, (LONG)dyFileName);
            // we should really update the case of the search
            // window here.  but this is a rare case...
        } else {

            // resize the drives, tree, dir

            if (hwndT = HasDrivesWindow(hwnd)) {
                GetClientRect(hwnd, &rc);
                SendMessage(hwnd, WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));
            }

            if (hwndT = HasDirWindow(hwnd))
                SetLBFont(hwndT, GetDlgItem(hwndT, IDCW_LISTBOX), hFont);

            if (hwndT = HasTreeWindow(hwnd)) {

                // the tree list box

                hwndT = GetDlgItem(hwndT, IDCW_TREELISTBOX);

                /*
                    Kludge alert: xTreeMax is a single var representing the width of
                    all tree windows.  It always grows, never shrinks (like the budget
                    deficit).
                */
                xTreeMax = (WORD)((xTreeMax * iNew) / iOld);
                SendMessage(hwndT, LB_SETHORIZONTALEXTENT, xTreeMax, 0L);
                SendMessage(hwndT, WM_SETFONT, (WPARAM)hFont, 0L);
                SendMessage(hwndT, LB_SETITEMHEIGHT, 0, (LONG)dyFileName);
            }
        }

        // now repaint after all the font changes
        InvalidateRect(hwnd, NULL, TRUE);
    }
    DeleteObject(hOldFont); // done with this now, delete it
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ConfirmDlgProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
ConfirmDlgProc(
               HWND hDlg,
               UINT wMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    switch (wMsg) {
        case WM_INITDIALOG:
            CheckDlgButton(hDlg, IDD_DELETE,  bConfirmDelete);
            CheckDlgButton(hDlg, IDD_SUBDEL,  bConfirmSubDel);
            CheckDlgButton(hDlg, IDD_REPLACE, bConfirmReplace);
            CheckDlgButton(hDlg, IDD_MOUSE,   bConfirmMouse);
            CheckDlgButton(hDlg, IDD_CONFIG,  bConfirmFormat);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    bConfirmDelete  = IsDlgButtonChecked(hDlg, IDD_DELETE);
                    bConfirmSubDel  = IsDlgButtonChecked(hDlg, IDD_SUBDEL);
                    bConfirmReplace = IsDlgButtonChecked(hDlg, IDD_REPLACE);
                    bConfirmMouse   = IsDlgButtonChecked(hDlg, IDD_MOUSE);
                    bConfirmFormat  = IsDlgButtonChecked(hDlg, IDD_CONFIG);

                    WritePrivateProfileBool(szConfirmDelete,  bConfirmDelete);
                    WritePrivateProfileBool(szConfirmSubDel,  bConfirmSubDel);
                    WritePrivateProfileBool(szConfirmReplace, bConfirmReplace);
                    WritePrivateProfileBool(szConfirmMouse,   bConfirmMouse);
                    WritePrivateProfileBool(szConfirmFormat,  bConfirmFormat);

                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdcopy.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDCOPY.C -                                                             */
/*                                                                          */
/*      File Manager Diskette Copying Routines                              */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"

LONG  APIENTRY   LongPtrAdd(LPSTR, DWORD);

PBPB GetBootBPB(INT nSrceDrive);
PBPB GetBPB(INT nDrive, PDevPB pDevicePB);
BOOL CheckBPBCompatibility(PBPB pSrceBPB, int nSrcDriveType, PBPB pDestBPB, int nDestDriveType);

BOOL ModifyDeviceParams(
                                   INT nDrive,
                                   PDevPB pdpbParams,
                                   HANDLE *phSaveParams,
                                   PBPB pDriveBPB,
                                   PBPB pMediaBPB);

BOOL FormatAllTracks(
                                PDISKINFO pDisketteInfo,
                                WORD wStartCylinder,
                                WORD wStartHead,
                                LPSTR lpDiskBuffer);

BOOL AllocDiskCopyBuffers(PDISKINFO pDisketteInfo);
VOID FreeBuffers(VOID);
VOID GetDisketteInfo(PDISKINFO pDisketteInfo, PBPB pBPB);
VOID DCopyMessageBox(HWND hwnd, WORD idString, WORD wFlags);
VOID PromptDisketteChange(HWND hwnd, BOOL bWrite);
INT ReadWriteMaxPossible(BOOL bWrite, WORD wStartCylinder, PDISKINFO pDisketteInfo);
INT ReadWrite(BOOL bWrite, WORD wStartCylinder, PDISKINFO pDisketteInfo);
BOOL RestoreDPB(INT nDisk, HANDLE hSavedParams);
INT ReadWriteCylinder(BOOL bWrite, WORD wCylinder, PDISKINFO pDisketteInfo);


/* The following structure is the Parameter block for the read-write
 * operations using the IOCTL calls in DOS
 */
struct RW_PARMBLOCK {
    BYTE        bSplFn;
    WORD        wHead;
    WORD        wCylinder;
    WORD        wStSector;
    WORD        wCount;
    LPSTR       lpBuffer;
};

/* Global Variables */
BOOL        bFormatDone;
BOOL        bSingleDrive            = TRUE;
WORD        wCompletedCylinders     = 0;
DWORD       dwDisketteBufferSize;
LPSTR       lpDosMemory;
LPSTR       lpFormatBuffer;
LPSTR       lpReadWritePtr;
LPSTR       hpDisketteBuffer;
HANDLE      hFormatBuffer;
HANDLE      hDosMemory;
HANDLE      hDisketteBuffer;
PDevPB      pTrackLayout;           /* DevPB with the track layout */
BOOTSEC     BootSec;

/* External Variables */
extern BPB  bpbList[];



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetBootBPB() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This reads the boot sector of a floppy and returns a ptr to
 * the BIOS PARAMETER BLOCK in the Boot sector.
 */

PBPB
GetBootBPB(
          INT nSrceDrive
          )
{
    INT       rc;

    /* Make sure that the source diskette's boot sector is valid. */
    rc = GenericReadWriteSector((LPSTR)&BootSec, INT13_READ, (WORD)nSrceDrive, 0, 0, 1);

    if ((rc < 0) || ((BootSec.jump[0] != 0xE9) && (BootSec.jump[0] != 0xEB)))
        return (PBPB)NULL;

    return (PBPB)&(BootSec.BPB);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetBPB() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Gets get the BPB of the Physical Drive.
 *
 * This uses the IOCTL calls if DOS ver >= 3.2; Otherwise it uses the
 * BIOS calls to find out the drive type and picks us the BPB from a table.
 * It also returns the DeviceParameterBlock thro params if DOS >= 3.2.
 * Sets devType field of DeviceParameterBlock in any case (11.12.91) v-dougk
 */

PBPB
GetBPB(
      INT nDrive,
      PDevPB pDevicePB
      )
{
    INT       iDisketteType;
    PBPB      pBPB = NULL;

    /* Check the DOS version */
    if (wDOSversion >= DOS_320) {
        /* All fields in pDevicePB must be initialized to zero. */
        memset(pDevicePB, 0, sizeof(DevPB));

        /* Spl Function field must be set to get parameters */
        pDevicePB->SplFunctions = 0;
        pBPB = &(pDevicePB->BPB);
    } else {
        /* Find out the Drive type using the BIOS. */
        if ((iDisketteType = GetDriveCapacity((WORD)nDrive)) == 0)
            goto GBPB_Error;

        /* Lookup this drive's default BPB. */
        pBPB = &bpbList[iDisketteType+2];

        switch (iDisketteType) {
            case 1:
                pDevicePB->devType = 0; // 360K
                break;
            case 2:
                pDevicePB->devType = 1; // 1.2M
                break;
        }
    }

    GBPB_Error:
    return (pBPB);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CheckBPBCompatibility() -                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Checks whether the two BPB are compatible for the purpose of performing
 * the diskcopy operation.
 */

BOOL
CheckBPBCompatibility(
                     PBPB pSrceBPB,
                     int nSrcDriveType,
                     PBPB pDestBPB,
                     int nDestDriveType
                     )
{
    /* Let us compare the media byte */
    if (pSrceBPB->bMedia == 0xF9) {
        /* If the source and dest have the same number of sectors,
         * or if srce is 720KB and Dest is 1.44MB floppy drive,
         * thnigs are kosher.
         */
        if ((pSrceBPB->cSec == pDestBPB->cSec) ||
            ((pSrceBPB->secPerTrack == 9) && (pDestBPB -> bMedia == 0xF0)))
            return (TRUE);
    } else {
        /* If they have the same media byte */
        if ((pSrceBPB->bMedia == pDestBPB->bMedia) &&
            (pSrceBPB->cbSec  == pDestBPB->cbSec) && // bytes per sector are the same
            (pSrceBPB->cSec   == pDestBPB->cSec))    // total sectors on drive are the same
            return (TRUE); /* They are compatible */
        else if
            /* srce is 160KB and dest is 320KB drive */
             (((pSrceBPB->bMedia == MEDIA_160) && (pDestBPB->bMedia == MEDIA_320)) ||
              /* or if srce is 180KB and dest is 360KB drive */
              ((pSrceBPB->bMedia == MEDIA_180) && (pDestBPB->bMedia == MEDIA_360)) ||
              /* or if srce is 1.44MB and dest is 2.88MB drive */
              ((pSrceBPB->bMedia == MEDIA_1440) && (pDestBPB->bMedia == MEDIA_2880)
               && ((nSrcDriveType == 7) || (nSrcDriveType == 9))
               &&  (nDestDriveType == 9)) ||
              /* or if srce is 360KB and dest is 1.2MB drive */
              ((pSrceBPB->bMedia == MEDIA_360) && (pDestBPB->secPerTrack == 15)))
            return (TRUE); /* They are compatible */
    }

    /* All other combinations are currently incompatible. */
    return (FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ModifyDeviceParams() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Saves a copy of the drive parameters block and
 * Checks if the BPB of Drive and BPB of disk are different and if
 * so, modifies the drive parameter block accordingly.
 */

BOOL
ModifyDeviceParams(
                  INT nDrive,
                  PDevPB pdpbParams,
                  HANDLE *phSaveParams,
                  PBPB pDriveBPB,
                  PBPB pMediaBPB)
{
    INT       iDriveCode;
    HANDLE    hNewDPB;
    PDevPB    pNewDPB;

    if (!(*phSaveParams = BuildDevPB(pdpbParams)))
        return FALSE;

    /* Check if the Disk and Drive have the same parameters */
    if (pMediaBPB->bMedia != pDriveBPB->bMedia) {
        /* They are not equal; So, it must be a 360KB floppy in a 1.2MB drive
         * or a 720KB floppy in a 1.44MB drive kind of situation!.
         * So, modify the DriveParameterBlock's BPB.
         */
        *(PBPB)&(pdpbParams->BPB) = *pMediaBPB;
    }

    if (wDOSversion >= DOS_320) {
        /* Build a DPB with TrackLayout */
        if (!(hNewDPB = BuildDevPB(pdpbParams)))
            goto MDP_Error;

        pNewDPB = (PDevPB)LocalLock(hNewDPB);

        pNewDPB->SplFunctions = 4;        /* To Set parameters */

        /* Check if this is a 360KB floppy; And if it is a 1.2MB drive, the
         * number of cylinders and mediatype field are wrong; So, we modify
         * these fields here anyway;
         * This is required to format a 360KB floppy on a NCR PC916 machine;
         * Fix for Bug #6894 --01-10-90-- SANKAR
         */
        if (pMediaBPB->bMedia == MEDIA_360) {
            pNewDPB->NumCyls = 40;
            pNewDPB->bMediaType = 1;
        }

        LocalUnlock(hNewDPB);
        LocalFree(hNewDPB);
    } else {
        iDriveCode = 0;
        switch (pMediaBPB->bMedia) {
            case MEDIA_360:
            case MEDIA_320:
                if ((pDriveBPB->bMedia == MEDIA_360) ||
                    (pDriveBPB->bMedia == MEDIA_320))
                    iDriveCode = 1;  /* Must be 360/320KB in 360KB drive */
                else
                    iDriveCode = 2;  /* Must be 360/320Kb in 1.2MB drive */
                break;

            case MEDIA_1200:
                iDriveCode = 3;  /* Must be 1.2MB in 1.2MB drive */
                break;
        }
        if (iDriveCode)
            SetDASD((WORD)nDrive, (BYTE)iDriveCode);
    }
    return (TRUE);

    /* Error handling */
    MDP_Error:
    if (hNewDPB)
        LocalFree(hNewDPB);
    if (*phSaveParams) {
        LocalFree(*phSaveParams);
        *phSaveParams = NULL;
    }
    return (FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FormatAllTracks() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
FormatAllTracks(
               PDISKINFO pDisketteInfo,
               WORD wStartCylinder,
               WORD wStartHead,
               LPSTR lpDiskBuffer)
{
    INT   iErrCode;
    BOOL  bRetValue = TRUE;
    WORD  wTotalCylinders;
    WORD  wSecPerTrack;
    WORD  wHeads;
    WORD  wDrive;

    LoadString(hAppInstance, IDS_FORMATTINGDEST, szMessage, 128);
    SendDlgItemMessage(hdlgProgress, IDD_PROGRESS, WM_SETTEXT, 0, (LPARAM)szMessage);

    bFormatDone = TRUE;
    wDrive = pDisketteInfo->wDrive;

    if (wDOSversion >= DOS_320) {
        pTrackLayout->SplFunctions = 5;
    } else {
        if ((pTrackLayout->BPB.bMedia == 0xF9) &&      /* high density */
            (pTrackLayout->BPB.secPerTrack == 15))     /* 1.2 Meg Drive */
            SetDASD(wDrive, 3);         /* 1.2 MB floppy in 1.2MB drive */
    }

    wTotalCylinders = pDisketteInfo->wLastCylinder + 1;
    wSecPerTrack = pDisketteInfo->wSectorsPerTrack;
    wHeads = pDisketteInfo->wHeads;

    /* Format tracks one by one, checking if the user has "Aborted"
     * after each track is formatted; DlgProgreeProc() will set the global
     * bUserAbort, if the user has aborted;
     */
    while (wStartCylinder < wTotalCylinders) {
        /* Has the user aborted? */
        if (WFQueryAbort()) {
            bRetValue = FALSE;
            break;
        }

        /* If no message is pending, go ahead and format one track */
        if ((iErrCode = GenericFormatTrack(wDrive, wStartCylinder, wStartHead, wSecPerTrack, lpDiskBuffer))) {
            /* Check if it is a fatal error */
            if (iErrCode == -1) {
                bRetValue = FALSE;
                break;
            }
        }

        if (++wStartHead >= wHeads) {
            wStartHead = 0;
            wStartCylinder++;
        }
    }

    if (wDOSversion >= DOS_320) {
        pTrackLayout->SplFunctions = 4;
    }

    return (bRetValue);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GenericReadWriteSector() -                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Checks the DOS version number; If it is >= 3.2, then IOCTL
 * calls are made to read/write; Else it calls int13 read/write.
 */

INT
APIENTRY
GenericReadWriteSector(
                      LPSTR lpBuffer,
                      WORD wFunction,
                      WORD wDrive,
                      WORD wCylinder,
                      WORD wHead,
                      WORD wCount)
{
    struct RW_PARMBLOCK  RW_ParmBlock;

    /* If the DOS version is >= 3.2, we use DOS IOCTL function calls. */
    if (wDOSversion >= DOS_320) {
        RW_ParmBlock.bSplFn = 0;
        RW_ParmBlock.wHead = wHead;
        RW_ParmBlock.wCylinder = wCylinder;
        RW_ParmBlock.wStSector = 0;
        RW_ParmBlock.wCount = wCount;
        RW_ParmBlock.lpBuffer = lpBuffer;

        return (0);
    } else
        /* Use Int13 function calls. */
        return (MyReadWriteSector(lpBuffer, wFunction, wDrive, wCylinder, wHead, wCount));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AllocDiskCopyBuffers() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
AllocDiskCopyBuffers(
                    PDISKINFO pDisketteInfo
                    )
{
    HANDLE    hMemTemp;

    ENTER("AllocDiskCopyBuffers");

    hFormatBuffer = LocalAlloc(LHND, (LONG)(2*CBSECTORSIZE));
    if (!hFormatBuffer)
        return FALSE;
    lpFormatBuffer = (LPSTR)LocalLock(hFormatBuffer);

    // We will try to reserve 16K for dialog boxes that comeup during diskcopy

    hMemTemp = LocalAlloc(LHND, (16 * 1024));
    if (!hMemTemp)
        goto Failure;

    hDosMemory = (HANDLE)NULL;

    // now, lets try to allocate a buffer for the whole disk, and
    // if that fails try smaller
    // note, standard mode will only give us 1M chuncks

    dwDisketteBufferSize = pDisketteInfo->wCylinderSize * (pDisketteInfo->wLastCylinder + 1);

    // we will try down to 8 cylinders worth, less than that means
    // there will be too much disk swapping so don't bother

    do {
        hDisketteBuffer = LocalAlloc(LHND, dwDisketteBufferSize);

        if (hDisketteBuffer) {
            hpDisketteBuffer = (LPSTR)LocalLock(hDisketteBuffer);
            break;
        } else {
            // reduce request by 4 cylinders.
            dwDisketteBufferSize -= pDisketteInfo->wCylinderSize * 4;
        }

    } while (dwDisketteBufferSize > (DWORD)(8 * pDisketteInfo->wCylinderSize));

    LocalFree(hMemTemp);         // now free this up for user

    if (hDisketteBuffer)
        return TRUE;

    // fall through here to the failure case
    Failure:

    if (lpFormatBuffer) {
        LocalUnlock(hFormatBuffer);
        LocalFree(hFormatBuffer);
    }

    if (hDosMemory)
//      +++GlobalDosFree - NO 32BIT FORM+++(hDosMemory);
        LocalFree(hDosMemory);

    LEAVE("AllocDiskCopyBuffers");
    return FALSE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FreeBuffers() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
FreeBuffers()
{
    if (lpFormatBuffer) {
        LocalUnlock(hFormatBuffer);
        LocalFree(hFormatBuffer);
    }

    if (hDosMemory)
//      +++GlobalDosFree - NO 32BIT FORM+++(hDosMemory);
        LocalFree(hDosMemory);

    if (hpDisketteBuffer) {
        LocalUnlock(hDisketteBuffer);
        LocalFree(hDisketteBuffer);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetDisketteInfo() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetDisketteInfo(
               PDISKINFO pDisketteInfo,
               PBPB pBPB
               )
{
    WORD  secPerTrack;

    secPerTrack = pBPB->secPerTrack;

    /* Fill the DisketteInfo with the info from the default BPB. */
    pDisketteInfo->wCylinderSize    = secPerTrack * pBPB->cbSec * pBPB->cHead;
    pDisketteInfo->wLastCylinder    = (pBPB->cSec / (secPerTrack * pBPB->cHead))-1;
    pDisketteInfo->wHeads           = pBPB->cHead;
    pDisketteInfo->wSectorsPerTrack = secPerTrack;
    pDisketteInfo->wSectorSize      = pBPB->cbSec;

}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DCopyMessageBox() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
DCopyMessageBox(
               HWND hwnd,
               WORD idString,
               WORD wFlags
               )
{
    LoadString(hAppInstance, IDS_COPYDISK, szTitle, sizeof(szTitle));
    LoadString(hAppInstance, idString, szMessage, sizeof(szMessage));

    MessageBox(hwnd, szMessage, szTitle, wFlags);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PromptDisketteChange() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
PromptDisketteChange(
                    HWND hwnd,
                    BOOL bWrite
                    )
{
    WORD      idString;

    if (bWrite)
        idString = IDS_INSERTDEST;
    else
        idString = IDS_INSERTSRC;

    /* These dialogs have to be sysmodal because the DiskCopy progress dialog
     * is now made a SysModal one; The following messagebox will hang if it
     * is NOT sysmodal;
     * A part of the Fix for Bug #10075 --SANKAR-- 03-05-90
     */
    DCopyMessageBox(hwnd, idString, MB_OK | MB_SYSTEMMODAL | MB_ICONINFORMATION);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadWriteCylinder() -                                                   */
// BOOL             bWrite;             TRUE for Write, FALSE for Read
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
ReadWriteCylinder(
                 BOOL bWrite,
                 WORD wCylinder,
                 PDISKINFO pDisketteInfo
                 )
{
    register INT  rc;
    WORD          wHead;
    WORD          wDrive;
    WORD          wSectorCount;
    WORD          wTrackSize;
    LPSTR         lpBuffer;

    wDrive = pDisketteInfo->wDrive;
    wSectorCount = pDisketteInfo->wSectorsPerTrack;
    wTrackSize = (wSectorCount * pDisketteInfo->wSectorSize);

    if (hDosMemory)
        lpBuffer = lpDosMemory;

    /* Perform the operation for all the heads for a given cylinder */
    for (wHead=0; wHead < pDisketteInfo->wHeads; wHead++) {
        if (!hDosMemory)
            lpBuffer = lpReadWritePtr;

        if (bWrite) {
            if (hDosMemory)
                memcpy(lpBuffer, lpReadWritePtr, wTrackSize);

            rc = GenericReadWriteSector((LPSTR)lpBuffer,
                                        INT13_WRITE,
                                        wDrive,
                                        wCylinder,
                                        wHead,
                                        wSectorCount);
            if (rc) {
                /* Format all tracks starting from the given track */
                if (!bFormatDone) {
                    if (!FormatAllTracks(pDisketteInfo, wCylinder, wHead, lpFormatBuffer))
                        return (-1);  /* Failure */
                    rc = GenericReadWriteSector((LPSTR)lpBuffer,
                                                INT13_WRITE,
                                                wDrive,
                                                wCylinder,
                                                wHead,
                                                wSectorCount);
                } else
                    break;
            }
        } else {
            rc = GenericReadWriteSector((LPSTR)lpBuffer,
                                        INT13_READ,
                                        wDrive,
                                        wCylinder,
                                        wHead,
                                        wSectorCount);
            if (hDosMemory)
                memcpy(lpReadWritePtr, lpBuffer, wTrackSize);

            /*** FIX30: What about the DOS 4.0 volume stuff??? ***/
        }

        if (rc)
            return (-1);

        lpReadWritePtr += wTrackSize;
    }
    return (0);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadWriteMaxPossible() -                                                */
// BOOL bWrite  TRUE for Write, FALSE for Read
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This reads or writes as many cylinders as possible into the hpDisketteBuffer.
 * It returns the next cylinder to be read.
 */

INT
ReadWriteMaxPossible(
                    BOOL bWrite,
                    WORD wStartCylinder,
                    PDISKINFO pDisketteInfo
                    )
{
    MSG       msg;
    WORD      wPercentDone;
    DWORD     dwBufferSize;

    dwBufferSize = dwDisketteBufferSize;

    /* We will read a cylinder only if we can read the entire cylinder. */
    while (dwBufferSize >= pDisketteInfo->wCylinderSize) {
        /* Check if any messages are pending */
        if (!PeekMessage((LPMSG)&msg, (HWND)NULL, 0, 0, PM_REMOVE)) {
            /* No message; So, go ahead with read/write */
            if (ReadWriteCylinder(bWrite, wStartCylinder, pDisketteInfo))
                return (-1);

            wStartCylinder++;
            wCompletedCylinders++;

            /* Have we read/written all the cylinders? */
            if (wStartCylinder > pDisketteInfo->wLastCylinder)
                break;

            /* Since each cylinder is counted once during read and once during
             * write, number of cylinders is multiplied by 50 and not 100.
             */
            wPercentDone = (wCompletedCylinders * 50) / (pDisketteInfo->wLastCylinder + 1);
            if (LoadString(hAppInstance, IDS_PERCENTCOMP, szTitle, 32)) {
                wsprintf(szMessage, szTitle, wPercentDone);
                SendDlgItemMessage(hdlgProgress, IDD_PROGRESS, WM_SETTEXT, 0, (LPARAM)szMessage);
            }

            dwBufferSize -= pDisketteInfo->wCylinderSize;
        } else {
            /* Check if this is a message for the ProgressDlg */
            if (!IsDialogMessage(hdlgProgress, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } else {
                /* That message might have resulted in a Abort */
                if (bUserAbort)
                    return (-1);
            }
        }
    }
    return (wStartCylinder);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadWrite() -                                                           */
// BOOL     bWrite TRUE for Write, FALSE for Read
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This reads or writes as many cylinders as possible into the hpDisketteBuffer.
 * It returns the next cylinder to be read.
 */

INT
ReadWrite(
         BOOL bWrite,
         WORD wStartCylinder,
         PDISKINFO pDisketteInfo
         )
{
    INT   iRetVal = 0;
    return (iRetVal);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RestoreDPB() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
RestoreDPB(
          INT nDisk,
          HANDLE hSavedParams
          )
{
    register PDevPB  pDevPB;

    if (!(pDevPB = (PDevPB)LocalLock(hSavedParams)))
        return (FALSE);

    pDevPB->SplFunctions = 4;
    LocalUnlock(hSavedParams);
    LocalFree(hSavedParams);
    return (TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CopyDiskette() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* NOTE: Returns positive value for success otherwise failure. */

INT
APIENTRY
CopyDiskette(
            HWND hwnd,
            WORD nSourceDisk,
            WORD nDestDisk
            )
{
    INT           rc = -1;
    register WORD wCylinder;
    WORD          wNextCylinder;
    PBPB          pIoctlBPB;      /* Source Drive's BPB (taken from DevicePB)  */
    PBPB          pBootBPB;       /* Boot Drive's BPB (taken from Boot sector) */
    PBPB          pDestBPB;
    DevPB         dpbSrceParams;
    DevPB         dpbDestParams;
    HANDLE        hTrackLayout = NULL;
    HANDLE        hSaveSrceParams;
    HANDLE        hSaveDestParams;
    FARPROC       lpfnDialog;
    DISKINFO      SourceDisketteInfo;
    DISKINFO      DestDisketteInfo;

    /* Check if it is a two drive system; put message to insert both floppies */
    if (nSourceDisk != nDestDisk) {
        bSingleDrive = FALSE;
        DCopyMessageBox(hwnd, IDS_INSERTSRCDEST, MB_OK);
    } else {
        bSingleDrive = TRUE;
        DCopyMessageBox(hwnd, IDS_INSERTSRC, MB_OK);
    }

    /* Get the BiosParameterBlock of source drive */
    if (!(pIoctlBPB = GetBPB(nSourceDisk, &dpbSrceParams)))
        return (0);

    /* Get the BiosParameterBlock of the Source Diskette */
    if (!(pBootBPB = GetBootBPB(nSourceDisk)))
        return (0);

    /* Get the BPB and DPB for the Destination drive also; */
    if (!bSingleDrive) {
        if (!(pDestBPB = GetBPB(nDestDisk, &dpbDestParams)))
            return (0);

        /* Compare BPB of source and Dest to see if they are compatible */
        if (!(CheckBPBCompatibility(pIoctlBPB, dpbSrceParams.devType, pDestBPB, dpbDestParams.devType))) {
            DCopyMessageBox(hwnd, IDS_COPYSRCDESTINCOMPAT, MB_ICONHAND | MB_OK);
            return (0);
        }
    }

    if (!ModifyDeviceParams(nSourceDisk, &dpbSrceParams, &hSaveSrceParams, pIoctlBPB, pBootBPB))
        return (0);

    if (!bSingleDrive) {
        if (!ModifyDeviceParams(nDestDisk, &dpbDestParams, &hSaveDestParams, pDestBPB, pBootBPB)) {
            RestoreDPB(nSourceDisk, hSaveSrceParams);
            return (0);
        }
    }

    GetDisketteInfo((PDISKINFO)&SourceDisketteInfo, pBootBPB);

    /* The Destination Diskette must have the same format as the source */
    DestDisketteInfo = SourceDisketteInfo;

    /* Except the drive number */
    SourceDisketteInfo.wDrive = nSourceDisk;
    DestDisketteInfo.wDrive = nDestDisk;

    /* In case we need to format the destination diskette, we need to know the
     * track layout; So, build a DPB with the required track layout;
     */
    if (wDOSversion >= DOS_320) {
        if (!(hTrackLayout = BuildDevPB(&dpbSrceParams)))
            goto Failure0;

        pTrackLayout = (PDevPB)LocalLock(hTrackLayout);

        /* The following is required to format a 360KB floppy in a 1.2MB
         * drive of NCR PC916 machine; We do formatting, if the destination
         * floppy is an unformatted one;
         * Fix for Bug #6894 --01-10-90-- SANKAR --
         */
        if (pTrackLayout->BPB.bMedia == MEDIA_360) {
            pTrackLayout->NumCyls = 40;
            pTrackLayout->bMediaType = 1;
        }
    }

    /* We wish we could do the following allocation at the begining of this
     * function, but we can not do so, because we need SourceDisketteInfo
     * and we just got it;
     */
    if (!AllocDiskCopyBuffers((PDISKINFO)&SourceDisketteInfo)) {
        DCopyMessageBox(hwnd, IDS_REASONS+DE_INSMEM, MB_ICONHAND | MB_OK);
        goto Failure0;
    }

    bUserAbort = FALSE;
    wCompletedCylinders = 0;

    hdlgProgress = CreateDialog(hAppInstance, (LPSTR)MAKEINTRESOURCE(DISKCOPYPROGRESSDLG), hwnd, ProgressDlgProc);
    if (!hdlgProgress)
        goto Failure2;

    EnableWindow(hwnd, FALSE);

    /* Start with the first cylinder. */
    wCylinder = 0;
    while (wCylinder <= SourceDisketteInfo.wLastCylinder) {
        /* If this is a single drive system, ask the user to insert
         * the source diskette.
         * Do not prompt for the first time, because the Source diskette is
         * already in the drive.
         */
        if (bSingleDrive && (wCylinder > 0))
            PromptDisketteChange(hdlgProgress, FALSE);

        /* Read in the current cylinder. */
        rc = ReadWrite(FALSE, wCylinder, (PDISKINFO)&SourceDisketteInfo);
        if (rc < 0)
            break;
        else
            wNextCylinder = (WORD)rc;

        /* If this is a single drive system, ask the user to insert
         * the destination diskette.
         */
        if (bSingleDrive)
            PromptDisketteChange(hdlgProgress, TRUE);

        /* Write out the current cylinder. */
        bFormatDone = FALSE;
        rc = ReadWrite(TRUE, wCylinder, (PDISKINFO)&DestDisketteInfo);
        if (rc < 0)
            break;

        wCylinder = wNextCylinder;
    }

    EnableWindow(hwnd, TRUE);
    DestroyWindow(hdlgProgress);
    hdlgProgress = NULL;
    Failure2:
    FreeBuffers();
    Failure0:
    if (wDOSversion >= DOS_320) {
        /* Reset the Source drive parameters to the same as old */
        RestoreDPB(nSourceDisk, hSaveSrceParams);
        if (!bSingleDrive) {
            /* Reset the Dest drive parameters to the same as old */
            RestoreDPB(nDestDisk, hSaveDestParams);
        }
    }

    if ((wDOSversion >= DOS_320) && hTrackLayout) {
        LocalUnlock(hTrackLayout);
        LocalFree(hTrackLayout);
    }

    return (rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdlgs3.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDLGS.C -                                                              */
/*                                                                          */
/*      Windows File System Dialog procedures                               */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "wnetcaps.h"			// WNetGetCaps()
#include "lfn.h"
#include "wfcopy.h"


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ChooseDriveDlgProc() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
ChooseDriveDlgProc(
                  register HWND hDlg,
                  UINT wMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    CHAR szDrive[5];

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                INT   i;
                HWND  hwndLB;
                lstrcpy(szDrive, "A:");

                hwndLB = GetDlgItem(hDlg, IDD_DRIVE);

                switch (wSuperDlgMode) {
                    case IDM_SYSDISK:
                    case IDM_DISKCOPY:
                        FillFloppies:
                        for (i = 0; i < cDrives; i++) {
                            if (IsRemovableDrive(rgiDrive[i])) {
                                szDrive[0] = (CHAR)('A'+rgiDrive[i]);
                                SendMessage(hwndLB, CB_ADDSTRING, 0, (LPARAM)szDrive);
                            }
                        }
                        if (wSuperDlgMode == IDM_DISKCOPY && hwndLB == GetDlgItem(hDlg, IDD_DRIVE)) {
                            SendMessage(hwndLB, CB_SETCURSEL, 0, 0L);
                            hwndLB = GetDlgItem(hDlg, IDD_DRIVE1);
                            goto FillFloppies;
                        }
                        break;

                    case IDM_DISCONNECT:
                        for (i=0; i < cDrives; i++) {
                            wParam = rgiDrive[i];
                            if (!IsCDRomDrive((WORD)wParam)) {
                                CHAR szTemp[80];

                                szTemp[0] = (CHAR)('A' + wParam);
                                szTemp[1] = ':';
                                szTemp[2] = 0;
                                lstrcpy(szDrive,szTemp);
                                szTemp[2] = ' ';

                                if (WFGetConnection(szDrive, szTemp+3, FALSE) != WN_SUCCESS)
                                    continue;

                                SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)szTemp);
                            }
                        }
                        SendMessage(hwndLB,LB_SETCURSEL,0,0L);
                        return TRUE;
                }
                SendMessage(hwndLB, CB_SETCURSEL, 0, 0L);
                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDOK:
                    {
                        CHAR szTemp[80];

                        if (wSuperDlgMode == IDM_DISCONNECT) {
                            SendDlgItemMessage(hDlg, IDD_DRIVE, LB_GETTEXT,
                                               (WPARAM)SendDlgItemMessage(hDlg, IDD_DRIVE,
                                                                          WM_COMMAND,
                                                                          GET_WM_COMMAND_MPS(LB_GETCURSEL,0,0)),
                                               (LPARAM)szTemp);
                        } else
                            GetDlgItemText(hDlg, IDD_DRIVE, szTemp, sizeof(szTemp) - 1);

                        iFormatDrive = (INT)(szTemp[0] - 'A');

                        if (wSuperDlgMode == IDM_DISKCOPY) {
                            GetDlgItemText(hDlg, IDD_DRIVE1, szTemp, sizeof(szTemp) - 1);
                            iCurrentDrive = (INT)(szTemp[0] - 'A');
                        }

                        EndDialog(hDlg, TRUE);
                        break;
                    }

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DiskLabelDlgProc() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
DiskLabelDlgProc(
                register HWND hDlg,
                UINT wMsg,
                WPARAM wParam,
                LPARAM lParam
                )
{
    CHAR szOldVol[13];
    CHAR szNewVol[13];

    switch (wMsg) {
        case WM_INITDIALOG:

            /* Get the current volume label */

            szNewVol[0] = (CHAR)(GetSelectedDrive() + 'A');
            szNewVol[1] = ':';
            szNewVol[2] = '\0';
            if (!IsTheDiskReallyThere(hDlg, szNewVol, FUNC_LABEL)) {
                EndDialog(hDlg, FALSE);
                break;
            }

            GetVolumeLabel(szNewVol[0]-'A', szOldVol, FALSE);
            OemToAnsi(szOldVol, szOldVol);

            /* Display the current volume label. */
            SetDlgItemText(hDlg, IDD_NAME, szOldVol);
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szNewVol)-2, 0L);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    {
                        HWND hwnd;
                        BOOL bOldVolExists;

                        GetVolumeLabel(GetSelectedDrive(), szOldVol, FALSE);

                        bOldVolExists = (szOldVol[0] != TEXT('\0'));
                        GetDlgItemText(hDlg, IDD_NAME, szNewVol, sizeof(szNewVol));

                        if (MySetVolumeLabel(GetSelectedDrive(), bOldVolExists, szNewVol)) {
                            GetWindowText(hDlg, szTitle, sizeof(szTitle));
                            LoadString(hAppInstance, IDS_LABELDISKERR, szMessage, sizeof(szMessage));
                            MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                            EndDialog(hDlg, FALSE);
                            break;
                        }

                        for (hwnd = GetWindow(hwndMDIClient, GW_CHILD);
                            hwnd;
                            hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                            // refresh windows on this drive

                            if ((LONG)GetSelectedDrive() == GetWindowLong(hwnd, GWL_TYPE))
                                SendMessage(hwnd, FS_CHANGEDRIVES, 0, 0L);
                        }
                        EndDialog(hDlg, TRUE);
                        break;
                    }

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


INT
APIENTRY
FormatDiskette(
              HWND hwnd
              )
{
    WNDPROC lpfnDialog;
    INT res;
    DWORD dwSave;

    // in case current drive is on floppy

    GetSystemDirectory(szMessage, sizeof(szMessage));
    SheChangeDir(szMessage);

    dwSave = dwContext;
    dwContext = IDH_FORMAT;
    res = (int)DialogBox(hAppInstance, MAKEINTRESOURCE(FORMATDLG), hwnd, FormatDlgProc);
    dwContext = dwSave;

    return res;
}



WORD fFormatFlags = 0;
WORD nLastDriveInd = 0;

VOID
FillDriveCapacity(
                 HWND hDlg,
                 INT nDrive
                 )
{
    INT count, cap;

    SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_RESETCONTENT, 0, 0L);

    cap = (INT)GetDriveCapacity((WORD)nDrive);

    count = 0;      // index of each string, since we are inserting at the end

    // 3.5 (720 1.44 2.88
    if ((cap >= 3) && (cap <= 5)) {

        // 1.44

        LoadString(hAppInstance, IDS_144MB, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_144MB,0));

        // 720

        LoadString(hAppInstance, IDS_720KB, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_720KB,0));

        if (cap == 5) { // 2.88
            LoadString(hAppInstance, IDS_288MB, szTitle, sizeof(szTitle));
            SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
            SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_288MB,0));
        }
    } else if ((cap >= 1) && (cap <= 2)) {

        // 1.2

        LoadString(hAppInstance, IDS_12MB, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_12MB,0));

        // 360

        LoadString(hAppInstance, IDS_360KB, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_360KB,0));
    } else {
        // device cap

        LoadString(hAppInstance, IDS_DEVICECAP, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count, MAKELONG(IDS_DEVICECAP, 0));

    }
    SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETCURSEL, FF_CAPMASK & fFormatFlags, 0L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FormatDlgProc() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
FormatDlgProc(
             register HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    CHAR szLabel[13];
    CHAR szBuf[128];
    INT  i, iCap, iDrive;
    WORD count;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:

            // fill drives combo

            count = 0;
            LoadString(hAppInstance, IDS_DRIVETEMP, szTitle, sizeof(szTitle));
            for (i=0; i < cDrives; i++) {
                if (IsRemovableDrive(rgiDrive[i])) {
                    wsprintf(szMessage, szTitle, (CHAR)('A'+rgiDrive[i]), ' ');

                    if (count == (WORD)nLastDriveInd)
                        iDrive = i;

                    SendDlgItemMessage(hDlg, IDD_DRIVE, CB_INSERTSTRING, count, (LPARAM)szMessage);
                    SendDlgItemMessage(hDlg, IDD_DRIVE, CB_SETITEMDATA, count++, MAKELONG(rgiDrive[i], 0));
                }
            }

            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szLabel)-2, 0L);

            if (fFormatFlags & FF_SAVED) {
                CheckDlgButton(hDlg, IDD_VERIFY, fFormatFlags & FF_QUICK);
                CheckDlgButton(hDlg, IDD_MAKESYS, fFormatFlags & FF_MAKESYS);
            }

            SendDlgItemMessage(hDlg, IDD_DRIVE, CB_SETCURSEL, nLastDriveInd, 0L);

            FillDriveCapacity(hDlg, rgiDrive[iDrive]);

            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDD_HELP:
                    goto DoHelp;

                case IDD_DRIVE:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                        case CBN_SELCHANGE:
                            i = (INT)SendDlgItemMessage(hDlg, IDD_DRIVE, CB_GETCURSEL, 0, 0L);
                            i = (INT)SendDlgItemMessage(hDlg, IDD_DRIVE, CB_GETITEMDATA, i, 0L);
                            fFormatFlags &= ~FF_CAPMASK;
                            FillDriveCapacity(hDlg, i);
                            break;
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    nLastDriveInd = (WORD)SendDlgItemMessage(hDlg, IDD_DRIVE, CB_GETCURSEL, 0, 0L);
                    iFormatDrive = (INT)SendDlgItemMessage(hDlg, IDD_DRIVE, CB_GETITEMDATA, nLastDriveInd, 0L);

                    i = (INT)SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_GETCURSEL, 0, 0L);
                    fFormatFlags &= ~FF_CAPMASK;    // clear any previous bits
                    fFormatFlags |= (WORD)i;        // save last selection as default

                    if (i >= 0)
                        iCap = (INT)SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_GETITEMDATA, i, 0L);
                    else
                        iCap = IDS_DEVICECAP;

                    if (iCap == IDS_DEVICECAP)
                        iCap = -1;
                    else
                        iCap -= IDS_DRIVEBASE;  // normalize down to
                                                // indexes into bpbList[]

                    fFormatFlags |= FF_SAVED;

                    if (IsDlgButtonChecked(hDlg, IDD_MAKESYS))
                        fFormatFlags |= FF_MAKESYS;
                    else
                        fFormatFlags &= ~FF_MAKESYS;

                    if (IsDlgButtonChecked(hDlg, IDD_VERIFY))
                        fFormatFlags |= FF_QUICK;
                    else
                        fFormatFlags &= ~FF_QUICK;

                    GetDlgItemText(hDlg, IDD_NAME, szLabel, sizeof(szLabel));

                    if (bConfirmFormat) {
                        LoadString(hAppInstance, IDS_FORMATCONFIRMTITLE, szTitle, sizeof(szTitle));
                        LoadString(hAppInstance, IDS_FORMATCONFIRM, szBuf, sizeof(szBuf));
                        wsprintf(szMessage, szBuf, (CHAR)('A'+iFormatDrive));

                        if (MessageBox(hDlg, szMessage, szTitle, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES)
                            break;
                    }
                    if (FormatFloppy(hDlg, (WORD)iFormatDrive, iCap, (fFormatFlags & FF_MAKESYS), (fFormatFlags & FF_QUICK))) {

                        if (szLabel[0])
                            MySetVolumeLabel(iFormatDrive, FALSE, szLabel);

                        if (fFormatFlags & FF_ONLYONE) {
                            fFormatFlags &= ~FF_ONLYONE;    // clear the flag
                            EndDialog(hDlg, TRUE);
                        } else {
                            SetDlgItemText(hDlg, IDD_NAME, szNULL); // clear it

                            LoadString(hAppInstance, IDS_FORMATCOMPLETE, szTitle, sizeof(szTitle));
                            LoadString(hAppInstance, IDS_FORMATANOTHER, szMessage, sizeof(szMessage));

                            wsprintf(szBuf, szMessage, GetTotalDiskSpace((WORD)iFormatDrive), GetFreeDiskSpace((WORD)iFormatDrive));

                            if (MessageBox(hDlg, szBuf, szTitle, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2) != IDYES) {
                                EndDialog(hDlg, TRUE);
                            }
                        }
#if 0
                        // this doesn't work quite right

                        // refresh all windows open on this drive

                        for (hwnd = GetWindow(hwndMDIClient, GW_CHILD);
                            hwnd;
                            hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                            // refresh windows on this drive

                            if (iFormatDrive == (INT)GetWindowLong(hwnd, GWL_TYPE))
                                SendMessage(hwnd, FS_CHANGEDRIVES, 0, 0L);

                        }
#endif

                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ProgressDlgProc() -                                                     */
/*                                                                            */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
ProgressDlgProc(
               register HWND hDlg,
               UINT wMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    switch (wMsg) {
        case WM_INITDIALOG:
            /* Check if this is the dialog for DISKCOPY */
            if (GetDlgItem(hDlg, IDD_DRIVE)) {
                /* Yes! Then, tell the user the drive we are copying from. */
                LoadString(hAppInstance, IDS_DRIVETEMP, szTitle, sizeof(szTitle));
                wsprintf(szMessage, szTitle, (CHAR)('A' + iCurrentDrive), '.');
                SetDlgItemText(hDlg, IDD_DRIVE, szMessage);
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDCANCEL:
                    bUserAbort = TRUE;
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


// update all the windows and things after drives have been connected
// or disconnected.

VOID
APIENTRY
UpdateConnections()
{
    HWND hwnd, hwndNext;
    INT i, iDrive;
    HCURSOR hCursor;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    cDrives = UpdateDriveList();    // updates rgiDrive[]
    InitDriveBitmaps();

    // close all windows that have the current drive set to
    // the one we just disconnected

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = hwndNext) {

        hwndNext = GetWindow(hwnd, GW_HWNDNEXT);

        // ignore the titles and search window
        if (GetWindow(hwnd, GW_OWNER) || hwnd == hwndSearch)
            continue;

        iDrive = GetWindowLong(hwnd, GWL_TYPE);

        if (IsValidDisk(iDrive)) {
            // refresh drive bar only
            SendMessage(hwnd, FS_CHANGEDRIVES, 0, 0L);
        } else {
            // this drive has gone away
            if (IsLastWindow()) {
                // disconecting the last drive
                // set this guy to the first non floppy
                for (i = 0; i < cDrives; i++) {
                    if (!IsRemovableDrive(rgiDrive[i])) {
                        SendMessage(HasDrivesWindow(hwnd), FS_SETDRIVE, i, 0L);
                        break;
                    }
                }
            } else
                SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
        }
    }
    ShowCursor(FALSE);
    SetCursor(hCursor);
}


BOOL
DisconnectDrive(
               HWND hDlg,
               INT iDrive
               )
{
    CHAR szTemp[MAXPATHLEN];
    CHAR szDrive[5];
    INT ret, nIsNet;

    // don't allow disconnecting from the system directory

    GetSystemDirectory(szTemp, sizeof(szTemp));
    SheChangeDir(szTemp);        // to fix confused lanman

    if (iDrive == (INT)(*szTemp - 'A')) {
        LoadString(hAppInstance, IDS_NETERR, szTitle, sizeof(szTitle));
        LoadString(hAppInstance, IDS_NETDISCONWINERR, szMessage, sizeof(szMessage));
        MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
        return FALSE;
    }

    lstrcpy(szDrive, "A:");
    szDrive[0] = (CHAR)('A'+iDrive);

    nIsNet = IsNetDrive((WORD)iDrive);
    ret = WNetCancelConnection(szDrive, FALSE);     // don't force this

    // remove from the permanent connection list (even in error case)
    WriteProfileString(szNetwork, szDrive, szNULL);

    if (nIsNet != 2 && ret != WN_SUCCESS && ret != WN_NOT_CONNECTED) {

        LoadString(hAppInstance, IDS_NETERR, szTitle, sizeof(szTitle));

        if (ret == WN_OPEN_FILES)
            LoadString(hAppInstance, (UINT)IDS_NETDISCONOPEN, szMessage, sizeof(szMessage));
        else
            WNetErrorText((WORD)ret, szMessage, sizeof(szMessage));

        MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
        return FALSE;
    }
    return TRUE;
}


VOID
FillDrives(
          HWND hDlg
          )
{
    INT i, iDrive, count = 0;
    CHAR szDrive[4];
    CHAR szTemp[120];
    HWND hwndLB, hwndCB;

    hwndLB = GetDlgItem(hDlg, IDD_DRIVE1);
    hwndCB = GetDlgItem(hDlg, IDD_DRIVE);

    SendMessage(hwndCB, CB_RESETCONTENT, 0, 0L);
    SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

    // fill the list of drives to connect to...

    lstrcpy(szDrive, "A:");

    iDrive = 0;
    for (i = 0; i < 26; i++) {
        if (rgiDrive[iDrive] == i) {
            iDrive++;
        } else {
            if (i == 1)
                continue;        // skip B:?

            szDrive[0] = (CHAR)('A'+i);

            // WN_BAD_LOCALNAME means the drive is not sutable for
            // making a connection to (lastdrive limit, etc).

            if (WFGetConnection(szDrive, szTemp, TRUE) == WN_BAD_LOCALNAME)
                continue;

            SendMessage(hwndCB, CB_INSERTSTRING, -1, (LPARAM)szDrive);
        }
    }

    SendMessage(hwndCB, CB_SETCURSEL, 0, 0L);

    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
    for (i = 0; i < cDrives; i++) {
        if (IsRemoteDrive(rgiDrive[i])) {

            szTemp[0] = (CHAR)('A' + rgiDrive[i]);
            szTemp[1] = ':';
            szTemp[2] = 0;
            lstrcpy(szDrive,szTemp);
            szTemp[2] = ' ';

            if (WFGetConnection(szDrive, szTemp+3, FALSE) != WN_SUCCESS)
                continue;

            count++;
            SendMessage(hwndLB, LB_INSERTSTRING, -1, (LPARAM)szTemp);
        }
    }
    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hwndLB, NULL, TRUE);

    SendMessage(hwndLB, LB_SETCURSEL, 0, 0L);

    EnableWindow(GetDlgItem(hDlg, IDD_DISCONNECT), count);
}

LPSTR pszPrevPath;

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ConnectDlgProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
ConnectDlgProc(
              register HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    BOOL              bPrevs;
    CHAR              szDrive[4];
    CHAR              szPath[WNBD_MAX_LENGTH], szPathSave[WNBD_MAX_LENGTH];
    CHAR              szPassword[32];
    HCURSOR           hCursor;

    switch (wMsg) {
        case WM_INITDIALOG:
            hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            ShowCursor(TRUE);

            FillDrives(hDlg);

            if (!(WNetGetCaps(WNNC_CONNECTION) & WNNC_CON_BROWSEDIALOG))
                EnableWindow(GetDlgItem(hDlg, IDD_NETBROWSE), FALSE);

            SendDlgItemMessage(hDlg, IDD_PATH, EM_LIMITTEXT, sizeof(szPath)-1, 0L);
            SendDlgItemMessage(hDlg, IDD_PASSWORD, EM_LIMITTEXT, sizeof(szPassword)-1, 0L);

            /* Are there any Previous connections? */
            bPrevs = (GetPrivateProfileString(szPrevious, NULL, szNULL,
                                              szPath, sizeof(szPath)-1, szTheINIFile) != 0);

            EnableWindow(GetDlgItem(hDlg, IDD_PREV), bPrevs);

            ShowCursor(FALSE);
            SetCursor(hCursor);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDOK:
                    {
                        HCURSOR   hCursor;
                        LPSTR p;
                        UINT  id;

                        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                        ShowCursor(TRUE);

                        GetDlgItemText(hDlg, IDD_DRIVE, szDrive, sizeof(szDrive));
                        GetDlgItemText(hDlg, IDD_PATH, szPath, sizeof(szPath));
                        GetDlgItemText(hDlg, IDD_PASSWORD, szPassword, sizeof(szPassword));
                        lstrcpy(szPathSave, szPath);  // may have comments

                        // support saving extra stuff after the first double space
                        // put a NULL in at the first double space

                        p = szPath;
                        while (*p && *p != ' ')
                            p = AnsiNext(p);
                        if (*(p + 1) == ' ')
                            *p = 0;

                        if ((id = WNetAddConnection(szPath, szPassword, szDrive)) != WN_SUCCESS) {
                            ShowCursor(FALSE);
                            SetCursor(hCursor);

                            LoadString(hAppInstance, IDS_NETERR, szTitle, sizeof(szTitle));
                            WNetErrorText(id, szMessage, sizeof(szMessage));
                            MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                            break;
                        }

                        UpdateConnections();
                        InvalidateVolTypes();

                        FillDrives(hDlg);

                        SetDlgItemText(hDlg, IDD_PATH, szNULL);
                        SetDlgItemText(hDlg, IDD_PASSWORD, szNULL);

                        // always add to previous...
                        WritePrivateProfileString(szPrevious, szPathSave, szNULL, szTheINIFile);

                        // store the connection in win.ini for reconect at
                        // startup if the winnet driver does not support this
                        // itself
                        //
                        // allow SHIFT to make the connection not permenent

                        if (!(WNetGetCaps(WNNC_CONNECTION) & WNNC_CON_RESTORECONNECTION) &&
                            (GetKeyState(VK_SHIFT) >= 0))
                            WriteProfileString(szNetwork, szDrive, szPath);

                        ShowCursor(FALSE);
                        SetCursor(hCursor);
                        break;
                    }

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    break;

                case IDD_NETBROWSE:

                    //	          if (WNetBrowseDialog(hDlg, WNBD_CONN_DISKTREE, szPath) == WN_SUCCESS)
                    //                      SetDlgItemText(hDlg, IDD_PATH, szPath);
                    break;

                case IDD_DISCONNECT:

                    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    ShowCursor(TRUE);

                    wParam = (WPARAM)SendDlgItemMessage(hDlg, IDD_DRIVE1, LB_GETCURSEL, 0, 0L);
                    SendDlgItemMessage(hDlg, IDD_DRIVE1, LB_GETTEXT, wParam, (LPARAM)szPath);

                    if (DisconnectDrive(hDlg, (INT)(szPath[0] - 'A'))) {
                        SendDlgItemMessage(hDlg, IDD_DRIVE1, LB_DELETESTRING, wParam, 0L);
                        UpdateConnections();
                        FillDrives(hDlg);
                        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDD_PATH), 1L);
                    }

                    ShowCursor(FALSE);
                    SetCursor(hCursor);
                    break;

                case IDD_PREV:
                    {
                        DWORD dwSave = dwContext;

                        dwContext = IDH_DLG_PREV;

                        pszPrevPath = szPath;

                        if (DialogBox(hAppInstance, MAKEINTRESOURCE(PREVIOUSDLG), hDlg, PreviousDlgProc) > 0) {
                            SetDlgItemText(hDlg, IDD_PATH, pszPrevPath);
                            GetPrivateProfileString(szPrevious, pszPrevPath, szNULL, szPassword, 12, szTheINIFile);
                            SetDlgItemText(hDlg, IDD_PASSWORD, szNULL);
                            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDD_PASSWORD), 1L);
                        }
                        dwContext = dwSave;
                        break;
                    }

                case IDD_DRIVE:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE) {
                        if (GetDlgItemText(hDlg,IDD_DRIVE,szDrive,3)) {
                            if (WFGetConnection(szDrive,szPath,FALSE) == WN_SUCCESS)
                                SetDlgItemText(hDlg,IDD_PATH,szPath);
                        }
                    }
                    break;

                case IDD_PATH:
                    if (!(wParam = GetDlgItemText(hDlg,IDD_PATH,szPath,64)) &&
                        GetFocus()==GetDlgItem(hDlg, IDOK))
                        SendMessage(hDlg, WM_NEXTDLGCTL,
                                    (WPARAM)GetDlgItem(hDlg, IDCANCEL), 1L);
                    EnableWindow(GetDlgItem(hDlg,IDOK),wParam ? TRUE : FALSE);
                    SendMessage(hDlg, DM_SETDEFID, wParam ? IDOK : IDCANCEL, 0L);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}

INT_PTR
APIENTRY
DrivesDlgProc(
             HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    INT nDrive, iSel;
    HWND hwndDrives, hwndActive;
    CHAR szTemp[MAXPATHLEN];
    CHAR szVolShare[MAXPATHLEN];

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                INT nCurDrive;
                INT nIndex;

                nCurDrive = GetSelectedDrive();
                nIndex = 0;

                for (nDrive=0; nDrive < cDrives; nDrive++) {

                    if (IsRemovableDrive(rgiDrive[nDrive])) // avoid flopies
                        szVolShare[0] = (CHAR)NULL;
                    else
                        GetVolShare((WORD)rgiDrive[nDrive], szVolShare);

                    if (nCurDrive == rgiDrive[nDrive])
                        nIndex = nDrive;

                    wsprintf(szTemp, "%c: %s", rgiDrive[nDrive] + 'A', (LPSTR)szVolShare);

                    SendDlgItemMessage(hDlg, IDD_DRIVE, LB_ADDSTRING, 0, (LPARAM)szTemp);
                }
                SendDlgItemMessage(hDlg, IDD_DRIVE, LB_SETCURSEL, nIndex, 0L);
                break;
            }

        case WM_COMMAND:

            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDD_DRIVE:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
                        break;

                    // fall through
                case IDOK:
                    iSel = (INT)SendDlgItemMessage(hDlg, IDD_DRIVE, LB_GETCURSEL, 0, 0L);
                    EndDialog(hDlg, TRUE);

                    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
                    if (hwndDrives = HasDrivesWindow(hwndActive)) {
                        SendMessage(hwndDrives, FS_SETDRIVE, iSel, 0L);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

            }
            break;
        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PreviousDlgProc() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
PreviousDlgProc(
               register HWND hDlg,
               UINT wMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    HWND hwndLB;
    INT iSel;
    CHAR szTemp[64];

    hwndLB = GetDlgItem(hDlg, IDD_PREV);

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                WORD      nSize;
                LPSTR      pstrT;
                LPSTR      szBuffer;

                /*** FIX30: We should be able to process a partial buffer here. ***/

                /* Get the connections out of WINFILE.INI. */
                nSize = 256;
                if (!(szBuffer = (LPSTR)LocalAlloc(LPTR, nSize))) {
                    PreviousDlgExit:
                    EndDialog(hDlg, FALSE);
                    break;
                }

                while ((INT)GetPrivateProfileString(szPrevious,
                                                    NULL, szNULL,
                                                    szBuffer, nSize,
                                                    szTheINIFile) == (INT)nSize-2) {
                    nSize += 512;
                    LocalFree((HANDLE)szBuffer);
                    if (!(szBuffer = (LPSTR)LocalAlloc(LPTR, nSize)))
                        goto PreviousDlgExit;
                }

                /* Put the connections into the list box. */
                pstrT = szBuffer;
                while (*pstrT) {
                    SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)pstrT);
                    while (*pstrT)
                        pstrT++;
                    pstrT++;
                }

                LocalFree((HANDLE)szBuffer);

                SendMessage(hwndLB, LB_SETCURSEL, 0, 0L);
                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDD_DELETE:
                    iSel = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                    if (iSel == LB_ERR)
                        break;
                    SendMessage(hwndLB, LB_GETTEXT, iSel, (LPARAM)szTemp);
                    SendMessage(hwndLB, LB_DELETESTRING, iSel, 0L);
                    SendMessage(hwndLB, LB_SETCURSEL, 0, 0L);
                    WritePrivateProfileString(szPrevious, szTemp, NULL, szTheINIFile);
                    break;

                case IDD_PREV:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
                        return FALSE;
                    /*** FALL THRU ***/

                case IDOK:
                    // return the selection through this global

                    *pszPrevPath = TEXT('\0');
                    iSel = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                    if (iSel != LB_ERR)
                        SendMessage(hwndLB, LB_GETTEXT, iSel, (LPARAM)pszPrevPath);
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdlgs2.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDLGS2.C -                                                             */
/*                                                                          */
/*      More Windows File System Dialog procedures                          */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "lfn.h"
#include "wfcopy.h"
#include "winnet.h"
#include "wnetcaps.h"			// WNetGetCaps()
#include "commdlg.h"

CHAR szShellOpenCommand[] = "\\shell\\open\\command";

VOID CheckAttribsDlgButton(HWND hDlg, INT id, DWORD dwAttribs, DWORD dwAttribs3State, DWORD dwAttribsOn);


// Return pointers to various bits of a path.
// ie where the dir name starts, where the filename starts and where the
// params are.
VOID
GetPathInfo(
           LPSTR szTemp,
           LPSTR *ppDir,
           LPSTR *ppFile,
           LPSTR *ppPar
           )
{
    /* strip leading spaces
     */
    for (*ppDir = szTemp; **ppDir == ' '; (*ppDir)++)
        ;

    /* locate the parameters
     */
    for (*ppPar = *ppDir; **ppPar && **ppPar != ' '; (*ppPar)++)
        ;

    /* locate the start of the filename and the extension.
     */
    for (*ppFile = *ppPar; *ppFile > *ppDir; --(*ppFile)) {
        if (((*ppFile)[-1] == ':') || ((*ppFile)[-1] == '\\'))
            break;
    }
}

VOID
ValidateExtension(
                 HWND hDlg
                 )
{
    CHAR szTemp[10];
    INT count;

    count = GetDlgItemText(hDlg, IDD_EXTENSION, szTemp, sizeof(szTemp));
    EnableWindow(GetDlgItem(hDlg, IDD_SEARCHALL), count);
    EnableWindow(GetDlgItem(hDlg, IDOK), count);
    SendMessage(hDlg, DM_SETDEFID, count ? IDOK : IDCANCEL, 0L);
}

// since LoadString() only reads up to a null we have to mark
// special characters where we want nulls then convert them
// after loading.

VOID
FixupNulls(
          LPSTR p
          )
{
    LPSTR pT;

    while (*p) {
        if (*p == '#') {
            pT = p;
            p = AnsiNext(p);
            *pT = TEXT('\0');
        } else
            p = AnsiNext(p);
    }
}

// Find the key associated with the given value.
BOOL
ValidFileTypeValue(
                  LPSTR szVal,
                  LPSTR szKey,
                  WORD cbMaxKey
                  )
{
    HKEY hk = NULL;
    WORD wTmp;
    LONG lTmp;
    BOOL retval = FALSE;
    CHAR szValTmp[128];

    if (RegOpenKey(HKEY_CLASSES_ROOT,szNULL,&hk) != ERROR_SUCCESS)
        return(FALSE);

    for (wTmp = 0;
        RegEnumKey(hk, wTmp, szKey, cbMaxKey) == ERROR_SUCCESS;
        wTmp++) {
        // Skip things that aren't file type things.
        if (szKey[0] == '.')
            continue;

        lTmp = 128;
        if (RegQueryValue(hk, szKey, szValTmp, &lTmp) != ERROR_SUCCESS) {
            continue;
        }

        if (!szValTmp[0])
            continue;

        if (!lstrcmp(szValTmp, szVal)) {
#ifdef VERBDEBUG
            OutputDebugString("wf.vftv: Found a match\n\r");
#endif
            //  Found a match.
            retval = TRUE;
            goto ProcExit;
        }

    }
    szKey[0] = TEXT('\0');
    ProcExit:
    RegCloseKey(hk);
    return retval;
}

// Sets the selection of a listbox to that matching the given string.
VOID
SetLBSelection(
              HWND hDlg,
              INT nDlgItem,
              LPSTR sz
              )
{
    INT iMatch;

    iMatch = (INT) SendDlgItemMessage(hDlg, nDlgItem, LB_SELECTSTRING, -1, (LPARAM) sz);
    if (iMatch == LB_ERR) {
#ifdef VERBDEBUG
        OutputDebugString("wf.sdft: Selection missing from list box.\n\r");
#endif
        return;
    }

    return;
}

// Given an extension (with or without a dot) set the list box or the
// programname fields properly.
VOID
UpdateSelectionOrName(
                     HWND hDlg
                     )
{
    CHAR szExt[128];
    CHAR szTemp[128];
    LONG cbTemp;
    LPSTR p;

    // Get the current extension (after the dot).
    GetDlgItemText(hDlg, IDD_EXTENSION, szTemp, sizeof(szTemp));

    // Make sure it has a dot.
    if (szTemp[0] != '.') {
        // Add one.
        szExt[0] = '.';
        lstrcpy(szExt+1, szTemp);
    } else {
        // It's already got one.
        lstrcpy(szExt, szTemp);
    }

    cbTemp = sizeof(szTemp);
    if (RegQueryValue(HKEY_CLASSES_ROOT,szExt,
                      szMessage,&cbTemp) == ERROR_SUCCESS) {
        if (*szMessage) {
            // it's associated with a class
#ifdef VERBDEBUG
            OutputDebugString("wf.uson: ");
            OutputDebugString(szTemp);
            OutputDebugString(" associated with class (");
            OutputDebugString(szMessage);
            OutputDebugString(")\n\r");
#endif
            szTemp[0] = TEXT('\0');
            cbTemp = sizeof(szTemp);
            RegQueryValue(HKEY_CLASSES_ROOT,szMessage,szTemp,&cbTemp);
#ifdef VERBDEBUG
            OutputDebugString("wf.uson: Associated with value (");
            OutputDebugString(szTemp);
            OutputDebugString(")\n\r");
#endif
            // Set the list box selection to the right type.
            SetLBSelection(hDlg, IDD_CLASSLIST, szTemp);
            // Put the type name in the program name field.
            SetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp);
        } else {
            // it's not associated with a class, see if it has a
            // shell open command and treat it as a command association
            lstrcat(szExt,szShellOpenCommand);
            cbTemp = sizeof(szTemp);
            if (RegQueryValue(HKEY_CLASSES_ROOT, szExt, szTemp, &cbTemp) == ERROR_SUCCESS
                && szTemp[0]) {
#ifdef VERBDEBUG
                OutputDebugString("wf.uson: It has a shell open command.\n\r");
#endif
                goto ProgramAssoc;
            } else {
                // Put "none" in the field.
#ifdef VERBDEBUG
                OutputDebugString("wf.uson: Class set to nothing.\n\r");
#endif
                LoadString(hAppInstance, IDS_ASSOCNONE, szTemp, sizeof(szTemp));
                SetDlgItemText(hDlg,IDD_PROGRAMNAME, szTemp);
                SetLBSelection(hDlg, IDD_CLASSLIST, szTemp);
                goto NoAssoc;
            }
        }
    } else if (GetProfileString(szExtensions, szExt+1, szNULL, szTemp, sizeof(szTemp))) {
        ProgramAssoc:
        /* Remove the "^." bulloney. */
        p = szTemp;
        while ((*p) && (*p != '^') && (*p != '%'))
            p = AnsiNext(p);
        *p = TEXT('\0');

        p--;
        if (*p == ' ')
            *p = 0;
        SetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp);
        // Set clear the selection.
        SendDlgItemMessage(hDlg, IDD_CLASSLIST, LB_SETCURSEL, -1, 0L);
    } else {
        // Nothing.
#ifdef VERBDEBUG
        OutputDebugString("wf.uson: No association.\n\r");
#endif
        LoadString(hAppInstance, IDS_ASSOCNONE, szTemp, sizeof(szTemp));
        SetDlgItemText(hDlg,IDD_PROGRAMNAME, szTemp);
        SetLBSelection(hDlg, IDD_CLASSLIST, szTemp);
    }

    NoAssoc:
    SendDlgItemMessage(hDlg, IDD_PROGRAMNAME, EM_LIMITTEXT, sizeof(szTemp) - 1, 0L);
}


// Given a class key returns the shell\open\command string in szValue
// and the number of chars copied in cbMaxValue. cbMaxValue should
// be initialised to the max siz eof szValue.
VOID
GetAssociatedExe(
                LPSTR szKey,
                LPSTR szValue,
                LONG *plcbValue
                )
{
    CHAR szTemp[128];
    LONG i;

    lstrcpy(szTemp, szKey);
    lstrcat(szTemp, szShellOpenCommand);
#ifdef VERBDEBUG
    OutputDebugString("wf.gae: Key Query ");
    OutputDebugString(szTemp);
    OutputDebugString("\n\r");
#endif


    RegQueryValue(HKEY_CLASSES_ROOT, szTemp, szValue, plcbValue);
    // Strip any params.
    for (i=0; szValue[i] != TEXT('\0'); i++) {
        if (szValue[i] == ' ') {
            szValue[i] = TEXT('\0');
            break;
        }
    }}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AssociateDlgProc() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
AssociateDlgProc(
                register HWND hDlg,
                UINT wMsg,
                WPARAM wParam,
                LPARAM lParam
                )
{
    CHAR szTemp[128];
    CHAR szTemp2[128];
    HKEY hk = NULL;

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                LPSTR  p;
                register LPSTR pSave;
                INT iItem;
                CHAR szTemp3[128];
                CHAR szTemp4[128];
                LONG lcbTemp;

                SendDlgItemMessage(hDlg,IDD_CLASSLIST,LB_RESETCONTENT,0,0L);

                if (RegOpenKey(HKEY_CLASSES_ROOT,szNULL,&hk) == ERROR_SUCCESS) {
                    for (wParam = 0;
                        RegEnumKey(hk, (DWORD)wParam, szTemp, sizeof(szTemp)) == ERROR_SUCCESS;
                        wParam++) {

                        // Skip things that aren't file type things.
                        if (szTemp[0] == '.')
                            continue;

                        lParam = 128;
                        if (RegQueryValue(hk, szTemp, szTemp2, (PLONG)&lParam) != ERROR_SUCCESS) {
                            continue;
                        }

                        // Skip things that aren't relevant ot the shell.
                        lParam = 128;
                        lstrcpy(szTemp3, szTemp);
                        lstrcat(szTemp3, "\\shell");
                        if (RegQueryValue(hk, szTemp3, szTemp4, (PLONG)&lParam) != ERROR_SUCCESS) {
                            continue;
                        }


                        if (!szTemp2[0])
                            continue;

                        // Add on program info
                        lcbTemp = sizeof(szTemp3);
                        szTemp3[0] = TEXT('\0');
                        GetAssociatedExe(szTemp, szTemp3, &lcbTemp);
                        if (szTemp3[0] != TEXT('\0')) {
                            lstrcat(szTemp2, " (");
                            lstrcat(szTemp2, szTemp3);
                            lstrcat(szTemp2, ")");
                        }

                        iItem = (INT)SendDlgItemMessage(hDlg,IDD_CLASSLIST, LB_ADDSTRING,0,(LPARAM)szTemp2);

                        SendDlgItemMessage(hDlg,IDD_CLASSLIST,LB_SETITEMDATA,iItem,
                                           (DWORD)AddAtom(szTemp));
                    }

                    RegCloseKey(hk);
                }

                // Add the (None) entry at the begining.
                LoadString(hAppInstance, IDS_ASSOCNONE, szTemp, sizeof(szTemp));
                SendDlgItemMessage(hDlg,IDD_CLASSLIST, LB_INSERTSTRING,0,(LPARAM)szTemp);

                lstrcpy(szTitle,".");

                /* Make 'p' point to the file's extension. */
                pSave = GetSelection(TRUE);
                if (pSave) {
                    p = GetExtension(pSave);
                    if (!IsProgramFile(pSave)) {
                        lstrcat(szTitle,p);
                    }
                    LocalFree((HANDLE)pSave);
                }

                SendDlgItemMessage(hDlg, IDD_EXTENSION, EM_LIMITTEXT, 4, 0L);
                SetDlgItemText(hDlg, IDD_EXTENSION, szTitle+1);
                SendDlgItemMessage(hDlg, IDD_EXTENSION, EM_SETMODIFY, 0, 0L);

                /* this is empty if there is no class association
                 */
                szMessage[0]=0;
                szTemp2[0]=0;

                UpdateSelectionOrName(hDlg);

                ValidateExtension(hDlg);

                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                HWND hwndT, hwndNext;

                case IDD_HELP:
                    goto DoHelp;

                case IDD_EXTENSION:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {
                        ValidateExtension(hDlg);
                        UpdateSelectionOrName(hDlg);
                    }
                    break;

                case IDD_SEARCHALL:
                    {
                        OPENFILENAME ofn;
                        DWORD dwSave = dwContext;

                        dwContext = IDH_ASSOC_BROWSE;

                        LoadString(hAppInstance, IDS_PROGRAMS, szTemp2, sizeof(szTemp2));
                        FixupNulls(szTemp2);
                        LoadString(hAppInstance, IDS_ASSOCIATE, szTitle, sizeof(szTitle));

                        szTemp[0] = TEXT('\0');

                        ofn.lStructSize        = sizeof(ofn);
                        ofn.hwndOwner                   = hDlg;
                        ofn.hInstance         = NULL;
                        ofn.lpstrFilter        = szTemp2;
                        ofn.lpstrCustomFilter = NULL;
                        ofn.nFilterIndex        = 1;
                        ofn.lpstrFile                = szTemp;
                        ofn.lpstrFileTitle        = NULL;
                        ofn.nMaxFile                   = sizeof(szTemp);
                        ofn.lpstrInitialDir   = NULL;
                        ofn.lpstrTitle        = szTitle;
                        ofn.Flags                = OFN_SHOWHELP | OFN_HIDEREADONLY;
                        ofn.lpfnHook                   = NULL;
                        ofn.lpstrDefExt           = NULL;
                        if (GetOpenFileName(&ofn)) {
                            SetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp);
                        }

                        dwContext = dwSave;
                    }
                    DosResetDTAAddress(); // undo any bad things COMMDLG did
                    break;

                case IDD_CLASSLIST:
                    // Handle a selection change.
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE) {
                        INT iSel;
                        LONG lTemp2;
                        ATOM aClass;

                        // Get selection number.
                        if (SendDlgItemMessage(hDlg,IDD_CLASSLIST,LB_GETCURSEL,0,0L) == 0) {
                            // User selected "none".
                            LoadString(hAppInstance, IDS_ASSOCNONE, szTemp, sizeof(szTemp));
                            // Copy into PROGRAMNAME field.
                            SetDlgItemText(hDlg, IDD_PROGRAMNAME, (LPSTR) szTemp);
                        } else {
                            // User selected a file type.
                            // Get the atom from the list box.
                            iSel = (WORD) SendDlgItemMessage(hDlg, IDD_CLASSLIST,
                                                             LB_GETCURSEL,0,0L);
                            aClass = (ATOM) SendDlgItemMessage(hDlg, IDD_CLASSLIST,
                                                               LB_GETITEMDATA, iSel, 0L);
                            // Use the atom to get the file type key.
                            GetAtomName(aClass, szTemp, sizeof(szTemp));
                            // Use the file type key to get the file type value.
                            lTemp2 = sizeof(szTemp2);
                            RegQueryValue(HKEY_CLASSES_ROOT, szTemp, szTemp2,
                                          &lTemp2);
                            // Splat the file type value into PROGRAMNAME field.
                            SetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp2);
                        }
                        break;
                    }

                case IDD_PROGRAMNAME:
                    break;

                case IDOK:
                    {
                        GetDlgItemText(hDlg, IDD_EXTENSION, szTemp, 5);

                        if (szTemp[0] != '.') {
                            lstrcpy(szTitle,".");
                            lstrcat(szTitle, szTemp);
                        } else
                            lstrcpy(szTitle, szTemp);

                        if (IsProgramFile(szTitle)) {
                            LoadString(hAppInstance, IDS_NOEXEASSOC, szTemp, sizeof(szTemp));
                            wsprintf(szMessage, szTemp, (LPSTR)szTitle);
                            GetWindowText(hDlg, szTitle, sizeof(szTitle));
                            MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                            SetDlgItemText(hDlg, IDD_EXTENSION, szNULL);
                            break;
                        }



                        // Read IDD_PROGRAMNAME bit.
                        GetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp, sizeof(szTemp));
                        LoadString(hAppInstance, IDS_ASSOCNONE, szTemp2, sizeof(szTemp2));

                        // Is it "(None)" ?
                        if (!lstrcmp(szTemp, szTemp2)) {
                            DeleteAssoc:
                            // Yep, They selected none.
                            RegDeleteKey(HKEY_CLASSES_ROOT,szTitle);
                            WriteProfileString(szExtensions, szTitle+1, NULL);
                        } else if (ValidFileTypeValue(szTemp, szTemp2, sizeof(szTemp2))) {
                            LPSTR p1, p2;

                            // The file type key is in szTemp2 (eg wrifile).
                            // The extension key (eg .wri) is in szTitle.
                            // The file type value (eg Write Document) is in
                            // szTemp.
#ifdef VERBDEBUG
                            OutputDebugString("wf.adp: Valid file type selected.\n\r");
                            OutputDebugString("wf.adp: Extension ");
                            OutputDebugString(szTitle);
                            OutputDebugString("\n\r");
                            OutputDebugString("wf.adp: File type key ");
                            OutputDebugString(szTemp2);
                            OutputDebugString("\n\r");
                            OutputDebugString("wf.adp: File type value ");
                            OutputDebugString(szTemp);
                            OutputDebugString("\n\r");
#endif

                            /* set the class
                             */
                            RegSetValue(HKEY_CLASSES_ROOT, szTitle, REG_SZ, szTemp2, 0L);

                            /* get the class's SHELL\OPEN\COMMAND
                             */
                            lstrcpy(szTemp, szTemp2);
                            lstrcat(szTemp, szShellOpenCommand);
                            lParam = 128;
                            szTemp2[0] = 0;
                            RegQueryValue(HKEY_CLASSES_ROOT, szTemp, szTemp2, (PLONG)&lParam);

                            /* insert ^.ext in for %1 in win.ini!
                             */
                            for (p1 = szTemp, p2 = szTemp2; *p2; p2 = AnsiNext(p2)) {
                                if (*p2 == '%') {
                                    p2++;
                                    if (!*p2)
                                        break;
                                    if (*p2 == '1') {
                                        *p1++ = '^';
                                        lstrcpy(p1,szTitle);
                                        p1 += lstrlen(p1);
                                    } else {
                                        *p1++ = *p2;
                                    }
                                } else {
                                    *p1++=*p2;
                                }
                            }

                            *p1 = 0; // null terminate

                            /* and use it for the extensions section
                             */
                            WriteProfileString(szExtensions,szTitle+1, szTemp);
                        } else {
                            // It must be a program name.

                            /* if no command line, treat as none
                             */
                            if (!szTemp[0])
                                goto DeleteAssoc;

                            // make sure it has an extension

                            if (*GetExtension(szTemp) == 0)
                                lstrcat(szTemp, ".exe");

                            if (!IsProgramFile(szTemp)) {
                                LoadString(hAppInstance, IDS_ASSOCNOTEXE, szTemp2, sizeof(szTemp2));
                                wsprintf(szMessage, szTemp2, (LPSTR)szTemp);
                                GetWindowText(hDlg, szTitle, sizeof(szTitle));
                                MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                                SetDlgItemText(hDlg, IDD_PROGRAMNAME, szNULL);
                                break;
                            }

                            /* unassociate the class from the extension
                             */
                            RegSetValue(HKEY_CLASSES_ROOT, szTitle, REG_SZ, szNULL, 0L);

                            /* update the [extensions] section
                             */
                            lstrcpy(szTemp2, szTemp);
                            lstrcat(szTemp2, " ^.");
                            lstrcat(szTemp2, szTitle+1);
                            WriteProfileString(szExtensions, szTitle+1, szTemp2);

                            /* update the reg database
                             */
                            lstrcat(szTemp," %1");
                            lstrcat(szTitle, szShellOpenCommand);
                            RegSetValue(HKEY_CLASSES_ROOT, szTitle, REG_SZ, szTemp, 0L);
                        }

                        // rebuild the list of document extensions
                        LocalFree((HANDLE)szDocuments);
                        BuildDocumentString();

                        /* Update all of the Directory Windows in order to see
                         * the effect of the new extensions.
                         */
                        hwndT = GetWindow(hwndMDIClient, GW_CHILD);
                        while (hwndT) {
                            hwndNext = GetWindow(hwndT, GW_HWNDNEXT);
                            if (!GetWindow(hwndT, GW_OWNER))
                                SendMessage(hwndT, WM_FILESYSCHANGE, FSC_REFRESH, 0L);
                            hwndT = hwndNext;

                        }
                    }
                    /*** FALL THRU ***/

                case IDCANCEL:
                    {
                        INT iItem;
                        INT cItems;
                        ATOM aClass;

                        cItems = (INT)SendDlgItemMessage(hDlg,IDD_CLASSLIST,
                                                         LB_GETCOUNT,0,0L);

                        /* clean out them atoms except for "(none)".
                         */
                        for (iItem = 1; iItem < cItems; iItem++) {
                            aClass = (ATOM)SendDlgItemMessage(hDlg,IDD_CLASSLIST,
                                                              LB_GETITEMDATA,iItem,0L);
                            if (aClass == LB_ERR)
                                break;

                            DeleteAtom(aClass);
                        }

                        EndDialog(hDlg, TRUE);
                        break;
                    }

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage || wMsg == wBrowseMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return(TRUE);
}


//
// Strips off the path portion and replaces the first part of an 8-dot-3
// filename with an asterisk.
//

VOID
StarFilename(
            LPSTR pszPath
            )
{
    LPSTR p;

    /* Remove any leading path information. */
    StripPath(pszPath);

    for (p = pszPath; *p && *p != '.'; p = (LPSTR)AnsiNext(p));

    if (*p == '.') {
        lstrcpy(pszPath+1, p);
        pszPath[0] = '*';
    } else
        lstrcpy(pszPath, szStarDotStar);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SearchDlgProc() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
SearchDlgProc(
             register HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    LPSTR     p;
    MDICREATESTRUCT   MDICS;
    CHAR szStart[MAXFILENAMELEN];

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg, IDD_DIR, EM_LIMITTEXT, sizeof(szSearch)-(1+MAXFILENAMELEN), 0L);
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szStart)-1, 0L);

            GetSelectedDirectory(0, szSearch);
            SetDlgItemText(hDlg, IDD_DIR, szSearch);

            p = GetSelection(TRUE);

            if (p) {
                GetNextFile(p, szStart, sizeof(szStart));
                StarFilename(szStart);
                SetDlgItemText(hDlg, IDD_NAME, szStart);
                LocalFree((HANDLE)p);
            }

            CheckDlgButton(hDlg, IDD_SEARCHALL, bSearchSubs);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    GetDlgItemText(hDlg, IDD_DIR, szSearch, sizeof(szSearch));
                    QualifyPath(szSearch);

                    GetDlgItemText(hDlg, IDD_NAME, szStart, sizeof(szStart));
                    AppendToPath(szSearch, szStart);

                    bSearchSubs = IsDlgButtonChecked(hDlg, IDD_SEARCHALL);

                    EndDialog(hDlg, TRUE);

                    /* Is the search window already up? */
                    if (hwndSearch) {
                        if (SendMessage(hwndSearch, FS_CHANGEDISPLAY, CD_PATH, (LPARAM)szSearch)) {
                            SendMessage(hwndMDIClient, WM_MDIACTIVATE, GET_WM_MDIACTIVATE_MPS(0, 0, hwndSearch));
                            if (IsIconic(hwndSearch))
                                ShowWindow(hwndSearch, SW_SHOWNORMAL);
                        }
                    } else {

                        LoadString(hAppInstance, IDS_SEARCHTITLE, szMessage, 32);
                        lstrcat(szMessage, szSearch);

                        /* Have the MDIClient create the MDI directory window. */
                        MDICS.szClass = szSearchClass;
                        MDICS.hOwner = hAppInstance;
                        MDICS.szTitle = szMessage;
                        MDICS.style = 0;
                        MDICS.x  = CW_USEDEFAULT;
                        MDICS.y  = 0;
                        MDICS.cx = CW_USEDEFAULT;
                        MDICS.cy = 0;

                        // it would be nice to pass szSearch through here
                        // as well...

                        {
                            HWND hwnd;

                            hwnd = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE,
                                                     0, 0L);
                            MDICS.lParam = 0;
                            if (hwnd &&
                                (GetWindowLong(hwnd, GWL_STYLE) & WS_MAXIMIZE))
                                MDICS.lParam |= WS_MAXIMIZE;
                        }

                        SendMessage(hwndMDIClient, WM_MDICREATE, 0, (LPARAM)&MDICS);

                        if (hwndSearch && MDICS.lParam)
                            SendMessage(hwndMDIClient, WM_MDIMAXIMIZE, (WPARAM)hwndSearch, 0L);


                    }
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


#define RUN_LENGTH      120

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RunDlgProc() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
RunDlgProc(
          HWND hDlg,
          UINT wMsg,
          WPARAM wParam,
          LPARAM lParam
          )
{
    LPSTR p,pDir,pFile,pPar;
    register WORD ret;
    LPSTR pDir2;
    CHAR szTemp[MAXPATHLEN];
    CHAR szTemp2[MAXPATHLEN];
    CHAR sz3[RUN_LENGTH];

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            SetDlgDirectory(hDlg, NULL);
            SetWindowDirectory();          // and really set the DOS current directory

            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szTemp)-1, 0L);

            p = GetSelection(TRUE);

            if (p) {
                SetDlgItemText(hDlg, IDD_NAME, p);
                LocalFree((HANDLE)p);
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;
#if 0
                case IDD_BROWSE:
                    {
                        OPENFILENAME ofn;
                        DWORD dwSave = dwContext;

                        dwContext = IDH_RUN_BROWSE;

                        LoadString(hAppInstance, IDS_PROGRAMS, szTemp2, sizeof(szTemp2));
                        FixupNulls(szTemp2);

                        LoadString(hAppInstance, IDS_RUN, szTitle, sizeof(szTitle));

                        GetSelectedDirectory(0, szDir);
                        szTemp[0] = 0;

                        ofn.lStructSize = sizeof(ofn);
                        ofn.hwndOwner = hDlg;
                        ofn.hInstance = NULL;
                        ofn.lpstrFilter = szTemp2;
                        ofn.lpstrCustomFilter = NULL;
                        ofn.nFilterIndex = 1;
                        ofn.nMaxCustFilter = NULL;
                        ofn.lpstrFile = szTemp;
                        ofn.nMaxFile = sizeof(szTemp);
                        ofn.lpstrInitialDir = szDir;
                        ofn.lpstrTitle = szTitle;
                        ofn.lpstrFileTitle = NULL;
                        ofn.nMaxFile = sizeof(szTemp);
                        ofn.Flags = OFN_SHOWHELP|OFN_HIDEREADONLY;
                        ofn.lpfnHook = NULL;
                        ofn.lpstrDefExt = "EXE";

                        if (GetOpenFileName(&ofn)) {
                            SetDlgItemText(hDlg, IDD_NAME, szTemp);
                            PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
                        }
                        DosResetDTAAddress(); // undo any bad things COMMDLG did
                        dwContext = dwSave;

                        break;
                    }
#endif

                case IDOK:
                    {
                        BOOL bLoadIt;

                        GetDlgItemText(hDlg, IDD_NAME, szTemp, sizeof(szTemp));
                        GetPathInfo(szTemp, &pDir, &pFile, &pPar);

                        // copy away parameters
                        lstrcpy(sz3,pPar);
                        *pPar = 0;    // strip the params from the program

                        // REVIEW HACK Hard code UNC style paths.
                        if (*pDir == '\\' && *(pDir+1) == '\\') {
                            // This is a UNC style filename so NULLify directory.
                            pDir2 = NULL;
                        } else {
                            GetSelectedDirectory(0, szTemp2);
                            pDir2 = szTemp2;
                        }

                        bLoadIt = IsDlgButtonChecked(hDlg, IDD_LOAD);
                        FixAnsiPathForDos(szTemp);
                        if (pDir2)
                            FixAnsiPathForDos(pDir2);
                        ret = ExecProgram(szTemp, sz3, pDir2, bLoadIt);
                        if (ret)
                            MyMessageBox(hDlg, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
                        else
                            EndDialog(hDlg, TRUE);
                        break;
                    }

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage || wMsg == wBrowseMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


VOID
CopyToClipboard(
               LPSTR pszFrom
               )
{
    CHAR szPath[MAXPATHLEN];
    UINT wFormat;
    HANDLE hMem;

    GetNextFile(pszFrom, szPath, sizeof(szPath));

    QualifyPath(szPath);
    FixAnsiPathForDos(szPath);

    wFormat = RegisterClipboardFormat("FileName");

    if (!wFormat)
        return;

    hMem = GlobalAlloc(GPTR|GMEM_DDESHARE, lstrlen(szPath)+1);

    if (!hMem)
        return;

    lstrcpy(GlobalLock(hMem), szPath);
    GlobalUnlock(hMem);

    if (OpenClipboard(hwndFrame)) {
        EmptyClipboard();
        SetClipboardData(wFormat, hMem);
#if 0
        // write, excel and winword will not past the package
        // if we put text in the clipboard.

        hMem = GlobalAlloc(GPTR | GMEM_DDESHARE, lstrlen(szPath)+1);
        if (hMem) {
            lstrcpy(GlobalLock(hMem), szPath);
            GlobalUnlock(hMem);
            SetClipboardData(CF_OEMTEXT, hMem);
        }
#endif
        CloseClipboard();
    }

}

VOID
EnableCopy(
          HWND hDlg,
          BOOL bCopy
          )
{
    HWND hwnd;

    // turn these on
    hwnd = GetDlgItem(hDlg, IDD_COPYTOCLIP);
    if (hwnd) {
        EnableWindow(hwnd, bCopy);
        ShowWindow(hwnd, bCopy ? SW_SHOWNA : SW_HIDE);
    }

    hwnd = GetDlgItem(hDlg, IDD_COPYTOFILE);
    if (hwnd) {
        EnableWindow(hwnd, bCopy);
        ShowWindow(hwnd, bCopy ? SW_SHOWNA : SW_HIDE);
    }

    // turn these off

    hwnd = GetDlgItem(hDlg, IDD_STATUS);
    if (hwnd) {
        EnableWindow(hwnd, !bCopy);
        ShowWindow(hwnd, !bCopy ? SW_SHOWNA : SW_HIDE);
    }

    hwnd = GetDlgItem(hDlg, IDD_NAME);
    if (hwnd) {
        EnableWindow(hwnd, !bCopy);
        ShowWindow(hwnd, !bCopy ? SW_SHOWNA : SW_HIDE);
    }
}

VOID
MessWithRenameDirPath(
                     PSTR pszPath
                     )
{
    CHAR szPath[MAXPATHLEN];

    // absolute path? don't tamper with it!
    if (!lstrcmp(pszPath + 1, ":\\") ||
        (lstrlen(pszPath) > (sizeof(szPath) - 4)))
        return;

    // prepend "..\" to this non absolute path
    lstrcpy(szPath, "..\\");
    lstrcat(szPath, pszPath);
    lstrcpy(pszPath, szPath);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SuperDlgProc() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This proc handles the Print, Move, Copy, Delete, and Rename functions.
 * The calling routine (AppCommandProc()) sets 'wSuperDlgMode' before
 * calling DialogBox() to indicate which function is being used.
 */

INT_PTR
APIENTRY
SuperDlgProc(
            register HWND hDlg,
            UINT wMsg,
            WPARAM wParam,
            LPARAM lParam
            )
{
    WORD                len;
    LPSTR                pszFrom;
    CHAR                szTo[MAXPATHLEN];
    static BOOL   bTreeHasFocus;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                LPSTR  p;
                HWND  hwndActive;

                SetDlgDirectory(hDlg, NULL);

                EnableCopy(hDlg, wSuperDlgMode == IDM_COPY);

                hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
                bTreeHasFocus = (GetTreeFocus(hwndActive) == HasTreeWindow(hwndActive));

                p = GetSelection(FALSE);

                switch (wSuperDlgMode) {

                    case IDM_COPY:
                        LoadString(hAppInstance, IDS_COPY, szTitle, sizeof(szTitle));
                        SetWindowText(hDlg, szTitle);

                        if (bTreeHasFocus) {      // selection came from the tree
                            AddBackslash(p);
                            lstrcat(p, szStarDotStar);
                        }
                        break;
                    case IDM_RENAME:
                        LoadString(hAppInstance, IDS_RENAME, szTitle, sizeof(szTitle));
                        SetWindowText(hDlg, szTitle);

                        // when renaming the current directory we cd up a level
                        // (not really) and apply the appropriate hacks

                        if (bTreeHasFocus) {
                            lstrcpy(szTo, p);
                            StripFilespec(szTo);
                            SetDlgDirectory(hDlg, szTo);  // make the user think this!

                            StripPath(p);         // name part of dir
                        }
                        break;
                }

                SetDlgItemText(hDlg, IDD_FROM, p);
                LocalFree((HANDLE)p);

                if ((wSuperDlgMode == IDM_PRINT) || (wSuperDlgMode == IDM_DELETE))
                    wParam = IDD_FROM;
                else
                    wParam = IDD_TO;
                SendDlgItemMessage(hDlg, (int)wParam, EM_LIMITTEXT, sizeof(szTo) - 1, 0L);

                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                WORD id = GET_WM_COMMAND_ID(wParam, lParam);
                case IDD_HELP:
                    goto DoHelp;

                case IDD_COPYTOFILE:
                case IDD_COPYTOCLIP:
                    CheckButtons:
                    CheckRadioButton(hDlg, IDD_COPYTOCLIP, IDD_COPYTOFILE, id);
                    break;

                case IDD_TO:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_SETFOCUS) {
                        id = IDD_COPYTOFILE;
                        goto CheckButtons;
                    }
                    break;

                case IDCANCEL:
                    /* This is for when this dialog is being used to print. */
                    bUserAbort = TRUE;
                    SuperDlgExit:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    len = (WORD)(SendDlgItemMessage(hDlg, IDD_FROM, EM_LINELENGTH, -1, 0L) + 1);

                    // make sure the pszFrom buffer is big enough to
                    // add the "..\" stuff in MessWithRenameDirPath()
                    len += 4;

                    pszFrom = (LPSTR)LocalAlloc(LPTR, len);
                    if (!pszFrom)
                        goto SuperDlgExit;

                    GetDlgItemText(hDlg, IDD_FROM, pszFrom, len);
                    GetDlgItemText(hDlg, IDD_TO, szTo, sizeof(szTo));

                    if (wSuperDlgMode == IDM_COPY && IsDlgButtonChecked(hDlg, IDD_COPYTOCLIP)) {
                        CopyToClipboard(pszFrom);
                        goto SuperDlgExit;
                    }

                    if (!szTo[0]) {
                        switch (wSuperDlgMode) {
                            case IDM_RENAME:
                            case IDM_MOVE:
                                goto SuperDlgExit;

                            case IDM_COPY:
                                szTo[0] = '.';
                                szTo[1] = '\0';
                                break;
                        }
                    }

                    EnableCopy(hDlg, FALSE);

                    hdlgProgress = hDlg;
                    if (wSuperDlgMode == IDM_PRINT)
                        WFPrint(pszFrom);
                    else {

                        if (wSuperDlgMode == IDM_RENAME && bTreeHasFocus) {
                            MessWithRenameDirPath(pszFrom);
                            MessWithRenameDirPath(szTo);
                        }
                        /* HACK: Compute the FUNC_ values from WFCOPY.H */
                        WFMoveCopyDriver(pszFrom, szTo, (WORD)(wSuperDlgMode-IDM_MOVE+1));
                    }

                    LocalFree((HANDLE)pszFrom);

                    lFreeSpace = -1L;     // force status info refresh

                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


VOID
CheckAttribsDlgButton(
                     HWND hDlg,
                     INT id,
                     DWORD dwAttribs,
                     DWORD dwAttribs3State,
                     DWORD dwAttribsOn
                     )
{
    INT i;

    if (dwAttribs3State & dwAttribs)
        i = 2;
    else if (dwAttribsOn & dwAttribs)
        i = 1;
    else
        i = 0;

    CheckDlgButton(hDlg, id, i);
}

INT
InitPropertiesDialog(
                    HWND hDlg
                    )
{
    HWND hwndLB, hwndActive, hwndTree;
    DWORD_PTR dwTemp;
    HANDLE hMem;
    LPMYDTA lpmydta;
    DWORD dwAttribsOn, dwAttribs3State, dwAttribsLast;
    HWND hwndDir, hwnd;
    CHAR szName[MAXPATHLEN];
    CHAR szPath[MAXPATHLEN];
    CHAR szTemp[MAXPATHLEN + 20];
    CHAR szBuf[80];
    WCHAR szNum[30];
    INT i, iMac, iCount, dyButton;
    DWORD dwSize;
    RECT rc, rcT;
    DWORD dwAttrib;
    FILETIME Time;
    DWORD Length;
    LFNDTA lfndta;
    PSTR p;
    HFONT hFont;
    INT nType = 0;

    // this is needed for relative findfirst calls below
    SetWindowDirectory();

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    hwndDir = HasDirWindow(hwndActive);
    hwndTree = HasTreeWindow(hwndActive);

    iCount = 0;
    dwAttribsOn = 0;                // all bits to check
    dwAttribs3State = 0;    // all bits to 3 state
    dwAttribsLast = 0xFFFF; // previous bits
    dwSize = 0L;

    if (hwndTree && hwndTree == GetTreeFocus(hwndActive)) {

        SendMessage(hwndActive, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
        StripBackslash(szPath);
        FixAnsiPathForDos(szPath);
        if (!WFFindFirst(&lfndta, szPath, ATTR_ALL | ATTR_DIR)) {
            LoadString(hAppInstance, IDS_REASONS+DE_PATHNOTFOUND, szMessage, sizeof(szMessage));
            MessageBox(hwndFrame, szMessage, szPath, MB_OK | MB_ICONSTOP);
            EndDialog(hDlg, FALSE);
            return 0;
        }
        WFFindClose(&lfndta);
        OemToAnsi(szPath, szPath);
        dwAttribsOn = lfndta.fd.dwFileAttributes;
        Time = lfndta.fd.ftLastWriteTime;
        Length = lfndta.fd.nFileSizeLow; // BUG < 64 bits!

        goto FULL_PATH_KINDA_THING;
    }

    if (hwndDir) {
        hwndLB = GetDlgItem(hwndDir, IDCW_LISTBOX);
        hMem = (HANDLE)GetWindowLongPtr(hwndDir, GWLP_HDTA);
    } else {
        hwndLB = GetDlgItem(hwndActive, IDCW_LISTBOX);
        hMem = (HANDLE)GetWindowLongPtr(hwndActive, GWLP_HDTASEARCH);
    }

    iMac = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    for (i = 0; i < iMac; i++) {
        if ((BOOL)SendMessage(hwndLB, LB_GETSEL, i, 0L)) {

            // get info from either dir or search window

            if (hwndDir) {
                SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&lpmydta);
                dwAttrib = lpmydta->my_dwAttrs;
                /* Check that this is not the .. entry */

                if (dwAttrib & ATTR_DIR && dwAttrib & ATTR_PARENT)
                    continue;

                Time   = lpmydta->my_ftLastWriteTime;
                Length = lpmydta->my_nFileSizeLow;
                lstrcpy(szName, lpmydta->my_cFileName);
            } else {
                SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)szPath);
                dwTemp = SendMessage(hwndLB, LB_GETITEMDATA, i, 0L);
                dwAttrib = ((LPDTASEARCH)lpmydta)[dwTemp].sch_dwAttrs;
                Time   = ((LPDTASEARCH)lpmydta)[dwTemp].sch_ftLastWriteTime;
                Length = ((LPDTASEARCH)lpmydta)[dwTemp].sch_nFileSizeLow;
            }

            dwAttribsOn |= dwAttrib;

            if (dwAttribsLast == 0xFFFF)
                // save the previous bits for future compares
                dwAttribsLast = dwAttrib;
            else
                // remember all bits that don't compare to last bits
                dwAttribs3State |= (dwAttrib ^ dwAttribsLast);

            dwSize += Length;

            iCount++;
        }
    }

    GetDlgItemText(hDlg, IDD_TEXT, szTemp, sizeof(szTemp));
    wsprintf(szBuf, szTemp, iCount, AddCommasW(dwSize, szNum));
    SetDlgItemText(hDlg, IDD_TEXT, szBuf);

    if (iCount == 1) {
        if (hwndDir) {
            SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
        } else {
            FULL_PATH_KINDA_THING:
            lstrcpy(szName, szPath);
            StripPath(szName);
            StripFilespec(szPath);
        }
        StripBackslash(szPath);

        GetWindowText(hDlg, szTitle, sizeof(szTitle));
        wsprintf(szTemp, szTitle, (LPSTR)szName);
        SetWindowText(hDlg, szTemp);

        SetDlgItemText(hDlg, IDD_NAME, szName);
        SetDlgItemText(hDlg, IDD_DIR, szPath);

        wsprintf(szTemp, szSBytes, (LPSTR)AddCommasW(Length, szNum));
        SetDlgItemText(hDlg, IDD_SIZE, szTemp);

        PutDate(&Time, szTemp);
        lstrcat(szTemp, "  ");
        PutTime(&Time, szTemp + lstrlen(szTemp));

        SetDlgItemText(hDlg, IDD_DATE, szTemp);
    } else
        dwContext = IDH_GROUP_ATTRIBS;

    // add the network specific property buttons

    if (WNetGetCaps(WNNC_DIALOG) & WNNC_DLG_PROPERTYDIALOG) {
        GetWindowRect(GetDlgItem(hDlg,IDOK), &rcT);
        GetWindowRect(GetDlgItem(hDlg,IDCANCEL), &rc);
        dyButton = rc.top - rcT.top;

        GetWindowRect(GetDlgItem(hDlg,IDD_HELP), &rc);
        ScreenToClient(hDlg,(LPPOINT)&rc.left);
        ScreenToClient(hDlg,(LPPOINT)&rc.right);

        p = GetSelection(3);
        if (p) {

            for (i = 0; i < 6; i++) {

                if (iCount > 1)
                    nType = WNPS_MULT;
                else if (dwAttribsOn & ATTR_DIR)
                    nType = WNPS_DIR;
                else
                    nType = WNPS_FILE;

                if (WNetGetPropertyText((WORD)i, (WORD)nType, p, szTemp, 30, WNTYPE_FILE) != WN_SUCCESS)
                    break;

                if (!szTemp[0])
                    break;

                OffsetRect(&rc,0,dyButton);
                hwnd = CreateWindowEx(0, "button", szTemp,
                                      WS_VISIBLE|WS_CHILD|WS_TABSTOP|BS_PUSHBUTTON,
                                      rc.left, rc.top,
                                      rc.right - rc.left, rc.bottom-rc.top,
                                      hDlg, (HMENU)IntToPtr(i + IDD_NETWORKFIRST), hAppInstance, NULL);

                if (hwnd) {
                    hFont = (HFONT)SendDlgItemMessage(hDlg, IDOK, WM_GETFONT, 0, 0L);
                    SendMessage(hwnd, WM_SETFONT, (WPARAM)hFont, 0L);
                }
            }

            LocalFree((HANDLE)p);

            ClientToScreen(hDlg,(LPPOINT)&rc.left);
            ClientToScreen(hDlg,(LPPOINT)&rc.right);
            GetWindowRect(hDlg,&rcT);
            rc.bottom += dyButton;
            if (rcT.bottom <= rc.bottom) {
                SetWindowPos(hDlg,NULL,0,0,rcT.right-rcT.left,
                             rc.bottom - rcT.top, SWP_NOMOVE|SWP_NOZORDER);
            }
        }
    }

    // change those that don't need to be 3state to regular

    if (ATTR_READONLY & dwAttribs3State)
        SetWindowLong(GetDlgItem(hDlg, IDD_READONLY), GWL_STYLE, WS_VISIBLE | WS_GROUP | WS_TABSTOP | BS_AUTO3STATE | WS_CHILD);

    if (ATTR_HIDDEN & dwAttribs3State)
        SetWindowLong(GetDlgItem(hDlg, IDD_HIDDEN), GWL_STYLE, WS_VISIBLE | BS_AUTO3STATE | WS_CHILD);
    if (ATTR_ARCHIVE & dwAttribs3State)
        SetWindowLong(GetDlgItem(hDlg, IDD_ARCHIVE), GWL_STYLE, WS_VISIBLE |  BS_AUTO3STATE | WS_CHILD);
    if (ATTR_SYSTEM & dwAttribs3State)
        SetWindowLong(GetDlgItem(hDlg, IDD_SYSTEM), GWL_STYLE, WS_VISIBLE | BS_AUTO3STATE | WS_CHILD);

    CheckAttribsDlgButton(hDlg, IDD_READONLY, ATTR_READONLY, dwAttribs3State, dwAttribsOn);
    CheckAttribsDlgButton(hDlg, IDD_HIDDEN,   ATTR_HIDDEN, dwAttribs3State, dwAttribsOn);
    CheckAttribsDlgButton(hDlg, IDD_ARCHIVE,  ATTR_ARCHIVE, dwAttribs3State, dwAttribsOn);
    CheckAttribsDlgButton(hDlg, IDD_SYSTEM,   ATTR_SYSTEM, dwAttribs3State, dwAttribsOn);

    return nType;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AttribsDlgProc() -                                                      */
/*                                                                          */
// assumes the active MDI child has a directory window
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
AttribsDlgProc(
              register HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    LPSTR p, pSel;
    BOOL bRet;
    HCURSOR hCursor;
    DWORD dwAttribsNew, dwAttribs, dwChangeMask;
    UINT state;
    CHAR szName[MAXPATHLEN];
    static INT nType;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {

        case WM_INITDIALOG:
            nType = InitPropertiesDialog(hDlg);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDD_NETWORKFIRST+0:
                case IDD_NETWORKFIRST+1:
                case IDD_NETWORKFIRST+2:
                case IDD_NETWORKFIRST+3:
                case IDD_NETWORKFIRST+4:
                case IDD_NETWORKFIRST+5:

                    p = GetSelection(3);
                    if (p) {
                        WNetPropertyDialog(hDlg, (WORD)(GET_WM_COMMAND_ID(wParam, lParam)-IDD_NETWORKFIRST), (WORD)nType, p, WNTYPE_FILE);
                        LocalFree((HANDLE)p);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    bRet = TRUE;
                    dwChangeMask = ATTR_READWRITE;
                    dwAttribsNew = ATTR_READWRITE;

                    if ((state = IsDlgButtonChecked(hDlg, IDD_READONLY)) < 2) {
                        dwChangeMask |= ATTR_READONLY;
                        if (state == 1)
                            dwAttribsNew |= ATTR_READONLY;
                    }

                    if ((state = IsDlgButtonChecked(hDlg, IDD_HIDDEN)) < 2) {
                        dwChangeMask |= ATTR_HIDDEN;
                        if (state == 1)
                            dwAttribsNew |= ATTR_HIDDEN;
                    }

                    if ((state = IsDlgButtonChecked(hDlg, IDD_ARCHIVE)) < 2) {
                        dwChangeMask |= ATTR_ARCHIVE;
                        if (state == 1)
                            dwAttribsNew |= ATTR_ARCHIVE;
                    }

                    if ((state = IsDlgButtonChecked(hDlg, IDD_SYSTEM)) < 2) {
                        dwChangeMask |= ATTR_SYSTEM;
                        if (state == 1)
                            dwAttribsNew |= ATTR_SYSTEM;
                    }

                    EndDialog(hDlg, bRet);

                    pSel = GetSelection(FALSE);

                    if (!pSel)
                        break;

                    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    ShowCursor(TRUE);

                    DisableFSC();

                    p = pSel;

                    while (p = GetNextFile(p, szName, sizeof(szName))) {

                        QualifyPath(szName);
                        FixAnsiPathForDos(szName);

                        dwAttribs = GetFileAttributes(szName);

                        if (dwAttribs & 0x8000)     // BUG hardcoded!
                            goto AttributeError;
                        else
                            dwAttribs &= ~ATTR_DIR;

                        dwAttribs = (dwChangeMask & dwAttribsNew) | (~dwChangeMask & dwAttribs);

                        if (WFSetAttr(szName, dwAttribs)) {
                            AttributeError:
                            GetWindowText(hDlg, szTitle, sizeof(szTitle));
                            LoadString(hAppInstance, IDS_ATTRIBERR, szMessage, sizeof(szMessage));
                            MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                            bRet = FALSE;
                            break;
                        }

                        // clear all the FSC messages from the message queue
                        wfYield();
                    }

                    EnableFSC();

                    ShowCursor(FALSE);
                    SetCursor(hCursor);

                    LocalFree((HANDLE)pSel);

                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MakeDirDlgProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
MakeDirDlgProc(
              HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    CHAR szPath[MAXPATHLEN];
    INT ret;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            SetDlgDirectory(hDlg, NULL);
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szPath)-1, 0L);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    GetDlgItemText(hDlg, IDD_NAME, szPath, sizeof(szPath));

                    EndDialog(hDlg, TRUE);

                    // parse out any quoted strings

                    GetNextFile(szPath, szPath, sizeof(szPath));

                    QualifyPath(szPath);

                    hdlgProgress = hDlg;
                    if (NetCheck(szPath,WNDN_MKDIR) == WN_SUCCESS) {
                        FixAnsiPathForDos(szPath);

                        ret = WF_CreateDirectory(hDlg, szPath);
                        if (ret && ret!=DE_OPCANCELLED) {
                            if (WFIsDir(szPath))
                                ret = IDS_MAKEDIREXISTS;
                            else
                                ret += IDS_REASONS;

                            GetWindowText(hDlg, szTitle, sizeof(szTitle));
                            LoadString(hAppInstance, ret, szMessage, sizeof(szMessage));
                            MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                        }
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdlgs.h ===
#define RUNDLG		    10
#define MYPRINTDLG	    11
#define ASSOCIATEDLG	    12
#define SEARCHDLG	    13
#define MOVECOPYDLG	    14
#define DELETEDLG	    15
#define ATTRIBSDLG	    16
#define MAKEDIRDLG	    17
#define EXITDLG 	    18
#define CHOOSEDRIVEDLG	    19
#define DISKCOPYDLG	    20
#define DISKCOPY2DLG	    21
#define DISKCOPYPROGRESSDLG 22
#define DISKLABELDLG	    23
#define FORMATDLG	    24
#define FORMAT2DLG	    25
#define FORMATPROGRESSDLG   26
#define SYSDISKPROGRESSDLG  27
#define CONNECTDLG	    28
#define PREVIOUSDLG	    29
#define OTHERDLG	    30
#define SORTBYDLG	    31
#define INCLUDEDLG	    32
#define CONFIRMDLG	    33
#define DMSTATUSDLG	    35
#define PRTDLG		    36
#define CHOOSENETDRIVEDLG   37
#define MULTIPLEATTRIBSDLG	38
#define CONFIRMREPLACE		39
#define CONFIRMDELETE		40
#define CONFIRMRMDIR		41
#define CONFIRMMOVE		42
#define CONFIRMRENAME		43
#define SELECTDLG		44
#define DRIVEDLG		45
#define LFNTOFATDLG		46
#define CHOOSESYSDRIVEDLG       47
#define FONTDLG		        145

#define IDD_TEXT	    100
#define IDD_DIR 	    101
#define IDD_FROM	    102
#define IDD_TO		    103
#define IDD_STATUS	    104
#define IDD_DATE1	    105
#define IDD_DATE2	    106
#define IDD_YESALL	    107
#define IDD_TOSTATUS	    108
#define IDD_TONAME	    109


#define IDD_NAME	    201
#define IDD_TYPE	    202
#define IDD_SIZE	    203
#define IDD_DATE	    204
#define IDD_TIME	    205
#define IDD_FLAGS	    206

#define IDD_UPPERCASE	    207
#define IDD_SETDEFAULT	    208
#define IDD_ASSOC	    209
#define IDD_PROGRAMS	    210
#define IDD_DOCS	    211
#define IDD_OTHER	    212
#define IDD_FOUND	    213
#define IDD_LOAD	    214
#define IDD_READONLY	    215
#define IDD_HIDDEN	    216
#define IDD_ARCHIVE	    217
#define IDD_SYSTEM	    218
#define IDD_DELETE	    219
#define IDD_SUBDEL	    220
#define IDD_REPLACE	    221
#define IDD_DRIVE	    222
#define IDD_PATH	    223
#define IDD_PASSWORD	    224
#define IDD_ADDPREV	    225
#define IDD_PREV	    226
#define IDD_NETBROWSE	    227
#define IDD_SERVERS	    228
#define IDD_SHARES	    229
#define IDD_EXT 	    230
#define IDD_SAVESETTINGS    231
#define IDD_SEARCHALL	    232
#define IDD_HIGHCAP	    241
#define IDD_MAKESYS	    242
#define IDD_PROGRESS	    243
#define IDD_VERIFY	    244
#define IDD_DRIVE1	    245
#define IDD_DRIVE2	    246
#define IDD_DRIVE3	    247
#define IDD_DRIVE4	    248
#define IDD_MOUSE	    249
#define IDD_SHOWHIDDEN	    250
#define IDD_CONFIG	    251
#define IDD_CLOSE	    252
#define IDD_PERM	    253
#define IDD_HELP	    254
#define IDD_DISCONNECT	    255
#define IDD_COPYTOCLIP	    256
#define IDD_COPYTOFILE      257

#define IDD_CLASSLIST	   111
#define IDD_EXTENSION	   112
#define IDD_PROGRAMNAME    113

#define IDD_ASSOCFIRST	   100
#define IDD_ASSOCLAST	   110

#define IDD_NETWORKFIRST   500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdrives.c ===
//---------------------------------------------------------------------------
//
// wfdrives.c
//
// window procs and other stuff for the drive bar
//
//---------------------------------------------------------------------------

#define PUBLIC           // avoid collision with shell.h
#include "winfile.h"
#include "treectl.h"
#include "lfn.h"
#include "wfcopy.h"
#include "winnet.h"
#include <winnetp.h>


VOID InvalidateDrive(HWND hwnd, INT nDrive);
VOID RectDrive(HWND hWnd, INT nDrive, BOOL bFocusOn);
VOID GetDriveRect(HWND hWnd, INT nDrive, PRECT prc);
INT  DriveFromPoint(HWND hWnd, POINT pt);
VOID DrawDrive(HDC hdc, INT x, INT y, INT nDrive, BOOL bCurrent, BOOL bFocus);
INT  KeyToItem(HWND hWnd, WORD nDriveLetter);

VOID  GetVolShareString(WORD wDrive, LPSTR szStr);
VOID  SetVolumeString(HWND hWnd, INT nDrive);

VOID  APIENTRY CheckEscapes(LPSTR);

// create a new split tree window for the given drive
// and inherit all the properties of the current window
// the current directory is set to the DOS current directory
// for this drive.  note, this can be somewhat random given
// that windows does not keep this info for each app (it is
// global to the system)
//
// in:
//      iDrive  the driver number to create the window for
//      hwndSrc    the window to take all the properties from
//

VOID
APIENTRY
NewTree(
       INT iDrive,
       HWND hwndSrc
       )
{
    HWND hwnd, hwndTree, hwndDir;
    CHAR szDir[MAXPATHLEN * 2];
    INT dxSplit;

    ENTER("NewTree");
    PRINT(BF_PARMTRACE, "iDrive=%d", IntToPtr(iDrive));

    // make sure the floppy/net drive is still valid

    if (!CheckDrive(hwndSrc, iDrive))
        return;

    if (hwndSrc == hwndSearch)
        dxSplit = -1;
    else {
        hwndTree = HasTreeWindow(hwndSrc);
        hwndDir = HasDirWindow(hwndSrc);

        if (hwndTree && hwndDir)
            dxSplit = GetWindowLong(hwndSrc, GWL_SPLIT);
        else if (hwndDir)
            dxSplit = 0;
        else
            dxSplit = 10000;
    }

    // take all the attributes from the current window
    // (except the filespec, we may want to change this)
    wNewSort     = (WORD)GetWindowLong(hwndSrc, GWL_SORT);
    wNewView     = (WORD)GetWindowLong(hwndSrc, GWL_VIEW);
    dwNewAttribs = (DWORD)GetWindowLong(hwndSrc, GWL_ATTRIBS);

    GetSelectedDirectory((WORD)(iDrive + 1), szDir);
    AddBackslash(szDir);
    SendMessage(hwndSrc, FS_GETFILESPEC, MAXPATHLEN, (LPARAM)szDir+lstrlen(szDir));

    hwnd = CreateTreeWindow(szDir, dxSplit);

    if (hwnd && (hwndTree = HasTreeWindow(hwnd)))
        SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(FALSE, 0), 0L);

    LEAVE("NewTree");
}



VOID
SetVolumeString(
               HWND hWnd,
               INT nDrive
               )
{
    LPSTR pVol;
    CHAR szVolShare[128];

    // clean up any old label

    if (pVol = (LPSTR)GetWindowLongPtr(hWnd, GWLP_LPSTRVOLUME)) {
        LocalFree((HANDLE)pVol);
    }

    GetVolShareString((WORD)nDrive, szVolShare);

    if (pVol = (LPSTR)LocalAlloc(LPTR, lstrlen(szVolShare)+1))
        lstrcpy(pVol, szVolShare);

    SetWindowLongPtr(hWnd, GWLP_LPSTRVOLUME, (LONG_PTR)pVol);
}



VOID
GetVolShareString(
                 WORD wDrive,
                 LPSTR szStr
                 )
{
    CHAR szVolShare[128];

    GetVolShare(wDrive, szVolShare);
    wsprintf(szStr, "%c: %s", wDrive + 'A', (LPSTR)szVolShare);
}


DWORD
APIENTRY
GetVolShareExtent(
                 HWND hwndDrives
                 )
{
    HDC hdc;
    CHAR szVolShare[128];
    HFONT hOld;
    INT i;

    lstrcpy(szVolShare, (LPSTR)GetWindowLongPtr(hwndDrives, GWLP_LPSTRVOLUME));

    hdc = GetDC(hwndDrives);

    hOld = SelectObject(hdc, hFont);

    MGetTextExtent(hdc, szVolShare, lstrlen(szVolShare), &i, NULL);

    if (hOld)
        SelectObject(hdc, hOld);

    ReleaseDC(hwndDrives, hdc);

    return ((DWORD)i);
}


VOID
GetDriveRect(
            HWND hWnd,
            INT nDrive,
            PRECT prc
            )
{
    RECT rc;
    INT nDrivesPerRow;

    GetClientRect(hWnd, &rc);

    if (!dxDrive)           // avoid div by zero
        dxDrive++;

    nDrivesPerRow = rc.right / dxDrive;

    if (!nDrivesPerRow)     // avoid div by zero
        nDrivesPerRow++;

    prc->top = dyDrive * (nDrive / nDrivesPerRow);
    prc->bottom = prc->top + dyDrive;

    prc->left = dxDrive * (nDrive % nDrivesPerRow);
    prc->right = prc->left + dxDrive;
}

INT
DriveFromPoint(
              HWND hWnd,
              POINT pt
              )
{
    RECT rc, rcDrive;
    INT x, y, nDrive;

    GetClientRect(hWnd, &rc);

    x = 0;
    y = 0;
    nDrive = 0;

    for (nDrive = 0; nDrive < cDrives; nDrive++) {
        rcDrive.left = x;
        rcDrive.right = x + dxDrive;
        rcDrive.top = y;
        rcDrive.bottom = y + dyDrive;
        InflateRect(&rcDrive, -dyBorder, -dyBorder);

        if (PtInRect(&rcDrive, pt))
            return nDrive;

        x += dxDrive;

        if (x + dxDrive > rc.right) {
            x = 0;
            y += dyDrive;
        }
    }

    return -1;      // no hit
}

VOID
InvalidateDrive(
               HWND hwnd,
               INT nDrive
               )
{
    RECT rc;

    GetDriveRect(hwnd, nDrive, &rc);
    InvalidateRect(hwnd, &rc, TRUE);
}


//
// void RectDrive(HWND hWnd, int nDrive, BOOL bDraw)
//
// draw the hilight rect around the drive to indicate that it is
// the target of a drop action.
//
// in:
//      hWnd    Drives window
//      nDrive  the drive to draw the rect around
//      bDraw   if TRUE, draw a rect around this drive
//              FALSE, erase the rect (draw the default rect)
//

VOID
RectDrive(
         HWND hWnd,
         INT nDrive,
         BOOL bDraw
         )
{
    RECT rc, rcDrive;
    HBRUSH hBrush;
    HDC hdc;

    GetDriveRect(hWnd, nDrive, &rc);
    rcDrive = rc;
    InflateRect(&rc, -dyBorder, -dyBorder);

    if (bDraw) {

        hdc = GetDC(hWnd);

        hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
        if (hBrush) {
            FrameRect(hdc, &rc, hBrush);
            DeleteObject(hBrush);
        }
        ReleaseDC(hWnd, hdc);

    } else {
        InvalidateRect(hWnd, &rcDrive, TRUE);
        UpdateWindow(hWnd);
    }
}

//
// void DrawDrive(HDC hdc, int x, int y, int nDrive, BOOL bCurrent, BOOL bFocus)
//
// paint the drive icons in the standard state, given the
// drive with the focus and the current selection
//
// in:
//      hdc             dc to draw to
//      x, y            position to start (dxDrive, dyDrive are the extents)
//      nDrive          the drive to paint
//      bCurrent        draw as the current drive (pushed in)
//      bFocus          draw with the focus
//

VOID
DrawDrive(
         HDC hdc,
         INT x,
         INT y,
         INT nDrive,
         BOOL bCurrent,
         BOOL bFocus
         )
{
    RECT rc;
    CHAR szTemp[2];
    DWORD rgb;

    rc.left = x;
    rc.right = x + dxDrive;
    rc.top = y;
    rc.bottom = y + dyDrive;

    rgb = GetSysColor(COLOR_BTNTEXT);

    if (bCurrent) {
        HBRUSH hbr;

        hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
        if (hbr) {
            if (bFocus) {
                rgb = GetSysColor(COLOR_HIGHLIGHTTEXT);
                FillRect(hdc, &rc, hbr);
            } else {
                InflateRect(&rc, -dyBorder, -dyBorder);
                FrameRect(hdc, &rc, hbr);
            }
            DeleteObject(hbr);
        }
    }

    if (bFocus)
        DrawFocusRect(hdc, &rc);


    szTemp[0] = (CHAR)(chFirstDrive + rgiDrive[nDrive]);

    SetBkMode(hdc, TRANSPARENT);

    rgb = SetTextColor(hdc, rgb);
    TextOut(hdc, x + dxDriveBitmap+(dyBorder*6), y + (dyDrive - dyText) / 2, szTemp, 1);
    SetTextColor(hdc, rgb);

    BitBlt(hdc, x + 4*dyBorder, y + (dyDrive - dyDriveBitmap) / 2, dxDriveBitmap, dyDriveBitmap,
           hdcMem, rgiDrivesOffset[nDrive], 2 * dyFolder, SRCCOPY);
}


// check net/floppy drives for validity, sets the net drive bitmap
// when the thing is not available
//
// note: IsTheDiskReallyThere() has the side effect of setting the
// current drive to the new disk if it is successful

BOOL
CheckDrive(
          HWND hwnd,
          INT nDrive
          )
{
    UINT err;
    CHAR szDrive[5];
    int iDriveInd;
    return TRUE;
}


VOID
DrivesDropObject(
                HWND hWnd,
                LPDROPSTRUCT lpds
                )
{
    INT nDrive;
    CHAR szPath[MAXPATHLEN * 2];
    PSTR pFrom;
    BOOL bIconic;

    bIconic = IsIconic(GetParent(hWnd));

    if (bIconic) {
        UseCurDir:
        SendMessage(GetParent(hWnd), FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
    } else {

        nDrive = DriveFromPoint(hWnd, lpds->ptDrop);

        if (nDrive < 0)
            goto UseCurDir;
        // this searches windows in the zorder then asks dos
        // if nothing is found...

        GetSelectedDirectory((WORD)(rgiDrive[nDrive] + 1), szPath);
    }
    AddBackslash(szPath);           // add spec part
    lstrcat(szPath, szStarDotStar);

    pFrom = (PSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch);

    CheckEscapes(szPath);
    DMMoveCopyHelper(pFrom, szPath, fShowSourceBitmaps);

    if (!bIconic)
        RectDrive(hWnd, nDrive, FALSE);
}


VOID
DrivesPaint(
           HWND hWnd,
           INT nDriveFocus,
           INT nDriveCurrent
           )
{
    RECT rc;
    INT nDrive;
    CHAR szPath[MAXPATHLEN * 2];

    HDC hdc;
    PAINTSTRUCT ps;
    DWORD dw;
    WORD dxAfterDrives;
    INT x, y;
    HANDLE hOld;
    INT cDriveRows, cDrivesPerRow;

    GetClientRect(hWnd, &rc);

    if (!rc.right)
        return;

    hdc = BeginPaint(hWnd, &ps);

    hOld = SelectObject(hdc, hFont);

    cDrivesPerRow = rc.right / dxDrive;

    if (!cDrivesPerRow)
        cDrivesPerRow++;

    cDriveRows = ((cDrives-1) / cDrivesPerRow) + 1;

    x = 0;
    y = 0;
    for (nDrive = 0; nDrive < cDrives; nDrive++) {

        if (GetFocus() != hWnd)
            nDriveFocus = -1;

        DrawDrive(hdc, x, y, nDrive, nDriveCurrent == nDrive, nDriveFocus == nDrive);
        x += dxDrive;

        if (x + dxDrive > rc.right) {
            x = 0;
            y += dyDrive;
        }
    }

    // now figure out where to put that stupid volume string

    lstrcpy(szPath, (PSTR)GetWindowLongPtr(hWnd, GWLP_LPSTRVOLUME));

    MGetTextExtent(hdc, szPath, lstrlen(szPath), (INT *)&dw, NULL);

    dxAfterDrives = (WORD)(rc.right - x);

    // does it fit after the drives in the last row?

    if (dxAfterDrives < LOWORD(dw)) {
        x = dxText;               // no, flush left
        y = rc.bottom - dyText - dyBorderx2;
    } else {
        x += (dxAfterDrives - LOWORD(dw)) / 2;    // yes, centered
        y = rc.bottom - (dyDrive + dyText) / 2;
    }

    SetBkMode(hdc, TRANSPARENT);

    TextOut(hdc, x, y, szPath, lstrlen(szPath));

    if (hOld)
        SelectObject(hdc, hOld);

    EndPaint(hWnd, &ps);
}

// set the current window to a new drive
//
//

VOID
DrivesSetDrive(
              HWND hWnd,
              INT iDriveInd,
              INT nDriveCurrent
              )
{
    CHAR szPath[MAXPATHLEN * 2];

    HWND        hwndTree;
    HWND        hwndDir;

    InvalidateRect(hWnd, NULL, TRUE);

    // save the current directory on this drive for later so
    // we don't have to hit the drive to get the current directory
    // and other apps won't change this out from under us

    GetSelectedDirectory(0, szPath);
    SaveDirectory(szPath);

    // this also sets the current drive if successful

    if (!CheckDrive(hWnd, rgiDrive[iDriveInd]))
        return;

    // cause current tree read to abort if already in progress

    hwndTree = HasTreeWindow(GetParent(hWnd));
    if (hwndTree && GetWindowLong(hwndTree, GWL_READLEVEL)) {

        // bounce any clicks on a drive that is currently being read

        if (iDriveInd != nDriveCurrent)
            bCancelTree = TRUE;
        return;
    }

    // do again after in case a dialog cause the drive bar
    // to repaint

    InvalidateRect(hWnd, NULL, TRUE);

    // get this from our cache if possible

    GetSelectedDirectory((WORD)(rgiDrive[iDriveInd] + 1), szPath);

    // set the drives window parameters and repaint

    SetWindowLong(hWnd, GWL_CURDRIVEIND, iDriveInd);
    SetWindowLong(hWnd, GWL_CURDRIVEFOCUS, iDriveInd);
    SetVolumeString(hWnd, rgiDrive[iDriveInd]);

    // this is set in TC_SETDRIVE as well but the FS_CHANGEDISPLAY
    // likes to have this set before for the UpdateStatus() call

    SetWindowLong(GetParent(hWnd), GWL_TYPE, rgiDrive[iDriveInd]);

    // reset the dir first to allow tree to steal data
    // if szPath is not valid the TC_SETDRIVE will reinit
    // the files half (if there is no tree we are dicked)

    if (hwndDir = HasDirWindow(GetParent(hWnd))) {

        AddBackslash(szPath);
        SendMessage(hwndDir, FS_GETFILESPEC, MAXFILENAMELEN, (LPARAM)szPath + lstrlen(szPath));
        SendMessage(hwndDir, FS_CHANGEDISPLAY, CD_PATH_FORCE, (LPARAM)szPath);

        StripFilespec(szPath);
    }

    // do this before TC_SETDRIVE incase the tree read
    // is aborted and lFreeSpace gets set to -2L

    lFreeSpace = -1L;   // force status info refresh

    // tell the tree control to do it's thing
    if (hwndTree)
        SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(GetKeyState(VK_SHIFT) < 0, 0), (LPARAM)(szPath));
    else { // at least resize things
        RECT rc;
        GetClientRect(GetParent(hWnd), &rc);
        ResizeWindows(GetParent(hWnd),(WORD)(rc.right+1),(WORD)(rc.bottom+1));
    }

    UpdateStatus(GetParent(hWnd));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DrivesWndProc() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
DrivesWndProc(
             HWND hWnd,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    INT nDrive, nDriveCurrent, nDriveFocus;
    RECT rc;
    static INT nDriveDoubleClick = -1;
    static INT nDriveDragging = -1;

    nDriveCurrent = GetWindowLong(hWnd, GWL_CURDRIVEIND);
    nDriveFocus = GetWindowLong(hWnd, GWL_CURDRIVEFOCUS);

    switch (wMsg) {
        case WM_CREATE:
            TRACE(BF_WM_CREATE, "DrivesWndProc - WM_CREATE");
            {
                INT i;

                // Find the current drive, set the drive bitmaps

                nDrive = GetWindowLong(GetParent(hWnd), GWL_TYPE);

                SetVolumeString(hWnd, nDrive);

                for (i=0; i < cDrives; i++) {

                    if (rgiDrive[i] == nDrive) {
                        SetWindowLong(hWnd, GWL_CURDRIVEIND, i);
                        SetWindowLong(hWnd, GWL_CURDRIVEFOCUS, i);
                    }

                }
                break;
            }

        case WM_DESTROY:
            MSG("DrivesWndProc", "WM_DESTROY");
            LocalFree((HANDLE)GetWindowLongPtr(hWnd, GWLP_LPSTRVOLUME));
            break;

        case WM_VKEYTOITEM:
            KeyToItem(hWnd, (WORD)wParam);
            return -2L;
            break;

        case WM_KEYDOWN:
            MSG("DrivesWndProc", "WM_KEYDOWN");
            switch (wParam) {

                case VK_ESCAPE:
                    bCancelTree = TRUE;
                    break;

                case VK_F6:   // like excel
                case VK_TAB:
                    {
                        HWND hwndTree, hwndDir;
                        BOOL bDir;
                        DWORD dwTemp;

                        GetTreeWindows(GetParent(hWnd), &hwndTree, &hwndDir, NULL);

                        // Check to see if we can change to the directory window

                        bDir = hwndDir ? TRUE : FALSE;
                        if (bDir) {
                            HWND hwndLB; /* Local scope ONLY */

                            hwndLB = GetDlgItem (hwndDir,IDCW_LISTBOX);
                            if (hwndLB) {
                                SendMessage (hwndLB,LB_GETTEXT,0,(LPARAM) &dwTemp);
                                bDir = dwTemp ? TRUE : FALSE;
                            }
                        }

                        if (GetKeyState(VK_SHIFT) < 0) {
                            if (bDir)
                                SetFocus (hwndDir);
                            else
                                SetFocus (hwndTree ? hwndTree : hWnd);
                        } else
                            SetFocus (hwndTree ? hwndTree :
                                      (bDir ? hwndDir : hWnd));
                        break;
                    }

                case VK_RETURN:               // same as double click
                    NewTree(rgiDrive[nDriveFocus], GetParent(hWnd));
                    break;

                case VK_SPACE:                // same as single click
                    SendMessage(hWnd, FS_SETDRIVE, nDriveFocus, 0L);
                    break;

                case VK_LEFT:
                    nDrive = max(nDriveFocus-1, 0);
                    break;

                case VK_RIGHT:
                    nDrive = min(nDriveFocus+1, cDrives-1);
                    break;
            }

            if ((wParam == VK_LEFT) || (wParam == VK_RIGHT)) {

                SetWindowLong(hWnd, GWL_CURDRIVEFOCUS, nDrive);

                GetDriveRect(hWnd, nDriveFocus, &rc);
                InvalidateRect(hWnd, &rc, TRUE);
                GetDriveRect(hWnd, nDrive, &rc);
                InvalidateRect(hWnd, &rc, TRUE);
            } else if ((wParam >= 'A') && (wParam <= 'Z'))
                KeyToItem(hWnd, (WORD)wParam);

            break;

        case FS_GETDRIVE:
            MSG("DrivesWndProc", "FS_GETDRIVE");
            {
                POINT pt;

                MPOINT2POINT(MAKEMPOINT(lParam), pt);
                nDrive = DriveFromPoint(hWnd, pt);

                if (nDrive < 0)
                    nDrive = nDriveCurrent;

                return rgiDrive[nDrive] + 'A';
            }

        case WM_DRAGMOVE:
            MSG("DrivesWndProc", "WM_DRAGSELECT/WM_DRAGMOVE");

#define lpds ((LPDROPSTRUCT)lParam)

            nDrive = DriveFromPoint(hWnd, lpds->ptDrop);

#if 0
            {
                char buf[100];

                wsprintf(buf, "WM_DRAGSELECT nDrive=%d nDriveDragging=%d\r\n", nDrive, nDriveDragging);
                OutputDebugString(buf);
            }
#endif
            // turn off?

            if ((nDrive != nDriveDragging) && (nDriveDragging >= 0)) {

                RectDrive(hWnd, nDriveDragging, FALSE);
                nDriveDragging = -1;
            }

            // turn on?

            if ((nDrive >= 0) && (nDrive != nDriveDragging)) {
                RectDrive(hWnd, nDrive, TRUE);
                nDriveDragging = nDrive;
            }

            break;

        case WM_DRAGSELECT:
#define lpds ((LPDROPSTRUCT)lParam)

#if 0
            {
                char buf[100];

                wsprintf(buf, "WM_DRAGSELECT wParam=%d\r\n", wParam);
                OutputDebugString(buf);
            }
#endif
            if (wParam) {
                // entered, turn it on
                nDriveDragging = DriveFromPoint(hWnd, lpds->ptDrop);
                if (nDriveDragging >= 0)
                    RectDrive(hWnd, nDriveDragging, TRUE);
            } else {
                // leaving, turn it off
                if (nDriveDragging >= 0)
                    RectDrive(hWnd, nDriveDragging, FALSE);
            }

            break;

        case WM_QUERYDROPOBJECT:
            MSG("DrivesWndProc", "WM_QUERYDROPOBJECT");
            /* Validate the format. */
#define lpds ((LPDROPSTRUCT)lParam)

            // if (DriveFromPoint(hWnd, lpds->ptDrop) < 0)
            //    return FALSE;

            switch (lpds->wFmt) {
                case DOF_EXECUTABLE:
                case DOF_DIRECTORY:
                case DOF_MULTIPLE:
                case DOF_DOCUMENT:
                    return (INT_PTR)GetMoveCopyCursor();
                default:
                    return FALSE;
            }
            break;

        case WM_DROPOBJECT:
            MSG("DrivesWndProc", "WM_DROPOBJECT");
            DrivesDropObject(hWnd, (LPDROPSTRUCT)lParam);
            return TRUE;

        case WM_SETFOCUS:
            MSG("DrivesWndProc", "WM_SETFOCUS");
            SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)hWnd);
            // fall through

        case WM_KILLFOCUS:

            MSG("DrivesWndProc", "WM_KILLFOCUS");
            GetDriveRect(hWnd, nDriveFocus, &rc);
            InvalidateRect(hWnd, &rc, TRUE);
            break;

        case WM_PAINT:
            DrivesPaint(hWnd, nDriveFocus, nDriveCurrent);
            break;

        case WM_MDIACTIVATE:
            /*  we're not an MDI child, but the real MDI child proc
                is sending us this so we can handle the following problem.
                nDriveDoubleClick is static, and is shared by all the child window
                drivewindow instances.  If the user rapidly clicks two child window
                drivewindows, then we can mistakenly interpret the second click
                as a double click in the first window.
            */
            if (!wParam && (nDriveDoubleClick != -1))
                /* terminate wait for doubleclick, make it a single click */
                SendMessage(hWnd,WM_TIMER,1,0L);
            break;


        case WM_TIMER:
            MSG("DrivesWndProc", "WM_TIMER");

            KillTimer(hWnd, wParam);
            if (nDriveDoubleClick > -1)
                SendMessage(hWnd, FS_SETDRIVE, nDriveDoubleClick, 0L); // single click action

            nDriveDoubleClick = -1; // default

            break;

        case WM_LBUTTONDOWN:

            MSG("DrivesWndProc", "WM_LBUTTONDOWN");
            {
                POINT pt;

                MPOINT2POINT(MAKEMPOINT(lParam), pt);
                nDrive = DriveFromPoint(hWnd, pt);
                if (nDrive < 0)
                /* clicked outside of drive box */
                {
                    if (nDriveDoubleClick == -2)
                    /* legit doubleclick outside */
                    {
                        nDriveDoubleClick = -1; // default value
                        KillTimer(hWnd, 1);
                        PostMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_DRIVESMORE, 0, 0));
                    } else /* first click outside */ {
                        if (nDriveDoubleClick != -1) // fast click on drivebox then outside drivebox
                            /* igonre first click, user is a spaz */
                            KillTimer(hWnd, 1);
                        nDriveDoubleClick = -2; // see WM_TIMER
                        SetTimer(hWnd, 1, GetDoubleClickTime(), NULL);
                    }
                } else {
                    if (nDriveDoubleClick == nDrive)
                    /* double click in drivebox */
                    {
                        nDriveDoubleClick = -1; // default
                        KillTimer(hWnd, 1);

                        InvalidateRect(hWnd, NULL, TRUE);   // erase the rect from the click

                        NewTree(rgiDrive[nDrive], GetParent(hWnd)); // double click action
                    } else if (nDriveDoubleClick == -2) // fast click outside drive then in drivebox
                    /* do nothing, user is a spaz */
                    {
                        KillTimer(hWnd, 1);
                        nDriveDoubleClick = -1;
                    } else { // legit first click in drivebox
                        nDriveDoubleClick = nDrive;
                        SetTimer(hWnd, 1, GetDoubleClickTime(), NULL);
                    }
                }
            }

            break;

        case FS_SETDRIVE:
            MSG("DrivesWndProc", "FS_SETDRIVE");
            // wParam     the drive index to set
            // lParam     not used

            DrivesSetDrive(hWnd, (WORD)wParam, nDriveCurrent);
            break;


        default:
            DEFMSG("DrivesWndProc", (WORD)wMsg);
            return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}

/* Returns nDrive if found, else -1 */
INT
KeyToItem(
         HWND hWnd,
         WORD nDriveLetter
         )
{
    INT nDrive;

    if (nDriveLetter > 'Z')
        nDriveLetter -= 'a';
    else
        nDriveLetter -= 'A';

    for (nDrive = 0; nDrive < cDrives; nDrive++) {
        if (rgiDrive[nDrive] == (int)nDriveLetter) {
            SendMessage(hWnd, FS_SETDRIVE, nDrive, 0L);
            return nDrive;
        }
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfext.c ===
//-------------------------------------------------------------------------
// File Manager Extensions support routines
//
//
// radical
//
//-------------------------------------------------------------------------

#include "winfile.h"
#include "winnet.h"


LONG
GetExtSelection(
               HWND hWnd,
               WORD wItem,
               LPFMS_GETFILESEL lpSel,
               BOOL bSearch,
               BOOL bGetCount,
               BOOL bLFNAware
               )
{
    HANDLE hDTA;
    LPMYDTA lpmydta;
    LPDTASEARCH lpdtasch, lpdtaschT;
    INT count, sel_ind, i;
    HWND hwndLB;
    CHAR szPath[MAXPATHLEN];
    FMS_GETFILESEL file;

    if (bGetCount)
        lpSel = &file;

    if (bSearch) {
        hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTASEARCH);
        lpdtasch = (LPDTASEARCH)LocalLock(hDTA);
        hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX);
    } else {
        hDTA = (HANDLE)GetWindowLongPtr(HasDirWindow(hWnd), GWLP_HDTA);
        hwndLB = GetDlgItem(HasDirWindow(hWnd), IDCW_LISTBOX);
        LocalLock(hDTA);
    }

    count = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    sel_ind = 0;            // index of current selected item

    for (i = 0; i < count; i++) {

        if ((BOOL)SendMessage(hwndLB, LB_GETSEL, i, 0L)) {

            if (bSearch) {

                lpdtaschT = &(lpdtasch[(INT)SendMessage(hwndLB, LB_GETITEMDATA, i, 0L)]);

                SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)szPath);
                lpSel->bAttr = (BYTE)lpdtaschT->sch_dwAttrs;
                lpSel->ftTime = lpdtaschT->sch_ftLastWriteTime;
                lpSel->dwSize = lpdtaschT->sch_nFileSizeLow;
            } else {

                SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&lpmydta);

                if (lpmydta->my_dwAttrs & ATTR_PARENT)
                    continue;

                SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                lstrcat(szPath, lpmydta->my_cFileName);
                lpSel->bAttr = (BYTE)lpmydta->my_dwAttrs;
                lpSel->ftTime = lpmydta->my_ftLastWriteTime;
                lpSel->dwSize = lpmydta->my_nFileSizeLow;
            }
            // skip LFN stuff for non LFN aware dudes!

            if (!bLFNAware && (lpSel->bAttr & ATTR_LFN))
                continue;

            FixAnsiPathForDos(szPath);
            lstrcpy(lpSel->szName, szPath);

            if (!bGetCount) {

                if (wItem == (WORD)sel_ind)
                    goto BailOutDude;
            }

            sel_ind++;
        }
    }

    BailOutDude:
    LocalUnlock(hDTA);

    return (LONG)sel_ind;
}



LONG
GetDriveInfo(
            HWND hwnd,
            LPFMS_GETDRIVEINFO lpSel
            )
{
    CHAR szPath[MAXPATHLEN];
    CHAR szVol[14];

    // this has to work for hwnd a tree or search window

    SendMessage(hwnd, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
    StripBackslash(szPath);
    FixAnsiPathForDos(szPath);

    lstrcpy(lpSel->szPath, szPath);
    lpSel->dwTotalSpace = lTotalSpace;
    lpSel->dwFreeSpace = lFreeSpace;
    GetVolumeLabel((szPath[0] & ~0x20) - 'A', szVol, FALSE);
    lstrcpy(lpSel->szVolume, szVol);
    szPath[2] = 0;
    if (WFGetConnection(szPath, lpSel->szShare, FALSE) != WN_SUCCESS)
        lpSel->szShare[0] = 0;

    return 1L;
}


VOID
APIENTRY
FreeExtensions()
{
    INT i;
    HMENU hMenuFrame;
    INT iMax;
    HWND hwndActive;

    hMenuFrame = GetMenu(hwndFrame);
    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
        iMax = 1;
    else
        iMax = 0;

    for (i = 0; i < iNumExtensions; i++) {
        (extensions[i].ExtProc)(NULL, FMEVENT_UNLOAD, 0L);
        DeleteMenu(hMenuFrame, IDM_EXTENSIONS + iMax, MF_BYPOSITION);
        FreeLibrary((HANDLE)extensions[i].hModule);
    }
    iNumExtensions = 0;
}


INT_PTR
APIENTRY
ExtensionMsgProc(
                UINT wMsg,
                WPARAM wParam,
                LPARAM lParam
                )
{
    HWND hwndActive;
    HWND hwndTree, hwndDir, hwndDrives, hwndFocus;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    GetTreeWindows(hwndActive, &hwndTree, &hwndDir, &hwndDrives);

    switch (wMsg) {

        case FM_RELOAD_EXTENSIONS:
            SendMessage(hwndFrame, WM_CANCELMODE, 0, 0L);
            FreeExtensions();
            InitExtensions();
            DrawMenuBar(hwndFrame);
            break;

        case FM_GETFOCUS:
            // wParam       unused
            // lParam       unused
            // return       window tyep with focus

            if (hwndActive == hwndSearch)
                return FMFOCUS_SEARCH;

            hwndFocus = GetTreeFocus(hwndActive);

            if (hwndFocus == hwndTree)
                return FMFOCUS_TREE;
            else if (hwndFocus == hwndDir)
                return FMFOCUS_DIR;
            else if (hwndFocus == hwndDrives)
                return FMFOCUS_DRIVES;
            break;

        case FM_GETDRIVEINFO:
            // wParam       unused
            // lParam       LPFMS_GETDRIVEINFO structure to be filled in

            return GetDriveInfo(hwndActive, (LPFMS_GETDRIVEINFO)lParam);

            break;

        case FM_REFRESH_WINDOWS:
            // wParam       0 refresh the current window
            //              non zero refresh all windows
            // lParam       unused

            if (wParam == 0)
                RefreshWindow(hwndActive);
            else {
                HWND hwndT, hwndNext;

                hwndT = GetWindow(hwndMDIClient, GW_CHILD);
                while (hwndT) {
                    hwndNext = GetWindow(hwndT, GW_HWNDNEXT);
                    if (!GetWindow(hwndT, GW_OWNER))
                        RefreshWindow(hwndT);
                    hwndT = hwndNext;
                }
            }
            lFreeSpace = -1L;
            UpdateStatus(hwndActive);
            break;

        case FM_GETSELCOUNT:
        case FM_GETSELCOUNTLFN:
            // wParam       unused
            // lParam       unused
            // return       # of selected items

        case FM_GETFILESEL:
        case FM_GETFILESELLFN:
            // wParam       index of selected item to get
            // lParam       LPFMS_GETFILESEL structure to be filled in

            if (hwndActive != hwndSearch && !hwndDir)
                return 0L;

            // note, this uses the fact that LFN messages are odd!

            return GetExtSelection(hwndActive, (WORD)wParam, (LPFMS_GETFILESEL)lParam,
                                   hwndActive == hwndSearch, (wMsg & ~1) == FM_GETSELCOUNT,
                                   (BOOL)(wMsg & 1));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfext.h ===
//
// File Manager Extensions definitions
//

#define MENU_TEXT_LEN       40

#define FMMENU_FIRST        1
#define FMMENU_LAST     99

#define FMEVENT_LOAD        100
#define FMEVENT_UNLOAD      101
#define FMEVENT_INITMENU    102
#define FMEVENT_USER_REFRESH    103
#define FMEVENT_SELCHANGE        104

#define FMFOCUS_DIR                1
#define FMFOCUS_TREE                2
#define FMFOCUS_DRIVES                3
#define FMFOCUS_SEARCH                4

#define FM_GETFOCUS     (WM_USER + 0x0200)
#define FM_GETDRIVEINFO     (WM_USER + 0x0201)
#define FM_GETSELCOUNT      (WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN   (WM_USER + 0x0203)  // LFN versions are odd
#define FM_GETFILESEL       (WM_USER + 0x0204)
#define FM_GETFILESELLFN    (WM_USER + 0x0205)  // LFN versions are odd
#define FM_REFRESH_WINDOWS  (WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS    (WM_USER + 0x0207)

typedef struct _FMS_GETFILESEL {
    FILETIME ftTime;
    DWORD dwSize;
    BYTE bAttr;
    CHAR szName[260];       // alwyas fully qualified
} FMS_GETFILESEL, FAR *LPFMS_GETFILESEL;

typedef struct _FMS_GETDRIVEINFO {  // for drive
    DWORD dwTotalSpace;
    DWORD dwFreeSpace;
    CHAR szPath[260];       // current directory
    CHAR szVolume[14];      // volume label
    CHAR szShare[128];      // if this is a net drive
} FMS_GETDRIVEINFO, FAR *LPFMS_GETDRIVEINFO;

typedef struct _FMS_LOAD {
    DWORD dwSize;               // for version checks
    CHAR  szMenuName[MENU_TEXT_LEN];    // output
    HMENU hMenu;                // output
    WORD  wMenuDelta;           // input
} FMS_LOAD, FAR *LPFMS_LOAD;


typedef INT_PTR (APIENTRY *FM_EXT_PROC)(HWND, WPARAM, LPARAM);
typedef DWORD (APIENTRY *FM_UNDELETE_PROC)(HWND, LPSTR);


//------------------ private stuff ---------------------------        /* ;Internal */
                                                                /* ;Internal */
typedef struct _EXTENSION {                                        /* ;Internal */
        INT_PTR (APIENTRY *ExtProc)(HWND, WPARAM, LPARAM);                /* ;Internal */
        WORD        Delta;                                                /* ;Internal */
        HANDLE        hModule;                                        /* ;Internal */
        HMENU         hMenu;                                                /* ;Internal */
        DWORD   dwFlags;                                        /* ;Internal */
} EXTENSION;                                                        /* ;Internal */
                                                                /* ;Internal */
#define MAX_EXTENSIONS 5                                        /* ;Internal */
extern EXTENSION extensions[MAX_EXTENSIONS];                        /* ;Internal */
                                                                /* ;Internal */
INT_PTR APIENTRY ExtensionMsgProc(UINT wMsg, WPARAM wParam, LPARAM lpSel);/* ;Internal */
VOID APIENTRY FreeExtensions(VOID);                                     /* ;Internal */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfformat.c ===
/****************************************************************************/
/*                                                                          */
/*  WFFORMAT.C -                                                            */
/*                                                                          */
/*      Windows File Manager Diskette Formatting Routines                   */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"


/* MyGetDriveType() returns */
#define NOCHANGE            0
#define CHANGE              1

/* Parameter Block for IOCTL Format call */
struct FORMATPARAMS {
    BYTE   bSpl;                    /* Special byte */
    WORD   wHead;
    WORD   wCylinder;
};


typedef struct _MEDIASENSE {
    BYTE IsDefault;
    BYTE DeviceType;
    BYTE res[10];
} MEDIASENSE;


/*--------------------------------------------------------------------------*/
/*  BIOS Parameter Block Table for Removable Media                          */
/*--------------------------------------------------------------------------*/

/* Each entry contains data about a floppy drive type in the following format:
 *                                                          Length
 *      cbSec               - Bytes/Sector                    2
 *      secPerClus          - Sectors/Cluster                 1
 *      cSecRes             - # of Reserved Sectors           2
 *      cFAT                - # of FATs                       1
 *      cDir                - # of Root Directory Entries     2
 *      cSec                - # of Sectors on the disk        2
 *      bMedia              - Media Descriptor Byte           1
 *      secPerFAT           - Sectors/FAT                     2
 *      secPerTrack         - Sectors/Track                   2
 *      cHead               - # of Disk Heads                 2
 *      cSecHidden          - # of Hidden Sectors             2
 */

BPB     bpbList[] =
{
    {512, 1, 1, 2,  64,  1*8*40, MEDIA_160,  1,  8, 1, 0}, /*  8sec SS 48tpi 160KB 5.25" DOS 1.0 & above */
    {512, 2, 1, 2, 112,  2*8*40, MEDIA_320,  1,  8, 2, 0}, /*  8sec DS 48tpi 320KB 5.25" DOS 1.1 & above */
    {512, 1, 1, 2,  64,  1*9*40, MEDIA_180,  2,  9, 1, 0}, /*  9sec SS 48tpi 180KB 5.25" DOS 2.0 & above */
    {512, 2, 1, 2, 112,  2*9*40, MEDIA_360,  2,  9, 2, 0}, /*  9sec DS 48tpi 360KB 5.25" DOS 2.0 & above */
    {512, 1, 1, 2, 224, 2*15*80, MEDIA_1200, 7, 15, 2, 0}, /* 15sec DS 96tpi 1.2MB 5.25" DOS 3.0 & above */
    {512, 2, 1, 2, 112,  2*9*80, MEDIA_720,  3,  9, 2, 0}, /*  9sec DS 96tpi 720KB  3.5" DOS 3.2 & above */
    {512, 1, 1, 2, 224, 2*18*80, MEDIA_1440, 9, 18, 2, 0}, /* 18sec DS 96tpi 1.44M  3.5" DOS 3.3 & above */
    {512, 2, 1, 2, 240, 2*36*80, MEDIA_2880, 9, 36, 2, 0}  /* 36sec DS 96tpi 2.88M  3.5" DOS 5.0 & above */
};


/* Precompute the total number of usable clusters...
 *   cCluster = (cSec/secPerClus) - { cSecRes
 *                                    + (cFAT * secPerFat)
 *                                    + (cDir*32+cbSec-1)/cbSec }/secPerClus;
 */
WORD cCluster[] = {0x0139, 0x013B, 0x015F, 0x0162, 0x0943, 0x02C9, 0x0B1F, 0xB2F, 0};





/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  BuildDevPB() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HANDLE
APIENTRY
BuildDevPB(
          PDevPB pDevPB
          )
{
    WORD              wCount;
    register HANDLE   hNewDevPB;
    PDevPB            pNewDevPB;
    WORD              wSecSize;
    register WORD     *wPtr;
    WORD              wTrackNumber;

    wCount = pDevPB->BPB.secPerTrack;

    if (!(hNewDevPB = LocalAlloc(LHND, TRACKLAYOUT_OFFSET+2+wCount*4)))
        return NULL;

    pNewDevPB = (PDevPB)LocalLock(hNewDevPB);

    memcpy(pNewDevPB, pDevPB, TRACKLAYOUT_OFFSET);
    wSecSize = pDevPB->BPB.cbSec;

    wPtr = (WORD *)((LPSTR)pNewDevPB + TRACKLAYOUT_OFFSET);
    *wPtr++ = wCount;

    for (wTrackNumber=1; wTrackNumber <= wCount; wTrackNumber++) {
        *wPtr++ = wTrackNumber;
        *wPtr++ = wSecSize;
    }

    LocalUnlock(hNewDevPB);
    return hNewDevPB;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SetDevParamsForFormat() -                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
SetDevParamsForFormat(
                     INT nDrive,
                     PDevPB pDevPB,
                     BOOL fLowCapacity
                     )
{
    HANDLE   hLocHandle;
    PDevPB   pNewDevPB;

    /* Allocate for the DPB with track layout */
    if (!(hLocHandle = BuildDevPB(pDevPB)))
        return FALSE;

    pNewDevPB = (PDevPB)LocalLock(hLocHandle);

    pNewDevPB->SplFunctions = 5;
    /* Is this a 360KB floppy in a 1.2Mb drive */
    if (fLowCapacity) {
        /* Yes! Then change the number of cylinders and Media type */
        /* Fix for Bug #???? --SANKAR-- 01-10-90 -- */
        pNewDevPB->NumCyls = 40;
        pNewDevPB->bMediaType = 1;
    }

    LocalUnlock(hLocHandle);
    LocalFree(hLocHandle);

    return TRUE;

}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GenericFormatTrack() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This calls IOCTL format if DOS ver >= 3.2; Else calls BIOS.
 *
 *  Returns : 0 if no error
 *          > 0 if tolerable error (resuling in bad sectors);
 *          -1  if fatal error (Format has to be aborted);
 */

INT
APIENTRY
GenericFormatTrack(
                  WORD nDisk,
                  WORD wCylinder,
                  WORD wHead,
                  WORD wSecPerTrack,
                  LPSTR lpDiskBuffer
                  )
{
    struct FORMATPARAMS   FormatParams;
    INT                   iRetVal = -1;   /* FATAL Error by default */
    register INT          iErrCode;

#ifdef DEBUG
    wsprintf(szMessage, "Formatting Head #%d, Cylinder#%d\n\r", wHead, wCylinder);
    OutputDebugString(szMessage);
#endif

    /* Check the DOS version */
    if (wDOSversion >= DOS_320) {
        FormatParams.bSpl = 0;
        FormatParams.wHead = wHead;
        FormatParams.wCylinder = wCylinder;
        switch (iErrCode = 0) {
            case NOERROR:
            case CRCERROR:
            case SECNOTFOUND:
            case GENERALERROR:
                iRetVal = iErrCode;
                break;
        }
    } else {
        switch (iErrCode = FormatTrackHead(nDisk, wCylinder, wHead, wSecPerTrack, lpDiskBuffer)) {
            case NOERROR:
            case DATAERROR:
            case ADDMARKNOTFOUND:
            case SECTORNOTFOUND:
                iRetVal = iErrCode;
                break;
        }
    }
    return (iRetVal);
}


INT  APIENTRY GetMediaType(INT nDrive)
{
    return 0;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FormatFloppy() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

// note, the below comment is out of date.  leave for reference only

/* The Format routine is intended to mimic the actions of the FORMAT command
 * on MSDOS.  We restrict the possible set of operations that Format must use
 * in order to simplify life. The RESTRICTIONS are:
 *
 *  -- If the drive selected for formatting is a Quad density drive, then the
 *         user will be asked if he wants to format it for 1.2 MB or 360 KB
 *         and the format will proceed accordingly;
 *  -- For all other types of drives, it will format the disk to the maximum
 *         capacity that the drive can handle.
 *
 * The requirements for Format are:
 *
 *  1) there be a disk in a "source" drive that contains a valid boot sector
 *  2) there be a disk in a "destination" drive that is formattable.
 *
 * The algorithm for determining a drive's capacity is as follows:
 *
 *      If Source == Destination then
 *          error
 *      If dosversion >= 3.20
 *       {
 *         Use generic get_device_parameters and Get BPB.
 *         if (the drive is a Quad density drive (1.2 MB), and if user wants
 *             to format for 360KB), take BPB for 360KB from the bpbList[].
 *         In all other cases, use the BPB of the device.
 *       }
 *      else
 *       {
 *         Ask INT 13 for the drive type.
 *         If error then {
 *            assume 48tpi double side
 *            Attempt to format track 0, head 1
 *            If error then
 *               assume 48tpi single side
 *         else
 *            if sectors per track = 15 then
 *                assume 96tpi
 *                Ask user if he wants to format for 1.2MB or 360KB and
 *                use the proper BPB from bpbList[]
 *            else
 *                error
 *       }
 *
 * Note that this does NOT take into account non-contiguous drive letters
 * (see 3.2 spec) nor future drives nor user-installed device drivers.
 *
 * Format (dSrc, nDstDrive, nDstDriveInt13) will format drive nDstDrive using an updated
 * boot sector from drive dSrc. We will allocate two blocks of memory, but
 * only one at a time.  The first one we allocate is the bit-map of bad
 * clusters that we find during the format.  The second is for the boot
 * sector.
 *
 *  Returns:    0           Success
 *              <> 0        error code
 *                      1 =>  NOMEMORY
 *                      3 =>  Invalid boot sector.
 *                      4 =>  System area of the floppy is bad
 *                      7 =>  Problem in writing in Dest diskette.
 *                      8 =>  Internal error
 *                      9 =>  Format has been aborted by user.
 */

// in:
//     hWnd            window to base messages on
//
//     nSource         drive to swipe boot stuff from
//
//     nDest           drive to format
//
//     iCapacity       SS48
//                     DS48
//                     DS96
//                     DS720KB
//                     DS144M
//                     DS288M
//                     -1      (device capacity)
//
//     bMakeSysDisk    make a system disk too
//
//     bQuick          do a quick format
//
// returns:
//     0               success
//     != 0            error
//

INT
APIENTRY
FormatFloppy(
            HWND hWnd,
            WORD nDest,
            INT iCapacity,
            BOOL bMakeSysDisk,
            BOOL bQuick
            )
{
    DPB           DPB;
    DBT           dbtSave;                /* Disk Base Table */
    INT           iErrCode;
    PBPB pBPB;
    WORD          w;
    WORD          cClusters;
    WORD          wFATValue;
    WORD          wBadCluster;
    WORD          cBadSectors;
    WORD          cTotalTracks;
    WORD          wCurrentHead;
    WORD          wPercentDone;
    WORD          wCurrentTrack;
    WORD          cTracksToFormat;
    WORD          wFirstDataSector;
    WORD      nSource;
    DevPB         dpbDiskParms;           /* Device Parameters */
    LPDBT         lpDBT;
    LPSTR         lpDiskBuffer;
    LPSTR         lpBadClusterList;
    HANDLE        hDiskBuffer;
    HANDLE        hBadClusterList;
    HANDLE        hSaveDiskParms = NULL;
    PDevPB        pdpbSaveDiskParms;
    CHAR          szMsg[128];
    BOOL          fLowCapacity = FALSE; /* Is a 360KB floppy in a 1.2MB drive? */
    INT           ret = 0;        // default to success

    nSource = (WORD)GetBootDisk();

    /* Initialize for cleanup. */
    hDiskBuffer      = NULL;
    lpDiskBuffer     = NULL;
    hBadClusterList  = NULL;
    lpBadClusterList = NULL;
    bUserAbort       = FALSE;

    /* Create a dialogbox that displays the progress of formatting; and also
     * gives the user a chance to abort formatting at anytime.
     */
    hdlgProgress = CreateDialog(hAppInstance, MAKEINTRESOURCE(FORMATPROGRESSDLG), hWnd, ProgressDlgProc);
    if (!hdlgProgress) {
        ret = IDS_FFERR_MEM;      // out of memory
        goto FFErrExit1;
    }

    EnableWindow(hWnd, FALSE);

    /* Flush to DOS disk buffers. */
    DiskReset();

    /* Get the Disk Base Table. */
    if (!(lpDBT = GetDBT())) {
        ret = IDS_FFERR_MEM;
        goto FFErrExit2;
    }

    dbtSave = *lpDBT;

    // this checks to see if we are trying to format the boot drive
    // this is a no no

    if ((nDest == nSource) || (!IsRemovableDrive(nDest))) {
        ret = IDS_FFERR_SRCEQDST;
        goto FFErrExit3;
    }

    /* Check if the sector size is of standard size; If not report error */
    if (HIWORD(GetClusterInfo(nSource)) > CBSECTORSIZE) {
        ret = IDS_FFERR_SECSIZE;
        goto FFErrExit3;
    }

    /* Allocate boot sector, sector buffer, track buffer */
    if (!(hDiskBuffer = LocalAlloc(LHND, (LONG)(2*CBSECTORSIZE)))) {
        ret = IDS_FFERR_MEM;
        goto FFErrExit3;
    }

    lpDiskBuffer = LocalLock(hDiskBuffer);


    /* If DOS Version is 3.2 or above, use DeviceParameters() to get the BPB. */
    if (wDOSversion >= DOS_320) {

        /* NOTE: All the fields of dpbDiskParms must be initialized to 0,
         *           otherwise, INT 21h, Function 44h, Subfunction 0Dh does NOT work;
         *           This function is called in DeviceParameters().
         */
        memset(&dpbDiskParms, 0, sizeof(DevPB));
        pBPB = &(dpbDiskParms.BPB);

        if (iCapacity != -1) {

            w = (WORD)GetMediaType(nDest);

            if (w) {
                switch (w) {
                    case 2:         // 720
                        if (iCapacity > DS720KB) {
                            w = IDS_720KB;
                            iCapacity = DS720KB;
                        } else
                            goto SensePass;
                        break;

                    case 7:         // 1.44
                        if (iCapacity > DS144M) {
                            w = IDS_144MB;
                            iCapacity = DS144M;
                        } else
                            goto SensePass;
                        break;
                    default:        // 2.88 and unknown case
                        goto SensePass;
                }

                LoadString(hAppInstance, IDS_FFERR_MEDIASENSE, szMsg, sizeof(szMsg));
                LoadString(hAppInstance, w, szTitle, sizeof(szTitle));
                wsprintf(szMessage, szMsg, (LPSTR)szTitle);
                LoadString(hAppInstance, IDS_FORMATERR, szTitle, sizeof(szTitle));
                if (MessageBox(hdlgProgress, szMessage, szTitle, MB_YESNO | MB_ICONINFORMATION) != IDYES) {
                    ret = IDS_FFERR_USERABORT;
                    goto FFErrExit3;
                }
            }

            SensePass:

            pBPB = &bpbList[iCapacity];
            cClusters = cCluster[iCapacity];

            // if we are formatting a 360K disk in a 1.2 MB drive set this
            // special flag

            if (iCapacity == DS48) {
                // We must remember to change the number of cylinders
                // while doing Set Device parameters; So, set this flag;
                fLowCapacity = TRUE;
            }
        } else {
            DWORD dwSec = pBPB->cSec;

            // use the default device parameters
            // NOTE: pBPB already points to proper data

            /* HPVECTRA: DOS 3.2 and above gives wrong sector count. */
            if (!pBPB->cSec)
                dwSec = dpbDiskParms.NumCyls * pBPB->secPerTrack * pBPB->cHead;

            /* Calculate the clusters for the disk. */
            cClusters = (WORD)(dwSec / pBPB->secPerClus) -
                        (pBPB->cSecRes + (pBPB->cFAT * pBPB->secPerFAT) +
                         (pBPB->cDir*32 + pBPB->cbSec - 1) / pBPB->cbSec) / pBPB->secPerClus;
        }

        /* Save the DriveParameterBlock for restoration latter */
        hSaveDiskParms = BuildDevPB(&dpbDiskParms);
        if (!hSaveDiskParms) {
            ret = IDS_FFERR_MEM;
            goto FFErrExit3;
        }
        pdpbSaveDiskParms = (PDevPB)LocalLock(hSaveDiskParms);

        /* Modify the parameters just for format */
        memcpy(&(dpbDiskParms.BPB), pBPB, sizeof(BPB));
        if (!SetDevParamsForFormat(nDest, &dpbDiskParms, fLowCapacity)) {
            ret = IDS_FFERR_MEM;
            goto FFErrExit3;
        }

    } else {
        // DOS < 3.2

        /* See if INT 13 knows the drive type. */
        switch (MyGetDriveType(nDest)) {
            case NOCHANGE:
                /* We assume that the machine is using old ROMS...
                 * Assume that we are using a 9-sector Double-sided 48tpi diskette.
                 */
                pBPB = &bpbList[DS48];
                cClusters = cCluster[DS48];
                lpDBT->lastsector = (BYTE)pBPB->secPerTrack;
                lpDBT->gaplengthf = 0x50;

                /* Try to format a track on side 1.  If this fails, assume that we
                 * have a Single-sided 48tpi diskette.
                 */
                if (FormatTrackHead(nDest, 0, 1, pBPB->secPerTrack, lpDiskBuffer)) {
                    pBPB = &bpbList[SS48];
                    cClusters = cCluster[SS48];
                }
                break;

            case CHANGE:
                if (iCapacity == DS48) {
                    /* User wants to format a 360KB floppy. */
                    pBPB = &bpbList[DS48];
                    cClusters = cCluster[DS48];
                } else {
                    /* User wants to format a 1.2 MB floppy */
                    pBPB = &bpbList[DS96];
                    cClusters = cCluster[DS96];
                }
                break;

            default:
                ret = IDS_FFERR_DRIVETYPE;
                goto FFErrExit5;
        }
    }

    lpDBT->lastsector = (BYTE)pBPB->secPerTrack;
    lpDBT->gaplengthf = (BYTE)(pBPB->secPerTrack == 15 ? 0x54 : 0x50);

    if (wDOSversion < DOS_320) {
        /* If 96tpi, fix up the Disk Base Table. */
        if (pBPB->bMedia == MEDIA_1200)      /* high density */
            if (pBPB->secPerTrack == 15)     /* then 1.2 Meg Drive */
                SetDASD(nDest, 3);           /* 1.2 MB floppy in 1.2MB drive */
    }

    LoadString(hAppInstance, IDS_PERCENTCOMP, szMsg, sizeof(szMsg));

    /* We believe that we know EXACTLY what is out there.  Allocate the boot
     * sector and the bad-cluster bit-map.  The boot sector buffer is reused as
     * two consecutive sectors of the FAT.
     */
    if (!(hBadClusterList = LocalAlloc(LHND, (LONG)((2 + cClusters + 7) / 8)))) {
        ret = IDS_FFERR_MEM;
        goto FFErrExit5;
    }

    lpBadClusterList = LocalLock(hBadClusterList);

    /* Let's format 1 track at a time and record the bad sectors in the
     * bitmap.  Note that we round DOWN the number of tracks so that we
     * don't format what might not be ours.  Fail if there are any bad
     * sectors in the system area.
     */

    /* Compute number of tracks to format. */
    if (!pBPB->cSec)
        cTracksToFormat = (WORD)dpbDiskParms.NumCyls;
    else
        cTracksToFormat = (WORD)(pBPB->cSec / pBPB->secPerTrack);


    /* Compute the starting track and head. */
    wCurrentTrack = pBPB->cSecHidden / (pBPB->secPerTrack * pBPB->cHead);
    wCurrentHead = (pBPB->cSecHidden % (pBPB->secPerTrack * pBPB->cHead))/pBPB->secPerTrack;

    /* Compute the number of the first sector after the system area. */
    wFirstDataSector = pBPB->cSecRes + pBPB->cFAT * pBPB->secPerFAT +
                       (pBPB->cDir * 32 + pBPB->cbSec-1) / pBPB->cbSec;

    cTotalTracks = cTracksToFormat;

    if (bQuick) {

        // read the boot sector to make sure the capacity selected
        // matches what it has been formated to

        iErrCode = GenericReadWriteSector(lpDiskBuffer, INT13_READ, nDest, 0, 0, 1);

        if (iErrCode || ((iCapacity != -1) && ((BOOTSEC *)lpDiskBuffer)->BPB.bMedia != bpbList[iCapacity].bMedia)) {

            fFormatFlags &= ~FF_QUICK;
            bQuick = FALSE;

            LoadString(hAppInstance, IDS_FORMATQUICKFAILURE, szMessage, 128);
            LoadString(hAppInstance, IDS_FORMAT, szTitle, 128);

            iErrCode = MessageBox(hdlgProgress, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION);

            if (iErrCode == IDYES)
                goto NormalFormat;
            else {
                ret = IDS_FFERR_USERABORT;
                goto FFErrExit;
            }
        }

    } else {

        NormalFormat:

        /* Format tracks one by one, checking if the user has "Aborted"
        * after each track is formatted; DlgProgreeProc() will set the global
        * bUserAbort, if the user has aborted;
        */
        while (cTracksToFormat) {

            /* Has the user aborted? */
            if (WFQueryAbort()) {
                ret = IDS_FFERR_USERABORT;
                goto FFErrExit;
            }

            /* If no message is pending, go ahead and format one track */
            if ((iErrCode = GenericFormatTrack(nDest, wCurrentTrack, wCurrentHead, pBPB->secPerTrack, lpDiskBuffer))) {

                /* Check if it is a fatal error */
                if (iErrCode == -1) {
                    // ret = IDS_FFERR_BADTRACK;
                    ret = IDS_FFERR;
                    goto FFErrExit;
                }

                /* Bad Track.  Compute the number of the first bad sector */
                cBadSectors = (wCurrentTrack * pBPB->cHead + wCurrentHead) * pBPB->secPerTrack;

                /* Fail if bad sector is in the system area */
                if (cBadSectors < wFirstDataSector) {
                    // ret = IDS_FFERR_BADTRACK;
                    ret = IDS_FFERR;
                    goto FFErrExit;
                }

                /* Enumerate all bad sectors and mark the corresponding
                * clusters as bad.
                */
                for (w=cBadSectors; w < cBadSectors + pBPB->secPerTrack; w++) {
                    wBadCluster = (w - wFirstDataSector) / pBPB->secPerClus + 2;
                    lpBadClusterList[wBadCluster/8] |= 1 << (wBadCluster % 8);
                }
            }

            cTracksToFormat--;

            /* Display the percentage of progress message */
            wPercentDone = (WORD)MulDiv(cTotalTracks - cTracksToFormat, 100, cTotalTracks);

            /* All tracks might have been formatted. But,
            * Still FAT and Root dir are to be created; It takes time; So,
            * make the user believe that still 1% formatting is left.
            */
            if (wPercentDone == 100)
                LoadString(hAppInstance, IDS_CREATEROOT, szMessage, sizeof(szMessage));
            else
                wsprintf(szMessage, szMsg, wPercentDone);

            SendDlgItemMessage(hdlgProgress, IDD_PROGRESS, WM_SETTEXT, 0, (LPARAM)szMessage);

            if (++wCurrentHead >= pBPB->cHead) {
                wCurrentHead = 0;
                wCurrentTrack++;
            }
        }
    }

    /* Write out the boot sector(s). */
    w = (WORD)WriteBootSector(nSource, nDest, pBPB, lpDiskBuffer);
    if (w) {
        // ret = IDS_FFERR_WRITEBOOT;
        if (w == 0x16)            // int24 unknown command, assume
            ret = IDS_SYSDISKNOFILES; // the int25 read failed
        else
            ret = IDS_FFERR;
        goto FFErrExit;
    }

    /* Has the user aborted? */
    if (WFQueryAbort()) {
        ret = IDS_FFERR_USERABORT;
        goto FFErrExit;
    }

    /* Format is complete.  Create correct DPB in system */
    SetDPB(nDest, pBPB, &DPB);

    // if doing a quick format keep the old bad cluster list

    /* Create FAT entries for each of the formatted clusters. */
    for (w=2; w < (WORD)(cClusters+2); w++) {

        if (bQuick) {
            wFATValue = 0;

            // is this entry reserved or marked as bad

            if ((wFATValue >= 0xFFF0) &&
                (wFATValue <= 0xFFF7)) {
                // yes, don't change it!
            } else {
                // mark as free

                if (0) {
                    // ret = IDS_FFERR_WRITEFAT;
                    ret = IDS_FFERR;
                    goto FFErrExit;
                }
            }

        } else {
            /* Was this cluster bad? */
            if (lpBadClusterList[w/8] & (1 << (w % 8)))
                wFATValue = 0xFFF7;
            else
                wFATValue = 0;

            /* Add this entry to the FAT (possibly writing the sector). */
            if (0) {
                // ret = IDS_FFERR_WRITEFAT;
                ret = IDS_FFERR;
                goto FFErrExit;
            }

        }
        if (WFQueryAbort()) {           /* Has the user aborted? */
            ret = IDS_FFERR_USERABORT;
            goto FFErrExit;
        }
    }

    /* Clean out the root directory. */
    memset(lpDiskBuffer, 0, CBSECTORSIZE);

    for (w=0; w < (WORD)((pBPB->cDir*32 + pBPB->cbSec-1)/pBPB->cbSec); w++) {
        /* Has the user aborted? */
        if (WFQueryAbort()) {
            ret = IDS_FFERR_USERABORT;
            goto FFErrExit;
        }
    }

    /* Should we make it a system disk also? */
    if (bMakeSysDisk) {
        LoadString(hAppInstance, IDS_COPYSYSFILES, szMessage, 32);
        SendDlgItemMessage(hdlgProgress, IDD_PROGRESS, WM_SETTEXT, 0, (LPARAM)szMessage);
        if (MakeSystemDiskette(nDest, TRUE)) {
            if (bUserAbort)
                ret = IDS_FFERR_USERABORT;
            else
                ret = IDS_FFERR_SYSFILES;
            goto FFErrExit;
        }
    }

    /* Normal Exit. */

    LocalUnlock(hBadClusterList);
    LocalFree(hBadClusterList);
    LocalUnlock(hDiskBuffer);

    if (hSaveDiskParms) {
        /* Restore the DriveParameterBlock */
        pdpbSaveDiskParms->SplFunctions = 4;

        LocalUnlock(hSaveDiskParms);
        LocalFree(hSaveDiskParms);
    }

    LocalFree(hDiskBuffer);
    *lpDBT = dbtSave;
    EnableWindow(hWnd, TRUE);
    DestroyWindow(hdlgProgress);
    hdlgProgress = NULL;
    return TRUE;

    FFErrExit:
    LocalUnlock(hBadClusterList);
    LocalFree(hBadClusterList);
    FFErrExit5:
    if (hSaveDiskParms) {
        /* Restore the DriveParameterBlock */
        pdpbSaveDiskParms->SplFunctions = 4;

        LocalUnlock(hSaveDiskParms);
        LocalFree(hSaveDiskParms);
    }
    LocalUnlock(hDiskBuffer);
    LocalFree(hDiskBuffer);
    FFErrExit3:
    *lpDBT = dbtSave;
    FFErrExit2:
    EnableWindow(hWnd, TRUE);
    DestroyWindow(hdlgProgress);
    hdlgProgress = NULL;
    FFErrExit1:

    if (ret != IDS_FFERR_USERABORT) {
        LoadString(hAppInstance, IDS_FORMATERR, szTitle, sizeof(szTitle));
        LoadString(hAppInstance, ret, szMessage, sizeof(szMessage));
        MessageBox(hWnd, szMessage, szTitle, MB_OK | MB_ICONSTOP);
    }
    return FALSE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetDriveCapacity() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Parameter:
 *    Drive number;
 * Returns:
 *    0  if Error;
 *    1  if 360KB floppy;
 *    2  if 1.2MB floppy;
 *    3  if 720KB, 3.5" floppy;
 *    4  if 1.44MB, 3.5" floppy;
 *    5  if 2.88MB, 3.5" floppy;
 *
 * these are used +2 as indexes into bpbList[] FIX31
 *
 * HACK ALERT:
 *    One might wonder why on earth we are not using int13h Fn 8 to
 * perform this function; The reason is that in old compaq 386/16
 * machines(though the BIOS is dated Sep 1986), this function is NOT
 * supported! So, we are forced to do the following:
 *    We check the DOS version; If it is >= 3.2, then we make IOCTL
 * calls to get the Drive parameters and we find the Drive capacity;
 * If DOS version is < 3.2, then there can't be 3.5" floppies at all;
 * The only high capacity floppy possible is the 5.25", 1.2MB floppy;
 * So, we call MyGetDriveType() (int13h, Fn 15h) to find if the
 * change-line is supported by the drive; If it is supported then it
 * must be a 1.2MB floppy; Otherwise, it is a 360KB floppy;
 *    What do you think?  Smart! Ugh?
 */

WORD
APIENTRY
GetDriveCapacity(
                WORD nDrive
                )
{
    DevPB dpbDiskParms;           /* Device Parameters */
    PBPB pBPB;


    if (wDOSversion >= DOS_320) {

        /* NOTE: All the fields of dpbDiskParms must be initialized to 0,
         *   otherwise, INT 21h, Function 44h, Subfunction 0Dh does NOT work;
         *   This function is called in DeviceParameters().
         */
        memset(&dpbDiskParms, 0, sizeof(DevPB));
        dpbDiskParms.SplFunctions = 0;

        pBPB = &(dpbDiskParms.BPB);

        /* Check if this is a 1.44MB drive */
        if (pBPB->bMedia == MEDIA_1440) {
            if (pBPB->secPerTrack == 18)
                return 4;     /* 1.44MB drive */
            else if (pBPB->secPerTrack == 36)
                return 5;     /* 2.88MB drive */
        }

        /* Check if this is a 720KB or 1.2MB drive */
        if (pBPB->bMedia == MEDIA_1200) {
            if (pBPB->secPerFAT == 3)
                return 3; /* 720KB drive */
            if (pBPB->secPerFAT == 7)
                return 2; /* 1.2MB drive */
        }

        if (pBPB->bMedia == MEDIA_360)
            return 1;       /* Must be a 386KB floppy. */

        return 0;                 // I don't know!
    } else {

        /* See if INT 13 Fn 15h knows the drive type. */
        switch (MyGetDriveType(nDrive)) {
            case NOCHANGE:
                /* We assume that the machine is using old ROMS... */
                return 1;  /* No changeline support! Must be 360KB floppy */
                break;

            case CHANGE:
                return 2;  /* DOS versions < 3.2 can not have 1.44 or 720KB
                             * drive; So, this has to be a 1.2MB drive
                             */
                break;
            default:
                return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfdos.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDOS.C -                                                               */
/*                                                                          */
/*      Ported code from wfdos.asm                                          */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"

DWORD
APIENTRY
GetExtendedError()
{
    return (GetLastError());     // temp fix, called by IsDiskReallyThere().
}


VOID
APIENTRY
DosGetDTAAddress()
{
}


VOID
APIENTRY
DosResetDTAAddress()
{
}


DWORD
APIENTRY
GetFreeDiskSpace(
                WORD wDrive
                )
{
    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwTotalClusters;

    if (GetDiskFreeSpace(GetRootPath(wDrive),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters)) {
        return (dwFreeClusters * dwSectorsPerCluster * dwBytesPerSector);
    } else {
        return (0);
    }
}


DWORD
APIENTRY
GetTotalDiskSpace(
                 WORD wDrive
                 )
{
    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwTotalClusters;

    if (GetDiskFreeSpace(GetRootPath(wDrive),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters)) {
        return (dwTotalClusters * dwSectorsPerCluster * dwBytesPerSector);
    } else {
        return (0);
    }
}


INT
APIENTRY
ChangeVolumeLabel(
                 INT nDrive,
                 LPSTR lpNewVolName
                 )
{
    UNREFERENCED_PARAMETER(nDrive);
    UNREFERENCED_PARAMETER(lpNewVolName);
    return (0);

}



INT
APIENTRY
GetVolumeLabel(
              INT nDrive,
              LPSTR lpszVol,
              BOOL bBrackets
              )
{
    *lpszVol = 0;

    if (apVolInfo[nDrive] == NULL)
        FillVolumeInfo(nDrive);

    if (apVolInfo[nDrive]) {

        if ((BOOL)*apVolInfo[nDrive]->szVolumeName)
            lstrcpy(&lpszVol[bBrackets ? 1 : 0],
                    apVolInfo[nDrive]->szVolumeName);
        else
            return (0);

    } else {
        return (0);
    }

    if (bBrackets) {
        lpszVol[0] = '[';
        lstrcat(lpszVol, "]");
    }
    return (1);
}


INT
APIENTRY
DeleteVolumeLabel(
                 INT nDrive
                 )
{
    UNREFERENCED_PARAMETER(nDrive);
    return (0);
}


HFILE
APIENTRY
CreateVolumeFile(
                LPSTR lpFileName
                )
{
    UNREFERENCED_PARAMETER(lpFileName);
    return (0);
}



VOID
APIENTRY
FillVolumeInfo(
              INT iVol
              )
{
    VOLINFO vi;

    vi.dwDriveType = rgiDriveType[iVol];

    if (GetVolumeInformation(
                            GetRootPath((WORD)iVol),
                            &vi.szVolumeName[0], MAX_VOLNAME,
                            &vi.dwVolumeSerialNumber,
                            &vi.dwMaximumComponentLength,
                            &vi.dwFileSystemFlags,
                            &vi.szFileSysName[0], MAX_FILESYSNAME)) {;

        if (apVolInfo[iVol] == NULL)
            apVolInfo[iVol] = LocalAlloc(LPTR, sizeof(VOLINFO));
        
        if (apVolInfo[iVol])
            *apVolInfo[iVol] = vi;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wffile.c ===
/****************************************************************************/
/*                                      */
/*  WFFILE.C -                                          */
/*                                      */
/*  Ported code from wffile.asm                                         */
/*                                      */
/****************************************************************************/

#include "winfile.h"

WORD
APIENTRY
MKDir(
     LPSTR pName
     )
{
    WORD wErr = 0;

    if (CreateDirectory(pName, NULL)) {
        ChangeFileSystem(FSC_MKDIR,pName,NULL);
    } else {
        wErr = (WORD)GetLastError();
    }

    return (wErr);
}


WORD
APIENTRY
RMDir(
     LPSTR pName
     )
{
    WORD wErr = 0;

    if (RemoveDirectory(pName)) {
        ChangeFileSystem(FSC_RMDIR,pName,NULL);
    } else {
        wErr = (WORD)GetLastError();
    }

    return (wErr);
}



BOOL
APIENTRY
WFSetAttr(
         LPSTR lpFile,
         DWORD dwAttr
         )
{
    BOOL bRet;

    bRet = SetFileAttributes(lpFile,dwAttr);
    if (bRet)
        ChangeFileSystem(FSC_ATTRIBUTES,lpFile,NULL);

    return (BOOL)!bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfgwl.h ===
typedef struct {
    HWND  hwnd;
    HWND  hwndLastFocus;
    WORD  wDriveNum;
    WORD  wView;
    BOOL  fFSCFlag;
    WORD  wSort;
    DWORD dwAttribs;
    INT   iSplit;
    LPTREECTLDATA lptcd;
    LPDIRDDATA    lpdird;
    LPDRIVESDATA  lpdrvd;
} TREEDATA, FAR *LPTREEDATA;

typedef struct {
    HWND  hwnd;
    INT   iReadLevel;
    HWND  hwndLB;
    LPTREEDATA lptreed;
} TREECTLDATA, FAR *LPTREECTLDATA;

typedef struct {
    HWND   hwnd;
    INT    iFirstTab;
    HANDLE hDTA;
    HWND   hwndLB;
    LPTREEDATA lptreed;
} DIRDATA, FAR *LPDIRDATA;

typedef struct {
    HWND  hwnd;
    LPSTR lpstrVolume;
    INT   iCurDriveInd;
    INT   iCurDriveFocus;
    LPTREEDATA lptreed;
} DRIVESDATA, FAR *LPDRIVESDATA;

typedef struct {
    HWND  hwnd;
    WORD  wDriveNum;
    WORD  wView;
    BOOL  fFSCFlag;
    WORD  wSort;
    DWORD dwAttribs;
    HANDLE hDTASearch;
    HWND  hwndLB;
    LPTREEDATA lptreed;
} SEARCHDATA, FAR *LPSEARCHDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wffsc.c ===
/****************************************************************************
 *                                      *
 *  WFFSC.ASM -                                 *
 *                                      *
 *  WINFILE's File System Change Notification Handler           *
 *                                      *
 ****************************************************************************/

#include "winfile.h"


VOID
APIENTRY
KernelChangeFileSystem(
                      LPSTR lpFile,
                      WORD wDosFunc
                      )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfhelp.h ===
#define IDH_HELPFIRST		5000
#define IDH_SYSMENU	(IDH_HELPFIRST + 2000)

#define IDH_MBFIRST		(IDH_HELPFIRST + 2001)
#define IDH_ASSOC_BROWSE	(IDH_HELPFIRST + 2002)
// NB Removed IDH_RUN_BROWSE_
#define IDH_FONT 		(IDH_HELPFIRST + 2004)
#define IDH_MBLAST		(IDH_HELPFIRST + 2099)

#define IDH_DLGFIRST	(IDH_HELPFIRST + 3000)

#define IDH_MB_FORMATCURERR	(IDH_MBFIRST + 0)

#define IDH_DLG_PREV		(IDH_DLGFIRST + PREVIOUSDLG)
#define IDH_DLG_CONFIRMREPLACE	(IDH_DLGFIRST + CONFIRMREPLACE)
#define IDH_DLG_CONFIRMRMDIR	(IDH_DLGFIRST + CONFIRMRMDIR)
#define IDH_DLG_CONFIRMRENAME	(IDH_DLGFIRST + CONFIRMRENAME)
#define IDH_DLG_CONFIRMMOVE	(IDH_DLGFIRST + CONFIRMMOVE)
#define IDH_DLG_CONFIRMDEL	(IDH_DLGFIRST + CONFIRMDELETE)


#define IDH_FILE 	(IDM_FILE + IDH_HELPFIRST)
#define IDH_OPEN 	(IDM_OPEN + IDH_HELPFIRST)
#define IDH_PRINT 	(IDM_PRINT + IDH_HELPFIRST)
#define IDH_ASSOCIATE 	(IDM_ASSOCIATE + IDH_HELPFIRST)
#define IDH_SEARCH 	(IDM_SEARCH + IDH_HELPFIRST)
#define IDH_RUN  	(IDM_RUN  + IDH_HELPFIRST)
#define IDH_MOVE 	(IDM_MOVE + IDH_HELPFIRST)
#define IDH_COPY 	(IDM_COPY + IDH_HELPFIRST)
#define IDH_DELETE 	(IDM_DELETE + IDH_HELPFIRST)
#define IDH_RENAME 	(IDM_RENAME + IDH_HELPFIRST)
#define IDH_ATTRIBS 	(IDM_ATTRIBS + IDH_HELPFIRST)
#define IDH_MAKEDIR 	(IDM_MAKEDIR + IDH_HELPFIRST)
#define IDH_SELALL 	(IDM_SELALL + IDH_HELPFIRST)
#define IDH_DESELALL 	(IDM_DESELALL + IDH_HELPFIRST)
#define IDH_UNDO 	(IDM_UNDO + IDH_HELPFIRST)
#define IDH_EXIT 	(IDM_EXIT + IDH_HELPFIRST)
#define IDH_SELECT 	(IDM_SELECT + IDH_HELPFIRST)
#define IDH_UNDELETE 	(IDM_UNDELETE + IDH_HELPFIRST)
#define IDH_GROUP_ATTRIBS 	(118 + IDH_HELPFIRST)
#define IDH_DISK 	(IDM_DISK + IDH_HELPFIRST)
#define IDH_DISKCOPY 	(IDM_DISKCOPY + IDH_HELPFIRST)
#define IDH_LABEL 	(IDM_LABEL + IDH_HELPFIRST)
#define IDH_FORMAT 	(IDM_FORMAT + IDH_HELPFIRST)
#define IDH_SYSDISK 	(IDM_SYSDISK + IDH_HELPFIRST)
#define IDH_CONNECT 	(IDM_CONNECT + IDH_HELPFIRST)
#define IDH_DISCONNECT 	(IDM_DISCONNECT + IDH_HELPFIRST)
#define IDH_CONNECTIONS (IDM_CONNECTIONS + IDH_HELPFIRST)
#define IDH_DRIVESMORE 	(IDM_DRIVESMORE + IDH_HELPFIRST)
#define IDH_TREE 	(IDM_TREE + IDH_HELPFIRST)
#define IDH_EXPONE 	(IDM_EXPONE + IDH_HELPFIRST)
#define IDH_EXPSUB 	(IDM_EXPSUB + IDH_HELPFIRST)
#define IDH_EXPALL 	(IDM_EXPALL + IDH_HELPFIRST)
#define IDH_COLLAPSE 	(IDM_COLLAPSE + IDH_HELPFIRST)
#define IDH_VIEW 	(IDM_VIEW + IDH_HELPFIRST)
#define IDH_VNAME 	(IDM_VNAME + IDH_HELPFIRST)
#define IDH_VDETAILS 	(IDM_VDETAILS + IDH_HELPFIRST)
#define IDH_VOTHER 	(IDM_VOTHER + IDH_HELPFIRST)
#define IDH_BYNAME 	(IDM_BYNAME + IDH_HELPFIRST)
#define IDH_BYTYPE 	(IDM_BYTYPE + IDH_HELPFIRST)
#define IDH_BYSIZE 	(IDM_BYSIZE + IDH_HELPFIRST)
#define IDH_BYDATE 	(IDM_BYDATE + IDH_HELPFIRST)
#define IDH_VINCLUDE 	(IDM_VINCLUDE + IDH_HELPFIRST)
#define IDH_REPLACE 	(IDM_REPLACE + IDH_HELPFIRST)
#define IDH_TREEONLY 	(IDM_TREEONLY + IDH_HELPFIRST)
#define IDH_DIRONLY 	(IDM_DIRONLY + IDH_HELPFIRST)
#define IDH_BOTH 	(IDM_BOTH + IDH_HELPFIRST)
#define IDH_SPLIT 	(IDM_SPLIT + IDH_HELPFIRST)
#define IDH_OPTIONS 	(IDM_OPTIONS + IDH_HELPFIRST)
#define IDH_CONFIRM 	(IDM_CONFIRM + IDH_HELPFIRST)
#define IDH_FONT_MENU 	(IDM_FONT + IDH_HELPFIRST)
#define IDH_LOWERCASE 	(IDM_LOWERCASE + IDH_HELPFIRST)
#define IDH_STATUSBAR 	(IDM_STATUSBAR + IDH_HELPFIRST)
#define IDH_MINONRUN 	(IDM_MINONRUN + IDH_HELPFIRST)
#define IDH_ADDPLUSES 	(IDM_ADDPLUSES + IDH_HELPFIRST)
#define IDH_EXPANDTREE 	(IDM_EXPANDTREE + IDH_HELPFIRST)
#define IDH_SAVESETTINGS 	(IDM_SAVESETTINGS + IDH_HELPFIRST)
#define IDH_EXTENSIONS 	(IDM_EXTENSIONS + IDH_HELPFIRST)
#define IDH_WINDOW 	(IDM_WINDOW + IDH_HELPFIRST)
#define IDH_CASCADE 	(IDM_CASCADE + IDH_HELPFIRST)
#define IDH_TILE 	(IDM_TILE + IDH_HELPFIRST)
#define IDH_REFRESH 	(IDM_REFRESH + IDH_HELPFIRST)
#define IDH_CLOSEALL 	(IDM_CLOSEALL + IDH_HELPFIRST)
#define IDH_CHILDSTART 	(IDM_CHILDSTART + IDH_HELPFIRST)
#define IDH_SAVE 	(IDM_SAVE + IDH_HELPFIRST)
#define IDH_ARRANGE 	(IDM_ARRANGE + IDH_HELPFIRST)
#define IDH_NEWWINDOW 	(IDM_NEWWINDOW + IDH_HELPFIRST)
#define IDH_HELPGENERAL (IDM_HELP + IDH_HELPFIRST)
#define IDH_HELPINDEX 	(IDM_HELPINDEX + IDH_HELPFIRST)
#define IDH_HELPKEYS 	(IDM_HELPKEYS + IDH_HELPFIRST)
#define IDH_HELPCOMMANDS 	(IDM_HELPCOMMANDS + IDH_HELPFIRST)
#define IDH_HELPPROCS 	(IDM_HELPPROCS + IDH_HELPFIRST)
#define IDH_HELPHELP 	(IDM_HELPHELP + IDH_HELPFIRST)
#define IDH_ABOUT 	(IDM_ABOUT + IDH_HELPFIRST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wflabel.c ===
/****************************************************************************/
/*                                      */
/*  WFLABEL.C -                                 */
/*                                      */
/*  Windows File System Diskette Labelling Routines             */
/*                                      */
/****************************************************************************/

#include "winfile.h"
//#include "lstrfns.h"

/*--------------------------------------------------------------------------*/
/*                                      */
/*  CreateVolumeLabel() -                           */
/*                                      */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
CreateVolumeLabel(
                 INT nDrive,
                 LPSTR lpNewVolLabel
                 )
{
    HFILE     fh;
    register INT  i;
    register LPSTR p;
    CHAR      szFullVolName[16];      /* Sample: A:\12345678.EXT,\0 */
    LPSTR         lpStart = lpNewVolLabel;

    lstrcpy((LPSTR)szFullVolName, GetRootPath((WORD)nDrive));

    /* If the volume label has more than 8 chars, we must seperate the
     * name and the extension by a '.'
     */

    p = &szFullVolName[3];

    /* Copy the file 8 characters of the VolLabel */
    for (i=0; i < 8; i++) {
        if (!(*p++ = *lpNewVolLabel++))
            break;
    }

    if (i == 8) {
        /* Seperate the extension part of it with a '.' */
        *p++ = '.';

        /* Copy the extension */
        i = 0;
        while (*p++ = *lpNewVolLabel++) {
            if (++i == 3) {
                /* Make sure we do not end on a lead byte; notice this is not
                 * necessary if the label came from an edit box with
                 * EM_LIMITEXT of 11; also notice that according to the
                 * DBCS seminar notes, we do NOT need this check before the '.'
                 */
                for (lpNewVolLabel=lpStart; lpNewVolLabel-lpStart<11;
                    lpNewVolLabel = AnsiNext(lpNewVolLabel))
                    /* do nothing */ ;
                if (lpNewVolLabel-lpStart > 11)
                    --p;
                *p = TEXT('\0');
                break;
            }
        }
    }

    /* Create a file with the attribute "VOLUME LABEL" */
    if ((fh = CreateVolumeFile(szFullVolName)) == 0)
        return (-1);

    M_lclose(fh);
    return (0);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  SetVolumeLabel() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
MySetVolumeLabel(
                INT nDrive,
                BOOL bOldVolLabelExists,
                LPSTR lpNewVolLabel
                )
{
    INT   iRet = 0;
    CHAR  szTemp[MAXFILENAMELEN];

    AnsiToOem(lpNewVolLabel, szTemp);

    // invalid chars copied from DOS user docs

#ifdef STRCSPN_IS_DEFINED_OR_LABEL_MENUITEM_IS_ENABLED
    if (szTemp[StrCSpn(szTemp, " *?/\\|.,;:+=[]()&^<>\"")] != '\0')
        return (-1);
#endif

    /* Check if there is an old volume label. */
    if (bOldVolLabelExists) {
        /* Are we changing or deleting the volume label? */
        if (*szTemp) {
            /* Yup! There is a new one too! So, change the Vol label */
// EDH ChangeVolumeLabel cannot change label to an existing dir/file name,
//     since it uses the DOS Rename to do the work. (I consider this a bug
//     in DOS' Rename func.)  Anyway, use delete/create to change label
//     instead.  13 Oct 91
//    iRet = ChangeVolumeLabel(nDrive, szTemp);
            iRet = DeleteVolumeLabel(nDrive);
            iRet = CreateVolumeLabel(nDrive, szTemp);
        } else {
            /* User wants to remove the Vol label. Remove it */
            iRet = DeleteVolumeLabel(nDrive);
        }
    } else {
        /* We are creating a new label. */
        if (*szTemp)
            iRet = CreateVolumeLabel(nDrive, szTemp);
    }

    return (iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfprint.c ===
/****************************************************************************/
/*                                                                          */
/*  WFPRINT.C -                                                             */
/*                                                                          */
/*      Windows Print Routines                                              */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winexp.h"

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PrintFile() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD
PrintFile(
         HWND hwnd,
         LPSTR szFile
         )
{
    WORD          ret;
    INT           iCurCount;
    INT           i;
    HCURSOR       hCursor;

    ret = 0;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    iCurCount = ShowCursor(TRUE) - 1;

    /* open the object            +++ ShellExecute() returns an hInstance?!?!?
     */
    ret = (WORD)RealShellExecute(hwnd, "print", szFile, "", NULL, NULL, NULL, NULL, SW_SHOWNORMAL, NULL);

    DosResetDTAAddress(); // undo any bad things COMMDLG did
    switch (ret) {
        case 0:
        case 8:
            ret = IDS_NOMEMORYMSG;
            break;

        case 2:
            ret = IDS_FILENOTFOUNDMSG;
            break;

        case 3:
        case 5:   // access denied
            ret = IDS_BADPATHMSG;
            break;

        case 4:
            ret = IDS_MANYOPENFILESMSG;
            break;

        case 10:
            ret = IDS_NEWWINDOWSMSG;
            break;

        case 12:
            ret = IDS_OS2APPMSG;
            break;

        case 15:
            /* KERNEL has already put up a messagebox for this one. */
            ret = 0;
            break;

        case 16:
            ret = IDS_MULTIPLEDSMSG;
            break;

        case 18:
            ret = IDS_PMODEONLYMSG;
            break;

        case 19:
            ret = IDS_COMPRESSEDEXE;
            break;

        case 20:
            ret = IDS_INVALIDDLL;
            break;

        case SE_ERR_SHARE:
            ret = IDS_SHAREERROR;
            break;

        case SE_ERR_ASSOCINCOMPLETE:
            ret = IDS_ASSOCINCOMPLETE;
            break;

        case SE_ERR_DDETIMEOUT:
        case SE_ERR_DDEFAIL:
        case SE_ERR_DDEBUSY:
            ret = IDS_DDEFAIL;
            break;

        case SE_ERR_NOASSOC:
            ret = IDS_NOASSOCMSG;
            break;

        default:
            if (ret < 32)
                goto EPExit;
            ret = 0;
    }

    EPExit:
    i = ShowCursor(FALSE);

    /* Make sure that the cursor count is still balanced. */
    if (i != iCurCount)
        ShowCursor(TRUE);

    SetCursor(hCursor);

    return (ret);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WFPrint() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD
APIENTRY
WFPrint(
       LPSTR pSel
       )
{
    CHAR szFile[MAXPATHLEN];
    CHAR szTemp[20];
    WORD ret;

    /* Turn off the print button. */
    if (hdlgProgress)
        EnableWindow(GetDlgItem(hdlgProgress, IDOK), FALSE);

    bUserAbort = FALSE;

    if (!(pSel = GetNextFile(pSel, szFile, sizeof(szFile))))
        return TRUE;

    /* See if there is more than one file to print.  Abort if so
     */
    if (pSel = GetNextFile(pSel, szTemp, sizeof(szTemp))) {
        MyMessageBox(hwndFrame, IDS_WINFILE, IDS_PRINTONLYONE, MB_OK | MB_ICONEXCLAMATION);
        return (FALSE);
    }

    if (hdlgProgress) {
        /* Display the name of the file being printed. */
        LoadString(hAppInstance, IDS_PRINTINGMSG, szTitle, 32);
        wsprintf(szMessage, szTitle, (LPSTR)szFile);
        SetDlgItemText(hdlgProgress, IDD_STATUS, szMessage);
    }

    ret = PrintFile(hdlgProgress ? hdlgProgress : hwndFrame, szFile);

    if (ret) {
        MyMessageBox(hwndFrame, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfinit.c ===
/****************************************************************************/
/*                                                                          */
/*  WFINIT.C -                                                              */
/*                                                                          */
/*      Windows File System Initialization Routines                         */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "lfn.h"
#include "winnet.h"
#include "wnetcaps.h"           // WNetGetCaps()
#include "stdlib.h"

typedef DWORD ( APIENTRY *EXTPROC)(HWND, WORD, LONG);
typedef DWORD ( APIENTRY *UNDELPROC)(HWND, LPSTR);
typedef VOID  ( APIENTRY *FNPENAPP)(WORD, BOOL);

VOID (APIENTRY *lpfnRegisterPenApp)(WORD, BOOL);
CHAR szPenReg[] = "RegisterPenApp";
CHAR szHelv[] = "MS Shell Dlg";    // default font, status line font face name

HBITMAP hbmSave;


INT     GetDriveOffset(register WORD wDrive);
DWORD   RGBToBGR(DWORD rgb);
VOID    BoilThatDustSpec(register CHAR *pStart, BOOL bLoadIt);
VOID    DoRunEquals(PINT pnCmdShow);
VOID    GetSavedWindow(LPSTR szBuf, PSAVE_WINDOW pwin);
VOID    GetSettings(VOID);
VOID    InitMenus(VOID);



INT
APIENTRY
GetHeightFromPointsString(
                         LPSTR szPoints
                         )
{
    HDC hdc;
    INT height;

    hdc = GetDC(NULL);
    height = MulDiv(-atoi(szPoints), GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(NULL, hdc);

    return height;
}

VOID
BiasMenu(
        HMENU hMenu,
        INT Bias
        )
{
    INT pos, id, count;
    HMENU hSubMenu;
    CHAR szMenuString[80];

    ENTER("BiasMenu");

    count = GetMenuItemCount(hMenu);

    if (count < 0)
        return;

    for (pos = 0; pos < count; pos++) {

        id = GetMenuItemID(hMenu, pos);

        if (id < 0) {
            // must be a popup, recurse and update all ID's here
            if (hSubMenu = GetSubMenu(hMenu, pos))
                BiasMenu(hSubMenu, Bias);
        } else if (id) {
            // replace the item that was there with a new
            // one with the id adjusted

            GetMenuString(hMenu, (WORD)pos, szMenuString, sizeof(szMenuString), MF_BYPOSITION);
            DeleteMenu(hMenu, pos, MF_BYPOSITION);
            InsertMenu(hMenu, (WORD)pos, MF_BYPOSITION | MF_STRING, id + Bias, szMenuString);
        }
    }
    LEAVE("BiasMenu");
}


VOID
APIENTRY
InitExtensions()
{
    CHAR szBuf[300] = {0};
    CHAR szPath[MAXPATHLEN];
    LPSTR p;
    HANDLE hMod;
    FM_EXT_PROC fp;
    HMENU hMenu;
    INT iMax;
    HMENU hMenuFrame;
    HWND  hwndActive;

    ENTER("InitExtensions");

    hMenuFrame = GetMenu(hwndFrame);

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
        iMax = 1;
    else
        iMax = 0;

    GetPrivateProfileString(szAddons, NULL, szNULL, szBuf, sizeof(szBuf), szTheINIFile);

    for (p = szBuf; *p && iNumExtensions < MAX_EXTENSIONS; p += lstrlen(p) + 1) {

        GetPrivateProfileString(szAddons, p, szNULL, szPath, sizeof(szPath), szTheINIFile);

        hMod = MLoadLibrary(szPath);

        if (hMod >= (HANDLE)32) {
            fp = (FM_EXT_PROC)GetProcAddress(hMod, "FMExtensionProc");

            if (fp) {
                WORD bias;
                FMS_LOAD ls;

                bias = (WORD)((IDM_EXTENSIONS + iNumExtensions + 1)*100);
                ls.wMenuDelta = bias;
                if ((*fp)(hwndFrame, FMEVENT_LOAD, (LPARAM)&ls)) {

                    if (ls.dwSize != sizeof(FMS_LOAD) || !ls.hMenu)
                        goto LoadFail;

                    hMenu = ls.hMenu;

                    extensions[iNumExtensions].ExtProc = fp;
                    extensions[iNumExtensions].Delta = bias;
                    extensions[iNumExtensions].hModule = hMod;
                    extensions[iNumExtensions].hMenu = hMenu;

                    BiasMenu(hMenu, bias);

                    InsertMenu(hMenuFrame,
                               IDM_EXTENSIONS + iNumExtensions + iMax,
                               MF_BYPOSITION | MF_POPUP,
                               (UINT_PTR)hMenu, ls.szMenuName);

                    iNumExtensions++;
                }
            } else {
                LoadFail:
                FreeLibrary(hMod);
            }
        }
    }
    LEAVE("InitExtensions");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetSettings() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetSettings()
{
    CHAR szTemp[128] = {0};
    INT size;

    ENTER("GetSettings");

    /* Get the flags out of the INI file. */
    bMinOnRun       = GetPrivateProfileInt(szSettings, szMinOnRun,      bMinOnRun,      szTheINIFile);
    wTextAttribs    = (WORD)GetPrivateProfileInt(szSettings, szLowerCase,     wTextAttribs,   szTheINIFile);
    bStatusBar      = GetPrivateProfileInt(szSettings, szStatusBar,     bStatusBar,     szTheINIFile);
    bConfirmDelete  = GetPrivateProfileInt(szSettings, szConfirmDelete, bConfirmDelete, szTheINIFile);
    bConfirmSubDel  = GetPrivateProfileInt(szSettings, szConfirmSubDel, bConfirmSubDel, szTheINIFile);
    bConfirmReplace = GetPrivateProfileInt(szSettings, szConfirmReplace,bConfirmReplace,szTheINIFile);
    bConfirmMouse   = GetPrivateProfileInt(szSettings, szConfirmMouse,  bConfirmMouse,  szTheINIFile);
    bConfirmFormat  = GetPrivateProfileInt(szSettings, szConfirmFormat, bConfirmFormat, szTheINIFile);
    bSaveSettings   = GetPrivateProfileInt(szSettings, szSaveSettings,  bSaveSettings, szTheINIFile);

    // test font for now

    GetPrivateProfileString(szSettings, szSize, "8", szTemp, sizeof(szTemp), szTheINIFile);
    size = GetHeightFromPointsString(szTemp);

    GetPrivateProfileString(szSettings, szFace, szHelv, szTemp, sizeof(szTemp), szTheINIFile);

    hFont = CreateFont(size, 0, 0, 0,
                       wTextAttribs & TA_BOLD ? 700 : 400,
                       wTextAttribs & TA_ITALIC, 0, 0,
                       ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                       DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, szTemp);

    LEAVE("GetSettings");
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetInternational() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
GetInternational()
{
    ENTER("GetInternational");

    GetProfileString(szInternational, "sShortDate", szShortDate, szShortDate, 11);
    AnsiUpper(szShortDate);
    GetProfileString(szInternational, "sTime", szTime, szTime, 2);
    GetProfileString(szInternational, "s1159", sz1159, sz1159, 9);
    GetProfileString(szInternational, "s2359", sz2359, sz2359, 9);
    GetProfileString(szInternational, "sThousand", szComma, szComma, sizeof(szComma));
    iTime   = GetProfileInt(szInternational, "iTime", iTime);
    iTLZero = GetProfileInt(szInternational, "iTLZero", iTLZero);

    LEAVE("GetInternational");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  BuildDocumentString() -                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Create a string which contains all of the extensions the user wants us to
 * display with document icons.  This consists of any associated extensions
 * as well as any extensions listed in the "Documents=" WIN.INI line.
 */

VOID
APIENTRY
BuildDocumentString()
{
    register LPSTR     p;
    register INT      len;
    INT               lenDocs;
    CHAR              szT[10];
    INT               i;
    HKEY hk;


    ENTER("BuildDocumentString");

    len = 32;

    /* Get all of the "Documents=" stuff. */
    szDocuments = (LPSTR)LocalAlloc(LPTR, len);
    if (!szDocuments)
        return;

    while ((lenDocs = GetProfileString(szWindows, "Documents", szNULL, szDocuments, len-1)) == len-1) {
        len += 32;
        szDocuments = (LPSTR)LocalReAlloc((HANDLE)szDocuments, len, LMEM_MOVEABLE);
        if (!szDocuments) {
            LEAVE("BuildDocumentString");
            return;
        }
    }

    lstrcat(szDocuments, szBlank);
    lenDocs++;
    p = (LPSTR)(szDocuments + lenDocs);

    /* Read all of the [Extensions] keywords into 'szDocuments'. */
    while ((INT)GetProfileString(szExtensions, NULL, szNULL, p, len-lenDocs) > (len-lenDocs-3)) {
        len += 32;
        szDocuments = (LPSTR)LocalReAlloc((HANDLE)szDocuments, len, LMEM_MOVEABLE);
        if (!szDocuments) {
            LEAVE("BuildDocumentString");
            return;
        }
        p = (LPSTR)(szDocuments + lenDocs);
    }

    /* Step through each of the keywords in 'szDocuments' changing NULLS into
     * spaces until a double-NULL is found.
     */
    p = szDocuments;
    while (*p) {
        /* Find the next NULL. */
        while (*p)
            p++;

        /* Change it into a space. */
        *p = ' ';
        p++;
    }


    if (RegOpenKey(HKEY_CLASSES_ROOT,szNULL,&hk) == ERROR_SUCCESS) {
        /* now enumerate the classes in the registration database and get all
         * those that are of the form *.ext
         */
        for (i = 0; RegEnumKey(hk,(DWORD)i,szT,sizeof(szT))
            == ERROR_SUCCESS; i++) {
            if (szT[0] != '.' ||
                (szT[1] && szT[2] && szT[3] && szT[4])) {
                /* either the class does not start with . or it has a greater
                 * than 3 byte extension... skip it.
                 */
                continue;
            }

            if (FindExtensionInList(szT+2,szDocuments)) {
                // don't add it if it's already there!
                continue;
            }

            len += 4;
            szDocuments = (PSTR)LocalReAlloc((HANDLE)szDocuments, len,
                                             LMEM_MOVEABLE);
            if (!szDocuments)
                break;
            lstrcat(szDocuments, szT+1);
            lstrcat(szDocuments, szBlank);
        }

        RegCloseKey(hk);
    }

    PRINT(BF_PARMTRACE, "OUT: szDocuments=%s", szDocuments);
    LEAVE("BuildDocumentString - ok");
    return;
}




INT
GetDriveOffset(
              register WORD wDrive
              )
{
    if (IsCDRomDrive(wDrive))
        return dxDriveBitmap * 0;

    switch (IsNetDrive(wDrive)) {
        case 1:
            return dxDriveBitmap * 4;
        case 2:
            return dxDriveBitmap * 5;
    }

    if (IsRemovableDrive(wDrive))
        return dxDriveBitmap * 1;

    if (IsRamDrive(wDrive))
        return dxDriveBitmap * 3;

    return dxDriveBitmap * 2;
}


VOID
APIENTRY
InitDriveBitmaps()
{
    INT nDrive;

    ENTER("InitDiskMenus");

    // and now add all new ones
    for (nDrive=0; nDrive < cDrives; nDrive++) {
        // refresh/init this here as well
        rgiDrivesOffset[nDrive] = GetDriveOffset((WORD)rgiDrive[nDrive]);
    }
    LEAVE("InitDiskMenus");
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InitMenus() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
InitMenus()
{
    WORD i;
    HMENU hMenu;
    OFSTRUCT os;
    INT iMax;
    CHAR szValue[MAXPATHLEN];
    HWND hwndActive;

    ENTER("InitMenus");

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
        iMax = 1;
    else
        iMax = 0;

    GetPrivateProfileString(szSettings, szUndelete, szNULL, szValue, sizeof(szValue), szTheINIFile);

    if (szValue[0]) {

        // create explicit filename to avoid searching the path

        GetSystemDirectory(os.szPathName, sizeof(os.szPathName));
        AddBackslash(os.szPathName);
        lstrcat(os.szPathName, szValue);

        if (MOpenFile(os.szPathName, &os, OF_EXIST) > 0) {

            hModUndelete = MLoadLibrary(szValue);

            if (hModUndelete >= (HANDLE)32) {
                lpfpUndelete = (FM_UNDELETE_PROC)GetProcAddress(hModUndelete, "UndeleteFile");

                if (lpfpUndelete) {
                    hMenu = GetSubMenu(GetMenu(hwndFrame), IDM_FILE + iMax);
                    LoadString(hAppInstance, IDS_UNDELETE, szValue, sizeof(szValue));
                    InsertMenu(hMenu, 4, MF_BYPOSITION | MF_STRING, IDM_UNDELETE, szValue);
                }
            } else {
                FreeLibrary(hModUndelete);

            }
        }
    }

    /* Init the Disk menu. */
    hMenu = GetMenu(hwndFrame);

    if (nFloppies == 0) {
        EnableMenuItem(hMenu, IDM_DISKCOPY, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu, IDM_FORMAT,   MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu, IDM_SYSDISK,  MF_BYCOMMAND | MF_GRAYED);
    }

    bNetAdmin = WNetGetCaps(WNNC_ADMIN) & WNNC_ADM_GETDIRECTORYTYPE;

    /* Should we enable the network items? */
    i = (WORD)WNetGetCaps(WNNC_DIALOG);

    i = 0;

    bConnect    = i & WNNC_DLG_ConnectDialog;     // note, these should both
    bDisconnect = i & WNNC_DLG_DisconnectDialog;  // be true or both false

    // use submenu because we are doing this by position

    hMenu = GetSubMenu(GetMenu(hwndFrame), IDM_DISK + iMax);

    if (i)
        InsertMenu(hMenu, 5, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

    if (bConnect && bDisconnect) {

        // lanman style double connect/disconnect

        LoadString(hAppInstance, IDS_CONNECT, szValue, sizeof(szValue));
        InsertMenu(hMenu, 6, MF_BYPOSITION | MF_STRING, IDM_CONNECT, szValue);
        LoadString(hAppInstance, IDS_DISCONNECT, szValue, sizeof(szValue));
        InsertMenu(hMenu, 7, MF_BYPOSITION | MF_STRING, IDM_DISCONNECT, szValue);
    } else if (WNetGetCaps(WNNC_CONNECTION)) {

    }

    hMenu = GetMenu(hwndFrame);

    if (bStatusBar)
        CheckMenuItem(hMenu, IDM_STATUSBAR, MF_BYCOMMAND | MF_CHECKED);
    if (bMinOnRun)
        CheckMenuItem(hMenu, IDM_MINONRUN,  MF_BYCOMMAND | MF_CHECKED);
    if (bSaveSettings)
        CheckMenuItem(hMenu, IDM_SAVESETTINGS,  MF_BYCOMMAND | MF_CHECKED);

    InitDriveBitmaps();

    InitExtensions();

    LEAVE("InitMenus");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  BoilThatDustSpec() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Parses the command line (if any) passed into WINFILE and exec's any tokens
 * it may contain.
 */

VOID
BoilThatDustSpec(
                register CHAR *pStart,
                BOOL bLoadIt
                )
{
    register CHAR *pEnd;
    WORD          ret;
    BOOL          bFinished;

    ENTER("BoilThatDustSpec");

    if (*pStart == TEXT('\0'))
        return;

    bFinished = FALSE;
    while (!bFinished) {
        pEnd = pStart;
        while ((*pEnd) && (*pEnd != ' ') && (*pEnd != ','))
            pEnd = AnsiNext(pEnd);

        if (*pEnd == TEXT('\0'))
            bFinished = TRUE;
        else
            *pEnd = TEXT('\0');

        ret = ExecProgram(pStart, szNULL, NULL, bLoadIt);
        if (ret)
            MyMessageBox(NULL, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

        pStart = pEnd+1;
    }
    LEAVE("BoilThatDustSpec");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DoRunEquals() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Handle the "Run=" and "Load=" lines in WIN.INI. */

VOID
DoRunEquals(
           PINT pnCmdShow
           )
{
    CHAR      szBuffer[128] = {0};

    /* "Load" apps before "Run"ning any. */
    GetProfileString(szWindows, "Load", szNULL, szBuffer, 128);
    if (*szBuffer)
        BoilThatDustSpec(szBuffer, TRUE);

    GetProfileString(szWindows, "Run", szNULL, szBuffer, 128);
    if (*szBuffer) {
        BoilThatDustSpec(szBuffer, FALSE);
        *pnCmdShow = SW_SHOWMINNOACTIVE;
    }
}


//
// BOOL APIENTRY LoadBitmaps()
//
// this routine loads DIB bitmaps, and "fixes up" their color tables
// so that we get the desired result for the device we are on.
//
// this routine requires:
//      the DIB is a 16 color DIB authored with the standard windows colors
//      bright blue (00 00 FF) is converted to the background color!
//      light grey  (C0 C0 C0) is replaced with the button face color
//      dark grey   (80 80 80) is replaced with the button shadow color
//
// this means you can't have any of these colors in your bitmap
//

#define BACKGROUND      0x000000FF      // bright blue
#define BACKGROUNDSEL   0x00FF00FF      // bright blue
#define BUTTONFACE      0x00C0C0C0      // bright grey
#define BUTTONSHADOW    0x00808080      // dark grey

DWORD
FlipColor(
         DWORD rgb
         )
{
    return RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb));
}


BOOL
APIENTRY
LoadBitmaps()
{
    HDC                   hdc;
    HANDLE                h;
    DWORD                 *p;
    LPSTR                 lpBits;
    HANDLE                hRes;
    LPBITMAPINFOHEADER    lpBitmapInfo;
    INT numcolors;
    DWORD n;
    DWORD rgbSelected;
    DWORD rgbUnselected;
    PVOID pv;

    ENTER("LoadBitmaps");

    rgbSelected = FlipColor(GetSysColor(COLOR_HIGHLIGHT));
    rgbUnselected = FlipColor(GetSysColor(COLOR_WINDOW));

    h = FindResource(hAppInstance, MAKEINTRESOURCE(BITMAPS), RT_BITMAP);
    if (!h) {
        return FALSE;
    }

    n = SizeofResource(hAppInstance, h);
    lpBitmapInfo = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, n);
    if (!lpBitmapInfo)
        return FALSE;

    /* Load the bitmap and copy it to R/W memory */
    hRes = LoadResource(hAppInstance, h);
    pv = (PVOID) LockResource(hRes);
    if (pv)
        memcpy( lpBitmapInfo, pv, n );
    UnlockResource(hRes);
    FreeResource(hRes);

    p = (DWORD *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

    /* Search for the Solid Blue entry and replace it with the current
     * background RGB.
     */
    numcolors = 16;

    while (numcolors-- > 0) {
        if (*p == BACKGROUND)
            *p = rgbUnselected;
        else if (*p == BACKGROUNDSEL)
            *p = rgbSelected;
        else if (*p == BUTTONFACE)
            *p = FlipColor(GetSysColor(COLOR_BTNFACE));
        else if (*p == BUTTONSHADOW)
            *p = FlipColor(GetSysColor(COLOR_BTNSHADOW));

        p++;
    }

    /* Now create the DIB. */

    /* First skip over the header structure */
    lpBits = (LPSTR)(lpBitmapInfo + 1);

    /* Skip the color table entries, if any */
    lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

    /* Create a color bitmap compatible with the display device */
    hdc = GetDC(NULL);
    if (hdcMem = CreateCompatibleDC(hdc)) {

        if (hbmBitmaps = CreateDIBitmap(hdc, lpBitmapInfo, (DWORD)CBM_INIT, lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS))
            hbmSave = SelectObject(hdcMem, hbmBitmaps);

    }
    ReleaseDC(NULL, hdc);



    LEAVE("LoadBitmaps");

    return TRUE;
}

//
// void GetSavedWindow(LPSTR szBuf, PSAVE_WINDOW pwin)
//
// in:
//      szBuf   buffer to parse out all the saved window stuff
//              if NULL pwin is filled with all defaults
// out:
//      pwin    this structure is filled with all fields from
//              szBuf.  if any fields do not exist this is
//              initialized with the standard defaults
//

VOID
GetSavedWindow(
              LPSTR szBuf,
              PSAVE_WINDOW pwin
              )
{
    PINT pint;
    INT count;

    ENTER("GetSavedWindow");

    // defaults

    pwin->rc.right = pwin->rc.left = CW_USEDEFAULT;
    pwin->pt.x = pwin->pt.y = pwin->rc.top = pwin->rc.bottom = 0;
    pwin->sw = SW_SHOWNORMAL;
    pwin->sort = IDD_NAME;
    pwin->view = VIEW_NAMEONLY;
    pwin->attribs = ATTR_DEFAULT;
    pwin->split = 0;

    pwin->szDir[0] = 0;

    if (!szBuf)
        return;

    count = 0;
    pint = (PINT)&pwin->rc;         // start by filling the rect

    while (*szBuf && count < 11) {

        *pint++ = atoi(szBuf);  // advance to next field

        while (*szBuf && *szBuf != ',')
            szBuf++;

        while (*szBuf && *szBuf == ',')
            szBuf++;

        count++;
    }

    lstrcpy(pwin->szDir, szBuf);    // this is the directory

    LEAVE("GetSavedWindow");
}


// szDir (OEM) path to check for existance

BOOL
CheckDirExists(
              LPSTR szDir
              )
{
    BOOL bRet = FALSE;

    ENTER("CheckDirExists");
    PRINT(BF_PARMTRACE, "szDir=%s", szDir);

    if (IsNetDrive((WORD)(DRIVEID(szDir))) == 2)
        return FALSE;

    if (IsValidDisk(DRIVEID(szDir)))
        bRet = !SheChangeDir(szDir);

    LEAVE("CheckDirExists");

    return bRet;
}



// return the tree directory in szTreeDir

BOOL
APIENTRY
CreateSavedWindows()
{
    CHAR buf[MAXPATHLEN+7*7], key[10];
    INT dir_num;
    HWND hwnd;
    SAVE_WINDOW win;
    INT iNumTrees;

    ENTER("CreateSavedWindows");

    // make sure this thing exists so we don't hit drives that don't
    // exist any more

    dir_num = 1;
    iNumTrees = 0;

    do {
        wsprintf(key, szDirKeyFormat, dir_num++);

        GetPrivateProfileString(szSettings, key, szNULL, buf, sizeof(buf), szTheINIFile);

        if (*buf) {
            CHAR szDir[MAXPATHLEN];

            GetSavedWindow(buf, &win);
            AnsiUpperBuff(win.szDir, 1);

            // clean off some junk so we
            // can do this test

            lstrcpy(szDir, win.szDir);
            StripFilespec(szDir);
            StripBackslash(szDir);
            FixAnsiPathForDos(szDir);

            if (!CheckDirExists(szDir))
                continue;

            wNewView = (WORD)win.view;
            wNewSort = (WORD)win.sort;
            dwNewAttribs = win.attribs;

            hwnd = CreateTreeWindow(win.szDir, win.split);

            if (!hwnd) {
                LEAVE("CreateSavedWindows");
                return FALSE;
            }

            iNumTrees++;

            // keep track of this for now...


            SetInternalWindowPos(hwnd, win.sw, &win.rc, &win.pt);
        }

    } while (*buf);

    // if nothing was saved create a tree for the current drive

    if (!iNumTrees) {
        //lstrcpy(buf, szOriginalDirPath);
        lstrcpy(buf, "\\"); // Don't use current filesystem directory
        lstrcat(buf, szStarDotStar);

        hwnd = CreateTreeWindow(buf, -1);// default to split window
        if (!hwnd)
            return FALSE;

        // ShowWindow(hwnd, SW_MAXIMIZE);

        iNumTrees++;
    }

    LEAVE("CreateSavedWindows - Ok");
    return TRUE;
}


// void  APIENTRY GetTextStuff(HDC hdc)
//
// this computues all the globals that are dependant on the
// currently selected font
//
// in:
//      hdc     DC with font selected into it
//

VOID
APIENTRY
GetTextStuff(
            HDC hdc
            )
{
    ENTER("GetTextStuff");

    MGetTextExtent(hdc, "M", 1, &dxText, &dyText);
    MGetTextExtent(hdc, szEllipses, 3, &dxEllipses, NULL);

    // these are all dependant on the text metrics

    dxDrive = dxDriveBitmap + dxText + (4*dyBorderx2);
    dyDrive = max(dyDriveBitmap + (4*dyBorderx2), dyText);

    // dxFileName = dxFolder + (12*dxText);
    dyFileName = max(dyText, dyFolder);   //  + dyBorder;

    LEAVE("GetTextStuff");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InitFileManager() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
InitFileManager(
               HANDLE hInstance,
               HANDLE hPrevInstance,
               LPSTR lpCmdLine,
               INT nCmdShow
               )
{
    INT           i;
    WORD          ret;
    INT           nHardDisk;
    HDC           hdcScreen;
    CHAR          szBuffer[128];
    HCURSOR       hcurArrow;
    WNDCLASS      wndClass;
    SAVE_WINDOW   win;
    HWND          hwnd;
    HANDLE hOld;
    LPSTR         lpT;
    TEXTMETRIC    tm;
    CHAR szTemp[80];

    ENTER("InitFileManager");
    PRINT(BF_PARMTRACE, "lpCmdLine=%s", lpCmdLine);
    PRINT(BF_PARMTRACE, "nCmdShow=%d", IntToPtr(nCmdShow));

    // ProfStart();

    hAppInstance = hInstance;     // Preserve this instance's module handle
    /* Set the Global DTA Address. This must be done before ExecProgram. */
    DosGetDTAAddress();

    if (*lpCmdLine)
        nCmdShow = SW_SHOWMINNOACTIVE;

    PRINT(BF_PARMTRACE, "lpCmdLine=%s", lpCmdLine);
    PRINT(BF_PARMTRACE, "nCmdShow=%d", IntToPtr(nCmdShow));

#ifdef LATER
    if (hPrevInstance) {
        // if we are already running bring up the other instance

        +++GetInstanceData - NOOP on 32BIT side+++(hPrevInstance, (NLPSTR)&hwndFrame, sizeof(HWND));

        if (hwndFrame) {

            hwnd = GetLastActivePopup(hwndFrame);

            BringWindowToTop(hwndFrame);

            if (IsIconic(hwndFrame))
                ShowWindow(hwndFrame, SW_RESTORE);
            else
                SetActiveWindow(hwnd);
        }
        LEAVE("InitFileManager");
        return FALSE;
    }
#else
    UNREFERENCED_PARAMETER(hPrevInstance);
    {
        HWND hwndT;
        BYTE szClass[20];

        if (CreateEvent(NULL, TRUE, FALSE, szFrameClass) == NULL) {
            for (hwndT = GetWindow(GetDesktopWindow(), GW_CHILD); hwndT;
                hwndT = GetWindow(hwndT, GW_HWNDNEXT)) {
                if (GetClassName(hwndT, szClass, sizeof(szClass)))
                    if (!lstrcmpi(szFrameClass, szClass)) {
                        SetForegroundWindow(hwndT);
                        if (IsIconic(hwndT))
                            ShowWindow(hwndT, SW_RESTORE);
                        return FALSE;
                    }
            }

            return FALSE;
        }
    }
#endif


    SetErrorMode(1);              // turn off critical error bullshit

//    if (lpfnRegisterPenApp = (FNPENAPP)GetProcAddress((HANDLE)GetSystemMetrics(SM_PENWINDOWS), szPenReg))
//        (*lpfnRegisterPenApp)(1, TRUE);


    /* Remember the current directory. */
    SheGetDir(0, szOriginalDirPath);

    if (!GetWindowsDirectory(szTheINIFile, sizeof(szTheINIFile))) {
        szTheINIFile[0] = '\0';
    }

    AddBackslash(szTheINIFile);
    lstrcat(szTheINIFile, szINIFile);

    GetProfileString(szWindows, "Programs", szDefPrograms, szTemp, sizeof(szTemp));
    szPrograms = (LPSTR)LocalAlloc(LPTR, lstrlen(szTemp)+1);
    if (!szPrograms)
        szPrograms = szNULL;
    else
        lstrcpy(szPrograms, szTemp);

    BuildDocumentString();

    /* Deal with any RUN= or LOAD= lines in WIN.INI. */

    if (*lpCmdLine) {
        // skip spaces
        while (*lpCmdLine == ' ')
            lpCmdLine++;

        for (lpT = lpCmdLine; *lpT; lpT = AnsiNext(lpT)) {
            if (*lpT == ' ')
                break;
        }
        if (*lpT == ' ')
            *lpT++ = 0;

        ret = ExecProgram(lpCmdLine, lpT, NULL, FALSE);
        if (ret)
            MyMessageBox(NULL, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
        else
            nCmdShow = SW_SHOWMINNOACTIVE;
    }

    /* Read WINFILE.INI and set the approriate variables. */
    GetSettings();

    /* Read the International constants out of WIN.INI. */
    GetInternational();

    dyBorder = GetSystemMetrics(SM_CYBORDER);
    dyBorderx2 = dyBorder * 2;
    dxFrame = GetSystemMetrics(SM_CXFRAME) - dyBorder;

    dxDriveBitmap = DRIVES_WIDTH;
    dyDriveBitmap = DRIVES_HEIGHT;
    dxFolder = FILES_WIDTH;
    dyFolder = FILES_HEIGHT;

    if (!LoadBitmaps())
        return FALSE;

    hicoTree = LoadIcon(hAppInstance, MAKEINTRESOURCE(TREEICON));
    hicoTreeDir = LoadIcon(hAppInstance, MAKEINTRESOURCE(TREEDIRICON));
    hicoDir = LoadIcon(hAppInstance, MAKEINTRESOURCE(DIRICON));

    chFirstDrive = (CHAR)((wTextAttribs & TA_LOWERCASE) ? 'a' : 'A');

    // now build the parameters based on the font we will be using

    hdcScreen = GetDC(NULL);

    hOld = SelectObject(hdcScreen, hFont);
    GetTextStuff(hdcScreen);
    if (hOld)
        SelectObject(hdcScreen, hOld);

    dxClickRect = max(GetSystemMetrics(SM_CXDOUBLECLK) / 2, 2 * dxText);
    dyClickRect = max(GetSystemMetrics(SM_CYDOUBLECLK) / 2, dyText);

    hFontStatus = CreateFont(GetHeightFromPointsString("10"), 0, 0, 0, 400, 0, 0, 0,
                             ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, szHelv);

    hOld = SelectObject(hdcScreen, hFontStatus);

    GetTextMetrics(hdcScreen, &tm);

    if (hOld)
        SelectObject(hdcScreen, hOld);

    dyStatus = tm.tmHeight + tm.tmExternalLeading + 7 * dyBorder;
    dxStatusField = GetDeviceCaps(hdcScreen, LOGPIXELSX) * 3;

    ReleaseDC(NULL, hdcScreen);

    cDrives = UpdateDriveList();

    /* Create an array of INT 13h drive numbers (floppies only). */
    nFloppies = 0;
    nHardDisk = 0x80;
    for (i=0; i < cDrives; i++) {
        if (IsRemovableDrive(rgiDrive[i])) {
            /* Avoid Phantom B: problems. */
            if ((nFloppies == 1) && (i > 1))
                nFloppies = 2;
            nFloppies++;
        } else {
            nHardDisk++;
        }
    }

    /* Load the accelerator table. */
    hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(WFACCELTABLE));

    LoadString(hInstance, IDS_DIRSREAD, szDirsRead, sizeof(szDirsRead));
    LoadString(hInstance, IDS_BYTES, szBytes, sizeof(szBytes));
    LoadString(hInstance, IDS_SBYTES, szSBytes, sizeof(szSBytes));

    wDOSversion = DOS_320;

    wHelpMessage = RegisterWindowMessage("ShellHelp");
    wBrowseMessage = RegisterWindowMessage("commdlg_help");

    hhkMessageFilter = SetWindowsHook(WH_MSGFILTER, MessageFilter);

    hcurArrow = LoadCursor(NULL, IDC_ARROW);

    wndClass.lpszClassName  = szFrameClass;
    wndClass.style          = 0;
    wndClass.lpfnWndProc    = FrameWndProc;
    wndClass.cbClsExtra     = 0;
    wndClass.cbWndExtra     = 0;
    wndClass.hInstance      = hInstance;
    wndClass.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(APPICON));
    wndClass.hCursor        = hcurArrow;
    wndClass.hbrBackground  = (HBRUSH)(COLOR_APPWORKSPACE + 1); // COLOR_WINDOW+1;
    wndClass.lpszMenuName   = MAKEINTRESOURCE(FRAMEMENU);

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szTreeClass;
    wndClass.style          = CS_VREDRAW | CS_HREDRAW;
    wndClass.lpfnWndProc    = TreeWndProc;
//  wndClass.cbClsExtra     = 0;
    wndClass.cbWndExtra     = sizeof(LONG) +// GWL_TYPE
                              sizeof(LONG) +// wViewStyle GWL_VIEW
                              sizeof(LONG) +// wSortStyle GWL_SORT
                              sizeof(LONG) +// dwAttrStyle GWL_ATTRIBS
                              sizeof(LONG) +// FSC flag GWL_FSCFLAG
                              sizeof(PVOID) +// hwndLastFocus GWL_LASTFOCUS
                              sizeof(LONG); // dxSplit GWL_SPLIT

    wndClass.hIcon          = NULL;
    wndClass.hCursor        = LoadCursor(hInstance, MAKEINTRESOURCE(SPLITCURSOR));
    wndClass.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wndClass.lpszMenuName   = NULL;

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szDrivesClass;
    wndClass.style          = CS_HREDRAW | CS_VREDRAW;
    wndClass.lpfnWndProc    = DrivesWndProc;
    wndClass.cbWndExtra     = sizeof(LONG) +// GWL_CURDRIVEIND
                              sizeof(LONG) +// GWL_CURDRIVEFOCUS
                              sizeof(PVOID); // GWLP_LPSTRVOLUME

    wndClass.hCursor        = hcurArrow;
    wndClass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE+1);

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szTreeControlClass;
    wndClass.style          = CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
    wndClass.lpfnWndProc    = TreeControlWndProc;
    wndClass.cbWndExtra     = sizeof(LONG); // GWL_READLEVEL
    wndClass.hCursor        = hcurArrow;
    wndClass.hbrBackground  = NULL;

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szDirClass;
    wndClass.style          = CS_VREDRAW | CS_HREDRAW;
    wndClass.lpfnWndProc    = DirWndProc;
    wndClass.cbWndExtra     = sizeof(PVOID)+ // DTA data GWLP_HDTA
                              sizeof(PVOID); // GWLP_TABARRAY

    wndClass.hIcon          = NULL;
    wndClass.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szSearchClass;
    wndClass.style          = 0;
    wndClass.lpfnWndProc    = SearchWndProc;
    wndClass.cbWndExtra     = sizeof(LONG) +        // GWL_TYPE
                              sizeof(LONG) +        // wViewStyle GWL_VIEW
                              sizeof(LONG) +        // wSortStyle GWL_SORT
                              sizeof(LONG) +        // dwAttrStyle GWL_ATTRIBS
                              sizeof(LONG) +        // FSC flag GWL_FSCFLAG
                              sizeof(PVOID) +       // GWLP_HDTASEARCH
                              sizeof(PVOID) +       // GWLP_TABARRAYSEARCH
                              sizeof(PVOID);        // GWLP_LASTFOCUSSEARCH

    wndClass.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(DIRICON));
    wndClass.hbrBackground  = NULL;

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }


    if (!LoadString(hInstance, IDS_WINFILE, szTitle, 32)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    GetPrivateProfileString(szSettings, szWindow, szNULL, szBuffer, sizeof(szBuffer), szTheINIFile);
    GetSavedWindow(szBuffer, &win);


    if (!CreateWindowEx(0, szFrameClass, szTitle,WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                        win.rc.left, win.rc.top, win.rc.right, win.rc.bottom,
                        NULL, NULL, hInstance, NULL)) {

        LEAVE("InitFileManager - Frame class creation failure");
        return FALSE;
    }


    InitMenus();            // after the window/menu has been created

    // support forced min or max

    if (nCmdShow == SW_SHOWNORMAL && win.sw == SW_SHOWMAXIMIZED)
        nCmdShow = SW_SHOWMAXIMIZED;

    ShowWindow(hwndFrame, nCmdShow);
    UpdateWindow(hwndFrame);

    LFNInit();

    if (!CreateSavedWindows()) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    ShowWindow(hwndMDIClient, SW_NORMAL);

    // now refresh all tree windows (start background tree read)
    //
    // since the tree reads happen in the background the user can
    // change the Z order by activating windows once the read
    // starts.  to avoid missing a window we must restart the
    // search through the MDI child list, checking to see if the
    // tree has been read yet (if there are any items in the
    // list box).  if it has not been read yet we start the read

    hwnd = GetWindow(hwndMDIClient, GW_CHILD);

    while (hwnd) {
        HWND hwndTree;

        if ((hwndTree = HasTreeWindow(hwnd)) &&
            (INT)SendMessage(GetDlgItem(hwndTree, IDCW_TREELISTBOX), LB_GETCOUNT, 0, 0L) == 0) {
            SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(FALSE, 0), 0L);
            hwnd = GetWindow(hwndMDIClient, GW_CHILD);
        } else {
            hwnd = GetWindow(hwnd, GW_HWNDNEXT);
        }
    }

    // ProfStop();

    LEAVE("InitFileManager - OK");
    return TRUE;
}


VOID
APIENTRY
DeleteBitmaps()
{
    ENTER("DeleteBitmaps");

    if (hdcMem) {

        SelectObject(hdcMem, hbmSave);

        if (hbmBitmaps)
            DeleteObject(hbmBitmaps);
        DeleteDC(hdcMem);
    }
    LEAVE("DeleteBitmaps");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FreeFileManager() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
FreeFileManager()
{
    ENTER("FreeFileManager");


    if (lpfnRegisterPenApp)
        (*lpfnRegisterPenApp)(1, FALSE);

    DeleteBitmaps();

    if (hFont)
        DeleteObject(hFont);

    if (hFontStatus)
        DeleteObject(hFontStatus);

    LEAVE("FreeFileManager");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wftree.c ===
/****************************************************************************/
/*                                                                          */
/*  WFTREE.C -                                                              */
/*                                                                          */
/*      Windows File System Tree Window Proc Routines                       */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "wfcopy.h"

HICON GetTreeIcon(HWND hWnd);

VOID  APIENTRY CheckEscapes(LPSTR);

HICON
GetTreeIcon(
           HWND hWnd
           )
{
    HWND hwndTree, hwndDir;

    hwndTree = HasTreeWindow(hWnd);
    hwndDir = HasDirWindow(hWnd);

    if (hwndTree && hwndDir)
        return hicoTreeDir;
    else if (hwndTree)
        return hicoTree;
    else
        return hicoDir;
}



VOID
APIENTRY
GetTreeWindows(
              HWND hwnd,
              PHWND phwndTree,
              PHWND phwndDir,
              PHWND phwndDrives
              )
{
    if (phwndTree) {
        *phwndTree = GetDlgItem(hwnd, IDCW_TREECONTROL);
    }
    if (phwndDir) {
        *phwndDir  = GetDlgItem(hwnd, IDCW_DIR);
    }
    if (phwndDrives) {
        *phwndDrives = GetDlgItem(hwnd, IDCW_DRIVES);
    }
}


// returns hwndTree, hwndDir or hwndDrives depending on the focus tracking
// for the window.  if none is found we return NULL

HWND
APIENTRY
GetTreeFocus(
            HWND hwndTree
            )
{
    HWND hwnd, hwndLast = NULL;

    hwndLast = hwnd = (HWND)GetWindowLongPtr(hwndTree, GWLP_LASTFOCUS);

    while (hwnd && hwnd != hwndTree) {
        hwndLast = hwnd;
        hwnd = GetParent(hwnd);
    }

    return hwndLast;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CompactPath() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
CompactPath(
           HDC hDC,
           LPSTR lpszPath,
           WORD dx
           )
{
    register INT  len;
    INT           dxFixed, dxT;
    LPSTR         lpEnd;          /* end of the unfixed string */
    LPSTR         lpFixed;        /* start of text that we always display */
    BOOL          bEllipsesIn;
    CHAR          szTemp[MAXPATHLEN];

    /* Does it already fit? */
    MGetTextExtent(hDC, lpszPath, lstrlen(lpszPath), &dxFixed, NULL);
    if (dxFixed <= (INT)dx)
        return(TRUE);

    /* Search backwards for the '\', and man, it better be there! */
    lpFixed = lpszPath + lstrlen(lpszPath);
    while (*lpFixed != '\\')
        lpFixed = AnsiPrev(lpszPath, lpFixed);

    /* Save this guy to prevent overlap. */
    lstrcpy(szTemp, lpFixed);

    lpEnd = lpFixed;
    bEllipsesIn = FALSE;
    MGetTextExtent(hDC, lpFixed, lstrlen(lpFixed), &dxFixed, NULL);

    while (TRUE) {
        MGetTextExtent(hDC, lpszPath, (int)(lpEnd - lpszPath), &dxT, NULL);
        len = dxFixed + dxT;

        if (bEllipsesIn)
            len += dxEllipses;

        if (len <= (INT)dx)
            break;

        bEllipsesIn = TRUE;

        if (lpEnd <= lpszPath) {
            /* Things didn't fit. */
            lstrcpy(lpszPath, szEllipses);
            lstrcat(lpszPath, szTemp);
            return(FALSE);
        }

        /* Step back a character. */
        lpEnd = AnsiPrev(lpszPath, lpEnd);
    }

    if (bEllipsesIn) {
        lstrcpy(lpEnd, szEllipses);
        lstrcat(lpEnd, szTemp);
    }

    return(TRUE);
}



//
// BOOL  APIENTRY ResizeSplit(HWND hWnd, int dxSplit)
//
// creates/resizes children of the MDI child for the given path or resizes
// (perhaps creating and destroying) these guys based on the dxSplit
// parameter
//
// in:
//      hWnd    window to fiddle with
//      dxSpit  location of split between tree and dir panes
//              if less than size limit no tree is created
//              (current is destroyed)
//              if past limit on right margin the dir window
//              is destroyed (or not created)
//
// returns:
//      TRUE    success, windows created
//      FALSE   failure, windows failed creation, out of mem, or
//              the tree was in a state the couldn't be resized
//

BOOL
APIENTRY
ResizeSplit(
           HWND hWnd,
           INT dxSplit
           )
{
    RECT rc;
    HWND hwndTree, hwndDir, hwndDrives, hwndLB;
    DWORD dwTemp;

    GetTreeWindows(hWnd, &hwndTree, &hwndDir, &hwndDrives);

    if (hwndTree && GetWindowLong(hwndTree, GWL_READLEVEL))
        return FALSE;

    GetClientRect(hWnd, &rc);

    // create the drives

    if (!hwndDrives) {

        // make new drives window

        hwndDrives = CreateWindowEx(0, szDrivesClass, NULL,

                                    WS_CHILD | WS_VISIBLE,
                                    0, 0, 0, 0,
                                    hWnd, (HMENU)IDCW_DRIVES,
                                    hAppInstance, NULL);

        if (!hwndDrives)
            return FALSE;
    }

    if (dxSplit > dxDriveBitmap * 2) {

        if (!hwndTree) {        // make new tree window

            hwndTree = CreateWindowEx(0, szTreeControlClass,
                                      NULL, WS_CHILD | WS_VISIBLE,
                                      0, 0, 0, 0, hWnd, (HMENU)IDCW_TREECONTROL,
                                      hAppInstance, NULL);

            if (!hwndTree)
                return FALSE;

            // only reset this if the dir window already
            // exists, that is we are creating the tree
            // by splitting open a dir window

            if (hwndDir)
                SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(FALSE, 0), 0L);
        }
    } else if (hwndTree) {          // we are closing the tree window

        // If the directory window is empty, then set the focus to the
        // drives window.

        if (hwndDir) {
            hwndLB = GetDlgItem (hwndDir,IDCW_LISTBOX);
            if (hwndLB) {
                SendMessage (hwndLB,LB_GETTEXT,0,(LPARAM)(LPSTR) &dwTemp);
                if (!dwTemp)
                    SetFocus (hwndDrives);
            }
        }
        DestroyWindow(hwndTree);
        dxSplit = 0;
    }

    if ((rc.right - dxSplit) > dxDriveBitmap * 2) {

        if (!hwndDir) {
            hwndDir = CreateWindowEx(0, szDirClass, NULL,
                                     WS_CHILD | WS_VISIBLE,
                                     0, 0, 0, 0,
                                     hWnd,(HMENU)IDCW_DIR,
                                     hAppInstance, NULL);
            if (!hwndDir)
                return FALSE;
        }
    } else if (hwndDir) {
        DestroyWindow(hwndDir);
        dxSplit = rc.right;
    }

    UpdateStatus(hWnd);

    SetWindowLong(hWnd, GWL_SPLIT, dxSplit);

    return TRUE;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  TreeWndProc() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* WndProc for the MDI child window containing the drives, volume, and
 * directory tree child windows.
 */

INT_PTR
APIENTRY
TreeWndProc(
           HWND hWnd,
           UINT wMsg,
           WPARAM wParam,
           LPARAM lParam
           )
{
    HWND hwndTree, hwndDir, hwndDrives, hwndFocus;
    CHAR szDir[MAXPATHLEN];
    RECT rc;
    HDC hdc;

    STKCHK();

    switch (wMsg) {
        case WM_FILESYSCHANGE:
            MSG("TreeWndProc", "WM_FILESYSCHANGE");

            if (hwndDir = HasDirWindow(hWnd))
                SendMessage(hwndDir, wMsg, wParam, lParam);

            break;

        case FS_CHANGEDRIVES:
            MSG("TreeWndProc", "FS_CHANGEDRIVES");
            {
                INT   iNewDrive;

                if (!(hwndDrives = GetDlgItem(hWnd, IDCW_DRIVES)))
                    break;

                DestroyWindow(hwndDrives);

                // see if this drive has gone, if so set this to the
                // last drive in the list

                iNewDrive = -1;

                if (!IsValidDisk((INT)GetWindowLong(hWnd, GWL_TYPE))) {
                    iNewDrive = rgiDrive[cDrives - 1];
                    SetWindowLong(hWnd, GWL_TYPE, iNewDrive);
                }

                hwndDrives = CreateWindowEx(0, szDrivesClass, NULL,
                                            WS_CHILD | WS_VISIBLE,
                                            0, 0, 0, 0,
                                            hWnd, (HMENU)IDCW_DRIVES,
                                            hAppInstance,
                                            NULL);

                if (!hwndDrives)
                    return -1L;

                // Don't show the new stuff if the tree window is iconic

                if (IsIconic(hWnd))
                    break;

                /* HACK!  Send SIZENOMDICRAP in the wParam of the size message.
                 * This will re-compute the sizes of all three areas of
                 * the tree window (in case the drive section grows or
                 * shrinks) and not pass it the size message on to the
                 * DefMDIChildProc() */

                GetClientRect(hWnd, &rc);
                SendMessage(hWnd, WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));

                // refresh the tree if necessary

                if (iNewDrive >= 0) {

                    GetSelectedDirectory((WORD)(iNewDrive+1), szDir);

                    SendMessage(GetDlgItem(hWnd, IDCW_TREECONTROL),
                                TC_SETDRIVE, MAKEWORD(FALSE, 0), (LPARAM)szDir);
                }

                break;
            }

        case FS_GETSELECTION:
            {
#define pfDir            (BOOL *)lParam
                LPSTR p;

                MSG("TreeWndProc", "FS_GETSELECTION");

                GetTreeWindows(hWnd, &hwndTree, &hwndDir, &hwndDrives);
                hwndFocus = GetTreeFocus(hWnd);

                if (hwndFocus == hwndDir || !hwndTree) {
                    return SendMessage(hwndDir, FS_GETSELECTION, wParam, lParam);
                } else {
                    p = (LPSTR)LocalAlloc(LPTR, MAXPATHLEN);
                    if (p) {
                        SendMessage(hWnd, FS_GETDIRECTORY, MAXPATHLEN, (LPARAM)p);
                        StripBackslash(p);
                        CheckEscapes(p);
                        if (wParam == 2) {      // BUG ??? wParam should be fMostRecentOnly
                            if (pfDir) {
                                *pfDir = IsLFN(p);
                            }
                            LocalFree((HANDLE)p);
                            return (INT_PTR)p;
                        }
                    }
                    if (pfDir) {
                        *pfDir = TRUE;
                    }
                    return (INT_PTR)p;
                }
#undef pfDir
            }

        case FS_GETDIRECTORY:
            MSG("TreeWndProc", "FS_GETDIRECTORY");

            // wParam is the length of the string pointed to by lParam
            // returns in lParam ANSI directory string with
            // a trailing backslash.  if you want to do a SetCurrentDirecotor()
            // you must first StripBackslash() the thing!

            GetMDIWindowText(hWnd, (LPSTR)lParam, (INT)wParam);        // get the string
            StripFilespec((LPSTR)lParam);        // Remove the trailing extention
            AddBackslash((LPSTR)lParam);        // terminate with a backslash
            break;


        case FS_GETFILESPEC:
            MSG("TreeWndProc", "FS_GETFILESPEC");
            // returns the current filespec (from View.Include...).  this is
            // an uppercase ANSI string

            GetMDIWindowText(hWnd, (LPSTR)lParam, (INT)wParam);
            StripPath((LPSTR)lParam);
            break;

            // redirect these messages to the drive icons to get the same result as
            // dropping on the active drive.
            // this is especially useful when we are minimized

        case WM_DRAGSELECT:
        case WM_QUERYDROPOBJECT:
        case WM_DROPOBJECT:
            MSG("TreeWndProc", "WM..OBJECT");

            // Do nothing
            return(TRUE);

            if (hwndDrives = HasDrivesWindow(hWnd)) {
                return SendMessage(hwndDrives, wMsg, wParam, lParam);
            }

            if (hwndDir = HasDirWindow(hWnd)) {
                return SendMessage(hwndDir, wMsg, wParam, lParam);
            }

            break;

        case FS_GETDRIVE:
            MSG("TreeWndProc", "FS_GETDRIVE");

            GetTreeWindows(hWnd, &hwndTree, &hwndDir, NULL);

            if (hwndTree)
                return SendMessage(hwndTree, wMsg, wParam, lParam);
            else
                return SendMessage(hwndDir, wMsg, wParam, lParam);

            break;

        case WM_CREATE:
            TRACE(BF_WM_CREATE, "TreeWndProc - WM_CREATE");
            {
                INT dxSplit;
                WORD wDrive;

                // lpcs->lpszName is the path we are opening the
                // window for (has extension stuff "*.*")

#define lpcs ((LPCREATESTRUCT)lParam)
#define lpmdics ((LPMDICREATESTRUCT)(lpcs->lpCreateParams))

                wDrive = lpcs->lpszName[0];

                if (wDrive >= 'a')
                    wDrive -= 'a';
                else
                    wDrive -= 'A';

                SetWindowLong(hWnd, GWL_TYPE, wDrive);

                dxSplit = (SHORT)LOWORD(lpmdics->lParam);

                // if dxSplit is negative we split in the middle

                if (dxSplit < 0)
                    dxSplit = lpcs->cx / 2;

                SetWindowLong(hWnd, GWL_SPLIT, dxSplit);
                SetWindowLongPtr(hWnd, GWLP_LASTFOCUS, 0);
                SetWindowLong(hWnd, GWL_FSCFLAG, FALSE);

                if (!ResizeSplit(hWnd, dxSplit))
                    return -1;

                GetTreeWindows(hWnd, &hwndTree, &hwndDir, NULL);

                SetWindowLongPtr(hWnd, GWLP_LASTFOCUS, (LONG_PTR)(hwndTree ? hwndTree : hwndDir));

                break;
            }


        case WM_CLOSE:
            MSG("TreeWndProc", "WM_CLOSE");

            // don't allow the last MDI child to be closed!

            if (hwndTree = HasTreeWindow(hWnd)) {
                // don't close if we are reading the tree
                if (GetWindowLong(hwndTree, GWL_READLEVEL))
                    break;
            }

            // don't leve current dir on floppies
            GetSystemDirectory(szDir, sizeof(szDir));
            SheSetCurDrive(DRIVEID(szDir));

            if (!IsLastWindow())
                goto DEF_MDI_PROC;      // this will close this window

            break;

        case WM_MDIACTIVATE:
            MSG("TreeWndProc", "WM_MDIACTIVATE");
            if (GET_WM_MDIACTIVATE_FACTIVATE(hWnd, wParam, lParam)) {           // we are receiving the activation

                lFreeSpace = -1L;
                UpdateStatus(hWnd);

                hwndFocus = (HWND)GetWindowLongPtr(hWnd, GWLP_LASTFOCUS);
                SetFocus(hwndFocus);
            } else if (hwndDrives = HasDrivesWindow(hWnd))
                SendMessage(hwndDrives,wMsg,wParam,lParam);
            break;

        case WM_SETFOCUS:
            MSG("TreeWndProc", "WM_SETFOCUS");

            hwndFocus = (HWND)GetWindowLongPtr(hWnd, GWLP_LASTFOCUS);
            SetFocus(hwndFocus);
            break;

        case WM_INITMENUPOPUP:
            MSG("TreeWndProc", "WM_INITMENUPOPUP");
            if (HIWORD(lParam)) {
                EnableMenuItem((HMENU)wParam, SC_CLOSE,
                               IsLastWindow() ? MF_BYCOMMAND | MF_DISABLED | MF_GRAYED :
                               MF_ENABLED);
            }
            break;


        case WM_SYSCOMMAND:
            MSG("TreeWndProc", "WM_SYSCOMMAND");

            if (wParam != SC_SPLIT)
                goto DEF_MDI_PROC;

            GetClientRect(hWnd, &rc);

            lParam = MAKELONG(rc.right / 2, 0);

            // fall through

        case WM_LBUTTONDOWN:
            MSG("TreeWndProc", "WM_LBUTTONDOWN");
            {
                MSG msg;
                INT x, y, dx, dy;

                if (IsIconic(hWnd))
                    break;

                if (hwndDrives = GetDlgItem(hWnd, IDCW_DRIVES)) {
                    GetClientRect(hwndDrives, &rc);
                    y = rc.bottom;
                } else {
                    y = 0;
                }

                x = LOWORD(lParam);

                GetClientRect(hWnd, &rc);

                dx = 4;
                dy = rc.bottom - y;   // the height of the client less the drives window

                hdc = GetDC(hWnd);

                // split bar loop

                PatBlt(hdc, x - dx / 2, y, dx, dy, PATINVERT);

                SetCapture(hWnd);

                while (GetMessage(&msg, NULL, 0, 0)) {

                    if (msg.message == WM_KEYDOWN || msg.message == WM_SYSKEYDOWN ||
                        (msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST)) {

                        if (msg.message == WM_LBUTTONUP || msg.message == WM_LBUTTONDOWN)
                            break;

                        if (msg.message == WM_KEYDOWN) {

                            if (msg.wParam == VK_LEFT) {
                                msg.message = WM_MOUSEMOVE;
                                msg.pt.x -= 2;
                            } else if (msg.wParam == VK_RIGHT) {
                                msg.message = WM_MOUSEMOVE;
                                msg.pt.x += 2;
                            } else if (msg.wParam == VK_RETURN ||
                                       msg.wParam == VK_ESCAPE) {
                                break;
                            }

                            SetCursorPos(msg.pt.x, msg.pt.y);
                        }

                        if (msg.message == WM_MOUSEMOVE) {

                            // erase old

                            PatBlt(hdc, x - dx / 2, y, dx, dy, PATINVERT);
                            ScreenToClient(hWnd, &msg.pt);
                            x = msg.pt.x;

                            // put down new

                            PatBlt(hdc, x - dx / 2, y, dx, dy, PATINVERT);
                        }
                    } else {
                        DispatchMessage(&msg);
                    }
                }
                ReleaseCapture();

                // erase old

                PatBlt(hdc, x - dx / 2, y, dx, dy, PATINVERT);
                ReleaseDC(hWnd, hdc);

                if (msg.wParam != VK_ESCAPE) {
                    if (ResizeSplit(hWnd, x))
                        SendMessage(hWnd, WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));
                }

                break;
            }

        case WM_QUERYDRAGICON:
            MSG("TreeWndProc", "WM_QUERYDRAGICON");
            return (INT_PTR)GetTreeIcon(hWnd);
            break;

        case WM_ERASEBKGND:
            MSG("TreeWndProc", "WM_ERASEBKGND");

            if (IsIconic(hWnd)) {
                // this paints the background of the icon properly, doing
                // brush allignment and other nasty stuff

                DefWindowProc(hWnd, WM_ICONERASEBKGND, wParam, 0L);
            } else {
                goto DEF_MDI_PROC;
            }
            break;

        case WM_PAINT:
            MSG("TreeWndProc", "WM_PAINT");
            {
                PAINTSTRUCT ps;

                hdc = BeginPaint(hWnd, &ps);


                if (IsIconic(hWnd)) {
                    DrawIcon(hdc, 0, 0, GetTreeIcon(hWnd));
                } else {
                    RECT rc2;

                    GetClientRect(hWnd, &rc);
                    rc.left = GetSplit(hWnd);

                    if (rc.left >= rc.right)
                        rc.left = 0;

                    rc.right = rc.left + dxFrame;

                    GetClientRect(HasDrivesWindow(hWnd), &rc2);

                    rc2.top = rc2.bottom;
                    rc2.bottom += dyBorder;
                    rc2.left = rc.left;
                    rc2.right = rc.right;
                    FillRect(hdc, &rc2, GetStockObject(BLACK_BRUSH));

                    // draw the black pane handle

                    rc.top = rc.bottom - GetSystemMetrics(SM_CYHSCROLL);
                    FillRect(hdc, &rc, GetStockObject(BLACK_BRUSH));
                }

                EndPaint(hWnd, &ps);
                break;
            }


        case WM_SIZE:
            if (wParam != SIZEICONIC)
                ResizeWindows(hWnd,LOWORD(lParam),HIWORD(lParam));

            // if wParam is SIZENOMDICRAP this WM_SIZE was generated by us.
            // don't let this through to the DefMDIChildProc().
            // that might change the min/max state, (show parameter)
            if (wParam == SIZENOMDICRAP)
                break;
            /*** FALL THRU ***/

        default:

            DEF_MDI_PROC:

            return DefMDIChildProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}


VOID
ResizeWindows(
             HWND hwndParent,
             WORD dxWindow,
             WORD dyWindow
             )
{
    INT dy, split;
    INT cDriveRows, cDrivesPerRow;
    DWORD dw;
    HWND hwndTree,hwndDir,hwndDrives;

    GetTreeWindows(hwndParent, &hwndTree, &hwndDir, &hwndDrives);

    split = GetSplit(hwndParent);

    // user has been fixed to do this right

    dy = dyWindow + dyBorder;

    if (hwndTree) {
        if (!hwndDir)
            MoveWindow(hwndTree, dxFrame, 0, dxWindow - dxFrame + dyBorder, dy, TRUE);
        else
            MoveWindow(hwndTree, -dyBorder, 0, split + dyBorder, dy, TRUE);
    }

    if (hwndDir) {
        if (!hwndTree)
            MoveWindow(hwndDir, dxFrame, 0, dxWindow - dxFrame + dyBorder, dy, TRUE);
        else
            MoveWindow(hwndDir, split + dxFrame, 0,
                       dxWindow - split - dxFrame + dyBorder, dy, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfutil.c ===
/****************************************************************************/
/*                                                                          */
/*  WFUTIL.C -                                                              */
/*                                                                          */
/*      Windows File System String Utility Functions                        */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "lfn.h"
#include "winnet.h"
#include "wnetcaps.h"           // WNetGetCaps()
#include "stdlib.h"

int rgiDriveType[26];
PSTR CurDirCache[26];

// cache GetDriveType calls for speed

INT
DriveType(
         INT iDrive
         )
{
    if (rgiDriveType[iDrive] != -1)
        return rgiDriveType[iDrive];

    return rgiDriveType[iDrive] = MGetDriveType(iDrive);
}

VOID
InvalidateDriveType()
{
    INT i;

    for (i = 0; i < 26; i++)
        rgiDriveType[i] = -1;
}

// iDrive   zero based drive number (0 = A, 1 = B)
// returns:
//  TRUE    we have it saved pszPath gets path
//  FALSE   we don't have it saved

BOOL
APIENTRY
GetSavedDirectory(
                 INT iDrive,
                 PSTR pszPath
                 )
{

    if (CurDirCache[iDrive]) {
        lstrcpy(pszPath, CurDirCache[iDrive]);
        return TRUE;
    } else
        return FALSE;
}

VOID
APIENTRY
SaveDirectory(
             PSTR pszPath
             )
{
    INT i;

    i = DRIVEID(pszPath);

    if (CurDirCache[i])
        LocalFree((HANDLE)CurDirCache[i]);

    CurDirCache[i] = (PSTR)LocalAlloc(LPTR, lstrlen(pszPath)+1);

    if (CurDirCache[i])
        lstrcpy(CurDirCache[i], pszPath);
}

/*
 *  GetSelectedDrive() -
 *
 *  Get the selected drive from the currently active window
 *
 *  should be in wfutil.c
 */

INT
APIENTRY
GetSelectedDrive()
{
    HWND hwnd;

    hwnd = (HWND)SendMessage(hwndMDIClient,WM_MDIGETACTIVE,0,0L);
    return (INT)SendMessage(hwnd,FS_GETDRIVE,0,0L) - (INT)'A';
}

/*
 *  GetSelectedDirectory() -
 *
 *  Gets the directory selected for the drive. uses the windows
 *  z-order to give precidence to windows higher in the order.
 *
 *  works like GetCurrentDirectory() except it looks through
 *  the window list for directories first (and returns ANSI)
 *
 *  returns:
 *  lpDir   ANSI string of current dir
 */

VOID
APIENTRY
GetSelectedDirectory(
                    WORD iDrive,
                    PSTR pszDir
                    )
{
    HWND hwnd;
    WORD iDriveT;

    if (iDrive) {
        for (hwnd = GetWindow(hwndMDIClient,GW_CHILD);
            hwnd;
            hwnd = GetWindow(hwnd,GW_HWNDNEXT)) {
            iDriveT = (WORD)SendMessage(hwnd,FS_GETDRIVE,0,0L);
            if (iDrive == (WORD)(iDriveT - 'A' + 1))
                goto hwndfound;
        }
        if (!GetSavedDirectory(iDrive - 1, pszDir)) {
            SheGetDir(iDrive,pszDir);
            OemToAnsi(pszDir,pszDir);
        }
        return;
    } else
        hwnd = (HWND)SendMessage(hwndMDIClient,WM_MDIGETACTIVE,0,0L);

    hwndfound:
    SendMessage(hwnd,FS_GETDIRECTORY,MAXPATHLEN,(LPARAM)pszDir);

    StripBackslash(pszDir);
}


// avoid confusion in DOSs upper case mapping by converting to
// upper case before passing down to dos

VOID
APIENTRY
FixAnsiPathForDos(
                 LPSTR szPath
                 )
{
    if (GetNameType(szPath) == FILE_83_CI)
        AnsiUpper(szPath);

    AnsiToOem(szPath, szPath);
}

// refresh a MDI child window (works for any type of mdi child)

VOID
APIENTRY
RefreshWindow(
             HWND hwndActive
             )
{
    HWND hwndTree, hwndDir;
    LPARAM lParam;
    CHAR szDir[MAXPATHLEN];
    INT iDrive;

    cDrives = UpdateDriveList();  // updates rgiDrive[]
    InitDriveBitmaps();

    // make sure the thing is still there (floppy drive, net drive)

    iDrive = (INT)GetWindowLong(hwndActive, GWL_TYPE);
    if ((iDrive >= 0) && !CheckDrive(hwndActive, iDrive))
        return;

    // update the dir part first so tree can steal later

    if (hwndDir = HasDirWindow(hwndActive))
        SendMessage(hwndDir, FS_CHANGEDISPLAY, CD_PATH, 0L);

    if (hwndTree = HasTreeWindow(hwndActive)) {
        // remember the current directory
        SendMessage(hwndActive, FS_GETDIRECTORY, sizeof(szDir), (LPARAM)szDir);

        // update the drives windows
        SendMessage(hwndActive, FS_CHANGEDRIVES, 0, 0L);

        if (IsValidDisk(szDir[0] - 'A'))
            lParam = (LPARAM)szDir;
        else
            lParam = 0;

        // update the tree
        SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(FALSE, TRUE), lParam);
    }

    if (hwndActive == hwndSearch)
        SendMessage(hwndActive, FS_CHANGEDISPLAY, CD_PATH, 0L);
}


VOID
APIENTRY
CheckEscapes(
            LPSTR szFile
            )
{
    CHAR szT[MAXPATHLEN];
    CHAR *p, *pT;

    for (p = szFile; *p; p = (LPSTR)AnsiNext(p)) {
        switch (*p) {
            case ' ':
            case ',':
            case ';':
            case '^':
            case '"':
                {
                    // this path contains an annoying character
                    lstrcpy(szT,szFile);
                    p = szFile;
                    *p++ = '"';
                    for (pT = szT; *pT; ) {
                        if (*pT == '^' || *pT == '"')
                            *p++ = '^';
                        if (IsDBCSLeadByte(*p++ = *pT++))
                            *p++ = *pT++;
                    }
                    *p++ = '"';
                    *p = 0;
                    return;
                }
        }
    }
}

HWND
APIENTRY
GetRealParent(
             HWND hwnd
             )
{
    // run up the parent chain until you find a hwnd
    // that doesn't have WS_CHILD set

    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
        hwnd = (HWND)GetWindowLongPtr(hwnd, GWLP_HWNDPARENT);

    return hwnd;
}

VOID
APIENTRY
WFHelp(
      HWND hwnd
      )
{
    if (!WinHelp(hwnd, szWinObjHelp, HELP_CONTEXT, dwContext)) {
        MyMessageBox(hwnd, IDS_WINFILE, IDS_WINHELPERR, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
    }

}

BOOL
APIENTRY
IsLastWindow()
{
    HWND hwnd;
    INT count;

    count = 0;

    // count all non title/search windows to see if close is allowed

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
        if (!GetWindow(hwnd, GW_OWNER) && ((INT)GetWindowLong(hwnd, GWL_TYPE) >= 0))
            count++;

    return count == 1;
}

// get connection information including disconnected drives
//
// in:
//        lpDev        device name "A:" "LPT1:", etc.
//        fClosed        if FALSE closed or error drives will be converted to
//                WN_SUCCESS return codes.  if TRUE return not connected
//                and error state values (ie, the caller knows about not
//                connected and error state drives)
// out:
//        lpPath        filled with net name if return is WN_SUCCESS (or not connected/error)
// returns:
//        WN_*        error code

WORD
APIENTRY
WFGetConnection(
               LPSTR lpDev,
               LPSTR lpPath,
               BOOL fClosed
               )
{
    DWORD cb;
    UINT err;
    UINT caps;


    cb = 64;

    caps = WNetGetCaps(WNNC_CONNECTION);
    if (caps & WNNC_CON_GETCONNECTIONS)
        err = WNetGetConnection(lpDev,lpPath,&cb);
    else
        return WN_NOT_CONNECTED;

    if (err == WN_NOT_CONNECTED &&
        !(caps & WNNC_CON_RESTORECONNECTION)) {
        if (GetProfileString(szNetwork,lpDev,szNULL,lpPath,64))
            err = WN_CONNECTION_CLOSED;
    }

    if (!fClosed)
        if (err == WN_CONNECTION_CLOSED || err == WN_DEVICE_ERROR)
            err = WN_SUCCESS;

    return (WORD)err;
}



// returns the number of this MDI window as well as returning
// the text with the number stripped off
//
// returns:
//      0       this title doesn't have a number
//      > 0     the title number
//      szTitle the title with the number stripped off

INT
APIENTRY
GetMDIWindowText(
                HWND hWnd,
                LPSTR szTitle,
                INT size
                )
{
    LPSTR lp, lpLast;

    ENTER("GetMDIWindowText");

    GetWindowText(hWnd, szTitle, size);

    lpLast = NULL;

    for (lp = szTitle; *lp; lp = AnsiNext(lp))
        if (*lp == ':')
            lpLast = lp;

    if (lpLast) {
        *lpLast++ = 0;
        PRINT(BF_PARMTRACE, "OUT: szTitle=%s", szTitle);
        PRINT(BF_PARMTRACE, "OUT: window#=%s", lpLast);
        LEAVE("GetMDIWindowText");
        return atoi(lpLast);    // return the window number
    } else {
        TRACE(BF_PARMTRACE, "OUT: window#=0");
        LEAVE("GetMDIWindowText");
        return 0;               // no number on this
    }
}

// set the MDI window text and add a ":#" on the end if
// there is another window with the same title.  this is to
// avoid confusion when there are multiple MDI children
// with the same title.  be sure to use GetMDIWindowText to
// strip off the number stuff.

VOID
APIENTRY
SetMDIWindowText(
                HWND hWnd,
                LPSTR szTitle
                )
{
    CHAR szTemp[MAXPATHLEN];
    CHAR szNumber[20];
    HWND hwnd;
    INT num, max_num;

    ENTER("SetMDIWindowText");
    PRINT(BF_PARMTRACE, "hWnd=%lx", hWnd);
    PRINT(BF_PARMTRACE, "IN: szTitle=%s", szTitle);

    max_num = 0;

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

        num = GetMDIWindowText(hwnd, szTemp, sizeof(szTemp));

        if (!lstrcmp(szTemp, szTitle)) {

            if (hwnd == hWnd)
                continue;

            if (!num) {
                lstrcat(szTemp, ":1");
                // if (wTextAttribs & TA_LOWERCASE)
                //    AnsiLower(szTemp);
                SetWindowText(hwnd, szTemp);
                num = 1;
            }
            max_num = max(max_num, num);
        }
    }

    if (max_num) {
        wsprintf(szNumber, ":%d", max_num+1);
        lstrcat(szTitle, szNumber);
    }

    // if (wTextAttribs & TA_LOWERCASE)
    //    AnsiLower(szTitle);
    SetWindowText(hWnd, szTitle);
    PRINT(BF_PARMTRACE, "OUT: szTitle=%s", szTitle);
    LEAVE("SetMDIWindowText");
}


#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')
#ifdef INLIBRARY
INT
APIENTRY
atoi(
    LPSTR sz
    )
{
    INT n = 0;
    BOOL bNeg = FALSE;

    if (*sz == '-') {
        bNeg = TRUE;
        sz++;
    }

    while (ISDIGIT(*sz)) {
        n *= 10;
        n += *sz - '0';
        sz++;
    }
    return bNeg ? -n : n;
}
#endif

// fills in rgiDrive[] and returns the number of drives

INT
APIENTRY
UpdateDriveList()
{
    INT i, cRealDrives = 0;
    DWORD dwDrives;

    dwDrives = GetLogicalDrives();

    for (i = 0; i < 26; i++) {
        if ((1 << i) & dwDrives) {
            rgiDrive[cRealDrives++] = i;
            rgiDriveType[i] =  MGetDriveType(i);
        } else {
            rgiDrive[i] = 0;
            rgiDriveType[i] = -1;        // invalidate the drivetype
        }

        if (apVolInfo[i]) {              // sothat volinfo is refreshed
            LocalFree(apVolInfo[i]);
            apVolInfo[i] = NULL;
        }
    }

    return cRealDrives;
}

int
GetBootDisk()
{
    CHAR szTemp[MAXPATHLEN];
        // well, close enough...
    if (GetWindowsDirectory(szTemp, sizeof(szTemp))) {
        return szTemp[0] - 'A';
    } else {
        return 'a';
    }
}


//
// IsCDROM()  - determine if a drive is a CDROM drive
//
//      iDrive      drive index (0=A, 1=B, ...)
//
// return TRUE/FALSE
//
WORD
APIENTRY
IsCDRomDrive(
            INT iDrive
            )
{
    if (rgiDriveType[iDrive] == DRIVE_CDROM)
        return (TRUE);
    return (FALSE);
}


// this is called for every drive at init time so it must
// be sure to not trigget things like the phantom B: drive support
//
// iDrive is a zero based drive number (0 = A, 1 = B)

WORD
APIENTRY
IsNetDrive(
          INT iDrive
          )
{
    INT err;
    CHAR szDrive[3];
    CHAR szConn[64];    // this really should be WNBD_MAX_LENGTH
                        // but this change would have to be many everywhere

    szDrive[0] = (CHAR)(iDrive+'A');
    szDrive[1] = ':';
    szDrive[2] = (CHAR)0;

    if (IsCDRomDrive(iDrive))   // this is bogus...  move this out
        return 0;

    err = WFGetConnection(szDrive, szConn, TRUE);

    if (err == WN_SUCCESS)
        return 1;

    if (err == WN_CONNECTION_CLOSED || err == WN_DEVICE_ERROR)
        return 2;

    return 0;
}


BOOL
APIENTRY
IsRemovableDrive(
                INT iDrive
                )
{
    return DriveType(iDrive) == DRIVE_REMOVABLE;
}


BOOL
APIENTRY
IsRemoteDrive(
             INT iDrive
             )
{
    return DriveType(iDrive) == DRIVE_REMOTE;
}


// iDrive   zero based drive number (A = 0)

BOOL
APIENTRY
IsRamDrive(
          INT iDrive
          )
{
    return DriveType(iDrive) == DRIVE_RAMDISK;
}


// get interesting stuff about a drive
//
// zero based drive numbers (0 = A, 1 = B)
//

DWORD
APIENTRY
GetClusterInfo(
              WORD drive
              )
{
    UNREFERENCED_PARAMETER(drive);
    return 0;
}



BOOL
APIENTRY
IsValidDisk(
           INT iDrive
           )
{
    if (apVolInfo[iDrive] == NULL)
        FillVolumeInfo(iDrive);

    return (apVolInfo[iDrive] != NULL);
}


VOID
APIENTRY
GetVolShare(
           WORD wDrive,
           LPSTR szVolShare
           )
{
    CHAR szDrive[5];

    szVolShare[0] = TEXT('\0');

    lstrcpy(szVolShare, "Objects");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsLFNSelected() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
IsLFNSelected()
{
    HWND  hwndActive;
    BOOL  fDir;
    LPSTR p;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    p = (LPSTR)SendMessage(hwndActive, FS_GETSELECTION, 2, (LPARAM)&fDir);
    if (p) {
        LocalFree((HANDLE)p);
    }

    return (fDir);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetSelection() -                                                        */

//  caller must free lpstr returned.
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPSTR
APIENTRY
GetSelection(
            INT iSelType
            )
{
    HWND  hwndActive;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    return (LPSTR)SendMessage(hwndActive,FS_GETSELECTION, (WPARAM)iSelType, 0L);
}


//
// in:
//      pFrom   pointer that is used as start of selection search.
//              on subsequent calls pass in the previous non NULL
//              return value
//
// out:
//      pTo     buffer that receives the next file in the list
//              for non NULL return
//
// returns:
//      NULL    if no more files in this list (szFile) is undefined
//      pointer to be passed to subsequent calls to this function
//      to enumerate thorough the file list
//

LPSTR
APIENTRY
GetNextFile(
           LPSTR pFrom,
           LPSTR pTo,
           INT cbMax
           )
{
    INT i;

    ENTER("GetNextFile");
    PRINT(BF_PARMTRACE, "IN: pFrom=%s", pFrom);

    if (!pFrom)
        return NULL;

    /* Skip over leading spaces and commas. */
    while (*pFrom && (*pFrom == ' ' || *pFrom == ','))
        pFrom = (LPSTR)AnsiNext(pFrom);

    if (!*pFrom)
        return (NULL);

    if (*pFrom == '\"') {
        pFrom = (LPSTR)AnsiNext(pFrom);

        /* Find the next quote */
        for (i=0; *pFrom && *pFrom != '\"';) {
            if (*pFrom == '^') {
                pFrom = (LPSTR)AnsiNext(pFrom);
                if (!*pFrom)
                    break;
            }

            if (i < cbMax - 1) {
                i++;
                if (IsDBCSLeadByte(*pTo++ = *pFrom++)) {
                    i++;
                    *pTo++ = *pFrom++;
                }
            }
        }
        pFrom = (LPSTR)AnsiNext(pFrom);
    } else {
        /* Find the next space or comma. */
        for (i=0; *pFrom && *pFrom != ' ' && *pFrom != ',';) {
            if (*pFrom == '^') {
                pFrom = (LPSTR)AnsiNext(pFrom);
                if (!*pFrom)
                    break;
            }

            if (i < cbMax - 1) {
                i++;
                if (IsDBCSLeadByte(*pTo++ = *pFrom++)) {
                    i++;
                    *pTo++ = *pFrom++;
                }
            }
        }
    }

    *pTo = TEXT('\0');

    PRINT(BF_PARMTRACE, pTo ? "OUT: pTo=%s" : "OUT: pTo=NULL", pTo);
    LEAVE("GetNextFile");

    return (pFrom);
}


// sets the DOS current directory based on the currently active window

VOID
APIENTRY
SetWindowDirectory()
{
    CHAR szTemp[MAXPATHLEN];

    GetSelectedDirectory(0, szTemp);
    FixAnsiPathForDos(szTemp);
    SheChangeDir(szTemp);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SetDlgDirectory() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Sets the IDD_DIR field of 'hDlg' to whatever the active window says is the
 * active directory.
 *
 * this does not really change the DOS current directory
 */

VOID
APIENTRY
SetDlgDirectory(
               HWND hDlg,
               PSTR pszPath
               )
{
    HDC       hDC;
    INT       dx;
    RECT      rc;
    HWND      hDlgItem;
    HANDLE    hFont;
    CHAR      szPath[MAXPATHLEN+5];
    CHAR      szTemp[MAXPATHLEN+20];

    ENTER("SetDlgDirectory");

    if (pszPath)
        lstrcpy(szPath, pszPath);
    else
        GetSelectedDirectory(0, szPath);

    /* Make sure that the current directory fits inside the static text field. */
    hDlgItem = GetDlgItem(hDlg, IDD_DIR);
    GetClientRect(hDlgItem, &rc);

    if (LoadString(hAppInstance, IDS_CURDIRIS, szMessage, sizeof(szMessage))) {
        hDC = GetDC(hDlg);
        hFont = (HANDLE)SendMessage(hDlgItem, WM_GETFONT, 0, 0L);
        if (hFont = SelectObject(hDC, hFont)) {
            MGetTextExtent(hDC, szMessage, lstrlen(szMessage), &dx, NULL);
            CompactPath(hDC, szPath, (WORD)(rc.right-rc.left-dx));
        }
        SelectObject(hDC, hFont);
        ReleaseDC(hDlg, hDC);
        wsprintf(szTemp, szMessage, (LPSTR)szPath);
        SetDlgItemText(hDlg, IDD_DIR, szTemp);
    }

    LEAVE("SetDlgDirectory");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WritePrivateProfileBool() -                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
WritePrivateProfileBool(
                       LPSTR szKey,
                       BOOL bParam
                       )
{
    CHAR  szBool[6];

    wsprintf(szBool, "%d", bParam);
    WritePrivateProfileString(szSettings, szKey, szBool, szTheINIFile);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WFQueryAbort() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
WFQueryAbort()

{
    MSG   msg;

    while (PeekMessage(&msg, NULL, 0, 0, TRUE)) {
        if (!IsDialogMessage(hdlgProgress, &msg))
            DispatchMessage(&msg);
    }
    return (bUserAbort);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsWild() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns TRUE iff the path contains * or ? */

BOOL
APIENTRY
IsWild(
      LPSTR lpszPath
      )
{
    while (*lpszPath) {
        if (*lpszPath == '?' || *lpszPath == '*')
            return (TRUE);
        lpszPath = AnsiNext(lpszPath);
    }

    return (FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CheckSlashies() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Replaces frontslashes (evil) with backslashes (good). */

VOID
APIENTRY
CheckSlashies(
             LPSTR lpT
             )
{
    while (*lpT) {
        if (*lpT == '/')
            *lpT = '\\';
        lpT = AnsiNext(lpT);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddBackslash() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Ensures that a path ends with a backslash. */

VOID
APIENTRY
AddBackslash(
            LPSTR lpszPath
            )
{
    ENTER("AddBackslash");
    PRINT(BF_PARMTRACE, "IN: lpszPath=%s", lpszPath);

    if (*AnsiPrev(lpszPath,lpszPath+lstrlen(lpszPath)) != '\\')
        lstrcat(lpszPath, "\\");

    PRINT(BF_PARMTRACE, "OUT: lpszPath=%s", lpszPath);

    LEAVE("AddBackslash");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripBackslash() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Removes a trailing backslash from a proper directory name UNLESS it is
 * the root directory.  Assumes a fully qualified directory path.
 */

VOID
APIENTRY
StripBackslash(
              LPSTR lpszPath
              )
{
    register WORD len;

    len = lstrlen(lpszPath) - (IsDBCSLeadByte(*AnsiPrev(lpszPath,lpszPath+lstrlen(lpszPath))) ? 2 : 1);
    if ((len == 2) || (lpszPath[len] != '\\'))
        return;

    lpszPath[len] = TEXT('\0');
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripFilespec() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Remove the filespec portion from a path (including the backslash). */

VOID
APIENTRY
StripFilespec(
             LPSTR lpszPath
             )
{
    LPSTR     p;

    p = lpszPath + lstrlen(lpszPath);
    while ((*p != '\\') && (*p != ':') && (p != lpszPath))
        p = AnsiPrev(lpszPath, p);

    if (*p == ':')
        p++;

    /* Don't strip backslash from root directory entry. */
    if (p != lpszPath) {
        if ((*p == '\\') && (*(p-1) == ':'))
            p++;
    } else
        p++;

    *p = TEXT('\0');
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripPath() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Extract only the filespec portion from a path. */

VOID
APIENTRY
StripPath(
         LPSTR lpszPath
         )
{
    LPSTR     p;

    ENTER("StripPath");
    PRINT(BF_PARMTRACE, "IN: lpszPath=%s", lpszPath);

    p = lpszPath + lstrlen(lpszPath);
    while ((*p != '\\') && (*p != ':') && (p != lpszPath))
        p = AnsiPrev(lpszPath, p);

    if (p != lpszPath || *p == '\\')
        p++;

    if (p != lpszPath)
        lstrcpy(lpszPath, p);

    PRINT(BF_PARMTRACE, "OUT: lpszPath=%s", lpszPath);
    LEAVE("StripPath");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetExtension() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns the extension part of a filename. */

LPSTR
APIENTRY
GetExtension(
            LPSTR pszFile
            )
{
    PSTR p, pSave = NULL;

    p = pszFile;
    while (*p) {
        if (*p == '.')
            pSave = p;
        p = (LPSTR)AnsiNext(p);
    }

    if (!pSave)
        return (p);

    return (LPSTR)AnsiNext(pSave);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindExtensionInList() -                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns TRUE if 'lpszExt' is somewhere in 'pszList'. */

BOOL
APIENTRY
FindExtensionInList(
                   LPSTR pszExt,
                   LPSTR pszList
                   )
{
    LPSTR p2;
    CHAR ch;

    while (*pszList) {
        /* Move to the next item in the list. */
        while ((*pszList) && (*pszList == ' '))
            pszList = (LPSTR)AnsiNext(pszList);

        if (!*pszList)
            break;

        /* NULL-terminate this item. */
        p2 = (LPSTR)AnsiNext(pszList);
        while ((*p2) && (*p2 != ' '))
            p2 = (LPSTR)AnsiNext(p2);
        ch = *p2;
        *p2 = TEXT('\0');
        if (!lstrcmpi(pszExt, pszList)) {
            *p2 = ch;
            return (TRUE);
        }
        *p2 = ch;
        pszList = p2;
    }
    return (FALSE);
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyMessageBox() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
MyMessageBox(
            HWND hWnd,
            WORD idTitle,
            WORD idMessage,
            WORD wStyle
            )
{
    CHAR  szTemp[MAXMESSAGELEN];
    HWND hwndT;

    LoadString(hAppInstance, idTitle, szTitle, sizeof(szTitle));

    if (idMessage < 32) {
        LoadString(hAppInstance, IDS_UNKNOWNMSG, szTemp, sizeof(szTemp));
        wsprintf(szMessage, szTemp, idMessage);
    } else
        LoadString(hAppInstance, idMessage, szMessage, sizeof(szMessage));

    if (hWnd)
        hwndT = GetLastActivePopup(hWnd);
    else
        hwndT = hWnd;

    return MessageBox(hwndT, szMessage, szTitle, wStyle | MB_TASKMODAL);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ExecProgram() -                                                         */
/*                                                                          */
/*  all strings are OEM                                                     */
/*--------------------------------------------------------------------------*/

/* Returns 0 for success.  Otherwise returns a IDS_ string code. */

WORD
APIENTRY
ExecProgram(
           LPSTR lpPath,
           LPSTR lpParms,
           LPSTR lpDir,
           BOOL bLoadIt
           )
{
    WORD          ret;
    INT           iCurCount;
    INT           i;
    HCURSOR       hCursor;

    ENTER("ExecProgram");

    ret = 0;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    iCurCount = ShowCursor(TRUE) - 1;

    /* open the object
     */

    if (lpPath)
        OemToAnsi(lpPath, lpPath);
    if (lpParms)
        OemToAnsi(lpParms, lpParms);
    if (lpDir)
        OemToAnsi(lpDir, lpDir);

    // Shell Execute takes ansi string.
    //
    ret = (WORD)RealShellExecute(hwndFrame, NULL, lpPath, lpParms, lpDir, NULL, NULL, NULL, (WORD)(bLoadIt ? SW_SHOWMINNOACTIVE : SW_SHOWNORMAL), NULL);

    DosResetDTAAddress(); // undo any bad things COMMDLG did

    if (lpPath)
        AnsiToOem(lpPath, lpPath);
    if (lpParms)
        AnsiToOem(lpParms, lpParms);
    if (lpDir)
        AnsiToOem(lpDir, lpDir);

    switch (ret) {
        case 0:
        case 8:
            ret = IDS_NOMEMORYMSG;
            break;

        case 2:
            ret = IDS_FILENOTFOUNDMSG;
            break;

        case 3:
        case 5:        // access denied
            ret = IDS_BADPATHMSG;
            break;

        case 4:
            ret = IDS_MANYOPENFILESMSG;
            break;

        case 10:
            ret = IDS_NEWWINDOWSMSG;
            break;

        case 12:
            ret = IDS_OS2APPMSG;
            break;

        case 15:
            /* KERNEL has already put up a messagebox for this one. */
            ret = 0;
            break;

        case 16:
            ret = IDS_MULTIPLEDSMSG;
            break;

        case 18:
            ret = IDS_PMODEONLYMSG;
            break;

        case 19:
            ret = IDS_COMPRESSEDEXE;
            break;

        case 20:
            ret = IDS_INVALIDDLL;
            break;

        case SE_ERR_SHARE:
            ret = IDS_SHAREERROR;
            break;

        case SE_ERR_ASSOCINCOMPLETE:
            ret = IDS_ASSOCINCOMPLETE;
            break;

        case SE_ERR_DDETIMEOUT:
        case SE_ERR_DDEFAIL:
        case SE_ERR_DDEBUSY:
            ret = IDS_DDEFAIL;
            break;

        case SE_ERR_NOASSOC:
            ret = IDS_NOASSOCMSG;
            break;

        default:
            if (ret < 32)
                goto EPExit;

            if (bMinOnRun && !bLoadIt)
                ShowWindow(hwndFrame, SW_SHOWMINNOACTIVE);
            ret = 0;
    }

    EPExit:
    i = ShowCursor(FALSE);

#if 0

    /* Make sure that the cursor count is still balanced. */
    if (i != iCurCount)
        ShowCursor(TRUE);
#endif

    SetCursor(hCursor);

    PRINT(BF_PARMTRACE, "OUT: ret=%ud", ret);
    LEAVE("ExecProgram");
    return ret;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsProgramFile() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns TRUE is the Path points to a file which has one of the extentions
 * listed in the "Programs=" portions of WIN.INI.
 */

BOOL
APIENTRY
IsProgramFile(
             LPSTR lpszPath
             )
{
    LPSTR szExt;
    CHAR szTemp[MAXPATHLEN];

    /* Move the string into our own DS. */
    lstrcpy(szTemp, lpszPath);

    /* Get the file's extension. */
    StripPath(szTemp);
    szExt = GetExtension(szTemp);

    if (!*szExt) {
        /* The specified path didn't have an extention.  It can't be a program. */
        return (FALSE);
    }

    return FindExtensionInList(szExt, szPrograms);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsDocument() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns TRUE is the Path points to a file which has one of the extentions
 * listed in the "Documents=" portions of WIN.INI or one which has an Association.
 */

BOOL
APIENTRY
IsDocument(
          LPSTR lpszPath
          )
{
    LPSTR szExt;
    CHAR szTemp[MAXPATHLEN];

    /* Move the string into our own DS. */
    lstrcpy(szTemp, lpszPath);

    /* Get the file's extension. */
    StripPath(szTemp);
    szExt = GetExtension(szTemp);

    if (!*szExt) {
        /* The specified path didn't have an extention.  It can't be a program. */
        return (FALSE);
    }

    return FindExtensionInList(szExt, szDocuments);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfsearch.c ===
/****************************************************************************/
/*                                                                          */
/*  WFSEARCH.C -                                                            */
/*                                                                          */
/*      File System Search Routines                                         */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "lfn.h"

INT maxExt;
INT iDirsRead;
DWORD LastUpdateTime;


WORD APIENTRY StackAvail(VOID);
INT FillSearchLB(HWND hwndLB, LPSTR szSearchFileSpec, BOOL bSubDirOnly);
INT SearchList(HWND hwndLB, LPSTR szPath, LPSTR szFileSpec, BOOL bRecurse, LPHANDLE lphMem, INT iFileCount);
LPSTR SearchGetSelection(HWND hwndLB, BOOL bMostRecent, BOOL *pfDir);


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SearchList() -                                                          */
/*                                                                          */
/*  This is a recursive routine.  It returns the number of files found.     */
//  szPath      OEM
//  szFileSpec  OEM
/*                                                                          */
/*--------------------------------------------------------------------------*/

#define DTA_GRANULARITY 20

INT
SearchList(
          HWND hwndLB,
          LPSTR szPath,
          LPSTR szFileSpec,
          BOOL bRecurse,
          LPHANDLE lphMem,
          INT iFileCount
          )
{
    INT           iRetVal;
    INT           cxExt;
    BOOL          bFound;
    LPSTR          pszNewPath;
    LPSTR          pszNextFile;
    LFNDTA        lfndta;
    LPDTASEARCH   lpdtasch;
    HDC hdc;
    HANDLE hOld;
    HANDLE hMem, hMemT;
    DWORD     TimeNow;

    STKCHK();

    hMem = *lphMem;

    /* Just return 0 files so parent dirs will still be searched
     */
    if (StackAvail() < 1024)
        return(iFileCount);

    TimeNow = GetTickCount();

    if (TimeNow > LastUpdateTime+1000) {
        LastUpdateTime = TimeNow;
        if (LoadString(hAppInstance, IDS_DIRSREAD, szMessage, sizeof(szMessage)))
            wsprintf(szStatusTree, szMessage, iDirsRead);

        InvalidateRect(hwndFrame, NULL, FALSE);
        UpdateWindow(hwndFrame);
    }

    iDirsRead++;

    if (!hMem) {
        hMem = LocalAlloc(LPTR, (DWORD)DTA_GRANULARITY * sizeof(DTASEARCH));
        if (!hMem)
            return -1;
        *lphMem = hMem;
    }
    lpdtasch = (LPDTASEARCH)LocalLock(hMem);

    // allocate the buffer for this level
    pszNewPath = (LPSTR)LocalAlloc(LPTR, lstrlen(szPath) + MAXFILENAMELEN + 2);
    if (!pszNewPath)
        return -1;

    lstrcpy(pszNewPath, szPath);
    AddBackslash(pszNewPath);
    pszNextFile = pszNewPath + lstrlen(pszNewPath);
    lstrcpy(pszNextFile, szFileSpec);

    bFound = WFFindFirst(&lfndta, pszNewPath, ATTR_ALL);

    hdc = GetDC(hwndLB);
    hOld = SelectObject(hdc, hFont);

    while (bFound) {

        // alow escape to exit
        if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) {
            bRecurse = FALSE;
            iFileCount = -1;
            break;
        }

        // Make sure this is not a "." or ".." directory

        if (lfndta.fd.cFileName[0] != '.') {
            BOOL bLFN;

            lstrcpy(pszNextFile, lfndta.fd.cFileName);
            OemToAnsi(pszNewPath, szMessage);

            bLFN = IsLFN(lfndta.fd.cFileName);

            iRetVal = (INT)SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)szMessage);

            MGetTextExtent(hdc, szMessage, lstrlen(szMessage), &cxExt, NULL);
            maxExt = max(maxExt, cxExt);

            if (iRetVal >= 0) {

                if (iFileCount && ((iFileCount % DTA_GRANULARITY) == 0)) {
                    LocalUnlock(hMem);

                    if (!(hMemT = LocalReAlloc(hMem, (DWORD)((iFileCount + DTA_GRANULARITY) * sizeof(DTASEARCH)), LMEM_MOVEABLE))) {
                        LocalLock(hMem);
                        bRecurse = FALSE;       // simulate an abort
                        iFileCount = -1;
                        break;
                    } else {
                        hMem = hMemT;
                        *lphMem = hMemT;
                    }

                    lpdtasch = (LPDTASEARCH)LocalLock(hMem);
                }
                lpdtasch[iFileCount] = *((LPDTASEARCH)(&lfndta.fd));
                if (bLFN)
                    lpdtasch[iFileCount].sch_dwAttrs |= ATTR_LFN;
                SendMessage(hwndLB, LB_SETITEMDATA, iRetVal, (LONG)iFileCount);
                iFileCount++;
            }
        }

        /* Search for more files in the current directory */
        bFound = WFFindNext(&lfndta);
    }

    WFFindClose(&lfndta);

    if (hOld)
        SelectObject(hdc, hOld);
    ReleaseDC(hwndLB, hdc);

    LocalUnlock(hMem);
    SetWindowLongPtr(GetParent(hwndLB), GWLP_HDTASEARCH, (LONG_PTR)hMem);

    if (!bRecurse)
        goto SearchEnd;

    /* Now see if there are any subdirectories here */
    lstrcpy(pszNextFile, szStarDotStar);

    bFound = WFFindFirst(&lfndta, pszNewPath, ATTR_DIR | ATTR_HS);

    while (bFound) {

        // alow escape to exit
        if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) {
            bRecurse = FALSE;
            iFileCount = -1;
            break;
        }

        /* Make sure this is not a "." or ".." directory. */
        if ((lfndta.fd.cFileName[0] != '.') && (lfndta.fd.dwFileAttributes & ATTR_DIR)) {
            /* Yes, search and add files in this directory */
            lstrcpy(pszNextFile, lfndta.fd.cFileName);

            /* Add all files in this subdirectory. */
            if ((iRetVal = SearchList(hwndLB, pszNewPath, szFileSpec, bRecurse, lphMem, iFileCount)) < 0) {
                iFileCount = iRetVal;
                break;
            }
            iFileCount = iRetVal;

        }
        bFound = WFFindNext(&lfndta);
    }

    WFFindClose(&lfndta);

    SearchEnd:

    LocalFree((HANDLE)pszNewPath);
    return iFileCount;
}


VOID
FixUpFileSpec(
             LPSTR szFileSpec
             )
{
    CHAR szTemp[MAXPATHLEN+1];
    register LPSTR p;

    if (*szFileSpec == '.') {
        lstrcpy(szTemp, "*");
        lstrcat(szTemp, szFileSpec);
        lstrcpy(szFileSpec, szTemp);
    }


    /* HACK:  If there isn't a dot and the last char is a *, append ".*" */
    p = szFileSpec;
    while ((*p) && (*p != '.'))
        p = AnsiNext(p);

    if ((!*p) && (p != szFileSpec)) {
        p = AnsiPrev(szFileSpec, p);
        if (*p == '*')
            lstrcat(p, ".*");
    }

}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FillSearchLB() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  This parses the given string for Drive, PathName, FileSpecs and
 *  calls SearchList() with proper parameters;
 *
 *  hwndLB           : List box where files are to be displayed;
 *  szSearchFileSpec : ANSI path to search
 *  bSubDirOnly      : TRUE, if only subdirectories are to be searched;
 */

INT
FillSearchLB(
            HWND hwndLB,
            LPSTR szSearchFileSpec,
            BOOL bRecurse
            )
{
    INT           iRet;
    HCURSOR       hCursor;
    CHAR          szFileSpec[MAXPATHLEN+1];
    CHAR          szPathName[MAXPATHLEN+1];
    HANDLE        hMemIn = NULL;

    FixAnsiPathForDos(szSearchFileSpec);
    /* Get the file specification part of the string. */
    lstrcpy(szFileSpec, szSearchFileSpec);
    lstrcpy(szPathName, szSearchFileSpec);
    StripPath(szFileSpec);
    StripFilespec(szPathName);

    FixUpFileSpec(szFileSpec);

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);
    maxExt = 0;
    iDirsRead = 1;
    LastUpdateTime = 0;
    iRet = SearchList(hwndLB, szPathName, szFileSpec, bRecurse, &hMemIn, 0);
    ShowCursor(FALSE);
    SetCursor(hCursor);

    SendMessage(hwndLB, LB_SETSEL, TRUE, 0L);

    return(iRet);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SearchGetSelection() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns a string containing the names of the selected
 * files seperated by spaces.  If bMostRecent is TRUE, it only returns the
 * most recently selected file.
 *
 * The string is returned and a *pfDir is set indicating if it points
 * to a directory.
 *
 * NOTE: The caller must free the returned pointer!
 */

LPSTR
SearchGetSelection(
                  HWND hwndLB,
                  BOOL bMostRecent,
                  BOOL *pfDir
                  )
{
    register LPSTR p;
    LPSTR          pT;
    register WORD i;
    WORD          iMac;
    WORD          cch = 1;
    BOOL          bDir;
    HANDLE hMem;
    LPDTASEARCH lpdtasch;
    CHAR szTemp[MAXPATHLEN];

    BOOL bLFNTest;

    if (bLFNTest = (bMostRecent == 2)) {
        bMostRecent = FALSE;
    } else {
        p = (LPSTR)LocalAlloc(LPTR, 1);
        if (!p)
            return NULL;
    }

    if (bMostRecent == 3)
        bMostRecent = 0;

    bDir = TRUE;

    iMac = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    hMem = (HANDLE)GetWindowLongPtr(GetParent(hwndLB), GWLP_HDTASEARCH);

    lpdtasch = (LPDTASEARCH)LocalLock(hMem);

    for (i=0; i < iMac; i++) {
        if (!(BOOL)SendMessage(hwndLB, LB_GETSEL, i, 0L))
            continue;

        cch += (WORD)SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)szTemp);
        cch++;

        if (bLFNTest) {
            if (IsLFN(szTemp)) {
                if (pfDir)
                    *pfDir = TRUE;
                return NULL;
            }
        } else {
            pT = (LPSTR)LocalReAlloc((HANDLE)p, cch, LMEM_MOVEABLE | LMEM_ZEROINIT);
            if (!pT)
                goto SGSExit;
            p = pT;
            lstrcat(p, szTemp);

            bDir = lpdtasch[(INT)SendMessage(hwndLB, LB_GETITEMDATA, i, 0L)].sch_dwAttrs & ATTR_DIR;

            if (bMostRecent)
                break;

            lstrcat(p, szBlank);
        }
    }
    SGSExit:
    LocalUnlock(hMem);

    if (bLFNTest) {
        if (pfDir)
            *pfDir = FALSE;
        return NULL;
    }

    if (pfDir)
        *pfDir = bDir;
    return(p);
}


VOID
CreateLine(
          WORD wLineFormat,
          LPSTR szFile,
          LPDTASEARCH lpdtasch,
          LPSTR szBuffer
          )
{
    LPSTR pch;
    BYTE chAttribute;

    pch = szBuffer;

    chAttribute = (BYTE)lpdtasch->sch_dwAttrs;

    /* Copy the file name. */
    lstrcpy(pch, szFile);
    pch += lstrlen(pch);

    *pch = TEXT('\0');

    /* Should we show the size? */
    if (wLineFormat & VIEW_SIZE) {
        *pch++ = TABCHAR;
        if (!(chAttribute & ATTR_DIR))
            pch += PutSize(lpdtasch->sch_nFileSizeLow, pch);
    }

    /* Should we show the date? */
    if (wLineFormat & VIEW_DATE) {
        *pch++ = TABCHAR;
        pch += PutDate(&lpdtasch->sch_ftLastWriteTime, pch);
    }

    /* Should we show the time? */
    if (wLineFormat & VIEW_TIME) {
        *pch++ = TABCHAR;
        pch += PutTime(&lpdtasch->sch_ftLastWriteTime, pch);
    }

    /* Should we show the attributes? */
    if (wLineFormat & VIEW_FLAGS) {
        *pch++ = TABCHAR;
        pch += PutAttributes((WORD)chAttribute, pch);
    }
}


// the window text looks like "Search Window: C:\FOO\BAR\*.*"

VOID
GetSearchPath(
             HWND hWnd,
             LPSTR pszPath
             )
{
    LPSTR p;

    CHAR szTemp[MAXPATHLEN+32];

    // the search window doesn't have a current directory
    GetWindowText(hWnd, szTemp, sizeof(szTemp));

    // the window text looks like "Search Window: C:\FOO\BAR\*.*"
    p = szTemp;
    while (*p && *p != ':') // find the :
        p = AnsiNext(p);

    p += 2;                 // skip the ": "

    lstrcpy(pszPath, p);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  UpdateSearchStatus() -                          */
/*                                      */
/*--------------------------------------------------------------------------*/

VOID
UpdateSearchStatus(
                  HWND hwndLB
                  )
{
    INT nCount;

    nCount = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
    if (LoadString(hAppInstance, IDS_SEARCHMSG, szMessage, sizeof(szMessage)))
        wsprintf(szStatusTree, szMessage, nCount);
    szStatusDir[0] = '\0';
    InvalidateRect(hwndFrame, NULL, FALSE);
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  SearchWndProc() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
SearchWndProc(
             register HWND hWnd,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    INT  iRet;
    INT  iSel;
    HWND hwndLB;
    CHAR szTemp[MAXPATHLEN + 32];
    CHAR szPath[MAXPATHLEN];

    STKCHK();

    hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX);

    switch (wMsg) {
        case FS_GETDRIVE:
            MSG("SearchWndProc", "FS_GETDRIVE");
            // Returns the letter of the corresponding directory

            SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
            return szPath[0];     // first character

        case FS_GETDIRECTORY:
            MSG("SearchWndProc", "FS_GETDIRECTORY");

            GetSearchPath(hWnd, szPath);

            StripFilespec(szPath);        // remove the filespec
            AddBackslash(szPath);         // to be the same as DirWndProc
            lstrcpy((LPSTR)lParam, szPath);
            break;

        case FS_GETFILESPEC:

            MSG("SearchWndProc", "FS_GETFILESPEC");
            // the search window doesn't have a current directory
            GetSearchPath(hWnd, szPath);
            StripPath(szPath);                    // remove the path (leave the filespec)
            lstrcpy((LPSTR)lParam, szPath);
            break;

        case FS_SETSELECTION:
            MSG("SearchWndProc", "FS_SETSELECTION");
            // wParam is the select(TRUE)/unselect(FALSE) param
            // lParam is the filespec to match against

            SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            DSSetSelection(hwndLB, wParam ? TRUE : FALSE, (LPSTR)lParam, TRUE);
            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
            InvalidateRect(hwndLB, NULL, TRUE);
            break;

        case FS_GETSELECTION:
            MSG("SearchWndProc", "FS_GETSELECTION");
            return (INT_PTR)SearchGetSelection(hwndLB, wParam ? TRUE : FALSE, (BOOL *)lParam);
            break;

        case WM_MDIACTIVATE:
            if (wParam) {
                UpdateSearchStatus(hwndLB);

                // if we are dirty, ask if we should update

                if (GetWindowLong(hWnd, GWL_FSCFLAG))
                    PostMessage(hWnd, FS_CHANGEDISPLAY, CD_SEARCHUPDATE, 0L);
            }
            break;

        case WM_FILESYSCHANGE:
            SetWindowLong(hWnd, GWL_FSCFLAG, TRUE);   // I need updating

            // if the search window is not active or FSCs are disabled
            // don't prompt now, wait till we get the end FSC or are
            // activated (above in WM_ACTIVATE)
            if (cDisableFSC ||
                (hWnd != (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L)) &&
                (GetActiveWindow() != hwndFrame))
                break;

            PostMessage(hWnd, FS_CHANGEDISPLAY, CD_SEARCHUPDATE, 0L);
            break;

        case FS_CHANGEDISPLAY:
            MSG("SearchWndProc", "FS_CHANGEDISPLAY");

            SetWindowLong(hWnd, GWL_FSCFLAG, FALSE);  // I am clean

            if (wParam == CD_SEARCHUPDATE) {
                LoadString(hAppInstance, IDS_SEARCHTITLE, szTitle, sizeof(szTitle));
                LoadString(hAppInstance, IDS_SEARCHREFRESH, szMessage, sizeof(szMessage));
                if (MessageBox(hWnd, szMessage, szTitle, MB_YESNO | MB_ICONQUESTION) != IDYES)
                    break;
            }

            // is this a refresh?

            if (!lParam) {
                GetSearchPath(hWnd, szPath);
            } else {
                lstrcpy(szPath, (LPSTR)lParam);   // explicit re-search
            }

            LoadString(hAppInstance, IDS_SEARCHTITLE, szMessage, 32);
            lstrcat(szMessage, szPath);
            SetWindowText(hWnd, szMessage);

            SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

            iRet = FillSearchLB(hwndLB, szPath, bSearchSubs);

            FixTabsAndThings(hwndLB,(WORD *)GetWindowLongPtr(hWnd, GWLP_TABARRAYSEARCH), maxExt + dxText,wNewView);

            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
            InvalidateRect(hwndLB, NULL, TRUE);
            if (iRet == 0) {
                LoadString(hAppInstance, IDS_SEARCHTITLE, szTitle, sizeof(szTitle));
                LoadString(hAppInstance, IDS_SEARCHNOMATCHES, szMessage, sizeof(szMessage));
                MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONINFORMATION);

                ShowWindow(hWnd, SW_HIDE);
                PostMessage(hWnd, WM_CLOSE, 0, 0L);
                return FALSE;
            } else {
                UpdateSearchStatus(hwndLB);
            }

            if (GetFocus() != hwndLB)
                return(iRet);

            /*** FALL THRU ***/

        case WM_SETFOCUS:
            MSG("SearchWndProc", "WM_SETFOCUS");

            SetFocus(hwndLB);
            return (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

        case WM_CLOSE:
            MSG("SearchWndProc", "WM_CLOSE");
            hwndSearch = NULL;
            goto DefChildProc;

        case WM_COMMAND:
            /* Was this a double-click? */
            if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
                SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_OPEN, 0, 0));
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE) {
                INT i;
                for (i = 0; i < iNumExtensions; i++) {
                    (extensions[i].ExtProc)(hwndFrame, FMEVENT_SELCHANGE, 0L);
                }
            }
            break;

        case WM_DESTROY:
            MSG("SearchWndProc", "WM_DESTROY");
            {
                HANDLE hMem;

                if (hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTASEARCH))
                    LocalFree(hMem);

                if (hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_TABARRAYSEARCH))
                    LocalFree(hMem);
            }
            break;

        case WM_CREATE:
            TRACE(BF_WM_CREATE, "SearchWndProc - WM_CREATE");
            {
                // globals used:
                //    szSearch        path to start search at
                //    bSearchSubs     tells us to do a recursive search

                RECT      rc;
                WORD      *pwTabs;

                GetClientRect(hWnd, &rc);
                hwndLB = CreateWindowEx(0, szListbox, NULL,
                                        WS_CHILD | WS_BORDER | LBS_SORT | LBS_NOTIFY |
                                        LBS_OWNERDRAWFIXED | LBS_EXTENDEDSEL |
                                        LBS_NOINTEGRALHEIGHT | LBS_WANTKEYBOARDINPUT |
                                        LBS_HASSTRINGS | WS_VSCROLL | WS_HSCROLL | WS_VISIBLE,
                                        -1, -1, rc.right+2, rc.bottom+2,
                                        hWnd, (HMENU)IDCW_LISTBOX,
                                        hAppInstance, NULL);
                if (!hwndLB)
                    return -1L;

                if ((pwTabs = (WORD *)LocalAlloc(LPTR,sizeof(WORD) * 4)) == NULL)
                    return -1L;

                hwndSearch = hWnd;
                SetWindowLong(hWnd, GWL_TYPE,   TYPE_SEARCH);
                SetWindowLong(hWnd, GWL_VIEW,   wNewView);
                SetWindowLong(hWnd, GWL_SORT,   IDD_NAME);
                SetWindowLong(hWnd, GWL_ATTRIBS,ATTR_DEFAULT);
                SetWindowLong(hWnd, GWL_FSCFLAG,   FALSE);
                SetWindowLongPtr(hWnd, GWLP_HDTASEARCH, 0);
                SetWindowLongPtr(hWnd, GWLP_TABARRAYSEARCH, (LONG_PTR)pwTabs);
                SetWindowLongPtr(hWnd, GWLP_LASTFOCUSSEARCH, (LONG_PTR)hwndLB);

                // Fill the listbox
                if (!FillSearchLB(hwndLB, szSearch, bSearchSubs)) {
                    LoadString(hAppInstance, IDS_SEARCHTITLE, szTitle, sizeof(szTitle));
                    LoadString(hAppInstance, IDS_SEARCHNOMATCHES, szMessage, sizeof(szMessage));
                    MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONINFORMATION);
                    hwndSearch = NULL;
                    return -1L;
                } else {
                    FixTabsAndThings(hwndLB,pwTabs, maxExt + dxText,wNewView);
                    SendMessage(hwndLB, WM_SETFONT, (WPARAM)hFont, 0L);
                    ShowWindow(hwndSearch, SW_SHOWNORMAL);
                }

                break;
            }

        case WM_DRAGLOOP:
            MSG("SearchWndProc", "WM_DRAGLOOP");
            /* WM_DRAGLOOP is sent to the source window as the object is moved.
             *
             *    wParam: TRUE if the object is currently over a droppable sink
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGLOOP is used to turn the source bitmaps on/off as we drag. */

            DSDragLoop(hwndLB, wParam, (LPDROPSTRUCT)lParam, TRUE);
            break;

        case WM_DRAGSELECT:
            MSG("SearchWndProc", "WM_DRAGSELECT");
            /* WM_DRAGSELECT is sent to a sink whenever an new object is dragged
             * inside of it.
             *
             *    wParam: TRUE if the sink is being entered, FALSE if it's being
             *            exited.
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGSELECT is used to turn our selection rectangle on or off. */
#define lpds ((LPDROPSTRUCT)lParam)

            iSelHilite = LOWORD(lpds->dwControlData);
            DSRectItem(hwndLB, iSelHilite, (BOOL)wParam, TRUE);
            break;

        case WM_DRAGMOVE:
            MSG("SearchWndProc", "WM_DRAGMOVE");
            /* WM_DRAGMOVE is sent to a sink as the object is being dragged
             * within it.
             *
             *    wParam: Unused
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGMOVE is used to move our selection rectangle among sub-items. */

#define lpds ((LPDROPSTRUCT)lParam)

            /* Get the subitem we are over. */
            iSel = LOWORD(lpds->dwControlData);

            /* Is it a new one? */
            if (iSel == iSelHilite)
                break;

            /* Yup, un-select the old item. */
            DSRectItem(hwndLB, iSelHilite, FALSE, TRUE);

            /* Select the new one. */
            iSelHilite = iSel;
            DSRectItem(hwndLB, iSel, TRUE, TRUE);
            break;

        case WM_DRAWITEM:
            MSG("SearchWndProc", "WM_DRAWITEM");
            {
                LPDRAWITEMSTRUCT      lpLBItem;
                HANDLE hMem;
                LPDTASEARCH lpdtasch;

                lpLBItem = (LPDRAWITEMSTRUCT)lParam;
                iSel = lpLBItem->itemID;

                if (iSel < 0)
                    break;

                SendMessage(hwndLB, LB_GETTEXT, iSel, (LPARAM)szPath);

                hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTASEARCH);
                lpdtasch = (LPDTASEARCH)LocalLock(hMem);

                iSel = (INT)SendMessage(hwndLB, LB_GETITEMDATA, iSel, 0L);
                CreateLine((WORD)GetWindowLong(hWnd, GWL_VIEW), szPath, &(lpdtasch[iSel]), szTemp);
                DrawItem(lpLBItem, szTemp, lpdtasch[iSel].sch_dwAttrs, TRUE,
                         (WORD *)GetWindowLongPtr(hWnd,GWLP_TABARRAYSEARCH));
                LocalUnlock(hMem);

                break;
            }

        case WM_DROPOBJECT:
            MSG("SearchWndProc", "WM_DROPOBJECT");
            {
                LPSTR      pFrom;
                WORD      ret;
                WORD      iSelSink;
                HANDLE hMem;
                LPDTASEARCH lpdtasch;
                DWORD attrib;

                /* WM_DROPOBJECT is sent to a sink when the user releases an
                 * acceptable object over it
                 *
                 *    wParam: TRUE if over the non-client area, FALSE if over the
                 *            client area.
                 *    lParam: LPDROPSTRUCT
                 */

#define lpds ((LPDROPSTRUCT)lParam)

                iSelSink = LOWORD(lpds->dwControlData);

                /* Are we dropping onto ourselves? (i.e. a selected item in the
                 * source listbox OR an unused area of the source listbox)  If
                 * so, don't do anything.
                 */
                if (hWnd == lpds->hwndSource) {
                    if ((iSelSink == 0xFFFF) || (SendMessage(hwndLB, LB_GETSEL, iSelSink, 0L)))
                        return TRUE;
                }

                /* Are we dropping on a unused portion of the listbox? */
                if (iSelSink == 0xFFFF)
                    return TRUE;

                /* Get the sink's filename. */
                SendMessage(hwndLB, LB_GETTEXT, iSelSink, (LPARAM)szPath);

                hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTASEARCH);
                lpdtasch = (LPDTASEARCH)LocalLock(hMem);
                attrib = lpdtasch[(INT)SendMessage(hwndLB, LB_GETITEMDATA, iSelSink, 0L)].sch_dwAttrs;
                LocalUnlock(hMem);

                /* Are we dropping on a subdirectory? */
                if (attrib & ATTR_DIR)
                    goto DirMoveCopy;

                /* Are we not dropping on a Program file? */
                if (!IsProgramFile(szPath))
                    return TRUE;

                if (lpds->wFmt == DOF_DIRECTORY) {
                    goto DODone;
                }

                /* We're dropping a file onto a program.
                 * Exec the program using the source file as the parameter.
                 */

                /* Should we confirm it first? */
                if (bConfirmMouse) {
                    LoadString(hAppInstance, IDS_MOUSECONFIRM, szTitle, MAXTITLELEN);
                    LoadString(hAppInstance, IDS_EXECMOUSECONFIRM, szTemp, sizeof(szTemp));

                    wsprintf(szMessage, szTemp, (LPSTR)szPath, (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch));
                    if (MessageBox(hwndFrame, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
                        goto DODone;
                }


                /* If we dragged from a Dir Window, add path information. */
                if (lpds->hwndSource == hWnd)
                    szTemp[0] = TEXT('\0');
                else
                    SendMessage(lpds->hwndSource, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);

                lstrcat(szTemp, (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch));
                // put a "." extension on if none found
                if (*GetExtension(szTemp) == 0)
                    lstrcat(szTemp, ".");
                FixAnsiPathForDos(szTemp);

                FixAnsiPathForDos(szPath);
                ret = ExecProgram(szPath,szTemp,NULL,FALSE);
                if (ret)
                    MyMessageBox(hwndFrame, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
                DODone:
                DSRectItem(hwndLB, iSelHilite, FALSE, TRUE);
                return TRUE;

                DirMoveCopy:
                pFrom = (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch);

                AddBackslash(szPath);     // add filespec filter
                lstrcat(szPath, szStarDotStar);

                DMMoveCopyHelper(pFrom, szPath, fShowSourceBitmaps);

                DSRectItem(hwndLB, iSelHilite, FALSE, TRUE);
                return TRUE;
            }

        case WM_LBTRACKPOINT:
            MSG("SearchWndProc", "WM_LBTRACKPOINT");
            return(DSTrackPoint(hWnd, hwndLB, wParam, lParam, TRUE));

        case WM_MEASUREITEM:
            MSG("SearchWndProc", "WM_MEASUREITEM");
            {
#define pLBMItem ((LPMEASUREITEMSTRUCT)lParam)

                pLBMItem->itemHeight = dyFileName;
                break;
            }

        case WM_QUERYDROPOBJECT:
            MSG("SearchWndProc", "WM_QUERYDROPOBJECT");
            /* Ensure that we are dropping on the client area of the listbox. */
#define lpds ((LPDROPSTRUCT)lParam)

            /* Ensure that we can accept the format. */
            switch (lpds->wFmt) {
                case DOF_EXECUTABLE:
                case DOF_DIRECTORY:
                case DOF_DOCUMENT:
                case DOF_MULTIPLE:
                    if (lpds->hwndSink == hWnd)
                        lpds->dwControlData = -1L;
                    return TRUE;
            }
            return FALSE;

        case WM_SIZE:
            MSG("SearchWndProc", "WM_SIZE");
            if (wParam != SIZEICONIC) {
                MoveWindow(GetDlgItem(hWnd, IDCW_LISTBOX),
                           -1, -1,
                           LOWORD(lParam)+2,
                           HIWORD(lParam)+2,
                           TRUE);
            }
            /*** FALL THRU ***/

        default:
            DefChildProc:
            DEFMSG("SearchWndProc", (WORD)wMsg);
            return(DefMDIChildProc(hWnd, wMsg, wParam, lParam));
    }
    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\winexp.h ===
#ifndef NOATOM
/* atom manager internals */
#define ATOMSTRUC struct atomstruct
typedef ATOMSTRUC *PATOM;
typedef ATOMSTRUC {
    PATOM chain;
    WORD  usage;             /* Atoms are usage counted. */
    BYTE  len;               /* length of ASCIZ name string */
    BYTE  name;              /* beginning of ASCIZ name string */
} ATOMENTRY;

typedef struct {
    int     numEntries;
    PATOM   pAtom[ 1 ];
} ATOMTABLE;
ATOMTABLE * pAtomTable;
#endif

LPSTR lstrbscan(LPSTR, LPSTR);
LPSTR lstrbskip(LPSTR, LPSTR);

int  OpenPathName(LPSTR, int);
int  DeletePathName(LPSTR);
WORD _ldup(int);


/* scheduler things that the world knows not */
BOOL        WaitEvent( HANDLE );
BOOL        PostEvent( HANDLE );
BOOL        KillTask( HANDLE );

/* print screen hooks */
BOOL        SetPrtScHook(FARPROC);
FARPROC     GetPrtScHook(void);

/* module stuff */
HANDLE  GetDSModule( WORD );
HANDLE  GetDSInstance( WORD );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wfsys.c ===
/****************************************************************************/
/*                                      */
/*  WFSYS.C -                                   */
/*                                      */
/*  Routines for Making Bootable Floppies                   */
/*                                      */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "wfcopy.h"

#define CSYSFILES   3   /* Three system files are to be copied */
#define SYSFILENAMELEN  16  /* Example "A:\????????.???\0" */

#define SEEK_END    2   /* Used by _llseek() */

/* Error Codes.  NOTE: Don't change this order! */
#define NOERROR     0   /* No error           */
#define NOMEMORY    1   /* Insufficient memory    */
#define NOSRCFILEBIOS   2   /* BIOS is missing    */
#define NOSRCFILEDOS    3   /* DOS is missing     */
#define NOSRCFILECMD    4   /* Command.Com is missing */
#define COPYFILEBIOS    5   /* Error in copying BIOS  */
#define COPYFILEDOS 6   /* Error in copying DOS   */
#define COPYFILECMD 7   /* Error in copying Command.com */
#define INVALIDBOOTSEC  8
#define INVALIDDSTDRIVE 9
#define DSTDISKERROR    10
#define NOTSYSABLE  11  /* First N clusters are NOT empty */
#define NOTSYSABLE1 12  /* First 2 entries in ROOT are not sys files */
#define NOTSYSABLE2 13  /* First N clusters are not allocated to SYS files */
#define NODISKSPACE 14  /* There is not sufficient disk space */

#define BUFFSIZE    8192
#define SECTORSIZE  512

LONG SysFileSize[CSYSFILES];

CHAR BIOSfile[SYSFILENAMELEN];
CHAR DOSfile[SYSFILENAMELEN];
CHAR COMMANDfile[130];  /* Command.com can have a full path name in COMSPEC= */
CHAR *SysFileNamePtr[CSYSFILES]; /* Ptrs to source file names */

/* SysNameTable contains the names of System files; First for PCDOS, the
 * second set for MSDOS.
 */
CHAR *SysNameTable[2][3] = {
    {"IBMBIO.COM", "IBMDOS.COM", "COMMAND.COM"},
    {"IO.SYS",     "MSDOS.SYS",  "COMMAND.COM"}
};


BOOL
IsSYSable(
         WORD    iSrceDrive,
         WORD    iDestDrive,
         CHAR    DestFileNames[][SYSFILENAMELEN],       /* NOTE: 2-dimensional array */
         LPSTR   lpFileBuff
         );



/*--------------------------------------------------------------------------*/
/*                                      */
/*  SameFilenames() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* This checks whether the two filenames are the same or not.
 * The problem lies in the fact that lpDirFileName points to the
 * filename as it appears in a directory (filename padded with blanks
 * up to eight characters and then followed by extension). But
 * szFileName is an ASCII string with no embedded blanks and has a
 * dot that seperates the extension from file name.
 */

BOOL
SameFilenames(
             LPSTR lpDirFileName,
             LPSTR szFileName
             )
{
    INT   i;
    CHAR  c1;
    CHAR  c2;

    /* lpDirFileName definitely has 11 characters (8+3). Nothing more!
     * Nothing less!
     */
    for (i=0; i < 11; i++) {
        c1 = *lpDirFileName++;
        c2 = *szFileName++;
        if (c2 == '.') {
            /* Skip all the blanks at the end of the filename */
            while (c1 == ' ' && i < 11) {
                c1 = *lpDirFileName++;
                i++;
            }

            c2 = *szFileName++;
        }
        if (c1 != c2)
            break;
    }
    return (i != 11);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  HasSystemFiles() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

/* See if the specified disk has IBMBIO.COM and IBMDOS.COM (or IO.SYS and
 * MSDOS.SYS).  If so, store their sizes in SysFileSize[].
 */

BOOL
APIENTRY
HasSystemFiles(
              WORD iDrive
              )
{
    INT      i;
    HFILE    fh;
    DPB      DPB;
    BOOL     rc;
    CHAR     ch;
    LPSTR    lpStr;
    LPSTR    lpFileBuff;
    OFSTRUCT OFInfo;
    HANDLE   hFileBuff;

    /* Initialise the source filename pointers */
    SysFileNamePtr[0] = &BIOSfile[0];
    SysFileNamePtr[1] = &DOSfile[0];
    SysFileNamePtr[2] = &COMMANDfile[0];

    hFileBuff = NULL;
    lpFileBuff = NULL;

    /* Acertain the presence of BIOS/DOS/COMMAND and grab their sizes.
     * First we will try IBMBIO.COM. If it does not exist, then we will try
     * IO.SYS. It it also does not exist, then it is an error.
     */

    /* Get the DPB */
    if (GetDPB(iDrive, &DPB) != NOERROR)
        goto HSFError;

    /* Check if the iDrive has standard sector size; If it doesn't then report
     * error; (We can allocate a bigger buffer and proceed at this point, but
     * int25 to read an abosolute sector may not work in pmodes, because they
     * assume standard sector sizes;)
     * Fix for Bug #10632  --SANKAR-- 03-21-90
     */
    if (HIWORD(GetClusterInfo(iDrive)) > SECTORSIZE)
        goto HSFError;

    /* Allocate enough memory to read the first cluster of root dir. */
    if (!(hFileBuff = LocalAlloc(LHND, (DWORD)SECTORSIZE)))
        goto HSFError;

    if (!(lpFileBuff = LocalLock(hFileBuff)))
        goto HSFError;

    /* Read the first cluster of the root directory. */
    if (MyInt25(iDrive, lpFileBuff, 1, DPB.dir_sector))
        goto HSFError;

    /* Let us start with the first set of system files. */
    for (i=0; i <= CSYSFILES-1; i++) {
        lstrcpy((LPSTR)SysFileNamePtr[i], "C:\\");
        lstrcat((LPSTR)SysFileNamePtr[i], SysNameTable[0][i]);
        *SysFileNamePtr[i] = (BYTE)('A'+iDrive);
    }
    /* Get the command.com from the COMSPEC= environment variable */
    lpStr = MGetDOSEnvironment();

    /* Find the COMSPEC variable. */
    while (*lpStr != TEXT('\0')) {
        if (lstrlen(lpStr) > 8) {
            ch = lpStr[7];
            lpStr[7] = TEXT('\0');
            if (lstrcmpi(lpStr, (LPSTR)"COMSPEC") == 0) {
                lpStr[7] = ch;
                break;
            }
        }
        lpStr += lstrlen(lpStr)+1;
    }

    /* If no COMSPEC then things are really roached... */
    if (*lpStr == TEXT('\0'))
        goto HSFError;

    /* The environment variable is COMSPEC; Look for '=' char */
    while (*lpStr != '=')
        lpStr = AnsiNext(lpStr);

    /* Copy the command.com with the full pathname */
    lstrcpy((LPSTR)SysFileNamePtr[2], lpStr);

    /* Check if the IBMBIO.COM and IBMDOS.COM exist. */
    if (SameFilenames(lpFileBuff, (LPSTR)(SysFileNamePtr[0]+3)) ||
        SameFilenames(lpFileBuff+sizeof(DIRTYPE), (LPSTR)(SysFileNamePtr[1]+3))) {
        /* Check if at least IO.SYS and MSDOS.SYS exist. */
        lstrcpy((LPSTR)(SysFileNamePtr[0]+3), SysNameTable[1][0]);
        lstrcpy((LPSTR)(SysFileNamePtr[1]+3), SysNameTable[1][1]);
        if (SameFilenames(lpFileBuff, (SysFileNamePtr[0]+3)) ||
            SameFilenames(lpFileBuff+sizeof(DIRTYPE), (SysFileNamePtr[1]+3)))
            goto HSFError;
    }

    /* Check if COMMAND.COM exists in the source drive. */
    if ((fh = MOpenFile((LPSTR)SysFileNamePtr[2], (LPOFSTRUCT)&OFInfo, OF_READ)) == -1)
        goto HSFError;

    /* Get the file sizes. */
    SysFileSize[0] = ((LPDIRTYPE)lpFileBuff)->size;
    SysFileSize[1] = ((LPDIRTYPE)(lpFileBuff+sizeof(DIRTYPE)))->size;
    SysFileSize[2] = M_llseek(fh, 0L, SEEK_END);
    M_lclose(fh);
    rc = TRUE;
    goto HSFExit;

    HSFError:
    rc = FALSE;

    HSFExit:
    if (lpFileBuff)
        LocalUnlock(hFileBuff);
    if (hFileBuff)
        LocalFree(hFileBuff);
    MFreeDOSEnvironment(lpStr);

    return (rc);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  CalcFreeSpace() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Given an array of filenames and the number of files, this function
 * calculates the freespace that would be created if those files are deleted.
 *
 * NOTE: This function returns TOTAL free space, (i.e) the summation of
 *   already existing free space and the space occupied by those files.
 */

INT
CalcFreeSpace(
             CHAR    DestFiles[][SYSFILENAMELEN],
             INT cFiles,
             INT cbCluster,
             WORD    wFreeClusters,
             WORD    wReqdClusters
             )
{
    INT   i;
    HFILE fh;
    LONG  lFileSize;
    OFSTRUCT OFInfo;

    ENTER("CalcFreeSpace");

    /* Find out the space already occupied by SYS files, if any. */
    for (i=0; i < cFiles; i++) {
        fh = MOpenFile(&DestFiles[i][0], &OFInfo, OF_READ);
        if (fh != (HFILE)-1) {
            /* Get the file size */
            lFileSize = M_llseek(fh, 0L, SEEK_END);

            if (lFileSize != -1L)
                wFreeClusters += LOWORD((lFileSize + cbCluster - 1)/cbCluster);

            M_lclose(fh);

            if (wFreeClusters >= wReqdClusters)
                return (wFreeClusters);
        }
    }
    LEAVE("CalcFreeSpace");
    return (wFreeClusters);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  CheckDiskSpace() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

BOOL
CheckDiskSpace(
              WORD    iDestDrive,
              INT cbCluster,              /* Bytes/Cluster of dest drive */
              CHAR    DestFileNames[][SYSFILENAMELEN],    /* NOTE: 2-dimensional array */
              BOOL    bDifferentSysFiles,
              CHAR    DestSysFiles[][SYSFILENAMELEN]
              )

{
    INT   i;
    INT   wFreeClusters;
    INT   wReqdClusters;

    /* Compute the number of clusters required. */
    wReqdClusters = 0;
    for (i=0; i < CSYSFILES; i++)
        wReqdClusters += LOWORD((SysFileSize[i] + cbCluster - 1) / cbCluster);

    /* Calculate the free disk space in clusters in the destination disk */
    wFreeClusters = LOWORD(GetFreeDiskSpace(iDestDrive) / cbCluster);

    if (wFreeClusters >= wReqdClusters)
        /* We have enough space. */
        return (TRUE);

    wFreeClusters = CalcFreeSpace(DestFileNames, CSYSFILES, cbCluster, (WORD)wFreeClusters, (WORD)wReqdClusters);
    if (wFreeClusters >= wReqdClusters)
        return (TRUE);

    /* Check if the sys files in the dest disk are different. */
    if (bDifferentSysFiles) {
        wFreeClusters = CalcFreeSpace(DestSysFiles, 2, cbCluster, (WORD)wFreeClusters, (WORD)wReqdClusters);
        if (wFreeClusters >= wReqdClusters)
            return (TRUE);
    }

    /* Insufficient disk space even if we delete the sys files. */
    return (FALSE);
}



/*--------------------------------------------------------------------------*/
/*                                      */
/*  IsSYSable() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* The requirements for the destination disk to be sysable are either:
 *
 * 1) first two directory entries are empty
 * 2) the first N clusters free where N = ceil (size IBMBIO/secPerClus)
 * 3) there is enough room on the disk for IBMBIO/IBMDOS/COMMAND
 *
 * - or -
 *
 * 1) the first two directory entries are IBMBIO.COM and IBMDOS.COM
 *                    or  IO.SYS and MSDOS.SYS
 * 2) the first N clusters are alloced to these files where N is defines above.
 * 3) there is enough room on the disk for IBMBIO/IBMDOS/COMMAND after
 *     deleting the IBMBIO/IBMDOS/COMMAND on the disk.
 *
 *  IMPORTANT NOTE:
 *  DestFileNames[][] contain the names of the sys files that would be
 *  created on the Destination diskette;
 *  DestSysFiles[][] contain the names of the sys files already
 *  present in the destination diskette, if any; Please Note that
 *  these two sets of filenames need not be the same, because you can
 *  install MSDOS on to a diskette that already has PCDOS and
 *  vice-versa.
 */

BOOL
IsSYSable(
         WORD    iSrceDrive,
         WORD    iDestDrive,
         CHAR    DestFileNames[][SYSFILENAMELEN],       /* NOTE: 2-dimensional array */
         LPSTR   lpFileBuff
         )
{
#ifdef LATER
    INT       i;
    DPB       DPB;
    WORD      clusTmp1, clusTmp2;
    WORD      clusBIOS, clusDOS;
    INT       cBytesPerCluster;
    INT       cBIOSsizeInClusters;
    BOOL      bDifferentDestFiles = FALSE;
    CHAR      chVolLabel[11];     /* This is NOT null terminated */
    DWORD     dwSerialNo;
    CHAR      DestSysFiles[2][SYSFILENAMELEN];
    INT       cContigClusters;
    DWORD     dwClusterInfo;
    CHAR      szTemp[SYSFILENAMELEN];

    /* Grab DPB for destination. */
    if (GetDPB(iDestDrive, &DPB))
        return (FALSE);

    /* Has the user aborted? */
    if (WFQueryAbort())
        return (FALSE);

    /* Get bytes per cluster for destination. */
    dwClusterInfo = GetClusterInfo(iDestDrive);
    /* Bytes per cluster = sectors per cluster * size of a sector   */
    cBytesPerCluster = LOWORD(dwClusterInfo) * HIWORD(dwClusterInfo);
    if (!cBytesPerCluster)
        return (FALSE);

    /* Has the user aborted? */
    if (WFQueryAbort())
        return (FALSE);

    /* Convert size of BIOS into full clusters */
    cBIOSsizeInClusters = LOWORD((SysFileSize[0] + cBytesPerCluster - 1) / cBytesPerCluster);

    /* Number of clusters required to be contiguous depends on DOS versions.
     * DOS 3.2 and below expect all clusters of BIOS to be contiguos.
     * But 3.3 and above expect only the first stub loader (<2K) to be contiguous.
     */
    cContigClusters = (GetDOSVersion() > 0x314) ?
                      ((2048 + cBytesPerCluster - 1)/cBytesPerCluster) :
                      cBIOSsizeInClusters;

    /* Grab first sector of destination root directory */
    if (MyInt25(iDestDrive, lpFileBuff, 1, DPB.dir_sector))
        return (FALSE);

    /* Has the user aborted? */
    if (WFQueryAbort())
        return (FALSE);

    /* Are the first two directory entries empty? */
    if ((lpFileBuff[0]           == 0 || (BYTE)lpFileBuff[0]           == 0xE5) &&
        (lpFileBuff[sizeof(DIRTYPE)] == 0 || (BYTE)lpFileBuff[sizeof(DIRTYPE)] == 0xE5)) {
        /* Any of first N (= BIOS size) clusters not empty? */
        for (i=0; i < cContigClusters; i++) {
            /* Has the user aborted? */
            if (WFQueryAbort())
                return (FALSE);
        }
    } else {
        /* Are the first two directory entries NOT BIOS/DOS? */
        for (i=0; i < 2; i++) {
            if ((!SameFilenames(lpFileBuff, SysNameTable[i][0])) ||
                (!SameFilenames(lpFileBuff+sizeof(DIRTYPE), SysNameTable[i][1]))) {
                /* Check if the destination files are the same as the source files */
                if (lstrcmpi(&DestFileNames[0][3], SysNameTable[i][0])) {
                    /* No! Delete the other set of filenames. */
                    DestSysFiles[0][0] = DestSysFiles[1][0] = (BYTE)('A'+iDestDrive);
                    lstrcpy(&DestSysFiles[0][1], ":\\");
                    lstrcpy(&DestSysFiles[0][3], SysNameTable[i][0]);
                    lstrcpy(&DestSysFiles[1][1], ":\\");
                    lstrcpy(&DestSysFiles[1][3], SysNameTable[i][1]);
                    bDifferentDestFiles = TRUE;
                }
                break;
            }
        }

        /* Did we find a match? */
        if (i == 2)
            /* Nope, the 2 entries are occupied by non-system files. */
            return (FALSE);

        /* Any of first N clusters NOT allocated to BIOS/DOS? */
        clusBIOS = ((LPDIRTYPE)lpFileBuff)->first;
        clusDOS = ((LPDIRTYPE)(lpFileBuff + sizeof(DIRTYPE)))->first;

        /* Do it the hard way, for each cluster 2..N+2 see if it is in the chain.
         */
        for (i=0; i < cContigClusters; i++) {
            clusTmp1 = clusBIOS;
            clusTmp2 = clusDOS;

            /* Check if cluster #i+2 is allocated to either of these files. */
            while (TRUE) {
                if (i+2 == (INT)clusTmp1 || i+2 == (INT)clusTmp2)
                    break;

//            if (clusTmp1 != -1)
                if (clusTmp1 < 0xFFF0)
                    clusTmp1 = 0;
//            if (clusTmp2 != -1)
                if (clusTmp2 < 0xFFF0)
                    clusTmp2 = 0;
//            if (clusTmp1 == -1 && clusTmp2 == -1)
                if (clusTmp1 >= 0xFFF0 && clusTmp2 >= 0xFFF0)
                    return FALSE;

                /* Did the user abort? */
                if (WFQueryAbort())
                    return FALSE;
            }
        }
    }

    /* Let us check if there is enough space on the dest disk. */
    if (CheckDiskSpace(iDestDrive, cBytesPerCluster, DestFileNames, bDifferentDestFiles, DestSysFiles) == FALSE)
        return (FALSE);

    /* Has the user aborted? */
    if (WFQueryAbort())
        return (FALSE);

    /* Get the Present Volume label and preserve it. */
    GetVolumeLabel(iDestDrive, (LPSTR)chVolLabel, FALSE);

    /*** NOTE: chVolLabel remains in OEM characters! ***/

    /* Get the serial no if any and preserve it. */
    dwSerialNo = ReadSerialNumber(iDestDrive, lpFileBuff);

    /* Copy and adjust boot sector from source to destination */
    if (WriteBootSector(iSrceDrive, iDestDrive, NULL, lpFileBuff) != NOERROR)
        return (FALSE);

    /* Restore the old volume label and serial number in the boot rec. */
    if (ModifyVolLabelInBootSec(iDestDrive, (LPSTR)chVolLabel, dwSerialNo, lpFileBuff))
        return (FALSE);

    /* Delete destination BIOS/DOS/COMMAND. */
    for (i=0; i < CSYSFILES; i++) {
        AnsiToOem(DestFileNames[i], szTemp);
        SetFileAttributes(szTemp, 0);
        DosDelete(szTemp);
        if ((bDifferentDestFiles) && (i < 2)) {
            SetFileAttributes(szTemp, 0);
            DosDelete(szTemp);
        }

        /* Has the user aborted? */
        if (WFQueryAbort())
            return (FALSE);
    }

    /* Reset the DPB_next_free field of the DPB to 2, sothat when IBMBIO.COM is
     * copied into this disk, the clusters will get allocated starting from 2.
     */
    ModifyDPB(iDestDrive);
#endif // LATER

    return (TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  MakeSystemDiskette() -                          */
/*                                      */
/*--------------------------------------------------------------------------*/

/* This routine is intended to mimic the functions of the SYS command
 * under MSDOS:  to transfer a version of the operating system from a source
 * disk to a destination such that the destination will be bootable.
 *
 *  The requirements of the source disk is that it contain:
 *
 *      1) a command processor (COMMAND.COM)
 *      2) a default set of device drivers (IBMBIO.COM)
 *      3) an operating system (IBMDOS.COM)
 *      4) a boot sector appropriate to the device drivers
 *
 *  The requirements for the destination disk are either:
 *
 *      1) first two directory entries are empty
 *      2) the first N clusters free where N = ceil (size IBMBIO/secPerClus)
 *      3) there is enough room on the disk for IBMBIO/IBMDOS/COMMAND
 *
 *  - or -
 *
 *      1) the first two directory entries are IBMBIO.COM and IBMDOS.COM
 *                                         or  IO.SYS and MSDOS.SYS
 *      2) the first N clusters are alloced to these files where N is defined
 *          above
 *      3) there is enough room on the disk for IBMBIO/IBMDOS/COMMAND after
 *      deleting the IBMBIO/IBMDOS/COMMAND on the disk.
 *
 *  Inputs:
 *        iDestDrive 0-based drive number of formatted drive
 *                       for destination.
 *        bEmptyFloppy : TRUE if the floppy is empty; Useful when
 *          the floppy is just formatted; No need to check if
 *          it is Sysable;
 *  Returns:    0       Successful transferral of boot sector and files
 *      <> 0    error code.
 */


BOOL
APIENTRY
MakeSystemDiskette(
                  WORD iDestDrive,
                  BOOL bEmptyFloppy
                  )
{
    INT       i;
    HANDLE    hFileBuff;  /* Buffer to read in file contents etc., */
    LPSTR     lpFileBuff;
    CHAR      DestFileName[CSYSFILES][SYSFILENAMELEN];
    CHAR      szTemp1[SYSFILENAMELEN];
    CHAR      szTemp2[SYSFILENAMELEN];
    WORD      nSource;

    nSource = (WORD)GetBootDisk();


    if (!HasSystemFiles(nSource)) {
        LoadString(hAppInstance, IDS_SYSDISKNOFILES, szMessage, sizeof(szMessage));
        MessageBox(hdlgProgress, szMessage, szTitle, MB_OK | MB_ICONSTOP);
        bUserAbort = TRUE;
        return FALSE;
    }

    if (iDestDrive == nSource) {
        LoadString(hAppInstance, IDS_SYSDISKSAMEDRIVE, szMessage, sizeof(szMessage));
        MessageBox(hdlgProgress, szMessage, szTitle, MB_OK | MB_ICONSTOP);
        bUserAbort = TRUE;
        return FALSE;
    }

    /* Initialize variables for cleanup. */
    hFileBuff = NULL;
    lpFileBuff = NULL;

    /* Flush the DOS buffers. */
    DiskReset();

    if (!(hFileBuff = LocalAlloc(LHND, (DWORD)BUFFSIZE)))
        return (1);

    lpFileBuff = LocalLock(hFileBuff);

    for (i=0; i < (CSYSFILES - 1); i++) {
        /* Create the destination file names */
        lstrcpy((LPSTR)&DestFileName[i][0], (LPSTR)SysFileNamePtr[i]);
        DestFileName[i][0] = (BYTE)('A' + iDestDrive);
    }

    /* Copy just the Command.COM without any path name */
    lstrcpy((LPSTR)DestFileName[2], "X:\\");
    lstrcat((LPSTR)DestFileName[2], (LPSTR)SysNameTable[0][2]);
    DestFileName[2][0] = (BYTE)('A' + iDestDrive);

    /* Check if it is an empty floppy; If so, there is no need to check if it
     * is 'SYSable'. It is bound to be 'Sysable'. So, skip all the checks and
     * go ahead with copying the sys files.
     */
    if (!bEmptyFloppy) {

        /* Check if the Destination floppy is SYS-able */
        if (!IsSYSable(nSource, iDestDrive, DestFileName, lpFileBuff))
            goto MSDErrExit;

        /* Did the user abort? */
        if (WFQueryAbort())
            goto MSDErrExit;
    }

    /* Copy files */

    bCopyReport = FALSE;

    DisableFSC();

    for (i=0; i < CSYSFILES; i++) {
        /* Copy all files except command.com with sys attributes */
        AnsiToOem(SysFileNamePtr[i], szTemp1);
        AnsiToOem(DestFileName[i], szTemp2);

        /* Make sure the destination file is deleted first */
        SetFileAttributes(szTemp2, ATTR_ALL);
        WFRemove(szTemp2);

        // copy code preserves the attributes
        if (FileCopy(szTemp1, szTemp2))
            goto MSDErrExit2;

        if (WFQueryAbort())
            goto MSDErrExit2;
    }


    if (EndCopy())          // empty the copy queue
        goto MSDErrExit2;

    EnableFSC();

    /* Normal Exit. */

    LocalUnlock(hFileBuff);
    LocalFree(hFileBuff);

    return FALSE;     // success

    MSDErrExit2:

    EnableFSC();

    MSDErrExit:

    CopyAbort();      // Purge any copy commands in copy queue
    LocalUnlock(hFileBuff);
    LocalFree(hFileBuff);

    return TRUE;      // failure
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\winnet.c ===
/*
 * This file contains stubs to simulate WINNET apis
 *
 * Createsd 4/23/91 sanfords
 */

#include <windows.h>
#include "winnet.h"

WORD
WNetOpenJob(
           LPTSTR szQueue,
           LPTSTR szJobTitle,
           WORD nCopies,
           LPINT lpfh
           )
{
    szQueue; szJobTitle; nCopies; lpfh;

    return (0);
}

WORD
WNetCloseJob(
            WORD fh,
            LPINT lpidJob,
            LPTSTR szQueue
            )
{
    fh; lpidJob; szQueue;

    return (0);
}

WORD
WNetWriteJob(
            HANDLE hJob,
            LPTSTR lpData,
            LPINT lpcb
            )
{
    hJob; lpData; lpcb;

    return (0);
}

WORD
WNetAbortJob(
            WORD fh,
            LPTSTR lpszQueue
            )
{
    fh; lpszQueue;

    return (0);
}


WORD
WNetHoldJob(
           LPTSTR szQueue,
           WORD idJob
           )
{
    szQueue; idJob;

    return (0);
}

WORD
WNetReleaseJob(
              LPTSTR szQueue,
              WORD idJob
              )
{
    szQueue; idJob;

    return (0);
}

WORD
WNetCancelJob(
             LPTSTR szQueue,
             WORD idJob
             )
{
    szQueue; idJob;

    return (0);
}

WORD
WNetSetJobCopies(
                LPTSTR szQueue,
                WORD idJob,
                WORD nCopies
                )
{
    szQueue; idJob; nCopies;

    return (0);
}

WORD
WNetWatchQueue(
              HWND hwnd,
              LPTSTR szLocal,
              LPTSTR szUsername,
              WORD wIndex
              )

{
    hwnd; szLocal; szUsername; wIndex;

    return (0);
}

WORD
WNetUnwatchQueue(
                LPTSTR szQueue
                )
{
    szQueue;

    return (0);
}

WORD
WNetLockQueueData(
                 LPTSTR szQueue,
                 LPTSTR szUsername,
                 LPQUEUESTRUCT *lplpQueue
                 )
{
    szQueue; szUsername; lplpQueue;

    return (0);
}

WORD
WNetUnlockQueueData(
                   LPTSTR szQueue
                   )
{
    szQueue;

    return (0);
}


// grabbed from win31 user\net.c

DWORD
APIENTRY
WNetErrorText(
             DWORD wError,
             LPTSTR lpsz,
             DWORD cbMax
             )
{
    DWORD wInternalError;
    DWORD cb = 0;
#ifdef LATER
    TCHAR szT[40];
#endif

    wsprintf( lpsz, TEXT("Error %d occurred"), wError);
    return cb;
}

#if LATERMAYBE
WORD LFNFindFirst(LPTSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD LFNFindClose(HANDLE);
WORD LFNGetAttribute(LPTSTR,LPINT);
WORD LFNSetAttribute(LPTSTR,WORD);
WORD LFNCopy(LPTSTR,LPTSTR,PQUERYPROC);
WORD LFNMove(LPTSTR,LPTSTR);
WORD LFNDelete(LPTSTR);
WORD LFNMKDir(LPTSTR);
WORD LFNRMDir(LPTSTR);
WORD LFNGetVolumeLabel(WORD,LPTSTR);
WORD LFNSetVolumeLabel(WORD,LPTSTR);
WORD LFNParse(LPTSTR,LPTSTR,LPTSTR);
WORD LFNVolumeType(WORD,LPINT);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\winnet.h ===
/*
 *  Windows/Network Interface
 *  Copyright (C) Microsoft 1989
 *
 *  Standard WINNET Driver Header File, spec version 3.10
 *                       rev. 3.10.05 ;Internal
 */


/*
 *  SPOOLING - CONTROLLING JOBS
 */


#include "winnetwk.h"
#include "mpr.h"

#define	LPUINT	PUINT

#define WNJ_NULL_JOBID  0


WORD WNetOpenJob(LPTSTR,LPTSTR,WORD,LPINT);
WORD WNetCloseJob(WORD,LPINT,LPTSTR);
WORD WNetWriteJob(HANDLE,LPTSTR,LPINT);
WORD WNetAbortJob(WORD,LPTSTR);
WORD WNetHoldJob(LPTSTR,WORD);
WORD WNetReleaseJob(LPTSTR,WORD);
WORD WNetCancelJob(LPTSTR,WORD);
WORD WNetSetJobCopies(LPTSTR,WORD,WORD);

/*
 *  SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct {
    WORD    pqName;
    WORD    pqComment;
    WORD    pqStatus;
    WORD    pqJobcount;
    WORD    pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE    0x0
#define WNPRQ_PAUSE 0x1
#define WNPRQ_ERROR 0x2
#define WNPRQ_PENDING   0x3
#define WNPRQ_PROBLEM   0x4


typedef struct _jobstruct {
    WORD    pjId;
    WORD    pjUsername;
    WORD    pjParms;
    WORD    pjPosition;
    WORD    pjStatus;
    DWORD   pjSubmitted;
    DWORD   pjSize;
    WORD    pjCopies;
    WORD    pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS       0x0007
#define  WNPRJ_QS_QUEUED        0x0000
#define  WNPRJ_QS_PAUSED        0x0001
#define  WNPRJ_QS_SPOOLING      0x0002
#define  WNPRJ_QS_PRINTING      0x0003
#define WNPRJ_DEVSTATUS     0x0FF8
#define  WNPRJ_DS_COMPLETE      0x0008
#define  WNPRJ_DS_INTERV        0x0010
#define  WNPRJ_DS_ERROR         0x0020
#define  WNPRJ_DS_DESTOFFLINE       0x0040
#define  WNPRJ_DS_DESTPAUSED        0x0080
#define  WNPRJ_DS_NOTIFY        0x0100
#define  WNPRJ_DS_DESTNOPAPER       0x0200
#define  WNPRJ_DS_DESTFORMCHG       0x0400
#define  WNPRJ_DS_DESTCRTCHG        0x0800
#define  WNPRJ_DS_DESTPENCHG        0x1000

#define SP_QUEUECHANGED     0x0500


WORD WNetWatchQueue(HWND,LPTSTR,LPTSTR,WORD);
WORD WNetUnwatchQueue(LPTSTR);
WORD WNetLockQueueData(LPTSTR,LPTSTR,LPQUEUESTRUCT FAR *);
WORD WNetUnlockQueueData(LPTSTR);



/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2 {
    WORD fdateCreation;
    WORD ftimeCreation;
    WORD fdateLastAccess;
    WORD ftimeLastAccess;
    WORD fdateLastWrite;
    WORD ftimeLastWrite;
    DWORD cbFile;
    DWORD cbFileAlloc;
    WORD attr;
    DWORD cbList;
    BYTE cchName;
    BYTE achName[1];
} FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (FAR PASCAL *PQUERYPROC)( void );

WORD LFNFindFirst(LPTSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD LFNFindClose(HANDLE);
WORD LFNGetAttribute(LPTSTR,LPINT);
WORD LFNSetAttribute(LPTSTR,WORD);
WORD LFNCopy(LPTSTR,LPTSTR,PQUERYPROC);
WORD LFNMove(LPTSTR,LPTSTR);
WORD LFNDelete(LPTSTR);
WORD LFNMKDir(LPTSTR);
WORD LFNRMDir(LPTSTR);
WORD LFNGetVolumeLabel(WORD,LPTSTR);
WORD LFNSetVolumeLabel(WORD,LPTSTR);
WORD LFNParse(LPTSTR,LPTSTR,LPTSTR);
WORD LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI      0
#define FILE_83_CS      1
#define FILE_LONG       2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD     0
#define VOLUME_LONGNAMES    1

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC   0xFFFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\winobj.c ===
/****************************************************************************/
/*                                                                          */
/*  WINFILE.C -                                                             */
/*                                                                          */
/*      Windows File System Application                                     */
/*                                                                          */
/****************************************************************************/

#define NO_WF_GLOBALS
#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "stdlib.h"


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Global Variables -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL        bNetAdmin               = FALSE;
BOOL        bMinOnRun               = FALSE;
BOOL        bStatusBar              = TRUE;
BOOL        bConfirmDelete          = TRUE;
BOOL        bConfirmSubDel          = TRUE;
BOOL        bConfirmReplace         = TRUE;
BOOL        bConfirmMouse           = TRUE;
BOOL        bConfirmFormat          = TRUE;
BOOL        bSearchSubs             = TRUE;
BOOL        bUserAbort              = FALSE;
BOOL        bConnect                = FALSE;
BOOL        bDisconnect             = FALSE;
BOOL        bFileSysChanging        = FALSE;
BOOL        fShowSourceBitmaps      = TRUE;
BOOL    bMultiple;              // used to indicate multiple selection
BOOL    bFSCTimerSet = FALSE;
BOOL    bStoleTreeData = FALSE;
BOOL    bSaveSettings = TRUE;


CHAR        chFirstDrive;                       /* 'A' or 'a' */

CHAR        szExtensions[]          = "Extensions";
CHAR        szFrameClass[]          = "WOS_Frame";
CHAR        szTreeClass[]           = "WOS_Tree";
CHAR        szDrivesClass[]         = "WOS_Drives";
CHAR        szTreeControlClass[]    = "DirTree";
CHAR        szDirClass[]            = "WOS_Dir";
CHAR        szSearchClass[]         = "WOS_Search";

CHAR        szMinOnRun[]            = "MinOnRun";
CHAR        szStatusBar[]           = "StatusBar";
CHAR        szSaveSettings[]        = "Save Settings";

CHAR        szConfirmDelete[]       = "ConfirmDelete";
CHAR        szConfirmSubDel[]       = "ConfirmSubDel";
CHAR        szConfirmReplace[]      = "ConfirmReplace";
CHAR        szConfirmMouse[]        = "ConfirmMouse";
CHAR        szConfirmFormat[]       = "ConfirmFormat";
CHAR        szDirKeyFormat[]        = "dir%d";
CHAR        szWindow[]              = "Window";
CHAR        szFace[]                = "Face";
CHAR        szSize[]                = "Size";
CHAR        szLowerCase[]           = "LowerCase";
CHAR        szAddons[]              = "AddOns";
CHAR        szUndelete[]            = "UNDELETE.DLL";

CHAR        szDefPrograms[]         = "EXE COM BAT PIF";
CHAR        szINIFile[]             = "WINOBJ.INI";
CHAR        szWindows[]             = "Windows";
CHAR        szPrevious[]            = "Previous";
CHAR        szSettings[]            = "Settings";
CHAR        szInternational[]       = "Intl";
CHAR        szStarDotStar[]         = "*.*";
CHAR        szNULL[]                = "";
CHAR        szBlank[]               = " ";
CHAR        szEllipses[]            = "...";
CHAR        szReservedMarker[]      = "FAT16   ";
CHAR        szNetwork[]             = "Network";

CHAR        szDirsRead[32];
CHAR        szCurrentFileSpec[14]   = "*.*";
CHAR        szShortDate[11]         = "MM/dd/yy";
CHAR        szTime[2]               = ":";
CHAR        sz1159[9]               = "AM";
CHAR        sz2359[9]               = "PM";
CHAR        szComma[2]              = ",";
CHAR        szListbox[]             = "ListBox";        // window style

CHAR        szTheINIFile[64+12+3];
CHAR        szTitle[128];
CHAR        szMessage[MAXMESSAGELEN+1];
CHAR        szSearch[MAXPATHLEN+1];
CHAR        szStatusTree[80];
CHAR        szStatusDir[80];
CHAR        szOriginalDirPath[64+12+3]; /* OEM string!!!!!! */
CHAR        szBytes[10];
CHAR        szSBytes[10];

EFCB        VolumeEFCB ={
    0xFF,
    0, 0, 0, 0, 0,
    ATTR_VOLUME,
    0,
    '?','?','?','?','?','?','?','?','?','?','?',
    0, 0, 0, 0, 0,
    '?','?','?','?','?','?','?','?','?','?','?',
    0, 0, 0, 0, 0, 0, 0, 0, 0
};

INT         cDrives;
INT         dxDrive;
INT         dyDrive;
INT         dxDriveBitmap;
INT         dyDriveBitmap;
INT         dxEllipses;
INT         dxFolder;
INT         dyFolder;
INT         dyBorder;                   /* System Border Width/Height       */
INT         dyBorderx2;                 /* System Border Width/Height * 2   */
INT         dyStatus;                   /* Status Bar height                */
INT         dxStatusField;
INT         dxText;                     /* System Font Width 'M'            */
INT         dyText;                     /* System Font Height               */
//INT         dxFileName;
INT         dyFileName;
INT         iCurrentDrive;              /* Logical # of the current drive   */
INT         iFormatDrive;               /* Logical # of the drive to format */
INT         nFloppies;                  /* Number of Removable Drives       */
INT         rgiDrive[26];
INT         rgiDriveType[26];
VOLINFO     *(apVolInfo[26]);
INT         rgiDrivesOffset[26];
INT         iSelHilite              = -1;
INT         iTime                   = 0;        /* Default to 12-hour time  */
INT         iTLZero                 = TRUE;     /* Default to leading zeros */
INT         cDisableFSC             = 0;        /* has fsc been disabled?   */
INT         iReadLevel = 0;     // global.  if !0 someone is reading a tree
INT         dxFrame;
INT         dxClickRect;
INT         dyClickRect;

BOOL    bCancelTree;

HANDLE  hAccel              = NULL;
HANDLE  hAppInstance;

HBITMAP hbmBitmaps      = NULL;
HDC     hdcMem          = NULL;

INT iCurDrag = 0;

HICON   hicoTree        = NULL;
HICON   hicoTreeDir     = NULL;
HICON   hicoDir         = NULL;

HWND    hdlgProgress;
HWND    hwndFrame       = NULL;
HWND    hwndMDIClient   = NULL;
HWND    hwndSearch      = NULL;
HWND    hwndDragging    = NULL;

LPSTR    szPrograms;
LPSTR    szDocuments;

WORD    wTextAttribs    = TA_LOWERCASE;
WORD    wSuperDlgMode;
WORD    wFATSector      = (WORD)0xFFFF;
WORD    wFATMode        = 0;
WORD    wDOSversion;
UINT    wHelpMessage;
UINT    wBrowseMessage;
WORD    xTreeMax = 0; // current width of widest tree window

WORD    wNewView        = VIEW_NAMEONLY;
WORD    wNewSort        = IDD_NAME;
DWORD   dwNewAttribs    = ATTR_DEFAULT;

LONG lFreeSpace = -1L;
LONG lTotalSpace = -1L;

HFONT hFont;
HFONT hFontStatus;
CHAR szWinObjHelp[] = "WINOBJ.HLP";

INT iNumExtensions = 0;
EXTENSION extensions[MAX_EXTENSIONS];

FM_UNDELETE_PROC lpfpUndelete = NULL;
BOOL EnablePropertiesMenu (HWND,PSTR);
HHOOK hhkMessageFilter = NULL;

WORD wMenuID = 0;
HMENU hMenu = 0;
WORD  wMenuFlags = 0;
DWORD dwContext = 0L;

HANDLE hModUndelete = NULL;


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WinMain() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

MMain(
     hInst,
     hPrevInst,
     lpCmdLine,
     nCmdShow
     )
//{
    MSG       msg;

    FBREAK(BF_START);
    ENTER("MMain");
    PRINT(BF_PARMTRACE, "lpCmdLine=%s", lpCmdLine);
    PRINT(BF_PARMTRACE, "nCmdShow=%ld", IntToPtr(nCmdShow));

    if (!InitFileManager(hInst, hPrevInst, lpCmdLine, nCmdShow)) {
        FreeFileManager();
        return FALSE;
    }

    while (GetMessage(&msg, NULL, 0, 0)) {

        // since we use RETURN as an accelerator we have to manually
        // restore ourselves when we see VK_RETURN and we are minimized

        if (msg.message == WM_SYSKEYDOWN && msg.wParam == VK_RETURN && IsIconic(hwndFrame)) {
            ShowWindow(hwndFrame, SW_NORMAL);
        } else {
            if (!TranslateMDISysAccel(hwndMDIClient, &msg) &&
                (!hwndFrame || !TranslateAccelerator(hwndFrame, hAccel, &msg))) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    FreeFileManager();

    LEAVE("MMain");
    return (int)msg.wParam;
}


VOID
NoRunInLongDir(
              HWND hwndActive,
              HMENU hMenu
              )
{
    char szTemp[MAXPATHLEN];
    WORD wMenuFlags;

    // cannot run in a long directory
    SendMessage(hwndActive, FS_GETDIRECTORY, MAXPATHLEN, (LPARAM)szTemp);
    StripBackslash(szTemp);
    //wMenuFlags = IsLFN(szTemp) ? MF_BYCOMMAND | MF_GRAYED
    //                : MF_BYCOMMAND | MF_ENABLED;

    wMenuFlags = MF_BYCOMMAND | MF_ENABLED;
    EnableMenuItem(hMenu, IDM_RUN, wMenuFlags);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FrameWndProc() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
FrameWndProc(
            HWND hWnd,
            UINT wMsg,
            WPARAM wParam,
            LPARAM lParam
            )
{
    RECT     rc;
    HMENU    hMenu = NULL;

    STKCHK();

    switch (wMsg) {
        case WM_CREATE:
            TRACE(BF_WM_CREATE, "FrameWndProc - WM_CREATE");
            {
                CLIENTCREATESTRUCT    ccs;

                /* Store the Frame's hwnd. */
                hwndFrame = hWnd;

                // ccs.hWindowMenu = GetSubMenu(GetMenu(hWnd), IDM_WINDOW);
                // the extensions haven't been loaded yet so the window
                // menu is in the position of the first extensions menu
                ccs.hWindowMenu = GetSubMenu(GetMenu(hWnd), IDM_EXTENSIONS);
                ccs.idFirstChild = IDM_CHILDSTART;

                // create the MDI client at aproximate size to make sure
                // "run minimized" works

                GetClientRect(hwndFrame, &rc);

                hwndMDIClient = CreateWindow("MDIClient", NULL,
                                             WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL | WS_BORDER,
                                             // -dyBorder, -dyBorder,
                                             // rc.right + dyBorder,
                                             // rc.bottom - dyBorder - (bStatusBar ? dyStatus + dyBorder : 0),
                                             0, 0, rc.right, rc.bottom,
                                             hWnd, (HMENU)1, hAppInstance, (LPSTR)&ccs);
                if (!hwndMDIClient) {
                    MSG("FrameWndProc", "WM_CREATE failed!");
                    return -1L;
                }

                break;
            }

        case WM_INITMENUPOPUP:
            MSG("FrameWndProc", "WM_INITMENUPOPUP");
            {
                BOOL      bMaxed;
                WORD      wSort;
                WORD      wView;
                WORD      wMenuFlags;
                HWND      hwndActive;
                HWND      hwndTree, hwndDir;
                BOOL      bLFN;

                hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
                if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
                    bMaxed = 1;
                else
                    bMaxed = 0;

                hwndTree = HasTreeWindow(hwndActive);
                hwndDir = HasDirWindow(hwndActive);
                wSort = (WORD)GetWindowLong(hwndActive, GWL_SORT);
                wView = (WORD)GetWindowLong(hwndActive, GWL_VIEW);

                hMenu = (HMENU)wParam;

                wMenuFlags = MF_BYCOMMAND | MF_ENABLED;

                //        bLFN = IsLFNSelected();
                bLFN = FALSE;       // For now, ignore the case.

                switch (LOWORD(lParam)-bMaxed) {
                    case IDM_FILE:
                        MSG("FrameWndProc", "IDM_FILE");
                        {
                            LPSTR     pSel;
                            BOOL      fDir;

                            if (!hwndDir)
                                wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                            // EnableMenuItem(hMenu, IDM_PRINT,    wMenuFlags);
                            EnableMenuItem(hMenu, IDM_SELALL,   wMenuFlags);
                            EnableMenuItem(hMenu, IDM_DESELALL, wMenuFlags);

                            if (hwndActive == hwndSearch || hwndDir)
                                wMenuFlags = MF_BYCOMMAND;
                            else
                                wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                            // EnableMenuItem(hMenu, IDM_ATTRIBS, wMenuFlags);
                            EnableMenuItem(hMenu, IDM_SELECT, wMenuFlags);

                            pSel = (LPSTR)SendMessage(hwndActive, FS_GETSELECTION, 1, (LPARAM)&fDir);

                            // can't print an lfn thing or a directory.
                            wMenuFlags = (WORD)((bLFN || fDir)
                                                ? MF_BYCOMMAND | MF_DISABLED | MF_GRAYED
                                                : MF_BYCOMMAND | MF_ENABLED);

                            EnableMenuItem(hMenu, IDM_PRINT, wMenuFlags);

                            // can't open an LFN file but can open an LFN dir
                            wMenuFlags = (WORD)((bLFN && !fDir)
                                                ? MF_BYCOMMAND | MF_DISABLED | MF_GRAYED
                                                : MF_BYCOMMAND | MF_ENABLED);

                            EnableMenuItem(hMenu, IDM_OPEN, wMenuFlags);

                            // See if we can enable the Properties... menu
                            if (EnablePropertiesMenu (hwndActive,pSel))
                                wMenuFlags = MF_BYCOMMAND;
                            else
                                wMenuFlags = MF_BYCOMMAND | MF_GRAYED;
                            EnableMenuItem (hMenu, IDM_ATTRIBS, wMenuFlags);

                            LocalFree((HANDLE)pSel);

                            NoRunInLongDir(hwndActive, hMenu);
                            break;
                        }

                    case IDM_DISK:
                        MSG("FrameWndProc", "IDM_DISK");

                        // be sure not to allow disconnect while any trees
                        // are still being read (iReadLevel != 0)

                        if (bDisconnect) {
                            INT i;

                            wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                            if (!iReadLevel) {
                                for (i=0; i < cDrives; i++) {
                                    wParam = rgiDrive[i];
                                    if ((!IsCDRomDrive((INT)wParam)) && (IsNetDrive((INT)wParam))) {
                                        wMenuFlags = MF_BYCOMMAND | MF_ENABLED;
                                        break;
                                    }
                                }
                            }
                            EnableMenuItem(hMenu, IDM_DISCONNECT, wMenuFlags);
                        } else {
                            if (iReadLevel)
                                EnableMenuItem(hMenu, IDM_CONNECTIONS, MF_BYCOMMAND | MF_GRAYED);
                            else
                                EnableMenuItem(hMenu, IDM_CONNECTIONS, MF_BYCOMMAND | MF_ENABLED);
                        }

                        break;

                    case IDM_TREE:
                        MSG("FrameWndProc", "IDM_TREE");
                        if (!hwndTree || iReadLevel)
                            wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                        EnableMenuItem(hMenu, IDM_EXPONE,     wMenuFlags);
                        EnableMenuItem(hMenu, IDM_EXPSUB,     wMenuFlags);
                        EnableMenuItem(hMenu, IDM_EXPALL,     wMenuFlags);
                        EnableMenuItem(hMenu, IDM_COLLAPSE,   wMenuFlags);
                        EnableMenuItem(hMenu, IDM_ADDPLUSES,  wMenuFlags);

                        if (hwndTree)
                            CheckMenuItem(hMenu, IDM_ADDPLUSES, GetWindowLong(hwndActive, GWL_VIEW) & VIEW_PLUSES ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);

                        break;

                    case IDM_VIEW:
                        MSG("FrameWndProc", "IDM_VIEW");
                        EnableMenuItem(hMenu, IDM_VNAME,    wMenuFlags);
                        EnableMenuItem(hMenu, IDM_VDETAILS, wMenuFlags);
                        EnableMenuItem(hMenu, IDM_VOTHER,   wMenuFlags);

                        if (hwndActive == hwndSearch || IsIconic(hwndActive))
                            wMenuFlags = MF_BYCOMMAND | MF_GRAYED;
                        else {
                            CheckMenuItem(hMenu, IDM_BOTH, hwndTree && hwndDir ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                            CheckMenuItem(hMenu, IDM_DIRONLY, !hwndTree && hwndDir ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                            CheckMenuItem(hMenu, IDM_TREEONLY, hwndTree && !hwndDir ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        }

                        EnableMenuItem(hMenu, IDM_BOTH,      wMenuFlags);
                        EnableMenuItem(hMenu, IDM_TREEONLY,  wMenuFlags);
                        EnableMenuItem(hMenu, IDM_DIRONLY,   wMenuFlags);
                        EnableMenuItem(hMenu, IDM_SPLIT,     wMenuFlags);

                        EnableMenuItem(hMenu, IDM_VINCLUDE, wMenuFlags);

                        wView &= VIEW_EVERYTHING;

                        CheckMenuItem(hMenu, IDM_VNAME,   (wView == VIEW_NAMEONLY) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(hMenu, IDM_VDETAILS,(wView == VIEW_EVERYTHING) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(hMenu, IDM_VOTHER,  (wView != VIEW_NAMEONLY && wView != VIEW_EVERYTHING) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);

                        CheckMenuItem(hMenu, IDM_BYNAME, (wSort == IDD_NAME) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(hMenu, IDM_BYTYPE, (wSort == IDD_TYPE) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(hMenu, IDM_BYSIZE, (wSort == IDD_SIZE) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(hMenu, IDM_BYDATE, (wSort == IDD_DATE) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);

                        if (hwndDir)
                            wMenuFlags = MF_BYCOMMAND | MF_ENABLED;
                        else
                            wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                        EnableMenuItem(hMenu, IDM_BYNAME, wMenuFlags);
                        EnableMenuItem(hMenu, IDM_BYTYPE, wMenuFlags);
                        EnableMenuItem(hMenu, IDM_BYSIZE, wMenuFlags);
                        EnableMenuItem(hMenu, IDM_BYDATE, wMenuFlags);

                        break;

                    case IDM_OPTIONS:
                        MSG("FrameWndProc", "IDM_OPTIONS");
                        if (iReadLevel)
                            wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                        EnableMenuItem(hMenu, IDM_ADDPLUSES, wMenuFlags);
                        EnableMenuItem(hMenu, IDM_EXPANDTREE, wMenuFlags);

                        break;

                    default:
                        MSG("FrameWndProc", "default WM_COMMAND");
                        {
                            INT pos = (INT)LOWORD(lParam) - bMaxed;
                            INT index;

                            if ((pos >= IDM_EXTENSIONS) && (pos < (iNumExtensions + IDM_EXTENSIONS))) {
                                // HIWORD(lParam) is the menu handle
                                // LOWORD(lParam) is menu item delta.  DLL should
                                // add this to it's menu id if it want's to
                                // change the menu.

                                index = pos - IDM_EXTENSIONS;

                                (extensions[index].ExtProc)(hwndFrame, FMEVENT_INITMENU, (LPARAM)(hMenu));
                            }
                            break;
                        }
                }
                break;
            }

        case WM_PAINT:
            MSG("FrameWndProc", "WM_PAINT");
            {
                HDC           hdc;
                RECT          rcTemp;
                HBRUSH        hBrush;
                PAINTSTRUCT   ps;
                BOOL bEGA;
                HFONT hFontOld;

                hdc = BeginPaint(hWnd, &ps);

                if (!IsIconic(hWnd) && bStatusBar) {

                    GetClientRect(hWnd, &rc);
                    hFontOld = SelectObject(hdc, hFontStatus);

                    // status area, leave room for the top border
                    rc.top = rc.bottom - dyStatus + dyBorder;

                    bEGA = GetNearestColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT)) ==
                           GetNearestColor(hdc, GetSysColor(COLOR_BTNFACE));

                    if (!bEGA) {

                        // displays with button shadows

                        // draw the frame

                        if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE))) {

                            // top bottom

                            rcTemp = rc;
                            rcTemp.bottom = rcTemp.top + dyBorderx2;
                            FillRect(hdc, &rcTemp, hBrush);

                            rcTemp = rc;
                            rcTemp.top = rcTemp.bottom - dyBorderx2;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left right

                            rcTemp = rc;
                            rcTemp.right = 8 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            rcTemp = rc;
                            rcTemp.left = dxStatusField * 2 - 8 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // middle

                            rcTemp = rc;
                            rcTemp.left  = dxStatusField - 4 * dyBorder;
                            rcTemp.right = dxStatusField + 4 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            DeleteObject(hBrush);
                        }

                        // shadow

                        if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW))) {

                            // left

                            rcTemp.left   = 8 * dyBorder;
                            rcTemp.right  = dxStatusField - 4 * dyBorder;
                            rcTemp.top    = rc.top + dyBorderx2;
                            rcTemp.bottom = rcTemp.top + dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // right

                            rcTemp.left   = dxStatusField + 4 * dyBorder;
                            rcTemp.right  = dxStatusField * 2 - 8 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left side 1

                            rcTemp = rc;
                            rcTemp.left = 8 * dyBorder;
                            rcTemp.right = rcTemp.left + dyBorder;
                            rcTemp.top += dyBorderx2;
                            rcTemp.bottom -= dyBorderx2;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left side 2

                            rcTemp.left = dxStatusField + 4 * dyBorder;
                            rcTemp.right = rcTemp.left + dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            DeleteObject(hBrush);
                        }
                        // the hilight

                        // hilight

                        if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT))) {

                            // left

                            rcTemp.left   = 8 * dyBorder;
                            rcTemp.right  = dxStatusField - 4 * dyBorder;
                            rcTemp.top    = rc.bottom - 3 * dyBorder;
                            rcTemp.bottom = rcTemp.top + dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // right

                            rcTemp.left   = dxStatusField + 4 * dyBorder;
                            rcTemp.right  = dxStatusField * 2 - 8 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left side 1

                            rcTemp = rc;
                            rcTemp.left = dxStatusField - 5 * dyBorder;
                            rcTemp.right = rcTemp.left + dyBorder;
                            rcTemp.top += dyBorderx2;
                            rcTemp.bottom -= dyBorderx2;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left side 2

                            rcTemp.left = 2 * dxStatusField - 9 * dyBorder;
                            rcTemp.right = rcTemp.left + dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            DeleteObject(hBrush);
                        }
                    }

                    // solid black line across top (above the status rc)

                    if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNTEXT))) {
                        rcTemp = rc;
                        rcTemp.bottom = rcTemp.top;
                        rcTemp.top -= dyBorder;
                        FillRect(hdc, &rcTemp, hBrush);
                        DeleteObject(hBrush);
                    }

                    // set the text and background colors

                    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
                    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

                    // now the text, with a gray background

                    rcTemp.top    = rc.top + 3 * dyBorder;
                    rcTemp.bottom = rc.bottom - 3 * dyBorder;
                    rcTemp.left   = 9 * dyBorder;
                    rcTemp.right  = dxStatusField - 5 * dyBorder;

                    ExtTextOut(hdc, rcTemp.left + dyBorderx2, rcTemp.top,
                               ETO_OPAQUE | ETO_CLIPPED, bEGA ? &rc : &rcTemp, szStatusTree, lstrlen(szStatusTree), NULL);

                    rcTemp.left    = dxStatusField + 5 * dyBorder;
                    rcTemp.right   = dxStatusField * 2 - 9 * dyBorder;

                    ExtTextOut(hdc, rcTemp.left + dyBorderx2, rcTemp.top,
                               bEGA ? ETO_CLIPPED : ETO_OPAQUE | ETO_CLIPPED, &rcTemp, szStatusDir, lstrlen(szStatusDir), NULL);

                    if (hFontOld)
                        SelectObject(hdc, hFontOld);
                }

                EndPaint(hWnd, &ps);
                break;
            }

        case WM_DESTROY:
            MSG("FrameWndProc", "WM_DESTROY");
            //FileCDR(NULL);
            if (!WinHelp(hwndFrame, szWinObjHelp, HELP_QUIT, 0L)) {
                MyMessageBox(hwndFrame, IDS_WINFILE, IDS_WINHELPERR, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
            }
            hwndFrame = NULL;
            PostQuitMessage(0);
            break;

        case WM_SIZE:
            MSG("FrameWndProc", "WM_SIZE");
            if (wParam != SIZEICONIC) {
                INT dx, dy;

                // make things look good by putting WS_BORDER on the
                // client, then adjust the thing so it gets clipped

                dx = LOWORD(lParam) + 2 * dyBorder;
                dy = HIWORD(lParam) + 2 * dyBorder;
                if (bStatusBar)
                    dy -= dyStatus;

                MoveWindow(hwndMDIClient, -dyBorder, -dyBorder, dx, dy, TRUE);

                if (bStatusBar) {
                    GetClientRect(hwndFrame, &rc);
                    rc.top = rc.bottom - dyStatus;
                    InvalidateRect(hWnd, &rc, TRUE);
                }
            }
            break;

        case WM_TIMER:

            MSG("FrameWndProc", "WM_TIMER");
            // this came from a FSC that wasn't generated by us
            bFSCTimerSet = FALSE;
            KillTimer(hWnd, 1);
            EnableFSC();
            break;

        case WM_FILESYSCHANGE:
            MSG("FrameWndProc", "WM_FILESYSCHANGE");
            {
                LPSTR lpTo;

                // if its a rename (including those trapped by kernel)
                // find the destination
                if (wParam == FSC_RENAME || wParam == 0x8056) {
                    if (wParam == 0x8056)
                        lpTo = (LPSTR)LOWORD(lParam);
                    else
                        lpTo = (LPSTR)lParam;
                    while (*lpTo++)
                        ;
                } else
                    lpTo = NULL;

                ChangeFileSystem((WORD)wParam, (LPSTR)lParam, lpTo);
                break;
            }

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
            MSG("FrameWndProc", "WM_SYSCOLORCHANGE/WININICHANGE");
            if (!lParam || !lstrcmpi((LPSTR)lParam, szInternational)) {
                HWND hwnd;
                GetInternational();

                for (hwnd = GetWindow(hwndMDIClient,GW_CHILD);
                    hwnd;
                    hwnd = GetWindow(hwnd,GW_HWNDNEXT)) {

                    if (!GetWindow(hwnd, GW_OWNER))
                        InvalidateRect(hwnd, NULL, TRUE);
                }
            }
            if (!lParam || !lstrcmpi((LPSTR)lParam, "colors")) {    // win.ini section [colors]
                HWND hwnd;

                DeleteBitmaps();
                LoadBitmaps();

                InitDriveBitmaps();   // reset the drive bitmaps

                // we need to recread the drives windows to change
                // the bitmaps

                for (hwnd = GetWindow(hwndMDIClient,GW_CHILD);
                    hwnd;
                    hwnd = GetWindow(hwnd,GW_HWNDNEXT)) {

                    if (!GetWindow(hwnd, GW_OWNER))
                        SendMessage(hwnd, FS_CHANGEDRIVES, 0, 0L);
                }
            }
            break;

        case FM_GETFOCUS:
        case FM_GETDRIVEINFO:
        case FM_GETSELCOUNT:
        case FM_GETSELCOUNTLFN:
        case FM_GETFILESEL:
        case FM_GETFILESELLFN:
        case FM_REFRESH_WINDOWS:
        case FM_RELOAD_EXTENSIONS:
            return ExtensionMsgProc(wMsg, wParam, lParam);
            break;

        case WM_MENUSELECT:
            MSG("FrameWndProc", "WM_MENUSELECT");
            if (GET_WM_MENUSELECT_HMENU(wParam, lParam)) {
                // Save the menu the user selected
                wMenuID = GET_WM_MENUSELECT_CMD(wParam, lParam);
                wMenuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
                hMenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);
                if (wMenuID >= IDM_CHILDSTART && wMenuID < IDM_HELPINDEX)
                    wMenuID = IDM_CHILDSTART;
            }
            break;

        case WM_ENDSESSION:
            if (wParam) {
#ifdef ORGCODE
                /* Yeah, I know I shouldn't have to save this, but I don't
                 * trust anybody
                 */
                BOOL bSaveExit = bExitWindows;
                bExitWindows = FALSE;

                /* Simulate an exit command to clean up, but don't display
                 * the "are you sure you want to exit", since somebody should
                 * have already taken care of that, and hitting Cancel has no
                 * effect anyway.
                 */
                AppCommandProc(IDM_EXIT, 0L);
                bExitWindows = bSaveExit;
#else
                AppCommandProc(IDM_EXIT);
#endif
            }
            break;

        case WM_CLOSE:

            MSG("FrameWndProc", "WM_ENDSESSION/WM_CLOSE");
            if (iReadLevel) {
                bCancelTree = 2;
                break;
            }

            wParam = IDM_EXIT;

            /*** FALL THRU ***/

        case WM_COMMAND:
            if (AppCommandProc(GET_WM_COMMAND_ID(wParam, lParam)))
                break;
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDM_EXIT) {

                FreeExtensions();
                if (hModUndelete >= (HANDLE)32)
                    FreeLibrary(hModUndelete);

                DestroyWindow(hWnd);
                break;
            }
            /*** FALL THRU ***/

        default:

            if (wMsg == wHelpMessage) {

                if (GET_WM_COMMAND_ID(wParam, lParam) == MSGF_MENU) {

                    // Get outta menu mode if help for a menu item

                    if (wMenuID && hMenu) {
                        WORD m = wMenuID;       // save
                        HMENU hM = hMenu;
                        WORD  mf = wMenuFlags;

                        SendMessage(hWnd, WM_CANCELMODE, 0, 0L);

                        wMenuID   = m;          // restore
                        hMenu = hM;
                        wMenuFlags = mf;
                    }

                    if (!(wMenuFlags & MF_POPUP)) {

                        if (wMenuFlags & MF_SYSMENU)
                            dwContext = IDH_SYSMENU;
                        else
                            dwContext = wMenuID + IDH_HELPFIRST;

                        WFHelp(hWnd);
                    }

                } else if (GET_WM_COMMAND_ID(wParam, lParam) == MSGF_DIALOGBOX) {

                    // context range for message boxes

                    if (dwContext >= IDH_MBFIRST && dwContext <= IDH_MBLAST)
                        WFHelp(hWnd);
                    else
                        // let dialog box deal with it
                        PostMessage(GetRealParent(GET_WM_COMMAND_HWND(wParam, lParam)), wHelpMessage, 0, 0L);
                }

            } else {
                DEFMSG("FrameWndProc", (WORD)wMsg);
                return DefFrameProc(hWnd, hwndMDIClient, wMsg, wParam, lParam);
            }
    }

    return 0L;
}


LRESULT
APIENTRY
MessageFilter(
             INT nCode,
             WPARAM wParam,
             LPARAM lParam
             )
{
    LPMSG lpMsg = (LPMSG) lParam;
    if (nCode == MSGF_MENU) {

        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
            // Window of menu we want help for is in loword of lParam.

            PostMessage(hwndFrame, wHelpMessage, MSGF_MENU, MAKELONG((WORD)lpMsg->hwnd,0));
            return 1;
        }

    } else if (nCode == MSGF_DIALOGBOX) {

        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
            // Dialog box we want help for is in loword of lParam

            PostMessage(hwndFrame, wHelpMessage, MSGF_DIALOGBOX, MAKELONG(lpMsg->hwnd, 0));
            return 1;
        }

    }

    return (INT)DefHookProc(nCode, wParam, (LPARAM)lpMsg, &hhkMessageFilter);
}

/*============================================================================
;
; EnablePropertiesMenu
;
; The following function checks to see if we can enable the Properties...
; item in the File menu.  The Properties... menu should be disabled if:
;
; 1) The root directory is selected in the current tree window.
; 2) ONLY the .. directory is selected in the current directory window.
; 3) Nothing is selected in the window having the focus.
;
; Parameters:
;
; hwndActive    - Currently active window, contains a listbox in LASTFOCUS
; pSel          - Currently selected item.
;
; Return Value: This function returns TRUE if the Properties... menu item
;               should be enabled.
;
============================================================================*/

BOOL
EnablePropertiesMenu (
                     HWND hwndActive,
                     PSTR pSel
                     )

{
    HANDLE hDTA;      /* Handle to list box DTA data */
    WORD wHighlight;  /* Number of highlighted entries in listbox */
    LPMYDTA lpmydta; /* Pointer to listbox DTA data */
    BOOL bRet;        /* Return value */
    HWND hwndLB;

    bRet = FALSE;

    /* Can't get properties on root directory */

    if ((lstrlen (pSel) == 3 && pSel[2] == '\\'))
        return (FALSE);

    if (hwndActive == hwndSearch)
        hwndLB = (HWND)GetWindowLongPtr(hwndActive, GWLP_LASTFOCUSSEARCH);
    else
        hwndLB = (HWND)GetWindowLongPtr(hwndActive, GWLP_LASTFOCUS);

    if (!hwndLB)
        return (TRUE);

    wHighlight = (WORD) SendMessage (hwndLB,LB_GETSELCOUNT,0,0L);

    if (hwndActive == hwndSearch)
        return (wHighlight >= 1);

    /* Lock down DTA data */
    if (!(hDTA = (HANDLE)GetWindowLongPtr (GetParent(hwndLB),GWLP_HDTA)))
        return (TRUE);

    if (!(lpmydta = (LPMYDTA) LocalLock (hDTA)))
        return (TRUE);

    if (wHighlight <= 0)
        goto ReturnFalse;

    if (wHighlight > 1)
        goto ReturnTrue;

    /* If exactly one element is highlighted, make sure it is not .. */

    if (!(BOOL) SendMessage (hwndLB,LB_GETSEL,0,0L))
        goto ReturnTrue;

    /* Get the DTA index. */

    SendMessage (hwndLB,LB_GETTEXT,0,(LPARAM) &lpmydta);
    if (!lpmydta)
        goto ReturnFalse;

    if ((lpmydta->my_dwAttrs & ATTR_DIR) &&
        (lpmydta->my_dwAttrs & ATTR_PARENT))
        goto ReturnFalse;

    ReturnTrue:

    bRet = TRUE;

    ReturnFalse:

    LocalUnlock (hDTA);
    return (bRet);
}

LONG
lmul(
    WORD w1,
    WORD w2
    )
{
    return (LONG)w1 * (LONG)w2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wnetcaps.h ===
#ifndef _WNETCAPS_INCLUDED
    #define _WNETCAPS_INCLUDED


UINT WNetGetCaps( UINT  nIndex );

#define WNNC_CONNECTION         0x00000006
#define  WNNC_CON_ADDCONNECTION     0x00000001
#define  WNNC_CON_CANCELCONNECTION  0x00000002
#define  WNNC_CON_GETCONNECTIONS    0x00000004

#define  WNNC_CON_BROWSEDIALOG      0x00000010

#define  WNNC_CON_RESTORECONNECTION 0x00000020
#define  WNNC_CON_ADDCONNECTION2    0x00000040
#define  WNNC_CON_ENUM              0x00000080

#define WNNC_DIALOG             0x00000008
#define  WNNC_DLG_DEVICEMODE        0x00000001

#define  WNNC_DLG_ConnectDialog     0x00000004
#define  WNNC_DLG_DisconnectDialog  0x00000008


#define  WNNC_DLG_PROPERTYDIALOG    0x00000020
#define  WNNC_DLG_CONNECTIONDIALOG  0x00000040

#define WNNC_ADMIN              0x00000009
#define  WNNC_ADM_GETDIRECTORYTYPE  0x00000001
#define  WNNC_ADM_DIRECTORYNOTIFY   0x00000002
#define  WNNC_ADM_LONGNAMES         0x00000004

//
//  BROWSE DIALOG
//

#define WNBD_CONN_UNKNOWN   0x0
#define WNBD_CONN_DISKTREE  0x1
#define WNBD_CONN_PRINTQ    0x3
#define WNBD_MAX_LENGTH     0x80    // path length, includes the NULL

#define WNTYPE_DRIVE    1
#define WNTYPE_FILE     2
#define WNTYPE_PRINTER  3
#define WNTYPE_COMM     4

#define WNPS_FILE       0
#define WNPS_DIR        1
#define WNPS_MULT       2

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR    1
#define WNDN_RMDIR    2
#define WNDN_MVDIR    3

#endif  // _WNETCAPS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\wnetcaps.c ===
/*
 *	History:
 *	    kevinl	08-Jan-1991	Created
 */

#include "winfile.h"
#include <winnet.h>
#include "wnetcaps.h"

UINT    wConnectionCaps ;
UINT    wDialogCaps ;
UINT    wAdminCaps ;

/*****
 *
 *  WNetGetCaps
 *
 *  WinNet API Function -- see spec for parms and return values.
 *
 */

UINT
WNetGetCaps(
           UINT  nIndex
           )
{
    /* Under NT, the network can be stopped at anytime, so we
     * check everytime someone queries what capabilities we have.
     * Thus overall, we represent a consistent picture to the user (though
     * there will be times when an application may be out of date).
     */

    DWORD dwRet;
    DWORD dwBuffSize = 50;
    CHAR szUserName[50];

    dwRet = WNetGetUser( NULL, szUserName, &dwBuffSize );

    switch ( dwRet ) {
        case WN_NO_NETWORK:

            wConnectionCaps = 0 ;
            wDialogCaps = 0 ;
            wAdminCaps  = 0 ;

            break ;

        default:
            wConnectionCaps =  ( WNNC_CON_ADDCONNECTION     |
                                 WNNC_CON_CANCELCONNECTION  |
                                 WNNC_CON_GETCONNECTIONS     );

            wDialogCaps     =  ( WNNC_DLG_CONNECTIONDIALOG |
                                 WNNC_DLG_DEVICEMODE       |
                                 WNNC_DLG_PROPERTYDIALOG    ) ;

            wAdminCaps      =  ( WNNC_ADM_GETDIRECTORYTYPE   |
                                 WNNC_ADM_DIRECTORYNOTIFY     ) ;
            break ;
    }

    switch (nIndex) {
        case WNNC_CONNECTION:
            return	wConnectionCaps;

        case WNNC_DIALOG:
            return	wDialogCaps;

        case WNNC_ADMIN:
            return  wAdminCaps;

        default:
            return	0;
    }
}  /* WNetGetCaps */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\winobj\winfile.h ===
/****************************************************************************/
/*                                                                          */
/*  WINFILE.H -                                                             */
/*                                                                          */
/*  Include for WINFILE program                                             */
/*                                                                          */
/****************************************************************************/

#define NOCOMM
#define WIN31

#include <windows.h>
#include <port1632.h>
#include <winuserp.h>
#include <setjmp.h>
#include <string.h>
#include <memory.h>
#include <shellapi.h>
#include <shlapip.h>
#include "wfext.h"
#include "wfhelp.h"
#include "dbg.h"

#undef CheckEscapes

#define DwordAlign(cb)      ((cb + 3) & ~3)

typedef HWND NEAR *PHWND;

#define SIZENOMDICRAP       944

#define MAXDOSFILENAMELEN   12+1            // includes the NULL
#define MAXDOSPATHLEN       (68+MAXDOSFILENAMELEN)  // includes the NULL

#define MAXLFNFILENAMELEN   260
#define MAXLFNPATHLEN       260

#define MAXFILENAMELEN      MAXLFNFILENAMELEN
#define MAXPATHLEN          MAXLFNPATHLEN

#define MAXTITLELEN         32
#define MAXMESSAGELEN       (50 + MAXFILENAMELEN * 2)

#include "wfdisk.h"

// struct for volume info

#define MAX_VOLNAME             12
#define MAX_FILESYSNAME         12

typedef struct _VOLINFO {
    DWORD     dwVolumeSerialNumber;
    DWORD     dwMaximumComponentLength;
    DWORD     dwFileSystemFlags;
    DWORD     dwDriveType;
    CHAR      szVolumeName[MAX_VOLNAME];
    CHAR      szFileSysName[MAX_FILESYSNAME];
} VOLINFO;


/*--------------------------------------------------------------------------*/
/*                                      */
/*  Function Templates                              */
/*                                      */
/*--------------------------------------------------------------------------*/

BOOL   APIENTRY FileCDR(FARPROC);
VOID   APIENTRY KernelChangeFileSystem(LPSTR,WORD);

/* WFDOSDIR.ASM */
DWORD  APIENTRY GetExtendedError(VOID);
VOID   APIENTRY DosGetDTAAddress(VOID);
VOID   APIENTRY DosResetDTAAddress(VOID);
BOOL   APIENTRY DosFindFirst(LPDOSDTA, LPSTR, WORD);
BOOL   APIENTRY DosFindNext(LPDOSDTA);
BOOL   APIENTRY DosDelete(LPSTR);
INT    APIENTRY GetCurrentVolume(LPSTR);
INT    APIENTRY UpdateDriveList(VOID);
WORD   APIENTRY GetFirstCDROMDrive(VOID);
// WORD   APIENTRY GetFileAttributes(LPSTR);
// WORD   APIENTRY SetFileAttributes(LPSTR, WORD);
DWORD  APIENTRY GetFreeDiskSpace(WORD);
DWORD  APIENTRY GetTotalDiskSpace(WORD);
INT    APIENTRY ChangeVolumeLabel(INT, LPSTR);
INT    APIENTRY GetVolumeLabel(INT, LPSTR, BOOL);
INT    APIENTRY DeleteVolumeLabel(INT);
INT    APIENTRY CreateVolumeFile(LPSTR);
INT    APIENTRY CreateVolumeLabel(INT, LPSTR);
INT    APIENTRY MySetVolumeLabel(INT, BOOL, LPSTR);

INT    APIENTRY WF_CreateDirectory(HWND, LPSTR);
WORD   APIENTRY FileCopy(LPSTR szSource, LPSTR szDest);

/* WFDISK.C */
DWORD  APIENTRY LongShift(DWORD dwValue, WORD wCount);
VOID   APIENTRY SetDASD(WORD, BYTE);
LPDBT  APIENTRY GetDBT(VOID);
HANDLE  APIENTRY BuildDevPB(PDevPB);
VOID   APIENTRY DiskReset(VOID);
WORD   APIENTRY GetDPB(WORD, PDPB);
VOID   APIENTRY SetDPB(WORD, PBPB, PDPB);
INT    APIENTRY ModifyDPB(WORD);
INT    APIENTRY MyInt25(WORD, LPSTR, WORD, WORD);
INT    APIENTRY MyReadWriteSector(LPSTR, WORD, WORD, WORD, WORD, WORD);
INT    APIENTRY GenericReadWriteSector(LPSTR, WORD, WORD, WORD, WORD, WORD);
VOID   APIENTRY lStrucCopy(LPSTR, LPSTR, WORD);
INT    APIENTRY FormatTrackHead(WORD, WORD, WORD, WORD, LPSTR);
INT    APIENTRY GenericFormatTrack(WORD, WORD, WORD, WORD, LPSTR);
INT    APIENTRY MyGetDriveType(WORD);
INT    APIENTRY WriteBootSector(WORD, WORD, PBPB, LPSTR);
WORD   APIENTRY GetDriveCapacity(WORD);
DWORD  APIENTRY DreamUpSerialNumber(VOID);
DWORD  APIENTRY GetClusterInfo(WORD);
DWORD  APIENTRY ReadSerialNumber(INT, LPSTR);
INT    APIENTRY ModifyVolLabelInBootSec(INT, LPSTR, DWORD, LPSTR);
LPSTR  GetRootPath(WORD wDrive);

/* WFUTIL.C */
INT  APIENTRY GetBootDisk(VOID);
VOID  APIENTRY FixAnsiPathForDos(LPSTR szPath);
VOID  APIENTRY RefreshWindow(HWND hwndActive);
BOOL  APIENTRY IsLastWindow(VOID);
//LPSTR  APIENTRY AddCommas(LPSTR szBuf, DWORD dw);
VOID  APIENTRY GetVolShare(WORD wDrive, LPSTR szVolShare);
VOID  APIENTRY InvalidateChildWindows(HWND hwnd);
BOOL  APIENTRY IsValidDisk(INT iDrive);
LPSTR  APIENTRY GetSelection(INT iSelType);
LPSTR  APIENTRY GetNextFile(LPSTR pCurSel, LPSTR szFile, INT size);
VOID  APIENTRY SetWindowDirectory(VOID);
VOID  APIENTRY SetDlgDirectory(HWND hDlg, PSTR pszPath);
VOID  APIENTRY WritePrivateProfileBool(LPSTR szKey, BOOL bParam);
VOID  APIENTRY WritePrivateProfileInt(LPSTR szKey, INT wParam);
BOOL  APIENTRY IsWild(LPSTR lpszPath);
VOID  APIENTRY AddBackslash(LPSTR lpszPath);
VOID  APIENTRY StripBackslash(LPSTR lpszPath);
VOID  APIENTRY StripFilespec(LPSTR lpszPath);
VOID  APIENTRY StripPath(LPSTR lpszPath);
LPSTR  APIENTRY GetExtension(LPSTR pszFile);
BOOL  APIENTRY FindExtensionInList(LPSTR pszExt, LPSTR pszList);
INT   APIENTRY MyMessageBox(HWND hWnd, WORD idTitle, WORD idMessage, WORD wStyle);
WORD  APIENTRY ExecProgram(LPSTR,LPSTR,LPSTR,BOOL);
BOOL  APIENTRY IsProgramFile(LPSTR lpszPath);
BOOL  APIENTRY IsDocument(LPSTR lpszPath);
BOOL  APIENTRY IsRemovableDrive(INT);
BOOL  APIENTRY IsRemoteDrive(INT);
VOID  APIENTRY SetMDIWindowText(HWND hWnd, LPSTR szTitle);
INT   APIENTRY GetMDIWindowText(HWND hWnd, LPSTR szTitle, INT size);
BOOL  APIENTRY ResizeSplit(HWND hWnd, INT dxSplit);

/* WFDIRSRC.C */
HCURSOR  APIENTRY GetMoveCopyCursor(VOID);
VOID  APIENTRY SetLBFont(HWND hWnd, HWND hwndLB, HANDLE hFont);
VOID  APIENTRY DrawItem(LPDRAWITEMSTRUCT lpLBItem, LPSTR szLine, DWORD dwAttrib, BOOL bHilight, WORD *pTabs);
VOID  APIENTRY DSDragLoop(HWND hwndLB, WPARAM wParam, LPDROPSTRUCT lpds, BOOL bSearch);
VOID  APIENTRY DSRectItem(HWND hwndLB, INT iSel, BOOL bFocusOn, BOOL bSearch);
INT   APIENTRY DSTrackPoint(HWND hWnd, HWND hwndLB, WPARAM wParam, LPARAM lParam, BOOL bSearch);
VOID  APIENTRY DSSetSelection(HWND hwndLB, BOOL bSelect, LPSTR szSpec, BOOL bSearch);
INT   APIENTRY FixTabsAndThings(HWND hwndLB, WORD *pwTabs, INT iMaxWidthFileName, WORD wViewOpts);

VOID  APIENTRY UpdateStatus(HWND hWnd);
BOOL  APIENTRY CompactPath(HDC hdc, LPSTR szPath, WORD dx);
VOID  APIENTRY SetActiveDirectory(VOID);
VOID  APIENTRY GetInternational(VOID);
VOID  APIENTRY BuildDocumentString(VOID);
BOOL  APIENTRY LoadBitmaps(VOID);
BOOL  APIENTRY InitFileManager(HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdLine, INT nCmdShow);
VOID  APIENTRY InitDriveBitmaps(VOID);
VOID  APIENTRY InitExtensions(VOID);
VOID  APIENTRY FreeFileManager(VOID);
VOID  APIENTRY DeleteBitmaps(VOID);
BOOL  APIENTRY FormatFloppy(HWND hWnd, WORD nDestDrive, INT iCapacity, BOOL bMakeSysDisk, BOOL bQuick);
BOOL  APIENTRY HasSystemFiles(WORD iDrive);
BOOL  APIENTRY MakeSystemDiskette(WORD nDestDrive, BOOL bEmptyDisk);
INT   APIENTRY CopyDiskette(HWND hwnd, WORD nSrcDrive, WORD nDestDrive);
VOID  APIENTRY ChangeFileSystem(WORD wOper, LPSTR lpPath, LPSTR lpTo);
WORD  APIENTRY DMMoveCopyHelper(LPSTR pFrom, LPSTR pTo, BOOL bCopy);
WORD  APIENTRY WFMoveCopyDriver(LPSTR pFrom, LPSTR pTo, WORD wFunc);
WORD  APIENTRY IsTheDiskReallyThere(HWND hwnd, register LPSTR pPath, WORD wFunc);
WORD  APIENTRY WFPrint(LPSTR szFile);
VOID  APIENTRY GetSelectedDirectory(WORD iDrive, PSTR pszDir);
VOID  APIENTRY SaveDirectory(PSTR pszDir);
INT   APIENTRY GetSelectedDrive(VOID);
VOID  APIENTRY GetTextStuff(HDC hdc);
INT   APIENTRY GetHeightFromPointsString(LPSTR szPoints);

INT   APIENTRY GetDrive(HWND hwnd, POINT pt);

VOID  APIENTRY CheckSlashies(LPSTR);
VOID  APIENTRY SetSourceDir(LPDROPSTRUCT lpds); // wfdir.c
VOID  APIENTRY UpdateSelection(HWND hwndLB);
DWORD  APIENTRY GetVolShareExtent(HWND hWnd);       // wfdrives.c


BOOL  APIENTRY WFQueryAbort(VOID);

VOID  APIENTRY EnableFSC( VOID );
VOID  APIENTRY DisableFSC( VOID );

VOID  APIENTRY ResizeWindows(HWND hwndParent,WORD dxWindow, WORD dyWindow);
BOOL  APIENTRY CheckDrive(HWND hwnd, INT nDrive);
INT_PTR  APIENTRY FrameWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
BOOL     APIENTRY AppCommandProc(WORD id);
INT_PTR  APIENTRY TreeWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DriveWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DrivesWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY VolumeWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY TreeChildWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY TreeControlWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DirWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SearchWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

INT_PTR  APIENTRY DrivesDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY AssociateDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SearchDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY RunDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SelectDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY FontDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SuperDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY AttribsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY MakeDirDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ExitDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DiskLabelDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ChooseDriveDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY FormatDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY Format2DlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ProgressDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DiskCopyDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DiskCopy2DlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ConnectDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY PreviousDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY OtherDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SortByDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY IncludeDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ConfirmDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
VOID  APIENTRY SaveWindows(HWND hwndMain);
INT  APIENTRY PutDate(LPFILETIME lpftDate, LPSTR szStr);
INT  APIENTRY PutTime(LPFILETIME lpftTime, LPSTR szStr);
INT  APIENTRY PutSize(DWORD dwSize, LPSTR szOutStr);
INT  APIENTRY PutAttributes(register DWORD dwAttribute, register LPSTR szStr);
BOOL  APIENTRY CreateSavedWindows(VOID);
HWND  APIENTRY CreateDirWindow(register LPSTR szPath, BOOL bReplaceOpen, HWND hwndActive);
HWND  APIENTRY CreateTreeWindow(LPSTR szDir, INT dxSplit);
VOID  APIENTRY GetTreeWindows(HWND hwnd, PHWND phwndTree, PHWND phwndDir, PHWND hwndDrives);
HWND  APIENTRY GetTreeFocus(HWND hWnd);
VOID  APIENTRY SetTreeCase(HWND hWnd);
INT   APIENTRY GetSplit(HWND hwnd);
HWND  APIENTRY GetMDIChildFromDecendant(HWND hwnd);
INT   APIENTRY GetDrive(HWND hwnd, POINT pt);
WORD  APIENTRY IsNetDrive(INT iDrive);
WORD  APIENTRY IsCDRomDrive(INT iDrive);
BOOL  APIENTRY IsRamDrive(INT wDrive);
WORD  APIENTRY WFGetConnection(LPSTR,LPSTR,BOOL);
WORD  APIENTRY NetCheck(LPSTR,WORD);

VOID  APIENTRY InitExtensions(VOID);

VOID  APIENTRY NewTree(INT iDrive, HWND hWnd);
INT   APIENTRY FormatDiskette(HWND hwnd);
VOID  APIENTRY NewFont(VOID);
HWND  APIENTRY GetRealParent(HWND hwnd);
VOID  APIENTRY WFHelp(HWND hwnd);
LRESULT APIENTRY MessageFilter(INT nCode, WPARAM wParam, LPARAM lParam);
VOID  APIENTRY UpdateConnections(VOID);
VOID APIENTRY FillVolumeInfo(INT iVol);
WORD APIENTRY WFCopy(PSTR,PSTR);
WORD APIENTRY StartCopy(VOID);
WORD APIENTRY EndCopy(VOID);
VOID APIENTRY CopyAbort(VOID);
VOID APIENTRY QualifyPath(PSTR);
VOID APIENTRY wfYield(VOID);

LONG APIENTRY lmul(WORD w1, WORD w2);

#define DEBUGF(foo)
#define STKCHK()

#define TA_LOWERCASE    0x01
#define TA_BOLD     0x02
#define TA_ITALIC   0x04

#ifndef NO_WF_GLOBALS

/*--------------------------------------------------------------------------*/
/*                                      */
/*  Global Externs                              */
/*                                      */
/*--------------------------------------------------------------------------*/

extern BOOL bNetAdmin;
extern BOOL bMinOnRun;
extern BOOL bReplace;
extern BOOL bStatusBar;
extern BOOL bConfirmDelete;
extern BOOL bConfirmSubDel;
extern BOOL bConfirmReplace;
extern BOOL bConfirmMouse;
extern BOOL bConfirmFormat;
extern BOOL bSaveSettings;
extern BOOL bSearchSubs;
extern BOOL bUserAbort;
extern BOOL bConnect;
extern BOOL bDisconnect;
extern BOOL bFileSysChanging;
extern BOOL fShowSourceBitmaps;
extern BOOL bMultiple;
extern BOOL bFSCTimerSet;
extern BOOL bSaveSettings;


extern CHAR chFirstDrive;

extern CHAR szExtensions[];
extern CHAR szFrameClass[];
extern CHAR szTreeClass[];
extern CHAR szDriveClass[];
extern CHAR szDrivesClass[];
extern CHAR szVolumeClass[];
extern CHAR szTreeChildClass[];
extern CHAR szTreeControlClass[];
extern CHAR szDirClass[];
extern CHAR szSearchClass[];

extern CHAR szSaveSettings[];
extern CHAR szMinOnRun[];
extern CHAR szReplace[];
extern CHAR szLowerCase[];
extern CHAR szStatusBar[];
extern CHAR szCurrentView[];
extern CHAR szCurrentSort[];
extern CHAR szCurrentAttribs[];
extern CHAR szConfirmDelete[];
extern CHAR szConfirmSubDel[];
extern CHAR szConfirmReplace[];
extern CHAR szConfirmMouse[];
extern CHAR szConfirmFormat[];
extern CHAR szTreeKey[];
extern CHAR szDirKeyFormat[];
extern CHAR szWindow[];

extern CHAR szDefPrograms[];
extern CHAR szINIFile[];
extern CHAR szWindows[];
extern CHAR szPrevious[];
extern CHAR szSettings[];
extern CHAR szInternational[];
extern CHAR szStarDotStar[];
extern CHAR szNULL[];
extern CHAR szBlank[];
extern CHAR szEllipses[];
extern CHAR szReservedMarker[];
extern CHAR szNetwork[];

extern CHAR szDirsRead[32];
extern CHAR szCurrentFileSpec[];
extern CHAR szShortDate[];
extern CHAR szTime[];
extern CHAR sz1159[];
extern CHAR sz2359[];
extern CHAR szComma[2];
extern CHAR szDated[];
extern CHAR szListbox[];
extern CHAR szWith[];

extern CHAR szTheINIFile[64+12+3];
extern CHAR szTitle[128];
extern CHAR szMessage[MAXMESSAGELEN+1];
extern CHAR szSearch[MAXPATHLEN+1];
extern CHAR szStatusTree[80];
extern CHAR szStatusDir[80];
extern CHAR szOriginalDirPath[64+12+3];
extern CHAR szFace[];
extern CHAR szSize[];
extern CHAR     szAddons[];
extern CHAR     szUndelete[];
extern CHAR szWinObjHelp[];
extern CHAR szSaveSettings[];
extern CHAR     szBytes[10];
extern CHAR     szSBytes[10];

extern INT  cKids;
extern INT  cDrives;
extern INT  dxDrive;
extern INT  dyDrive;
extern INT  dxDriveBitmap;
extern INT  dyDriveBitmap;
extern INT  dxEllipses;
extern INT  dxBraces;
extern INT  dxFolder;
extern INT  dyFolder;
extern INT  dyBorder;       /* System Border Width/Height       */
extern INT  dyBorderx2;     /* System Border Width/Height * 2   */
extern INT  dyStatus;       /* Status Bar height            */
extern INT  dxStatusField;
extern INT  dxText;         /* System Font Width 'M'        */
extern INT  dyText;         /* System Font Height           */
extern INT  dxFileName;
extern INT  dyFileName;
extern INT  dxFileDetails;
extern INT  iFormatDrive;       /* Logical # of the drive to format */
extern INT  iCurrentDrive;      /* Logical # of the drive to format */
extern INT  nFloppies;      /* Number of Removable Drives       */
extern INT  rgiDrive[26];
extern INT  rgiDriveType[26];
extern VOLINFO *(apVolInfo[26]);
extern INT  rgiInt13Drive[26];
extern INT  rgiDrivesOffset[26];
extern INT  idViewChecked;
extern INT  idSortChecked;
extern INT  defTabStops[];
extern INT  iSelHilite;
extern INT  iTime;
extern INT  iTLZero;
extern INT  cDisableFSC;
extern INT  iReadLevel;
extern INT  dxFrame;
extern INT  dyTitle;
extern INT  dxClickRect;
extern INT  dyClickRect;

extern HANDLE   hAccel;
extern HANDLE   hAppInstance;

extern HBITMAP  hbmBitmaps;
extern HDC  hdcMem;

extern INT  iCurDrag;
extern HICON    hicoTree;
extern HICON    hicoTreeDir;
extern HICON    hicoDir;

extern HWND hdlgProgress;
extern HWND hwndFrame;
extern HWND hwndLastActiveDir;
extern HWND hwndMDIClient;
extern HWND hwndSearch;
extern HWND hwndDragging;       /* source window of DM */

extern LPSTR szPrograms;
extern LPSTR szDocuments;

extern WORD wTextAttribs;
extern WORD wSuperDlgMode;
extern WORD wCDROMIndex;
extern WORD wDOSversion;
extern UINT wHelpMessage;
extern UINT wBrowseMessage;

extern WORD wNewView;
extern WORD wNewSort;
extern DWORD dwNewAttribs;
extern WORD xTreeMax;

extern LONG lFreeSpace;
extern LONG lTotalSpace;

extern BOOL bPaintBackground;
extern BOOL bCancelTree;

extern HFONT hFont;
extern HFONT hFontStatus;

extern EXTENSION extensions[MAX_EXTENSIONS];
extern INT iDeltaStart;
extern INT iNumExtensions;
extern DWORD ( APIENTRY *lpfpUndelete)(HWND, LPSTR);

extern HHOOK hhkMessageFilter;
extern DWORD dwContext;
extern HANDLE hModUndelete;
extern WORD fFormatFlags;
extern WORD nLastDriveInd;

#endif // ndef NO_WF_GLOBALS

/*--------------------------------------------------------------------------*/
/*                                      */
/*  Defines                                 */
/*                                      */
/*--------------------------------------------------------------------------*/

#define TABCHAR             '\t'

#define DO_LISTOFFILES      1L

#define WS_MDISTYLE (WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_SYSMENU | WS_CAPTION | WS_THICKFRAME | WS_MAXIMIZEBOX)
#define WS_DIRSTYLE (WS_CHILD | LBS_SORT | LBS_NOTIFY | LBS_OWNERDRAWFIXED | LBS_EXTENDEDSEL | LBS_NOINTEGRALHEIGHT | LBS_WANTKEYBOARDINPUT)
#define WS_SEARCHSTYLE  (WS_DIRSTYLE | LBS_HASSTRINGS | WS_VSCROLL)


/* Extra Window Word Offsets */

// szTreeClass & szSearchClass common..

#define GWL_TYPE            0   // > 0 Tree, -1 = search
#define GWL_VIEW            4
#define GWL_SORT            8
#define GWL_ATTRIBS         12
#define GWL_FSCFLAG         16

// szTreeClass only...

#define GWLP_LASTFOCUS       20
#define GWL_SPLIT           24

// szSearchClass only...

#define GWLP_HDTASEARCH      20
#define GWLP_TABARRAYSEARCH  24  // on                   szSearchClass
#define GWLP_LASTFOCUSSEARCH 28  // on                   szSearchClass

// szDirClass...

#define GWLP_HDTA            0
#define GWLP_TABARRAY        4

// szDrivesClass...

#define GWL_CURDRIVEIND     0   // current selection in drives window
#define GWL_CURDRIVEFOCUS   4   // current focus in drives window
#define GWLP_LPSTRVOLUME     8   // LPSTR to Volume/Share string

// szTreeControlClass

#define GWL_READLEVEL       0   // iReadLevel for each tree control window



// GWL_TYPE numbers

#define TYPE_TREE           0   // and all positive numbers (drive number)
#define TYPE_SEARCH         -1


/* WM_FILESYSCHANGE message wParam value */
#define FSC_CREATE          0
#define FSC_DELETE          1
#define FSC_RENAME          2
#define FSC_ATTRIBUTES      3
#define FSC_NETCONNECT      4
#define FSC_NETDISCONNECT   5
#define FSC_REFRESH         6
#define FSC_MKDIR           7
#define FSC_RMDIR           8

#define WM_LBTRACKPT        0x131

#define TC_SETDRIVE         0x944
#define TC_GETCURDIR        0x945
#define TC_EXPANDLEVEL      0x946
#define TC_COLLAPSELEVEL    0x947
#define TC_GETDIR           0x948
#define TC_SETDIRECTORY     0x949
#define TC_TOGGLELEVEL      0x950

#define FS_CHANGEDISPLAY    (WM_USER+0x100)
#define FS_CHANGEDRIVES     (WM_USER+0x101)
#define FS_GETSELECTION     (WM_USER+0x102)
#define FS_GETDIRECTORY     (WM_USER+0x103)
#define FS_GETDRIVE         (WM_USER+0x104)
#define WM_OWNERDRAWBEGIN   (WM_USER+0x105)
#define WM_OWNERDRAWEND     (WM_USER+0x106)
#define FS_SETDRIVE         (WM_USER+0x107)
#define FS_GETFILESPEC      (WM_USER+0x108)
#define FS_SETSELECTION     (WM_USER+0x109)

#define ATTR_READWRITE      0x0000
#define ATTR_READONLY       FILE_ATTRIBUTE_READONLY     // == 0x0001
#define ATTR_HIDDEN         FILE_ATTRIBUTE_HIDDEN       // == 0x0002
#define ATTR_SYSTEM         FILE_ATTRIBUTE_SYSTEM       // == 0x0004
#define ATTR_VOLUME         0x0008
#define ATTR_DIR            FILE_ATTRIBUTE_DIRECTORY    // == 0x0010
#define ATTR_ARCHIVE        FILE_ATTRIBUTE_ARCHIVE      // == 0x0020
#define ATTR_NORMAL         FILE_ATTRIBUTE_NORMAL       // == 0x0080
#define ATTR_PARENT         0x0040  // my hack DTA bits
#define ATTR_LFN            0x1000  // my hack DTA bits
#define ATTR_RWA            (ATTR_READWRITE | ATTR_ARCHIVE)
#define ATTR_ALL            (ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIR | ATTR_ARCHIVE | ATTR_NORMAL)
#define ATTR_PROGRAMS       0x0100
#define ATTR_DOCS           0x0200
#define ATTR_OTHER          0x0400
#define ATTR_EVERYTHING     (ATTR_ALL | ATTR_PROGRAMS | ATTR_DOCS | ATTR_OTHER | ATTR_PARENT)
#define ATTR_DEFAULT        (ATTR_EVERYTHING & ~(ATTR_HIDDEN | ATTR_SYSTEM))
#define ATTR_HS             (ATTR_HIDDEN | ATTR_SYSTEM)

#define ATTR_TYPES          0x00ff0000
#define ATTR_SYMLINK        0x00010000
#define ATTR_ADAPTER        0x00020000
#define ATTR_CONTROLLER     0x00030000
#define ATTR_DEVICE         0x00040000
#define ATTR_DRIVER         0x00050000
#define ATTR_EVENT          0x00060000
#define ATTR_EVENTPAIR      0x00070000
#define ATTR_FILE           0x00080000
#define ATTR_MUTANT         0x00090000
#define ATTR_PORT           0x000a0000
#define ATTR_PROFILE        0x000b0000
#define ATTR_SECTION        0x000c0000
#define ATTR_SEMAPHORE      0x000d0000
#define ATTR_TIMER          0x000e0000
#define ATTR_TYPE           0x000f0000
#define ATTR_PROCESS        0x00100000

#define ATTR_USED           (0x00BF | ATTR_TYPES)

#define ATTR_RETURNED       0x2000  /* used in DTA's by copy */

#define CD_PATH             0x0001
#define CD_VIEW             0x0002
#define CD_SORT             0x0003
#define CD_PATH_FORCE       0x0004
#define CD_SEARCHUPDATE     0x0005
#define CD_ALLOWABORT       0x8000

#define VIEW_NAMEONLY       0x0000
#define VIEW_UPPERCASE      0x0001
#define VIEW_SIZE           0x0002
#define VIEW_DATE           0x0004
#define VIEW_TIME           0x0008
#define VIEW_FLAGS          0x0010
#define VIEW_PLUSES         0x0020
#define VIEW_EVERYTHING     (VIEW_SIZE | VIEW_TIME | VIEW_DATE | VIEW_FLAGS)

#define CBSECTORSIZE        512

#define INT13_READ          2
#define INT13_WRITE         3

#define ERR_USER            0xF000

/* Child Window IDs */
#define IDCW_DRIVES         1
#define IDCW_DIR            2
#define IDCW_TREELISTBOX    3
#define IDCW_TREECONTROL    5
#define IDCW_LISTBOX        6   // list in search


#define HasDirWindow(hwnd)      GetDlgItem(hwnd, IDCW_DIR)
#define HasTreeWindow(hwnd)     GetDlgItem(hwnd, IDCW_TREECONTROL)
#define HasDrivesWindow(hwnd)   GetDlgItem(hwnd, IDCW_DRIVES)
#define GetSplit(hwnd)          ((int)GetWindowLong(hwnd, GWL_SPLIT))


/* Menu Command Defines */
#define IDM_FILE            0
#define IDM_OPEN            101
#define IDM_PRINT           102
#define IDM_ASSOCIATE       103
#define IDM_SEARCH          104
#define IDM_RUN             105
#define IDM_MOVE            106
#define IDM_COPY            107
#define IDM_DELETE          108
#define IDM_RENAME          109
#define IDM_ATTRIBS         110
#define IDM_MAKEDIR         111
#define IDM_SELALL          112
#define IDM_DESELALL        113
#define IDM_UNDO            114
#define IDM_EXIT            115
#define IDM_SELECT          116
#define IDM_UNDELETE        117
#define IDM_DISK            7
#define IDM_DISKCOPY        801
#define IDM_LABEL           802
#define IDM_FORMAT          803
#define IDM_SYSDISK         804
#define IDM_CONNECT         805
#define IDM_DISCONNECT      806
#define IDM_DRIVESMORE      851
#define IDM_CONNECTIONS     852
#define IDM_TREE            1
#define IDM_EXPONE          201
#define IDM_EXPSUB          202
#define IDM_EXPALL          203
#define IDM_COLLAPSE        204
#define IDM_NEWTREE         205
#define IDM_VIEW            2
#define IDM_VNAME           301
#define IDM_VDETAILS        302
#define IDM_VOTHER          303

#define IDM_BYNAME          304
#define IDM_BYTYPE          305
#define IDM_BYSIZE          306
#define IDM_BYDATE          307

#define IDM_VINCLUDE        309
#define IDM_REPLACE         310

#define IDM_TREEONLY        311
#define IDM_DIRONLY         312
#define IDM_BOTH            313
#define IDM_SPLIT           314

#define IDM_OPTIONS         3
#define IDM_CONFIRM         401
#define IDM_LOWERCASE       402
#define IDM_STATUSBAR       403
#define IDM_MINONRUN        404
#define IDM_ADDPLUSES       405
#define IDM_EXPANDTREE      406
#define IDM_FONT            410
#define IDM_SAVESETTINGS    411

#define IDM_EXTENSIONS      5

#define IDM_WINDOW          10      // IDM_EXTENSIONS + MAX_EXTENSIONS
#define IDM_CASCADE         1001
#define IDM_TILE            1002
#define IDM_REFRESH         1003
#define IDM_ARRANGE         1004
#define IDM_NEWWINDOW       1005
#define IDM_CHILDSTART      1006

#define IDM_HELP            11      // IDM_WINDOW + 1
#define IDM_HELPINDEX       1101
#define IDM_HELPKEYS        0x001E
#define IDM_HELPCOMMANDS    0x0020
#define IDM_HELPPROCS       0x0021
#define IDM_HELPHELP        1102
#define IDM_ABOUT           1103

#define BITMAPS             100
#define FILES_WIDTH         16
#define FILES_HEIGHT        16
#define DRIVES_WIDTH        27
#define DRIVES_HEIGHT       14

#define APPICON             200
#define TREEICON            201
#define DIRICON             202
#define WINDOWSICON         203
#define TREEDIRICON         204

#define SINGLEMOVECURSOR    300 // move is even
#define MULTMOVECURSOR      302
#define SINGLECOPYCURSOR    301 // copy is odd
#define MULTCOPYCURSOR      303

#define APPCURSOR           300
#define DIRCURSOR           301
#define DOCCURSOR           302
#define FILECURSOR          304
#define FILESCURSOR         305
#define SPLITCURSOR         306

#define APPCURSORC          310
#define DIRCURSORC          311
#define DOCCURSORC          312
#define FILECURSORC         314
#define FILESCURSORC        315

#define WFACCELTABLE        400

#define FRAMEMENU           500

/* Indexes into the mondo bitmap */
#define BM_IND_APP          0
#define BM_IND_DOC          1
#define BM_IND_FIL          2
#define BM_IND_RO           3
#define BM_IND_DIRUP        4
#define BM_IND_CLOSE        5
#define BM_IND_CLOSEPLUS    6
#define BM_IND_OPEN         7
#define BM_IND_OPENPLUS     8
#define BM_IND_OPENMINUS    9
#define BM_IND_CLOSEMINUS   10
#define BM_IND_CLOSEDFS     11
#define BM_IND_OPENDFS      12
#define BM_IND_TYPEBASE     13

#define IDS_ENDSESSION      40  /* Must be > 32 */
#define IDS_ENDSESSIONMSG   41
#define IDS_COPYDISK        50
#define IDS_INSERTDEST      51
#define IDS_INSERTSRC       52
#define IDS_INSERTSRCDEST   53
#define IDS_FORMATTINGDEST  54
#define IDS_COPYDISKERR     55
#define IDS_COPYDISKERRMSG  56
#define IDS_COPYDISKSELMSG  57
#define IDS_COPYSRCDESTINCOMPAT 58
#define IDS_PERCENTCOMP     60
#define IDS_CREATEROOT      61
#define IDS_COPYSYSFILES    62
#define IDS_FORMATERR       63
#define IDS_FORMATERRMSG    64
//#define IDS_FORMATCURERR    65
#define IDS_FORMATCOMPLETE  66
#define IDS_FORMATANOTHER   67
#define IDS_FORMATCANCELLED 68
#define IDS_SYSDISK         70
#define IDS_SYSDISKRUSURE   71
#define IDS_SYSDISKERR      72
#define IDS_SYSDISKNOFILES  73
#define IDS_SYSDISKSAMEDRIVE    74
#define IDS_SYSDISKADDERR   75
#define IDS_NETERR          80
#define IDS_NETCONERRMSG    81
#define IDS_NETDISCONCURERR 82
#define IDS_NETDISCONWINERR 83
#define IDS_NETDISCON       84
#define IDS_NETDISCONRUSURE 85
#define IDS_NETDISCONERRMSG 86
#define IDS_FILESYSERR      90
#define IDS_ATTRIBERR       91
#define IDS_MAKEDIRERR      92
#define IDS_LABELDISKERR    93
#define IDS_SEARCHERR       94
#define IDS_SEARCHNOMATCHES 95
#define IDS_MAKEDIREXISTS   96
#define IDS_SEARCHREFRESH   97
#define IDS_ASSOCFILE       100
#define IDS_DRIVETEMP       101
#define IDS_EXECERRTITLE    110
#define IDS_UNKNOWNMSG      111
#define IDS_NOMEMORYMSG     112
#define IDS_FILENOTFOUNDMSG 113
#define IDS_BADPATHMSG      114
#define IDS_MANYOPENFILESMSG    115
#define IDS_NOASSOCMSG      116
#define IDS_MULTIPLEDSMSG   117
#define IDS_ASSOCINCOMPLETE 118
#define IDS_MOUSECONFIRM    120
#define IDS_COPYMOUSECONFIRM    121
#define IDS_MOVEMOUSECONFIRM    122
#define IDS_EXECMOUSECONFIRM    123
#define IDS_WINFILE         124
#define IDS_ONLYONE         125
#define IDS_TREETITLE       126
#define IDS_SEARCHTITLE     127
#define IDS_NOFILESTITLE    130
#define IDS_NOFILESMSG      131
#define IDS_TOOMANYTITLE    132
#define IDS_OOMTITLE        133
#define IDS_OOMREADINGDIRMSG    134
#define IDS_CURDIRIS        140
#define IDS_COPY            141
#define IDS_ANDCOPY         142
#define IDS_RENAME          143
#define IDS_ANDRENAME       144
#define IDS_FORMAT          145
#define IDS_FORMATSELDISK   146
//#define IDS_MAKESYSDISK     147
#define IDS_DISCONNECT      148
#define IDS_DISCONSELDISK   149
#define IDS_CREATINGMSG     150
#define IDS_REMOVINGMSG     151
#define IDS_COPYINGMSG      152
#define IDS_RENAMINGMSG     153
#define IDS_MOVINGMSG       154
#define IDS_DELETINGMSG     155
#define IDS_PRINTINGMSG     156
#define IDS_NOSUCHDRIVE     160
#define IDS_MOVEREADONLY    161
#define IDS_RENAMEREADONLY  162
#define IDS_CONFIRMREPLACE  163
#define IDS_CONFIRMREPLACERO    164 /* Confirm/readonly */
#define IDS_CONFIRMRMDIR    165 /* Must be confirm + 1 */
#define IDS_CONFIRMRMDIRRO  166
#define IDS_CONFIRMDELETE   167
#define IDS_CONFIRMDELETERO 168
#define IDS_COPYINGTITLE    169
#define IDS_REMOVINGDIRMSG  170
#define IDS_STATUSMSG       180
#define IDS_DIRSREAD        181
#define IDS_DRIVEFREE       182
#define IDS_SEARCHMSG       183
#define IDS_DRIVE           184
#define IDS_SELECTEDFILES   185
#define IDS_NETDISCONOPEN   186
#define IDS_STATUSMSG2      187
#define IDS_DRIVENOTREADY   188
#define IDS_UNFORMATTED     189

#define IDS_CANTPRINTTITLE  190
#define IDS_PRINTFNF        191
#define IDS_PRINTDISK       192
#define IDS_PRINTMEMORY     193
#define IDS_PRINTERROR      194
#define IDS_TREEABORT       195
#define IDS_TREEABORTTITLE  196
#define IDS_DESTFULL        197
#define IDS_WRITEPROTECTFILE    198
#define IDS_FORMATQUICKFAILURE  199

#define IDS_OS2APPMSG       200
#define IDS_NEWWINDOWSMSG   201
#define IDS_PMODEONLYMSG    202

#define IDS_DDEFAIL         203

#define IDS_FORMATCONFIRM   210
#define IDS_FORMATCONFIRMTITLE  211
#define IDS_DISKCOPYCONFIRM 212
#define IDS_DISKCOPYCONFIRMTITLE    213
#define IDS_CLOSE           214
#define IDS_UNDELETE        215
#define IDS_CONNECT         216
#define IDS_CONNECTIONS     217
#define IDS_PATHNOTTHERE    218
#define IDS_PROGRAMS        219
#define IDS_ASSOCIATE       220
#define IDS_RUN             221
#define IDS_PRINTERRTITLE   222
#define IDS_WINHELPERR      223
#define IDS_NOEXEASSOC          224
#define IDS_ASSOCNOTEXE         225
#define IDS_ASSOCNONE           226
#define IDS_NOFILES             227
#define IDS_PRINTONLYONE        228
#define IDS_COMPRESSEDEXE       229
#define IDS_INVALIDDLL          230
#define IDS_SHAREERROR          231
#define IDS_CREATELONGDIR       232
#define IDS_CREATELONGDIRTITLE  233
#define IDS_BYTES       234
#define IDS_SBYTES      235

#define IDS_DRIVEBASE       300
#define IDS_12MB            (300 + DS96)
#define IDS_360KB           (300 + DS48)
#define IDS_144MB           (300 + DS144M)
#define IDS_720KB           (300 + DS720KB)
#define IDS_288MB           (300 + DS288M)
#define IDS_DEVICECAP       (300 + DS288M + 1)


#define IDS_FFERR_MEM       400
#define IDS_FFERR_USERABORT 401
#define IDS_FFERR_SRCEQDST  402
#define IDS_FFERR_SECSIZE   403
#define IDS_FFERR_DRIVETYPE 404
//#define IDS_FFERR_BADTRACK  405
//#define IDS_FFERR_WRITEBOOT 406
//#define IDS_FFERR_WRITEFAT  407
//#define IDS_FFERR_WRITEROOT 408
#define IDS_FFERR_SYSFILES  409
#define IDS_FFERR_MEDIASENSE    410
#define IDS_FFERR       411

#define IDS_OPENINGMSG          420
#define IDS_CLOSINGMSG          421


#define IDS_COPYERROR       1000
#define IDS_VERBS       1010
#define IDS_ACTIONS     1020
#define IDS_REPLACING       1030
#define IDS_CREATING        1031
#define IDS_REASONS     1040    // error codes strings (range += 255)


#define DE_INVFUNCTION      0x01        // DOS error codes (int21 returns)
#define DE_FILENOTFOUND     0x02
#define DE_PATHNOTFOUND     0x03
#define DE_NOHANDLES        0x04
#define DE_ACCESSDENIED     0x05
#define DE_INVHANDLE        0x06
#define DE_INSMEM           0x08
#define DE_INVFILEACCESS    0x0C
#define DE_DELCURDIR        0x10
#define DE_NOTSAMEDEVICE    0x11
#define DE_NODIRENTRY       0x12

#define DE_WRITEPROTECTED   0x13    // extended error start here
#define DE_ACCESSDENIEDNET  0x41

#define DE_NODISKSPACE      0x70    // our own error codes
#define DE_SAMEFILE     0x71
#define DE_MANYSRC1DEST     0x72
#define DE_DIFFDIR      0x73
#define DE_ROOTDIR      0x74
#define DE_OPCANCELLED      0x75
#define DE_DESTSUBTREE      0x76
#define DE_WINDOWSFILE      0x77
#define DE_ACCESSDENIEDSRC  0x78
#define DE_PATHTODEEP       0x79
#define DE_MANYDEST         0x7A
#define DE_RENAMREPLACE     0x7B
#define DE_HOWDIDTHISHAPPEN 0xFF    // internal error

#define ERRORONDEST     0x80    // indicate error on destination file


#include "wfdlgs.h"

// struct for save and restore of window positions

typedef struct {
    CHAR szDir[MAXPATHLEN];
    RECT rc;
    POINT pt;
    INT sw;
    INT view;
    INT sort;
    INT attribs;
    INT split;
} SAVE_WINDOW, NEAR *PSAVE_WINDOW;


#define SC_SPLIT            100

// Temporary. copied from win31 windows.h and slightly modified.
// We can delete these definitions once USER incorporates these in winuser.h

#define     GlobalAllocPtr(flags, cb)   \
    (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalFreePtr(lp)       \
    (GlobalUnlock(lp), (BOOL)(ULONG_PTR)GlobalFree((lp)))


WORD APIENTRY WFRemove(PSTR pszFile);
WORD APIENTRY WFMove(PSTR pszFrom, PSTR pszTo);

// These errors aren't in shellapi.h as yet. till such time...
/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE      27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

// the LPDROPSTRUCT->dwData will point to this structure

typedef struct {         /* dodata */
    LPSTR pch;           // in win31 this is LOWORD(lpds->dwData)
    HANDLE hMemGlobal;   // in win31 this is HIWORD(lpds->dwData)
} DRAGOBJECTDATA, FAR *LPDRAGOBJECTDATA;


#include "dlg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wperf\calcperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtrp.h

Abstract:

    This module contains NT/Win32 Perfmtr private data and types

Author:

    Mark Enstrom (marke) 28-Mar-1991

Revision History:

--*/

#ifndef _CALCPERFH_INCLUDED_
#define _CALCPERFH_INCLUDED_

#define MAX_PROCESSOR 16
#define DATA_LIST_LENGTH 100
#define DELAY_SECONDS 2

//
// display const
//

#define SAVE_SUBJECTS  (MAX_PROCESSOR+12+3+1)
#define BORDER_WIDTH   2
#define INDENT_WIDTH   8
#define GRAPH_WIDTH    130
#define GRAPH_HEIGHT   40
#define PERF_METER_CPU_CYCLE 10

//
//  time constant for sampling performance
//

#define PERF_TIME_DELAY 1000

//
//  types of display modes
//

#define DISPLAY_MODE_CPU_ONLY   0
#define DISPLAY_MODE_CPU        10
#define DISPLAY_MODE_VM         20
#define DISPLAY_MODE_CACHE      30
#define DISPLAY_MODE_POOL       40
#define DISPLAY_MODE_IO         50
#define DISPLAY_MODE_LPC        60
#define DISPLAY_MODE_SVR        70

//
// structure to save screen statistics
//

typedef struct _CPU_DATA_LIST
{
    PUCHAR   KernelTime;
    PUCHAR   UserTime;
    PUCHAR   TotalTime;
} CPU_DATA_LIST,*PCPU_DATA_LIST;


typedef struct _PERF_DATA_LIST
{
    PULONG  PerfData;
} PERF_DATA_LIST,*PPERF_DATA_LIST;

//
//  This info packet is associated with each
//  performance item
//

typedef struct tagDISPLAYITEM
{
    HDC     MemoryDC;
    HBITMAP MemoryBitmap;
    ULONG   Max;
    ULONG   PositionX;
    ULONG   PositionY;
    ULONG   Width;
    ULONG   Height;
    ULONG   NumberOfElements;
    ULONG   CurrentDrawingPos;
    RECT    Border;
    RECT    GraphBorder;
    RECT    TextBorder;
    BOOL    Display;
    BOOL    ChangeScale;
    ULONG   KernelTime[DATA_LIST_LENGTH];
    ULONG   UserTime[DATA_LIST_LENGTH];
    ULONG   TotalTime[DATA_LIST_LENGTH];
    ULONG   DpcTime[DATA_LIST_LENGTH];
    ULONG   InterruptTime[DATA_LIST_LENGTH];

} DISPLAY_ITEM,*PDISPLAY_ITEM;

//
// flag to activate each menu selection
//

#define DISPLAY_INACTIVE 0
#define DISPLAY_ACTIVE   1


//
//  Keep book-keeping info for all processors
//

typedef struct _CPU_VALUE
{
        LARGE_INTEGER   KernelTime;
        LARGE_INTEGER   UserTime;
        LARGE_INTEGER   IdleTime;
        LARGE_INTEGER   DpcTime;
        LARGE_INTEGER   InterruptTime;
        ULONG           InterruptCount;
} CPU_VALUE,*PCPU_VALUE;



BOOL
UpdatePerfInfo(
   PULONG   DataPointer,
   ULONG    NewDataValue,
   PULONG   OldMaxValue
   );


VOID
InitListData(
   PDISPLAY_ITEM    PerfListItem,
   ULONG            NumberOfItems
   );

#endif /* _CALCPERFH_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wperf\draw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Draw.c

Abstract:

   Win32 application to display performance statictics. This routine implements
   graphics output for display windows.

Author:

   Mark Enstrom  (marke)

Environment:

   Win32

Revision History:

   10-07-92     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <math.h>
#include <errno.h>
#include "Wperf.h"

extern DISPLAY_ITEM    PerfDataList[SAVE_SUBJECTS];
extern WINPERF_INFO    WinperfInfo;
extern PUCHAR          PerfNames[];



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    )

/*++

Routine Description:

    Calculate all parameters to fit the given number of
    windows into the app window. Fill out the data structure
    for each sub-window

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/

{
    RECT    ClientRect;
    int     cx,cy;
    UINT    Index;
    int     ActiveWindows,IndexX,IndexY;
    int     WindowsX,WindowsY,WindowWidth,WindowHeight;
    int     LastRowWidth,LoopWidth;
    double  fWindowsX,fActiveWindows,fcx,fcy;

    //
    //  Find out the client area bounds
    //

    GetClientRect(hWnd,&ClientRect);

    cx = ClientRect.right;
    cy = ClientRect.bottom - 2;   // subtract 2 to give a little more border

    //
    //  Find out how many perf windows are active
    //

    ActiveWindows = 0;

    for (Index=0;Index<NumberOfWindows;Index++) {
        if (DisplayItems[Index].Display == TRUE) {
            ActiveWindows++;
        }
    }

    //
    // Return if there are no active windows to display
    //

    if (ActiveWindows == 0) {
        return(TRUE);
    }


    //
    //  Now convert the window dimensions to floating point and
    //  then take the square root of the window dimension to find
    //  out the number of windows in the x direction
    //

    fActiveWindows = 1.0 * ActiveWindows;

    fcx = 1.0 * cx;
    fcy = 1.0 * cy;

    if (fcy != 0.0) {
        fWindowsX = sqrt((fcx * fActiveWindows) / fcy);
    }   else {

        //
        // If fcy = 0 then return since this is an error condition that
        // would cause a divide by zero.
        //

        return(FALSE);
    }

    //
    // convert back to integer
    //

    WindowsX = (int)fWindowsX;

    if (WindowsX == 0) {
        WindowsX = 1;
    } else if (WindowsX > ActiveWindows) {
        WindowsX = ActiveWindows;
    }

    WindowsY = ActiveWindows / WindowsX;

    //
    //  Add on extra line to Y to take care of the left over windows ie:
    //  if there are 15 active windows and the x number = 7 then y = 2 with 1
    //  left over.
    //

    Index = ActiveWindows - (WindowsX * WindowsY);

    if (Index > 0) {
        WindowsY++;
        LastRowWidth = cx / Index;
    } else {
        LastRowWidth = cx / WindowsX;
    }

    WindowWidth  = cx / WindowsX;
    WindowHeight = cy / WindowsY;

    //
    // Assign positions for each active window
    //

    Index  = 0;

    for (IndexY=0;IndexY<WindowsY;IndexY++) {
        for (IndexX=0;IndexX<WindowsX;IndexX++) {

            //
            // Find the next active display item
            //

            while ((DisplayItems[Index].Display != TRUE) && (Index < NumberOfWindows)) {
                Index++;
            }

            //
            //  Add y fixup for last row
            //

            if (IndexY == WindowsY - 1) {
                LoopWidth = LastRowWidth;
            } else {
                LoopWidth = WindowWidth;
            }


            DisplayItems[Index].PositionX = LoopWidth  * IndexX;
            DisplayItems[Index].PositionY = WindowHeight * IndexY + 1;  // +1 for more top border
            DisplayItems[Index].Width     = LoopWidth - 1;
            DisplayItems[Index].Height    = WindowHeight - 1;

            //
            // Last Column fix-up to use all of window.
            //

            if (IndexX == WindowsX - 1) {
                DisplayItems[Index].Width = cx - DisplayItems[Index].PositionX - 1;
            }

            //
            //
            //

            Index++;

            if (Index >= NumberOfWindows) {
                break;
            }

        }


        if (Index >= NumberOfWindows) {
            break;
        }


    }



    return(TRUE);
}



VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Calculate all borders for graphics windows

Arguments:

    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;
    LONG    GraphHeight,TextHeight;
    BOOLEAN TextWindow;

    double  fx1,fx2,fy1;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->PositionX + 2;
    x2 = DisplayItem->PositionX + DisplayItem->Width - 2;
    y1 = DisplayItem->PositionY + 2;
    y2 = DisplayItem->PositionY + DisplayItem->Height - 2;

    //
    // find out in there is enough space for a text window
    //

    if ((y2 - y1 - 12) > 30) {

        TextWindow = TRUE;

        //
        // Calculate dimensions for a text window and a graphics window
        //
        // fx1 = portion of the window - bordres and free space
        //
        // fx2 = fraction of window used for graphics
        //
        // fy1 = fraction of winddow used for text
        //

        fx1 = (y2 - y1 - 10);

        fx2 = fx1 * 0.6666;
        fy1 = fx1 * 0.3333;

        GraphHeight = (LONG)fx2;
        TextHeight  = (LONG)fy1;

        if (TextHeight > 20) {
            GraphHeight += TextHeight-20;
            TextHeight = 20;
        }

        //
        // Calculate window boundaries
        //

        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y1 + 4 + GraphHeight + 1;

        tx1 = x1 + 4;
        tx2 = x2 - 4;
        ty1 = gy2 + 1 + 2 + 1;  // border,free space,border
        ty2 = gy2 + TextHeight + 1;

    }   else {

        TextWindow = FALSE;
        GraphHeight = y2 - y1 - 10;
        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y2 - 4;
        tx1 = tx2 = ty1 = ty2 = 0;

    }

    //
    // Fill in structures for drawing text and graphics
    //

    DisplayItem->Border.left        = x1;
    DisplayItem->Border.right       = x2;
    DisplayItem->Border.top         = y1;
    DisplayItem->Border.bottom      = y2;

    DisplayItem->GraphBorder.left   = gx1;
    DisplayItem->GraphBorder.right  = gx2;
    DisplayItem->GraphBorder.top    = gy1;
    DisplayItem->GraphBorder.bottom = gy2;

    DisplayItem->TextBorder.left    = tx1;
    DisplayItem->TextBorder.right   = tx2;
    DisplayItem->TextBorder.top     = ty1;
    DisplayItem->TextBorder.bottom  = ty2;
}




VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw the window frame for a performance window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    DrawRect;
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->Border.left;
    x2 = DisplayItem->Border.right;
    y1 = DisplayItem->Border.top;
    y2 = DisplayItem->Border.bottom;

    gx1 = DisplayItem->GraphBorder.left;
    gx2 = DisplayItem->GraphBorder.right;
    gy1 = DisplayItem->GraphBorder.top;
    gy2 = DisplayItem->GraphBorder.bottom;

    tx1 = DisplayItem->TextBorder.left;
    tx2 = DisplayItem->TextBorder.right;
    ty1 = DisplayItem->TextBorder.top;
    ty2 = DisplayItem->TextBorder.bottom;

    //
    // Draw top border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y1 + 2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // Draw Left border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x1 + 2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // Draw right border in dark shade
    //


    DrawRect.left   = x2 - 2;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // draw bottom in dark shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y2-2;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw graphics area single border
    //

    //
    // Draw top border in dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy1+1;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw Left border in Dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx1 + 1;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw right border in Light shade
    //


    DrawRect.left   = gx2 - 1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // draw bottom in Light shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy2-1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    if (tx2 > 0) {

        //
        // Draw top border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty1 + 1;

        FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

        //
        // Draw Left border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx1 + 1;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

        //
        // Draw right border in Light shade
        //


        DrawRect.left   = tx2 - 1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

        //
        // draw bottom in Light shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty2-1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    }
}




VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    )
/*++

Routine Description:

    Draw text into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    TextRect;
    UCHAR   TextStr[50];
    UINT    FontSize;

    //
    // Check that text display is enabled
    //

    if (DisplayItem->TextBorder.right == 0) {
        return;
    }

    TextRect.left = DisplayItem->TextBorder.left +1;
    TextRect.right = DisplayItem->TextBorder.right -1;
    TextRect.top = DisplayItem->TextBorder.top +1;
    TextRect.bottom = DisplayItem->TextBorder.bottom -1;

    FillRect(hDC,&TextRect,WinperfInfo.hBackground);

    SetBkColor(hDC,RGB(192,192,192));

    //
    //  Decide which font to draw with
    //

    FontSize =  TextRect.bottom - TextRect.top;

    if (FontSize >= 15) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.LargeFont);
    } else if (FontSize > 10) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.MediumFont);
    } else {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.SmallFont);
    }

    DrawText(
                hDC,
                PerfNames[Item],
                strlen(PerfNames[Item]),
                &TextRect,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE
             );


    //
    // Build the numeric value
    //

    wsprintf(TextStr,"   %li",DisplayItem->TotalTime[0]);

    DrawText(
                hDC,
                TextStr,
                strlen(TextStr),
                &TextRect,
                DT_RIGHT | DT_VCENTER | DT_SINGLELINE
             );




    SelectObject(hDC,WinperfInfo.hOldFont);

}





VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw graphics into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect;
    ULONG   Scale,i,GraphWidth,GraphHeight;



    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth +1;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&MemGraphRect,WinperfInfo.hBackground);

    MemGraphRect.right  = GraphWidth;
    MemGraphRect.bottom = GraphHeight;

    if (DisplayItem->Max == 0) {
        DisplayItem->Max = 1;
    }

    //
    // calculate scale from data to perf window
    //

    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }


    //
    //  Draw UserTime if needed
    //

    if (DisplayItem->NumberOfElements>1) {

        //
        // Select kernel pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hRedPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->KernelTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




        for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
                    MemGraphRect.right - Scale * i,
                    MemGraphRect.bottom - (DisplayItem->KernelTime[i] * GraphHeight)/DisplayItem->Max
               );

        }

        //
        // Select User Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hGreenPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);

        for (i=1;((i<DATA_LIST_LENGTH) && i * Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->UserTime[i] * GraphHeight)/DisplayItem->Max);

        }

        //
        // Select DPC Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hYellowPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);

        for (i=1;((i<DATA_LIST_LENGTH) && i * Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->DpcTime[i] * GraphHeight)/DisplayItem->Max);

        }
        //
        // Select Interrupt Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hMagentaPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->InterruptTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);

        for (i=1;((i<DATA_LIST_LENGTH) && i * Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->InterruptTime[i] * GraphHeight)/DisplayItem->Max);

        }
    }

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBluePen);
    MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->TotalTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




    for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
        LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->TotalTime[i] * GraphHeight)/DisplayItem->Max);

    }



    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);


}

VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Shift memory bitmap 1 location left then draw the 1 new data point.
    BitBlt this to the screen.


Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect,FillArea;
    ULONG   Scale,GraphWidth,GraphHeight;



    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight;

    if (DisplayItem->Max == 0) {
        DisplayItem->Max = 1;
    }

    //
    // calculate scale from data to perf window
    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }

    //
    // Shift memory image left by scale
    //


    BitBlt( DisplayItem->MemoryDC,
            0,
            0,
            GraphWidth+1 - Scale,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            Scale,
            0,
            SRCCOPY);


    //
    // Fill The new area on the right of the screen
    //

    FillArea.left   = GraphWidth +1 - Scale;
    FillArea.right  = GraphWidth +1;
    FillArea.top    = 0;
    FillArea.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&FillArea,WinperfInfo.hBackground);


    //
    // Draw the 1 new data point
    //


    //
    //  Draw UserTime if needed
    //

    if (DisplayItem->NumberOfElements>1) {

        //
        // Select kernel pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hRedPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->KernelTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->KernelTime[1] * GraphHeight)/DisplayItem->Max
              );

        //
        // Select User Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hGreenPen);

        MoveToEx(
                    DisplayItem->MemoryDC,
                    MemGraphRect.right,
                    MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
                    (LPPOINT)NULL
                 );

        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->UserTime[1] * GraphHeight)/DisplayItem->Max
              );

        //
        // Select DPC Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hYellowPen);

        MoveToEx(
                    DisplayItem->MemoryDC,
                    MemGraphRect.right,
                    MemGraphRect.bottom - (DisplayItem->DpcTime[0] * GraphHeight)/ DisplayItem->Max,
                    (LPPOINT)NULL
                 );

        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->DpcTime[1] * GraphHeight)/DisplayItem->Max
              );

        //
        // Select Interrupt Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hMagentaPen);

        MoveToEx(
                    DisplayItem->MemoryDC,
                    MemGraphRect.right,
                    MemGraphRect.bottom - (DisplayItem->InterruptTime[0] * GraphHeight)/ DisplayItem->Max,
                    (LPPOINT)NULL
                 );

        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->InterruptTime[1] * GraphHeight)/DisplayItem->Max
              );

    }

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBluePen);

    MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->TotalTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




    LineTo(DisplayItem->MemoryDC,
            MemGraphRect.right - Scale,
            MemGraphRect.bottom - (DisplayItem->TotalTime[1] * GraphHeight)/DisplayItem->Max);



    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);


}



BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Create a memory context and a memory bitmap for each perf window



Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    int     Width;
    int     Height;

    if (DisplayItem->Display == TRUE) {

        //
        //  Calculate width of memory bitmap needed
        //

        Width  = DisplayItem->GraphBorder.right - DisplayItem->GraphBorder.left;
        Height = DisplayItem->GraphBorder.bottom - DisplayItem->GraphBorder.top;

        if ((Width<=0) || (Height <= 0)) {

            //
            // Disable this window that is to small to be seen
            //

            //DisplayItem->Display = FALSE;

            //return(TRUE);

            //
            // make a fake width and height
            //

            Width  = 1;
            Height = 1;
        }

        //
        //  Create DC and Bitmap
        //

        DisplayItem->MemoryDC     = CreateCompatibleDC(hDC);

        if (DisplayItem->MemoryDC == NULL) {
            return(FALSE);
        }


        DisplayItem->MemoryBitmap = CreateCompatibleBitmap(hDC,Width,Height);

        if (DisplayItem->MemoryBitmap == 0) {
            return(FALSE);
        }

        SelectObject(DisplayItem->MemoryDC,DisplayItem->MemoryBitmap);

    }

    return(TRUE);
}



VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Delete memory bitmap and context

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    if (DisplayItem->MemoryDC != NULL) {
        DeleteDC(DisplayItem->MemoryDC);
    }

    if (DisplayItem->MemoryBitmap != NULL) {
        DeleteObject(DisplayItem->MemoryBitmap);
    }

}








#define	BOX_DEPTH	3

VOID
DrawCpuBarGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item

    )
/*++

Routine Description:

    Draw a 3-d like CPU bar graph into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,DrawRect;
    ULONG   i,GraphWidth,GraphHeight,CpuGraphHeight;
    ULONG   BarWidth,BarHeight,tHeight,kHeight,uHeight,dHeight,iHeight;
    POINT   PolyPoint[4];
    HPEN    hOldPen;
    UINT    FontSize;
    UCHAR   TextStr[100];
    ULONG   nItems,UserBase, KerBase, DPCbase, TotBase, IntBase;


    nItems = 5;

    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left;
    GraphHeight = GraphRect.bottom - GraphRect.top;


    BarWidth   = GraphWidth/((nItems*4)+4);
    BarHeight  = GraphHeight/((nItems*4)+4);

    CpuGraphHeight = GraphHeight - 2 * BarHeight;

    //
    // Jump Out if window is too small
    //

    if (BarWidth == 0) {
        return;
    }

    //
    // Calculate Heights
    //

    uHeight = (DisplayItem->UserTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    UserBase = 2;
    kHeight = (DisplayItem->KernelTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    KerBase = 6;
    dHeight = (DisplayItem->DpcTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    DPCbase = 10;
    iHeight = (DisplayItem->InterruptTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    IntBase = 14;
    tHeight = (DisplayItem->TotalTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    TotBase = 18;

    DrawRect.left   = 0;
    DrawRect.right  = GraphWidth;
    DrawRect.top    = 0;
    DrawRect.bottom = GraphHeight;

    FillRect(DisplayItem->MemoryDC,&DrawRect,WinperfInfo.hBackground);
    SelectObject(DisplayItem->MemoryDC,GetStockObject(GRAY_BRUSH));

    //
    // Draw Background, face 1 (left side)
    //

    PolyPoint[0].x = DrawRect.left + BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight/2);

    PolyPoint[1].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[1].y = DrawRect.bottom    - (BOX_DEPTH*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[2].y = DrawRect.bottom    - (GraphHeight - BarHeight/2);

    PolyPoint[3].x = DrawRect.left + BarWidth;
    PolyPoint[3].y = DrawRect.bottom    - (GraphHeight - BOX_DEPTH*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Background, face 2 (bottom)
    //

    PolyPoint[0].x = DrawRect.left + BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight/2);

    //  Left line
    PolyPoint[1].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[1].y = DrawRect.bottom    - (BOX_DEPTH*BarHeight/2);

    //  Back line
    PolyPoint[2].x = DrawRect.left + (nItems*4+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom    - (BOX_DEPTH*BarHeight/2);

    //	Bottom line.
    PolyPoint[3].x = DrawRect.left + (nItems*4)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom    - (BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Background, face 3 (Back Side)
    //

    PolyPoint[0].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BOX_DEPTH*BarHeight/2);

    PolyPoint[1].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (GraphHeight - BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (nItems*4+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom    - (GraphHeight - BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (nItems*4+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom    - ((BOX_DEPTH*BarHeight)/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Scale Lines if the window height is large ( > 200)
    //


    if ((DrawRect.bottom - DrawRect.top) > 200) {

        hOldPen = SelectObject(DisplayItem->MemoryDC,WinperfInfo.hDotPen);
        SetBkMode(DisplayItem->MemoryDC,TRANSPARENT);

	//
	//	Back
	//

	for (i=1;i<10;i++) {
            MoveToEx(DisplayItem->MemoryDC,
                     BOX_DEPTH*BarWidth,
                     DrawRect.bottom  - (BOX_DEPTH*BarHeight/2 + (i*CpuGraphHeight/10)),
                     NULL
                    );

            LineTo(DisplayItem->MemoryDC,
                     (nItems*4+2)*BarWidth,
                     DrawRect.bottom  - (BOX_DEPTH*BarHeight/2 + (i*CpuGraphHeight/10))
                );
        }

	//
	//	Left Side
	//

	for (i=1;i<10;i++) {
            MoveToEx(DisplayItem->MemoryDC,
                     BarWidth,
                     DrawRect.bottom  - (BarHeight/2 + (i*CpuGraphHeight/10)),
                     NULL
                    );

            LineTo(DisplayItem->MemoryDC,
                     BOX_DEPTH*BarWidth,
                     DrawRect.bottom  - (BOX_DEPTH*BarHeight/2 + (i*CpuGraphHeight/10))
                  );
        }


        SelectObject(DisplayItem->MemoryDC,hOldPen);
    }

    //
    //  Draw CPU User time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hGreenBrush);

    PolyPoint[0].x = DrawRect.left + (UserBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (uHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (UserBase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (uHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw User Box Side
    //

    PolyPoint[0].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (UserBase+BOX_DEPTH)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (UserBase+BOX_DEPTH)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 + uHeight);

    PolyPoint[3].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (BarHeight + uHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw User Box Top
    //

    PolyPoint[0].x = DrawRect.left + (UserBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (uHeight +  BarHeight);

    PolyPoint[1].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (uHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (UserBase+BOX_DEPTH)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (uHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (UserBase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (uHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    //  Draw CPU Kernel time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hRedBrush);

    PolyPoint[0].x = DrawRect.left + (KerBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - ( kHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (KerBase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (kHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Kernel Box Side
    //

    PolyPoint[0].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (KerBase+3)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (KerBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 +kHeight);

    PolyPoint[3].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (kHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Kernel Box Top
    //

    PolyPoint[0].x = DrawRect.left + (KerBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (kHeight + BarHeight);

    PolyPoint[1].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (kHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (KerBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (kHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (KerBase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (kHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    //  Draw CPU DPC time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hYellowBrush);

    PolyPoint[0].x = DrawRect.left + (DPCbase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - ( dHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (DPCbase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (dHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw DPC Box Side
    //

    PolyPoint[0].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (DPCbase+3)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (DPCbase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 +dHeight);

    PolyPoint[3].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (dHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw DPC Box Top
    //

    PolyPoint[0].x = DrawRect.left + (DPCbase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (dHeight + BarHeight);

    PolyPoint[1].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (dHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (DPCbase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (dHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (DPCbase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (dHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    //  Draw CPU Interrupt time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hMagentaBrush);

    PolyPoint[0].x = DrawRect.left + (IntBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - ( iHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (IntBase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (iHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Interrupt Box Side
    //

    PolyPoint[0].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (IntBase+3)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (IntBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 +iHeight);

    PolyPoint[3].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (iHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Interrupt Box Top
    //

    PolyPoint[0].x = DrawRect.left + (IntBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (iHeight + BarHeight);

    PolyPoint[1].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (iHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (IntBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (iHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (IntBase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (iHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    //  Draw CPU Total time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBlueBrush);

    PolyPoint[0].x = DrawRect.left + (TotBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - ( tHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (TotBase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (tHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw CPU Total Box Side
    //

    PolyPoint[0].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (TotBase+3)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (TotBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 + tHeight);

    PolyPoint[3].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (tHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Kernel Box Top
    //

    PolyPoint[0].x = DrawRect.left + (TotBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (tHeight + BarHeight);

    PolyPoint[1].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (tHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (TotBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (tHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (TotBase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (tHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Update screen with memory image
    //

    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth,
            GraphHeight,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);

    //
    // Draw Text output for CPU bar-graph window
    //


    DrawRect.left = DisplayItem->TextBorder.left +2;
    DrawRect.right = DisplayItem->TextBorder.right -2;
    DrawRect.top = DisplayItem->TextBorder.top +1;
    DrawRect.bottom = DisplayItem->TextBorder.bottom -1;

    FillRect(hDC,&DrawRect,WinperfInfo.hBackground);

    SetBkColor(hDC,RGB(192,192,192));

    //
    //  Decide which font to draw with
    //

    FontSize =  DrawRect.bottom - DrawRect.top;

    if (FontSize >= 15) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.LargeFont);
    } else if (FontSize > 10) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.MediumFont);
    } else {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.SmallFont);

    }

    strcpy(TextStr,PerfNames[Item]);

    if ((DrawRect.right - DrawRect.left) > 120) {
        strcat(TextStr," User,Kernel,Dpc,Int,Total");
    } else {
        strcat(TextStr," U K D I T");
    }

    DrawText(
                hDC,
                TextStr,
                strlen(TextStr),
                &DrawRect,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE
             );



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wperf\calcperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   CalcPerf.c

Abstract:

   calculate perfoemance statistics

Author:



Environment:

   Win32

Revision History:

   10-20-91     Initial version



--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include "calcperf.h"

SYSTEM_EXCEPTION_INFORMATION                ExceptionInfo;
SYSTEM_EXCEPTION_INFORMATION                PreviousExceptionInfo;
SYSTEM_PERFORMANCE_INFORMATION              PerfInfo;
SYSTEM_PERFORMANCE_INFORMATION              PreviousPerfInfo;
POBJECT_TYPE_INFORMATION                    ObjectInfo;
WCHAR                                       Buffer[ 256 ];
STRING                                      DeviceName;
UNICODE_STRING                              DeviceNameU;
OBJECT_ATTRIBUTES                           ObjectAttributes;
NTSTATUS                                    Status;

CCHAR                                       NumberOfProcessors;
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfo[MAX_PROCESSOR];

CPU_VALUE                                   PreviousCpuData[MAX_PROCESSOR];

//
//  make the maximum for pages available a "grow only" max. (since the
//  amount of memory in a machine is limited. Set to 1 Mbytes here.
//

ULONG                                       PgAvailMax = 16384;
ULONG                                       PreviousInterruptCount;
ULONG                                       InterruptCount;


ULONG
InitPerfInfo(
    VOID
    )

/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

   None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-21-91      Initial code

--*/

{

    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    NtQuerySystemInformation(
       SystemExceptionInformation,
       &ExceptionInfo,
       sizeof(ExceptionInfo),
       NULL
    );

    PreviousExceptionInfo = ExceptionInfo;

    NtQuerySystemInformation(
       SystemPerformanceInformation,
       &PerfInfo,
       sizeof(PerfInfo),
       NULL
    );

    PreviousPerfInfo = PerfInfo;

    NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSOR) {
        return(0);
    }

    NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
       NULL
    );

    PPerfInfo = ProcessorInfo;

    PreviousInterruptCount = 0;

    for (i=0; i < NumberOfProcessors; i++) {

        PreviousInterruptCount           += PPerfInfo->InterruptCount;
        PreviousCpuData[i].KernelTime     = PPerfInfo->KernelTime;
        PreviousCpuData[i].UserTime       = PPerfInfo->UserTime;
        PreviousCpuData[i].IdleTime       = PPerfInfo->IdleTime;
        PreviousCpuData[i].DpcTime        = PPerfInfo->DpcTime;
        PreviousCpuData[i].InterruptTime  = PPerfInfo->InterruptTime;
	PreviousCpuData[i].InterruptCount = PPerfInfo->InterruptCount;

        PPerfInfo++;
    }

    return(NumberOfProcessors);
}

BOOL
CalcCpuTime(
   PDISPLAY_ITEM PerfListItem
   )

/*++

Routine Description:

   calculate and return %cpu time and time periods

Arguments:

   None

Return Value:


Revision History:

      10-21-91      Initial code

--*/

{

    LARGE_INTEGER   CurrentTime;
    LARGE_INTEGER   PreviousTime;
    LARGE_INTEGER   ElapsedTime;
    LARGE_INTEGER   ElapsedSystemTime;
    LARGE_INTEGER   PercentTime;
    LARGE_INTEGER   DeltaKernelTime,DeltaUserTime,DeltaIdleTime;
    LARGE_INTEGER   DeltaInterruptTime,DeltaDpcTime;
    LARGE_INTEGER   TotalElapsedTime;
    LARGE_INTEGER   TotalKernelTime;
    LARGE_INTEGER   TotalUserTime;
    LARGE_INTEGER   TotalIdleTime;
    LARGE_INTEGER   TotalDpcTime;
    LARGE_INTEGER   TotalInterruptTime;
    ULONG           ProcessCount, ThreadCount;
    ULONG           ListIndex;
    ULONG           Total;

//    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;

    //
    //   get system performance info
    //

    NtQuerySystemInformation(
       SystemExceptionInformation,
       &ExceptionInfo,
       sizeof(ExceptionInfo),
       NULL
    );

    NtQuerySystemInformation(
       SystemPerformanceInformation,
       &PerfInfo,
       sizeof(PerfInfo),
       NULL
    );

    NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
       NULL
    );

    ObjectInfo = (POBJECT_TYPE_INFORMATION)Buffer;
    NtQueryObject( NtCurrentProcess(),
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );

    ProcessCount = ObjectInfo->TotalNumberOfObjects;

    NtQueryObject( NtCurrentThread(),
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );

    ThreadCount = ObjectInfo->TotalNumberOfObjects;

    //
    //  calculate Kernel,User,Total times for each CPU.
    //  SUM the interrupt count accross all CPUs
    //

    InterruptCount = 0;

    TotalElapsedTime.QuadPart = 0;
    TotalKernelTime  = TotalElapsedTime;
    TotalUserTime    = TotalElapsedTime;
    TotalIdleTime    = TotalElapsedTime;
    TotalInterruptTime = TotalElapsedTime;
    TotalDpcTime     = TotalElapsedTime;

    for (ListIndex=0;ListIndex<MAX_PROCESSOR;ListIndex++) {

        //
        //  Increment the interrupt count for each processor
        //

        InterruptCount += ProcessorInfo[ListIndex].InterruptCount;

        //
        //  Calculate the % kernel,user,total for each CPU.
	//
	//  Note that DPC and Interrupt time are charged against kernel time
	//  already.
        //

        PreviousTime.QuadPart = PreviousCpuData[ListIndex].KernelTime.QuadPart+
                        PreviousCpuData[ListIndex].UserTime.QuadPart;


        CurrentTime.QuadPart  = ProcessorInfo[ListIndex].KernelTime.QuadPart+
                        ProcessorInfo[ListIndex].UserTime.QuadPart;

        ElapsedSystemTime.QuadPart = CurrentTime.QuadPart - PreviousTime.QuadPart;

        //
        //  UserTime =      (User) *100
        //              ----------------
        //               Kernel + User
        //
        //
        //                        Idle *100
        //  TotalTime = 100 -  --------------
        //                      Kernel + User
        //
        //
        //
        //                   (Kernel - Idle - DPC - Interrupt)*100
        //  KernelTime =     -------------------
        //                     Kernel + User
        //

        DeltaUserTime.QuadPart = ProcessorInfo[ListIndex].UserTime.QuadPart -
                        PreviousCpuData[ListIndex].UserTime.QuadPart;

        DeltaIdleTime.QuadPart = ProcessorInfo[ListIndex].IdleTime.QuadPart -
                        PreviousCpuData[ListIndex].IdleTime.QuadPart;

        DeltaDpcTime.QuadPart = ProcessorInfo[ListIndex].DpcTime.QuadPart -
                        PreviousCpuData[ListIndex].DpcTime.QuadPart;

	DeltaInterruptTime.QuadPart = ProcessorInfo[ListIndex].InterruptTime.QuadPart -
                        PreviousCpuData[ListIndex].InterruptTime.QuadPart;

        DeltaKernelTime.QuadPart = ProcessorInfo[ListIndex].KernelTime.QuadPart -
                        PreviousCpuData[ListIndex].KernelTime.QuadPart;

        DeltaKernelTime.QuadPart = DeltaKernelTime.QuadPart -
                        DeltaIdleTime.QuadPart -
			DeltaDpcTime.QuadPart -
			DeltaInterruptTime.QuadPart;

        //
        // accumulate per CPU information for the Total CPU field
        //

        TotalElapsedTime.QuadPart += ElapsedSystemTime.QuadPart;
        TotalIdleTime.QuadPart += DeltaIdleTime.QuadPart;
        TotalUserTime.QuadPart += DeltaUserTime.QuadPart;
        TotalKernelTime.QuadPart += DeltaKernelTime.QuadPart;
        TotalDpcTime.QuadPart += DeltaDpcTime.QuadPart;
        TotalInterruptTime.QuadPart += DeltaInterruptTime.QuadPart;

	//
        //  Update old time value entries
        //

        PreviousCpuData[ListIndex].UserTime     = ProcessorInfo[ListIndex].UserTime;
        PreviousCpuData[ListIndex].KernelTime   = ProcessorInfo[ListIndex].KernelTime;
        PreviousCpuData[ListIndex].IdleTime     = ProcessorInfo[ListIndex].IdleTime;
        PreviousCpuData[ListIndex].DpcTime      = ProcessorInfo[ListIndex].DpcTime;
        PreviousCpuData[ListIndex].InterruptTime= ProcessorInfo[ListIndex].InterruptTime;

        //
        // If the elapsed system time is not zero, then compute the percentage
        // of time spent in user, kernel, DPC, and interupt mode. Otherwise, default the time
        // to zero.
        //

        if (ElapsedSystemTime.QuadPart != 0) {

            //
            //  Calculate User Time %
            //

            ElapsedTime.QuadPart = DeltaUserTime.QuadPart * 100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save User Time
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].UserTime[0],PercentTime.LowPart,NULL);

            //
            //  Calculate Total Cpu time
            //

            ElapsedTime.QuadPart = DeltaIdleTime.QuadPart*100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save Total Time
            //

            Total = 100 - PercentTime.LowPart;
            if (Total > 100) {
                Total  = 100;
            }

            UpdatePerfInfo(&PerfListItem[ListIndex].TotalTime[0],Total,NULL);

            //
            //  Calculate Kernel Time %
            //

            ElapsedTime.QuadPart = DeltaKernelTime.QuadPart * 100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save Kernel Time
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].KernelTime[0],PercentTime.LowPart,NULL);

            //
            //  Calculate DPC Time %
            //

            ElapsedTime.QuadPart = DeltaDpcTime.QuadPart * 100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save DPC Time
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].DpcTime[0],PercentTime.LowPart,NULL);

	    //
            //  Calculate Interrupt Time %
            //

            ElapsedTime.QuadPart = DeltaInterruptTime.QuadPart * 100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save DPC Time
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].InterruptTime[0],PercentTime.LowPart,NULL);

        } else {

            //
            // Set percentage of user and kernel time to zero.
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].UserTime[0],0,NULL);
            UpdatePerfInfo(&PerfListItem[ListIndex].TotalTime[0],100,NULL);
            UpdatePerfInfo(&PerfListItem[ListIndex].KernelTime[0],0,NULL);
            UpdatePerfInfo(&PerfListItem[ListIndex].DpcTime[0],0,NULL);
            UpdatePerfInfo(&PerfListItem[ListIndex].InterruptTime[0],0,NULL);
        }
    }

    //
    //  save pagefaults and update next entry
    //

    PerfListItem[ListIndex].ChangeScale  = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    PerfInfo.PageFaultCount - PreviousPerfInfo.PageFaultCount,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save pages available
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    PerfInfo.AvailablePages,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save context switch count per interval
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (PerfInfo.ContextSwitches - PreviousPerfInfo.ContextSwitches)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save first level TB fills per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (PerfInfo.FirstLevelTbFills - PreviousPerfInfo.FirstLevelTbFills)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save second level tb fills per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (PerfInfo.SecondLevelTbFills - PreviousPerfInfo.SecondLevelTbFills)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save system calls per time interval
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (PerfInfo.SystemCalls - PreviousPerfInfo.SystemCalls)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;


    //
    //  save interrupt count per interval
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (InterruptCount - PreviousInterruptCount)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save paged pool pages
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    PerfInfo.PagedPoolPages,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save non-paged pool pages
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    PerfInfo.NonPagedPoolPages,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save Process count
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    ProcessCount,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save ThreadCount
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    ThreadCount,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save alignment fixup count per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (ExceptionInfo.AlignmentFixupCount -
                        PreviousExceptionInfo.AlignmentFixupCount),
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save exception dispatch count per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (ExceptionInfo.ExceptionDispatchCount -
                        PreviousExceptionInfo.ExceptionDispatchCount),
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save floating emulation count per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (ExceptionInfo.FloatingEmulationCount -
                        PreviousExceptionInfo.FloatingEmulationCount),
                    &PerfListItem[ListIndex].Max);

    ListIndex++;

    //
    //  save byte/word emulation count per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (ExceptionInfo.ByteWordEmulationCount -
                        PreviousExceptionInfo.ByteWordEmulationCount),
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    // If the elapsed system time is not zero, then compute the percentage
    // of time spent in user and kdrnel mode. Otherwise, default the time
    // to zero.
    //

    if (TotalElapsedTime.QuadPart != 0) {

        //
        //  Calculate and save total CPU value
        //

        ElapsedTime.QuadPart = TotalUserTime.QuadPart * 100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;
        UpdatePerfInfo(&PerfListItem[ListIndex].UserTime[0],PercentTime.LowPart,NULL);

        ElapsedTime.QuadPart = TotalKernelTime.QuadPart * 100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;
        UpdatePerfInfo(&PerfListItem[ListIndex].KernelTime[0],PercentTime.LowPart,NULL);

        ElapsedTime.QuadPart = TotalIdleTime.QuadPart *100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;

        //
        //  Save Total Time
        //

        Total = 100 - PercentTime.LowPart;
        if (Total > 100) {
            Total  = 100;
        }

        UpdatePerfInfo(&PerfListItem[ListIndex].TotalTime[0],Total,NULL);

        ElapsedTime.QuadPart = TotalDpcTime.QuadPart *100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;
        UpdatePerfInfo(&PerfListItem[ListIndex].DpcTime[0],PercentTime.LowPart,NULL);

        ElapsedTime.QuadPart = TotalInterruptTime.QuadPart *100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;
        UpdatePerfInfo(&PerfListItem[ListIndex].InterruptTime[0],PercentTime.LowPart,NULL);

    } else {

        //
        // Set percentage of user and kernel time to zero.
        //

        UpdatePerfInfo(&PerfListItem[ListIndex].UserTime[0],0,NULL);
        UpdatePerfInfo(&PerfListItem[ListIndex].KernelTime[0],0,NULL);
        UpdatePerfInfo(&PerfListItem[ListIndex].DpcTime[0],0,NULL);
        UpdatePerfInfo(&PerfListItem[ListIndex].InterruptTime[0],0,NULL);
        UpdatePerfInfo(&PerfListItem[ListIndex].TotalTime[0],100,NULL);
    }

    //
    // done with setting values, save settings and return
    //

    PreviousExceptionInfo = ExceptionInfo;
    PreviousPerfInfo = PerfInfo;
    PreviousInterruptCount = InterruptCount;
    return(TRUE);
}


BOOL
UpdatePerfInfo(
   PULONG    DataPointer,
   ULONG     NewDataValue,
   PULONG    OldMaxValue
   )

/*++

Routine Description:

    Shift array of DATA_LIST_LENGTH USORTS and add the new value to the
    start of list

Arguments:

    DataPointer  - Pointer to the start of a DATA_LIST_LENGTH array
    NewDataValue - Data element to be added
    OldMaxValue  - Scale value

Return Value:

    TRUE is MaxValue must be increased or decreased

Revision History:

      10-21-91      Initial code

--*/

{

    ULONG   Index;
    ULONG   ScanMax;

    //
    //  Shift DataArray while keeping track of the max value
    //
    //  Set temp max to 100 to init a minimum maximum
    //

    ScanMax = 100;
    for (Index=DATA_LIST_LENGTH-1;Index>=1;Index--) {
        DataPointer[Index] = DataPointer[Index-1];
        if (DataPointer[Index] > ScanMax) {
            ScanMax = DataPointer[Index];
        }
    }

    //
    // add and check first value
    //

    DataPointer[0] = NewDataValue;
    if (NewDataValue > ScanMax) {
        ScanMax = NewDataValue;
    }

    //
    //  If OldMaxValue = NULL then do not do a max limit check
    //

    if (OldMaxValue == NULL) {
        return(FALSE);
    }

    //
    //  If Max values changed then undate the new max
    //  value and return TRUE.
    //

    if (ScanMax != *OldMaxValue) {
        *OldMaxValue = ScanMax;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wperf\wperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winperf.h

Abstract:

   This module contains the definit

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#ifndef _WINPERFH_INCLUDED_
#define _WINPERFH_INCLUDED_

#define DIALOG_SUCCESS  100
#define DIALOG_CANCEL   0

#define IDM_EXIT        1100
#define IDM_SELECT      1101
#define IDM_ALL         1103
#define TIMER_ID        1001
#define IDM_CPU_GRP     1002
#define IDM_PERF_GRP    1003
#define IDM_SEL_DLG     1004
#define IDM_STYLE_GRP   1005


#define IDM_CPU0        101
#define IDM_CPU1        102
#define IDM_CPU2        103
#define IDM_CPU3        104
#define IDM_CPU4        105
#define IDM_CPU5        106
#define IDM_CPU6        107
#define IDM_CPU7        108
#define IDM_CPU8        109
#define IDM_CPU9        110
#define IDM_CPU10       111
#define IDM_CPU11       112
#define IDM_CPU12       113
#define IDM_CPU13       114
#define IDM_CPU14       115
#define IDM_CPU15       116
#define IDM_PGFLT       117
#define IDM_PGAV        118
#define IDM_CONTEXT     119
#define IDM_1TB         120
#define IDM_2TB         121
#define IDM_SYSCALL     122
#define IDM_INT         123
#define IDM_POOL        124
#define IDM_NONPOOL     125
#define IDM_PROCESS     126
#define IDM_THREAD      127
#define IDM_ALIGN       128
#define IDM_EXCEPT      129
#define IDM_FLOAT       130
#define IDM_INS_EMUL    131
#define IDM_CPU_TOTAL   132
#define IDM_SEL_LINE    133
#define IDM_SEL_BAR     134


#define WINPERF_ICON 1011
#define CPUTHERM_ICON 1012
#define BALL_BITMAP 1011

#define CPU_STYLE_LINE 0
#define CPU_STYLE_BAR 1


#include "calcperf.h"


typedef struct _WINPERF_INFO
{
    DWORD   WindowPositionX;
    DWORD   WindowPositionY;
    DWORD   WindowSizeX;
    DWORD   WindowSizeY;
    DWORD   DisplayElement[SAVE_SUBJECTS];
    DWORD   DisplayMode;
    DWORD   CpuStyle;
    HPEN    hBluePen;
    HPEN    hRedPen;
    HPEN    hGreenPen;
    HPEN    hMagentaPen;
    HPEN    hYellowPen;
    HPEN    hDotPen;
    HBRUSH  hBackground;
    HBRUSH  hRedBrush;
    HBRUSH  hGreenBrush;
    HBRUSH  hBlueBrush;
    HBRUSH  hMagentaBrush;
    HBRUSH  hYellowBrush;
    HBRUSH  hLightBrush;
    HBRUSH  hDarkBrush;
    HFONT   LargeFont;
    HFONT   MediumFont;
    HFONT   SmallFont;
    HFONT   hOldFont;
    HMENU   hMenu;
    HWND    hWndMain;
    UINT_PTR TimerId;
    UINT    NumberOfProcessors;
    BOOL    DisplayMenu;
} WINPERF_INFO,*PWINPERF_INFO;






BOOL
InitApplication(
   HANDLE hInstance,
   HBRUSH hBackground
   );


BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    );



LRESULT APIENTRY
MainWndProc(
   HWND  hWnd,
   UINT  message,
   WPARAM wParam,
   LPARAM lParam
   );



LRESULT APIENTRY
CpuWndProc(
   HWND  hWnd,
   UINT  message,
   WPARAM wParam,
   LPARAM lParam
   );


BOOL
APIENTRY About(
   HWND     hDlg,
   UINT     message,
   WPARAM   wParam,
   LPARAM   lParam
   );




BOOL    APIENTRY MoveToEx(IN HDC, IN int, IN int, OUT LPPOINT);
BOOL    APIENTRY SetViewportExtEx(IN HDC, IN int, IN int, OUT LPSIZE);
BOOL    APIENTRY SetViewportOrgEx(IN HDC, IN int, IN int, OUT LPPOINT);
BOOL    APIENTRY SetWindowExtEx(IN HDC, IN int, IN int, OUT LPSIZE);
BOOL    APIENTRY SetWindowOrgEx(IN HDC, IN int, IN int, OUT LPPOINT);
BOOL    APIENTRY GetWindowExtEx(IN HDC, OUT LPSIZE);
BOOL    APIENTRY GetCurrentPositionEx(IN HDC, OUT LPPOINT);
BOOL    APIENTRY MGetWindowExt(HDC hdc, INT * pcx, INT * pcy);
BOOL    APIENTRY MGetCurrentPosition(HDC hdc, INT * px, INT * py);
HANDLE  APIENTRY MGetInstHandle(VOID);

LPSTR   MGetCmdLine(VOID);


VOID
UpdateCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient
   );

VOID
DrawCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient,
   IN   ULONG DisplayItem
   );

VOID
ReScalePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

BOOL
CalcCpuTime(
   PDISPLAY_ITEM    PerfListItem
   );

ULONG
InitPerfInfo(VOID);


VOID
InitProfileData(PWINPERF_INFO pWinperfInfo);







VOID
SaveProfileData(PWINPERF_INFO pWinperfInfo);

VOID
DrawPerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );


VOID
UpdatePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

//
//  change style constants
//

#define STYLE_ENABLE_MENU  WS_OVERLAPPEDWINDOW
#define STYLE_DISABLE_MENU (WS_THICKFRAME+WS_BORDER)


LRESULT APIENTRY
DbgWndProc(
   HWND   hWnd,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );


BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );



INT_PTR
APIENTRY SelectDlgProc(
   HWND hDlg,
   UINT  message,
   WPARAM wParam,
   LPARAM lParam
   );

VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    );

VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );


BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    );


VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawCpuBarGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    );

#endif /* _WINPERFH_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wperf\wperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Wperf.c

Abstract:

   Win32 application to display performance statictics.

Author:

   Mark Enstrom  (marke)

Environment:

   Win32

Revision History:

   10-20-91     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include "wperf.h"

//
// global handles
//

HANDLE  hInst;

//
// Selected Display Mode (read from wp2.ini), default set here.
//

DISPLAY_ITEM    PerfDataList[SAVE_SUBJECTS];
WINPERF_INFO    WinperfInfo;

//
// Window names
//

PUCHAR PerfNames[] = {
    "CPU0",
    "CPU1",
    "CPU2",
    "CPU3",
    "CPU4",
    "CPU5",
    "CPU6",
    "CPU7",
    "CPU8",
    "CPU9",
    "CPU10",
    "CPU11",
    "CPU12",
    "CPU13",
    "CPU14",
    "CPU15",
    "PAGE FLT",
    "PAGES AVAIL",
    "CONTEXT SW/S",
    "1st TB MISS/S",
    "2nd TB MISS/S",
    "SYSTEM CALLS/S",
    "INTERRUPT/S",
    "PAGE POOL",
    "NON-PAGE POOL",
    "PROCESSES",
    "THREADS",
    "ALIGN FIXUP",
    "EXCEPT DSPTCH",
    "FLOAT EMULAT",
    "INSTR EMULAT",
    "CPU"
};


int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )

/*++

Routine Description:

   Windows entry point routine


Arguments:

Return Value:

   status of operation

Revision History:

      03-21-91      Initial code

--*/
{
   MSG      msg;
   HBRUSH   BackBrush;


    //
    // check for other instances of this program
    //

    BackBrush = CreateSolidBrush(RGB(192,192,192));

    if (!InitApplication(hInstance,BackBrush)) {
        //DbgPrint("Init Application fails\n");
        return (FALSE);
    }

    //
    // Perform initializations that apply to a specific instance
    //

    if (!InitInstance(hInstance, nCmdShow)){
        return (FALSE);
    }

    //
    // Acquire and dispatch messages until a WM_QUIT message is received.
    //

    while (GetMessage(&msg,        // message structure
            NULL,                  // handle of window receiving the message
            0,                     // lowest message to examine
            0))                    // highest message to examine
        {
        TranslateMessage(&msg);    // Translates virtual key codes
        DispatchMessage(&msg);     // Dispatches message to window
    }

    DeleteObject(BackBrush);

    return (int)(msg.wParam);      // Returns the value from PostQuitMessage
}

BOOL
InitApplication(
    HANDLE  hInstance,
    HBRUSH  hBackground
    )

/*++

Routine Description:

   Initializes window data and registers window class.

Arguments:

   hInstance   - current instance
   hBackground - background fill brush

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{

    WNDCLASS  wc;
    BOOL      ReturnStatus;

    //
    // Fill in window class structure with parameters that describe the
    // main window.
    //

    wc.style         = CS_DBLCLKS;                          // Class style(s).
    wc.lpfnWndProc   = MainWndProc;                         // Function to retrieve messages for
                                                            // windows of this class.
    wc.cbClsExtra    = 0;                                   // No per-class extra data.
    wc.cbWndExtra    = 0;                                   // No per-window extra data.
    wc.hInstance     = hInstance;                           // Application that owns the class.
    wc.hIcon         = LoadIcon(hInstance,                  //
                            MAKEINTRESOURCE(WINPERF_ICON)); // Load Winperf icon
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);         // Load default cursor
    wc.hbrBackground = hBackground;;                        // Use background passed to routine
    wc.lpszMenuName  = "winperfMenu";                       // Name of menu resource in .RC file.
    wc.lpszClassName = "WinPerfClass";                      // Name used in call to CreateWindow.

    ReturnStatus = RegisterClass(&wc);
    return(ReturnStatus);
}

BOOL
InitInstance(
    HANDLE hInstance,
    int nCmdShow
    )

/*++

Routine Description:

   Save instance handle and create main window. This function performs
   initialization tasks that cannot be shared by multiple instances.

Arguments:

    hInstance - Current instance identifier.
    nCmdShow  - Param for first ShowWindow() call.

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{

    DWORD   WindowStyle;

    //
    // Save the instance handle in a static variable, which will be used in
    // many subsequent calls from this application to Windows.
    //

    hInst = hInstance;

    //
    // init the window position and size to be in the upper corner of
    // the screen, 200x100
    //
    //  What I want here is a way to get the WINDOW dimensions
    //

    WinperfInfo.WindowPositionX = 640 - 200;
    WinperfInfo.WindowPositionY = 0;
    WinperfInfo.WindowSizeX     = 200;
    WinperfInfo.WindowSizeY     = 100;
    WinperfInfo.CpuStyle        = CPU_STYLE_LINE;

    //
    //  read profile data from .ini file
    //

    InitProfileData(&WinperfInfo);
    WinperfInfo.hMenu = LoadMenu(hInstance,"winperfMenu");

    //
    // Create a main window for this application instance.
    //

    WinperfInfo.hWndMain = CreateWindow(
        "WinPerfClass",                 // See RegisterClass() call.
        "Perf Meter",                   // Text for window title bar.
        WS_OVERLAPPEDWINDOW,            // window style
        WinperfInfo.WindowPositionX,    // Default horizontal position.
        WinperfInfo.WindowPositionY,    // Default vertical position.
        WinperfInfo.WindowSizeX,        // Default width.
        WinperfInfo.WindowSizeY,        // Default height.
        NULL,                           // Overlapped windows have no parent.
        NULL,                           // Use the window class menu.
        hInstance,                      // This instance owns this window.
        NULL                            // Pointer not needed.
    );

    //
    // Decide on whether or not to display the menu and caption
    // based on the window class read from the .ini file
    //

    if (WinperfInfo.DisplayMode==STYLE_ENABLE_MENU) {
        WinperfInfo.DisplayMenu = TRUE;

    } else {
        WinperfInfo.DisplayMenu = FALSE;
        WindowStyle = GetWindowLong(WinperfInfo.hWndMain,GWL_STYLE);
        WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
        SetWindowPos(WinperfInfo.hWndMain, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
        SetWindowLong(WinperfInfo.hWndMain,GWL_STYLE,WindowStyle);
        SetMenu(WinperfInfo.hWndMain,NULL);
    }

    //
    // If window could not be created, return "failure"
    //

    if (!WinperfInfo.hWndMain) {
      return (FALSE);
    }

    //
    // Make the window visible; update its client area; and return "success"
    //

    SetFocus(WinperfInfo.hWndMain);
    ShowWindow(WinperfInfo.hWndMain, SW_SHOWNORMAL);
    UpdateWindow(WinperfInfo.hWndMain);

    return (TRUE);
}

LRESULT APIENTRY
MainWndProc(
   HWND   hWnd,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   message - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{

    PAINTSTRUCT   ps;

    //
    //   process each message
    //

    switch (message) {

        //
        // create window
        //

        case WM_CREATE:
        {
            HDC hDC = GetDC(hWnd);
            BOOLEAN   Fit;
            UINT      Index;


            //
            // make brushes and pens
            //

            WinperfInfo.hBluePen     = CreatePen(PS_SOLID,1,RGB(000,000,128));
            WinperfInfo.hRedPen      = CreatePen(PS_SOLID,1,RGB(255,000,000));
            WinperfInfo.hGreenPen    = CreatePen(PS_SOLID,1,RGB(000,255,000));
            WinperfInfo.hMagentaPen  = CreatePen(PS_SOLID,1,RGB(255,000,254));
            WinperfInfo.hYellowPen   = CreatePen(PS_SOLID,1,RGB(255,255,000));
            WinperfInfo.hDotPen      = CreatePen(PS_DOT,1,RGB(000,000,000));

            WinperfInfo.hBackground  = CreateSolidBrush(RGB(192,192,192));
            WinperfInfo.hLightBrush  = CreateSolidBrush(RGB(255,255,255));
            WinperfInfo.hDarkBrush   = CreateSolidBrush(RGB(128,128,128));
            WinperfInfo.hRedBrush    = CreateSolidBrush(RGB(255,000,000));
            WinperfInfo.hGreenBrush  = CreateSolidBrush(RGB(000,255,000));
            WinperfInfo.hBlueBrush   = CreateSolidBrush(RGB(000,000,255));
            WinperfInfo.hMagentaBrush= CreateSolidBrush(RGB(255,000,254));
            WinperfInfo.hYellowBrush = CreateSolidBrush(RGB(255,255,000));

            //
            //  create thee fonts using NT default font families
            //

            WinperfInfo.SmallFont      = CreateFont(8,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Small Fonts");

            WinperfInfo.MediumFont      = CreateFont(10,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");

            WinperfInfo.LargeFont      = CreateFont(14,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");


            //
            // create a system timer event to call performance gathering routines by.
            //

            WinperfInfo.TimerId = SetTimer(hWnd,
                                           TIMER_ID,
                                           1000 * DELAY_SECONDS,
                                           NULL);

            //
            // init display variables
            //

            InitPerfWindowDisplay(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            //
            //  Fit the perf windows into the main window
            //

            Fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            if (!Fit) {
                //DbgPrint("FitPerfWindows Fails         !\n");
            }

            for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                CalcDrawFrame(&PerfDataList[Index]);


                if (!CreateMemoryContext(hDC,&PerfDataList[Index])) {
                    MessageBox(hWnd,"Error Allocating Memory","Winperf",MB_OK);
                    DestroyWindow(hWnd);
                    break;
                }

            }

            //
            // init performance routines
            //

            WinperfInfo.NumberOfProcessors = InitPerfInfo();

            //
            // release the DC handle
            //

            ReleaseDC(hWnd,hDC);

      }
      break;

      //
      // re-size
      //

      case WM_SIZE:

      {
            int     i;
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;
            BOOLEAN Fit;

            //DbgPrint("WM_SIZE display active[0] = %i\n",(int)PerfDataList[0].Display);

            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            WinperfInfo.WindowPositionX = ClientRect.left;
            WinperfInfo.WindowPositionY = ClientRect.top;
            WinperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            WinperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            Fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            if (!Fit) {
                //DbgPrint("WM_SIZE error, FitPerf returns FALSE\n");
            }

            for (i=0;i<SAVE_SUBJECTS;i++) {
                DeleteMemoryContext(&PerfDataList[i]);
                CalcDrawFrame(&PerfDataList[i]);

                if (!CreateMemoryContext(hDC,&PerfDataList[i])) {
                    MessageBox(hWnd,"Error Allocating Memory","Winperf",MB_OK);
                    DestroyWindow(hWnd);
                    break;
                }
            }

            //
            // force window to be re-painted
            //

            InvalidateRect(hWnd,NULL,TRUE);

            //
            // release the DC handle
            //


            ReleaseDC(hWnd,hDC);



      }
      break;

      case WM_MOVE:
      {
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;


            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            WinperfInfo.WindowPositionX = ClientRect.left;
            WinperfInfo.WindowPositionY = ClientRect.top;
            WinperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            WinperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            ReleaseDC(hWnd,hDC);

      }

      break;


      //
      // command from application menu
      //

    case WM_COMMAND:



            switch (wParam){

               //
               // exit window
               //

               case IDM_EXIT:

                  DestroyWindow(hWnd);
                  break;

               //
               // about command
               //

            case IDM_SELECT:
            {
                HDC     hDC = GetDC(hWnd);
                INT_PTR DialogResult;
                int Index;
                BOOLEAN fit;

                DialogResult = DialogBox(hInst,
                                         MAKEINTRESOURCE(IDM_SEL_DLG),
                                         hWnd,
                                         SelectDlgProc);

                if (DialogResult == DIALOG_SUCCESS) {

                    fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

                    if (!fit) {
                        //DbgPrint("Fit Fails\n");
                    }

                    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                        DeleteMemoryContext(&PerfDataList[Index]);
                        CalcDrawFrame(&PerfDataList[Index]);

                        if (!CreateMemoryContext(hDC,&PerfDataList[Index])) {
                            MessageBox(hWnd,"Error Allocating Memory","Winperf",MB_OK);
                            DestroyWindow(hWnd);
                            break;
                        }
                    }

                    InvalidateRect(hWnd,NULL,TRUE);

                }

                ReleaseDC(hWnd,hDC);
            }

            break;


            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
            }

            break;

        case WM_PAINT:

            //
            // repaint the window
            //

            {

                int i;
                HDC hDC = BeginPaint(hWnd,&ps);



                SelectObject(hDC,GetStockObject(NULL_BRUSH));

                for (i=0;i<SAVE_SUBJECTS;i++) {

                    if (PerfDataList[i].Display == TRUE) {

                        DrawFrame(hDC,&PerfDataList[i]);

                        //
                        //  Draw each item, for CPU items decide whether to draw
                        //  line graphs or CPU bar graphs
                        //

                        if (
                            ((i < MAX_PROCESSOR) || (i == (IDM_CPU_TOTAL - IDM_CPU0))) &&
                            (WinperfInfo.CpuStyle == CPU_STYLE_BAR)
                           ) {

                            DrawCpuBarGraph(hDC,&PerfDataList[i],i);

                        } else {

                            DrawPerfText(hDC,&PerfDataList[i],i);
                            DrawPerfGraph(hDC,&PerfDataList[i]);
                        }

                    }
                }

                EndPaint(hWnd,&ps);

            }
            break;


        case WM_TIMER:
        {
            int i;
            HDC hDC = GetDC(hWnd);

            CalcCpuTime(PerfDataList);

            //
            // update all performance information
            //

            for (i=0;i<SAVE_SUBJECTS;i++) {

                if (PerfDataList[i].Display == TRUE) {

                    //
                    // for cpu0-7 and cpu total, check for cpu bar graph or
                    // cpu line graph
                    //

                    if (
                        ((i < MAX_PROCESSOR) || (i == (IDM_CPU_TOTAL - IDM_CPU0))) &&
                        (WinperfInfo.CpuStyle == CPU_STYLE_BAR)
                       ) {

                        DrawCpuBarGraph(hDC,&PerfDataList[i],i);

                    } else {


                        DrawPerfText(hDC,&PerfDataList[i],i);

                        if (PerfDataList[i].ChangeScale) {
                            DrawPerfGraph(hDC,&PerfDataList[i]);
                        } else {
                            ShiftPerfGraph(hDC,&PerfDataList[i]);
                        }

                    }

                }
            }


            ReleaseDC(hWnd,hDC);

        }
        break;

        //
        // handle a double click
        //

        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            DWORD   WindowStyle;


            //
            // get old window style, take out caption and menu
            //

            if (!IsIconic(hWnd)) {

                if (WinperfInfo.DisplayMenu) {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
                    SetMenu(hWnd,NULL);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    WinperfInfo.DisplayMode=STYLE_DISABLE_MENU;
                    WinperfInfo.DisplayMenu = FALSE;

                } else {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle & (~STYLE_DISABLE_MENU)) | STYLE_ENABLE_MENU;
                    SetMenu(hWnd,WinperfInfo.hMenu);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    WinperfInfo.DisplayMode=STYLE_ENABLE_MENU;
                    WinperfInfo.DisplayMenu = TRUE;
                }
            } else {
                DefWindowProc(hWnd, message, wParam, lParam);
            }


        }
        break;

        //
        //  enable dragging with mouse in non-client
        //

        case WM_NCHITTEST:
        {

            lParam = DefWindowProc(hWnd, message, wParam, lParam);
            if ((WinperfInfo.DisplayMenu==FALSE) && (lParam == HTCLIENT)) {
                return(HTCAPTION);
            } else {
                return(lParam);
            }


        }
        break;

        case WM_DESTROY:
        {
            UINT    Index;

            //
            // Save profile info
            //

            SaveProfileData(&WinperfInfo);

            //
            // Delete Windows Objects
            //

            KillTimer(hWnd,TIMER_ID);

            DeleteObject(WinperfInfo.hRedPen);
            DeleteObject(WinperfInfo.hGreenPen);
            DeleteObject(WinperfInfo.hBluePen);
            DeleteObject(WinperfInfo.hYellowPen);
            DeleteObject(WinperfInfo.hMagentaPen);
            DeleteObject(WinperfInfo.hDotPen);

	    DeleteObject(WinperfInfo.hBackground);
            DeleteObject(WinperfInfo.hLightBrush);
            DeleteObject(WinperfInfo.hDarkBrush);
            DeleteObject(WinperfInfo.hRedBrush);
            DeleteObject(WinperfInfo.hGreenBrush);
            DeleteObject(WinperfInfo.hBlueBrush);
            DeleteObject(WinperfInfo.hMagentaBrush);
            DeleteObject(WinperfInfo.hYellowBrush);

            for (Index=0;Index<SAVE_SUBJECTS;Index++ ) {
                DeleteMemoryContext(&PerfDataList[Index]);
            }

            //
            // Destroy window
            //

            PostQuitMessage(0);
         }
         break;


        default:

            //
            // Passes message on if unproccessed
            //

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0;
}



INT_PTR
APIENTRY SelectDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process message for select dialog box.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    UINT    ButtonState;
    UINT    Index;

    switch (message) {
    case WM_INITDIALOG:

        //
        // Init Buttons with PerfDataList Structure
        //

        for (Index = 0; Index< SAVE_SUBJECTS; Index++) {
            if (Index < MAX_PROCESSOR) {
                if (Index < WinperfInfo.NumberOfProcessors) {
                    if (PerfDataList[Index].Display == TRUE) {
                        SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_SETCHECK,1,0);

                    } else {
                        SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_SETCHECK,0,0);
                    }

                } else {

                    //
                    // Disable display if > WinperfInfo.NumberOfProcessors
                    //
                    // Also Disable radio button
                    //

                    PerfDataList[Index].Display = FALSE;
                    EnableWindow(GetDlgItem(hDlg,IDM_CPU0+Index),FALSE);
                }

            } else {

                //
                // Set or clear radio button based on display variable
                //

                if (PerfDataList[Index].Display == TRUE) {
                    SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_SETCHECK,1,0);

                } else {
                    SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_SETCHECK,0,0);
                }
            }
        }

        //
        // Beyond the end of the save subjects lies the cpu Style, set this to either style
        //

        if (WinperfInfo.CpuStyle == CPU_STYLE_LINE) {
            CheckRadioButton(hDlg,IDM_SEL_LINE,IDM_SEL_BAR,IDM_SEL_LINE);

        } else {
            CheckRadioButton(hDlg,IDM_SEL_LINE,IDM_SEL_BAR,IDM_SEL_BAR);
        }

        return (TRUE);

    case WM_COMMAND:

           switch(wParam) {

               //
               // end function
               //

           case IDOK:


                for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                   ButtonState = (UINT)SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_GETCHECK,0,0);
                   if (ButtonState == 1) {
                       PerfDataList[Index].Display = TRUE;
                       WinperfInfo.DisplayElement[Index] = 1;

                   } else {
                       PerfDataList[Index].Display = FALSE;
                       WinperfInfo.DisplayElement[Index] = 0;
                   }

                }

                //
                // Check CPU bar graph
                //

                ButtonState = IsDlgButtonChecked(hDlg,IDM_SEL_LINE);
                if (ButtonState == 1) {
                    WinperfInfo.CpuStyle = CPU_STYLE_LINE;

                } else {
                    WinperfInfo.CpuStyle = CPU_STYLE_BAR;
                }

                EndDialog(hDlg, DIALOG_SUCCESS);
                return (TRUE);

           case IDCANCEL:

                EndDialog(hDlg, DIALOG_CANCEL );
                return (TRUE);

            //
            // CPU STYLE
            //

            case IDM_SEL_LINE:
                CheckRadioButton(hDlg,IDM_SEL_LINE,IDM_SEL_BAR,IDM_SEL_LINE);
                return(TRUE);

            case IDM_SEL_BAR:
                CheckRadioButton(hDlg,IDM_SEL_LINE,IDM_SEL_BAR,IDM_SEL_BAR);
                return(TRUE);
        }

    }
    return (FALSE);
}

VOID
InitProfileData(
    PWINPERF_INFO pWinperfInfo
    )

/*++

Routine Description:

    Attempt tp read the following fields from the winperf.ini file

Arguments:

    WindowPositionX - Window initial x position
    WindowPositionY - Window initial y position
    WindowSizeX     - Window initial width
    WindowSizey     - Window Initial height
    DisplayMode     - Window initial display mode

Return Value:


    None, values are set to default before a call to this operation. If there is a problem then
    default:values are left unchanged.

Revision History:

      02-17-91      Initial code

--*/

{

    DWORD   PositionX,PositionY,SizeX,SizeY,Mode,Index,Element[SAVE_SUBJECTS],CpuStyle;
    UCHAR   TempStr[256];

    PositionX = GetPrivateProfileInt("winperf","PositionX"  ,pWinperfInfo->WindowPositionX,"winperf.ini");
    PositionY = GetPrivateProfileInt("winperf","PositionY"  ,pWinperfInfo->WindowPositionY,"winperf.ini");
    SizeX     = GetPrivateProfileInt("winperf","SizeX"      ,pWinperfInfo->WindowSizeX    ,"winperf.ini");
    SizeY     = GetPrivateProfileInt("winperf","SizeY"      ,pWinperfInfo->WindowSizeY    ,"winperf.ini");

    //
    // read the first deiplay element with default 1
    //

    Element[0] = GetPrivateProfileInt("winperf","DisplayElement0",1,"winperf.ini");

    //
    // read the rest of the display elements with default 0
    //

    for (Index=1;Index<SAVE_SUBJECTS;Index++) {
        wsprintf(TempStr,"DisplayElement%i",Index);
        Element[Index] = GetPrivateProfileInt("winperf",TempStr,0,"winperf.ini");
    }

    Mode      = GetPrivateProfileInt("winperf","DisplayMode",pWinperfInfo->DisplayMode    ,"winperf.ini");
    CpuStyle  = GetPrivateProfileInt("winperf","CpuStyle",pWinperfInfo->CpuStyle    ,"winperf.ini");

    pWinperfInfo->WindowPositionX = PositionX;
    pWinperfInfo->WindowPositionY = PositionY;
    pWinperfInfo->WindowSizeX     = SizeX;
    pWinperfInfo->WindowSizeY     = SizeY;

    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
        pWinperfInfo->DisplayElement[Index] = Element[Index];
    }
    pWinperfInfo->DisplayMode     = Mode;
    pWinperfInfo->CpuStyle        = CpuStyle;
}

VOID
SaveProfileData(
    PWINPERF_INFO pWinperfInfo
    )

/*++

Routine Description:

    Save profile data

Arguments:

    WindowPositionX - Window initial x position
    WindowPositionY - Window initial y position
    WindowSizeX     - Window initial width
    WindowSizey     - Window Initial height
    DisplayMode     - Window initial display mode

Return Value:


    None.

Revision History:

      02-17-91      Initial code

--*/

{
    UCHAR    TempStr[50],TempName[50];
    UINT     Index;

    wsprintf(TempStr,"%i",pWinperfInfo->WindowPositionX);
    WritePrivateProfileString("winperf","PositionX",TempStr,"winperf.ini");

    wsprintf(TempStr,"%i",pWinperfInfo->WindowPositionY);
    WritePrivateProfileString("winperf","PositionY",TempStr,"winperf.ini");

    wsprintf(TempStr,"%i",pWinperfInfo->WindowSizeX);
    WritePrivateProfileString("winperf","SizeX",TempStr,"winperf.ini");

    wsprintf(TempStr,"%i",pWinperfInfo->WindowSizeY);
    WritePrivateProfileString("winperf","SizeY",TempStr,"winperf.ini");

    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
        wsprintf(TempStr,"%li",pWinperfInfo->DisplayElement[Index]);
        wsprintf(TempName,"DisplayElement%li",Index);
        WritePrivateProfileString("winperf",TempName,TempStr,"winperf.ini");

    }


    wsprintf(TempStr,"%li",pWinperfInfo->DisplayMode);
    WritePrivateProfileString("winperf","DisplayMode",TempStr,"winperf.ini");

    wsprintf(TempStr,"%li",pWinperfInfo->CpuStyle);
    WritePrivateProfileString("winperf","CpuStyle",TempStr,"winperf.ini");

}









BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    )

/*++

Routine Description:

    Init All perf windows to active, init data

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/
{
    int     Index1;
    UINT    Index;

    for (Index=0;Index<NumberOfWindows;Index++) {

        if (WinperfInfo.DisplayElement[Index] == 0) {
            DisplayItems[Index].Display = FALSE;
        } else {
            DisplayItems[Index].Display = TRUE;
        }

        DisplayItems[Index].CurrentDrawingPos = 0;

        if (Index < MAX_PROCESSOR) {
            DisplayItems[Index].NumberOfElements = 3;
            DisplayItems[Index].Max = 100;
        } else if (Index == (IDM_CPU_TOTAL - IDM_CPU0)) {
            DisplayItems[Index].NumberOfElements = 3;
            DisplayItems[Index].Max = 100;
        } else {
            DisplayItems[Index].NumberOfElements = 1;
        }


        for (Index1=0;Index1<DATA_LIST_LENGTH;Index1++) {
            DisplayItems[Index].KernelTime[Index1] = 0;
            DisplayItems[Index].UserTime[Index1] = 0;
            DisplayItems[Index].DpcTime[Index1] = 0;
            DisplayItems[Index].InterruptTime[Index1] = 0;
            DisplayItems[Index].TotalTime[Index1] = 0;
        }
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ws2hdr\ws2hdr.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ws2hdr.c

Abstract:

    Munges the WinSock 2.0 header file.

    This program scans stdin, searching for begin and end tags. Lines of
    text between these tags are assumed to be function prototypes of the
    form:

        function_linkage
        return_type
        calling_convention
        function_name(
            parameters,
            parameters,
            ...
            );

    For each such function prototype found, the following is output:

        #if INCL_WINSOCK_API_PROTOTYPES
        function_linkage
        return_type
        calling_convention
        function_name(
            parameters,
            parameters,
            ...
            );
        #endif

        #if INCL_WINSOCK_API_TYPEDEFS
        typedef
        return_type
        (calling_convention * LPFN_FUNCTION_NAME)(
            parameters,
            parameters,
            ...
            );
        #endif

Author:

    Keith Moore (keithmo)        09-Dec-1995

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <string.h>


//
// Private constants.
//

#define MAX_HEADER_LINE 128
#define MAX_API_LINES   32

#define BEGIN_APIS      "/*BEGIN_APIS*/"
#define END_APIS        "/*END_APIS*/"


INT
__cdecl
main(
    INT    argc,
    CHAR * argv[]
    )
{

    CHAR lineBuffer[MAX_HEADER_LINE];
    CHAR apiBuffer[MAX_API_LINES][MAX_HEADER_LINE];
    INT i;
    INT apiLineNumber = 0;
    INT fileLineNumber = 0;
    BOOL inApis = FALSE;
    BOOL beginApis;
    BOOL endApis;

    //
    // This app takes no command line arguments.
    //

    if( argc != 1 ) {

        fprintf(
            stderr,
            "WS2HDR v1.01 " __DATE__ "\n"
            );

        fprintf(
            stderr,
            "use: ws2hdr < file1 > file2\n"
            );

        return 1;

    }

    //
    // Read stdin until exhausted.
    //

    while( fgets( lineBuffer, sizeof(lineBuffer), stdin ) != NULL ) {

        fileLineNumber++;

        //
        // fgets() leaves the terminating '\n' on the string; remove it.
        //

        lineBuffer[strlen(lineBuffer) - 1] = '\0';

        //
        // Check for our tags.
        //

        beginApis = FALSE;
        endApis = FALSE;

        if( _stricmp( lineBuffer, BEGIN_APIS ) == 0 ) {

            beginApis = TRUE;

        } else if( _stricmp( lineBuffer, END_APIS ) == 0 ) {

            endApis = TRUE;

        }

        //
        // Warn if we got an invalid tag.
        //

        if( beginApis && inApis ) {

            fprintf(
                stderr,
                "WARNING: unexpected %s, line %d\n",
                BEGIN_APIS,
                fileLineNumber
                );

            continue;

        }

        if( endApis && !inApis ) {

            fprintf(
                stderr,
                "WARNING: unexpected %s, line %d\n",
                END_APIS,
                fileLineNumber
                );

            continue;

        }

        //
        // Remember if we're currently between tags.
        //

        if( beginApis ) {

            inApis = TRUE;
            continue;

        }

        if( endApis ) {

            inApis = FALSE;
            continue;

        }

        //
        // If we're not between tags, or if the line is empty, just
        // output the line.
        //

        if( !inApis ) {

            printf( "%s\n", lineBuffer );
            continue;

        }

        if( lineBuffer[0] == '\0' ) {

            printf( "\n" );
            continue;

        }

        //
        // Add the line to our buffer. If the line doesn't end in ';',
        // then we're not at the end of the prototype, so keep reading
        // and scanning.
        //

        strcpy( &apiBuffer[apiLineNumber++][0], lineBuffer );

        if( lineBuffer[strlen(lineBuffer) - 1] != ';' ) {

            continue;

        }

        //
        // At this point the following are established in apiBuffer:
        //
        //  apiBuffer[0] == function linkage
        //  apiBuffer[1] == return type
        //  apiBuffer[2] == calling convention
        //  apiBuffer[3] == function name (with trailing '(')
        //  apiBuffer[4..n-1] == parameters
        //  apiBuffers[n] == ");"
        //

        //
        // First, dump out the prototype with its appropriate CPP protector.
        //

        printf( "#if INCL_WINSOCK_API_PROTOTYPES\n" );

        for( i = 0 ; i < apiLineNumber ; i++ ) {

            printf( "%s\n", &apiBuffer[i][0] );

        }

        printf( "#endif // INCL_WINSOCK_API_PROTOTYPES\n" );
        printf( "\n" );

        //
        // Now dump out the typedef with its appropriate CPP protector.
        //
        // Note that we must munge the api function name around a bit
        // first. Specifically, we remove the trailing '(' and map the
        // name to uppercase.
        //

        printf( "#if INCL_WINSOCK_API_TYPEDEFS\n" );

        apiBuffer[3][strlen( &apiBuffer[3][0] ) - 1] = '\0';
        _strupr( &apiBuffer[3][0] );

        printf( "typedef\n" );
        printf( "%s\n", &apiBuffer[1][0] );
        printf( "(%s * LPFN_%s)(\n", &apiBuffer[2][0], &apiBuffer[3][0] );

        for( i = 4 ; i < apiLineNumber ; i++ ) {

            printf( "%s\n", &apiBuffer[i][0] );

        }

        printf( "#endif // INCL_WINSOCK_API_TYPEDEFS\n" );

        //
        // Start over at the next input line.
        //

        apiLineNumber = 0;

    }

    return 0;

}   // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wsremote\advert.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       advert.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "Remote.h"

// ===================================================
// CLIENT END OF THE MAILSLOT
// ===================================================

#define  INITIAL_AD_RATE 15*1000          //10 Sec.  REMOVE
#define  MAXIMUM_AD_RATE 45*60*1000       //1  hour
#define  INITIAL_SLEEP_PERIOD 2*60*1000   //Initial Sleep Period REMOVE - change to 5 min.
#define  KDCONNECTED TEXT("Kernel Debugger connection established.")

extern   TCHAR           SaveFileName[64];
extern   SESSION_TYPE    ClientList[10];
extern   HANDLE          ListenThreadH;

HANDLE   hRead;

HANDLE
IsConnectedToClient(
    TCHAR *ClientName
    );

BOOL
WaitForString(
    HANDLE hRead,
    TCHAR   *str
    );

VOID
InitAd(
   BOOL IsAdvertise
   );

VOID
ShutAd(
   BOOL IsAdvertise
   );

DWORD
Advertise(
    TCHAR *PipeName
    );


VOID
InitAd(
   BOOL IsAdvertise
   )
{
    if (IsAdvertise)
    {
            HANDLE hThread;
            DWORD  WhoCares;
            hThread=CreateThread
            (
                 (LPSECURITY_ATTRIBUTES)NULL,
                 0,
                 (LPTHREAD_START_ROUTINE)Advertise,
                 (LPVOID)PipeName,
                 0,
                 &WhoCares
            );
            CloseHandle(hThread);
    }

}

VOID
ShutAd(
   BOOL IsAdvertise
   )
{
    if (IsAdvertise)
        SAFECLOSEHANDLE(hRead);
}

DWORD
Advertise(
    TCHAR *PipeName
    )
{
    DWORD   WaitTime=INITIAL_AD_RATE;
    DWORD   NameLen=32;
    HANDLE  hThread;
    TCHAR    SendBuff[256];
    DWORD   tmp;
    HANDLE  hMailSlot;
    TCHAR    Hostname[32];
    Sleep(INITIAL_SLEEP_PERIOD);

    hRead=CreateFile(
                     SaveFileName,
                     GENERIC_READ|GENERIC_WRITE,
                     FILE_SHARE_READ|FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (hRead==INVALID_HANDLE_VALUE)
    {
        return(1);
    }

    hMailSlot=CreateFile(
                             TEXT("\\\\NTDEV\\MAILSLOT\\REMOTE\\ADVERTISE"),
                             GENERIC_WRITE,
                             FILE_SHARE_WRITE,
                             (LPSECURITY_ATTRIBUTES)NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             (HANDLE)NULL
                            );

    if (hMailSlot==INVALID_HANDLE_VALUE)
    {
        return(2);
    }


    GetComputerName(HostName,&NameLen);
    _stprintf(SendBuff,TEXT("%.31s %.31s %.63s"),HostName,PipeName,ChildCmd);
    if (!WaitForString(hRead,KDCONNECTED))
    {
        return(1);
    }

    while(TRUE)
    {
        if (!(WriteFile(
                        hMailSlot,
                        (LPVOID)SendBuff,
                        (DWORD)_tcslen(SendBuff)+1,
                        &tmp,
                        NULL
                       )
             )
           )
        {
            //ERRORMSSG(TEXT("WriteFile Failed on Mailslot"));
            Sleep(10*60*1000);
        }
        else
        {
            Sleep(15*1000);
            while ((hThread=IsConnectedToClient(TEXT("SKYLINK")))!=NULL)
            {
                WaitForSingleObject(hThread,INFINITE);
                WaitTime=INITIAL_AD_RATE;
                WaitForString(hRead,KDCONNECTED); //REMOVE COMMENT
            }
            WaitTime=min(MAXIMUM_AD_RATE,2*WaitTime);
            Sleep(WaitTime);
        }

    }
    return(0); //Should never get here

}

BOOL
WaitForString(
    HANDLE hRead,
    TCHAR   *str
    )
{
    int   len=_tcslen(str);
    TCHAR  Buff[512];
    TCHAR  *BuffEnd=Buff;
    TCHAR  *BuffPos=Buff;
    TCHAR  *strPos=str;
    int   matchcount=0;
    BOOL  Found=FALSE;
    DWORD bytesread;

    while(!Found)
    {
        while (BuffPos==BuffEnd)
        {
            BuffPos=Buff;
            SetLastError(0);
	        if ((!ReadFile(hRead,Buff,512,&bytesread,NULL))||(bytesread==0))
            {
                if ((GetLastError()!=ERROR_HANDLE_EOF)&&(GetLastError()!=0))
                {
                    return(FALSE);
                }
                Sleep(2*60*1000);
            }
            BuffEnd=Buff+bytesread;
        }

        while(!Found && (BuffPos!=BuffEnd))
        {
            if (*(BuffPos++)==*(strPos++))
            {
                matchcount++;
                if (matchcount==len)
                    Found=TRUE;
            }
            else
            {
                matchcount=0;
                strPos=str;
            }
        }
    }
    return(Found);
}

HANDLE
IsConnectedToClient(
    TCHAR *ClientName
    )
{
    extern SESSION_TYPE ClientList[MAX_SESSION];
    int i;

    for (i=0;i<MAX_SESSION;i++)
    {
        if ((ClientList[i].Active==TRUE) &&
            (_tcscmp(ClientName,ClientList[i].Name)==0)
           )
        {
            return(ClientList[i].hThread);
        }
    }
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ws\ws.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ws.c

Abstract:

    Utility program to set both the console window size and buffer size.

Author:

    Steve Wood (stevewo) 01-Feb-1992

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>

void
Usage()
{
    printf("Usage: ws [-w WindowColumns,WindowRows][-b BufferColumns,BufferRows]\n");
    exit(1);
}

__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int i;
    char *s;
    HANDLE ScreenHandle;
    DWORD WindowRows,WindowColumns;
    DWORD BufferRows,BufferColumns;
    COORD BufferSize;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    SMALL_RECT WindowSize;
    COORD LargestScreenSize;
    USHORT MaxRows;
    USHORT MaxCols;

    ScreenHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    if (!GetConsoleScreenBufferInfo( ScreenHandle, &sbi )) {
        fprintf( stderr, "WS: Unable to read current console mode.\n" );
        exit( 1 );
        }

    BufferRows = sbi.dwSize.Y;
    BufferColumns = sbi.dwSize.X;
    WindowRows = sbi.srWindow.Bottom - sbi.srWindow.Top + 1;
    WindowColumns = sbi.srWindow.Right - sbi.srWindow.Left + 1;
    LargestScreenSize = GetLargestConsoleWindowSize( ScreenHandle );

    try {
        for (i=1; i<argc; i++) {
            s = argv[ i ];
            if (*s == '-' || *s == '/') {
                s++;
                switch( tolower( *s ) ) {

                    //
                    // Set window size
                    //

                    case 'w':
                        if (sscanf( argv[++i], "%d,%d", &WindowColumns, &WindowRows ) != 2) {
                            printf("Invalid usage\n");
                            Usage();
                        }
                        break;

                    //
                    // Set buffer size
                    //

                    case 'b':
                        if (sscanf( argv[++i], "%d,%d", &BufferColumns, &BufferRows ) != 2) {
                            printf("Invalid usage\n");
                            Usage();
                        }
                        break;


                    default:
                        Usage();
                    }
                }
            else {
                printf( "Error - argv[ %u ]: %s\n", i, argv[ i ] );
                Usage();
                }
            }
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Usage();
        }

    MaxRows = (USHORT)min( (int)WindowRows, (int)(sbi.dwSize.Y) );
    MaxRows = (USHORT)min( (int)MaxRows, (int)LargestScreenSize.Y );
    MaxCols = (USHORT)min( (int)WindowColumns, (int)(sbi.dwSize.X) );
    MaxCols = (USHORT)min( (int)MaxCols, (int)LargestScreenSize.X );


    WindowSize.Top = 0;
    WindowSize.Left = 0;
    WindowSize.Bottom = MaxRows - (SHORT)1;
    WindowSize.Right = MaxCols - (SHORT)1;
    SetConsoleWindowInfo( ScreenHandle, TRUE, &WindowSize );

    BufferSize.X = (SHORT)BufferColumns;
    BufferSize.Y = (SHORT)BufferRows;
    SetConsoleScreenBufferSize( ScreenHandle, BufferSize );

    printf( "WS -w %d,%d -b %d,%d\n", MaxCols, MaxRows, BufferColumns, BufferRows );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wsremote\client.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    Client.c

Abstract:

    The Client component of Remote. Connects to the remote
    server using named pipes. It sends its stdin to
    the server and output everything from server to
    its stdout.

Author:

    Rajivendra Nath (rajnath) 2-Jan-1992

Environment:

    Console App. User mode.

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "Remote.h"

HANDLE*
EstablishSession(
    TCHAR *server,
    TCHAR *pipe
    );

SOCKET*
SockEstablishSession(
    TCHAR *server,
    TCHAR *pipe
    );

DWORD
GetServerOut(
    PVOID *Noarg
    );

DWORD
SockGetServerOut(
    PVOID *Noarg
    );

DWORD
SendServerInp(
    PVOID *Noarg
    );

DWORD
SockSendServerInp(
    PVOID *Noarg
    );

BOOL
FilterClientInp(
    TCHAR *buff,
    int count
    );

BOOL
SockFilterClientInp(
    TCHAR *buff,
    int count
    );

BOOL
Mych(
    DWORD ctrlT
    );

BOOL
SockMych(
    DWORD ctrlT
    );

VOID
SendMyInfo(
    PHANDLE Pipes
    );

VOID
SockSendMyInfo(
    SOCKET MySocket
    );


HANDLE iothreads[2];
HANDLE MyStdInp;
HANDLE MyStdOut;
HANDLE ReadPipe;
HANDLE WritePipe;
SOCKET RWSocket;


CONSOLE_SCREEN_BUFFER_INFO csbi;

TCHAR   MyEchoStr[30];
BOOL   CmdSent;
DWORD  LinesToSend=LINESTOSEND;

VOID
Client(
    TCHAR* Server,
    TCHAR* Pipe
    )
{
    HANDLE *Connection;
    DWORD  tid;


    MyStdInp=GetStdHandle(STD_INPUT_HANDLE);
    MyStdOut=GetStdHandle(STD_OUTPUT_HANDLE);

    _tprintf(TEXT("****************************************\n"));
    _tprintf(TEXT("***********     WSREMOTE    ************\n"));
    _tprintf(TEXT("***********      CLIENT     ************\n"));
    _tprintf(TEXT("****************************************\n"));

    if ((Connection=EstablishSession(Server,Pipe))==NULL)
        return;


    ReadPipe=Connection[0];
    WritePipe=Connection[1];


    SetConsoleCtrlHandler((PHANDLER_ROUTINE)Mych,TRUE);

    // Start Thread For Server --> Client Flow
    if ((iothreads[0]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
            (DWORD)0,                           // Use same stack size.
            (LPTHREAD_START_ROUTINE)GetServerOut, // Thread procedure.
            (LPVOID)NULL,              // Parameter to pass.
            (DWORD)0,                           // Run immediately.
            (LPDWORD)&tid))==NULL)              // Thread identifier.
    {

        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread"));
        return;
    }



    //
    // Start Thread for Client --> Server Flow
    //

    if ((iothreads[1]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
                    (DWORD)0,                           // Use same stack size.
                    (LPTHREAD_START_ROUTINE)SendServerInp, // Thread procedure.
                    (LPVOID)NULL,          // Parameter to pass.
                    (DWORD)0,                           // Run immediately.
                    (LPDWORD)&tid))==NULL)              // Thread identifier.
    {

        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread"));
        return;
    }

    WaitForMultipleObjects(2,iothreads,FALSE,INFINITE);

    TerminateThread(iothreads[0],1);
    TerminateThread(iothreads[1],1);
    _tprintf(TEXT("*** SESSION OVER ***\n"));
}


VOID
SockClient(
    TCHAR* Server,
    TCHAR* Pipe
    )
{
    SOCKET *Connection;
    DWORD  tid;
	int nRet;


    MyStdInp=GetStdHandle(STD_INPUT_HANDLE);
    MyStdOut=GetStdHandle(STD_OUTPUT_HANDLE);

    _tprintf(TEXT("**************************************\n"));
    _tprintf(TEXT("***********     WSREMOTE    ************\n"));
    _tprintf(TEXT("***********      CLIENT(IP) ************\n"));
    _tprintf(TEXT("**************************************\n"));

    if ((Connection=SockEstablishSession(Server,Pipe))==NULL)
        return;

	RWSocket = *Connection;  

    SetConsoleCtrlHandler((PHANDLER_ROUTINE)SockMych,TRUE);

    // Start Thread For Server --> Client Flow
    if ((iothreads[0]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
            (DWORD)0,                           // Use same stack size.
            (LPTHREAD_START_ROUTINE)SockGetServerOut, // Thread procedure.
            (LPVOID)NULL,              // Parameter to pass.
            (DWORD)0,                           // Run immediately.
            (LPDWORD)&tid))==NULL)              // Thread identifier.
    {

        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread"));
        return;
    }



    //
    // Start Thread for Client --> Server Flow
    //

    if ((iothreads[1]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
                    (DWORD)0,                           // Use same stack size.
                    (LPTHREAD_START_ROUTINE)SockSendServerInp, // Thread procedure.
                    (LPVOID)NULL,          // Parameter to pass.
                    (DWORD)0,                           // Run immediately.
                    (LPDWORD)&tid))==NULL)              // Thread identifier.
    {

        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread"));
        return;
    }

    WaitForMultipleObjects(2,iothreads,FALSE,INFINITE);

    TerminateThread(iothreads[0],1);
    TerminateThread(iothreads[1],1);
	
//	_tprintf(TEXT("Calling WSACleanup()....\n"));
	nRet = WSACleanup();
    _tprintf(TEXT("*** SESSION OVER ***\n"));
}

DWORD
GetServerOut(
    PVOID *Noarg
    )

{
    TCHAR buffin[200];
    DWORD  dread=0,tmp;

    while(ReadFile(ReadPipe,buffin,200,&dread,NULL))
    {
        if (dread!=0)
        {
           if (!WriteFile(MyStdOut,buffin,dread,&tmp,NULL))
            break;
        }

    }
    return(1);
}


DWORD
SockGetServerOut(
    PVOID *Noarg
    )
{
    
	TCHAR buffin[200];
    DWORD  dread=0,tmp;

    while(ReadSocket(RWSocket,buffin,200,&dread))
    {
        if (dread!=0)
        {
           if (!WriteFile(MyStdOut,buffin,dread,&tmp,NULL))
            break;
        }

    }
    return(1);
}

DWORD
SendServerInp(
    PVOID *Noarg
    )

{
    TCHAR buff[200];
    DWORD  dread,dwrote;
    SetLastError(0);

    while(ReadFile(MyStdInp,buff,200,&dread,NULL))
    {
        if (FilterClientInp(buff,dread))
            continue;
          if (!WriteFile(WritePipe,buff,dread,&dwrote,NULL))
            break;
    }
    return(0);
}

DWORD
SockSendServerInp(
    PVOID *Noarg
    )

{
    TCHAR buff[200];
    DWORD  dread,dwrote;
    SetLastError(0);

    while(ReadFile(MyStdInp,buff,200,&dread,NULL))
    {
       if (SockFilterClientInp(buff,dread))
            continue;
		if (!WriteSocket(RWSocket,buff,dread,&dwrote))
            break;
		memset(buff, 0, sizeof(buff));
      
    }
    return(0);
}

BOOL
SockSendAuth(
    SOCKET s
    )

{
    TCHAR	EncodeBuffer[1024];
    TCHAR * pEncodeBuffer; 
	TCHAR	UserBuffer[1024];
//    TCHAR *	String = UserBuffer;
    DWORD	dwrote;
	int		len;
	BOOL	bRet;

    SetLastError(0);
	
	memset(EncodeBuffer, 0, sizeof(EncodeBuffer));
	
	_stprintf(	UserBuffer,
		        TEXT("%s:%s"),
				Username,
				Password);

    pEncodeBuffer = EncodeBuffer + _tcslen(EncodeBuffer);
	len = _tcslen(UserBuffer);
    Base64Encode(UserBuffer, _tcslen(UserBuffer), pEncodeBuffer);
    len = _tcslen(pEncodeBuffer);

	bRet = WriteSocket(s,pEncodeBuffer,len,&dwrote);
	
	return TRUE;
}

BOOL
FilterClientInp(
    TCHAR *buff,
    int count
    )
{

    if (count==0)
        return(TRUE);

    if (buff[0]==2)  //Adhoc screening of ^B so that i386kd/mipskd
        return(TRUE);//do not terminate.

    if (buff[0]==COMMANDCHAR)
    {
        switch (buff[1])
        {
        case 'k':
        case 'K':
        case 'q':
        case 'Q':
              CloseHandle(WritePipe);
              return(FALSE);

        case 'h':
        case 'H':
              _tprintf(TEXT("%cM : Send Message\n"),COMMANDCHAR);
              _tprintf(TEXT("%cP : Show Popup on Server\n"),COMMANDCHAR);
              _tprintf(TEXT("%cS : Status of Server\n"),COMMANDCHAR);
              _tprintf(TEXT("%cQ : Quit client\n"),COMMANDCHAR);
              _tprintf(TEXT("%cH : This Help\n"),COMMANDCHAR);
              return(TRUE);

        default:
              return(FALSE);
        }

    }
    return(FALSE);
}

BOOL
SockFilterClientInp(
    TCHAR *buff,
    int count
    )
{
int nRet;

    if (count==0)
        return(TRUE);

    if (buff[0]==2)  //Adhoc screening of ^B so that i386kd/mipskd
        return(TRUE);//do not terminate.

    if (buff[0]==COMMANDCHAR)
    {
        switch (buff[1])
        {
        case 'k':
        case 'K':
        case 'q':
        case 'Q':
			  nRet = shutdown(RWSocket, SD_BOTH);
			  if (nRet == SOCKET_ERROR)
				_tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
              closesocket(RWSocket);
              return(FALSE);

        case 'h':
        case 'H':
              _tprintf(TEXT("%cM : Send Message\n"),COMMANDCHAR);
              _tprintf(TEXT("%cP : Show Popup on Server\n"),COMMANDCHAR);
              _tprintf(TEXT("%cS : Status of Server\n"),COMMANDCHAR);
              _tprintf(TEXT("%cQ : Quit client\n"),COMMANDCHAR);
              _tprintf(TEXT("%cH : This Help\n"),COMMANDCHAR);
              return(TRUE);

        default:
              return(FALSE);
        }

    }
    return(FALSE);
}

BOOL
Mych(
   DWORD ctrlT
   )

{
    TCHAR  c[2];
    DWORD tmp;
    DWORD send=1;
    c[0]=CTRLC;
    if (ctrlT==CTRL_C_EVENT)
    {
        if (!WriteFile(WritePipe,c,send,&tmp,NULL))
        {
            Errormsg(TEXT("Error Sending ^c\n"));
            return(FALSE);
        }
        return(TRUE);
    }
    if ((ctrlT==CTRL_BREAK_EVENT)||
        (ctrlT==CTRL_CLOSE_EVENT)||
        (ctrlT==CTRL_LOGOFF_EVENT)||
        (ctrlT==CTRL_SHUTDOWN_EVENT)

       )
    {
        CloseHandle(WritePipe); //Will Shutdown naturally
    }
    return(FALSE);
}

BOOL
SockMych(
   DWORD ctrlT
   )

{
    TCHAR  c[2];
    DWORD tmp;
    DWORD send=1;
    c[0]=CTRLC;
    if (ctrlT==CTRL_C_EVENT)
    {
        if (!WriteSocket(RWSocket,c,send,&tmp))
        {
            Errormsg(TEXT("Error Sending ^c\n"));
            return(FALSE);
        }
        return(TRUE);
    }
    if ((ctrlT==CTRL_BREAK_EVENT)||
        (ctrlT==CTRL_CLOSE_EVENT)||
        (ctrlT==CTRL_LOGOFF_EVENT)||
        (ctrlT==CTRL_SHUTDOWN_EVENT)

       )
    {
        CloseHandle(WritePipe); //Will Shutdown naturally
    }
    return(FALSE);
}

HANDLE*
EstablishSession(
    TCHAR *server,
    TCHAR *srvpipename
    )
{
    static HANDLE PipeH[2];
    TCHAR   pipenameSrvIn[200];
    TCHAR   pipenameSrvOut[200];

    _stprintf(pipenameSrvIn ,SERVER_READ_PIPE ,server,srvpipename);
    _stprintf(pipenameSrvOut,SERVER_WRITE_PIPE,server,srvpipename);

    if ((INVALID_HANDLE_VALUE==(PipeH[0]=CreateFile(pipenameSrvOut,
        GENERIC_READ ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL))) ||
        (INVALID_HANDLE_VALUE==(PipeH[1]=CreateFile(pipenameSrvIn ,
        GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)))) {

        DWORD Err=GetLastError();
        TCHAR msg[128];

        Errormsg(TEXT("*** Unable to Connect ***"));
        //
        // Print a helpful message
        //
        switch(Err)
        {
            case 2: _stprintf(msg,TEXT("Invalid PipeName %s"),srvpipename);break;
            case 53:_stprintf(msg,TEXT("Server %s not found"),server);break;
            default:
                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|
                               FORMAT_MESSAGE_IGNORE_INSERTS,
                               NULL, Err, 0, msg, 128, NULL);
                break;

        }
        _tprintf(TEXT("Diagnosis:%s\n"),msg);

        return(NULL);
    }

    _tprintf(TEXT("Connected..\n\n"));

    SendMyInfo(PipeH);

    return(PipeH);
}


SOCKET*
SockEstablishSession(
    TCHAR *server,
    TCHAR *srvpipename
    )
{
    static SOCKET   Socket;

    int				nRet;
    LPHOSTENT       lpHostEntry         = NULL;
	SOCKADDR_IN		sa;
	WORD			wVersionRequested	= MAKEWORD(1,1);
	WSADATA			wsaData;
	unsigned short	usPort;
#ifdef UNICODE
    int             nStrLen;
#endif

	//
	// Initialize WinSock
	//
	nRet = WSAStartup(wVersionRequested, &wsaData);
	if (nRet)
	{
	_tprintf(TEXT("Initialize WinSock Failed"));
		return NULL;
	}
	// Check version
	if (wsaData.wVersion != wVersionRequested)
	{       
	_tprintf(TEXT("Wrong WinSock Version"));
		return NULL;
	}


	// 
	// Lookup host
	//
#ifdef UNICODE
    nStrLen	= lstrlen( server );

    if (nStrLen)
    {
        char *  pszAnsiStr  = (char *)malloc( nStrLen + 1 );

        if (pszAnsiStr)
        {
            int nErr    = WideCharToMultiByte(  CP_THREAD_ACP,
                                                WC_COMPOSITECHECK,
                                                server,
                                                -1,
                                                pszAnsiStr,
                                                nStrLen,
                                                NULL,
                                                NULL );

            if (!nErr)
            {
                DWORD dwErr = GetLastError();

                switch( dwErr )
                {
                    case ERROR_INSUFFICIENT_BUFFER:
                        _tprintf(TEXT("error: gethostbyname-- WideCharToMultiByte Error: ERROR_INSUFFICIENT_BUFFER"));
                        break;
                    case ERROR_INVALID_FLAGS:
                        _tprintf(TEXT("error: gethostbyname-- WideCharToMultiByte Error: ERROR_INVALID_FLAGS"));
                        break;
                    case ERROR_INVALID_PARAMETER:
                        _tprintf(TEXT("error: gethostbyname-- WideCharToMultiByte Error: ERROR_INVALID_PARAMETER"));
                        break;
                }

                free( pszAnsiStr );
                return NULL;
            }

            lpHostEntry = gethostbyname( pszAnsiStr );
            free( pszAnsiStr );
        }
    }
#else
    lpHostEntry = gethostbyname( server );
#endif
    if (lpHostEntry == NULL)
	{
		_tprintf(TEXT("wsremote: gethostbyname() error "));
		return NULL;
	}

	//
	// Fill in the server address structure
	//
	sa.sin_family = AF_INET;
	sa.sin_addr = *((LPIN_ADDR)*lpHostEntry->h_addr_list);

	usPort = (unsigned short)_ttoi( srvpipename );
	sa.sin_port = htons(usPort);	

	//	
	// Create a TCP/IP stream socket
	//
	
	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (Socket == INVALID_SOCKET)
	{
		_tprintf(TEXT("socket()"));
		return NULL;
	}

	//
	// Request a connection
	//
	nRet = connect(Socket, 
	               (LPSOCKADDR)&sa, 
				   sizeof(SOCKADDR_IN));
	if (nRet == SOCKET_ERROR)
	{
		int	iWSAErr;
		iWSAErr	= WSAGetLastError();

		_tprintf( TEXT("connect(), Error: %d"), iWSAErr );
			return NULL;
	}

	SockSendMyInfo(Socket);

    return(&Socket);
}

VOID
SendMyInfo(
    PHANDLE pipeH
    )
{
    HANDLE rPipe=pipeH[0];
    HANDLE wPipe=pipeH[1];

    DWORD  hostlen=HOSTNAMELEN-1;
    WORD   BytesToSend=sizeof(SESSION_STARTUPINFO);
    DWORD  tmp;
    SESSION_STARTUPINFO ssi;
    SESSION_STARTREPLY  ssr;
    DWORD  BytesToRead;
    TCHAR   *buff;

    ssi.Size=BytesToSend;
    ssi.Version=VERSION;

    GetComputerName((TCHAR *)ssi.ClientName,&hostlen);
    ssi.LinesToSend=LinesToSend;
    ssi.Flag=ClientToServerFlag;

    {
        DWORD NewCode=MAGICNUMBER;
        TCHAR  Name[15];

        _tcscpy(Name,(TCHAR *)ssi.ClientName);
        memcpy(&Name[11],(TCHAR *)&NewCode,sizeof(NewCode));

        WriteFile(wPipe,(TCHAR *)Name,HOSTNAMELEN-1,&tmp,NULL);
        ReadFile(rPipe ,(TCHAR *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp,NULL);

        if (ssr.MagicNumber!=MAGICNUMBER)
        {
            _tprintf(TEXT("WSREMOTE FAILED TO CONNECT TO SERVER..\n"));
            WriteFile(MyStdOut,(TCHAR *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp,NULL);
            return;
        }

        //Get Rest of the info-its not the old server

        ReadFixBytes(rPipe,(TCHAR *)&ssr.Size,sizeof(ssr.Size),0);
        ReadFixBytes(rPipe,(TCHAR *)&ssr.FileSize,sizeof(ssr)-sizeof(ssr.FileSize)-sizeof(ssr.MagicNumber),0);

    }

    if (!WriteFile(wPipe,(TCHAR *)&ssi,BytesToSend,&tmp,NULL))
    {
       Errormsg(TEXT("INFO Send Error"));
       return;
    }

    BytesToRead=MINIMUM(ssr.FileSize,ssi.LinesToSend*CHARS_PER_LINE);
    buff=calloc(BytesToRead+1,1);
    if (buff!=NULL)
    {
        DWORD  bytesread=0;

        ReadFile(rPipe,buff,BytesToRead,&bytesread,NULL);

        WriteFile(MyStdOut,buff,bytesread,&tmp,NULL);
        free(buff);
    }

}

VOID
SockSendMyInfo(
    SOCKET MySocket
    )
{
    BOOL                bRet;
#ifdef UNICODE
    char                szAnsiName[HOSTNAMELEN];
#endif
    DWORD               hostlen                 = HOSTNAMELEN-1;
    DWORD               BytesToRead;
    DWORD               tmp;
    DWORD               NewCode                 = MAGICNUMBER;
    SESSION_STARTUPINFO ssi;
    SESSION_STARTREPLY  ssr;
    int                 nRet;
    TCHAR               Name[HOSTNAMELEN];

    TCHAR *             buff;
    WORD                BytesToSend             = sizeof(SESSION_STARTUPINFO);
       

    ssi.Size=BytesToSend;
    ssi.Version=VERSION;

    GetComputerName((TCHAR *)ssi.ClientName,&hostlen);
    ssi.LinesToSend=LinesToSend;
    ssi.Flag=ClientToServerFlag;

    bRet = SockSendAuth(MySocket);

    // append on magic number
    _tcscpy(Name, ssi.ClientName);

#ifdef UNICODE
    GetAnsiStr( (TCHAR *)&Name, (char *)&szAnsiName, HOSTNAMELEN );

    memcpy(&szAnsiName[11], &NewCode, sizeof(DWORD) );

    WriteSocketA( MySocket,(char *)&szAnsiName,HOSTNAMELEN-1,&tmp);
#else
    memcpy(&Name[11], &NewCode, sizeof(DWORD) );

    WriteSocket( MySocket,(TCHAR *)Name,HOSTNAMELEN-1,&tmp);
#endif
    ReadSocket(MySocket ,(TCHAR *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp);

    if (ssr.MagicNumber!=MAGICNUMBER)
    {
        _tprintf(TEXT("WSREMOTE FAILED TO CONNECT TO SERVER..\n"));
        nRet = shutdown(MySocket, SD_BOTH);
        if (nRet == SOCKET_ERROR)
            _tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
        closesocket(MySocket);
        return;
    }

    //Get Rest of the info-its not the old server

    SockReadFixBytes(MySocket,(TCHAR *)&ssr.Size,sizeof(ssr.Size),0);
    SockReadFixBytes(MySocket,(TCHAR *)&ssr.FileSize,sizeof(ssr)-sizeof(ssr.FileSize)-sizeof(ssr.MagicNumber),0);

    if (!WriteSocket(MySocket,(TCHAR *)&ssi,BytesToSend,&tmp))
    {
       _tprintf(TEXT("INFO Send Error"));
       return;
    }

    BytesToRead=MINIMUM(ssr.FileSize,ssi.LinesToSend*CHARS_PER_LINE);
    buff=calloc(BytesToRead+1,1);

    if (buff!=NULL)
    {
        DWORD  bytesread=0;

        ReadSocket(MySocket,buff,BytesToRead,&bytesread);
        WriteFile(MyStdOut,buff,bytesread,&tmp,NULL);

        free(buff);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wsremote\remote.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    Remote.c

Abstract:

    This module contains the main() entry point for Remote.
    Calls the Server or the Client depending on the first parameter.


Author:

    Rajivendra Nath (rajnath) 2-Jan-1993

Environment:

    Console App. User mode.

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include "Remote.h"

TCHAR   HostName[HOSTNAMELEN];
TCHAR * ChildCmd;
TCHAR*  PipeName;
TCHAR*  ServerName;
TCHAR*  Username;
TCHAR*  Password;
HANDLE  MyOutHandle;
BOOL    bIPLocked=FALSE;

BOOL   IsAdvertise=TRUE;
DWORD  ClientToServerFlag;

TCHAR* ColorList[]={
	TEXT("black"),
	TEXT("blue"),
	TEXT("green"),
	TEXT("cyan"),
	TEXT("red"),
	TEXT("purple"),
	TEXT("yellow"),
	TEXT("white"),
	TEXT("lblack"),
	TEXT("lblue"),
	TEXT("lgreen"),
	TEXT("lcyan"),
	TEXT("lred"),
	TEXT("lpurple"),
	TEXT("lyellow"),
	TEXT("lwhite")
};

WORD
GetColorNum(
    TCHAR* color
    );

VOID
SetColor(
    WORD attr
    );

BOOL
GetNextConnectInfo(
    TCHAR** SrvName,
    TCHAR** PipeName
    );



CONSOLE_SCREEN_BUFFER_INFO csbiOriginal;

int _cdecl _tmain(int argc, TCHAR *argv[])
{
    WORD  RunType;              // Server or Client end of Remote
    DWORD len=HOSTNAMELEN-1;
    int   i, FirstArg;

    BOOL  bSetAttrib=FALSE;     // Change Console Attributes
    BOOL  bPromptForArgs=FALSE; // Is /P option
	BOOL  bIPSession=TRUE;           // Is /N for Named Pipes
    TCHAR	szTitle[100];		// New Title
    TCHAR	szOrgTitle[100];	// Old Title
    WORD  wAttrib;              // Console Attributes

    GetComputerName((LPTSTR)HostName,&len);

    MyOutHandle=GetStdHandle(STD_OUTPUT_HANDLE);

    GetConsoleScreenBufferInfo(MyOutHandle,&csbiOriginal);

    //
    // Parameter Processing
    //
    // For Server:
    // Remote /S <Executable>  <PipeName> [Optional Params]
    //
    // For Client:
    // Remote /C <Server Name> <PipeName> [Optional Params]
    // or
    // Remote /P
    // This will loop continously prompting for different
    // Servers and Pipename


    if ((argc<2)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
    {

        DisplayServerHlp();
        DisplayClientHlp();
        return(1);
    }

    switch(argv[1][1])
    {

    case 'c':
    case 'C':

        //
        // Is Client End of Remote
        //

        if ((argc<4)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        ServerName=argv[2];
        PipeName=argv[3];
        FirstArg=4;
        RunType=REMOTE_CLIENT;
        break;


    case 'p':
    case 'P':

        //
        // Is Client End of Remote
        //

        bPromptForArgs=TRUE;
        RunType=REMOTE_CLIENT;
        FirstArg=2;
        break;


    case 's':
    case 'S':
        //
        // Is Server End of Remote
        //
        if ((argc<4)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        ChildCmd=argv[2];
        PipeName=argv[3];
        FirstArg=4;

        RunType=REMOTE_SERVER;
        break;


    default:
        DisplayServerHlp();
        DisplayClientHlp();
        return(1);
    }

    //
    // Save Existing Values
    //

    //
    //Colors /f   <ForeGround> /b <BackGround>
    //

    wAttrib=csbiOriginal.wAttributes;

    //
    //Title  /T Title
    //

    GetConsoleTitle( szOrgTitle, lstrlen( szOrgTitle) );

    if (RunType==REMOTE_SERVER)
    {
    	//
    	// Base Name of Executable
    	// For setting the title
    	//

        TCHAR *tcmd=ChildCmd;

        while ((*tcmd!=' ')    &&(*tcmd!=0))   tcmd++;
        while ((tcmd!=ChildCmd)&&(*tcmd!='\\'))tcmd--;

        _stprintf( szTitle, TEXT("%-8.8s [WSRemote /C %s %s]"), tcmd, HostName, PipeName);
    }

    //
    //Process Common (Optional) Parameters
    //

    for (i=FirstArg;i<argc;i++)
    {

        if ((argv[i][0]!='/')&&(argv[i][0]!='-'))
        {
            _tprintf( TEXT("Invalid parameter %s:Ignoring\n"),argv[i]);
            continue;
        }

        switch(argv[i][1])
        {
		case 'u':    // Only Valid for Server End
        case 'U':    // Username To Use to Connect to Session
            i++;
            if (i>=argc)
            {
                _tprintf( TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            Username=(argv[i]);
            break;

		case 'p':    // Only Valid for Server End
        case 'P':    // Password To Use to Connect to Session
            i++;
            if (i>=argc)
            {
                _tprintf( TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            Password=(argv[i]);
            break;

        case 'l':    // Only Valid for client End
        case 'L':    // Max Number of Lines to recieve from Server
            i++;
            if (i>=argc)
            {
                _tprintf(TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            LinesToSend=(DWORD)_ttoi(argv[i])+1;
            break;

        case 't':    // Title to be set instead of the default
        case 'T':
            i++;
            if (i>=argc)
            {
                _tprintf(TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            _stprintf( szTitle, TEXT("%s"),argv[i]);
            break;

        case 'b':    // Background color
        case 'B':
            i++;
            if (i>=argc)
            {
                _tprintf(TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            {
                WORD col=GetColorNum(argv[i]);
                if (col!=0xffff)
                {
                    bSetAttrib=TRUE;
                    wAttrib=col<<4|(wAttrib&0x000f);
                }
                break;
            }

        case 'f':    // Foreground color
        case 'F':
            i++;
            if (i>=argc)
            {
                _tprintf(TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            {
                WORD col=GetColorNum(argv[i]);
                if (col!=0xffff)
                {
                    bSetAttrib=TRUE;
                    wAttrib=col|(wAttrib&0x00f0);
                }
                break;
            }

        case 'q':
        case 'Q':
            IsAdvertise=FALSE;
            ClientToServerFlag|=0x80000000;
            break;
		
		case 'n':
        case 'N':
            bIPSession=FALSE;
            break;
		
		case 'i':
        case 'I':
            bIPLocked=TRUE;
            break;
        default:
            _tprintf(TEXT("Unknown Parameter=%s %s\n"),argv[i-1],argv[i]);
            break;

        }

    }

    //
    //Now Set various Parameters
    //

    //
    //Colors
    //

    SetColor(wAttrib);

    if (RunType==REMOTE_CLIENT)
    {
        BOOL done=FALSE;

        //
        // Set Client end defaults and start client
        //



        while(!done)
        {
            if (!bPromptForArgs ||
                GetNextConnectInfo(&ServerName,&PipeName)
               )
            {
                _stprintf( szTitle, TEXT("WSRemote /C %s %s"),ServerName,PipeName);
                SetConsoleTitle(szTitle);

                
				if (!bIPSession)
				{
				//
                // Start Client (Client.C)
                //
                Client(ServerName,PipeName);
				}
				else
				{
				SockClient(ServerName,PipeName);
				}
            }
            done=!bPromptForArgs;
        }
    }

    if (RunType==REMOTE_SERVER)
    {
		SetConsoleTitle(szTitle);

        //
        // Start Server (Server.C)
        //
        Server(ChildCmd,PipeName);
    }

    //
    //Reset Colors
    //
    SetColor(csbiOriginal.wAttributes);
    SetConsoleTitle(szOrgTitle);

    ExitProcess(0);
	return( 1 );
}
/*************************************************************/
VOID
ErrorExit(
    TCHAR* str
    )
{
    _tprintf(TEXT("Error-%d:%s\n"),GetLastError(),str);
    ExitProcess(1);
}

/*************************************************************/
DWORD
ReadFixBytes(
    HANDLE hRead,
    TCHAR*  Buffer,
    DWORD  ToRead,
    DWORD  TimeOut   //ignore for timebeing
    )
{
    DWORD xyzBytesRead=0;
    DWORD xyzBytesToRead=ToRead;
    TCHAR* xyzbuff=Buffer;

    while(xyzBytesToRead!=0)
    {
        if (!ReadFile(hRead,xyzbuff,xyzBytesToRead,&xyzBytesRead,NULL))
        {
            return(xyzBytesToRead);
        }

        xyzBytesToRead-=xyzBytesRead;
        xyzbuff+=xyzBytesRead;
    }
    return(0);

}
/*************************************************************/

/*************************************************************/
DWORD
SockReadFixBytes(
    SOCKET hSocket,
    TCHAR*  Buffer,
    DWORD  ToRead,
    DWORD  TimeOut   //ignore for timebeing
    )
{
    DWORD xyzBytesRead=0;
    DWORD xyzBytesToRead=ToRead;
    TCHAR* xyzbuff=Buffer;

    while(xyzBytesToRead!=0)
    {
        if (!ReadSocket(hSocket,xyzbuff,xyzBytesToRead,&xyzBytesRead))
        {
            return(xyzBytesToRead);
        }

        xyzBytesToRead-=xyzBytesRead;
        xyzbuff+=xyzBytesRead;
    }
    return(0);

}
/*************************************************************/

VOID
DisplayClientHlp()
{
    _tprintf(TEXT("\n   To Start the CLIENT end of WSREMOTE\n"));
    _tprintf(TEXT("   ---------------------------------\n"));
    _tprintf(TEXT("   Syntax : WSREMOTE /C <ServerName> <Unique Id> [Param]\n"));
    _tprintf(TEXT("   Example: WSREMOTE /C iisdebug   70\n"));
    _tprintf(TEXT("            This would connect to a server session on \n"));
    _tprintf(TEXT("            iisdebug with id \"70\" if there was a\n"));
    _tprintf(TEXT("            WSREMOTE /S <\"Cmd\"> 70\n"));
    _tprintf(TEXT("            started on the machine iisdebug.\n\n"));
    _tprintf(TEXT("   To Exit: %cQ (Leaves the Remote Server Running)\n"),COMMANDCHAR);
    _tprintf(TEXT("   [Param]: /L <# of Lines to Get>\n"));
    _tprintf(TEXT("   [Param]: /F <Foreground color eg blue, lred..>\n"));
    _tprintf(TEXT("   [Param]: /B <Background color eg cyan, lwhite..>\n"));
	_tprintf(TEXT("   [Param]: /N (Connect over Named Pipes)\n"));
	_tprintf(TEXT("   [Param]: /U <Username> (Username to connect)\n"));
	_tprintf(TEXT("   [Param]: /P <Password> (Password to connect)\n"));
    _tprintf(TEXT("\n"));
}
/*************************************************************/

VOID
DisplayServerHlp()
{

#define WRITEF2(VArgs)            {                                                 \
                                    HANDLE xh=GetStdHandle(STD_OUTPUT_HANDLE);     \
                                    TCHAR   VBuff[256];                             \
                                    DWORD  tmp;                                    \
                                    _stprintf VArgs;                                 \
                                    WriteFile(xh,VBuff,lstrlen(VBuff),&tmp,NULL);   \
                                 }                                                 \


    _tprintf(TEXT("\n   To Start the SERVER end of WSREMOTE\n"));
    _tprintf(TEXT("   ---------------------------------\n"));
    _tprintf(TEXT("   Syntax : WSREMOTE /S <\"Cmd\"> <Unique Id or Port Number> [Param]\n"));
    _tprintf(TEXT("   Syntax : WSREMOTE /S <\"Cmd\"> <Unique Id or Port Number> [Param]\n"));
    _tprintf(TEXT("   Example: WSREMOTE /S \"cmd.exe\" inetinfo\n"));
    _tprintf(TEXT("            To interact with this \"Cmd\" \n"));
    _tprintf(TEXT("            from some other machine\n"));
    _tprintf(TEXT("            - start the client end by:\n"));
    _tprintf(TEXT("            REMOTE /C %s  PortNum\n\n"),HostName);
    _tprintf(TEXT("   To Exit: %cK \n"),COMMANDCHAR);
    _tprintf(TEXT("   [Param]: /F <Foreground color eg yellow, black..>\n"));
    _tprintf(TEXT("   [Param]: /B <Background color eg lblue, white..>\n"));
	_tprintf(TEXT("   [Param]: /I (Turns ON IP Blocking)\n"));
	_tprintf(TEXT("   [Param]: /U <Username> (Username to connect)\n"));
	_tprintf(TEXT("   [Param]: /P <Password> (Password to connect)\n"));
    _tprintf(TEXT("\n"));

}

WORD
GetColorNum(
    TCHAR *color
    )
{
    WORD wIndex;

    _tcslwr(color);
    for (wIndex=0;wIndex<16;wIndex++)
    {
        if (_tcscmp(ColorList[wIndex],color)==0)
        {
            return(wIndex);
        }
    }
    return ((WORD)_ttoi(color));
}

VOID
SetColor(
    WORD attr
    )
{
	COORD  origin={0,0};
    DWORD  dwrite;
    FillConsoleOutputAttribute
    (
    	MyOutHandle,attr,csbiOriginal.dwSize.
    	X*csbiOriginal.dwSize.Y,origin,&dwrite
    );
    SetConsoleTextAttribute(MyOutHandle,attr);
}

BOOL
GetNextConnectInfo(
    TCHAR** SrvName,
    TCHAR** PipeName
    )
{
    static TCHAR szServerName[64];
    static TCHAR szPipeName[32];
    TCHAR *s;

    __try
    {
        ZeroMemory(szServerName,64);
        ZeroMemory(szPipeName,32);
        SetConsoleTitle( TEXT("Remote - Prompting for next Connection"));
        _tprintf(TEXT("Debugger machine (server): "));
        fflush(stdout);

        if (((*SrvName=_getts(szServerName))==NULL)||
             (_tcslen(szServerName)==0))
        {
            return(FALSE);
        }

        if (szServerName[0] == COMMANDCHAR &&
            (szServerName[1] == 'q' || szServerName[1] == 'Q')
           )
        {
            return(FALSE);
        }

        if (s = _tcschr( szServerName, ' ' )) {
            *s++ = '\0';
            while (*s == ' ') {
                s += 1;
            }
            *PipeName=_tcscpy(szPipeName, s);
            _tprintf(szPipeName);
            fflush(stdout);
        }
        if (_tcslen(szPipeName) == 0) {
            _tprintf(TEXT("Debuggee machine : "));
            fflush(stdout);
            if ((*PipeName=_getts(szPipeName))==NULL)
            {
                return(FALSE);
            }
        }

        if (s = _tcschr(szPipeName, ' ')) {
            *s++ = '\0';
        }

        if (szPipeName[0] == COMMANDCHAR &&
            (szPipeName[1] == 'q' || szPipeName[1] == 'Q')
           )
        {
            return(FALSE);
        }
        _tprintf(TEXT("\n\n"));
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(FALSE);  // Ignore exceptions
    }
    return(TRUE);
}


/*************************************************************/
VOID
Errormsg(
    TCHAR* str
    )
{
    _tprintf(TEXT("Error (%d) - %s\n"),GetLastError(),str);
}

/*************************************************************/

BOOL ReadSocket(SOCKET s,TCHAR * buff,int len,DWORD* dread)
{
    BOOL    bRet    = FALSE;
    DWORD   numread;

#ifdef UNICODE
    char *	pszAnsiStr	= (char *)calloc( (len + 1), sizeof(char) );

    if (pszAnsiStr)
    {
        int nErr;
        numread = (DWORD)recv( s, pszAnsiStr, len, 0);

        if (SOCKET_ERROR != numread)
        {
            nErr    = MultiByteToWideChar(  CP_ACP,
                                            MB_PRECOMPOSED,
                                            pszAnsiStr,
                                            len,
                                            buff,
                                            len );

            if (nErr)
            {
                *dread  = numread;
                bRet    = TRUE;
            }

            //Base64Decode(buff,DecodeBuffer);
        }

        free( pszAnsiStr );
    }
#else
    numread = (DWORD)recv( s, buff, len, 0);

    if (SOCKET_ERROR != numread)
    {
        *dread  = numread;
        bRet    = TRUE;
    }

#endif
    return bRet;
}

// returns TRUE if successful, false otherwise
BOOL WriteSocket(
        SOCKET  s,
        TCHAR * buff,
        int     len,
        DWORD*  dsent)
{
    BOOL    bRet    = FALSE;
    DWORD   numsent;

#ifdef UNICODE

    int     nStrLen = lstrlen( buff );

    if (nStrLen)
    {
        char * pszAnsiStr   = (char *)malloc( nStrLen + 1 );

        if (pszAnsiStr)
        {
            int nErr    = WideCharToMultiByte(  CP_ACP,
                                                WC_COMPOSITECHECK,
                                                buff,
                                                nStrLen,
                                                pszAnsiStr,
                                                nStrLen,
                                                NULL,
                                                NULL );
            if (nErr)
            {
                numsent = (DWORD)send(s, pszAnsiStr, nStrLen, 0);
                if (SOCKET_ERROR != numsent)
                {
                    *dsent  = numsent;
                    bRet    = TRUE;
                }
            }

            //Base64Decode(buff,DecodeBuffer);
            free( pszAnsiStr );
        }
    }
#else
    numsent = (DWORD)send(s, buff, len, 0);
    if (SOCKET_ERROR != numsent)
    {
        *dsent  = numsent;
        bRet    = TRUE;
    }

#endif
    return  bRet;
}

#ifdef UNICODE
// returns TRUE if successful, false otherwise
BOOL WriteSocketA(
        SOCKET  s,
        char *  pszAnsiStr,
        int     len,
        DWORD * dsent)
{
    BOOL    bRet    = FALSE;
    DWORD   numsent;

    numsent = (DWORD)send(s, pszAnsiStr, len, 0);

    if (SOCKET_ERROR != numsent)
    {
        *dsent  = numsent;
        bRet    = TRUE;
    }

    //Base64Decode(buff,DecodeBuffer);
    return  bRet;
}
#endif

////////////////////////////////////////////////
unsigned char Base64Table[64] =
{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/'};

VOID
Base64Encode(
    TCHAR * String,
    DWORD StringLength,
    TCHAR * EncodeBuffer)
{
    DWORD  EncodeDword;
    int    Index;

    memset(EncodeBuffer, 0, 2 * StringLength);

    Index = 0;

    while (StringLength >= 3) {
        //
        // Encode a three byte chunk
        //

        EncodeDword = (String[0] << 16) & 0xff0000;

        EncodeDword += (String[1] << 8) & 0xff00;

        EncodeDword += String[2] & 0xff;

        EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 18) & 63];
        EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 12) & 63];
        EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 6) & 63];
        EncodeBuffer[Index++] = Base64Table[EncodeDword & 63];

        String += 3;
        StringLength -= 3;
    }

    switch (StringLength) {
        case 1:
            EncodeDword = (String[0] << 16) & 0xff0000;
            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 18) & 63];
            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 12) & 63];
            EncodeBuffer[Index++] = '=';
            EncodeBuffer[Index++] = '=';
            break;
        case 2:
            EncodeDword = (String[0] << 16) & 0xff0000;
            EncodeDword += (String[1] << 8) & 0xff00;

            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 18) & 63];
            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 12) & 63];
            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 6) & 63];
            EncodeBuffer[Index++] = '=';
            break;
    }

    EncodeBuffer[Index] = 0;

    return;
}
int
GetBase64Index(
    TCHAR A)
{
    int i;

    for (i=0; i<64; i++) {
        if (Base64Table[i] == A) {
            return i;
        }
    }

    return -1;
}
VOID
Base64Decode(
    TCHAR * String,
    TCHAR * DecodeBuffer)
{
    DWORD  DecodeDword;
    int    Index = 0;

    memset(DecodeBuffer, 0, _tcslen(String));

    if (_tcslen(String) % 4) {
        printf("WCAT INTERNAL ERROR %s %d\n", __FILE__, __LINE__);
        return;
    }

    while (*String) {
        //
        // Decode a four byte chunk
        //

        if (GetBase64Index(String[0]) < 0) {
            //
            // Invalid string
            //

            printf("WCAT INTERNAL ERROR %s %d\n", __FILE__, __LINE__);
            return;
        }

        DecodeDword = ((unsigned int) GetBase64Index(String[0])) << 18;

        if (GetBase64Index(String[1]) >= 0) {
            //
            // still more characters
            //

            DecodeDword += ((unsigned int) GetBase64Index(String[1])) << 12;
            if (GetBase64Index(String[2]) >= 0) {
                //
                // still more characters
                //

                DecodeDword += ((unsigned int) GetBase64Index(String[2])) << 6;
                if (GetBase64Index(String[3]) >= 0) {
                    //
                    // still more characters
                    //

                    DecodeDword += (unsigned int) GetBase64Index(String[3]);
                    DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 16) & 0xff);
                    DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 8) & 0xff);
                    DecodeBuffer[Index++] = (unsigned char) (DecodeDword & 0xff);
                } else {
                    DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 16) & 0xff);
                    DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 8) & 0xff);
                }
            } else {
                DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 16) & 0xff);
            }
        }

        String += 4;
    }

    return;
}

VOID
SplitUserName(
    TCHAR * FullName,
    TCHAR * Domain,
    TCHAR * UserName)
{
    TCHAR * Slash;
    Slash = _tcsstr(FullName, TEXT(":"));

    if (Slash) {
        // there is a domain name

        *Slash = 0;
        _tcscpy(Domain, FullName);
        _tcscpy(UserName, Slash+1);
        *Slash = ':';
    } else {
        *Domain = 0;
        _tcscpy(UserName, FullName);
    }
}

#ifdef UNICODE

// caller must free buffer
WCHAR * inet_ntoaw(
    struct in_addr stInet
)
{
    char *  pszAnsiInetStr  = inet_ntoa( stInet );

    int nStrLen = strlen( pszAnsiInetStr );

    WCHAR * pszInetStr  = (WCHAR *)calloc( (nStrLen + 1), sizeof( TCHAR ));

    int nErr    = MultiByteToWideChar(  CP_ACP,
                                        MB_PRECOMPOSED,
                                        pszAnsiInetStr,
                                        nStrLen,
                                        pszInetStr,
                                        nStrLen );

    if (!nErr)
    {
        free( pszInetStr );
        pszInetStr  = NULL;
    }

    return pszInetStr;
}

BOOL ReadFileW(
    HANDLE          hFile,      // handle of file to read
    WCHAR *         pszBuffer,  // pointer to buffer that receives data
    DWORD           dwLength,   // number of bytes to read
    LPDWORD         pdwRead,    // pointer to number of bytes read
    LPOVERLAPPED    pData       // pointer to structure for data
)
{
    BOOL    bRet    = FALSE;
    char *  pszAnsi = (char *)calloc( dwLength + 1, sizeof(char *));

    if (pszAnsi)
    {
        bRet    = ReadFile( hFile,
                            pszAnsi,
                            dwLength,
                            pdwRead,
                            pData);

        if (bRet)
        {
            int nErr    = MultiByteToWideChar(  CP_ACP,
                                                MB_PRECOMPOSED,
                                                pszAnsi,
                                                *pdwRead,
                                                pszBuffer,
                                                *pdwRead );

            if (!nErr)
            {
                bRet    = FALSE;
            }
        }

        free( pszAnsi );
    }

    return bRet;
}

BOOL WriteFileW(
    HANDLE          hFile,      // handle to file to write to
    WCHAR *         pszBuffer,  // pointer to data to write to file
    DWORD           dwWrite,    // number of bytes to write
    LPDWORD         pdwWritten, // pointer to number of bytes written
    LPOVERLAPPED    pData       // pointer to structure for overlapped I/O
)
{
    BOOL    bRet    = FALSE;
    int     nStrLen = lstrlen( pszBuffer );

    if (nStrLen)
    {
        char * pszAnsiStr   = (char *)malloc( nStrLen + 1 );

        if (pszAnsiStr)
        {
            int nErr    = WideCharToMultiByte(  CP_ACP,
                                                WC_COMPOSITECHECK,
                                                pszBuffer,
                                                nStrLen,
                                                pszAnsiStr,
                                                nStrLen,
                                                NULL,
                                                NULL );
            if (nErr)
            {
                bRet    = WriteFile(    hFile,
                                        pszAnsiStr,
                                        dwWrite,
                                        pdwWritten,
                                        pData);
            }

            free( pszAnsiStr );
        }
    }

    return bRet;
}

// caller most free buffer
BOOL    GetAnsiStr(
    WCHAR * pszWideStr,
    char *  pszAnsiStr,
    UINT    uBufSize
)
{
    BOOL    bRet    = FALSE;
    if (pszWideStr && pszAnsiStr)
    {
        int     nStrLen = lstrlen( pszWideStr );

        if (nStrLen)
        {
            int nErr    = WideCharToMultiByte(  CP_ACP,
                                                WC_COMPOSITECHECK,
                                                pszWideStr,
                                                nStrLen,
                                                pszAnsiStr,
                                                uBufSize - 1,
                                                NULL,
                                                NULL );
            if (nErr)
            {
                pszAnsiStr[nStrLen] = '\0';
                bRet    = TRUE;
            }
        }
    }
    return  bRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wsremote\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wsremote.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wsremote\remote.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       remote.h
//
//--------------------------------------------------------------------------

#ifndef __WSREMOTE_H__
#define __WSREMOTE_H__

#include <winsock2.h>
#include <tchar.h>

#define VERSION             7
#define REMOTE_SERVER       1
#define REMOTE_CLIENT       2

#define SERVER_READ_PIPE    TEXT("\\\\%s\\PIPE\\%sIN")   //Client Writes and Server Reads
#define SERVER_WRITE_PIPE   TEXT("\\\\%s\\PIPE\\%sOUT")  //Server Reads  and Client Writes

#define COMMANDCHAR         '@' //Commands intended for remote begins with this
#define CTRLC               3

#define CLIENT_ATTR         FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_RED|BACKGROUND_BLUE
#define SERVER_ATTR         FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE|BACKGROUND_RED

//
//Some General purpose Macros
//
#define MINIMUM(x,y)          ((x)>(y)?(y):(x))
#define MAXIMUM(x,y)          ((x)>(y)?(x):(y))

#define ERRORMSSG(str)      _tprintf(TEXT("Error %d - %s [%s %d]\n"),GetLastError(),str,__FILE__,__LINE__)
#define SAFECLOSEHANDLE(x)  {if (x!=INVALID_HANDLE_VALUE) {CloseHandle(x);x=INVALID_HANDLE_VALUE;}}


                                    // All because printf does not work
                                    // with NT IO redirection
                                    //

#define WRITEF(VArgs)            {                                                 \
                                    HANDLE xh=GetStdHandle(STD_OUTPUT_HANDLE);     \
                                    TCHAR   VBuff[256];                             \
                                    DWORD  tmp;                                    \
                                    _stprintf VArgs;                                 \
                                    WriteFile(xh,VBuff,lstrlen(VBuff),&tmp,NULL);   \
                                 }                                                 \

#define HOSTNAMELEN         16

#define CHARS_PER_LINE      45

#define MAGICNUMBER     0x31109000
#define BEGINMARK       '\xfe'
#define ENDMARK         '\xff'
#define LINESTOSEND     200

#define MAX_SESSION     10

typedef struct
{
    DWORD    Size;
    DWORD    Version;
    TCHAR     ClientName[15];
    DWORD    LinesToSend;
    DWORD    Flag;
}   SESSION_STARTUPINFO;

typedef struct
{
    DWORD MagicNumber;      //New Remote
    DWORD Size;             //Size of structure
    DWORD FileSize;         //Num bytes sent
}   SESSION_STARTREPLY;

typedef struct
{
    TCHAR    Name[HOSTNAMELEN];     //Name of client Machine;
    BOOL    Active;         //Client at the other end connected
    BOOL    CommandRcvd;    //True if a command recieved
    BOOL    SendOutput;     //True if Sendoutput output
    HANDLE  PipeReadH;      //Client sends its StdIn  through this
    HANDLE  PipeWriteH;     //Client gets  its StdOut through this
    HANDLE  rSaveFile;      //Sessions read handle to SaveFile
    HANDLE  hThread;        //Session Thread
    HANDLE  MoreData;       //Event handle set if data available to be read
	SOCKET	Socket;			//Socket for IP Session
	TCHAR    szIP[16];			//IP Address of Client, if NOT IP then NULL
} SESSION_TYPE;



VOID
Server(
    TCHAR* ChildCmd,
    TCHAR* PipeName
    );


VOID
Client(
    TCHAR* ServerName,
    TCHAR* PipeName
    );

VOID
SockClient(
    TCHAR* ServerName,
    TCHAR* PipeName
    );

VOID
ErrorExit(
    TCHAR* str
    );

VOID
DisplayClientHlp(
    );

VOID
DisplayServerHlp(
    );

ULONG
DbgPrint(
    PCH Format,
    ...
    );

DWORD
ReadFixBytes(
    HANDLE hRead,
    TCHAR   *Buffer,
    DWORD  ToRead,
    DWORD  TimeOut   //ignore for timebeing
    );

DWORD
SockReadFixBytes(
    SOCKET hSocket,
    TCHAR   *Buffer,
    DWORD  ToRead,
    DWORD  TimeOut   //ignore for timebeing
    );

VOID
Errormsg(
    TCHAR* str
    );

BOOL ReadSocket(
		SOCKET s,
		TCHAR * buff,
		int len,
		DWORD* dread);

BOOL WriteSocket(
        SOCKET  s,
        TCHAR * buff,
        int     len,
        DWORD*  dsent);

VOID
Base64Encode(
    TCHAR * String,
    DWORD StringLength,
    TCHAR * EncodeBuffer);

VOID
Base64Decode(
    TCHAR * String,
    TCHAR * DecodeBuffer);

int
GetBase64Index(
    TCHAR A);

VOID
SplitUserName(
    TCHAR * FullName,
    TCHAR * Domain,
    TCHAR * UserName);

#ifdef UNICODE
BOOL WriteSocketA(
        SOCKET  s,
        char *  pszAnsiStr,
        int     len,
        DWORD * dsent);

// caller must free buffer
WCHAR * inet_ntoaw(
    struct in_addr stInet );

BOOL ReadFileW(
    HANDLE          hFile,      // handle of file to read
    WCHAR *         pszBuffer,  // pointer to buffer that receives data
    DWORD           dwLength,   // number of bytes to read
    LPDWORD         pdwRead,    // pointer to number of bytes read
    LPOVERLAPPED    pData       // pointer to structure for data
);

BOOL WriteFileW(
    HANDLE          hFile,      // handle to file to write to
    WCHAR *         pszBuffer,  // pointer to data to write to file
    DWORD           dwWrite,    // number of bytes to write
    LPDWORD         pdwWritten, // pointer to number of bytes written
    LPOVERLAPPED    pData       // pointer to structure for overlapped I/O
);

BOOL    GetAnsiStr(
    WCHAR * pszWideStr,
    char *  pszAnsiStr,
    UINT    uBufSize
);

#endif UNICODE

extern TCHAR   HostName[HOSTNAMELEN];
extern TCHAR*  ChildCmd;
extern TCHAR*  PipeName;
extern TCHAR*  ServerName;
extern TCHAR*  Username;
extern TCHAR*  Password;
extern HANDLE MyOutHandle;
extern DWORD  LinesToSend;
extern BOOL   IsAdvertise;
extern BOOL   bIPLocked;
extern DWORD  ClientToServerFlag;

#endif //__WSREMOTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wsfslib\wserror.h ===
/*
 * Module Name:  WSERROR.H
 *
 * Description:
 *
 * Working set tuner error message include file.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 *						
 */


/*
 *	Constant definitions.
 */
#ifdef	ERROR
#undef	ERROR
#endif
#define ERROR		1		/* Exit processing codes */
#define NOEXIT 		0xFFFF	
#define NO_MSG		FALSE
#define PRINT_MSG	TRUE
					/* Message defines */
#define MSG_BUFFER_SIZE	0
#define MSG_DYNTRC	1
#define MSG_FILE_CREATE	2
#define MSG_FILE_OPEN	3
#define MSG_FILE_OFFSET	4
#define MSG_FILE_READ	5
#define MSG_FILE_WRITE	6
#define MSG_SEM_CREATE	7
#define MSG_SEM_OPEN	8
#define MSG_SEM_ACQUIRE	9
#ifdef SHM_USED
#define MSG_SHM_CREATE	10
#define MSG_SHM_ACCESS	11
#endif /* SHM_USED */
#define MSG_FILE_BAD_HDR 12
#define MSG_NO_MEM	 13
#define MSG_EXEC_PGM	 14
#define MSG_TRACE_ON	 15
#define MSG_TRACE_OFF	 16
#define MSG_WSINFO_ON	 17
#define MSG_WSPREPRO	 18
#define MSG_WSPDUMP	 19
#define MSG_WSREDUCE	 20

// These messages are order dependent; they must correspond to the 'MSG_'
// definitions above.
static CHAR	*pchMsg[] = {
	"%s %s:  WARNING - RESULT BUFFER TOO SMALL (0x%lx BYTES) %s\n",
	"%s %s:  FATAL ERROR (%d) FROM DOSDYNAMICTRACE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT CREATE FILE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT OPEN FILE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT SET POINTER FOR FILE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT READ FILE %s (POSSIBLY CORRUPT)\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT WRITE FILE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT CREATE SEMAPHORE NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT OPEN SEMAPHORE NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT ACQUIRE SEMAPHORE NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT CREATE SHARED MEMORY NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT ACCESS SHARED MEMORY NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - BAD FILE HEADER %s\n",
	"%s %s:  FATAL ERROR  - COULD NOT ALLOCATE (%ld BYTES) MEMORY FOR %s\n",
	"%s %s:  FATAL ERROR (%d) - Dos32ExecPgm(%s)\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT INSERT TRACEPOINTS IN %s\n",
	"%s %s:  WARNING (%d) - COULD NOT REMOVE TRACEPOINTS FROM %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT COLLECT DATA, %s FAILED\n",
	"%s %s:  ERROR (%d) - COULD NOT POSTPROCESS .WSI FILE, %s FAILED\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT DUMP WSP DATA, %s FAILED\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT REDUCE WSP DATA, %s FAILED\n",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wsfslib\wsexport.h ===
/*
 * Module Name:  WSEXPORT.H
 *
 * Description:
 *
 * Working set tuner include file for WSINFO and WSEXPORT.  Contains 
 * common constant definitions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 *						
 */


/*
 *	Constant definitions.
 */

#define DEFAULT_DELAY	0	/* Defaults for command line arguments */
#define DEFAULT_RATE	1000	
#define DEFAULT_BUFSZ	0x100000
#define DEFAULT_SNAPS	0

#define TIMEOUT		1000	/* Default timeout value */

#define WSINFO_ON	1	/* Defines for argv[1] */
#define WSINFO_OFF	0
#define WSINFO_PAUSE	2
#define WSINFO_RESUME	3
#define WSINFO_QUERY	4
#define WSINFO_MAX	5

#define SEM_ACQUIRED	0x1	/* Resource definitions */
#define SEM_OPEN	0x2
#ifdef SHM_USED
#define SHM_OPEN	0x4
#endif /* SHM_USED */



/*
 *	Function prototypes.
 */

USHORT FAR PASCAL WsInfoOn( VOID );
USHORT FAR PASCAL WsInfoOff( VOID );
USHORT FAR PASCAL WsInfoPause( VOID );
USHORT FAR PASCAL WsInfoResume( VOID );
USHORT FAR PASCAL WsInfoQuery( VOID );
USHORT FAR PASCAL WsInfoInit( PSZ, PSZ, PSZ, ULONG, ULONG, ULONG, BOOL, BOOL );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wsfslib\wsdata.h ===
/*
 * Module Name:  WSDATA.H
 *
 * Description:
 *
 * Working set tuner include file.  Contains common structure
 * declarations and constant definitions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987-1998
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 * 04/16/98 - QFE DerrickG (mdg):
 *            - modified dtqo_s.dtqo_resv from "unsigned short" to "unsigned long"
 *              to accommodate large symbol counts
 *						
 */

/*
 *	Constant definitions.
 */

#define NUM_VAR_BITS	(sizeof(ULONG) << 3)

#ifdef TMIFILEHACK
#define	MAXLINE	80
#endif /* TMIFILEHACK */

/*
 *	    Type definitions and structure declarations.
 */

typedef ULONG	fxnbits_t;

struct	dtqo_s	{
	unsigned long	dtqo_hMTE;	 /* MTE handle			*/
	unsigned short	dtqo_usID;	 /* Identifier			*/
	unsigned long	dtqo_resv;	 /* Reserved			*/ // mdg 98/4
	unsigned long	dtqo_cbPathname; /* Module pathname length	*/
	unsigned long	dtqo_clVar;	 /* Number of dyntrc variables	*/
};

typedef struct	dtqo_s	dtqo_t;


/*
 * WSI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      sentinel 0 (dtgp_s)              | <----------
 *	|=======================================|           |
 *	|      snapshot 0 (dtgp_s) for module X |           | S
 *	|---------------------------------------|           | n
 *	|      dynamic trace variables for X    |           | a
 *	|---------------------------------------|           | p
 *	|      snapshot 0 (dtgp_s) for module Y |           | s
 *	|---------------------------------------|           | h
 *	|      dynamic trace variables for Y    |           | o
 *	|---------------------------------------|           | t
 *	|               etc.                    |           |
 *	|=======================================|           | D
 *	|      sentinel 1 (dtgp_s)              |           | a
 *	|=======================================|           | t
 *	|      snapshot 1 (dtgp_s) for module X |           | a
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for X    |           |
 *	|---------------------------------------|           |
 *	|      snapshot 1 (dtgp_s) for module Y |           |
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for Y    |           |
 *	|---------------------------------------|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      sentinel 2 (dtgp_s)              |           |
 *	|=======================================|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      end sentinel (dtgp_s)            |           |
 *	|_______________________________________| <----------
 *	|_______________________________________|
 *	|                                       | <---------- Q
 *	|      dtqo_s for module X              |           | u
 *	|---------------------------------------|           | e
 *	|      module X pathname string         |           | r
 *	|=======================================|           | y
 *	|      dtqo_s for module Y              |           |  
 *	|---------------------------------------|           | I
 *	|      module Y pathname string         |           | n
 *	|=======================================|           | f
 *	|               etc.                    | <---------- o
 *	|=======================================|            
 *	|_______________________________________|
 *	
 */


				/* WSI file header format */
struct wsihdr_s {
	CHAR	wsihdr_chSignature[4];	// file signature
	ULONG	wsihdr_ulLevel;		// format level
	ULONG	wsihdr_ulTimeStamp;	// time stamp
	ULONG	wsihdr_ulOffGetvar;	// offset to DT_GETVAR data
	ULONG	wsihdr_ulOffQuery;	// offset to DT_QUERY data
	ULONG	wsihdr_cbFile;		// size of file (in bytes)
	ULONG	wsihdr_ulSnaps;		// number of snapshots
};

typedef struct wsihdr_s wsihdr_t;

/*
 * WSP file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsphdr_s                 |
 *	|---------------------------------------|
 *	|         module pathname array         |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 bitstring            | 
 *      |      (rounded to DWORD boundary)      |
 *	|=======================================|
 *	|      function #1 bitstring            | 
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* WSP file header format */
struct wsphdr_s {
	CHAR	wsphdr_chSignature[4];	// file signature
	ULONG	wsphdr_ulTimeStamp;	// time stamp
	dtqo_t	wsphdr_dtqo;		// query info
	ULONG	wsphdr_ulOffBits;	// offset to first bitstring
	ULONG	wsphdr_ulSnaps;		// number of snapshots
	/* followed by module pathname char array, length specified in dtqo */
};

typedef struct wsphdr_s wsphdr_t;


/*
 * TMI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              tmihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 tmirec_s             | 
 *	|---------------------------------------|
 *	|      function #0 name array           |
 *	|=======================================|
 *	|      function #1 tmirec_s             | 
 *	|---------------------------------------|
 *	|      function #1 name array           |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* TMI file header. */
typedef struct  tmihdr_s {
            CHAR    tmihdr_chSignature[4]; // "TMI\0"               
            USHORT  tmihdr_usMajor;        // Range 0x0001 to 0x00FF 
            USHORT  tmihdr_cTmiRec;        // Number of tmirec in file
            CHAR    tmihdr_chModName[256]; // Name of traced module    
            USHORT  tmihdr_usID;           // Module identifier         
            CHAR    tmihdr_resv[30];       // Reserved                   
};

typedef struct tmihdr_s tmihdr_t;

				/* Per-function information from TMI file */
struct tmirec_s {
	ULONG	tmirec_ulFxnBit;	// function's bit reference position
	ULONG	tmirec_usFxnAddrObj;	// object portion of function address
	ULONG	tmirec_ulFxnAddrOff;	// offset portion of function address
	ULONG	tmirec_cbFxn;		// size of function (in bytes)
	USHORT	tmirec_cbFxnName;	// size in bytes of function name
	CHAR	tmirec_FxnName[1];	// bytes of function name start here 
};

typedef struct tmirec_s tmirec_t;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wsremote\server.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    Server.c

Abstract:

    The server component of Remote. It spawns a child process
    and redirects the stdin/stdout/stderr of child to itself.
    Waits for connections from clients - passing the
    output of child process to client and the input from clients
    to child process.

Author:

    Rajivendra Nath (rajnath) 2-Jan-1992

Environment:

    Console App. User mode.

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "Remote.h"


#define MAX_SESSION   10

#define COMMANDFORMAT     TEXT("%c%-15s    [%-15s %s]\n%c")
#define LOCALNAME         TEXT("Local")
#define LOCALCLIENT(x)    (strcmp((char *)(x->Name),LOCALNAME)==0)
#define RemoteInfo(prt,flg) {if (!(flg&&0x80000000)) prt;}


#define CMDSTRING(OutBuff,InpBuff,Client,szTime)  {                              \
                                                    _stprintf                      \
                                                    (                            \
                                                       &OutBuff[0],COMMANDFORMAT,\
                                                       BEGINMARK,InpBuff,        \
                                                       Client->Name,szTime,      \
                                                       ENDMARK                   \
                                                    );                           \
                                                 }                               \

#ifdef UNICODE
int MakeCommandString(
    TCHAR * pszOutput,
    TCHAR * pszInput,
    TCHAR * pszName,
    TCHAR * pszTime);
#endif

#define BUFFSIZE      256

#ifdef INTERNALUSECOMPONENT
VOID InitAd(BOOL IsAdvertise);
VOID ShutAd(BOOL IsAdvertise);
#endif

static SOCKET listenSocket;
SESSION_TYPE ClientList[MAX_SESSION];


HANDLE  ChildStdInp;     //Server Writes to  it
HANDLE  ChildStdOut;     //Server Reads from it
HANDLE  ChildStdErr;     //Server Reads from it

HANDLE  SaveFile;       //File containing all that was
                        //output by child process.
                        //Each connection opens a handle to this file
                        //and is sent through PipeWriteH.

TCHAR   SaveFileName[MAX_PATH+1]; //Name of above file - all new sessions need
HANDLE  ChldProc;
HANDLE  ListenThreadH;
HANDLE  SockListenThreadH;

// GetFormattedTime -- returns pointer to formatted time
//
// returns pointer to static buffer which should be OK.
//


TCHAR * GetFormattedTime(VOID)
{
    static TCHAR    szTime[30];

    //
    // Get time and format to characters
    //

    GetTimeFormat( LOCALE_USER_DEFAULT,
                   TIME_NOSECONDS | TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER,
                   NULL,   // use current time
                   NULL,   // use default format
                   szTime,
                   30 );

    return( (TCHAR *)&szTime );
}


HANDLE
ForkChildProcess(          // Creates a new process
    TCHAR *cmd,             // Redirects its stdin,stdout
    PHANDLE in,            // and stderr - returns the
    PHANDLE out,           // corresponding pipe ends.
    PHANDLE err
    );

HANDLE
OldForkChildProcess(       //Same as above except different
    TCHAR *cmd,             //method for redirection...for
    PHANDLE in,            //compatibility with.
    PHANDLE out,
    PHANDLE err
    );


DWORD
ListenForSession(          //THREAD:Listens for new connections and
    TCHAR * pipe             //spawns of new seesions - Updates the
    );                     //Status in Client DataStructure.



DWORD
NewSession(                //Manages the session with a client.
    SESSION_TYPE* Client
    );

DWORD                      //2 THREAD:Each reads either
GetChldOutput(             //StdOut or StdErr of child and
    HANDLE rhandle          //writes to SaveFile.
    );



DWORD
TransferFileToClient(      //X THREADS:Reads the save
    SESSION_TYPE* Client        //file and sendsoutput to a client.
    );


DWORD
GetClientInput(            //X THREADS:Gets input from Child pipe
    SESSION_TYPE* Client       //and sends to childs StdIn.
    );

BOOL
FilterCommand(             //Filters input from client
    SESSION_TYPE *cl,      //for commands intended for REMOTE
    TCHAR *buff,
    int dread
    );

DWORD
LocalSession(
    PVOID noarg
    );

DWORD
RemoteSession(
    SESSION_TYPE* Client
    );

BOOL
SrvCtrlHand(
    DWORD event
    );

VOID
SendStatus(
    HANDLE hClientPipe
    );

VOID
SockSendStatus(
    SOCKET MySocket
    );

DWORD
ShowPopup(
    TCHAR *mssg
    );

VOID
RemoveInpMark(
    TCHAR* Buff,
    DWORD Size
    );

VOID
CloseClient(
    SESSION_TYPE *Client
    );

VOID
InitClientList(
    );

/*************************************************************/
/*************************************************************/

DWORD
SockListenForSession(          //THREAD:Listens for new connections and
    TCHAR* pipe             //spawns of new seesions - Updates the
    );                     //Status in Client DataStructure.

DWORD
SockNewSession(                //Manages the session with a client.
    SESSION_TYPE* Client
    );

DWORD
SockTransferFileToClient(      //X THREADS:Reads the save
    SESSION_TYPE* Client        //file and sendsoutput to a client.
    );

DWORD
SockRemoteSession(
    SESSION_TYPE* Client
    );

DWORD
SockGetClientInput(            //X THREADS:Gets input from Child pipe
    SESSION_TYPE* Client       //and sends to childs StdIn.
    );

BOOL
SockAuthenticate(
    SOCKET MySocket
    );
/*************************************************************/
/*************************************************************/


/*************************************************************/
VOID
Server(                    //Main routine for server.
    TCHAR* ChildCmd,
    TCHAR* PipeName
    )
{
    WORD wVersionRequested = MAKEWORD(1,1);
    WSADATA wsaData;

    DWORD  ThreadID ;//No use
    HANDLE WaitH[3];
    DWORD  WaitObj;
    TCHAR   tmpdir[MAX_PATH+1];
    int nRet;

    _tprintf(TEXT("**************************************\n")
             TEXT("***********    WSREMOTE   ************\n")
             TEXT("***********     SERVER    ************\n")
             TEXT("**************************************\n")
             TEXT("To Connect: WSRemote /C %s %s\n\n"),HostName,PipeName);

    InitClientList();

    //
    // Initialize WinSock
    //
    nRet = WSAStartup(wVersionRequested, &wsaData);
    if (nRet)
    {
        _tprintf(TEXT("Initialize WinSock Failed"));
        return ;
    }
    // Check version
    if (wsaData.wVersion != wVersionRequested)
    {
        _tprintf(TEXT("Wrong WinSock Version"));
        return;
    }

    //
    // set environment variable
    //

    SetEnvironmentVariable(TEXT("_REMOTE"), PipeName);

    //
    //Start the command as a child process
    //

    ChldProc=ForkChildProcess(ChildCmd,&ChildStdInp,&ChildStdOut,&ChildStdErr);

    //
    //Create a tempfile for storing Child process output.
    //
    {
         DWORD rc = GetTempPath(sizeof(tmpdir),tmpdir);
         if (!rc || rc > sizeof(tmpdir))
         {
            _stprintf(tmpdir,TEXT("%s"),TEXT("."));
         }
         if (!GetTempFileName(tmpdir,TEXT("REMOTE"),0,SaveFileName))
              GetTempFileName(TEXT("."),TEXT("REMOTE"),0,SaveFileName);
    }


    if ((SaveFile=CreateFile(
                             (LPCTSTR)SaveFileName,           /* address of name of the file  */           \
                             GENERIC_READ|GENERIC_WRITE,      /* access (read/write) mode */               \
                             FILE_SHARE_READ|FILE_SHARE_WRITE,/* share mode   */                           \
                             (LPSECURITY_ATTRIBUTES)NULL,     /* security descriptor  */                   \
                             CREATE_ALWAYS,                   /* how to create    */                       \
                             FILE_ATTRIBUTE_NORMAL,           /* File Attribute */                    /* file attributes  */                       \
                             (HANDLE)NULL))==NULL)
    {
        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Could not Create Output File"));
    }


    //
    //Start 2 threads to save the output from stdout and stderr of cmd to savefile.
    //

    if ((WaitH[0]=CreateThread(
                     (LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
                     (DWORD)0,                              // Use same stack size.
                     (LPTHREAD_START_ROUTINE)GetChldOutput, // Thread procedure.
                     (LPVOID)ChildStdErr,                   // Parameter to pass.
                     (DWORD)0,                              // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed to Create GetGhldOutput#1 Thread"));
    }


    if ((WaitH[1]=CreateThread(
                     (LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
                     (DWORD)0,                              // Use same stack size.
                     (LPTHREAD_START_ROUTINE)GetChldOutput, // Thread procedure.
                     (LPVOID)ChildStdOut,                   // Parameter to pass.
                     (DWORD)0,                              // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed to Create GetGhldOutput#2 Thread"));
    }


    //
    //Start Thread to listen for new Connections
    //

    if ((ListenThreadH=CreateThread((LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                     (DWORD)0,                           // Use same stack size.
                     (LPTHREAD_START_ROUTINE)ListenForSession, // Thread procedure.
                     (LPVOID)PipeName,       // Parameter to pass.
                     (DWORD)0,                           // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed To Create ListenForSession Thread"));

    }


    //
    //Start Thread to listen for new Connections
    //

    if ((SockListenThreadH=CreateThread((LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                     (DWORD)0,                           // Use same stack size.
                     (LPTHREAD_START_ROUTINE)SockListenForSession, // Thread procedure.
                     (LPVOID)PipeName,       // Parameter to pass.
                     (DWORD)0,                           // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed To Create SockListenForSession Thread"));

    }

    //
    //Start Local Thread
    //

    if ((ClientList[0].hThread=CreateThread((LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                    (DWORD)0,                           // Use same stack size.
                    (LPTHREAD_START_ROUTINE)LocalSession, // Thread procedure.
                    (LPVOID)NULL,        // Parameter to pass.
                    (DWORD)0,                           // Run immediately.
                    (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed To Create ListenForSession Thread"));

    }

    SetConsoleCtrlHandler((PHANDLER_ROUTINE)SrvCtrlHand,TRUE);

#ifdef INTERNALUSECOMPONENT
    InitAd(IsAdvertise);
#endif

    WaitH[2]=ChldProc;
    WaitObj=WaitForMultipleObjects(3,WaitH,FALSE,INFINITE);
    switch (WaitObj-WAIT_OBJECT_0)
    {
        case 0:      // Error Writing to savefile
        case 1:
            TerminateProcess(ChldProc,0);
            break;
        case 2:      // Child Proc Terminated
            break;

        default:     // Out of Some Resource
            _tprintf(TEXT("Out of Resource Error %d..Terminating\n"),GetLastError());
            break;

    }

    TerminateThread(ListenThreadH,0);
    // SOCK:
    TerminateThread(SockListenThreadH,0);

#ifdef INTERNALUSECOMPONENT
    ShutAd(IsAdvertise);
#endif


    CloseHandle(ChildStdInp);
    CloseHandle(ChildStdOut);
    CloseHandle(ChildStdErr);

     //WSACleanup
    WSACleanup();
    _tprintf(TEXT("\nCalling WSACleanup()..\n"));

    _tprintf(TEXT("\nRemote:Parent exiting. Child(%s) dead..\n"),ChildCmd);

    CloseHandle(SaveFile);

    {
        int i;
        for (i=0;i<MAX_SESSION;i++)
            CloseClient(&ClientList[i]);
    }

    if (!DeleteFile(SaveFileName))
          _tprintf(TEXT("Temp File %s not deleted..\n"),SaveFileName);

    return;
}
/*************************************************************/
HANDLE
ForkChildProcess(          // Creates a new process
    TCHAR *cmd,             // Redirects its stdin,stdout
    PHANDLE inH,            // and stderr - returns the
    PHANDLE outH,           // corresponding pipe ends.
    PHANDLE errH
    )

{
    SECURITY_ATTRIBUTES lsa;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    HANDLE ChildIn;
    HANDLE ChildOut;
    HANDLE ChildErr;

    lsa.nLength=sizeof(SECURITY_ATTRIBUTES);
    lsa.lpSecurityDescriptor=NULL;
    lsa.bInheritHandle=TRUE;

    //
    //Create Parent_Write to ChildStdIn Pipe
    //

    if (!CreatePipe(&ChildIn,inH,&lsa,0))
        ErrorExit(TEXT("Could Not Create Parent-->Child Pipe"));

    //
    //Create ChildStdOut to Parent_Read pipe
    //

    if (!CreatePipe(outH,&ChildOut,&lsa,0))
        ErrorExit(TEXT("Could Not Create Child-->Parent Pipe"));

    //
    //Create ChildStdOut to Parent_Read pipe
    //

    if (!CreatePipe(errH,&ChildErr,&lsa,0))
        ErrorExit(TEXT("Could Not Create Child-->Parent Pipe"));

    //
    // Lets Redirect Console StdHandles - easy enough
    //


    si.cb=sizeof(STARTUPINFO);
    si.lpReserved=NULL;
    si.lpTitle=NULL;
    si.lpDesktop=NULL;
    si.dwX=si.dwY=si.dwYSize=si.dwXSize=0;
    si.dwFlags=STARTF_USESTDHANDLES;
    si.hStdInput =ChildIn;
    si.hStdOutput=ChildOut;
    si.hStdError =ChildErr;
    si.wShowWindow=SW_SHOW;
    si.lpReserved2=NULL;
    si.cbReserved2=0;

    //
    //Create Child Process
    //

    if (!CreateProcess( NULL,
                cmd,
                NULL,
                NULL,
                TRUE,
                NORMAL_PRIORITY_CLASS,
                NULL,
                NULL,
                &si,
                &pi))
    {
        if (GetLastError()==2)
            _tprintf(TEXT("Executable %s not found\n"),cmd);
        ErrorExit(TEXT("Could Not Create Child Process"));
    }

    //
    //Close unneccesary Handles and Restore the crt handles
    //

    CloseHandle(ChildIn);
    CloseHandle(ChildOut);
    CloseHandle(ChildErr);

    return(pi.hProcess);
}
/*************************************************************/
HANDLE
OldForkChildProcess(
    TCHAR *cmd,
    PHANDLE inH,
    PHANDLE outH,
    PHANDLE errH
    )
{
    SECURITY_ATTRIBUTES lsa;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    HANDLE OldStdIn =GetStdHandle(STD_INPUT_HANDLE);
    HANDLE OldStdOut=GetStdHandle(STD_OUTPUT_HANDLE);
    HANDLE OldStdErr=GetStdHandle(STD_ERROR_HANDLE);

    HANDLE ChildStdIn;
    HANDLE ChildStdOut;
    HANDLE ChildStdErr;

    lsa.nLength=sizeof(SECURITY_ATTRIBUTES);
    lsa.lpSecurityDescriptor=NULL;
    lsa.bInheritHandle=TRUE;

    //Create Parent_Write to ChildStdIn Pipe
    if (!CreatePipe(&ChildStdIn,inH,&lsa,0))
        ErrorExit(TEXT("Could Not Create Parent-->Child Pipe"));

    //Create ChildStdOut to Parent_Read pipe
    if (!CreatePipe(outH,&ChildStdOut,&lsa,0))
        ErrorExit(TEXT("Could Not Create Child-->Parent Pipe"));

    //Create ChildStdOut to Parent_Read pipe
    if (!CreatePipe(errH,&ChildStdErr,&lsa,0))
        ErrorExit(TEXT("Could Not Create Child-->Parent Pipe"));

    //Make ChildStdIn and Out as standard handles and get it inherited by child
    if (!SetStdHandle(STD_INPUT_HANDLE,ChildStdIn))
        ErrorExit(TEXT("Could not change StdIn"));

    if (!SetStdHandle(STD_OUTPUT_HANDLE,ChildStdOut))
        ErrorExit(TEXT("Could Not change StdOut"));

    if (!SetStdHandle(STD_ERROR_HANDLE,ChildStdErr))
        ErrorExit(TEXT("Could Not change StdErr"));

    si.cb=sizeof(STARTUPINFO);
    si.lpReserved=NULL;
    si.lpTitle=NULL;
    si.lpDesktop=NULL;
    si.dwX=si.dwY=si.dwYSize=si.dwXSize=si.dwFlags=0L;
    si.wShowWindow=SW_SHOW;
    si.lpReserved2=NULL;
    si.cbReserved2=0;

    //Create Child Process
    if (!CreateProcess( NULL,
                        cmd,
                        NULL,
                        NULL,
                        TRUE,
                        NORMAL_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &si,
                        &pi))
        ErrorExit(TEXT("Could Not Create Child Process"));

    //reset StdIn StdOut
    if (!SetStdHandle(STD_INPUT_HANDLE,OldStdIn))
    {
        TerminateProcess(pi.hProcess,1);
        ErrorExit(TEXT("Could not RESET StdIn"));
    }
    if (!SetStdHandle(STD_OUTPUT_HANDLE,OldStdOut))
    {
        TerminateProcess(pi.hProcess,1);
        ErrorExit(TEXT("Could not RESET StdIn"));
    }

    if (!SetStdHandle(STD_ERROR_HANDLE,OldStdErr))
    {
        TerminateProcess(pi.hProcess,1);
        ErrorExit(TEXT("Could not RESET StdIn"));
    }

    //Close unneccesary Handles
    CloseHandle(ChildStdIn);
    CloseHandle(ChildStdOut);
    CloseHandle(ChildStdErr);
    return(pi.hProcess);
}
/*************************************************************/

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
/*************************************************************/
DWORD
ListenForSession(
   TCHAR* pipename
   )
{
    int    i;
    DWORD  ThreadID;
    HANDLE PipeH[2];
    SECURITY_DESCRIPTOR SecurityDescriptor;
    HANDLE TokenHandle;
    TOKEN_DEFAULT_DACL DefaultDacl;
    SECURITY_ATTRIBUTES lsa;

    TCHAR   fullnameIn[BUFFSIZE];
    TCHAR   fullnameOut[BUFFSIZE];


    _stprintf(fullnameIn,SERVER_READ_PIPE  ,TEXT("."),pipename);
    _stprintf(fullnameOut,SERVER_WRITE_PIPE,TEXT("."),pipename);
    //
    // Initialize the security descriptor that we're going to
    // use.
    //

    InitializeSecurityDescriptor
    (
        &SecurityDescriptor,
        SECURITY_DESCRIPTOR_REVISION
    );

    (VOID) SetSecurityDescriptorDacl
           (
               &SecurityDescriptor,
               TRUE,
               NULL,
               FALSE
           );

    DefaultDacl.DefaultDacl = NULL;

    if (OpenProcessToken
        (
            GetCurrentProcess(),
            TOKEN_ADJUST_DEFAULT,
            &TokenHandle
        ))
    {

        //
        // Remove the default DACL on the token
        //

        SetTokenInformation
        (
            TokenHandle,
            TokenDefaultDacl,
            &DefaultDacl,
            sizeof( TOKEN_DEFAULT_DACL )
        );

    }

    lsa.nLength=sizeof(SECURITY_ATTRIBUTES);
    lsa.lpSecurityDescriptor=&SecurityDescriptor;
    lsa.bInheritHandle=TRUE;

    while(TRUE)
    {
        PipeH[0]=CreateNamedPipe
                 (
                    fullnameIn ,
                    PIPE_ACCESS_INBOUND ,
                    PIPE_TYPE_BYTE,
                    PIPE_UNLIMITED_INSTANCES,
                    0,0,0,&lsa
                 );

        PipeH[1]=CreateNamedPipe
                 (
                    fullnameOut,
                    PIPE_ACCESS_OUTBOUND,
                    PIPE_TYPE_BYTE,
                    PIPE_UNLIMITED_INSTANCES,
                    0,0,0,&lsa
                 );

        if (!ConnectNamedPipe(PipeH[0],NULL))
        {
            if (GetLastError()!=ERROR_PIPE_CONNECTED)
            {
                CloseHandle(PipeH[0]);
                CloseHandle(PipeH[1]);
                continue;
            }

        }

        if (!ConnectNamedPipe(PipeH[1],NULL))
        {
            if (GetLastError()!=ERROR_PIPE_CONNECTED)
            {
                CloseHandle(PipeH[0]);
                CloseHandle(PipeH[1]);
                continue;
            }
        }

        //
        //Look For a Free Slot & if not- then terminate connection
        //

        for (i=1;i<MAX_SESSION;i++)
        {
            //
            // Locate a Free Client block
            //
            if (!ClientList[i].Active)
                break;
        }

        if (i<MAX_SESSION)
        {
            //
            // Initialize the Client
            //
            ClientList[i].PipeReadH=PipeH[0];
            ClientList[i].PipeWriteH=PipeH[1];
            ClientList[i].Active=TRUE;
            ClientList[i].SendOutput=TRUE;
            ClientList[i].CommandRcvd=FALSE;

        }
        else
        {
            _tprintf(TEXT("Remote:Closing New Session - No more slots\n"));
            CloseHandle(PipeH[0]);
            CloseHandle(PipeH[1]);
            continue;
        }

        //
        //start new thread for this connection
        //

        if((ClientList[i].hThread=CreateThread (
                     (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                     (DWORD)0,                           // Use same stack size.
                     (LPTHREAD_START_ROUTINE)RemoteSession, // Thread procedure.
                     (LPVOID)&ClientList[i],             // Parameter to pass.
                     (DWORD)0,                           // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
        {
            CloseClient(&ClientList[i]);
            continue;
        }
    }
    return(0);
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

/*************************************************************/
DWORD
RemoteSession(
    SESSION_TYPE         *MyClient
    )
{
    DWORD                ReadCnt;
    SESSION_STARTUPINFO  ssi;
    TCHAR                 *headerbuff;
    TCHAR                 msg[BUFFSIZE];
    DWORD                tmp;
    SESSION_STARTREPLY   ssr;

    memset((TCHAR *)&ssi,0,sizeof(ssi));

    if ((MyClient->rSaveFile=CreateFile(
        SaveFileName,
        GENERIC_READ|GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        NULL,OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,NULL))==NULL)

    {
        CloseClient(MyClient);
        return(1);
    }



    {
        DWORD reply=0;

        ReadFixBytes(MyClient->PipeReadH,(TCHAR *)MyClient->Name,HOSTNAMELEN-1,0);

        //
        //Last four Bytes contains a code
        //

        memcpy((TCHAR *)&reply,(TCHAR *)&(MyClient->Name[11]),4);

        if (reply!=MAGICNUMBER)
        {
            //
            // Unknown client
            //
            CloseClient(MyClient);
            return(1);
        }

        ssr.MagicNumber=MAGICNUMBER;
        ssr.Size=sizeof(ssr);
        ssr.FileSize=GetFileSize( MyClient->rSaveFile, &tmp );

        WriteFile(MyClient->PipeWriteH,(TCHAR *)&ssr,sizeof(ssr),&tmp,NULL);
    }

    if (ReadFixBytes(MyClient->PipeReadH,(TCHAR *)&(ssi.Size),sizeof(ssi.Size),0)!=0)
    {
        CloseClient(MyClient);
        return(1);
    }

    if (ssi.Size>1024)      //Sanity Check
    {
        _stprintf(msg,TEXT("%s"),"Server:Unknown Header..Terminating session\n");
        WriteFile(MyClient->PipeWriteH,msg,_tcslen(msg),&tmp,NULL);
        CloseClient(MyClient);
        return(1);

    }


    if ((headerbuff=(TCHAR *)calloc(ssi.Size,1))==NULL)
    {
        _stprintf(msg,TEXT("%s"),"Server:Not Enough Memory..Terminating session\n");
        WriteFile(MyClient->PipeWriteH,msg,_tcslen(msg),&tmp,NULL);
        CloseClient(MyClient);
        return(1);

    }

    ReadCnt=ssi.Size-sizeof(ssi.Size);
    if (ReadFixBytes(MyClient->PipeReadH,(TCHAR *)headerbuff,ReadCnt,0)!=0)
    {
        CloseClient(MyClient);
        return(1);
    }

    memcpy((TCHAR *)&ssi+sizeof(ssi.Size),headerbuff,sizeof(ssi)-sizeof(ssi.Size));
    free(headerbuff);

    /* Version  */
    if (ssi.Version!=VERSION)
    {
         _stprintf(msg,TEXT("WSRemote Warning:Server Version=%d Client Version=%d\n"),VERSION,ssi.Version);
         WriteFile(MyClient->PipeWriteH,msg,_tcslen(msg),&tmp,NULL);

    }

    /* Name  */
    {
        memcpy(MyClient->Name,ssi.ClientName,15);
        MyClient->Name[14]=0;

    }

    /* Lines  */
    if (ssi.LinesToSend!=-1)
    {
        long  PosFromEnd=ssi.LinesToSend*CHARS_PER_LINE;
        DWORD BytesToSend=MINIMUM((DWORD)PosFromEnd,ssr.FileSize);
        DWORD BytesRead;
        TCHAR  *buff=(TCHAR *)calloc(BytesToSend+1,1);

        if (ssr.FileSize > (DWORD)PosFromEnd)
        {
            SetFilePointer( MyClient->rSaveFile,
                            -PosFromEnd,
                            (PLONG)NULL,
                            FILE_END
                           );

        }

        if (buff!=NULL)
        {
            if (!ReadFile(MyClient->rSaveFile,buff,BytesToSend,&BytesRead,NULL))
            {
                CloseClient(MyClient);
                return(1);
            }

            RemoveInpMark(buff,BytesRead);
            if (!WriteFile(MyClient->PipeWriteH,buff,BytesRead,&tmp,NULL))
            {
                CloseClient(MyClient);
                return(1);
            }
        }
        free(buff);

    }

    RemoteInfo(_tprintf(TEXT("\n**WSRemote:Connected To %s [%s]\n"),MyClient->Name,GetFormattedTime()),ssi.Flag);
    NewSession(MyClient);
    RemoteInfo(_tprintf(TEXT("\n**WSRemote:Disconnected From %s [%s]\n"),MyClient->Name,GetFormattedTime()),ssi.Flag);
    CloseClient(MyClient);
    return(0);
}
/*************************************************************/
DWORD
NewSession(
    SESSION_TYPE* MyClient
    )
{
    DWORD        ThreadId;
    HANDLE       rwThread[3];

    MyClient->MoreData=CreateEvent
    (
            (LPSECURITY_ATTRIBUTES) NULL,/* address of security attributes	*/
            FALSE,                	     /* flag for manual-reset event	*/
            TRUE,	                     /* flag for initial state	*/
            NULL	                     /* address of event-object name	*/
    );



    if ((rwThread[0]=CreateThread (
                        (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                        (DWORD)0,                           // Use same stack size.
                        (LPTHREAD_START_ROUTINE)GetClientInput, // Thread procedure.
                        (LPVOID)MyClient,                    // Parameter to pass.
                        (DWORD)0,                           // Run immediately.
                        (LPDWORD)&ThreadId))==NULL)
    {
        return(GetLastError());
    }


    if ((rwThread[1]=CreateThread (
                        (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                        (DWORD)0,                           // Use same stack size.
                        (LPTHREAD_START_ROUTINE)TransferFileToClient, // Thread procedure.
                        (LPVOID)MyClient,                    // Parameter to pass.
                        (DWORD)0,                           // Run immediately.
                        (LPDWORD)&ThreadId))==NULL)
    {
        CloseHandle(rwThread[0]);
        return(GetLastError());
    }

    rwThread[2]=ChldProc;
    WaitForMultipleObjects(3, rwThread,FALSE, INFINITE);

    TerminateThread(rwThread[0],1);
    TerminateThread(rwThread[1],1);

    CloseHandle(rwThread[0]);
    CloseHandle(rwThread[1]);

    return(0);
}
/*************************************************************/
DWORD
GetChldOutput(
    HANDLE readH
    )
{
    TCHAR  buff[BUFFSIZE];
    DWORD dread;
    DWORD tmp;


    while(ReadFile(readH,buff,BUFFSIZE-1,&dread,NULL))
    {
        buff[dread]='\0';

        if (!WriteFile(SaveFile,buff,dread,&tmp,NULL))
        {
            return(1);
        }

        //
        // Signal Reader Thread that more data
        //
        {
            int i;
            DWORD err; //REMOVE
            for (i=0;i<MAX_SESSION;i++)
            {
                if (ClientList[i].Active)
                {
                    if (!SetEvent(ClientList[i].MoreData))
                    	err=GetLastError(); //REMOVE
                }
            }
        }
    }
    return(1);
}
/*************************************************************/
DWORD
TransferFileToClient(
    SESSION_TYPE *MyClient
    )
{

    TCHAR          buffin[BUFFSIZE],buffout[BUFFSIZE],cmdbuff[BUFFSIZE];
    DWORD  tmp;
    DWORD  dread=0,dwrite=0;
    BOOL   incmd=FALSE;
    DWORD  cmdP=0;
    DWORD  i;
    TCHAR   MyEchoStr[30];

    _stprintf(MyEchoStr,TEXT("[%-15s"),MyClient->Name);

    while(ReadFile(MyClient->rSaveFile,buffin,BUFFSIZE-1,&dread,NULL))
    {
        if (dread==0)
        {
            WaitForSingleObject(MyClient->MoreData,INFINITE);
            continue;
        }
        dwrite=0;
        for(i=0;i<dread;i++)
        {
            if (incmd)
            {
                if ((buffin[i]==ENDMARK)||(cmdP==BUFFSIZE-1))
                {
                    incmd=FALSE;
                    cmdbuff[cmdP]=0;
                    if ((_tcsstr(cmdbuff,MyEchoStr)==NULL)||
                        (!MyClient->CommandRcvd))
                    {
                        if (!WriteFile(
                            MyClient->PipeWriteH,
                            cmdbuff,cmdP,&tmp,NULL))
                        {
                            return(1);
                        }
                    }
                    cmdP=0;
                }
                else
                {
                    cmdbuff[cmdP++]=buffin[i];
                }
            }
            else
            {

                if (buffin[i]==BEGINMARK)
                {
                    if (dwrite!=0)
                    {
                        if (!WriteFile(
                            MyClient->PipeWriteH,
                            buffout,dwrite,&tmp,NULL))
                        {
                            return(1);
                        }
                        dwrite=0;
                    }
                    incmd=TRUE;
                    continue;
                }
                else
                {
                    buffout[dwrite++]=buffin[i];
                }
            }
        }

        if (dwrite!=0)
        {
            if (!WriteFile(
                MyClient->PipeWriteH,
                buffout,dwrite,&tmp,NULL))
            {
                return(0);
            }
        }
    }
    return(1);
}

/*************************************************************/
DWORD
GetClientInput(
    SESSION_TYPE *MyClient
    )
{
    TCHAR buff[BUFFSIZE];
    DWORD tmp,dread;

#ifdef UNICODE
    while(ReadFileW(MyClient->PipeReadH,buff,BUFFSIZE,&dread,NULL))
#else
    while(ReadFile(MyClient->PipeReadH,buff,BUFFSIZE,&dread,NULL))
#endif
    {
        buff[dread]=0;
        MyClient->CommandRcvd=TRUE;

        if (FilterCommand(MyClient,buff,dread))
            continue;


        if (!WriteFile(ChildStdInp,buff,dread,&tmp,NULL))
        {
            ExitThread(0);
        }
    }
    return(1);
}
/*************************************************************/

BOOL
FilterCommand(
    SESSION_TYPE *cl,
    TCHAR *buff,
    int dread
    )
{
    TCHAR	inp_buff[4096];
    TCHAR   tmpchar;
    TCHAR   ch[3];
    DWORD   tmp;
    int     len;
    DWORD   ThreadID; //Useless

    if (dread==0)
        return(FALSE);

    buff[dread]=0;


    if (buff[0]==COMMANDCHAR)
    {
        switch(buff[1])
        {
            case 'l':
            case 'L':
				  if (bIPLocked == FALSE)
				  {
						bIPLocked=TRUE;
						_tprintf(TEXT("**LOCK: No IP Sessions Allowed\n"));
				  }
				  else
				  {
					bIPLocked=FALSE;
						_tprintf(TEXT("**LOCK: IP Sessions Now Allowed\n"));
				  }
                  break;
        case 'o':
        case 'O': cl->SendOutput=!cl->SendOutput;
                  break;
        case 'k':
        case 'K':TerminateProcess(ChldProc,1);
                 break;
        case 's':
        case 'S':
                 SendStatus(cl->PipeWriteH);
                 break;

        case 'p':
        case 'P':
        {
            TCHAR  *mssg=(TCHAR *)calloc(4096,1); //Free it in called Proc
            TCHAR  *ack=TEXT("WSRemote:Popup Shown..\n");

            if (mssg==NULL)
                break;

            _stprintf(mssg,TEXT("From %s [%s]\n\n%s\n"),cl->Name,GetFormattedTime(),&buff[2]);
            CreateThread(
                  (LPSECURITY_ATTRIBUTES)NULL,         // No security attributes.
                  (DWORD)0,              // Use same stack size.
                  (LPTHREAD_START_ROUTINE)ShowPopup, // Thread procedure.
                  (LPVOID)mssg,          // Parameter to pass.
                  (DWORD)0,              // Run immediately.
                  (LPDWORD)&ThreadID
                 );
#ifdef UNICODE
            WriteFileW(cl->PipeWriteH,ack,_tcslen(ack),&tmp,NULL);
#else
            WriteFile(cl->PipeWriteH,ack,_tcslen(ack),&tmp,NULL);
#endif
            break;
         }

        case 'm':
        case 'M':
                buff[dread-2]=0;
#ifdef UNICODE
                MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
                CMDSTRING(inp_buff,buff,cl,GetFormattedTime());
#endif
                len=_tcslen(inp_buff);
#ifdef UNICODE
                WriteFileW(SaveFile,inp_buff,len,&tmp,NULL);
#else
                WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
#endif
                break;

        case '@':
                buff[dread-2]=0;
#ifdef UNICODE
                MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
                CMDSTRING(inp_buff,&buff[1],cl,GetFormattedTime());
#endif
                len=_tcslen(inp_buff);
#ifdef UNICODE
                WriteFileW(SaveFile,inp_buff,len,&tmp,NULL);
#else
                WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
#endif
                //
                // Remove the first @ sign
                //
                MoveMemory(buff,&buff[1],dread-1);
                buff[dread-1]=' ';
                return(FALSE); //Send it it to the chile process
                break;


        default :
                _stprintf(inp_buff,TEXT("%s"),"** Unknown Command **\n");
#ifdef UNICODE
                WriteFileW( cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
#else
                WriteFile( cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
#endif
            case 'h':
            case 'H':
            {
#ifdef UNICODE
                _stprintf(inp_buff,TEXT("%cM: To Send Message\n"),COMMANDCHAR);
                WriteFileW(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cP: To Generate popup\n"),COMMANDCHAR);
                WriteFileW(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cK: To kill the server\n"),COMMANDCHAR);
                WriteFileW(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cH: This Help\n"),COMMANDCHAR);
                WriteFileW(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
#else
                _stprintf(inp_buff,TEXT("%cM: To Send Message\n"),COMMANDCHAR);
                WriteFile(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cP: To Generate popup\n"),COMMANDCHAR);
                WriteFile(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cK: To kill the server\n"),COMMANDCHAR);
                WriteFile(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cH: This Help\n"),COMMANDCHAR);
                WriteFile(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
#endif
                break;
            }
        }
        return(TRUE);
    }


    if ((buff[0]<26))
    {
        BOOL    ret=FALSE;
#ifdef UNICODE
        TCHAR * pszTime;
#endif

        _stprintf(ch,TEXT("^%c"),buff[0]+64);
#ifdef UNICODE
        pszTime = GetFormattedTime();
        MakeCommandString( inp_buff, ch, cl->Name, pszTime);
#else
        CMDSTRING(inp_buff,ch,cl,GetFormattedTime());
#endif
        len=_tcslen(inp_buff);

        if (buff[0]==CTRLC)
        {
            cl->CommandRcvd=FALSE;
            GenerateConsoleCtrlEvent(CTRL_C_EVENT,0);
            ret=TRUE; //Already sent to child
        }

        WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
        return(ret); //FALSE:send it to child StdIn
    }


    tmpchar=buff[dread-2]; //must be 13;but just incase
    buff[dread-2]=0;
#ifdef UNICODE
    MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
    CMDSTRING(inp_buff,buff,cl,GetFormattedTime());
#endif
    buff[dread-2]=tmpchar;
    len=_tcslen(inp_buff);
    WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
    return(FALSE);
}
/*************************************************************/

BOOL
SockFilterCommand(
    SESSION_TYPE *cl,
    TCHAR *buff,
    int dread
    )
{
    TCHAR       inp_buff[4096];
    TCHAR       tmpchar;
    TCHAR       ch[3];
    DWORD      tmp;
    int        len;
    DWORD      ThreadID; //Useless

    if (dread==0)
        return(FALSE);

    buff[dread]=0;

    if (buff[0]==COMMANDCHAR)
    {
        switch(buff[1])
        {
        case 'o':
        case 'O': cl->SendOutput=!cl->SendOutput;
                  break;
        case 'k':
        case 'K':TerminateProcess(ChldProc,1);
                 break;
        case 's':
        case 'S':
                 SockSendStatus(cl->Socket);
                 break;

        case 'p':
        case 'P':
        {
            TCHAR  *mssg=(TCHAR *)calloc(4096,1); //Free it in called Proc
            TCHAR  *ack=TEXT("WSRemote:Popup Shown..\n");

            if (mssg==NULL)
                break;

            _stprintf(mssg,TEXT("From %s [%s]\n\n%s\n"),cl->Name,GetFormattedTime(),&buff[2]);
            CreateThread(
                  (LPSECURITY_ATTRIBUTES)NULL,         // No security attributes.
                  (DWORD)0,              // Use same stack size.
                  (LPTHREAD_START_ROUTINE)ShowPopup, // Thread procedure.
                  (LPVOID)mssg,          // Parameter to pass.
                  (DWORD)0,              // Run immediately.
                  (LPDWORD)&ThreadID
                 );
            WriteSocket(cl->Socket,ack,_tcslen(ack),&tmp);
            break;
         }

        case 'm':
        case 'M':
                buff[dread-2]=0;
#ifdef UNICODE
                MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
                CMDSTRING(inp_buff,buff,cl,GetFormattedTime());
#endif
                len=_tcslen(inp_buff);
                WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
                break;

        case '@':
                buff[dread-2]=0;
#ifdef UNICODE
                MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
                CMDSTRING(inp_buff,&buff[1],cl,GetFormattedTime());
#endif
                len=_tcslen(inp_buff);
                WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
                //
                // Remove the first @ sign
                //
                MoveMemory(buff,&buff[1],dread-1);
                buff[dread-1]=' ';
                return(FALSE); //Send it it to the chile process
                break;


        default :
                _stprintf(inp_buff,TEXT("%s"),"** Unknown Command **\n");
                WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
        case 'h':
        case 'H':
                 _stprintf(inp_buff,TEXT("%cM: To Send Message\n"),COMMANDCHAR);
                 WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
                 _stprintf(inp_buff,TEXT("%cP: To Generate popup\n"),COMMANDCHAR);
                 WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
                 _stprintf(inp_buff,TEXT("%cK: To kill the server\n"),COMMANDCHAR);
                 WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
                 _stprintf(inp_buff,TEXT("%cH: This Help\n"),COMMANDCHAR);
                 WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
                 break;
        }
        return(TRUE);
    }


    if ((buff[0]<26))
    {
        BOOL ret=FALSE;

        _stprintf(ch,TEXT("^%c"),buff[0]+64);
#ifdef UNICODE
        MakeCommandString( inp_buff, ch, cl->Name, GetFormattedTime());
#else
        CMDSTRING(inp_buff,ch,cl,GetFormattedTime());
#endif
        len=_tcslen(inp_buff);


        if (buff[0]==CTRLC)
        {
            cl->CommandRcvd=FALSE;
            GenerateConsoleCtrlEvent(CTRL_C_EVENT,0);
            ret=TRUE; //Already sent to child
        }

        WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
        return(ret); //FALSE:send it to child StdIn
    }


    tmpchar=buff[dread-2]; //must be 13;but just incase
    buff[dread-2]=0;
#ifdef UNICODE
    MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
    CMDSTRING(inp_buff,buff,cl,GetFormattedTime());
#endif
    buff[dread-2]=tmpchar;
    len=_tcslen(inp_buff);
    WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
    return(FALSE);
}
/*************************************************************/



VOID
SendStatus(
    HANDLE hClientPipe
    )
{
    TCHAR  buff[1024];
    int   i;
    DWORD tmp;
    TCHAR  *env=(TCHAR *)GetEnvironmentStrings();
    DWORD ver=GetVersion();

    _stprintf(buff,TEXT("Command = %s\n"),ChildCmd);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("Server = %s PIPE=%s\n"),HostName,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

	_stprintf(buff,TEXT("IP Blocking= %d\n"),(DWORD)bIPLocked);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("Username= %s Password=%s\n"),Username,Password);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("Build = %d \n"),((WORD *)&ver)[1]);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    for (i=1;i<MAX_SESSION;i++)
    {
        if (ClientList[i].Active)
        {
            _stprintf(buff,TEXT("ACTIVE SESSION=%s\n"),ClientList[i].Name);
            WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);
        }
    }

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("ENVIRONMENT VARIABLES\n"),Server,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);


    __try
    {
        while (*env!=0)
        {
            _stprintf(buff,TEXT("%s\n"),env);
            WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

            while(*(env++)!=0);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _stprintf(buff,TEXT("Exception Generated Getting Environment Block\n"),env);
        WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    }

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);
    return;
}
/*************************************************************/
VOID
SockSendStatus(
    SOCKET MySocket
    )
{
    TCHAR  buff[1024];
    int   i;
    DWORD tmp;
    TCHAR  *env=(TCHAR *)GetEnvironmentStrings();
    DWORD ver=GetVersion();

    _stprintf(buff,TEXT("Command = %s\n"),ChildCmd);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    _stprintf(buff,TEXT("Server = %s Port=%s\n"),HostName,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

	_stprintf(buff,TEXT("IP Blocking= %d\n"),(DWORD)bIPLocked);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    _stprintf(buff,TEXT("Username= %s Password=%s\n"),Username,Password);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);
	
	_stprintf(buff,TEXT("Build = %d \n"),((WORD *)&ver)[1]);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    for (i=1;i<MAX_SESSION;i++)
    {
        if (ClientList[i].Active)
        {
            _stprintf(buff,TEXT("ACTIVE SESSION=%s from IP %s \n"),ClientList[i].Name, ClientList[i].szIP );
            WriteSocket(MySocket,buff,_tcslen(buff),&tmp);
        }
    }

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    _stprintf(buff,TEXT("ENVIRONMENT VARIABLES\n"),Server,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);


    __try
    {
        while (*env!=0)
        {
            _stprintf(buff,TEXT("%s\n"),env);
            WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

            while(*(env++)!=0);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _stprintf(buff,TEXT("Exception Generated Getting Environment Block\n"),env);
        WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    }

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);
    return;
}
/*************************************************************/


DWORD
ShowPopup(
    TCHAR *mssg
    )
{
    MessageBox(GetActiveWindow(),mssg,TEXT("***WSREMOTE***"),MB_OK|MB_SETFOREGROUND);
    free(mssg);
    return(0);

}
/*************************************************************/
BOOL SrvCtrlHand(
    DWORD event
    )
{
    if (event==CTRL_BREAK_EVENT)
    {
        TerminateProcess(ChldProc,1);
        return(TRUE);
    }
    else if (event==CTRL_C_EVENT)
        return(TRUE);
    return(FALSE);
}
/*************************************************************/

DWORD   LocalSession(PVOID noarg)
{
    //Local is ClientList[0]
    TCHAR *name=(TCHAR *)ClientList[0].Name;

    _tcscpy(name,LOCALNAME);
    if ((ClientList[0].rSaveFile=CreateFile(SaveFileName,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL))==NULL)
    {
        _tprintf(TEXT("WSRemote:Cannot open ReadHandle to Savefile:%d\n"),GetLastError());
        ClientList[0].Active=FALSE;
        return(1);

    }

    ClientList[0].PipeReadH=GetStdHandle(STD_INPUT_HANDLE);
    ClientList[0].PipeWriteH=GetStdHandle(STD_OUTPUT_HANDLE);
    ClientList[0].SendOutput=TRUE;
    ClientList[0].Active=TRUE;
    NewSession(&ClientList[0]);
    CloseClient(&ClientList[0]);
    return(0);
}

VOID
CloseClient(
    SESSION_TYPE *Client
    )
{
	int nRet;
    ZeroMemory(Client->Name,HOSTNAMELEN);

    if (Client->PipeReadH!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(Client->PipeReadH);
        Client->PipeReadH=INVALID_HANDLE_VALUE;
    }

    if (Client->PipeWriteH!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(Client->PipeWriteH);
        Client->PipeWriteH=INVALID_HANDLE_VALUE;
    }

    if (Client->rSaveFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(Client->rSaveFile);
        Client->rSaveFile=INVALID_HANDLE_VALUE;
    }
    if (Client->MoreData!=NULL)
    {
        CloseHandle(Client->MoreData);
        Client->MoreData=NULL;
    }
	 if (Client->Socket!=INVALID_SOCKET)
    {
		 nRet = shutdown(Client->Socket, SD_BOTH);
	     if (nRet == SOCKET_ERROR)
				_tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
        closesocket(Client->Socket);
		
        Client->Socket=INVALID_SOCKET;
    }
    ZeroMemory(Client->szIP,16);

    Client->Active=FALSE; //Keep it last else synch problem.
    return;
}

VOID
InitClientList(
    )
{
    int i;
    for (i=0;i<MAX_SESSION;i++)
    {
        ZeroMemory(ClientList[i].Name,HOSTNAMELEN);
        ClientList[i].PipeReadH=INVALID_HANDLE_VALUE;
        ClientList[i].PipeWriteH=INVALID_HANDLE_VALUE;
        ClientList[i].rSaveFile=INVALID_HANDLE_VALUE;
        ClientList[i].MoreData=NULL;
		ClientList[i].Socket=INVALID_SOCKET;
        ClientList[i].Active=FALSE;
        ClientList[i].CommandRcvd=FALSE;
        ClientList[i].SendOutput=FALSE;
        ClientList[i].hThread=NULL;
		ZeroMemory(ClientList[i].szIP,16);
    }
    return;
}



VOID
RemoveInpMark(
    TCHAR* Buff,
    DWORD Size
    )

{
    DWORD i;
    for (i=0;i<Size;i++)
    {
        switch (Buff[i])
        {
        case BEGINMARK:
            Buff[i]=' ';
            break;

        case ENDMARK:
            if (i<2)
            {
                Buff[i]= ' ';
            }
            else
            {
                Buff[i]  =Buff[i-1];
                Buff[i-1]=Buff[i-2];
                Buff[i-2]=' ';
            }
            break;

        default:
           break;
       }
    }
}


/*************************************************************/
DWORD
SockListenForSession(
   TCHAR* szListenPort
   )
{
	// Bind and Listen
	DWORD			ThreadID;	
	SOCKADDR_IN		saServer;
	int				nRet;
	unsigned short	usPort;
	int				i;

	// Accept
	SOCKET 			socketClient;
	SOCKADDR_IN 	SockAddr;
	int				nLen;

	int				iWSAErr;
    TCHAR *         pszInetAddress  = NULL;
	//
	// Create a TCP/IP stream socket
	//

	listenSocket = socket (	AF_INET,
				SOCK_STREAM,
				IPPROTO_TCP);

	if (listenSocket == INVALID_SOCKET)
	{
		_tprintf (TEXT("Could not create listen socket: %d"), WSAGetLastError() );
 		return FALSE;
	}

	//
	// Get the port number
	// TODO: Check szListenPort for Alpha Chars
	//
	usPort = (unsigned short)_ttoi( szListenPort );
	if (usPort == 0)
	{
		_tprintf (TEXT("**Invalid Listen Port: %s\n"),szListenPort);
		_tprintf (TEXT("**No Socket Connections Allowed....\n"));
		
		nRet = shutdown(listenSocket, SD_BOTH);
		  if (nRet == SOCKET_ERROR)
			 _tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
		closesocket(listenSocket);
		return FALSE;
	}

	saServer.sin_port = htons(usPort);

	//
	// Fill in the rest of the address structure
	//
	saServer.sin_family = AF_INET;
	saServer.sin_addr.s_addr = INADDR_ANY;

	//
	// Bind our name to the socket
	//
	nRet = bind(	listenSocket,
			(LPSOCKADDR)&saServer,
			sizeof(struct sockaddr));

	if (nRet == SOCKET_ERROR)
	{
		_tprintf (TEXT("bind() error: %d"), WSAGetLastError() );
		nRet = shutdown(listenSocket, SD_BOTH);
		  if (nRet == SOCKET_ERROR)
	  		_tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
		closesocket(listenSocket);
		return FALSE;
	}

	//
	// Set the Socket to listen
	//
	nRet = listen(listenSocket, SOMAXCONN);
	if (nRet == SOCKET_ERROR)
	{
		_tprintf (TEXT("listen error() error: %d"), WSAGetLastError() );
		 nRet = shutdown(listenSocket, SD_BOTH);
		  if (nRet == SOCKET_ERROR)
	  		_tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
		closesocket(listenSocket);
		return FALSE;
	}

	while (1)
	{

		// Block on Accept()
		nLen = sizeof(SOCKADDR_IN);
		socketClient = accept	(listenSocket,
					(LPSOCKADDR)&SockAddr,
					&nLen);
		if (socketClient == INVALID_SOCKET)
		{
			//Accept Failed
			_tprintf (TEXT("accept error() error: %d"), WSAGetLastError() );
			break;
		}// if

#ifdef UNICODE
        pszInetAddress = inet_ntoaw(SockAddr.sin_addr);
#else
        pszInetAddress = inet_ntoa(SockAddr.sin_addr);

#endif

        _tprintf(   TEXT("\nCONNECT on socket: %d\nFROM ip: %s"),
                    socketClient,
                    pszInetAddress );

		//
		//Look For a Free Slot & if not- then terminate connection
		//

		for (i=1;i<MAX_SESSION;i++)
		{
			//
			// Locate a Free Client block
			//
			if (!ClientList[i].Active)
				break;
		}// for

		if ( (i<MAX_SESSION) && (bIPLocked == FALSE) )
		{
			//
			// Initialize the Client
			//
			ClientList[i].PipeReadH=INVALID_HANDLE_VALUE;
			ClientList[i].PipeWriteH=INVALID_HANDLE_VALUE;
			ClientList[i].Active=TRUE;
			ClientList[i].SendOutput=TRUE;
			ClientList[i].CommandRcvd=FALSE;
			// SOCK
			ClientList[i].Socket=socketClient;
			_tcscpy(ClientList[i].szIP,pszInetAddress);

#ifdef UNICODE
            free( pszInetAddress );
#endif

			//
			//start new thread for this connection
			//

			if((ClientList[i].hThread=CreateThread (
						 (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
						 (DWORD)0,                           // Use same stack size.
						 (LPTHREAD_START_ROUTINE)SockRemoteSession, // Thread procedure.
						 (LPVOID)&ClientList[i],             // Parameter to pass.
						 (DWORD)0,                           // Run immediately.
						 (LPDWORD)&ThreadID))==NULL)
			{
				CloseClient(&ClientList[i]);
				continue;
			}// if
			}
			else
			{
				_tprintf(TEXT("WSRemote:Closing New Session - No more slots or IP is Locked Out\n"));
				nRet = shutdown(socketClient, SD_BOTH);
				if (nRet == SOCKET_ERROR)
	  				 _tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
				closesocket(socketClient);
				continue;
			}//if


	}// while

	iWSAErr	= WSAGetLastError();

	_tprintf (TEXT("FATAL ERROR, Exiting SockListenForSession: %d"),
			iWSAErr	);
	return 0;
}


/*************************************************************/
DWORD
SockRemoteSession(
    SESSION_TYPE         *MyClient
    )
{
//Declare Variables
//
    DWORD               ReadCnt;
    DWORD               tmp;
    SESSION_STARTUPINFO ssi;
    TCHAR *             headerbuff;
    TCHAR               msg[BUFFSIZE];
    SESSION_STARTREPLY  ssr;
    DWORD               reply           =0;
    BOOL                bRet;

    if ((MyClient->rSaveFile=CreateFile(
        SaveFileName,
        GENERIC_READ|GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        NULL,OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,NULL))==NULL)

    {
        CloseClient(MyClient);
        return(1);
    }

    bRet = SockAuthenticate(MyClient->Socket);
    if (bRet == FALSE)
    {
        _tprintf(TEXT("\nAuth:Bad Username or Password\n"));
        CloseClient(MyClient);
        return(1);
    }

//    ReadSocket( MyClient->Socket,
//                (TCHAR *)MyClient->Name,
//                HOSTNAMELEN-1,
//                &dwBytesRead);

    SockReadFixBytes(MyClient->Socket,(TCHAR *)MyClient->Name,HOSTNAMELEN-1,0);

        //
        //Last four Bytes contains a code
        //

        memcpy((TCHAR *)&reply,(TCHAR *)&(MyClient->Name[11]),4);

        if (reply!=MAGICNUMBER)
        {
            //
            // Unknown client
            //
            CloseClient(MyClient);
            return(1);
        }

        ssr.MagicNumber=MAGICNUMBER;
        ssr.Size=sizeof(ssr);
        ssr.FileSize=GetFileSize( MyClient->rSaveFile, &tmp );

        send(MyClient->Socket,(const char *)&ssr,sizeof(ssr),0);



    if (SockReadFixBytes(MyClient->Socket,(TCHAR *)&(ssi.Size),sizeof(ssi.Size),0)!=0)
    {
        CloseClient(MyClient);
        return(1);
    }

    if (ssi.Size>1024)      //Sanity Check
    {
        _stprintf(msg,TEXT("%s"),"Server:Unknown Header..Terminating session\n");
        WriteSocket(MyClient->Socket,msg,_tcslen(msg),&tmp);
        CloseClient(MyClient);
        return(1);

    }


    if ((headerbuff=(TCHAR *)calloc(ssi.Size,1))==NULL)
    {
        _stprintf(msg,TEXT("%s"),"Server:Not Enough Memory..Terminating session\n");
        WriteSocket(MyClient->Socket,msg,_tcslen(msg),&tmp);
        CloseClient(MyClient);
        return(1);

    }

    ReadCnt=ssi.Size-sizeof(ssi.Size);
    if (SockReadFixBytes(MyClient->Socket,(TCHAR *)headerbuff,ReadCnt,0)!=0)
    {
        CloseClient(MyClient);
        return(1);
    }

    memcpy((TCHAR *)&ssi+sizeof(ssi.Size),headerbuff,sizeof(ssi)-sizeof(ssi.Size));
    free(headerbuff);

    /* Version  */
    if (ssi.Version!=VERSION)
    {
         _stprintf(msg,TEXT("WSRemote Warning:Server Version=%d Client Version=%d\n"),VERSION,ssi.Version);
         WriteSocket(MyClient->Socket,msg,_tcslen(msg),&tmp);
    }

    /* Name  */
    {
        memcpy(MyClient->Name,ssi.ClientName,15);
        MyClient->Name[14]=0;

    }

    /* Lines  */
    if (ssi.LinesToSend!=-1)
    {
        long  PosFromEnd=ssi.LinesToSend*CHARS_PER_LINE;
        DWORD BytesToSend=MINIMUM((DWORD)PosFromEnd,ssr.FileSize);
        DWORD BytesRead;
        TCHAR  *buff=(TCHAR *)calloc(BytesToSend+1,1);

        if (ssr.FileSize > (DWORD)PosFromEnd)
        {
            SetFilePointer( MyClient->rSaveFile,
                            -PosFromEnd,
                            (PLONG)NULL,
                            FILE_END
                           );

        }

        if (buff!=NULL)
        {
            if (!ReadFile(MyClient->rSaveFile,buff,BytesToSend,&BytesRead,NULL))
            {
                CloseClient(MyClient);
                return(1);
            }

            RemoveInpMark(buff,BytesRead);
            if (!WriteSocket(MyClient->Socket,buff,BytesRead,&tmp))
            {
                CloseClient(MyClient);
                return(1);
            }
        }
        free(buff);

    }

    RemoteInfo(_tprintf(TEXT("\n**WSRemote:Connected To %s ip=%s [%s]\n"),MyClient->Name,MyClient->szIP,GetFormattedTime()),ssi.Flag);
    SockNewSession(MyClient);
    RemoteInfo(_tprintf(TEXT("\n**WSRemote:Disconnected From %s ip=%s [%s]\n"),MyClient->Name,MyClient->szIP,GetFormattedTime()),ssi.Flag);
    CloseClient(MyClient);
    return(0);
}

/*************************************************************/
DWORD
SockNewSession(
    SESSION_TYPE* MyClient
    )
{
    DWORD        ThreadId;
    HANDLE       rwThread[3];

    MyClient->MoreData=CreateEvent
    (
            (LPSECURITY_ATTRIBUTES) NULL,/* address of security attributes	*/
            FALSE,                	     /* flag for manual-reset event	*/
            TRUE,	                     /* flag for initial state	*/
            NULL	                     /* address of event-object name	*/
    );



    if ((rwThread[0]=CreateThread (
                        (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                        (DWORD)0,                           // Use same stack size.
                        (LPTHREAD_START_ROUTINE)SockGetClientInput, // Thread procedure.
                        (LPVOID)MyClient,                    // Parameter to pass.
                        (DWORD)0,                           // Run immediately.
                        (LPDWORD)&ThreadId))==NULL)
    {
        return(GetLastError());
    }

    if ((rwThread[1]=CreateThread (
                        (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                        (DWORD)0,                           // Use same stack size.
                        (LPTHREAD_START_ROUTINE)SockTransferFileToClient, // Thread procedure.
                        (LPVOID)MyClient,                    // Parameter to pass.
                        (DWORD)0,                           // Run immediately.
                        (LPDWORD)&ThreadId))==NULL)
    {
        CloseHandle(rwThread[0]);
        return(GetLastError());
    }

    rwThread[2]=ChldProc;
    WaitForMultipleObjects(3, rwThread,FALSE, INFINITE);

    TerminateThread(rwThread[0],1);
    TerminateThread(rwThread[1],1);

    CloseHandle(rwThread[0]);
    CloseHandle(rwThread[1]);

    return(0);
}

/*************************************************************/
DWORD
SockGetClientInput(
    SESSION_TYPE *MyClient
    )
{
    TCHAR	buf[BUFFSIZE];
    DWORD	tmp,
			dread;

	memset(buf, 0, sizeof(buf));
	
	while(ReadSocket(MyClient->Socket,buf,BUFFSIZE,&dread))
    {
        buf[sizeof(buf)]=0;
        MyClient->CommandRcvd=TRUE;

		if (0 == buf[0] )
			return(1);

        if (SockFilterCommand(MyClient,buf,dread))
            continue;


        if (!WriteFile(ChildStdInp,buf,dread,&tmp,NULL))
        {
            ExitThread(0);
        }
		memset(buf, 0, sizeof(buf));
    }
    return(1);
}

/*************************************************************/
DWORD
SockTransferFileToClient(
    SESSION_TYPE *MyClient
    )
{

    TCHAR	buffin[BUFFSIZE],
			buffout[BUFFSIZE],
			cmdbuff[BUFFSIZE];
    DWORD  tmp;
    DWORD  dread=0,dwrite=0;
    BOOL   incmd=FALSE;
    DWORD  cmdP=0;
    DWORD  i;
    TCHAR  MyEchoStr[30];

    _stprintf(MyEchoStr,TEXT("[%-15s"),MyClient->Name);


    while(ReadFile(MyClient->rSaveFile,buffin,BUFFSIZE-1,&dread,NULL))
    {
        if (dread==0)
        {
            WaitForSingleObject(MyClient->MoreData,INFINITE);
            continue;
        }
        dwrite=0;
        for(i=0;i<dread;i++)
        {
            if (incmd)
            {
                if ((buffin[i]==ENDMARK)||(cmdP==BUFFSIZE-1))
                {
                    incmd=FALSE;
                    cmdbuff[cmdP]=0;
                    if ((_tcsstr(cmdbuff,MyEchoStr)==NULL)||
                        (!MyClient->CommandRcvd))
                    {
                       //if (!send (MyClient->Socket, cmdbuff, cmdP, 0));
						//if (!SendBuffer(MyClient, cmdbuff, cmdP))
						if (!WriteSocket(MyClient->Socket, cmdbuff,cmdP,&tmp))
                        {
                            return(1);
                        }
                    }
                    cmdP=0;
                }
                else
                {
                    cmdbuff[cmdP++]=buffin[i];
                }
            }
            else
            {

                if (buffin[i]==BEGINMARK)
                {
                    if (dwrite!=0)
                    {
						//if (!send (MyClient->Socket, buffout, dwrite, 0));
                        //if (!SendBuffer(MyClient, buffout, dwrite))
						if (!WriteSocket(
                            MyClient->Socket,
                            buffout,dwrite,&tmp))
                        {
                            return(1);
                        }
                        dwrite=0;
                    }
                    incmd=TRUE;
                    continue;
                }
                else
                {
                    buffout[dwrite++]=buffin[i];
                }
            }
        }

        if (dwrite!=0)
        {
			//if (!send (MyClient->Socket, buffout, dwrite, 0));
            //if (!SendBuffer(MyClient, buffout, dwrite))
			if (!WriteSocket(
                MyClient->Socket,
                buffout,dwrite,&tmp))
            {
                return(0);
            }
        }
    }
    return(1);
}


BOOL
SockAuthenticate(
    SOCKET MySocket
    )
{
	BOOL	bRead;
	DWORD	dread;
	int		bufflen;
	int		iCmp;
	TCHAR	EncodeBuffer[1024];
	TCHAR	CheckEncodeBuffer[1024];
	TCHAR	UserBuffer[1024];
    TCHAR * String						= UserBuffer;
	TCHAR * pEncodeBuffer;
	TCHAR * pCheckEncodeBuffer;

    SetLastError(0);
	
	memset(CheckEncodeBuffer, 0, sizeof(CheckEncodeBuffer));
	
	_stprintf(
        UserBuffer,        TEXT("%s:%s"),
        Username,
        Password);

    pCheckEncodeBuffer = CheckEncodeBuffer + _tcslen(CheckEncodeBuffer);
    Base64Encode(UserBuffer, _tcslen(UserBuffer), pCheckEncodeBuffer);
    bufflen = _tcslen(pCheckEncodeBuffer);

	memset(EncodeBuffer, 0, sizeof(EncodeBuffer));

	bRead = ReadSocket(MySocket,EncodeBuffer,bufflen,&dread);
	
	pEncodeBuffer = EncodeBuffer;

	iCmp = _tcscmp(pEncodeBuffer, pCheckEncodeBuffer);
	if (iCmp != 0)
		return FALSE;

	return TRUE;

}

#ifdef UNICODE
int MakeCommandString(
    TCHAR * pszOutput,
    TCHAR * pszInput,
    TCHAR * pszName,
    TCHAR * pszTime
)
{
    int nStrLen =_stprintf( pszOutput,
                            TEXT("\xfe%-15s    [%-15s %s]\n\xff"),
                            pszInput,
                            pszName,
                            pszTime );

    return nStrLen;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstcat\wsdata.h ===
/*
 * Module Name:  WSDATA.H
 *
 * Description:
 *
 * Working set tuner include file.  Contains common structure
 * declarations and constant definitions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 *						
 */

/*
 *	Constant definitions.
 */

#define NUM_VAR_BITS	(sizeof(ULONG) << 3)

#ifdef TMIFILEHACK
#define	MAXLINE	80
#endif /* TMIFILEHACK */

/*
 *	    Type definitions and structure declarations.
 */

typedef ULONG	fxnbits_t;

struct	dtqo_s	{
	unsigned long	dtqo_hMTE;	 /* MTE handle			*/
	unsigned short	dtqo_usID;	 /* Identifier			*/
	unsigned short	dtqo_resv;	 /* Reserved			*/
	unsigned long	dtqo_cbPathname; /* Module pathname length	*/
	unsigned long	dtqo_clSegSize;	 /* Time Segment size*/
};

typedef struct	dtqo_s	dtqo_t;


/*
 * WSI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      sentinel 0 (dtgp_s)              | <----------
 *	|=======================================|           |
 *	|      snapshot 0 (dtgp_s) for module X |           | S
 *	|---------------------------------------|           | n
 *	|      dynamic trace variables for X    |           | a
 *	|---------------------------------------|           | p
 *	|      snapshot 0 (dtgp_s) for module Y |           | s
 *	|---------------------------------------|           | h
 *	|      dynamic trace variables for Y    |           | o
 *	|---------------------------------------|           | t
 *	|               etc.                    |           |
 *	|=======================================|           | D
 *	|      sentinel 1 (dtgp_s)              |           | a
 *	|=======================================|           | t
 *	|      snapshot 1 (dtgp_s) for module X |           | a
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for X    |           |
 *	|---------------------------------------|           |
 *	|      snapshot 1 (dtgp_s) for module Y |           |
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for Y    |           |
 *	|---------------------------------------|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      sentinel 2 (dtgp_s)              |           |
 *	|=======================================|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      end sentinel (dtgp_s)            |           |
 *	|_______________________________________| <----------
 *	|_______________________________________|
 *	|                                       | <---------- Q
 *	|      dtqo_s for module X              |           | u
 *	|---------------------------------------|           | e
 *	|      module X pathname string         |           | r
 *	|=======================================|           | y
 *	|      dtqo_s for module Y              |           |
 *	|---------------------------------------|           | I
 *	|      module Y pathname string         |           | n
 *	|=======================================|           | f
 *	|               etc.                    | <---------- o
 *	|=======================================|
 *	|_______________________________________|
 *	
 */


				/* WSI file header format */
struct wsihdr_s {
	CHAR	wsihdr_chSignature[4];	// file signature
	ULONG	wsihdr_ulLevel;		// format level
	ULONG	wsihdr_ulTimeStamp;	// time stamp
	ULONG	wsihdr_ulOffGetvar;	// offset to DT_GETVAR data
	ULONG	wsihdr_ulOffQuery;	// offset to DT_QUERY data
	ULONG	wsihdr_cbFile;		// size of file (in bytes)
	ULONG	wsihdr_ulSnaps;		// number of snapshots
};

typedef struct wsihdr_s wsihdr_t;

/*
 * WSP file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsphdr_s                 |
 *	|---------------------------------------|
 *	|         module pathname array         |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 bitstring            |
 *      |      (rounded to DWORD boundary)      |
 *	|=======================================|
 *	|      function #1 bitstring            |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* WSP file header format */
struct wsphdr_s {
	CHAR	wsphdr_chSignature[4];	// file signature
	ULONG	wsphdr_ulTimeStamp;	// time stamp
	dtqo_t	wsphdr_dtqo;		// query info
	ULONG	wsphdr_ulOffBits;	// offset to first bitstring
	ULONG	wsphdr_ulSnaps;		// number of snapshots
	/* followed by module pathname char array, length specified in dtqo */
};

typedef struct wsphdr_s wsphdr_t;


/*
 * TMI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              tmihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 tmirec_s             |
 *	|---------------------------------------|
 *	|      function #0 name array           |
 *	|=======================================|
 *	|      function #1 tmirec_s             |
 *	|---------------------------------------|
 *	|      function #1 name array           |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* TMI file header. */
typedef struct  tmihdr_s {
            CHAR    tmihdr_chSignature[4]; // "TMI\0"
            USHORT  tmihdr_usMajor;        // Range 0x0001 to 0x00FF
            USHORT  tmihdr_cTmiRec;        // Number of tmirec in file
            CHAR    tmihdr_chModName[256]; // Name of traced module
            USHORT  tmihdr_usID;           // Module identifier
            CHAR    tmihdr_resv[30];       // Reserved
};

typedef struct tmihdr_s tmihdr_t;

				/* Per-function information from TMI file */
struct tmirec_s {
	ULONG	tmirec_ulFxnBit;	// function's bit reference position
	ULONG	tmirec_usFxnAddrObj;	// object portion of function address
	ULONG	tmirec_ulFxnAddrOff;	// offset portion of function address
	ULONG	tmirec_cbFxn;		// size of function (in bytes)
	USHORT	tmirec_cbFxnName;	// size in bytes of function name
	CHAR	tmirec_FxnName[1];	// bytes of function name start here
};

typedef struct tmirec_s tmirec_t;

typedef struct tagWSPhdr{
    char    chFileSignature[4];
    ULONG   ulTimeStamp;
    ULONG   ulApiCount;
    USHORT  usId;
    ULONG   ulSetSymbols;  // mdg 4/98
    ULONG   ulModNameLen;
    ULONG   ulSegSize;
    ULONG   ulOffset;
    ULONG   ulSnaps;
}WSPHDR;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wsfslib\wsfslib.c ===
/*
 * Module Name:  WSFSLIB.C
 *								
 * Library/DLL:  Common library functions for handling working set tuner files.
 *								
 *								
 * Description:							
 *
 * Library routines called by the working set tuner programs to open and
 * read working set tuner files.  These functions may be useful to ISVs, etc.,
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/26/90	- created			
 *						
 */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include <wserror.h>
#include <wsdata.h>
#include <wsfslib.h>

#define MAXLINE 128


BOOL fWsIndicator = FALSE;

/*
 *	    Function declarations and prototypes.
 */


/*
 *			
 ***EP WsWSPOpen
 *					
 * Effects:							
 *								
 * Opens a WSP file, and reads and validates the file header.
 *
 * Returns:							
 *	
 *	Returns 0.  If an error is encountered, exits with ERROR via an
 *	indirect call through pfnExit.
 */

USHORT FAR PASCAL
WsWSPOpen( PSZ pszFileName, FILE **phFile, PFN pfnExit, wsphdr_t *pWspHdr,
		INT iExitCode, INT iOpenPrintCode )
{
	ULONG	rc = NO_ERROR;
	INT		iRet = 0;
	ULONG	cbRead = 0;
	size_t	stRead = 0;

	/* Open module's input WSP file. */

	if ((*phFile = fopen(pszFileName, "rb")) == NULL)
	{
		iRet = (*pfnExit)(iExitCode, iOpenPrintCode, MSG_FILE_OPEN, rc,
				pszFileName);
		return((USHORT)iRet);
	}



	/* Read WSP file header. */
	stRead = fread((PVOID) pWspHdr, (ULONG) sizeof(*pWspHdr),1, *phFile);
	if(!stRead)
	{
		iRet = (*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_OPEN, rc,
				pszFileName);
		return((USHORT)iRet);
	}


	/* Read module pathname (directly follows file header). */

#ifdef DEBUG
	printf("WspHdr (%s): ulTime 0x%lx, ulSnaps 0x%lx, OffBits 0x%lx\n",
//			szModPath, pWspHdr->wsphdr_ulTimeStamp,
			pszFileName, pWspHdr->wsphdr_ulTimeStamp, // mdg 4/98
			pWspHdr->wsphdr_ulSnaps, pWspHdr->wsphdr_ulOffBits);
#endif /* DEBUG */

	/* Validate the WSP file header. */
	if (_strcmpi(pWspHdr->wsphdr_chSignature, "WSP"))
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_BAD_HDR, (ULONG)-1, pszFileName);

	return(NO_ERROR);
}


/*
 *			
 ***EP WsTMIOpen
 *					
 * Effects:							
 *								
 * Opens a TMI file, and reads and validates the file header.
 *
 * Returns:							
 *	
 *	Returns the number of records in the TMI file.  If an error is
 *	encountered, exits with ERROR via an indirect call through pfnExit.
 */

ULONG FAR PASCAL
WsTMIOpen( PSZ pszFileName, FILE **phFile, PFN pfnExit, USHORT usId, PCHAR pch)
{
	//ULONG	ulTmp;
	ULONG	rc = NO_ERROR;
	ULONG	cbRead = 0;
	ULONG	cFxns = 0;
	CHAR	szLineTMI[MAXLINE];	// Line from TMI file
	CHAR	szTDFID[8];		// TDF Identifier string
	ULONG	ulTDFID = 0;		// TDF Identifier

	/* Open TMI file (contains function names, etc., in ASCII). */

	if ((*phFile = fopen(pszFileName, "rt")) == NULL)
	{
		(*pfnExit)(NOEXIT, PRINT_MSG, MSG_FILE_OPEN, rc,
			pszFileName);
		return(MSG_FILE_OPEN);
	}

	/* Validate TMI file. */
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL){
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	}
							// # fxns
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL){
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	}
	szLineTMI[strlen(szLineTMI) - 1] = '\0';
	if (sscanf(szLineTMI,"/* Total Symbols= %u */", &cFxns) != 1){
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	}
							// MODNAME
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
							// MAJOR
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
							// TDFID
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	if (sscanf(szLineTMI, "TDFID   = %s", szTDFID) != 1)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	ulTDFID = strtoul(szTDFID, (char **) 0, 0);

	/* Check identifier field */

	if (ulTDFID != (ULONG) usId)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_BAD_HDR, (ULONG)-1,
				pszFileName);

	return(cFxns);
}


/*
 *			
 ***EP WsTMIReadRec
 *					
 * Effects:							
 *								
 * Reads a record from a TMI file, including the variable length function
 * name.
 *
 * Returns:							
 *	
 *	Function size, in bytes, from this record.  If an error is
 *	encountered, exits with ERROR via an indirect call through pfnExit.
 */

ULONG FAR PASCAL
WsTMIReadRec( PSZ *ppszFxnName, PULONG pulFxnIndex, PULONG pulFxnAddr,
			  FILE *hFile, PFN pfnExit, PCHAR pch)
{
	ULONG	rc;
	ULONG	cbFxn;
	UINT	uiFxnAddrObj;	// object portion of function address
	ULONG	cbFxnName;		// size in bytes of function name
	// Read in function name, etc.

	rc = fscanf(hFile, "%ld %x:%lx 0x%lx %ul",  // mdg 98/4
				pulFxnIndex, &uiFxnAddrObj, pulFxnAddr, &cbFxn,
				&cbFxnName);

	if (rc != 5)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc, "TMI file");

   *ppszFxnName = malloc( 1 + cbFxnName );   // Allocate space for function name
   if (*ppszFxnName == NULL)  // Abort if no mem
		(*pfnExit)(ERROR, PRINT_MSG, MSG_NO_MEM, 1 + cbFxnName, "TMI file");
   rc = fgetc( hFile ); // Skip leading blank space
   fgets( *ppszFxnName, cbFxnName + 1, hFile );
   rc = fgetc( hFile );
	if (rc != '\n' || strlen( *ppszFxnName ) != cbFxnName)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc, "TMI file");

   return(cbFxn);
}

LPVOID APIENTRY AllocAndLockMem(DWORD cbMem, HGLOBAL *hMem)
{

	//
	// Changed to GHND from GMEM_MOVABLE
	//
	*hMem = GlobalAlloc(GHND, cbMem);

	if(!*hMem) {
		return(NULL);
	}

	return(GlobalLock(*hMem));
}

BOOL APIENTRY  UnlockAndFreeMem(HGLOBAL hMem)
{
	BOOL fRet;

	fRet = GlobalUnlock(hMem);
	if (fRet) {
		return(fRet);
	}

	if (!GlobalFree(hMem)) {
		return(FALSE);
	}

	return(TRUE);

}

void
ConvertAppToOem( unsigned argc, char* argv[] )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;

    for( i=0; i<argc; i++ ) {
        CharToOem( argv[i], argv[i] );
    }
    SetFileApisToOEM();
}


/*
 *			
 ***EP WsIndicator
 *					
 * Effects:							
 *								
 * Displays a progress indicator on the console. Doesn't use stdout which may be
 * redirected.
 *					
 * Parameters:							
 *								
 * eFunc             Description                         nVal
 * WSINDF_NEW,       Start new indicator                 Value of 100% limit
 * WSINDF_PROGRESS,  Set progress of current indicator   Value of progress toward limit
 * WSINDF_FINISH     Mark indicator as finished          -ignored-
 * -invalid-         Do nothing
 *
 * In all valid cases, pszLabel sets string to display before indicator. If NULL,
 * uses last set string.
 *
 * Returns:							
 *	
 *	Function size, in bytes, from this record.  If an error is
 *	encountered, exits with ERROR via an indirect call through pfnExit.
 */

VOID FAR PASCAL
WsProgress( WsIndicator_e eFunc, const char *pszLbl, unsigned long nVal )
{
   static unsigned long
                     nLimit = 0, nCurrent = 0;
   static const char *
                     pszLabel = "";
   static unsigned   nLabelLen = 0;
   static char       bStarted = FALSE;
   static unsigned   nLastLen = 0;
   static HANDLE     hConsole = NULL;
   DWORD             pnChars;

   switch (eFunc)
   {
   case WSINDF_NEW:
      if (bStarted)
         WsIndicator( WSINDF_FINISH, NULL, 0 );
      bStarted = TRUE;
      nLimit = nVal;
      nCurrent = 0;
      nLastLen = ~0; // Force redraw
      WsIndicator ( WSINDF_PROGRESS, pszLbl, 0 );
      break;

   case WSINDF_PROGRESS:
      if (!bStarted)
         break;
      if (pszLbl != NULL)
      {
         pszLabel = pszLbl;
         nLabelLen = strlen( pszLabel );
      }
      if (nVal > nCurrent) // Compare to current progress (ignore reverses)
         if (nVal <= nLimit)
            nCurrent = nVal;
         else
            nCurrent = nLimit;
      {                    // Calculate an indicator string and print it
         unsigned nLen = (unsigned) ((40.1 * (double)nCurrent) / nLimit);
         char *   pszBuf;

         if (nLastLen == nLen)   // Optimization - Don't redraw if result would be the same
         {
            if (pszLbl == NULL)
               break;
         }
         else
            nLastLen = nLen;
         if (hConsole == NULL)
         {
            hConsole = CreateFile( "CONOUT$", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );
            if (hConsole == NULL)   // Couldn't get the console for some reason?
               break;
         }
         WriteConsole( hConsole, "\r", 1, &pnChars, NULL );
         WriteConsole( hConsole, pszLabel, nLabelLen, &pnChars, NULL );
         WriteConsole( hConsole, " ", 1, &pnChars, NULL );
         pszBuf = malloc( nLen + 1 );
         if (pszBuf == NULL)  // No memory? Oh, well...
            break;
         memset( pszBuf, '-', nLen );
         pszBuf[nLen] = '\0';
         WriteConsole( hConsole, pszBuf, nLen, &pnChars, NULL );
         free( pszBuf);
      }
      break;

   case WSINDF_FINISH:
      if (!bStarted)
         break;
      WsIndicator( WSINDF_PROGRESS, pszLbl, nLimit );
      if (hConsole != NULL)
      {
         WriteConsole( hConsole, "\n", 1, &pnChars, NULL );
         CloseHandle( hConsole );
         hConsole = NULL;
      }
      bStarted = FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstcat\wstcat.c ===
/*
 * Module Name:  WSTCAT.C
 *								
 * Program:	 WSTCAT
 *								
 *								
 * Description:							
 *
 * Concatenates multiple WSP files, for the same module, into one WSP file.
 * Creates a single TMI file from the resulting files.
 *
 *
 * Modification History:
 *
 * 	8-20-92	Created									marklea
 *    4-24-98, QFE:                             DerrickG (mdg)
 *             - new WSP file format for large symbol counts (ULONG vs. USHORT)
 *             - support for long file names (LFN) of input/output files
 *             - removed limit on symbol name lengths
 *	
 *	
 *				
 *								
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wsdata.h>
#include <..\wsfslib\wserror.h>
#include <..\wsfslib\wsfslib.h>

#include <ntverp.h>
#define MODULE       "WSTCAT"
#define VERSION      VER_PRODUCTVERSION_STR

/*
 *	Global variable declaration and initialization.
 */
static ULONG	rc = NO_ERROR;			// Return code


typedef struct tagTMI{
   CHAR  *pszFxnName;
	ULONG ulAddr;
	ULONG ulSize;
	ULONG ulIndex;
	BOOL  fSet;
}TMI;

typedef struct indxMOD{
	ULONG	ulSetCnt;   // mdg 4/98
	ULONG	ulFxnTot;
	ULONG	ulOffset;
	ULONG	ulSnaps;
	PULONG	pulBitStrings;
	FILE	*hFileNDX;
	TMI		*tmi;
}NDXMOD;


typedef struct tagMOD{
	ULONG	ulSetCnt;   // mdg 4/98
	UINT	uiLeft;
	ULONG	ulOffset;
	ULONG	ulSnaps;
	FILE	*hFileWxx;
	PULONG	pulAddr;
}WSTMOD;

NDXMOD	nmod;
WSTMOD	wmod[256];

CHAR	*szFileWSP;		//WSP file name
CHAR	*szFileTMI;		//TMI file name
CHAR	*szFileWxx;		//extra wsp files
CHAR	*szFileTxx;		//extra tmi files
CHAR	*szModName;		//Module or DLL name
CHAR  *szFileWSPtmp; // Temporary .WSP file name
CHAR  *szFileTMItmp; // Temporary .TMI file name
ULONG	clVarTot = 0;		// Total number of dwords in bitstr
UINT	uiModCount;

WSPHDR	WspHdr, tmpHdr;

FILE	*hFileWSP;			
FILE	*hFileTmpWSP;
FILE	*hFileTMI;
FILE	*hFileTmpTMI;

/*
 *	    Function prototypes.
 */
VOID 	wspCatSetup(VOID);
VOID 	wspCatUsage(VOID);
VOID 	wspCat(VOID);
INT 	wspCatExit(INT, USHORT, UINT, ULONG, LPSTR);
int  	WspBCompare (ULONG, PULONG);
LONG 	WspBSearch (ULONG ulAddr, WSTMOD wmod);


/****************************** M A I N **************************************
*
*	Function:	main (INT argc, CHAR *argv[])
*
*
*	Purpose:	Parses command line and dumps the WSP and TMI files
*
*	Usage:		[d:][path]wstcat modulename
*
*	where:		modulename is the name of the module whose wXX files
*				you want to concatenate.
*
*	Returns:	NONE
*
*****************************************************************************/



VOID __cdecl main (INT argc, CHAR *argv[])
{

    ConvertAppToOem( argc, argv );
	if (argc != 2) {
		wspCatUsage();
      exit( -1 );
	}
	else {
      UINT     nLen;
      char *   pDot;
      
      if ((pDot = strrchr( argv[ 1 ], '.' )) != NULL)
         *pDot = '\0';
      nLen = strlen( argv[1] ) + 1;

      szModName = malloc( nLen );
      if (szModName)
		strcpy(szModName, argv[1]);
      else {
          exit(1);
      }
      szFileWSP = malloc( nLen + 4 );
      if (szFileWSP)
		strcat( strcpy( szFileWSP, szModName ), ".WSP" );
      else {
          free(szModName);
          exit(1);
      }
      szFileTMI = malloc( nLen + 4 );
      if (szFileTMI)
		strcat( strcpy( szFileTMI, szModName ), ".TMI" );
      else {
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
      szFileWxx = malloc( nLen + 4 );
      if (szFileWxx)
		strcat( strcpy( szFileWxx, szModName ), ".Wxx" );
      else {
          free(szFileTMI);
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
      szFileTxx = malloc( nLen + 4 );
      if (szFileTxx)
		strcat( strcpy( szFileTxx, szModName ), ".Txx" );
      else {
          free(szFileWxx);
          free(szFileTMI);
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
      szFileWSPtmp = malloc( nLen + 4 );
      if (szFileWSPtmp)
		strcat( strcpy( szFileWSPtmp, szModName ), ".Wzz" );
      else {
          free(szFileTxx);
          free(szFileWxx);
          free(szFileTMI);
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
      szFileTMItmp = malloc( nLen + 4 );
      if (szFileTMItmp)
		strcat( strcpy( szFileTMItmp, szModName ), ".Tzz" );
      else {
          free(szFileTMItmp);
          free(szFileTxx);
          free(szFileWxx);
          free(szFileTMI);
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
   }

	// Setup input files for dump processing.
	wspCatSetup();
	wspCat();

   // Free allocated memory
   free( szModName );
   free( szFileWSP );
   free( szFileTMI );
   free( szFileWxx );
   free( szFileTxx );
}

/*
 *			
 ***LP wspCatSetup
 *					
 *							
 * Effects:							
 *								
 * Opens the module's WSP and TMI input files, seeks to the start of the
 * first function's bitstring data in the WSP file, and allocates memory
 * to hold one function's bitstring.
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspCatExit()
 *	with ERROR.
 *	
 */

VOID wspCatSetup(VOID)
{
	ULONG	ulTmp;
	UINT	uiExt = 0;
	UINT	x;
   char *   pszTmpName;



	/* Open input WSP file.  Read and validate WSP file header.*/

	rc = WsWSPOpen(szFileWSP, &hFileWSP,(PFN)wspCatExit,
				   (wsphdr_t *)&WspHdr, ERROR, PRINT_MSG );

	if(rc){
		exit(rc);		
	}

	//
	// Open a temporary tmi file to hold concatenated information.
	// This file will be renamed to module.tmi when the cat process
	// is complete, and the current module.tmi will be renamed to module.txx.
	//
	hFileTMI = fopen(szFileTMI, "rt");
    if (!hFileTMI) {
		wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OPEN, GetLastError(), szFileTMI);
    }
	hFileTmpTMI = fopen(szFileTMItmp, "wt");
    if (!hFileTmpTMI) {
		wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OPEN, GetLastError(), szFileTMItmp);
    }
    pszTmpName = malloc( 128 + 1 );
    if (pszTmpName) {
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        free( pszTmpName );
    }
	fclose(hFileTMI);

	//
	//	Set key, module specific information
	//
	clVarTot 	  = WspHdr.ulSnaps;
	nmod.ulSnaps  = WspHdr.ulSnaps;
	nmod.ulSetCnt = WspHdr.ulSetSymbols;   // mdg 4/98
	nmod.ulOffset = WspHdr.ulOffset;

	nmod.ulFxnTot = WsTMIOpen(szFileTMI, &hFileTMI, (PFN) wspCatExit,
							  0, (PCHAR)0);
	//
	// Open a temporary wsp file to hold concatenated information.
	// This file will be renamed to module.wsp when the cat process
	// is complete, and the current module.wsp will be renamed to module.wxx.
	// The header is also written.
	//
	hFileTmpWSP = fopen(szFileWSPtmp, "wb");
    if (!hFileTmpWSP) {
		wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OPEN, GetLastError(), szFileWSPtmp);
    }
   WspHdr.ulOffset = sizeof(WSPHDR) + strlen( szModName );  // Set data location correctly
	fwrite(&WspHdr, sizeof(WSPHDR), 1, hFileTmpWSP);
	fwrite(szModName, strlen(szModName), 1, hFileTmpWSP);

	//
	//	Allocate memory to hold TMI data for each Symbol in the
	//	main TMI file
	//
	nmod.tmi = (TMI *)malloc(nmod.ulFxnTot * sizeof(TMI));
	if (nmod.tmi == NULL) {
		wspCatExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				nmod.ulFxnTot * sizeof(TMI), "nmod.tmi[]");
	}

	//
	//	Read data for each symbol record in the key TMI file
	//
	for (x = 0; x < nmod.ulFxnTot ; x++ ) {
		nmod.tmi[x].ulSize = WsTMIReadRec(&pszTmpName, &(nmod.tmi[x].ulIndex),
								&(nmod.tmi[x].ulAddr), hFileTMI,
								(PFN)wspCatExit, (PCHAR)0);
		nmod.tmi[x].pszFxnName = pszTmpName;

    }

	fclose(hFileTMI);

	//
	//	Get Txx and Wxx specific information
	//
	while(rc == NO_ERROR){

		//
		//	Modify the file name to the first wxx and txx file
		//
		sprintf(szFileWxx, "%s.w%02d", szModName, uiExt+1);
		sprintf(szFileTxx, "%s.t%02d", szModName, uiExt+1);

		//
		//	Open file.Wxx and read header information.
		//
		rc = WsWSPOpen(szFileWxx, &(wmod[uiExt].hFileWxx),(PFN)wspCatExit,
					   (wsphdr_t *)&tmpHdr, NOEXIT, NO_MSG );

		//
		//	Check for an error from the open command.  Could be the last
		//	file.
		//
		if(rc == NO_ERROR){
			
			clVarTot += tmpHdr.ulSnaps;  //Increment the total number of
										 //Snapshots by the number from
										 //each data file.
			wmod[uiExt].ulSetCnt = tmpHdr.ulSetSymbols;  // mdg 4/98
			wmod[uiExt].uiLeft 	 = tmpHdr.ulSetSymbols; // mdg 4/98
			wmod[uiExt].ulOffset = tmpHdr.ulOffset;
			wmod[uiExt].ulSnaps  = tmpHdr.ulSnaps;
			wmod[uiExt].pulAddr  = (ULONG *)malloc(wmod[uiExt].ulSetCnt *  // mdg 4/98
												  sizeof(ULONG));
			//
			//	Open the TMI file associated with this data file
			//
			WsTMIOpen(szFileTxx, &hFileTMI,(PFN)wspCatExit,
					  0, (PCHAR)0);
			//
			//	Read each address from the TMI file.
			//
			if(rc == NO_ERROR){
				for (x = 0; x < wmod[uiExt].ulSetCnt ; x++ ) {  // mdg 4/98
					WsTMIReadRec(&pszTmpName, &ulTmp, (wmod[uiExt].pulAddr)+x,
								 hFileTMI, (PFN)wspCatExit, (PCHAR)0);
					free( pszTmpName );

				}
			}
		}

		//
		//	Increment the module index
		//
		uiExt++;


	}
	uiModCount = uiExt;

	//
	//	Allocate enough memory to hold all the bit strings for each module
	//	in a single array.
	//
	nmod.pulBitStrings = (ULONG *) malloc(clVarTot * sizeof(ULONG));

	if (nmod.pulBitStrings == NULL)
		wspCatExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				clVarTot * sizeof(ULONG), "pulBitStrings[]");


}


/*
 *			
 ***LP wspCat
 *					
 *							
 * Effects:							
 *								
 * For each function,
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspCatExit()
 *	with ERROR.
 *	
 */

VOID wspCat(VOID)
{
	UINT		uiFxn = 0;			// Function number.
	UINT		x     = 0;
	PULONG		pulBitStrings;		// Pointer to bitstring data.
	ULONG		culSnaps = 0;		// Cumulative snapshots.
	LONG		lIndex   = 0;		// Index to WSP file.
	BOOL		fSetBits = FALSE;
    CHAR    	szBuffer [256];
	ULONG    ulNewSetCnt = 0;  // mdg 4/98


	for (uiFxn = 0; uiFxn < nmod.ulFxnTot; uiFxn++)
	{

		pulBitStrings = &(nmod.pulBitStrings[0]);
		culSnaps = nmod.ulSnaps;

		//
		// Check to see if any non-zero bit strings remain
		//
		if(uiFxn < nmod.ulSetCnt){ // mdg 4/98
			//
			// Seek to function's bitstring in WSP file.
			// only for the first function
			//
			if(!uiFxn){
				if ((rc = fseek(hFileWSP,nmod.ulOffset,SEEK_SET))!=NO_ERROR)
					wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET,
								rc, szModName);
			}
		
			//
			// Read bitstring for NDX api
			//
			if (fread(pulBitStrings, sizeof(ULONG), nmod.ulSnaps, hFileWSP) != (sizeof(ULONG) * nmod.ulSnaps))
                wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET, 0, szModName);
			fSetBits = TRUE;
		}
		//
		// If not, set the bitstring to '0'.  This is faster than seeking
		// to each bit string when they are zero.
		//
		else
			memset(pulBitStrings, '\0' , (sizeof(ULONG) * nmod.ulSnaps));

		//
		// Increment the pointer to allow for the addition of the next
		// bitstring set
		//
		pulBitStrings += nmod.ulSnaps;
		//
		// Now search WSTMOD array for a matching Function address
		//
		for (x=0; x < uiModCount - 1 ; x++ ) {
			culSnaps += wmod[x].ulSnaps;
			//
			// See if there are any functions that remain
			// and if so search for them
			//
			if(wmod[x].uiLeft){
				lIndex = WspBSearch(nmod.tmi[uiFxn].ulAddr, wmod[x]);
				//
				// If search has found a matching address, get the bitstring
				// and append it pulBitStrings
				//
				if (lIndex >= 0L) {

					lIndex = wmod[x].ulOffset +
							  ( lIndex * (wmod[x].ulSnaps * sizeof(ULONG)));

					if (rc = fseek(wmod[x].hFileWxx, lIndex, SEEK_SET) != NO_ERROR)
                        wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET, rc, szModName);

					if (fread(pulBitStrings, sizeof(ULONG), wmod[x].ulSnaps, wmod[x].hFileWxx) !=
                            (sizeof(ULONG) * wmod[x].ulSnaps)) 
                    {
                        wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET, 0, szModName);
                    
                    }

					wmod[x].uiLeft--;
					fSetBits = TRUE;
				}
				//
				// Otherwise, set all bytes to 0
				//
				else{
					memset(pulBitStrings, '\0' , (sizeof(ULONG) * wmod[x].ulSnaps));
				}
			}
			//
			// Otherwise, set all bytes to 0
			//
			else
				memset(pulBitStrings, '\0' , (sizeof(ULONG) * wmod[x].ulSnaps));

			//
			// Now increment the pointer to allow for appending of additional
			// bitstring data.
			//
			pulBitStrings += wmod[x].ulSnaps;
		}
		//
		// Now we need to write the TMI & WSP file with the concatenated
		// bitstring (only if set)
		//
		nmod.tmi[uiFxn].fSet = fSetBits;
		if (fSetBits) {
			ulNewSetCnt++; // 4/98
			sprintf(szBuffer, "%ld 0000:%08lx 0x%lx %ld ",
				(LONG)nmod.tmi[uiFxn].ulIndex, nmod.tmi[uiFxn].ulAddr,
            nmod.tmi[uiFxn].ulSize, strlen( nmod.tmi[uiFxn].pszFxnName ));
			fwrite(szBuffer, sizeof(char), strlen(szBuffer), hFileTmpTMI);
         fputs( nmod.tmi[uiFxn].pszFxnName, hFileTmpTMI );
         fputc( '\n', hFileTmpTMI );
			fwrite(nmod.pulBitStrings, sizeof(ULONG), culSnaps, hFileTmpWSP);
			fSetBits = FALSE;
		}

	}

	//
	// Now write all the TMI symbols not set to the temporary .tmi file
	//
    memset(nmod.pulBitStrings, '\0' , (sizeof(ULONG) * culSnaps));
	for (uiFxn = 0; uiFxn < nmod.ulFxnTot; uiFxn++) {
		if (!nmod.tmi[uiFxn].fSet) {
			sprintf(szBuffer, "%ld 0000:%08lx 0x%lx %ld ",
				(LONG)nmod.tmi[uiFxn].ulIndex, nmod.tmi[uiFxn].ulAddr,
            nmod.tmi[uiFxn].ulSize, strlen( nmod.tmi[uiFxn].pszFxnName ));
			fwrite(szBuffer, sizeof(char), strlen(szBuffer), hFileTmpTMI);
         fputs( nmod.tmi[uiFxn].pszFxnName, hFileTmpTMI );
         fputc( '\n', hFileTmpTMI );
			fwrite(nmod.pulBitStrings, sizeof(ULONG), culSnaps, hFileTmpWSP);
		}
    }
	//
	// Seek to the beginning of the WSP file and update the snapshot
	// count in the header
	//
    if (!fseek(hFileTmpWSP, 0L, SEEK_SET)) {
        WspHdr.ulSnaps = culSnaps;
        WspHdr.ulSetSymbols = ulNewSetCnt;  // mdg 4/98
        fprintf(stdout,"Set symbols: %lu\n", WspHdr.ulSetSymbols);  // mdg 4/98
        fwrite(&WspHdr, sizeof(WSPHDR), 1, hFileTmpWSP);
    }
	_fcloseall();

	//
	// Rename the non-cat'd .wsp file and rename the cat'd temporary .wsp
	// to the original .wsp.  We might also consider deleting all the
	// Wxx and Txx files.
	//
	sprintf (szFileWxx, "%s.%s", szModName, "WSP");
	sprintf (szFileTxx, "%s.%s", szModName, "WXX");
	remove(szFileTxx);
	if (rename(szFileWxx, szFileTxx) !=0){
		printf("Unable to rename file %s to %s\n", szFileWxx, szFileTxx);
	}
	else{
		if (rename(szFileWSPtmp, szFileWSP) !=0){
			printf ("Unable to rename %s to %s!\n", szFileWSPtmp, szFileWxx);
		}
	}
	//
	// Rename the non-cat'd .tmi file and rename the cat'd temporary .tmi
	// to the original .tmi.  We might also consider deleting all the
	// Wxx and Txx files.
	//
	sprintf (szFileWxx, "%s.%s", szModName, "TMI");
	sprintf (szFileTxx, "%s.%s", szModName, "TXX");
	remove(szFileTxx);
	if (rename(szFileWxx, szFileTxx) !=0){
		printf("Unable to rename file %s to %s\n", szFileWxx, szFileTxx);
	}
	else{
		if (rename(szFileTMItmp, szFileTMI) !=0){
			printf ("Unable to rename %s to %s!\n", szFileTMItmp, szFileWxx);
		}
	}


}



/*
 *			
 * wspCatUsage	
 *					
 *							
 * Effects:							
 *								
 *	Prints out usage message, and exits with an error.			
 *								
 * Returns:							
 *	
 *	Exits with ERROR.	
 */

VOID wspCatUsage(VOID)
{
	printf("\nUsage: %s moduleName[.WSP]\n\n", MODULE);
	printf("       \"moduleName\" is the name of the module file to combine.\n\n");
	printf("%s %s\n", MODULE, VERSION);

    exit(ERROR);
}

/*
 *			
 ***LP wspCatExit
 *					
 *							
 ***							
 *							
 * Effects:							
 *								
 *	Frees up resources (as necessary).  Exits with the specified
 *	exit code, or returns void if exit code is NOEXIT.			
 *								
 ***								
 * Returns:							
 *	
 *	Void, else exits.
 */

INT wspCatExit(INT iExitCode, USHORT fPrintMsg, UINT uiMsgCode,
				ULONG ulParam1,  LPSTR pszParam2)
{
   /* Print message, if necessary. */
   if (fPrintMsg)
   {
      printf(pchMsg[uiMsgCode], MODULE, VERSION , ulParam1, pszParam2);
   }


   // Special case:  do NOT exit if called with NOEXIT.
   if (iExitCode != NOEXIT)
      exit(iExitCode);
   return(uiMsgCode);
}

/***********************  W s p B S e a r c h *******************************
 *
 *   Function:	WspBSearch(ULONG ulAddr, PULONG pulAddr)
 *
 *   Purpose:	Binary search function for finding a match in the WST array
 *
 *
 *   Parameters:
 *
 *
 *
 *   Returns:	ULONG	lIndex;
 *
 *   History:	8-5-92	Marklea - created
 *
 */

LONG WspBSearch (ULONG ulAddr, WSTMOD wmod)
{
    int 	i;
//    ULONG   ulHigh = (ULONG)wmod.usSetCnt;
    ULONG   ulHigh = (ULONG)wmod.ulSetCnt;   // mdg 4/98
    ULONG   ulLow  = 0;
    ULONG   ulMid;


    while(ulLow < ulHigh){
		ulMid = ulLow + (ulHigh - ulLow) /2;
		if((i = WspBCompare(ulAddr, wmod.pulAddr+ulMid)) < 0) {
			ulHigh = ulMid;
		}
		else if (i > 0) {
			ulLow = ulMid + 1;
		}
		else {
			return (ulMid);
		}

    }

    return (-1L);

} /* WspBSearch () */

/***********************  W s p B C o m p a r e ********************************
 *
 *   Function:	WspBCompare(ULONG ulAddr, PULONG pulAddr)
 *
 *   Purpose:	Compare values for Binary search
 *
 *
 *   Parameters:
 *
 *   Returns:	-1 if val1 < val2
 *    1 if val1 > val2
 *    0 if val1 == val2
 *
 *   History:	8-3-92	Marklea - created
 *
 */

int WspBCompare(ULONG ulAddr, PULONG pulAddr)
{
    return (ulAddr < *pulAddr ? -1:
			ulAddr == *pulAddr ? 0:
			1);

} /* WspBCompare () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wsfslib\wsfslib.h ===
/*
 * Module Name:  WSFSLIB.H
 *
 * Description:
 *
 * Working set tuner include file for WSFSLIB library functions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987-1998
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/26/90	- created			
 * 04/16/98 - QFE DerrickG (mdg):
 *            - Removed WsGetWSDIR(), change return from WsTMIReadRec()
 *						
 */


/*
 *	Constant definitions.
 */



/*
 *	Function prototypes.
 */
typedef enum   // Progress indicator for console functions
{
   WSINDF_NEW,       // Start new indicator: value = 100% limit
   WSINDF_PROGRESS,  // Set progress of current indicator; value = progress toward limit
   WSINDF_FINISH     // Mark indicator as finished; value ignored
}  WsIndicator_e;
VOID FAR PASCAL WsProgress( WsIndicator_e eFunc, const char *pszLbl, unsigned long nVal );
extern BOOL fWsIndicator;
#define WsIndicator( x, y, z )   if (fWsIndicator) WsProgress( x, y, z )

typedef int (*PFN)(UINT, INT, UINT, ULONG, LPSTR);

USHORT FAR PASCAL 	WsWSPOpen( PSZ, FILE **, PFN, wsphdr_t *, INT, INT );
ULONG  FAR PASCAL 	WsTMIOpen( PSZ, FILE **, PFN, USHORT, PCHAR );
ULONG  FAR PASCAL 	WsTMIReadRec( PSZ *, PULONG, PULONG, FILE *, PFN, PCHAR );  // mdg 98/4
LPVOID APIENTRY 	AllocAndLockMem(DWORD cbMem, HGLOBAL *hMem);
BOOL   APIENTRY 	UnlockAndFreeMem(HGLOBAL hMem);
void ConvertAppToOem( unsigned argc, char* argv[] );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstdll\wstexp.h ===
/*** WSTEXP.H - Prototypes for WST's exported routines.
 *
 *
 * Title:
 *	wstexp.h - used by WST.c
 *
 *	Copyright (c) 1992, Microsoft Corporation.
 *      Reza Baghai.
 *
 *
 * Modification History:
 *	92.07.29  RezaB -- Created
 *
 */

void  __cdecl _mcount  (void);
void  __cdecl _penter  (void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstdll\wst.c ===
/*** WST.C - Working Set Tuner Data Collection Program.
 *
 *
 * Title:
 *
 *  WST- Working Set Tuner Data Collection Program.
 *
 *  Copyright (c) 1992-1994, Microsoft Corporation.
 *  Reza Baghai.
 *
 * Description:
 *
 *  The Working Set Tuner tool is organized as follows:
 *
 *     o WST.c ........ Tools main body
 *     o WST.h
 *     o WST.def
 *
 *
 *
 * Design/Implementation Notes
 *
 *  The following defines can be used to control output of all the
 *  debugging information to the debugger via KdPrint() for the checked
 *  builds:
 *
 *  (All debugging options are undefined for free/retail builds)
 *
 *  PPC
 *  ---
 *
 *  PPC experiences problems when reading symbols in CRTDLL.dll
 *
 *  #ifdef INFODBG   : Displays messages to indicate when data dumping/
 *                                 clearing operations are completed.  It has no effect
 *                                 on timing.  *DEFAULT*
 *
 *  #ifdef SETUPDBG  : Displays messages during memory management and
 *                                 symbol lookup operations.  It has some affect
 *                                         on timing whenever a chuck of memory is committed.
 *
 *  #ifdef C6            : Generate code using C6 compiler.  C6 compiler
 *                                         calls _mcount() as the profiling routine where as
 *                                 C8 calls _penter().
 *
 *
 *
 *
 * Modification History:
 *
 *    92.07.28  RezaB -- Created
 *    94.02.08  a-honwah -- ported to MIPS and ALPHA
 *    98.04.28  DerrickG (mdg) -- QFE:
 *              - use private grow-on-demand heap for Wststrdup() - large symbol count
 *              - remove unused code associated with patching - reduce irrelevant mem usage
 *              - modify WSP file format for large symbol count (long vs. short)
 *              - modify TMI file write routine for arbitrary function name sizes
 *              - added UnmapDebugInformation() to release symbols from DBGHELP
 *              - eliminated dump for modules with no symbols
 *              - modified WST.INI parsing code for more robust section recognition
 *              - added MaxSnaps WST.INI entry in [Time Interval] section to control
 *                memory allocated for snapshot data
 *              - Modified SetSymbolSearchPath() to put current directory first in
 *                search path per standard - see docs for SymInitialize()
 *              - Removed unused internal version number (it's already in the .rc)
 *
 */

#if DBG
//
// Don't do anything for the checked builds, let it be controlled from the
// sources file.
//
#else
//
// Disable all debugging options.
//
#undef INFODBG
#undef SETUPDBG
#define SdPrint(_x_)
#define IdPrint(_x_)
#endif

#ifdef SETUPDBG
#define SdPrint(_x_)    DbgPrint _x_
#else
#define SdPrint(_x_)
#endif

#ifdef INFODBG
#define IdPrint(_x_)    DbgPrint _x_
#else
#define IdPrint(_x_)
#endif



/* * * * * * * * * * * * *  I N C L U D E    F I L E S  * * * * * * * * * * */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <excpt.h>

#include <windows.h>

#include <dbghelp.h>

#include "wst.h"
#include "wstexp.h"

#if defined(_AMD64_)

VOID
penter (
    VOID
    )

{
    return;
}

#endif

#if defined(ALPHA) || defined(AXP64)
#define REG_BUFFER_SIZE         (sizeof(DWORDLONG) * 64)
#elif defined(IA64)
#define REG_BUFFER_SIZE         sizeof(CONTEXT) / sizeof(DWORDLONG)
#endif


#if defined(ALPHA) || defined(IA64)
//typedef double DWORDLONG;  // bobw not needed in NT5
void SaveAllRegs (DWORDLONG *pSaveRegs) ;
void RestoreAllRegs (DWORDLONG *pSaveRegs) ;
void penter(void);
#endif

void     SetSymbolSearchPath  (void);
LPSTR    lpSymbolSearchPath = NULL;
#define  NO_CALLER   10L

/* * * * * * * * * *  G L O B A L   D E C L A R A T I O N S  * * * * * * * * */


/* * * * * * * * * *  F U N C T I O N   P R O T O T Y P E S  * * * * * * * * */

BOOLEAN  WSTMain  (IN PVOID DllHandle, ULONG Reason,
                   IN PCONTEXT Context OPTIONAL);

BOOLEAN  WstDllInitializations (void);

void     WstRecordInfo (DWORD_PTR dwAddress, DWORD_PTR dwPrevAddress);

void     WstGetSymbols (PIMG pCurImg, PSZ pszImageName, PVOID pvImageBase,
                        ULONG ulCodeLength,
                        PIMAGE_COFF_SYMBOLS_HEADER DebugInfo);

void     WstDllCleanups (void);

INT      WstAccessXcptFilter (ULONG ulXcptNo, PEXCEPTION_POINTERS pXcptPtr);

HANDLE   WstInitWspFile (PIMG pImg);

void     WstClearBitStrings (PIMG pImg);

void     WstDumpData (PIMG pImg);

void     WstRotateWsiMem (PIMG pImg);

void     WstWriteTmiFile (PIMG pImg);

int      WstCompare  (PWSP, PWSP);
void     WstSort     (WSP wsp[], INT iLeft, INT iRight);
int      WstBCompare (DWORD_PTR *, PWSP);
PWSP     WstBSearch  (DWORD_PTR dwAddr, WSP wspCur[], INT n);
void     WstSwap     (WSP wsp[], INT i, INT j);

DWORD    WstDumpThread  (PVOID pvArg);
DWORD    WstClearThread (PVOID pvArg);
DWORD    WstPauseThread (PVOID pvArg);

void       WstDataOverFlow(void);

#ifdef BATCHING
BOOL     WstOpenBatchFile (VOID);
#endif

#if defined(_PPC_)
//BOOL  WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);
#endif


/* * * * * * * * * * *  G L O B A L    V A R I A B L E S  * * * * * * * * * */

HANDLE              hWspSec;
PULONG              pulShared;
HANDLE              hSharedSec;
HANDLE            hWstHeap = NULL;   // mdg 4/98 for private heap

IMG                 aImg [MAX_IMAGES];
int                 iImgCnt;

HANDLE              hGlobalSem;
HANDLE              hLocalSem;
HANDLE              hDoneEvent;
HANDLE              hDumpEvent;
HANDLE              hClearEvent;
HANDLE              hPauseEvent;
HANDLE              hDumpThread;
HANDLE              hClearThread;
HANDLE              hPauseThread;
DWORD              DumpClientId;
DWORD               ClearClientId;
DWORD               PauseClientId;
PSZ                 pszBaseAppImageName;
PSZ                    pszFullAppImageName;
WSTSTATE               WstState = NOT_STARTED;
char                   achPatchBuffer [PATCHFILESZ+1] = "???";
PULONG              pulWsiBits;
PULONG              pulWspBits;
PULONG              pulCurWsiBits;
static UINT         uiTimeSegs= 0;
ULONG                  ulSegSize;
ULONG             ulMaxSnapULONGs = (MAX_SNAPS_DFLT + 31) / 32;   // mdg 98/3
ULONG                  ulSnaps = 0L;
ULONG                  ulBitCount = 0L;
LARGE_INTEGER       liStart;
int                 iTimeInterval = 0;   // mdg 98/3
BOOL                fInThread = FALSE;
ULONG               ulThdStackSize = 16*PAGE_SIZE;
BOOL                fPatchImage = FALSE;
SECURITY_DESCRIPTOR SecDescriptor;
LARGE_INTEGER       liOverhead = {0L, 0L};

#ifdef BATCHING
HANDLE              hBatchFile;
BOOL                   fBatch = TRUE;
#endif



/* * * * * *  E X P O R T E D   G L O B A L    V A R I A B L E S  * * * * * */
/* none */





/******************************  W S T M a i n  *******************************
 *
 *  WSTMain () -
 *              This is the DLL entry routine.  It performs
 *              DLL's initializations and cleanup.
 *
 *  ENTRY   -none-
 *
 *  EXIT    -none-
 *
 *  RETURN  TRUE if successful
 *          FALSE otherwise.
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

BOOLEAN WSTMain (IN PVOID DllHandle,
                 ULONG Reason,
                 IN PCONTEXT Context OPTIONAL)

{
    DllHandle;    // avoid compiler warnings
    Context;  // avoid compiler warnings


    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // Initialize the DLL data
        //
#if defined(_PPC_LIBC)
        if (!_CRT_INIT(DllHandle, Reason, Context))
            return(FALSE);
#endif
        KdPrint (("WST:  DLL_PROCESS_ATTACH\n"));
        WstDllInitializations ();
    } else if (Reason == DLL_PROCESS_DETACH) {
        //
        // Cleanup time
        //
#if defined(_PPC_LIBC)
        if (!_CRT_INIT(DllHandle, Reason, Context))
            return(FALSE);
#endif
        KdPrint (("WST:  DLL_PROCESS_DETACH\n"));
        WstDllCleanups ();
    }
#if defined(DBG)
    else {
        KdPrint (("WST:  DLL_PROCESS_??\n"));  // mdg 98/3
    }
#endif   // DBG

    return (TRUE);

} /* WSTMain() */

/******************  W s t s t r d u p  ****************************
 *
 *  Wststrdup () -
 *     Allocate a memory and then duplicate a string
 *     It is here because we don't want to use strdup in crtdll.dll
 *
 *  ENTRY   LPSTR
 *
 *  EXIT    LPSTR
 *
 *  RETURN  NULL if failed
 *          LPSTR is success
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */
LPSTR Wststrdup (LPTSTR lpInput)
// No NULL return ever - throws exception if low on memory
{
    size_t   StringLen;
    LPSTR    lpOutput;

#if defined(DBG)
    if (NULL == lpInput) {
        KdPrint (("WST:  Wststrdup() - NULL pointer\n"));    // mdg 98/3
        return NULL;
    }
#endif
    if (NULL == hWstHeap) {
        hWstHeap = HeapCreate( HEAP_GENERATE_EXCEPTIONS, 1, 0 );   // Create min size growable heap
    }
    StringLen = strlen( lpInput ) + 1;
    lpOutput = HeapAlloc( hWstHeap, HEAP_GENERATE_EXCEPTIONS, StringLen );
    if (lpOutput)
        CopyMemory( lpOutput, lpInput, StringLen );

    return lpOutput;
}



/******************  W s t D l l I n i t i a l i z a t i o n s  ***************
 *
 *  WstDllInitializations () -
 *              Performs the following initializations:
 *
 *              o  Create LOCAL semaphore (not named)
 *                      o  Create/Open global storage for WST data
 *                      o  Locate all the executables/DLLs in the address and
 *                 grab all the symbols
 *              o  Sort the symbol list
 *              o  Set the profiling flag to TRUE
 *
 *
 *  ENTRY   -none-
 *
 *  EXIT    -none-
 *
 *  RETURN  TRUE if successful
 *          FALSE otherwise.
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

BOOLEAN WstDllInitializations ()
{
    DWORD_PTR                    dwAddr = 0L;
    DWORD                        dwPrevAddr = 0L;
    ANSI_STRING                  ObjName;
    UNICODE_STRING               UnicodeName;
    OBJECT_ATTRIBUTES           ObjAttributes;
    PLDR_DATA_TABLE_ENTRY    LdrDataTableEntry;
    PPEB                         Peb;
    PSZ                          ImageName;
    PLIST_ENTRY                  Next;
    ULONG                        ExportSize;
    PIMAGE_EXPORT_DIRECTORY  ExportDirectory;
    STRING                       ImageStringName;
    LARGE_INTEGER                AllocationSize;
    SIZE_T                       ulViewSize;
    LARGE_INTEGER                liOffset = {0L, 0L};
    HANDLE                       hIniFile;
    NTSTATUS                    Status;
    IO_STATUS_BLOCK              iostatus;
    char                         achTmpImageName [32];
    PCHAR                        pchPatchExes = "";
    PCHAR                        pchPatchImports = "";
    PCHAR                        pchPatchCallers = "";
    PCHAR                        pchTimeInterval = "";
    PVOID                       ImageBase;
    ULONG                       CodeLength;
    LARGE_INTEGER                liFreq;
    PIMG                     pImg;
    PIMAGE_NT_HEADERS            pImageNtHeader;
    TCHAR                        atchProfObjsName[160] = PROFOBJSNAME;
    PTEB                        pteb = NtCurrentTeb();
    LARGE_INTEGER             liStartTicks;
    LARGE_INTEGER             liEndTicks;
    ULONG                        ulElapsed;
    PCHAR                           pchEntry;
    int                          i;                  // To match "->iSymCnt"
#ifndef _WIN64
    PIMAGE_DEBUG_INFORMATION pImageDbgInfo = NULL;
#endif


    /*
     ***
     */

    SetSymbolSearchPath();

    // Create public share security descriptor for all the named objects
    //

    Status = RtlCreateSecurityDescriptor (
                                         &SecDescriptor,
                                         SECURITY_DESCRIPTOR_REVISION1
                                         );
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlCreateSecurityDescriptor failed - 0x%lx\n", Status));  // mdg 98/3
        return (FALSE);
    }

    Status = RtlSetDaclSecurityDescriptor (
                                          &SecDescriptor,       // SecurityDescriptor
                                          TRUE,                 // DaclPresent
                                          NULL,                 // Dacl
                                          FALSE                 // DaclDefaulted
                                          );
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlSetDaclSecurityDescriptor failed - 0x%lx\n", Status));  // mdg 98/3
        return (FALSE);
    }


    /*
     ***
     */

    // Initialization for GLOBAL semaphore creation (named)
    //
    RtlInitString (&ObjName, GLOBALSEMNAME);
    Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
        return (FALSE);
    }

    InitializeObjectAttributes (&ObjAttributes,
                                &UnicodeName,
                                OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                NULL,
                                &SecDescriptor);

    // Create GLOBAL semaphore
    //
    Status = NtCreateSemaphore (&hGlobalSem,
                                SEMAPHORE_QUERY_STATE     |
                                SEMAPHORE_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                1L,
                                1L);

    RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "GLOBAL semaphore creation failed - 0x%lx\n", Status));  // mdg 98/3
        return (FALSE);
    }


    /*
     ***
     */

    // Create LOCAL semaphore (not named - only for this process context)
    //
    Status = NtCreateSemaphore (&hLocalSem,
                                SEMAPHORE_QUERY_STATE     |
                                SEMAPHORE_MODIFY_STATE    |
                                SYNCHRONIZE,
                                NULL,
                                1L,
                                1L);

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "LOCAL semaphore creation failed - 0x%lx\n",  // mdg 98/3
                  Status));
        return (FALSE);
    }


    /*
     ***
     */

    // Initialize for allocating shared memory
    //
    RtlInitString(&ObjName, SHAREDNAME);
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &ObjName, TRUE);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlAnsiStringToUnicodeString() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    InitializeObjectAttributes(&ObjAttributes,
                               &UnicodeName,
                               OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                               NULL,
                               &SecDescriptor);

    AllocationSize.HighPart = 0;
    AllocationSize.LowPart = PAGE_SIZE;

    // Create a read-write section
    //
    Status = NtCreateSection(&hSharedSec,
                             SECTION_MAP_READ | SECTION_MAP_WRITE,
                             &ObjAttributes,
                             &AllocationSize,
                             PAGE_READWRITE,
                             SEC_RESERVE,
                             NULL);
    RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "NtCreateSection() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    ulViewSize = AllocationSize.LowPart;
    pulShared = NULL;

    // Map the section - commit all
    //
    Status = NtMapViewOfSection (hSharedSec,
                                 NtCurrentProcess(),
                                 (PVOID *)&pulShared,
                                 0L,
                                 PAGE_SIZE,
                                 NULL,
                                 &ulViewSize,
                                 ViewUnmap,
                                 0L,
                                 PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "NtMapViewOfSection() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    *pulShared = 0L;

    /*
     ***
     */

    hIniFile = CreateFile (
                          WSTINIFILE,                     // The filename
                          GENERIC_READ,                   // Desired access
                          FILE_SHARE_READ,                // Shared Access
                          NULL,                           // Security Access
                          OPEN_EXISTING,                  // Read share access
                          FILE_ATTRIBUTE_NORMAL,          // Open option
                          NULL);                          // No template file

    if (hIniFile == INVALID_HANDLE_VALUE) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "Error openning %s - 0x%lx\n", WSTINIFILE, GetLastError()));
        return (FALSE);
    }

    Status = NtReadFile(hIniFile,                // DLL patch file handle
                        0L,                       // Event - optional
                        NULL,                     // Completion routine - optional
                        NULL,                     // Completion routine argument - optional
                        &iostatus,                // Completion status
                        (PVOID)achPatchBuffer,    // Buffer to receive data
                        PATCHFILESZ,              // Bytes to read
                        &liOffset,                // Byte offset - optional
                        0L);                      // Target process - optional

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "Error reading %s - 0x%lx\n", WSTINIFILE, Status));
        return (FALSE);
    } else if (iostatus.Information >= PATCHFILESZ) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "initialization file buffer too small (%lu)\n", PATCHFILESZ));
        return (FALSE);
    } else {
        achPatchBuffer [iostatus.Information] = '\0';
        _strupr (achPatchBuffer);

        // Allow for headers to appear in any order in .INI or be absent
        pchPatchExes = strstr( achPatchBuffer, PATCHEXELIST );
        pchPatchImports = strstr( achPatchBuffer, PATCHIMPORTLIST );
        pchTimeInterval = strstr( achPatchBuffer, TIMEINTERVALIST );
        if (pchPatchExes != NULL) {
            if (pchPatchExes > achPatchBuffer)
                *(pchPatchExes - 1) = '\0';
        } else {
            pchPatchExes = "";
        }
        if (pchPatchImports != NULL) {
            if (pchPatchImports > achPatchBuffer)
                *(pchPatchImports - 1) = '\0';
        } else {
            pchPatchImports = "";
        }
        if (pchTimeInterval != NULL) {
            const char *   pSnapsEntry = strstr( pchTimeInterval, MAX_SNAPS_ENTRY );

            if (pchTimeInterval > achPatchBuffer)
                *(pchTimeInterval - 1) = '\0';
            if (pSnapsEntry) {
                long     lSnapsEntry =
                atol( pSnapsEntry + sizeof( MAX_SNAPS_ENTRY ) - 1 );
                if (lSnapsEntry > 0)
                    ulMaxSnapULONGs = (lSnapsEntry + 31) / 32;
            }
        } else {
            pchTimeInterval = "";
        }
    }

    NtClose (hIniFile);

    SdPrint (("WST:  WstDllInitializations() - Patching info:\n"));
    SdPrint (("WST:    -- %s\n", pchPatchExes));
    SdPrint (("WST:    -- %s\n", pchPatchImports));
    SdPrint (("WST:    -- %s\n", pchTimeInterval));


    /*
     ***
     */

    // Initialize for allocating global storage for WSPs
    //
    _ui64toa ((ULONG64)pteb->ClientId.UniqueProcess, atchProfObjsName+75, 10);
    _ui64toa ((ULONG64)pteb->ClientId.UniqueThread,  atchProfObjsName+105, 10);
    strcat (atchProfObjsName, atchProfObjsName+75);
    strcat (atchProfObjsName, atchProfObjsName+105);

    SdPrint (("WST:  WstDllInitializations() - %s\n", atchProfObjsName));

    RtlInitString(&ObjName, atchProfObjsName);
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &ObjName, TRUE);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlAnsiStringToUnicodeString() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    InitializeObjectAttributes (&ObjAttributes,
                                &UnicodeName,
                                OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                NULL,
                                &SecDescriptor);

    AllocationSize.HighPart = 0;
    AllocationSize.LowPart = MEMSIZE;

    // Create a read-write section
    //
    Status =NtCreateSection(&hWspSec,
                            SECTION_MAP_READ | SECTION_MAP_WRITE,
                            &ObjAttributes,
                            &AllocationSize,
                            PAGE_READWRITE,
                            SEC_RESERVE,
                            NULL);

    RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "NtCreateSection() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    ulViewSize = AllocationSize.LowPart;
    pImg = &aImg[0];
    pImg->pWsp = NULL;

    // Map the section - commit the first 4 * COMMIT_SIZE pages
    //
    Status = NtMapViewOfSection(hWspSec,
                                NtCurrentProcess(),
                                (PVOID *)&(pImg->pWsp),
                                0L,
                                COMMIT_SIZE * 4,
                                NULL,
                                &ulViewSize,
                                ViewUnmap,
                                0L,
                                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "NtMapViewOfSection() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    try /* EXCEPT - to handle access violation exception. */ {
        //
        // Locate all the executables/DLLs in the address and get their symbols
        //
        BOOL fTuneApp = FALSE;  // Set if whole app is to be tuned
        iImgCnt = 0;
        Peb = NtCurrentPeb();
        Next = Peb->Ldr->InMemoryOrderModuleList.Flink;

        for (; Next != &Peb->Ldr->InMemoryOrderModuleList; Next = Next->Flink) {
            IdPrint (("WST:  WstDllInitializations() - Walking module chain: 0x%lx\n", Next));
            LdrDataTableEntry =
            (PLDR_DATA_TABLE_ENTRY)
            (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InMemoryOrderLinks));

            ImageBase = LdrDataTableEntry->DllBase;
            if ( Peb->ImageBaseAddress == ImageBase ) {

                RtlUnicodeStringToAnsiString (&ImageStringName,
                                              &LdrDataTableEntry->BaseDllName,
                                              TRUE);
                ImageName = ImageStringName.Buffer;
                pszBaseAppImageName = ImageStringName.Buffer;

                RtlUnicodeStringToAnsiString (&ImageStringName,
                                              &LdrDataTableEntry->FullDllName,
                                              TRUE);
                pszFullAppImageName = ImageStringName.Buffer;
                //
                //      Skip the object directory name (if any)
                //
                if ( (pszFullAppImageName = strchr(pszFullAppImageName, ':')) ) {
                    pszFullAppImageName--;
                } else {
                    pszFullAppImageName = pszBaseAppImageName;
                }
                IdPrint (("WST:  WstDllInitializations() - FullAppImageName: %s\n", pszFullAppImageName));
            } else {
                ExportDirectory =
                (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData (
                                                                      ImageBase,
                                                                      TRUE,
                                                                      IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                      &ExportSize);

                ImageName = (PSZ)((ULONG_PTR)ImageBase + ExportDirectory->Name);
                IdPrint (("WST:  WstDllInitializations() - ImageName: %s\n", ImageName));
            }

            pImageNtHeader = RtlImageNtHeader (ImageBase);

            _strupr (strcpy (achTmpImageName, ImageName));
            pchEntry = strstr (pchPatchExes, achTmpImageName);
            if (pchEntry) {
                if (*(pchEntry-1) == ';') {
                    pchEntry = NULL;
                } else if ( Peb->ImageBaseAddress == ImageBase )
                    fTuneApp = TRUE;
            }

            if ( strcmp (achTmpImageName, WSTDLL) && (pchEntry || fTuneApp) ) {
                if ( !fPatchImage )
                    fPatchImage = TRUE;
                //
                // Locate the code range.
                //
                pImg->pszName = Wststrdup (ImageName);
                pImg->ulCodeStart = 0L;
                pImg->ulCodeEnd = 0L;
                pImg->iSymCnt = 0;

#ifndef _WIN64
                pImageDbgInfo = MapDebugInformation (0L,
                                                     ImageName,
                                                     lpSymbolSearchPath,
                                                     (DWORD)ImageBase);

                if (pImageDbgInfo == NULL) {
                    IdPrint (("WST:  WstDllInitializations() - "
                              "No symbols for %s\n", ImageName));
                } else if ( pImageDbgInfo->CoffSymbols == NULL ) {
                    IdPrint (("WST:  WstDllInitializations() - "
                              "No coff symbols for %s\n", ImageName));
                } else {
                    PIMAGE_COFF_SYMBOLS_HEADER  DebugInfo;

                    DebugInfo = pImageDbgInfo->CoffSymbols;
                    if (DebugInfo->LvaToFirstSymbol == 0L) {
                        IdPrint (("WST:  WstDllInitializations() - "
                                  "Virtual Address to coff symbols not set for %s\n",
                                  ImageName));
                    } else {
                        CodeLength = (DebugInfo->RvaToLastByteOfCode -
                                      DebugInfo->RvaToFirstByteOfCode) - 1;
                        pImg->ulCodeStart = (ULONG)ImageBase +
                                            DebugInfo->RvaToFirstByteOfCode;
                        pImg->ulCodeEnd = pImg->ulCodeStart + CodeLength;
                        IdPrint(( "WST:  WstDllInitializations() - %ul total symbols\n", DebugInfo->NumberOfSymbols ));
                        WstGetSymbols (pImg, ImageName, ImageBase, CodeLength,
                                       DebugInfo);
                    }
                    // mdg 98/3
                    // Must release debug information - should not stay around cluttering up memory!
                    if (!UnmapDebugInformation( pImageDbgInfo ))
                        KdPrint(("WST:  WstDllInitializations() - failure in UnmapDebugInformation()\n"));
                    pImageDbgInfo = NULL;
                } // if pImageDbgInfo->CoffSymbols != NULL
#endif      // _WIN64

                IdPrint (("WST:  WstDllInitializations() - @ 0x%08lx "
                          "image #%d = %s; %d symbols extracted\n", (ULONG)ImageBase, iImgCnt,
                          ImageName, pImg->iSymCnt));
                pImg->pWsp[pImg->iSymCnt].pszSymbol = UNKNOWN_SYM;
                pImg->pWsp[pImg->iSymCnt].ulFuncAddr = UNKNOWN_ADDR;
                pImg->pWsp[pImg->iSymCnt].ulBitString = 0;  // mdg 98/3
                pImg->pWsp[pImg->iSymCnt].ulCodeLength = 0;  // mdg 98/3
                (pImg->iSymCnt)++;

                //
                // Set wsi.
                //
                pImg->pulWsi = pImg->pulWsiNxt = (PULONG)
                                                 (pImg->pWsp + pImg->iSymCnt);
                RtlZeroMemory (pImg->pulWsi,
                               pImg->iSymCnt * ulMaxSnapULONGs * sizeof(ULONG));


                //
                // Set wsp.
                //
                pImg->pulWsp = (PULONG)(pImg->pulWsi +
                                        (pImg->iSymCnt * ulMaxSnapULONGs));
                RtlZeroMemory (pImg->pulWsp,
                               pImg->iSymCnt * ulMaxSnapULONGs * sizeof(ULONG));

                //
                // Sort wsp & set code lengths
                //
                WstSort (pImg->pWsp, 0, pImg->iSymCnt-1);
                //
                // Last symbol length is set to be the same as length of
                // (n-1)th symbol or remaining code length of module
                //
                i = pImg->iSymCnt - 1;  // mdg 98/3 (assert pImg->iSymCnt is at least 1)
                if (i--) {   // Test count & set index to top symbol
                    pImg->pWsp[i].ulCodeLength = (ULONG)(
                    i ? pImg->pWsp[i].ulFuncAddr - pImg->pWsp[i - 1].ulFuncAddr
                    : pImg->ulCodeEnd + 1 - pImg->pWsp[i].ulFuncAddr);

                    while (i-- > 0) {   // Enumerate symbols & set index
                        pImg->pWsp[i].ulCodeLength = (ULONG)(pImg->pWsp[i+1].ulFuncAddr -
                                                     pImg->pWsp[i].ulFuncAddr);
                    }
                }

                //
                // Setup next pWsp
                //
                (pImg+1)->pWsp = (PWSP)(pImg->pulWsp +
                                        (pImg->iSymCnt * ulMaxSnapULONGs));
                iImgCnt++;
                pImg++;

                if (iImgCnt == MAX_IMAGES) {
                    KdPrint(("WST:  WstDllInitialization() - Not enough "
                             "space allocated for all images\n"));
                    return (FALSE);
                }
            }

        }  // if (Next != &Peb->Ldr->InMemoryOrderModuleList)
    } // try
    //
    // + : transfer control to the handler (EXCEPTION_EXECUTE_HANDLER)
    // 0 : continue search             (EXCEPTION_CONTINUE_SEARCH)
    // - : dismiss exception & continue   (EXCEPTION_CONTINUE_EXECUTION)
    //
    except ( WstAccessXcptFilter (GetExceptionCode(), GetExceptionInformation()) )
    {
        //
        // Should never get here since filter never returns
        // EXCEPTION_EXECUTE_HANDLER.
        //
        KdPrint (("WST:  WstDllInitializations() - *LOGIC ERROR* - "
                  "Inside the EXCEPT: (xcpt=0x%lx)\n", GetExceptionCode()));
    }
    /*
     ***
     */

    //
    // Get the frequency
    //
    NtQueryPerformanceCounter (&liStart, &liFreq);

    if (strlen(pchTimeInterval) > (sizeof(TIMEINTERVALIST)+1))  // mdg 98/3
        iTimeInterval = atoi (pchTimeInterval+sizeof(TIMEINTERVALIST)+1);
    if ( iTimeInterval == 0 ) {
        //
        // Use the default value
        //
        iTimeInterval = TIMESEG;
    }
    ulSegSize = iTimeInterval * (liFreq.LowPart / 1000);

#ifdef BATCHING
    fBatch = WstOpenBatchFile();
#endif

    SdPrint (("WST:  Time interval:  Millisecs=%d  Ticks=%lu\n",
              iTimeInterval, ulSegSize));

    if (fPatchImage) {

        // Initialization for DONE event creation
        //
        RtlInitString (&ObjName, DONEEVENTNAME);
        Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
            return (FALSE);
        }

        InitializeObjectAttributes (&ObjAttributes,
                                    &UnicodeName,
                                    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    &SecDescriptor);
        // Create DONE event
        //
        Status = NtCreateEvent (&hDoneEvent,
                                EVENT_QUERY_STATE    |
                                EVENT_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                NotificationEvent,
                                TRUE);
        RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "DONE event creation failed - 0x%lx\n", Status));  // mdg 98/3
            return (FALSE);
        }


        // Initialization for DUMP event creation
        //
        RtlInitString (&ObjName, DUMPEVENTNAME);
        Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
            return (FALSE);
        }

        InitializeObjectAttributes (&ObjAttributes,
                                    &UnicodeName,
                                    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    &SecDescriptor);
        // Create DUMP event
        //
        Status = NtCreateEvent (&hDumpEvent,
                                EVENT_QUERY_STATE    |
                                EVENT_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                NotificationEvent,
                                FALSE);
        RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "DUMP event creation failed - 0x%lx\n", Status));  // mdg 98/3
            return (FALSE);
        }


        // Initialization for CLEAR event creation
        //
        RtlInitString (&ObjName, CLEAREVENTNAME);
        Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
            return (FALSE);
        }

        InitializeObjectAttributes (&ObjAttributes,
                                    &UnicodeName,
                                    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    &SecDescriptor);

        // Create CLEAR event
        //
        Status = NtCreateEvent (&hClearEvent,
                                EVENT_QUERY_STATE    |
                                EVENT_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                NotificationEvent,
                                FALSE);
        RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "CLEAR event creation failed - 0x%lx\n", Status));  // mdg 98/3
            return (FALSE);
        }


        // Initialization for PAUSE event creation
        //
        RtlInitString (&ObjName, PAUSEEVENTNAME);
        Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
            return (FALSE);
        }

        InitializeObjectAttributes (&ObjAttributes,
                                    &UnicodeName,
                                    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    &SecDescriptor);
        // Create PAUSE event
        //
        Status = NtCreateEvent (&hPauseEvent,
                                EVENT_QUERY_STATE    |
                                EVENT_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                NotificationEvent,
                                FALSE);
        RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "PAUSE event creation failed - 0x%lx\n", Status));  // mdg 98/3
            return (FALSE);
        }

        //
        // Calculate excess overhead for WstRecordInfo
        //
        liOverhead.HighPart = 0L;
        liOverhead.LowPart  = 0xFFFFFFFF;
        for (i=0; i < NUM_ITERATIONS; i++) {
            NtQueryPerformanceCounter (&liStartTicks, NULL);
            //
            WSTUSAGE(NtCurrentTeb()) = 0L;

#ifdef i386
            _asm
            {
                push  edi
                mov     edi, dword ptr [ebp+4]
                mov     dwAddr, edi
                mov     edi, dword ptr [ebp+8]
                mov     dwPrevAddr, edi
                pop     edi
            }
#endif

#if defined(ALPHA) || defined(IA64)
            {
                PULONG  pulAddr;
                DWORDLONG SaveRegisters [REG_BUFFER_SIZE] ;

                SaveAllRegs (SaveRegisters);

                pulAddr = (PULONG) dwAddr;
                pulAddr -= 1;

                RestoreAllRegs (SaveRegisters);
            }
#elif defined(_X86_)
            SaveAllRegs ();
            RestoreAllRegs ();
#endif
            WSTUSAGE(NtCurrentTeb()) = 0L;
            Status = NtWaitForSingleObject (hLocalSem, FALSE, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDllInitilizations() - "
                          "Wait for LOCAL semaphore failed - 0x%lx\n", Status));
            }
            liStart.QuadPart = liStart.QuadPart - liStart.QuadPart ;
            liStart.QuadPart = liStart.QuadPart + liStart.QuadPart ;
            liStart.QuadPart = liStart.QuadPart + liStart.QuadPart ;

            Status = NtReleaseSemaphore (hLocalSem, 1, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDllInitializations() - "
                          "Error releasing LOCAL semaphore - 0x%lx\n", Status));
            }
            WSTUSAGE(NtCurrentTeb()) = 0L;
            //
            NtQueryPerformanceCounter (&liEndTicks, NULL);
            ulElapsed = liEndTicks.LowPart - liStartTicks.LowPart;
            if (ulElapsed < liOverhead.LowPart) {
                liOverhead.LowPart = ulElapsed;
            }
        }
        SdPrint (("WST:  WstDllInitializations() - WstRecordInfo() overhead = %lu\n",
                  liOverhead.LowPart));

        // Start monitor threads
        //
        hDumpThread = CreateThread (
                                   NULL,                                   // no security attribute
                                   (DWORD)1024L,                           // initial stack size
                                   (LPTHREAD_START_ROUTINE)WstDumpThread,  // thread starting address
                                   NULL,                                   // no argument for the thread
                                   (DWORD)0,                               // no creation flag
                                   &DumpClientId);                         // address for thread id
        hClearThread = CreateThread (
                                    NULL,                                   // no security attribute
                                    (DWORD)1024L,                           // initial stack size
                                    (LPTHREAD_START_ROUTINE)WstClearThread, // thread starting address
                                    NULL,                                   // no argument for the thread
                                    (DWORD)0,                               // no creation flag
                                    &ClearClientId);                        // address for thread id
        hPauseThread = CreateThread (
                                    NULL,                                   // no security attribute
                                    (DWORD)1024L,                           // initial stack size
                                    (LPTHREAD_START_ROUTINE)WstPauseThread, // thread starting address
                                    NULL,                                   // no argument for the thread
                                    (DWORD)0,                               // no creation flag
                                    &PauseClientId);                        // address for thread id

        NtQueryPerformanceCounter (&liStart, NULL);
        WstState = STARTED;
    }

    return (TRUE);

} /* WstDllInitializations () */





/******************************  _ p e n t e r  ******************************
 *
 *  _penter() / _mcount() -
 *              This is the main profiling routine.  This routine is called
 *              upon entry of each routine in the profiling DLL/EXE.
 *
 *  ENTRY   -none-
 *
 *  EXIT    -none-
 *
 *  RETURN  -none-
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              Compiling apps with -Gp option trashs EAX initially.
 *
 */
#ifdef i386
void __cdecl _penter ()
#elif defined(ALPHA) || defined(IA64) || defined(_AMD64_)
void c_penter (ULONG_PTR dwPrevious, ULONG_PTR dwCurrent)
#endif
{
    DWORD_PTR        dwAddr;
    DWORD_PTR        dwPrevAddr;
    ULONG_PTR        ulInWst ;
#if defined(ALPHA) || defined(_AXP64_) || defined(IA64)
    PULONG  pulAddr;
    DWORDLONG SaveRegisters [REG_BUFFER_SIZE];
    SaveAllRegs(SaveRegisters) ;
#endif

    dwAddr = 0L;
    dwPrevAddr = 0L;
    ulInWst = WSTUSAGE(NtCurrentTeb());

    if (WstState != STARTED) {
        goto Exit0;
    } else if (ulInWst) {
        goto Exit0;
    }


    //
    //  Put the address of the calling function into var dwAddr
    //
#ifdef i386
    _asm
    {
        push  edi
        mov     edi, dword ptr [ebp+4]
        mov     dwAddr, edi
        mov     edi, dword ptr [ebp+8]
        mov     dwPrevAddr, edi
        pop     edi
    }
#endif

#if defined(ALPHA) || defined(IA64)
    dwPrevAddr = NO_CALLER;
    dwAddr = dwCurrent;
    // GetCaller (&dwAddr, 0x0220);  // FIXFIX StackSize

    // now check if we are calling from the stub we created
    pulAddr = (PULONG) dwAddr;
    pulAddr -= 1;

    if (*(pulAddr)          == 0x681b4000  &&
        (*(pulAddr  + 1)     == 0xa75e0008) &&
        (*(pulAddr  + 8)     == 0xfefe55aa) ) {

        // get the address that we will go after the penter function
        dwAddr = *(pulAddr + 4) & 0x0000ffff;
        if (*(pulAddr + 5) & 0x00008000) {
            // fix the address since we have to add one when
            // we created our stub code
            dwAddr -= 1;
        }
        dwAddr = dwAddr << 16;
        dwAddr |= *(pulAddr + 5) & 0x0000ffff;

        // get the caller to the stub
        dwPrevAddr = dwPrevious;
        // GetStubCaller (&dwPrevAddr, 0x0220);   // FIXFIX StackSize
    }


#endif


    //
    //  Call WstRecordInfo for this API
    //
#ifdef i386
    SaveAllRegs ();
#endif

    WstRecordInfo (dwAddr, dwPrevAddr);

#ifdef i386
    RestoreAllRegs ();
#endif


    Exit0:

#if defined(ALPHA) || defined(IA64)
    RestoreAllRegs (SaveRegisters);
#endif

    return;
} /* _penter() / _mcount()*/

void __cdecl _mcount ()
{
}





/*************************  W s t R e c o r d I n f o  ************************
 *
 *  WstRecordInfo (dwAddress) -
 *
 *  ENTRY   dwAddress - Address of the routine just called
 *
 *  EXIT    -none-
 *
 *  RETURN  -none-
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

void WstRecordInfo (DWORD_PTR dwAddress, DWORD_PTR dwPrevAddress)
{

    NTSTATUS         Status;
    INT          x;
    INT              i, iIndex;
    PWSP         pwspTmp;
    LARGE_INTEGER   liNow, liTmp;
    LARGE_INTEGER    liElapsed;
    CHAR         *pszSym;

#ifdef BATCHING
    CHAR         szBatchBuf[128];
    DWORD            dwCache;
    DWORD            dwHits;
    DWORD            dwBatch;
    IO_STATUS_BLOCK ioStatus;
#endif


    WSTUSAGE(NtCurrentTeb()) = 1;

    //
    //  Wait for the semaphore object to suspend execution of other threads
    //
    Status = NtWaitForSingleObject (hLocalSem, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstRecordInfo() - "
                  "Wait for LOCAL semaphore failed - 0x%lx\n", Status));
    }

    NtQueryPerformanceCounter(&liNow, NULL);
    liElapsed.QuadPart = liNow.QuadPart - liStart.QuadPart ;


    //   SdPrint(("WST:  WstRecordInfo() - Elapsed time: %ld\n", liElapsed.LowPart));

    //
    //  WstBSearch is a binary find function that will return the address of
    //  the wsp record we want
    //

    //   SdPrint(("WST:  WstRecordInfo() - Preparing for WstBSearch of 0x%lx\n",
    //      dwAddress-5));

    pwspTmp = NULL;
    for (i=0; i<iImgCnt; i++) {
        if ( (dwAddress >= aImg[i].ulCodeStart) &&
             (dwAddress < aImg[i].ulCodeEnd) ) {
#ifdef i386
            pwspTmp = WstBSearch(dwAddress-5, aImg[i].pWsp, aImg[i].iSymCnt);
            if (!pwspTmp) {
                pwspTmp = WstBSearch(UNKNOWN_ADDR, aImg[i].pWsp, aImg[i].iSymCnt);
            }
#else
            // the following works for both MIPS and ALPHA

            pwspTmp = WstBSearch(dwAddress, aImg[i].pWsp, aImg[i].iSymCnt);
            if (!pwspTmp) {
                // symbol not found
                pwspTmp = WstBSearch(UNKNOWN_ADDR, aImg[i].pWsp, aImg[i].iSymCnt);
            }
#endif
            break;
        }
    }
    iIndex = i;

    if (pwspTmp) {
        pszSym = pwspTmp->pszSymbol;
        pwspTmp->ulBitString |= 1;
    } else {
        SdPrint (("WST:  WstRecordInfo() - LOGIC ERROR - Completely bogus addr = 0x%08lx\n",
                  dwAddress));   // We could also get here if moduled compiled with -Gh but no COFF symbols available
    }

    if (liElapsed.LowPart >= ulSegSize) {
        SdPrint(("WST:  WstRecordInfo() - ulSegSize expired; "
                 "Preparing to shift the BitStrings\n"));

        if (ulBitCount < 31) {
            for (i=0; i<iImgCnt; i++) {
                for (x=0; x < aImg[i].iSymCnt ; x++ ) {
                    aImg[i].pWsp[x].ulBitString <<= 1;
                }
            }
        }

        liElapsed.LowPart = 0L;
        ulBitCount++;
        NtQueryPerformanceCounter(&liStart, NULL);
        liNow = liStart;

        if (ulBitCount == 32) {
            SdPrint(("WST:  WstRecordInfo() - Dump Bit Strings\n"));
            for (i=0; i<iImgCnt; i++) {
                for (x=0; x < aImg[i].iSymCnt ; x++ ) {
                    aImg[i].pulWsiNxt[x] = aImg[i].pWsp[x].ulBitString;
                    aImg[i].pWsp[x].ulBitString = 0L;
                }
                aImg[i].pulWsiNxt += aImg[i].iSymCnt;
            }
            ulSnaps++;
            ulBitCount = 0;
            if (ulSnaps == ulMaxSnapULONGs) {
                KdPrint (("WST:  WstRecordInfo() - No more space available"
                          " for next time snap data!\n"));
                //
                // Dump and clear the data
                //
                WstDataOverFlow();
            }
        }
    }

#ifdef BATCHING
    //
    //  The following code will get the current batching information
    //  if the DLL was compiled with the BATCHING variable set.  You
    //  should not have this variable set if you are tuning GDI.
    //
    if (fBatch) {
        GdiGetCsInfo(&dwHits, &dwBatch, &dwCache);

        if (dwHits)
            GdiResetCsInfo();

        if (dwBatch == 10)
            GdiResetCsInfo();

        while (*(pszSym++) != '_');

        sprintf(szBatchBuf, "%s:%s,%ld,%ld,%ld\n",
                aImg[iIndex].pszName, pszSym, dwHits, dwBatch, dwCache);
        Status = NtWriteFile(hBatchFile,
                             NULL,
                             NULL,
                             NULL,
                             &ioStatus,
                             szBatchBuf,
                             strlen(szBatchBuf),
                             NULL,
                             NULL
                            );

        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstRecodInfo() - "
                      "NtWriteFile() failed on hBatchFile - 0x%lx\n", Status));
        }
    }//Batching info
#endif


    //
    //  We call NtQueryPerformanceCounter here to account for the overhead
    //  required for doing our work
    //
    NtQueryPerformanceCounter(&liTmp, NULL);
    liElapsed.QuadPart = liTmp.QuadPart - liNow.QuadPart ;
    liStart.QuadPart = liStart.QuadPart + liElapsed.QuadPart ;
    liStart.QuadPart = liStart.QuadPart + liOverhead.QuadPart ;

    //
    // Release semaphore to continue execution of other threads
    //
    Status = NtReleaseSemaphore (hLocalSem, 1, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstRecordInfo () - "
                  "Error releasing LOCAL semaphore - 0x%lx\n", Status));
    }

    WSTUSAGE(NtCurrentTeb()) = 0L;

} /* WstRecordInfo () */





/********************  W s t C l e a r B i t S t r i n g  *********************
 *
 *  Function:   WstClearBitStrings (pImg)
 *
 *  Purpose:    This function clears the BitString for each symbol.
 *
 *  Parameters: pImg - Current image data structure pointer
 *
 *  Returns:    -none-
 *
 *  History:    8-3-92  Marklea - created
 *
 */

void WstClearBitStrings (PIMG pImg)
{
    UINT    uiLshft = 0;
    INT  x;


    //
    //  Since we are completed with the profile, we need to create a
    //  DWORD out of the balance of the bitString.  We do this by  left
    //  shifting the bitstring by difference between the bitCount and
    //  32.
    //
    if (ulBitCount < 32) {
        uiLshft =(UINT)(31 - ulBitCount);
        for (x=0; x < pImg->iSymCnt; x++) {
            pImg->pWsp[x].ulBitString <<= uiLshft;
            pImg->pulWsiNxt[x] = pImg->pWsp[x].ulBitString;
        }
        pImg->pulWsiNxt += pImg->iSymCnt;
    }


} /* WstClearBitStrings () */





/***********************  W s t I n i t W s p F i l e  ***********************
 *
 *   Function:  WstInitWspFile (pImg)
 *
 *   Purpose:   This function will create a WSP file and dump the header
 *               information for the file.
 *
 *   Parameters: pImg - Current image data structure pointer
 *
 *   Returns:   Handle to the WSP file.
 *
 *   History:   8-3-92  Marklea - created
 *
 */

HANDLE WstInitWspFile (PIMG pImg)
{
    CHAR    szOutFile [256] = WSTROOT;
    CHAR szModName [128] = {0};
    PCHAR pDot;
    CHAR szExt [5] = "WSP";
    WSPHDR  wsphdr;
    DWORD   dwBytesWritten;
    BOOL    fRet;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    int      iExt = 0;

    //
    //  Prepare the filename path
    //
    strcat (szOutFile, pImg->pszName);

    //
    //  Open the file for binary output.
    //
    pImg->fDumpAll = TRUE;
    while (iExt < 256) {
        strcpy ((strchr(szOutFile,'.'))+1, szExt);
        hFile = CreateFile ( szOutFile,      // WSP file handle
                             GENERIC_WRITE |
                             GENERIC_READ, // Desired access
                             0L,             // Read share access
                             NULL,           // No EaBuffer
                             CREATE_NEW,
                             FILE_ATTRIBUTE_NORMAL,
                             0);             // EaBuffer length
        if (hFile != INVALID_HANDLE_VALUE) {
            IdPrint(("WST:  WstInitWspFile() - WSP file name: %s\n",
                     szOutFile));
            if (iExt != 0) {
                pImg->fDumpAll = FALSE;
            }
            break;
        }
        iExt++;
        sprintf (szExt, "W%02x", iExt);
    }
    if (iExt == 256) {
        KdPrint (("WST:  WstInitWspFile() - "
                  "Error creating %s - 0x%lx\n", szOutFile,
                  GetLastError()));
        return (hFile);
    }

    //
    //  Fill a WSP header structure
    //

    strcpy(szModName, pImg->pszName);
    pDot = strchr(szModName, '.');
    if (pDot)
        strcpy(pDot, "");

    strcpy(wsphdr.chFileSignature, "WSP");
    wsphdr.ulTimeStamp   = 0L;
    wsphdr.usId         = 0;
    wsphdr.ulApiCount    = 0;
    wsphdr.ulSetSymbols  = pImg->ulSetSymbols;
    wsphdr.ulModNameLen  = strlen(szModName);
    wsphdr.ulSegSize = (ULONG)iTimeInterval;
    wsphdr.ulOffset      = wsphdr.ulModNameLen + (ULONG)sizeof(WSPHDR);
    wsphdr.ulSnaps      = ulSnaps;

    //
    //  Write header and module name
    //
    fRet = WriteFile(hFile,                      // Wsp file handle
                     (PVOID)&wsphdr,           // Buffer of data
                     (ULONG)sizeof(WSPHDR),    // Bytes to write
                     &dwBytesWritten,          // Bytes written
                     NULL);

    if (!fRet) {
        KdPrint (("WST:  WstInitWspFile() - "
                  "Error writing to %s - 0x%lx\n", szOutFile,
                  GetLastError));
        return (NULL);
    }

    fRet = WriteFile (hFile,                 // Wsp file handle
                      (PVOID)szModName,         // Buffer of data
                      (ULONG)strlen(szModName),     // Bytes to write
                      &dwBytesWritten,
                      NULL);
    if (!fRet) {
        KdPrint (("WST:  WstInitWspFile() - "
                  "Error writing to %s - 0x%lx\n", szOutFile,
                  GetLastError()));
        return (NULL);
    }

    return (hFile);

} /* WstInitWspFile () */





/**************************  W s t D u m p D a t a  **************************
 *
 *   Function:  WstDumpData (pImg)
 *
 *   Purpose:
 *
 *   Parameters: pImg - Current image data structure pointer
 *
 *   Returns:   NONE
 *
 *   History:   8-3-92  Marklea - created
 *
 */

void WstDumpData (PIMG pImg)
{
    INT      x = 0;
    DWORD    dwBytesWritten;
    BOOL     fRet;
    HANDLE   hWspFile;


    if ( !(hWspFile = WstInitWspFile(pImg)) ) {
        KdPrint (("WST:  WstDumpData() - Error creating WSP file.\n"));
        return;
    }

    //
    // Write all the symbols with any bits set
    //
    for (x=0; x<pImg->iSymCnt; x++) {
        if (pImg->pWsp[x].ulBitString) {
            fRet = WriteFile(
                            hWspFile,                          // Wsp file handle
                            (PVOID)(pImg->pulWsp+(x*ulSnaps)),  // Buffer of data
                            ulSnaps * sizeof(ULONG),           // Bytes to write
                            &dwBytesWritten,                       // Bytes written
                            NULL);                             // Optional
            if (!fRet) {
                KdPrint (("WST:  WstDumpData() - "
                          "Error writing to WSP file - 0x%lx\n",
                          GetLastError()));
                return;
            }
        }
    }
    //
    // Now write all the symbols with no bits set
    //
    if (pImg->fDumpAll) {
        for (x=0; x<pImg->iSymCnt; x++) {
            if (pImg->pWsp[x].ulBitString == 0L) {
                fRet = WriteFile(
                                hWspFile,                           // Wsp file handle
                                (PVOID)(pImg->pulWsp+(x*ulSnaps)),  // Buffer of data
                                ulSnaps * sizeof(ULONG),            // Bytes to write
                                &dwBytesWritten,                    // Bytes written
                                NULL);                              // Optional
                if (!fRet) {
                    KdPrint (("WST:  WstDumpData() - "
                              "Error writing to WSP file - 0x%lx\n",
                              GetLastError()));
                    return;
                }
            }
        }
    }

    fRet = CloseHandle(hWspFile);
    if (!fRet) {
        KdPrint (("WST:  WstDumpData() - "
                  "Error closing %s - 0x%lx\n", "WSI file",
                  GetLastError()));
        return;
    }

} /* WstDumpData () */





/************************  W s t W r i t e T m i F i l e **********************
 *
 *   Function:  WstWriteTmiFile (pImg)
 *
 *   Purpose:  Write all the symbole info for the current image to its TMI
 *             file.
 *
 *
 *   Parameters: pImg - Current image data structure pointer
 *
 *   Returns:    -none-
 *
 *   History:   8-5-92  Marklea - created
 *
 */

void WstWriteTmiFile (PIMG pImg)
{
    CHAR    szOutFile [256] = WSTROOT;
    CHAR    szBuffer [256];
    CHAR szExt [5] = "TMI";
    HANDLE  hTmiFile;
    INT     x;
    DWORD   dwBytesWritten;
    BOOL    fRet;
    int     iExt = 0;
    PSZ     pszSymbol;
    ULONG    nSymbolLen;


    //
    //  Prepare the filename path
    //
    strcat (szOutFile, pImg->pszName);

    //
    //  Open the file for binary output.
    //
    pImg->fDumpAll = TRUE;
    KdPrint (("WST:  WstWriteTmiFile() - creating TMI for %s\n", szOutFile));
    while (iExt < 256) {
        strcpy ((strchr(szOutFile,'.'))+1, szExt);
        hTmiFile = CreateFile ( szOutFile,      // TMI file handle
                                GENERIC_WRITE |
                                GENERIC_READ, // Desired access
                                0L,             // Read share access
                                NULL,           // No EaBuffer
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                0);             // EaBuffer length
        if (hTmiFile != INVALID_HANDLE_VALUE) {
            IdPrint(("WST:  WstWriteTmiFile() - TMI file name: %s\n",
                     szOutFile));
            if (iExt != 0) {
                pImg->fDumpAll = FALSE;
            }
            break;
        }
        iExt++;
        sprintf (szExt, "T%02x", iExt);
    }
    if (iExt == 256) {
        KdPrint (("WST:  WstWriteTmiFile() - "
                  "Error creating %s - 0x%lx\n", szOutFile,
                  GetLastError()));
        return;
    }

    sprintf(szBuffer, "/* %s for NT */\n"
            "/* Total Symbols= %lu */\n"
            "DO NOT DELETE\n"
            "%d\n"
            "TDFID   = 0\n",
            pImg->pszName,
            pImg->fDumpAll ? pImg->iSymCnt : pImg->ulSetSymbols,
            iTimeInterval);
    //
    //  Write header
    //
    fRet = WriteFile(hTmiFile,                 // Tmi file handle
                     (PVOID)szBuffer,        // Buffer of data
                     (ULONG)strlen(szBuffer), // Bytes to write
                     &dwBytesWritten,        // Bytes written
                     NULL);

    if (!fRet) {
        KdPrint (("WST:  WstWriteTmiFile() - "
                  "Error writing to %s - 0x%lx\n", szOutFile,
                  GetLastError));
        return;
    }

    //
    // Dump all the symbols with set bits.
    //
    IdPrint (("WST:  WstWriteTmiFile() - Dumping set symbols...\n"));
    for (x=0; x<pImg->iSymCnt ; x++) {
        if (pImg->pWsp[x].ulBitString) {
            pszSymbol =
            (pImg->pWsp[x].pszSymbol);
            nSymbolLen = strlen( pszSymbol );   // mdg 98/4

            sprintf(szBuffer, "%ld 0000:%08lx 0x%lx %lu ", // mdg 98/4
                    (LONG)x, pImg->pWsp[x].ulFuncAddr,
                    pImg->pWsp[x].ulCodeLength, nSymbolLen);
            //
            //  Write symbol line
            //
            fRet = WriteFile(hTmiFile,               // Tmi file handle
                             (PVOID)szBuffer,    // Buffer of data
                             (ULONG)strlen(szBuffer), // Bytes to write
                             &dwBytesWritten,  // Bytes written
                             NULL)
                   && WriteFile(hTmiFile,                  // Tmi file handle
                                (PVOID)pszSymbol,   // Buffer of data
                                nSymbolLen,       // Bytes to write
                                &dwBytesWritten,  // Bytes written
                                NULL)
                   && WriteFile(hTmiFile,                  // Tmi file handle
                                (PVOID)"\n",      // Buffer of data
                                1,                // Bytes to write
                                &dwBytesWritten,  // Bytes written
                                NULL);

            if (!fRet) {
                KdPrint (("WST:  WstWriteTmiFile() - "
                          "Error writing to %s - 0x%lx\n", szOutFile,
                          GetLastError));
                return;
            }
        }
    }
    //
    // Now dump all the symbols without any bits set.
    //
    IdPrint (("WST:  WstWriteTmiFile() - Dumping unset symbols...\n"));
    if (pImg->fDumpAll) {
        for (x=0; x<pImg->iSymCnt ; x++ ) {
            if (!pImg->pWsp[x].ulBitString) {
                pszSymbol =
                (pImg->pWsp[x].pszSymbol);
                nSymbolLen = strlen( pszSymbol );   // mdg 98/4
                sprintf(szBuffer, "%ld 0000:%08lx 0x%lx %lu ", // mdg 98/4
                        (LONG)x, pImg->pWsp[x].ulFuncAddr,
                        pImg->pWsp[x].ulCodeLength, nSymbolLen);
                //
                //      Write symbol line
                //
                fRet = WriteFile(hTmiFile,                // Tmi file handle
                                 (PVOID)szBuffer, // Buffer of data
                                 (ULONG)strlen(szBuffer), // Bytes to write
                                 &dwBytesWritten,  // Bytes written
                                 NULL)
                       && WriteFile(hTmiFile,               // Tmi file handle
                                    (PVOID)pszSymbol,    // Buffer of data
                                    nSymbolLen,       // Bytes to write
                                    &dwBytesWritten,  // Bytes written
                                    NULL)
                       && WriteFile(hTmiFile,               // Tmi file handle
                                    (PVOID)"\n",      // Buffer of data
                                    1,                // Bytes to write
                                    &dwBytesWritten,  // Bytes written
                                    NULL);

                if (!fRet) {
                    KdPrint (("WST:  WstWriteTmiFile() - "
                              "Error writing to %s - 0x%lx\n", szOutFile,
                              GetLastError));
                    return;
                }
            }
        }
    }

    fRet = CloseHandle(hTmiFile);
    if (!fRet) {
        KdPrint (("WST:  WstWriteTmiFile() - "
                  "Error closing %s - 0x%lx\n", szOutFile, GetLastError()));
        return;
    }

}  /* WstWriteTmiFile () */





/***********************  W s t R o t a t e W s i M e m ***********************
 *
 *   Function:  WstRotateWsiMem (pImg)
 *
 *   Purpose:
 *
 *
 *   Parameters: pImg - Current image data structure pointer
 *
 *   Returns:    -none-
 *
 *   History:   8-5-92  Marklea - created
 *
 */

void WstRotateWsiMem (PIMG pImg)
{
    ULONG    ulCurSnap;
    ULONG    ulOffset;
    int      x;
    PULONG  pulWsp;


    pulWsp = pImg->pulWsp;
    pImg->ulSetSymbols = 0;

    for (x=0; x<pImg->iSymCnt; x++) {
        ulOffset = 0L;
        ulCurSnap = 0L;
        pImg->pWsp[x].ulBitString = 0L;

        while (ulCurSnap < ulSnaps) {

            ulOffset = (ULONG)x + ((ULONG)pImg->iSymCnt * ulCurSnap);
            *pulWsp = *(pImg->pulWsi + ulOffset);
            pImg->pWsp[x].ulBitString |= (*pulWsp);
            pulWsp++;
            ulCurSnap++;
        }

        if (pImg->pWsp[x].ulBitString) {
            /*
                     SdPrint (("WST:  WstRotateWsiMem() - set:  %s\n",
                        pImg->pWsp[x].pszSymbol));
            */
            (pImg->ulSetSymbols)++;
        }
    }

    IdPrint (("WST:  WstRotateWsiMem() - Number of set symbols = %lu\n",
              pImg->ulSetSymbols));

} /* WstRotateWsiMwm () */





/***********************  W s t G e t S y m b o l s  *************************
 *
 *  WstGetSymbols (pCurWsp, pszImageName, pvImageBase, ulCodeLength, DebugInfo)
 *              This routine stores all the symbols for the current
 *              image into pCurWsp
 *
 *  ENTRY   upCurWsp - Pointer to current WSP structure
 *              pszImageName - Pointer to image name
 *              pvImageBase - Current image base address
 *              ulCodeLength - Current image code length
 *                      DebugInfo - Pointer to the coff debug info structure
 *
 *  EXIT    -none-
 *
 *  RETURN  -none-
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */
#ifndef _WIN64

void WstGetSymbols (PIMG pCurImg,
                    PSZ   pszImageName,
                    PVOID pvImageBase,
                    ULONG ulCodeLength,
                    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo)
{
    IMAGE_SYMBOL             Symbol;
    PIMAGE_SYMBOL            SymbolEntry;
    PUCHAR                   StringTable;
    ULONG                    i;
    char                     achTmp[9];
    PWSP                     pCurWsp;
    PSZ                      ptchSymName;


    pCurWsp = pCurImg->pWsp;
    achTmp[8] = '\0';

    //
    // Crack the COFF symbol table
    //
    SymbolEntry = (PIMAGE_SYMBOL)
                  ((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
    StringTable = (PUCHAR)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol +
                           DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);

    //
    // Loop through all symbols in the symbol table.
    //
    for (i = 0; i < DebugInfo->NumberOfSymbols; i++) {
        //
        // Skip thru aux symbols..
        //
        RtlMoveMemory (&Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL);

        if (Symbol.SectionNumber == 1) {   //code section
            if (ISFCN( Symbol.Type )) {  // mdg 98/3 Also picks up WEAK_EXTERNAL functions
                //
                // This symbol is within the code.
                //
                pCurImg->iSymCnt++;
                pCurWsp->ulBitString = 0L;
                pCurWsp->ulFuncAddr = Symbol.Value + (ULONG)pvImageBase;
                if (Symbol.N.Name.Short) {
                    strncpy (achTmp, (PSZ)&(Symbol.N.Name.Short), 8);
#ifdef i386
                    // only need to strip leading underscore for i386.
                    // mips and alpha are ok.
                    if (achTmp[0] == '_') {
                        pCurWsp->pszSymbol = Wststrdup (&achTmp[1]);
                    } else {
                        pCurWsp->pszSymbol = Wststrdup (achTmp);
                    }
#else
                    pCurWsp->pszSymbol = Wststrdup (achTmp);
#endif
                } else {
                    ptchSymName = (PSZ)&StringTable[Symbol.N.Name.Long];
#ifdef i386
                    // only need to strip leading underscore for i386.
                    // mips and alpha are ok.
                    if (*ptchSymName == '_') {
                        ptchSymName++;
                    }
#endif

                    pCurWsp->pszSymbol = Wststrdup (ptchSymName);
                }

                //            IdPrint(( "WST:  WstGetSymbols() - 0x%lx = %s\n", pCurWsp->ulFuncAddr, pCurWsp->pszSymbol ));

                pCurWsp++;
            }
        }
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL);
    }

} /* WstGetSymbols () */
#endif





/***********************  W s t D l l C l e a n u p s  ***********************
 *
 *  WstDllCleanups () -
 *              Dumps the end data, closes all semaphores and events, and
 *              closes DUMP, CLEAR & PAUSE thread handles.
 *
 *  ENTRY   -none-
 *
 *  EXIT    -none-
 *
 *  RETURN  -none-
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

void WstDllCleanups ()
{
    NTSTATUS  Status;
    int       i;


    if (WstState != NOT_STARTED) {
        WstState = STOPPED;

        IdPrint(("WST:  WstDllCleanups() - Outputting data...\n"));   // mdg 98/3

        if (ulBitCount != 0L) {
            ulSnaps++;
        }

        //
        // Get the GLOBAL semaphore.. (valid accross all process contexts)
        //
        Status = NtWaitForSingleObject (hGlobalSem, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllCleanups() - "
                      "ERROR - Wait for GLOBAL semaphore failed - 0x%lx\n",
                      Status));
        }
        for (i=0; i<iImgCnt; i++) {
            if (aImg[i].iSymCnt > 1) {   // Don't dump modules w/o symbols (the 1 is UNKNOWN) mdg 98/4
                WstClearBitStrings (&aImg[i]);
                WstRotateWsiMem (&aImg[i]);
                WstDumpData (&aImg[i]);
                WstWriteTmiFile (&aImg[i]);
            }
        }
        //
        // Release the GLOBAL semaphore so other processes can dump data
        //
        Status = NtReleaseSemaphore (hGlobalSem, 1, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllCleanups() - "
                      "Error releasing GLOBAL semaphore - 0x%lx\n", Status));
        }

        IdPrint(("WST:  WstDllCleanups() - ...Done.\n"));
    }

    if (fInThread) {
        (*pulShared)--;
        fInThread = FALSE;
        if ( (int)*pulShared <= 0L ) {
            Status = NtSetEvent (hDoneEvent, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDllCleanups() - "
                          "ERROR - Setting DONE event failed - 0x%lx\n", Status));
            }
        }
    }


    // Unmap and close shared block section
    //
    Status = NtUnmapViewOfSection (NtCurrentProcess(), (PVOID)pulShared);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - NtUnmapViewOfSection() - 0x%lx\n", Status));
    }

    Status = NtClose(hSharedSec);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - NtClose() - 0x%lx\n", Status));
    }

    // Unmap and close WSP section
    //
    Status = NtUnmapViewOfSection (NtCurrentProcess(), (PVOID)aImg[0].pWsp);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - NtUnmapViewOfSection() - 0x%lx\n", Status));
    }

    Status = NtClose(hWspSec);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - NtClose() - 0x%lx\n", Status));
    }
    // Free private heap
    //
    if (NULL != hWstHeap) {
        if (!HeapDestroy( hWstHeap )) { // Eliminate private heap & allocations
            KdPrint (("WST:  WstDllCleanups() -"
                      "ERROR - HeapDestroy() - 0x%lx\n", GetLastError()));
        }
    }

    // Close GLOBAL semaphore
    //
    Status = NtClose (hGlobalSem);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - Could not close the GLOBAL semaphore - 0x%lx\n",
                  Status));
    }

    //
    // Close LOCAL semaphore
    //
    Status = NtClose (hLocalSem);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - Could not close the LOCAL semaphore - 0x%lx\n",
                  Status));
    }

    if (fPatchImage) {
        //
        // Close all events
        //
        NtClose (hDoneEvent);
        NtClose (hDumpEvent);
        NtClose (hClearEvent);
        NtClose (hPauseEvent);

        //
        // Close thread handles - threads are terminated during DLL detaching
        // process.
        //
        CloseHandle (hDumpThread);
        CloseHandle (hClearThread);
        CloseHandle (hPauseThread);

    }


} /* WstDllCleanups () */





/*******************  W s t A c c e s s X c p t F i l t e r  ******************
 *
 *  WstAccessXcptFilter (ulXcptNo, pXcptInfoPtr) -
 *              Commits COMMIT_SIZE  more pages of memory if exception is access
 *          violation.
 *
 *  ENTRY   ulXcptNo - exception number
 *              pXcptInfoPtr - exception report record info pointer
 *
 *  EXIT    -none-
 *
 *  RETURN  EXCEPTIONR_CONTINUE_EXECUTION : if access violation exception
 *                      and mem committed successfully
 *              EXCEPTION_CONTINUE_SEARCH : if non-access violation exception
 *                      or cannot commit more memory
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

INT WstAccessXcptFilter (ULONG ulXcptNo, PEXCEPTION_POINTERS pXcptPtr)
{
    NTSTATUS  Status;
    SIZE_T    ulSize = COMMIT_SIZE;
    PVOID     pvMem = (PVOID)pXcptPtr->ExceptionRecord->ExceptionInformation[1];


    if (ulXcptNo != EXCEPTION_ACCESS_VIOLATION) {
        return (EXCEPTION_CONTINUE_SEARCH);
    } else {
        Status = NtAllocateVirtualMemory (NtCurrentProcess(),
                                          &pvMem,
                                          0L,
                                          &ulSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstAccessXcptFilter() - "
                      "Error committing more memory @ 0x%08lx - 0x%08lx "
                      "- TEB=0x%08lx\n", pvMem, Status, NtCurrentTeb()));
            return (EXCEPTION_CONTINUE_SEARCH);
        } else {
            SdPrint (("WST:  WstAccessXcptFilter() - "
                      "Committed %d more pages @ 0x%08lx - TEB=0x%08lx\n",
                      COMMIT_SIZE/PAGE_SIZE, pvMem, NtCurrentTeb()));
        }

        return (EXCEPTION_CONTINUE_EXECUTION);
    }

} /* WstAccessXcptFilter () */





/*****************************************************************************/
/*******  S O R T / S E A R C H   U T I L I T Y   F U N C T I O N S  *********/
/*****************************************************************************/


/*************************  W s t C o m p a r e  *****************************
 *
 *   Function:  WstCompare(PVOID val1,PVOID val2)
 *
 *   Purpose:   Compare values for qsort
 *
 *
 *   Parameters: PVOID
 *
 *   Returns:   -1 if val1 < val2
 *    1 if val1 > val2
 *    0 if val1 == val2
 *
 *   History:   8-3-92  Marklea - created
 *
 */

int WstCompare (PWSP val1, PWSP val2)
{
    return (val1->ulFuncAddr < val2->ulFuncAddr ? -1:
            val1->ulFuncAddr == val2->ulFuncAddr ? 0:
            1);

} /* WstComapre () */





/***********************  W s t B C o m p a r e ********************************
 *
 *   Function:  WstBCompare(PDWORD pdwVal1, PVOID val2)
 *
 *   Purpose:   Compare values for Binary search
 *
 *
 *   Parameters: PVOID
 *
 *   Returns:   -1 if val1 < val2
 *    1 if val1 > val2
 *    0 if val1 == val2
 *
 *   History:   8-3-92  Marklea - created
 *
 */

int WstBCompare (DWORD_PTR *pdwVal1, PWSP val2)
{
#if  defined(_X86_)
    return (*pdwVal1 < val2->ulFuncAddr ? -1:
            *pdwVal1 == val2->ulFuncAddr ? 0:
            1);
#elif defined(ALPHA) || defined(IA64) || defined(_AMD64_)
    int dwCompareCode = 0;

    if (*pdwVal1 < val2->ulFuncAddr) {
        dwCompareCode = -1;
    } else if (*pdwVal1 >= val2->ulFuncAddr + val2->ulCodeLength) {
        dwCompareCode = 1;
    }
    return (dwCompareCode);
#endif

} /* WstBCompare () */




/***********************  W s t S o r t **************************************
 *
 *   Function:  WstSort(WSP wsp[], INT iLeft, INT iRight)
 *
 *   Purpose:   Sort WSP array for binary search
 *
 *
 *   Parameters: wsp[]  Pointer to WSP array
 *   iLeft   Left most index value for array
 *   iRight  Rightmost index value for array
 *
 *   Returns:   NONE
 *
 *   History:   8-4-92  Marklea - created
 *
 */

void WstSort (WSP wsp[], INT iLeft, INT iRight)
{
    INT     i, iLast;


    if (iLeft >= iRight) {
        return;
    }


    WstSwap(wsp, iLeft, (iLeft + iRight)/2);

    iLast = iLeft;

    for (i=iLeft+1; i <= iRight ; i++ ) {
        if (WstCompare(&wsp[i], &wsp[iLeft]) < 0) {
            if (!wsp[i].ulFuncAddr) {
                SdPrint(("WST:  WstSort() - Error in symbol list ulFuncAddr: "
                         "0x%lx [%d]\n", wsp[i].ulFuncAddr, i));
            }
            WstSwap(wsp, ++iLast, i);
        }
    }

    WstSwap(wsp, iLeft, iLast);
    WstSort(wsp, iLeft, iLast-1);
    WstSort(wsp, iLast+1, iRight);

} /* WstSort () */





/***********************  W s t S w a p **************************************
 *
 *   Function:  WstSwap(WSP wsp[], INT i, INT j)
 *
 *   Purpose:   Helper function for WstSort to swap WSP array values
 *
 *
 *   Parameters: wsp[]  Pointer to WSP array
 *   i  index value to swap to
 *   i  index value to swap from
 *
 *   Returns:   NONE
 *
 *   History:   8-4-92  Marklea - created
 *
 */

void WstSwap (WSP wsp[], INT i, INT j)
{
    WSP wspTmp;


    wspTmp = wsp[i];
    wsp[i] = wsp[j];
    wsp[j] = wspTmp;

} /* WstSwap () */





/***********************  W s t B S e a r c h *******************************
 *
 *   Function:  WstBSearch(DWORD dwAddr, WSP wspCur[], INT n)
 *
 *   Purpose:   Binary search function for finding a match in the WSP array
 *
 *
 *   Parameters: dwAddr Address of calling function
 *   wspCur[]Pointer to WSP containg value to match with dwAddr
 *   n  Number of elements in WSP array
 *
 *   Returns:   PWSP    Pointer to matching WSP
 *
 *   History:   8-5-92  Marklea - created
 *
 */

PWSP WstBSearch (DWORD_PTR dwAddr, WSP wspCur[], INT n)
{
    int  i;
    ULONG   ulHigh = n;
    ULONG   ulLow  = 0;
    ULONG   ulMid;

    while (ulLow < ulHigh) {
        ulMid = ulLow + (ulHigh - ulLow) /2;
        if ((i = WstBCompare(&dwAddr, &wspCur[ulMid])) < 0) {
            ulHigh = ulMid;
        } else if (i > 0) {
            ulLow = ulMid + 1;
        } else {
            return (&wspCur[ulMid]);
        }
    }

    return (NULL);

} /* WstBSearch () */




/**************************  W s t D u m p t h r e a d  ***********************
 *
 *              WstDumpThread (pvArg) -
 *              This routine is executed as the DUMP notification thread.
 *              It will wait on an event before calling the dump routine.
 *
 *              ENTRY   pvArg - thread's single argument
 *
 *      EXIT    -none-
 *
 *              RETURN  0
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *                              Leaves profiling turned off.
 *
 */

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)                   // Not all control paths return (due to infinite loop)
#endif

DWORD WstDumpThread (PVOID pvArg)
{
    NTSTATUS  Status;
    int       i;


    pvArg;   // prevent compiler warnings


    SdPrint (("WST:  WstDumpThread() started.. TEB=0x%lx\n", NtCurrentTeb()));

    for (;;) {
        //
        // Wait for the DUMP event..
        //
        Status = NtWaitForSingleObject (hDumpEvent, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDumpThread() - "
                      "ERROR - Wait for DUMP event failed - 0x%lx\n", Status));
        }
        Status = NtResetEvent (hDoneEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDumpThread() - "
                      "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
        }
        fInThread = TRUE;
        (*pulShared)++;
        if (WstState != NOT_STARTED) {

            IdPrint (("WST:  Profiling stopped & DUMPing data... \n"));

            // Stop profiling
            //
            WstState = NOT_STARTED;

            // Dump the data
            //
            if (ulBitCount != 0L) {
                ulSnaps++;
            }

            //
            // Get the GLOBAL semaphore.. (valid accross all process contexts)
            //
            Status = NtWaitForSingleObject (hGlobalSem, FALSE, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDumpThread() - "
                          "ERROR - Wait for GLOBAL semaphore failed - 0x%lx\n",
                          Status));
            }
            for (i=0; i<iImgCnt; i++) {
                if (aImg[i].iSymCnt > 1) {   // Don't dump modules w/o symbols (the 1 is UNKNOWN) mdg 98/4
                    WstClearBitStrings (&aImg[i]);
                    WstRotateWsiMem (&aImg[i]);
                    WstDumpData (&aImg[i]);
                    WstWriteTmiFile (&aImg[i]);
                }
            }
            //
            // Release the GLOBAL semaphore so other processes can dump data
            //
            Status = NtReleaseSemaphore (hGlobalSem, 1, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDumpThread() - "
                          "Error releasing GLOBAL semaphore - 0x%lx\n", Status));
            }

            IdPrint (("WST:  ...data DUMPed & profiling stopped.\n"));
        }

        (*pulShared)--;
        if ( *pulShared == 0L ) {
            Status = NtSetEvent (hDoneEvent, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDumpThread() - "
                          "ERROR - Setting DONE event failed - 0x%lx\n",
                          Status));
            }
        }

        fInThread = FALSE;
    }

    return 0;

} /* WstDumpThread () */



/************************  W s t C l e a r T h r e a d  ***********************
 *
 *              WstClearThread (hNotifyEvent) -
 *              This routine is executed as the CLEAR notification thread.
 *                              It will wait on an event before calling the clear routine
 *                              and restarting profiling.
 *
 *              ENTRY   pvArg - thread's single argument
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

DWORD WstClearThread (PVOID pvArg)
{
    NTSTATUS  Status;
    int       i;


    pvArg;   // prevent compiler warnings


    SdPrint (("WST:  WstClearThread() started.. TEB=0x%lx\n", NtCurrentTeb()));

    for (;;) {
        //
        // Wait for the CLEAR event..
        //
        Status = NtWaitForSingleObject (hClearEvent, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstClearThread() - "
                      "Wait for CLEAR event failed - 0x%lx\n", Status));
        }
        Status = NtResetEvent (hDoneEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstClearThread() - "
                      "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
        }
        fInThread = TRUE;
        (*pulShared)++;

        IdPrint (("WST:  Profiling stopped & CLEARing data...\n"));

        // Stop profiling while clearing data
        //
        WstState = STOPPED;

        // Clear WST info
        //
        ulBitCount = 0L;
        ulSnaps = 0L;

        for (i=0; i<iImgCnt; i++) {
            aImg[i].pulWsiNxt = aImg[i].pulWsi;
            RtlZeroMemory (aImg[i].pulWsi,
                           aImg[i].iSymCnt * ulMaxSnapULONGs * sizeof(ULONG));
            RtlZeroMemory (aImg[i].pulWsp,
                           aImg[i].iSymCnt * ulMaxSnapULONGs * sizeof(ULONG));
        }
        NtQueryPerformanceCounter (&liStart, NULL);

        // Resume profiling
        //
        WstState = STARTED;

        IdPrint (("WST:  ...data is CLEARed & profiling restarted.\n"));
        (*pulShared)--;
        if ( *pulShared == 0L ) {
            Status = NtSetEvent (hDoneEvent, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstClearThread() - "
                          "ERROR - Setting DONE event failed - 0x%lx\n",
                          Status));
            }
        }

        fInThread = FALSE;
    }

    return 0;

} /* WstClearThread () */


/************************  W s t P a u s e T h r e a d  ***********************
 *
 *              WstPauseThread (hNotifyEvent) -
 *                              This routine is executed as the PAUSE notification thread.
 *                              It will wait on an event before pausing the profiling.
 *
 *              ENTRY   pvArg - thread's single argument
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

DWORD WstPauseThread (PVOID pvArg)
{
    NTSTATUS  Status;


    pvArg;   // prevent compiler warnings


    SdPrint (("WST:  WstPauseThread() started.. TEB=0x%lx\n", NtCurrentTeb()));

    for (;;) {
        //
        // Wait for the PASUE event..
        //
        Status = NtWaitForSingleObject (hPauseEvent, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstPauseThread() - "
                      "Wait for PAUSE event failed - 0x%lx\n", Status));
        }
        Status = NtResetEvent (hDoneEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstPauseThread() - "
                      "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
        }
        fInThread = TRUE;
        (*pulShared)++;
        if (WstState == STARTED) {
            //
            // Stop profiling
            //
            WstState = STOPPED;

            IdPrint (("WST:  Profiling stopped.\n"));
        }

        (*pulShared)--;
        if ( *pulShared == 0L ) {
            Status = NtSetEvent (hDoneEvent, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST: WstPauseThread() - "
                          "ERROR - Setting DONE event failed - 0x%lx\n",
                          Status));
            }
        }

        fInThread = FALSE;
    }

    return 0;

} /* WstPauseThread () */


#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


/***********************  W s t D a t a O v e r F l o w  **********************
 *
 *              WstDataOverFlow () -
 *                              This routine is called upon lack of space for storing next
 *              time snap data.  It dumps and then clears the WST data.
 *
 *              ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

void WstDataOverFlow(void)
{
    NTSTATUS   Status;

    //
    // Dump data
    //
    Status = NtResetEvent (hDoneEvent, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - "
                  "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
    }
    Status = NtPulseEvent (hDumpEvent, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - NtPulseEvent() "
                  "failed for DUMP event - %lx\n", Status));
    }
    Status = NtWaitForSingleObject (hDoneEvent, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - NtWaitForSingleObject() "
                  "failed for DONE event - %lx\n", Status));
    }

    //
    // Clear data
    //
    Status = NtResetEvent (hDoneEvent, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - "
                  "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
    }
    Status = NtPulseEvent (hClearEvent, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - NtPulseEvent() "
                  "failed for CLEAR event - %lx\n", Status));
    }
    //
    // Wait for the DONE event..
    //
    Status = NtWaitForSingleObject (hDoneEvent, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - NtWaitForSingleObject() "
                  "failed for DONE event - %lx\n", Status));
    }
} /* WstDataOverFlow() */



#ifdef BATCHING

BOOL WstOpenBatchFile(VOID)
{
    NTSTATUS             Status;
    ANSI_STRING              ObjName;
    UNICODE_STRING           UnicodeName;
    OBJECT_ATTRIBUTES        ObjAttributes;
    IO_STATUS_BLOCK          iostatus;
    RtlInitString(&ObjName, "\\Device\\Harddisk0\\Partition1\\wst\\BATCH.TXT");
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &ObjName, TRUE);

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstOpenBatchFile() - "
                  "RtlAnsiStringToUnicodeString() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    InitializeObjectAttributes (&ObjAttributes,
                                &UnicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                &SecDescriptor);

    Status = NtCreateFile(&hBatchFile,
                          GENERIC_WRITE | SYNCHRONIZE,      // Desired access
                          &ObjAttributes,               // Object attributes
                          &iostatus,                        // Completion status
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_WRITE,
                          FILE_OVERWRITE_IF,
                          FILE_SEQUENTIAL_ONLY |        // Open option
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0L);

    RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstOpenBatchFile() - "
                  "NtCreateFile() failed - 0x%lx\n", Status));
        return (FALSE);
    }
    return(TRUE);

} /* WstOpenBatchFile () */

#endif


/*******************  S e t S y m b o l S e a r c h P a t h  ******************
 *
 *      SetSymbolSearchPath ()
 *              Return complete search path for symbols files (.dbg)
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              "lpSymbolSearchPath" global LPSTR variable will point to the
 *              search path.
 */
#define FilePathLen                256

void SetSymbolSearchPath (void)
{
    CHAR  SymPath[FilePathLen];
    CHAR  AltSymPath[FilePathLen];
    CHAR  SysRootPath[FilePathLen];
    LPSTR lpSymPathEnv=SymPath;
    LPSTR lpAltSymPathEnv=AltSymPath;
    LPSTR lpSystemRootEnv=SysRootPath;
    ULONG cbSymPath;
    DWORD dw;
    HANDLE hMemoryHandle;

    SymPath[0] = AltSymPath[0] = SysRootPath[0] = '\0';

    cbSymPath = 18;
    if (GetEnvironmentVariable("_NT_SYMBOL_PATH", SymPath, sizeof(SymPath))) {
        cbSymPath += strlen(lpSymPathEnv) + 1;
    }

    if (GetEnvironmentVariable("_NT_ALT_SYMBOL_PATH", AltSymPath, sizeof(AltSymPath))) {
        cbSymPath += strlen(lpAltSymPathEnv) + 1;
    }

    if (GetEnvironmentVariable("SystemRoot", SysRootPath, sizeof(SysRootPath))) {
        cbSymPath += strlen(lpSystemRootEnv) + 1;
    }

    hMemoryHandle = GlobalAlloc (GHND, cbSymPath+1);
    if (!hMemoryHandle) {
        return;
    }

    lpSymbolSearchPath = GlobalLock (hMemoryHandle);
    if (!lpSymbolSearchPath) {
        GlobalFree( hMemoryHandle ); // mdg 98/3
        return;
    }


    strcat(lpSymbolSearchPath,".");

    if (*lpAltSymPathEnv) {
        dw = GetFileAttributes(lpAltSymPathEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(lpSymbolSearchPath,";");
            strcat(lpSymbolSearchPath,lpAltSymPathEnv);
        }
    }
    if (*lpSymPathEnv) {
        dw = GetFileAttributes(lpSymPathEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(lpSymbolSearchPath,";");
            strcat(lpSymbolSearchPath,lpSymPathEnv);
        }
    }
    if (*lpSystemRootEnv) {
        dw = GetFileAttributes(lpSystemRootEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(lpSymbolSearchPath,";");
            strcat(lpSymbolSearchPath,lpSystemRootEnv);
        }
    }

} /* SetSymbolSearchPath () */

#ifdef i386

//+-------------------------------------------------------------------------
//
//  Function:    SaveAllRegs
//
//  Synopsis:    Save all regs.
//
//  Arguments:   nothing
//
//  Returns:     none
//
//--------------------------------------------------------------------------

Naked void SaveAllRegs(void)
{
    _asm
    {
        push   ebp
        mov    ebp,esp         ; Remember where we are during this stuff
        ; ebp = Original esp - 4

                push   eax             ; Save all regs that we think we might
        push   ebx             ; destroy
        push   ecx
        push   edx
        push   esi
        push   edi
        pushfd
        push   ds
        push   es
        push   ss
        push   fs
        push   gs

        mov    eax,[ebp+4]     ; Grab Return Address
        push   eax             ; Put Return Address on Stack so we can RET

        mov    ebp,[ebp+0]     ; Restore original ebp

        //
        // This is how the stack looks like before the RET statement
        //
        //        +-----------+
        //        |  Ret Addr |         + 3ch       CurrentEBP + 4
        //        +-----------+
        //        |  Org ebp  |         + 38h       CurrentEBP + 0
        //        +-----------+
        //        |    eax    |         + 34h
        //        +-----------+
        //        |    ebx    |         + 30h
        //        +-----------+
        //        |    ecx    |         + 2ch
        //        +-----------+
        //        |    edx    |         + 24h
        //        +-----------+
        //        |    esi    |         + 20h
        //        +-----------+
        //        |    edi    |         + 1ch
        //        +-----------+
        //        |   eflags  |         + 18h
        //        +-----------+
        //        |     ds    |         + 14h
        //        +-----------+
        //        |     es    |         + 10h
        //        +-----------+
        //        |     ss    |         + ch
        //        +-----------+
        //        |     fs    |         + 8h
        //        +-----------+
        //        |     gs    |         + 4h
        //        +-----------+
        //        |  Ret Addr |     ESP + 0h
        //        +-----------+

        ret
    }
}


//+-------------------------------------------------------------------------
//
//  Function:    RestoreAllRegs
//
//  Synopsis:    restore all regs
//
//  Arguments:   nothing
//
//  Returns:     none
//
//--------------------------------------------------------------------------

Naked void RestoreAllRegs(void)
{
    _asm
    {
        //
        // This is how the stack looks like upon entering this routine
        //
        //        +-----------+
        //        |  Ret Addr |         + 38h [ RetAddr for SaveAllRegs() ]
        //        +-----------+
        //        |  Org ebp  |         + 34h
        //        +-----------+
        //        |    eax    |         + 30h
        //        +-----------+
        //        |    ebx    |         + 2Ch
        //        +-----------+
        //        |    ecx    |         + 28h
        //        +-----------+
        //        |    edx    |         + 24h
        //        +-----------+
        //        |    esi    |         + 20h
        //        +-----------+
        //        |    edi    |         + 1Ch
        //        +-----------+
        //        |   eflags  |         + 18h
        //        +-----------+
        //        |     ds    |         + 14h
        //        +-----------+
        //        |     es    |         + 10h
        //        +-----------+
        //        |     ss    |         + Ch
        //        +-----------+
        //        |     fs    |         + 8h
        //        +-----------+
        //        |     gs    |         + 4h
        //        +-----------+
        //        |  Ret EIP  |     ESP + 0h  [ RetAddr for RestoreAllRegs() ]
        //        +-----------+
        //


        push   ebp             ; Save a temporary copy of original BP
        mov    ebp,esp         ; BP = Original SP + 4

                                      //
                                      // This is how the stack looks like NOW!
                                      //
                                      //        +-----------+
                                      //        |  Ret Addr |         + 3Ch [ RetAddr for SaveAllRegs() ]
                                      //        +-----------+
                                      //        |  Org ebp  |         + 38h [ EBP before SaveAllRegs()  ]
                                      //        +-----------+
                                      //        |    eax    |         + 34h
                                      //        +-----------+
                                      //        |    ebx    |         + 30h
                                      //        +-----------+
                                      //        |    ecx    |         + 2Ch
                                      //        +-----------+
                                      //        |    edx    |         + 28h
                                      //        +-----------+
                                      //        |    esi    |         + 24h
                                      //        +-----------+
                                      //        |    edi    |         + 20h
                                      //        +-----------+
                                      //        |   eflags  |         + 1Ch
                                      //        +-----------+
                                      //        |     ds    |         + 18h
                                      //        +-----------+
                                      //        |     es    |         + 14h
                                      //        +-----------+
                                      //        |     ss    |         + 10h
                                      //        +-----------+
                                      //        |     fs    |         + Ch
                                      //        +-----------+
                                      //        |     gs    |         + 8h
                                      //        +-----------+
                                      //        |  Ret EIP  |     ESP + 4h   [ RetAddr for RestoreAllRegs() ]
                                      //        +-----------+
                                      //        |    EBP    |     ESP + 0h  or EBP + 0h
                                      //        +-----------+
                                      //

                                      pop    eax             ; Get Original EBP
        mov    [ebp+38h],eax   ; Put it in the original EBP place
        ; This EBP is the EBP before calling
        ;  RestoreAllRegs()
        pop    eax             ; Get ret address forRestoreAllRegs ()
            mov    [ebp+3Ch],eax   ; Put Return Address on Stack

        pop    gs              ; Restore all regs
        pop    fs
        pop    ss
        pop    es
        pop    ds
        popfd
        pop    edi
        pop    esi
        pop    edx
        pop    ecx
        pop    ebx
        pop    eax
        pop    ebp

        ret
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstdll\ia64\wstutl.s ===
//    TITLE("Wst Utility")
//++
//    Copyright (c) 1992-1994, Microsoft Corporation.
//
//    Description:
//        SaveAllRegs ()
//              - save all IA64 registers
//
//        RestoreAllRegs ()
//              - restore all IA64 registers
//
//
//--


#include "ksia64.h"

        PublicFunction(c_penter)

//--------------------------------------------------------------------
// Routine:
//
//       VOID
//       SaveAllRegs(
//            IN  OUT PDWORDLONG   pSaveBuffer)
//
// Description:
//
//       This function saves the EM registers into the supplied buffer
//
// Input:
//
//       a0: pSaveBuffer - Pointer CONTEXT buffer where the registers should be
//                         saved.
//
// Output:
//
//       Stores the registers in the supplied buffer.
//
// Return value:
//
//       None
//
//
//
//--------------------------------------------------------------------

        LEAF_ENTRY(SaveAllRegs)


//
// Save all integer registers and flush the RSE
//

        .prologue
        .regstk     1, 10, 0, 0

        rbsp        = loc9
        rpfs        = loc8
        rbrp        = loc7
        rpr         = loc6
        runat       = loc4
        tmpbsp      = t20


        alloc       rpfs = ar.pfs, 1, 10, 0, 0
        add         loc0 = CxIntGp, a0
        add         loc1 = CxIntT8, a0
        ;;

        flushrs
        .save       ar.unat, loc4
        mov         runat = ar.unat
        mov         rpr = pr

        PROLOGUE_END

        .mem.offset 0,0
        st8.spill.nta [loc0] = gp, CxIntT0 - CxIntGp
        .mem.offset 0,8
        st8.spill.nta [loc1] = t8, CxIntT9 - CxIntT8
        add         loc2 = CxIntGp, a0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t0, CxIntT1 - CxIntT0
        .mem.offset 0,8
        st8.spill.nta [loc1] = t9, CxIntT10 - CxIntT9
        shr         loc2 = loc2, 3
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t1, CxIntS0 - CxIntT1
        .mem.offset 0,8
        st8.spill.nta [loc1] = t10, CxIntT11 - CxIntT10
        and         t0 = 0x3f, loc2
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s0, CxIntS1 - CxIntS0
        .mem.offset 0,8
        st8.spill.nta [loc1] = t11, CxIntT12 - CxIntT11
        cmp4.ge     pt1, pt0 = 1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s1, CxIntS2 - CxIntS1
        .mem.offset 0,8
        st8.spill.nta [loc1] = t12, CxIntT13 - CxIntT12
 (pt1)  sub         t1 = 1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s2, CxIntS3 - CxIntS2
        .mem.offset 0,8
        st8.spill.nta [loc1] = t13, CxIntT14 - CxIntT13
 (pt0)  add         t1 = -1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s3, CxIntV0 - CxIntS3
        .mem.offset 0,8
        st8.spill.nta [loc1] = t14, CxIntT15 - CxIntT14
 (pt0)  sub         t8 = 65, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = v0, CxIntTeb - CxIntV0
        .mem.offset 0,8
        st8.spill.nta [loc1] = t15, CxIntT16 - CxIntT15
        nop.i       0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = teb, CxIntT2 - CxIntTeb
        .mem.offset 0,8
        st8.spill.nta [loc1] = t16, CxIntT17 - CxIntT16
        mov         rbrp = brp
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t2, CxIntT3 - CxIntT2
        .mem.offset 0,8
        st8.spill.nta [loc1] = t17, CxIntT18 - CxIntT17
        mov         t11 = bs0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t3, CxIntSp - CxIntT3
        .mem.offset 0,8
        st8.spill.nta [loc1] = t18, CxIntT19 - CxIntT18
        mov         t12 = bs1
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = sp, CxIntT4 - CxIntSp
        .mem.offset 0,8
        st8.spill.nta [loc1] = t19, CxIntT20 - CxIntT19
        mov         t13 = bs2
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t4, CxIntT5 - CxIntT4
        .mem.offset 0,8
        st8.spill.nta [loc1] = t20, CxIntT21 - CxIntT20
        mov         t14 = bs3
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t5, CxIntT6 - CxIntT5
        .mem.offset 0,8
        st8.spill.nta [loc1] = t21, CxIntT22 - CxIntT21
        mov         t15 = bs4
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t6, CxIntT7 - CxIntT6
        .mem.offset 0,8
        st8.spill.nta [loc1] = t22, CxPreds - CxIntT22
        mov         t16 = bt0
        ;;

        st8.spill.nta [loc0] = t7
        st8.nta     [loc1] = rpr, CxIntNats - CxPreds   // save predicates
        mov         t17 = bt1
        ;;

        mov         t9 = ar.unat
        mov         t4 = ar.fpsr
        add         loc2 = CxBrRp, a0
        ;;

        add         loc3 = CxBrS3, a0
  (pt1) shl         t9 = t9, t1
  (pt0) shr.u       t2 = t9, t1
        ;;

//
// Save branch registers.
//

        st8.nta     [loc2] = rbrp, CxBrS0 - CxBrRp  // save brp
        st8.nta     [loc3] = t14, CxBrS4 - CxBrS3   // save bs3
  (pt0) shl         t3 = t9, t8
        ;;

        st8.nta     [loc2] = t11, CxBrS1 - CxBrS0   // save bs0
        st8.nta     [loc3] = t15, CxBrT0 - CxBrS4   // save bs4
  (pt0) or          t9 = t2, t3
        ;;

        st8.nta     [loc2] = t12, CxBrS2 - CxBrS1   // save bs1
        st8.nta     [loc3] = t16, CxBrT1 - CxBrT0   // save bt0
        add         loc0 = CxStFPSR, a0
        ;;

        st8.nta     [loc2] = t13                    // save bs2
        st8.nta     [loc3] = t17                    // save bt1
        add         loc2 = CxStFSR, a0
        ;;

        st8.nta     [loc0] = t4                     // save fpsr
        st8.nta     [loc1] = t9                     // save nat bits
        add         loc1 = CxStFIR, a0
        ;;

        mov         t0 = ar.fsr
        mov         t1 = ar.fir
        mov         t2 = ar.fdr
        ;;

        st8.nta     [loc2] = t0, CxStFDR - CxStFSR
        st8.nta     [loc1] = t1
        ;;

        st8.nta     [loc2] = t2

        mov         rbsp = ar.bsp
        add         loc2 = CxFltS0, a0
        add         loc3 = CxFltS1, a0
        ;;

//
// Save floating status and floating registers f0 - f127.
//

        stf.spill.nta [loc2] = fs0, CxFltS2 - CxFltS0
        stf.spill.nta [loc3] = fs1, CxFltS3 - CxFltS1
        shr         t0 = rpfs, 7
        ;;

        stf.spill.nta [loc2] = fs2, CxFltT0 - CxFltS2
        stf.spill.nta [loc3] = fs3, CxFltT1 - CxFltS3
        and         t0 = 0x7f, t0
        ;;

        stf.spill.nta [loc2] = ft0, CxFltT2 - CxFltT0
        stf.spill.nta [loc3] = ft1, CxFltT3 - CxFltT1
        shr         t1 = rbsp, 3
        ;;

        stf.spill.nta [loc2] = ft2, CxFltT4 - CxFltT2
        stf.spill.nta [loc3] = ft3, CxFltT5 - CxFltT3
        and         t1 = 0x3f, t1
        ;;

        stf.spill.nta [loc2] = ft4, CxFltT6 - CxFltT4
        stf.spill.nta [loc3] = ft5, CxFltT7 - CxFltT5
        sub         t2 = t0, t1
        ;;

        stf.spill.nta [loc2] = ft6, CxFltT8 - CxFltT6
        stf.spill.nta [loc3] = ft7, CxFltT9 - CxFltT7
        cmp4.le     pt1, pt0 = t2, zero
        ;;

        stf.spill.nta [loc2] = ft8, CxFltS4 - CxFltT8
        stf.spill.nta [loc3] = ft9, CxFltS5 - CxFltT9
 (pt0)  add         t2 = -1, t2
        ;;

        stf.spill.nta [loc2] = fs4, CxFltS6 - CxFltS4
        stf.spill.nta [loc3] = fs5, CxFltS7 - CxFltS5
 (pt0)  add         t0 = 1, t0
        ;;

        stf.spill.nta [loc2] = fs6, CxFltS8 - CxFltS6
        stf.spill.nta [loc3] = fs7, CxFltS9 - CxFltS7
 (pt0)  add         t2 = -63, t2
        ;;

        stf.spill.nta [loc2] = fs8, CxFltS10 - CxFltS8
        stf.spill.nta [loc3] = fs9, CxFltS11 - CxFltS9
 (pt0)  cmp4.ge.unc pt2, pt3 = t2, zero
        ;;

        stf.spill.nta [loc2] = fs10, CxFltS12 - CxFltS10
        stf.spill.nta [loc3] = fs11, CxFltS13 - CxFltS11
 (pt1)  br.cond.spnt Rcc20
        ;;

Rcc10:
 (pt2)  add         t0 = 1, t0
 (pt2)  add         t2 = -63, t2
 (pt3)  br.cond.sptk Rcc20
        ;;

        cmp4.ge     pt2, pt3 = t2, zero
        nop.m       0
        br          Rcc10

Rcc20:
        stf.spill.nta [loc2] = fs12, CxFltS14 - CxFltS12
        stf.spill.nta [loc3] = fs13, CxFltS15 - CxFltS13
        add         tmpbsp = -8, rbsp
        ;;

        stf.spill.nta [loc2] = fs14, CxFltS16 - CxFltS14
        stf.spill.nta [loc3] = fs15, CxFltS17 - CxFltS15
        shl         t0 = t0, 3
        ;;

        stf.spill.nta [loc2] = fs16, CxFltS18 - CxFltS16
        stf.spill.nta [loc3] = fs17, CxFltS19 - CxFltS17
        sub         rbsp = rbsp, t0
        ;;

        stf.spill.nta [loc2] = fs18, CxFltF32 - CxFltS18
        stf.spill.nta [loc3] = fs19, CxFltF33 - CxFltS19
        nop.i       0
        ;;

//
// Save application registers, control information and set context flags.
//

        User=pt0
        Krnl=pt1
        rdcr=t1
        mask=t2
        sol=t4
        rpsr=t5
        is=t6
        rccv=t7
        rlc=t8
        rec=t9
        rrsc=t10
        rrnat=t11
        flag=t16
        addr0=t17
        addr1=t18
        tmp=t19

        mov         rrsc = ar.rsc
        tbit.nz     Krnl, User = sp, 62         // bit 62 is 1 when
        mov         rlc = ar.lc
        ;;

        mov         ar.rsc = zero               // put RSE in lazy mode
        mov         rccv = ar.ccv
        mov         rec = ar.ec
        ;;                                      // in kernel

 (Krnl) mov         rpsr = psr
 (User) mov         rpsr = psr.um
        add         addr0 = CxApUNAT, a0

        mov         rrnat = ar.rnat
        add         addr1 = CxApLC, a0

 (Krnl) mov         rdcr = cr.dcr
 (Krnl) movl        tmp = 1 << PSR_BN
        ;;

        st8.nta     [addr0] = runat, CxApEC - CxApUNAT
        st8.nta     [addr1] = rlc, CxApCCV - CxApLC
 (Krnl) or          rpsr = tmp, rpsr
        ;;

        st8.nta     [addr0] = rec, CxApDCR - CxApEC
        st8.nta     [addr1] = rccv, CxRsPFS - CxApCCV
        mov         tmp = 1
        ;;

        st8.nta     [addr0] = rdcr, CxRsBSP - CxApDCR
        st8.nta     [addr1] = rpfs, CxRsBSPSTORE - CxRsPFS
        shl         tmp = tmp, 63
        ;;

        st8.nta     [addr0] = rbsp, CxRsRSC - CxRsBSP
        st8.nta     [addr1] = rbsp, CxRsRNAT - CxRsBSPSTORE
        or          rpfs = rpfs, tmp            // validate IFS
        ;;

        st8.nta     [addr0] = rrsc, CxStIIP - CxRsRSC
        st8.nta     [addr1] = rrnat, CxStIFS - CxRsRNAT
        mov         mask = RNAT_ALIGNMENT
        ;;

        st8.nta     [addr0] = rbrp, CxStIPSR - CxStIIP
        add         tmp = CxContextFlags, a0
        mov         flag = CONTEXT_FULL         // full context saved.
        ;;

        st8.nta     [addr0] = rpsr              // save psr
        st8.nta     [addr1] = rpfs
        or          tmpbsp = tmpbsp, mask
        ;;

        mov         ar.rsc = rrsc               // restore RSC
        st4.nta     [tmp] = flag

        mov         ar.unat = runat             // restore ar.unat
        st8.nta     [tmpbsp] = rrnat
 (p0)   br.ret.sptk brp                         // return to caller.

        LEAF_EXIT(SaveAllRegs)


//++
//
// VOID
// RestoreAllRegs (
//    IN PCONTEXT ContextRecord,
//    )
//
// Routine Description:
//
//    This function restores the registers of the caller from the specified
//    context.
//
//    N.B. The context record is assumed to be 16-byte aligned.
//
// Arguments:
//
//    ContextRecord (a0) - Supplies the address of a context record.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RestoreAllRegs)

        dest1=t8
        dest2=t9
        rlc=t10
        rpreds=t11
        rbrp=t12
        rbsp=t13
        rpfs=t14
        runat=t15
        rpreds=t16
        rsp=t17
        rfpsr=t18
        jb=t19
        tmp=t20
        src1=t21
        src2=t22

        .regstk     2, 9, 2, 0

        alloc       t4 = ar.pfs, 2, 11, 2, 0
        ARGPTR(a0)

        add         src1 = CxIntNats, a0
        add         src2 = CxPreds, a0
        add         tmp = CxIntGp, a0
        ;;

        ld8.nt1     t17 = [src1], CxBrRp - CxIntNats
        ld8.nt1     t16 = [src2], CxBrS0 - CxPreds
        shr         tmp = tmp, 3
        ;;

        ld8.nt1     t0 = [src1], CxBrS1 - CxBrRp
        ld8.nt1     t1 = [src2], CxBrS2 - CxBrS0
        and         tmp = 0x3f, tmp
        ;;

        ld8.nt1     t2 = [src1], CxBrS3 - CxBrS1
        ld8.nt1     t3 = [src2], CxBrS4 - CxBrS2
        cmp4.ge     pt1, pt0 = 1, tmp
        ;;

        ld8.nt1     t4 = [src1], CxBrT0 - CxBrS3
        ld8.nt1     t5 = [src2], CxBrT1 - CxBrS4
 (pt1)  sub         loc5 = 1, tmp
        ;;

        ld8.nt1     t6 = [src1], CxApUNAT - CxBrT0
        ld8.nt1     t7 = [src2], CxApLC - CxBrT1
 (pt0)  add         loc5 = -1, tmp
        ;;

        ld8.nt1     loc0 = [src1], CxApEC - CxApUNAT
        ld8.nt1     t8 = [src2], CxApCCV - CxApLC
 (pt0)  sub         loc6 = 65, tmp
        ;;

        ld8.nt1     t9 = [src1], CxApDCR - CxApEC
        ld8.nt1     t10 = [src2], CxRsPFS - CxApCCV
 (pt1)  shr.u       t17 = t17, loc5
        ;;

        ld8.nt1     loc1 = [src1], CxRsBSP - CxApDCR
        ld8.nt1     t11 = [src2], CxRsRSC - CxRsPFS
 (pt0)  shl         loc7 = t17, loc5
        ;;

        ld8.nt1     loc2 = [src1], CxStIIP - CxRsBSP
        ld8.nt1     loc3 = [src2], CxStIFS - CxRsRSC
 (pt0)  shr.u       loc8 = t17, loc6
        ;;

        ld8.nt1     loc9 = [src1]
        ld8.nt1     loc10 = [src2]
 (pt0)  or          t17 = loc7, loc8
        ;;

        mov         ar.unat = t17
        add         src1 = CxFltS0, a0
        shr         t12 = loc2, 3
        ;;

        add         src2 = CxFltS1, a0
        and         t12 = 0x3f, t12             // current rnat save index
        and         t13 = 0x7f, loc10           // total frame size
        ;;

        mov         ar.ccv = t10
        add         t14 = t13, t12
        mov         ar.pfs = t11
        ;;

Rrc20:
        cmp4.gt     pt1, pt0 = 63, t14
        ;;
 (pt0)  add         t14 = -63, t14
 (pt0)  add         t13 = 1, t13
        ;;

        nop.m       0
 (pt1)  shl         t13 = t13, 3
 (pt0)  br.cond.spnt Rrc20
        ;;

        add         loc2 = loc2, t13
        nop.f       0
        mov         pr = t16, -1

        ldf.fill.nt1  fs0 = [src1], CxFltS2 - CxFltS0
        ldf.fill.nt1  fs1 = [src2], CxFltS3 - CxFltS1
        mov         brp = t0
        ;;

        ldf.fill.nt1  fs2 = [src1], CxFltT0 - CxFltS2
        ldf.fill.nt1  fs3 = [src2], CxFltT1 - CxFltS3
        mov         bs0 = t1
        ;;

        ldf.fill.nt1  ft0 = [src1], CxFltT2 - CxFltT0
        ldf.fill.nt1  ft1 = [src2], CxFltT3 - CxFltT1
        mov         bs1 = t2
        ;;

        ldf.fill.nt1  ft2 = [src1], CxFltT4 - CxFltT2
        ldf.fill.nt1  ft3 = [src2], CxFltT5 - CxFltT3
        mov         bs2 = t3
        ;;

        ldf.fill.nt1  ft4 = [src1], CxFltT6 - CxFltT4
        ldf.fill.nt1  ft5 = [src2], CxFltT7 - CxFltT5
        mov         bs3 = t4
        ;;

        ldf.fill.nt1  ft6 = [src1], CxFltT8 - CxFltT6
        ldf.fill.nt1  ft7 = [src2], CxFltT9 - CxFltT7
        mov         bs4 = t5
        ;;

        ldf.fill.nt1  ft8 = [src1], CxFltS4 - CxFltT8
        ldf.fill.nt1  ft9 = [src2], CxFltS5 - CxFltT9
        mov         bt0 = t6
        ;;

        ldf.fill.nt1  fs4 = [src1], CxFltS6 - CxFltS4
        ldf.fill.nt1  fs5 = [src2], CxFltS7 - CxFltS5
        mov         bt1 = t7
        ;;

        ldf.fill.nt1  fs6 = [src1], CxFltS8 - CxFltS6
        ldf.fill.nt1  fs7 = [src2], CxFltS9 - CxFltS7
        mov         ar.lc = t8
        ;;

        ldf.fill.nt1  fs8 = [src1], CxFltS10 - CxFltS8
        ldf.fill.nt1  fs9 = [src2], CxFltS11 - CxFltS9
        mov         ar.ec = t9
        ;;

        ldf.fill.nt1  fs10 = [src1], CxFltS12 - CxFltS10
        ldf.fill.nt1  fs11 = [src2], CxFltS13 - CxFltS11
        nop.i       0
        ;;

        ldf.fill.nt1  fs12 = [src1], CxFltS14 - CxFltS12
        ldf.fill.nt1  fs13 = [src2], CxFltS15 - CxFltS13
        add         loc6 = CxIntGp, a0
        ;;

        ldf.fill.nt1  fs14 = [src1], CxFltS16 - CxFltS14
        ldf.fill.nt1  fs15 = [src2], CxFltS17 - CxFltS15
        add         loc7 = CxIntT0, a0
        ;;

        ldf.fill.nt1  fs16 = [src1], CxFltS18 - CxFltS16
        ldf.fill.nt1  fs17 = [src2], CxFltS19 - CxFltS17
        add         t19 = CxRsRNAT, a0
        ;;

        ldf.fill.nt1  fs18 = [src1]
        ldf.fill.nt1  fs19 = [src2]
        add         t7 = CxStFPSR, a0
        ;;

        ld8.nt1     loc8 = [t7]                 // load fpsr from context
        ld8.nt1     loc5 = [t19]                // load rnat from context
        nop.i       0

        ld8.fill.nt1 gp = [loc6], CxIntT1 - CxIntGp
        ld8.fill.nt1 t0 = [loc7], CxIntS0 - CxIntT0
        ;;

        ld8.fill.nt1 t1 = [loc6], CxIntS1 - CxIntT1
        ld8.fill.nt1 s0 = [loc7], CxIntS2 - CxIntS0
        ;;

        ld8.fill.nt1 s1 = [loc6], CxIntS3 - CxIntS1
        ld8.fill.nt1 s2 = [loc7], CxIntV0 - CxIntS2
        ;;

        ld8.fill.nt1 s3 = [loc6], CxIntTeb - CxIntS3
        ld8.fill.nt1 v0 = [loc7], CxIntT2 - CxIntV0
        ;;

        ld8.fill.nt1 teb = [loc6], CxIntT3 - CxIntTeb
        ld8.fill.nt1 t2 = [loc7], CxIntSp - CxIntT2
        ;;

        ld8.fill.nt1 t3 = [loc6], CxIntT4 - CxIntT3
        ld8.fill.nt1 loc4 = [loc7], CxIntT5 - CxIntSp
        ;;

        ld8.fill.nt1 t4 = [loc6], CxIntT6 - CxIntT4
        ld8.fill.nt1 t5 = [loc7], CxIntT7 - CxIntT5
        ;;

        ld8.fill.nt1 t6 = [loc6], CxIntT8 - CxIntT6
        ld8.fill.nt1 t7 = [loc7], CxIntT9 - CxIntT7
        ;;

        ld8.fill.nt1 t8 = [loc6], CxIntT10 - CxIntT8
        ld8.fill.nt1 t9 = [loc7], CxIntT11 - CxIntT9
        ;;

        ld8.fill.nt1 t10 = [loc6], CxIntT12 - CxIntT10
        ld8.fill.nt1 t11 = [loc7], CxIntT13 - CxIntT11
        ;;

        ld8.fill.nt1 t12 = [loc6], CxIntT14 - CxIntT12
        ld8.fill.nt1 t13 = [loc7], CxIntT15 - CxIntT13
        ;;

        ld8.fill.nt1 t14 = [loc6], CxIntT16 - CxIntT14
        ld8.fill.nt1 t15 = [loc7], CxIntT17 - CxIntT15
        ;;

        ld8.fill.nt1 t16 = [loc6], CxIntT18 - CxIntT16
        ld8.fill.nt1 t17 = [loc7], CxIntT19 - CxIntT17
        ;;

        ld8.fill.nt1 t18 = [loc6], CxIntT20 - CxIntT18
        ld8.fill.nt1 t19 = [loc7], CxIntT21 - CxIntT19
        ;;

        ld8.fill.nt1 t20 = [loc6], CxIntT22 - CxIntT20
        ld8.fill.nt1 t21 = [loc7]
        ;;

        rsm         1 << PSR_I
        ld8.fill.nt1 t22 = [loc6]
        ;;

        rsm         1 << PSR_IC
        movl        t0 = 1 << IFS_V
        ;;

        mov         ar.fpsr = loc8              // set fpsr
        mov         ar.unat = loc0
        ;;

        srlz.d
        or          loc10 = t0, loc10           // set ifs valid bit
        ;;

        mov         cr.iip = loc9
        mov         cr.ifs = loc10
        bsw.0
        ;;

        mov         cr.dcr = loc1
        mov         r17 = loc2                  // put BSP in a shadow reg
        or          r16 = 0x3, loc3             // put RSE in eager mode

        mov         ar.rsc = r0                 // put RSE in enforced lazy
        nop.m       0
        add         r20 = CxStIPSR, a0
        ;;

        ld8.nt1     r20 = [r20]                 // load IPSR
        mov         r18 = loc4                  // put SP in a shadow reg
        mov         r19 = loc5                  // put RNaTs in a shadow reg
        ;;

        alloc       t0 = 0, 0, 0, 0
        mov         cr.ipsr = r20
        mov         sp = r18
        ;;

        loadrs
        ;;
        mov         ar.bspstore = r17
        nop.i       0
        ;;

        mov         ar.rnat = r19               // set rnat register
        mov         ar.rsc = r16                // restore RSC
        bsw.1
        ;;

        LEAF_EXIT(RestoreAllRegs)



//--------------------------------------------------------------------
// Routine:
//
//       VOID
//       penter(
//            VOID)
//
// Description:
//
//       This function loads the return address and current address in to two
//       parameter registers, then calls the C version (c_penter)
//
// Input:
//
//       None
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
//
//
//--------------------------------------------------------------------

        LEAF_ENTRY(penter)

        .regstk 0, 1, 2, 0

        //
        // This to be filled in when the compiler implements /Gh switch
        //

        br.call.sptk brp = c_penter

        LEAF_EXIT(penter)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstdll\wst.h ===
/*** WST.H - Public defines and structure definitions for WST tool.
 *
 *
 * Title:
 *	Working Set Tuner Data Collection Tool include file used by WST.c
 *
 *	Copyright (c) 1992, Microsoft Corporation.
 *      Reza Baghai.
 *
 *
 * Modification History:
 *	92.07.28  RezaB -- Created
 *
 */



/* * * * * * * *   C o m m o n   M i s c .   D e f i n e s   * * * * * * * */

#define Naked       _declspec (naked)    // For asm functions

#define  MEMSIZE	 		64*1024*1024	// 64 MB virtual memory for data -
											// initially RESERVED - will be
											// COMITTED as needed.
#define  MAX_IMAGES 	    200		 	    // Limit on num of modules in proc
#define  PAGE_SIZE	    	4096	 		// 4K pages
#define  PATCHFILESZ	    PAGE_SIZE	 	// WST.INI file maximum size
#define  COMMIT_SIZE	    96*PAGE_SIZE 	// Mem chunck to be commited
#define  TIMESEG			1000 		    // Default time seg size in milisecs
#define  NUM_ITERATIONS     1000 	 	 	// Number of iterations used to
											// calculate overheads
#define  UNKNOWN_SYM   		"_???"
#define  UNKNOWN_ADDR  		0xffffffff
#define  MAX_SNAPS_DFLT   		3200   // Default # snaps if not specified in WST.INI
#define  MAX_SNAPS_ENTRY   "MAXSNAPS=" // mdg 98/3
#define  FILENAMELENGTH     256
#define  WSTDLL 	    	"WST.DLL"
#define  CRTDLL 	    	"CRTDLL.DLL"
#define  KERNEL32 	    	"KERNEL32.DLL"
#define  PATCHEXELIST	    "[EXES]"
#define  PATCHIMPORTLIST    "[PATCH IMPORTS]"
#define  TIMEINTERVALIST    "[TIME INTERVAL]"
#define  GLOBALSEMNAME	    "\\BaseNamedObjects\\WSTGlobalSem"
#define  PATCHSECNAME	    "\\BaseNamedObjects\\WSTPatch"
#define  PROFOBJSNAME	    "\\BaseNamedObjects\\WSTObjs"
#define  WSTINIFILE	    	 "c:\\wst\\wst.ini"
#define  WSTROOT	    	    "c:\\wst\\"
#define  DONEEVENTNAME	    "\\BaseNamedObjects\\WSTDoneEvent"
#define  DUMPEVENTNAME	    "\\BaseNamedObjects\\WSTDumpEvent"
#define  CLEAREVENTNAME     "\\BaseNamedObjects\\WSTClearEvent"
#define  PAUSEEVENTNAME	    "\\BaseNamedObjects\\WSTPauseEvent"
#define  SHAREDNAME		    "\\BaseNamedObjects\\WSTSHARED"
#define  WSTUSAGE(x)		((ULONG_PTR)(x->Instrumentation[3]))



/* * * * * * * * * *  G l o b a l   D e c l a r a t i o n s  * * * * * * * * */

typedef enum {
    NOT_STARTED,
    STARTED,
	STOPPED,
} WSTSTATE;

typedef struct _wsp {
	PSTR	pszSymbol;				// Pointer to Symbol name
	ULONG_PTR	ulFuncAddr;				// Function address of symbol
	ULONG	ulCodeLength;			// Length of this symbols code
	ULONG	ulBitString;			// Bitstring for tuning.
} WSP;
typedef WSP * PWSP;

typedef struct _img {
	PSTR	pszName;			
	ULONG_PTR   ulCodeStart;
	ULONG_PTR   ulCodeEnd;
	PWSP    pWsp;
	int     iSymCnt;
	PULONG  pulWsi;
	PULONG  pulWsp;
	PULONG  pulWsiNxt;
	ULONG   ulSetSymbols;
	BOOL    fDumpAll;
} IMG;
typedef IMG * PIMG;


typedef struct tagWSPhdr{
    char    chFileSignature[4];
    ULONG   ulTimeStamp;
    ULONG   ulApiCount;
    USHORT  usId;
    ULONG   ulSetSymbols;
    ULONG   ulModNameLen;
    ULONG   ulSegSize;
    ULONG   ulOffset;
    ULONG   ulSnaps;
}WSPHDR;


/* * * *  E x t e r n a l   F u n c t i o n   D e c l a r a t i o n s  * * * */

extern void GdiGetCsInfo (PDWORD, PDWORD, PDWORD);
extern void GdiResetCsInfo (void);

#ifdef i386
extern void SaveAllRegs (void);
extern void RestoreAllRegs (void);
#endif

#define STUB_SIGNATURE     0xfefe55aa   // Mips Patch Stub signature
#define  CAIROCRT           "CAIROCRT.DLL"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstdump\wstdump.c ===
/*++

   wstdump.c
	   Dump routines for WST

   History:
       10-26-92  RezaB - created.

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

#include <wst.h>

#include "wstdump.h"


//
// dump clear switches and defaults
//
WORD fDump = FALSE;
WORD fClear = FALSE;
WORD fPause = TRUE;


HANDLE  hDoneEvent;
HANDLE  hDumpEvent;
HANDLE  hClearEvent;
HANDLE	hPauseEvent;
HANDLE	hdll;

SECURITY_DESCRIPTOR  SecDescriptor;


//
// error handling
//
#define LOG_FILE "wstdump.log"
FILE *pfLog;


void    	  ClearDumpInfo  (void);
INT_PTR APIENTRY DialogProc(HWND, UINT, WPARAM, LPARAM);


/*++

  Main Routine

--*/

int WinMain(HINSTANCE hInstance,HINSTANCE hPrevInst,LPSTR lpCmdLine,int nCmdShow)
{
    NTSTATUS           Status;
    STRING	       	   EventName;
    UNICODE_STRING     EventUnicodeName;
    OBJECT_ATTRIBUTES  EventAttributes;


    // Prevent compiler from complaining..
    //
    hPrevInst;
    lpCmdLine;
    nCmdShow;


    // Open the log file for logging possible errors
    //
    pfLog = fopen (LOG_FILE, "w");
    if (!pfLog) {
        exit (1);
    }


    // Create public share security descriptor for all the named objects
    //

    Status = RtlCreateSecurityDescriptor (
		&SecDescriptor,
		SECURITY_DESCRIPTOR_REVISION1
		);
    if (!NT_SUCCESS(Status)) {
	fprintf (pfLog, "WSTDUMP: main () - RtlCreateSecurityDescriptor() "
		       "failed - %lx\n", Status);
	exit (1);
    }

    Status = RtlSetDaclSecurityDescriptor (
		&SecDescriptor,	   	// SecurityDescriptor
		TRUE,		   		// DaclPresent
		NULL,		   		// Dacl
		FALSE		   		// DaclDefaulted
		);
    if (!NT_SUCCESS(Status)) {
	fprintf (pfLog, "WSTDUMP: main () - RtlSetDaclSecurityDescriptor() "
		       "failed - %lx\n", Status);
	exit (1);
    }


    // Initialization for DONE event creation
    //
    RtlInitString (&EventName, DONEEVENTNAME);

    Status = RtlAnsiStringToUnicodeString (&EventUnicodeName,
					   &EventName,
                                           TRUE);
    if (NT_SUCCESS(Status)) {
	InitializeObjectAttributes (&EventAttributes,
				    &EventUnicodeName,
				    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
				    NULL,
				    &SecDescriptor);
    }
    else {
       fprintf (pfLog, "WSTDUMP: main () - RtlAnsiStringToUnicodeString() "
                       "failed for DUMP event name - %lx\n", Status);
	   exit (1);
    }
    //
    // Create DONE event
    //
    Status = NtCreateEvent (&hDoneEvent,
                            EVENT_QUERY_STATE    |
                              EVENT_MODIFY_STATE |
                              SYNCHRONIZE,
							&EventAttributes,
                            NotificationEvent,
                            TRUE);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: main () - NtCreateEvent() "
                        "failed to create DUMP event - %lx\n", Status);
        exit (1);
    }


    // Initialization for DUMP event creation
    //
    RtlInitString (&EventName, DUMPEVENTNAME);

    Status = RtlAnsiStringToUnicodeString (&EventUnicodeName,
					   &EventName,
                                           TRUE);
    if (NT_SUCCESS(Status)) {
	InitializeObjectAttributes (&EventAttributes,
				    &EventUnicodeName,
				    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
				    NULL,
				    &SecDescriptor);
    }
    else {
        fprintf (pfLog, "WSTDUMP: main () - RtlAnsiStringToUnicodeString() "
                       "failed for DUMP event name - %lx\n", Status);
        exit (1);
    }
    //
    // Create DUMP event
    //
    Status = NtCreateEvent (&hDumpEvent,
                            EVENT_QUERY_STATE    |
                              EVENT_MODIFY_STATE |
                              SYNCHRONIZE,
							&EventAttributes,
                            NotificationEvent,
                            FALSE);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: main () - NtCreateEvent() "
                        "failed to create DUMP event - %lx\n", Status);
        exit (1);
    }


    // Initialization for CLEAR event creation
    //
    RtlInitString (&EventName, CLEAREVENTNAME);

    Status = RtlAnsiStringToUnicodeString (&EventUnicodeName,
					   &EventName,
                                           TRUE);
    if (NT_SUCCESS(Status)) {
	InitializeObjectAttributes (&EventAttributes,
				    &EventUnicodeName,
				    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
				    NULL,
				    &SecDescriptor);
    }
    else {
        fprintf (pfLog, "WSTDUMP: main () - RtlAnsiStringToUnicodeString() "
                        "failed for CLEAR event name - %lx\n", Status);
        exit (1);
    }
    //
    // Create CLEAR event
    //
    Status = NtCreateEvent (&hClearEvent,
                            EVENT_QUERY_STATE    |
                              EVENT_MODIFY_STATE |
                              SYNCHRONIZE,
							&EventAttributes,
                            NotificationEvent,
                            FALSE);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: main () - NtCreateEvent() "
                        "failed to create CLEAR event - %lx\n", Status);
        exit (1);
    }


    // Initialization for PAUSE event creation
    //
    RtlInitString (&EventName, PAUSEEVENTNAME);

    Status = RtlAnsiStringToUnicodeString (&EventUnicodeName,
					   &EventName,
                                           TRUE);
    if (NT_SUCCESS(Status)) {
	InitializeObjectAttributes (&EventAttributes,
				    &EventUnicodeName,
				    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
				    NULL,
				    &SecDescriptor);
    }
    else {
        fprintf (pfLog, "WSTDUMP: main () - RtlAnsiStringToUnicodeString() "
			"failed for PAUSE event name - %lx\n", Status);
        exit (1);
    }
    //
    // Create PAUSE event
    //
    Status = NtCreateEvent (&hPauseEvent,
                            EVENT_QUERY_STATE    |
                              EVENT_MODIFY_STATE |
                              SYNCHRONIZE,
							&EventAttributes,
                            NotificationEvent,
                            FALSE);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: main () - NtCreateEvent() "
			"failed to create PAUSE event - %lx\n", Status);
        exit (1);
    }


    //
    // show dialog box
    //
    DialogBox(hInstance, "DumpDialog", NULL, DialogProc);

    return (0);

} /* main */


/*++

   Clears and/or dump profiling info to the dump file.

   Input:
       -none-

   Output:
       -none-
--*/

void ClearDumpInfo (void)
{
    NTSTATUS   Status;


    //
    // Pause profiling?
    //
    if (fPause) {
	Status = NtPulseEvent (hPauseEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            fprintf (pfLog, "WSTDUMP: ClearDumpInfo () - NtPulseEvent() "
			    "failed for PAUSE event - %lx\n", Status);
            exit (1);
        }
    }
    //
    // Dump data?
    //
    else if (fDump) {
        Status = NtPulseEvent (hDumpEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            fprintf (pfLog, "WSTDUMP: ClearDumpInfo () - NtPulseEvent() "
                            "failed for DUMP event - %lx\n", Status);
            exit (1);
        }
    }
    //
    // Clear data?
    //
    else if (fClear) {
        Status = NtPulseEvent (hClearEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            fprintf (pfLog, "WSTDUMP: ClearDumpInfo () - NtPulseEvent() "
                            "failed for CLEAR event - %lx\n", Status);
            exit (1);
        }
    }
    //
	// Wait for the DONE event..
    //
	Sleep (500);
	Status = NtWaitForSingleObject (hDoneEvent, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: ClearDumpInfo () - NtWaitForSingleObject() "
                        "failed for DONE event - %lx\n", Status);
        exit (1);
    }

} /* ClearDumpInfo() */



/*++

   Dump dialog procedure -- exported to windows.
   Allows user to change defaults:  dump, clear, and ".dmp" as dump
   file extension.

   Input:
       Messages from windows:
           - WM_INITDIALOG - initialize dialog box
           - WM_COMMAND    - user input received

   Output:
       returns TRUE if message processed, false otherwise

   SideEffects:
       global flags fDump and fClear may be altered

--*/

INT_PTR APIENTRY DialogProc(HWND hDlg, UINT wMesg, WPARAM wParam, LPARAM lParam)
{
    HICON hIcon;


    lParam;   //Avoid Compiler warnings

    switch (wMesg) {

        case WM_CREATE:

            hIcon = LoadIcon ((HINSTANCE)hDlg, "WSTDUMP.ICO");
            SetClassLongPtr (hDlg, GCLP_HICON, (LONG_PTR)hIcon);
            return TRUE;


        case WM_INITDIALOG:

			CheckDlgButton(hDlg, ID_DUMP, fDump);
            CheckDlgButton(hDlg, ID_CLEAR, fClear);
			CheckDlgButton(hDlg, ID_PAUSE, fPause);
            return TRUE;


        case WM_COMMAND:

            switch (wParam) {

                case IDOK:
					if (fDump) {
                        SetWindowText(hDlg, "Dumping Data..");
                    }
                    else if (fClear) {
                        SetWindowText(hDlg, "Clearing Data..");
                    }
					else if (fPause) {
						SetWindowText(hDlg, "Stopping WST..");
                    }

                    ClearDumpInfo();
					SetWindowText(hDlg, "WST Dump Utility");
                    return (TRUE);

                case IDEXIT:
                    EndDialog(hDlg, IDEXIT);
                    return (TRUE);

                case ID_DUMP:
					fDump = TRUE;
					fPause = FALSE;
					fClear = FALSE;
                    CheckDlgButton(hDlg, ID_DUMP, fDump);
					CheckDlgButton(hDlg, ID_PAUSE, fPause);
					CheckDlgButton(hDlg, ID_CLEAR, fClear);
                    return (TRUE);

                case ID_CLEAR:
					fClear = TRUE;
					fPause = FALSE;
					fDump = FALSE;
                    CheckDlgButton(hDlg, ID_CLEAR, fClear);
					CheckDlgButton(hDlg, ID_PAUSE, fPause);
					CheckDlgButton(hDlg, ID_DUMP, fDump);
                    return (TRUE);

				case ID_PAUSE:
					fPause = TRUE;
					fClear = FALSE;
					fDump = FALSE;
					CheckDlgButton(hDlg, ID_PAUSE, fPause);
					CheckDlgButton(hDlg, ID_CLEAR, fClear);
					CheckDlgButton(hDlg, ID_DUMP, fDump);
					return (TRUE);

            }

    }

    return (FALSE);     /* did not process a message */

} /* DialogProc() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstdump\wstdump.h ===
/*++
 wstdump.h

  Definitions for dialog box controls in WST dump routine.

  rezab 10-26-92

--*/


#define IDOK          1
#define IDEXIT        2

#define ID_STARTVAL   100
#define ID_PAUSE      100
#define ID_CLEAR      101
#define ID_DUMP       102

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstune\wsdata.h ===
/*
 * Module Name:  WSDATA.H
 *
 * Description:
 *
 * Working set tuner include file.  Contains common structure
 * declarations and constant definitions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 *						
 */

/*
 *	Constant definitions.
 */

#define NUM_VAR_BITS	(sizeof(ULONG) << 3)

#ifdef TMIFILEHACK
#define	MAXLINE	80
#endif /* TMIFILEHACK */

/*
 *	    Type definitions and structure declarations.
 */

typedef ULONG	fxnbits_t;

struct	dtqo_s	{
	unsigned long	dtqo_hMTE;	 /* MTE handle			*/
	unsigned short	dtqo_usID;	 /* Identifier			*/
//	unsigned short	dtqo_SymCnt;	 /* Reserved			*/
	unsigned long	dtqo_SymCnt;	 /* Reserved			*/ // mdg 4/98
	unsigned long	dtqo_cbPathname; /* Module pathname length	*/
	unsigned long	dtqo_clSegSize;	 /* Number of dyntrc variables	*/
};

typedef struct	dtqo_s	dtqo_t;


/*
 * WSI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      sentinel 0 (dtgp_s)              | <----------
 *	|=======================================|           |
 *	|      snapshot 0 (dtgp_s) for module X |           | S
 *	|---------------------------------------|           | n
 *	|      dynamic trace variables for X    |           | a
 *	|---------------------------------------|           | p
 *	|      snapshot 0 (dtgp_s) for module Y |           | s
 *	|---------------------------------------|           | h
 *	|      dynamic trace variables for Y    |           | o
 *	|---------------------------------------|           | t
 *	|               etc.                    |           |
 *	|=======================================|           | D
 *	|      sentinel 1 (dtgp_s)              |           | a
 *	|=======================================|           | t
 *	|      snapshot 1 (dtgp_s) for module X |           | a
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for X    |           |
 *	|---------------------------------------|           |
 *	|      snapshot 1 (dtgp_s) for module Y |           |
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for Y    |           |
 *	|---------------------------------------|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      sentinel 2 (dtgp_s)              |           |
 *	|=======================================|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      end sentinel (dtgp_s)            |           |
 *	|_______________________________________| <----------
 *	|_______________________________________|
 *	|                                       | <---------- Q
 *	|      dtqo_s for module X              |           | u
 *	|---------------------------------------|           | e
 *	|      module X pathname string         |           | r
 *	|=======================================|           | y
 *	|      dtqo_s for module Y              |           |
 *	|---------------------------------------|           | I
 *	|      module Y pathname string         |           | n
 *	|=======================================|           | f
 *	|               etc.                    | <---------- o
 *	|=======================================|
 *	|_______________________________________|
 *	
 */


				/* WSI file header format */
struct wsihdr_s {
	CHAR	wsihdr_chSignature[4];	// file signature
	ULONG	wsihdr_ulLevel;		// format level
	ULONG	wsihdr_ulTimeStamp;	// time stamp
	ULONG	wsihdr_ulOffGetvar;	// offset to DT_GETVAR data
	ULONG	wsihdr_ulOffQuery;	// offset to DT_QUERY data
	ULONG	wsihdr_cbFile;		// size of file (in bytes)
	ULONG	wsihdr_ulSnaps;		// number of snapshots
};

typedef struct wsihdr_s wsihdr_t;

/*
 * WSP file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsphdr_s                 |
 *	|---------------------------------------|
 *	|         module pathname array         |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 bitstring            |
 *      |      (rounded to DWORD boundary)      |
 *	|=======================================|
 *	|      function #1 bitstring            |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* WSP file header format */
struct wsphdr_s {
	CHAR	wsphdr_chSignature[4];	// file signature
	ULONG	wsphdr_ulTimeStamp;	// time stamp
	dtqo_t	wsphdr_dtqo;		// query info
	ULONG	wsphdr_ulOffBits;	// offset to first bitstring
	ULONG	wsphdr_ulSnaps;		// number of snapshots
	/* followed by module pathname char array, length specified in dtqo */
};

typedef struct wsphdr_s wsphdr_t;


/*
 * TMI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              tmihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 tmirec_s             |
 *	|---------------------------------------|
 *	|      function #0 name array           |
 *	|=======================================|
 *	|      function #1 tmirec_s             |
 *	|---------------------------------------|
 *	|      function #1 name array           |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* TMI file header. */
typedef struct  tmihdr_s {
            CHAR    tmihdr_chSignature[4]; // "TMI\0"
            USHORT  tmihdr_usMajor;        // Range 0x0001 to 0x00FF
            USHORT  tmihdr_cTmiRec;        // Number of tmirec in file
            CHAR    tmihdr_chModName[256]; // Name of traced module
            USHORT  tmihdr_usID;           // Module identifier
            CHAR    tmihdr_resv[30];       // Reserved
};

typedef struct tmihdr_s tmihdr_t;

				/* Per-function information from TMI file */
struct tmirec_s {
	ULONG	tmirec_ulFxnIndex;	// function's bit reference position
	ULONG	tmirec_usFxnAddrObj;	// object portion of function address
	ULONG	tmirec_ulFxnAddrOff;	// offset portion of function address
	ULONG	tmirec_cbFxn;		// size of function (in bytes)
	USHORT	tmirec_cbFxnName;	// size in bytes of function name
	CHAR	tmirec_FxnName[1];	// bytes of function name start here
};

typedef struct tmirec_s tmirec_t;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstune\wspdump.c ===
/*
 * Module Name:  WSPDUMP.C
 *								
 * Program:	 WSPDUMP
 *								
 *								
 * Description:							
 *
 * Dumps the contents of a WSP file.
 *
 * Contitional compilation notes:
 *
 * Modification History:
 *
 *	6-12-92:    Adapted OS/2 version of wspdump for NT	    		marklea
 *	6-17-92:    Modified wspDumpBits to dump in correct order   	marklea
 *	6-18-92:    Added page useage information		    			marklea
 *	8-31-92:	Made single exe from wspdump, wsreduce and wstune	marklea
 * 4-13-98: QFE                                                DerrickG (mdg):
 *          - new WSP file format for large symbol counts (ULONG vs. USHORT)
 *          - support for long file names (LFN) of input/output files
 *          - removed buggy reference to WSDIR env. variable
 *          - based .TMI file name exclusively on .WSP name for consistency
 *          - removed limit on symbol name lengths - return allocated name from WsTMIReadRec()
 *          - removed unused static declarations
 *								
 */

#include "wstune.h"

/*
 *	Global variable declaration and initialization.
 */

typedef struct fxn_t{
    CHAR   	*pszFxnName;
    ULONG   cbFxn;
	ULONG	ulTmiIndex;
	ULONG	ulOrigIndex;
}FXN;
typedef FXN *PFXN;

/*
 *	    Function prototypes.
 */

static VOID wspDumpSetup( VOID );
static VOID wspDumpRandom( VOID );
static UINT wspDumpBits( VOID );
static VOID wspDumpExit( UINT, USHORT, UINT, ULONG, PSZ );
static void wspDumpCleanup( void );
static VOID wspDumpSeq(VOID);
static int  __cdecl wspCompare(const void *fxn1, const void *fxn2);



static CHAR *szFileWSP = NULL;	// WSP file name
static CHAR *szFileTMI = NULL;	// TMI file name
static CHAR *szFileWSR = NULL;	// WSR file name
static CHAR *szDatFile = NULL;	// DAT file name


static ULONG	rc = NO_ERROR;	// Return code
static ULONG	ulTmp;			// Temp variable for Dos API returns
static ULONG	ulFxnIndex;		// Original index in symbol table
static FILE		*hFileWSP;		// Input WSP file handle
static FILE		*hFileTMI;		// Input TMI file handle
static FILE    *hFileDAT;      // Data file for dump
static wsphdr_t WspHdr;			// Input WSP file header
static BOOL 	fRandom = FALSE;	// Flag for random mode
static BOOL 	fVerbose = FALSE;	// Flag for verbose mode
static ULONG	ulFxnTot = 0;		// Total number of functions
static ULONG	clVarTot = 0;		// Total number of dwords in bitstr
static ULONG	*pulFxnBitstring;	// Function bitstring
static ULONG	ulSetSym = 0;		// Number of symbols set   // mdg 4/98
static BOOL	fDatFile = FALSE;

/*
 * Procedure wspDumpMain		
 *					
 *						
 ***
 * Effects:						
 *	
 * Constructs .WSP and .TMI input names from input basefile name. If szDatExt is
 * not NULL, appends it to szBaseFile to create output data file name. If fRandom,
 * constructs a .WSR output file. If fVerbose, adds extra output to data file.
 *
 * Processes the input files and displays the function reference data
 * for each function in the specified module WSP file.
 *
 */
BOOL wspDumpMain( CHAR *szBaseFile, CHAR *szDatExt, BOOL fRndm, BOOL fVbose )
{
	size_t	c;
    char *   pSlash;

    fRandom = fRndm;
    fVerbose = fVbose;
    // mdg 98/4 Allocate space for filenames - don't use static buffers
    c = 5 + strlen( szBaseFile ); // Length to allocate for filenames
    szFileWSP = malloc( c );
    if (szFileWSP) {
         strcat( strcpy( szFileWSP, szBaseFile ), ".WSP" );
    } else {
         return (1);
    }
    szFileTMI = malloc( c );
    if (szFileTMI) {
         strcat( strcpy( szFileTMI, szBaseFile ), ".TMI" );
    } else {
         free(szFileWSP);
        return (1);
    }

    // Create output file in current directory
    if (NULL != (pSlash = strrchr( szBaseFile, '\\' ))
        || NULL != (pSlash = strrchr( szBaseFile, '/' ))
        || NULL != (pSlash = strrchr( szBaseFile, ':' )))
    {
        c = strlen( ++pSlash ) + 5;
    } else
        pSlash = szBaseFile;

    if (fRandom) {
        szFileWSR = malloc( c );
        if (szFileWSR) {
            strcat( strcpy( szFileWSR, pSlash ), ".WSR" );
        } else {
            free(szFileTMI);
            free(szFileWSP);
            return (1);
        }
    }
    if (szDatExt != NULL) {
        fDatFile = TRUE;
        szDatFile = malloc( c - 4 + strlen( szDatExt ) );
        if (szDatFile) {
            strcat( strcpy( szDatFile, pSlash ), szDatExt );
        } else {
            free(szFileWSR);
            free(szFileTMI);
            free(szFileWSP);
            return (1);
        }
    } else {
       fDatFile = FALSE;
       szDatFile = "";
    }

	// Setup input files for dump processing.
	wspDumpSetup();		

	/* Print the WSP file info, either randomly (based on WSR file
	 * input) or sequentially (the default).
	 */
	if (fRandom == TRUE)
		wspDumpRandom();
	else
		wspDumpSeq();
		
   wspDumpCleanup();

   return(NO_ERROR);
}

/*
 *			
 ***LP wspDumpSetup
 *					
 *							
 * Effects:							
 *								
 * Opens the module's WSP and TMI input files, seeks to the start of the
 * first function's bitstring data in the WSP file, and allocates memory
 * to hold one function's bitstring.
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspDumpExit()
 *	with ERROR.
 *	
 */

VOID
wspDumpSetup()
{
	CHAR	szLineTMI[MAXLINE];	// Line from TMI file

	if(fDatFile){
		hFileDAT = fopen (szDatFile, "wt");
		if (hFileDAT == NULL) {
			printf("Error creating file %s, will send output to stdout.\n",
				   szDatFile);
			hFileDAT = stdout;
		}
	}
   else hFileDAT = stdout;

	/* Open input WSP file.  Read and validate WSP file header.*/

	rc = WsWSPOpen(szFileWSP, &hFileWSP,(PFN)wspDumpExit,&WspHdr,ERROR,PRINT_MSG);
	ulSetSym = WspHdr.wsphdr_dtqo.dtqo_SymCnt;
	clVarTot = WspHdr.wsphdr_ulSnaps;
	fprintf(stdout, "\n%s:  Set symbol count=%lu - Segment size=%ld\n",   // mdg 4/98
	   szDatFile, WspHdr.wsphdr_dtqo.dtqo_SymCnt,
	   WspHdr.wsphdr_dtqo.dtqo_clSegSize);


	/* Open TMI file (contains function names, obj:offset, size, etc.).
	 * Verify that the TMI file identifier matches the module
	 * identifier from the WSP file.
	 */
	ulFxnTot = WsTMIOpen(szFileTMI, &hFileTMI, (PFN) wspDumpExit,
				0, (PCHAR)0);


	if (!fseek(hFileTMI, 0L, SEEK_SET)) {
        return;
    }
	fgets(szLineTMI, MAXLINE, hFileTMI);

	/* Print module header information for output file */
	szLineTMI[strlen(szLineTMI)-1] = '\0';

	fprintf(hFileDAT,"\nDUMP OF FUNCTION REFERENCES FOR '%s':\n\n",szLineTMI);

   fclose (hFileTMI);
	ulFxnTot = WsTMIOpen(szFileTMI, &hFileTMI, (PFN) wspDumpExit,
				0, (PCHAR)0);

	/* Allocate memory to hold one function's entire bitstring. */

	pulFxnBitstring = (ULONG *) malloc(clVarTot * sizeof(ULONG));
	if (pulFxnBitstring == NULL)
		wspDumpExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				clVarTot * sizeof(ULONG), "pulFxnBitstring[]");
}

/*
 *			
 ***LP wspDumpSeq
 *					
 *							
 * Effects:							
 *								
 * For each function, prints the bitstring in ASCII form.
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspDumpExit()
 *	with ERROR.
 *	
 */

VOID wspDumpSeq(VOID)
{
	UINT	uiFxn = 0;			// Function number
	UINT	cTouched=0;			// Count of touched pages
	BOOL	fTouched=0;			// Flag to indicate page is touched.   // mdg 4/98
	UINT	i=0;				// Generic counter
	ULONG	cbFxnCum =0;		// Cumulative function sizes
	PFXN	Fxn;				// pointer to array of fxn name ptrs
	FILE 	*fpFileWSR = NULL;	// WSR file pointer
	ULONG	cbFBits = 0;		// Count of bytes in bitstring
	UINT	uiPageCount=0;		// Pages touched.
	ULONG	ulMaxBytes=0;		// Bytes of touched pages.


	/* Allocate memory for function names. */
	Fxn = (PFXN) malloc(ulFxnTot * sizeof(FXN));
	if (Fxn == NULL)
		wspDumpExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				ulFxnTot * sizeof(FXN), "Fxn[]");

   WsIndicator( WSINDF_NEW, "Load Functions", ulFxnTot );
	/* Read function names from TMI file. */
	for (uiFxn = 0; uiFxn < ulFxnTot; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		Fxn[uiFxn].cbFxn = WsTMIReadRec(&Fxn[uiFxn].pszFxnName, &ulFxnIndex, &ulTmp, hFileTMI,
					(PFN) wspDumpExit, (PCHAR)0);
		Fxn[uiFxn].ulOrigIndex = ulFxnIndex;
		Fxn[uiFxn].ulTmiIndex = (ULONG)uiFxn;

	}

	qsort(Fxn, ulFxnTot, sizeof(FXN), wspCompare);
   WsIndicator( WSINDF_FINISH, NULL, 0 );

	cbFBits = clVarTot * sizeof(ULONG);

   WsIndicator( WSINDF_NEW, "Write Data Out", ulFxnTot );
	for (uiFxn = 0; uiFxn < ulFxnTot; uiFxn++)
	{

      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		/* Seek to function's bitstring in WSP file. */
		if ((rc = fseek(hFileWSP,(WspHdr.wsphdr_ulOffBits+(Fxn[uiFxn].ulTmiIndex*cbFBits)),SEEK_SET))!=NO_ERROR)
			wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET,
					rc, szFileWSP);

		fprintf(hFileDAT,"Fxn '%s' (#%d):\n\t", Fxn[uiFxn].pszFxnName, Fxn[uiFxn].ulOrigIndex);
      free(Fxn[uiFxn].pszFxnName);  // mdg 98/4: Free allocated name string
      Fxn[uiFxn].pszFxnName = NULL;
		// Print this function's reference bitstring.
		// and if it has had a bit set, set touched flag to true

		if(wspDumpBits()){
			fTouched |=1;
			ulMaxBytes += Fxn[uiFxn].cbFxn;
		}
			

		fprintf(hFileDAT,"%-28s %10ld bytes.\n","Function size:", Fxn[uiFxn].cbFxn);
		cbFxnCum += Fxn[uiFxn].cbFxn;
		fprintf(hFileDAT,"%-28s %10ld bytes.\n\n","Cumulative function sizes:",
			cbFxnCum);

		//Checck to see if a 4k page boundry has been reached

		if(cbFxnCum >= (4096+(4096 * uiPageCount))){
		    for(i=0; i < 60; i++){
				fprintf(hFileDAT, "*");
		    }

		    fprintf(hFileDAT,"\n\nTotal function sizes has reached or exceeds %d bytes.\n\n",
			    (4096+(4096*uiPageCount)));
		    ++uiPageCount;

		    //Check to see of the page has been touched.

		    if(fTouched){
				fprintf(hFileDAT,"This page has been touched.\n");
				++cTouched;
		    }
		    else{
				fprintf(hFileDAT,"This page has not been touched.\n");
		    }
		    fTouched = 0;


		    for(i=0; i < 60; i++){
				fprintf(hFileDAT, "*");
		    }
		    fprintf(hFileDAT, "\n\n");
		}

	}
    ++uiPageCount;
    if(fTouched){
		fprintf(hFileDAT,"\n\n");
		for(i=0; i < 70; i++){
			fprintf(hFileDAT, "=");
		}
	    ++cTouched;
	    fprintf(hFileDAT,"\n\nThis page has been touched.");
    }
    fprintf(hFileDAT,"\n\n");
    for(i=0; i < 70; i++){
		fprintf(hFileDAT, "=");
    }

    fprintf(hFileDAT,"\n\n%-28s %10ld bytes\n\n","Cumulative function size:", cbFxnCum);
	 fprintf(hFileDAT,"%-28s %10d bytes\n\n", "Size of functions touched:", ulMaxBytes);
    fprintf(hFileDAT,"%-28s %10d\n\n", "Total page count:", uiPageCount);
    fprintf(hFileDAT,"%-28s %10d\n\n", "Total pages touched:", cTouched);

   WsIndicator( WSINDF_FINISH, NULL, 0 );
}

/*
 *			
 ***LP wspDumpBits
 *					
 *							
 * Effects:							
 *								
 * Prints a function's reference bitstring (verbose mode only), followed
 * by the sum of the "on" bits.
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspDumpExit()
 *	with ERROR.
 *	
 */

UINT
wspDumpBits()
{
	ULONG	clVar = 0;		// Current dword of bitstring
	UINT	uiBit = 0;		// Result of bit test (1 or 0)
	UINT	cBitsOn;		// Count of "on" bits
	ULONG	*pulBits;		// Pointer to ULONG packets of bits
	CHAR	szTmp[33];
	CHAR	szBits[33];

	cBitsOn = 0;
	pulBits = pulFxnBitstring;

			    /* Read next dword of function's bitstring. */

	szBits[0] = '\0';
	szTmp[0] = '\0';
	for (clVar = 0; clVar < clVarTot; clVar++, pulBits++)
	{
	    rc = fread((PVOID)pulBits,
		(ULONG) sizeof(ULONG),1, hFileWSP);
	    if(rc == 1)
		rc = NO_ERROR;
	    else
		rc = 2;


	    if (rc != NO_ERROR)
		    wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_READ,
				rc, szFileWSP);

		if (*pulBits == 0)
		{
			if (fVerbose == TRUE)
				fprintf(hFileDAT,"00000000000000000000000000000000");
		}
		else
		for (uiBit = 0; uiBit < NUM_VAR_BITS; uiBit++)
		{
		
			if (*pulBits & 1)
			{
				cBitsOn++;
				if (fVerbose == TRUE){
					strcpy(szTmp,szBits);
					strcpy(szBits,"1");
					strcat(szBits,szTmp);
				}
			}
			else
			{
				if (fVerbose == TRUE){
					strcpy(szTmp,szBits);
					strcpy(szBits,"0");
					strcat(szBits,szTmp);
				}
			}
			
			*pulBits = *pulBits >> 1;
		}
		if (fVerbose == TRUE)
		{
			if ((clVar % 2) != 0){
				fprintf(hFileDAT,"%s",szBits);
				szBits[0]='\0';
				fprintf(hFileDAT,"\n\t");
			}
			else{
				fprintf(hFileDAT,"%s",szBits);
				szBits[0]='\0';
				fprintf(hFileDAT," ");
			}
		}
	}
	fprintf(hFileDAT,"\n\t*** Sum of '1' bits = %ld\n\n", cBitsOn);

	return(cBitsOn);
}

/*
 *			
 ***LP wspDumpRandom
 *					
 *							
 * Effects:							
 *								
 * For each function ordinal specified in the WSR file, prints the
 * corresponding function's reference bitstring in ASCII form (verbose
 * mode only), followed by a sum of the "on" bits..
 *								
 * Returns:							
 *	
 *	Void.  If an error is encountered, exits through wspDumpExit()
 *	with ERROR.
 */

VOID
wspDumpRandom()
{
	UINT	uiFxn = 0;			// Function number
	UINT	cTouched=0;			// Count of touched pages
	BOOL	fTouched=0;			// Flag to indicate page is touched.   // mdg 4/98
	UINT	i=0;				// Generic counter
	ULONG	cbFxnCum =0;		// Cumulative function sizes
	PFXN	Fxn;				// pointer to array of fxn name ptrs
	ULONG	ulFxnOrd;			// function number within module
	FILE 	*fpFileWSR = NULL;	// WSR file pointer
	ULONG	cbFBits = 0;		// Count of bytes in bitstring
	UINT	uiPageCount=0;		// Pages touched.
	ULONG	ulMaxBytes=0;		// Bytes of touched pages.

	/* Open WSR file (contains function ordinal numbers in ASCII). */

	if ((fpFileWSR = fopen(szFileWSR, "r")) == NULL)
	{
		wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_OPEN, rc, szFileWSR);
	}

	/* Allocate memory for function names. */
	Fxn = (PFXN) malloc(ulFxnTot * sizeof(FXN));
	if (Fxn == NULL)
		wspDumpExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				ulFxnTot * sizeof(FXN), "Fxn[]");

   WsIndicator( WSINDF_NEW, "Load Functions", ulFxnTot );
	/* Read function names from TMI file. */
	for (uiFxn = 0; uiFxn < ulFxnTot; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		Fxn[uiFxn].cbFxn = WsTMIReadRec(&Fxn[uiFxn].pszFxnName, &ulFxnIndex, &ulTmp, hFileTMI,
					(PFN) wspDumpExit, (PCHAR)0);

	}
   WsIndicator( WSINDF_FINISH, NULL, 0 );

	cbFBits = clVarTot * sizeof(ULONG);

   WsIndicator( WSINDF_NEW, "Write Data Out", ulFxnTot );
	for (uiFxn = 0; uiFxn < ulFxnTot; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		/* Read function number from WSR file. */
		rc = fscanf(fpFileWSR, "%ld\n", &ulFxnOrd);
		if (rc != 1)
			wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_READ,
						rc, szFileWSR);

		/* Seek to function's bitstring in WSP file. */
		if ((rc = fseek(hFileWSP,(WspHdr.wsphdr_ulOffBits+(ulFxnOrd*cbFBits)),SEEK_SET))!=NO_ERROR)
			wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET,
					rc, szFileWSP);

		fprintf(hFileDAT,"Fxn '%s' (#%d):\n\t", Fxn[ulFxnOrd].pszFxnName, ulFxnOrd);
      free(Fxn[ulFxnOrd].pszFxnName);  // mdg 98/4: Free allocated name string
      Fxn[ulFxnOrd].pszFxnName = NULL;

		// Print this function's reference bitstring.
		// and if it has had a bit set, set touched flag to true

		if(uiFxn < ulSetSym){   // mdg 4/98
			if(wspDumpBits()){
				fTouched |= 1;
				ulMaxBytes += Fxn[ulFxnOrd].cbFxn;
			}
		}
		else{
			fprintf(hFileDAT,"\n\t*** Sum of '1' bits = %ld\n\n", 0L);
		}


			

		fprintf(hFileDAT,"%-28s %10ld bytes.\n","Function size:", Fxn[ulFxnOrd].cbFxn);
		cbFxnCum += Fxn[ulFxnOrd].cbFxn;
		fprintf(hFileDAT,"%-28s %10ld bytes.\n\n","Cumulative function sizes:",
			cbFxnCum);

		//Check to see if a 4k page boundry has been reached

		if(cbFxnCum >= (4096+(4096 * uiPageCount))){
		    for(i=0; i < 60; i++){
			fprintf(hFileDAT, "*");
		    }

		    fprintf(hFileDAT,"\n\nTotal function sizes has reached or exceeds %d bytes.\n\n",
			    (4096+(4096*uiPageCount)));
		    ++uiPageCount;

		    //Check to see of the page has been touched.

		    if(fTouched){
			fprintf(hFileDAT,"This page has been touched.\n");
			++cTouched;
		    }
		    else{
			fprintf(hFileDAT,"This page has not been touched.\n");
		    }
		    fTouched = 0;


		    for(i=0; i < 60; i++){
			fprintf(hFileDAT, "*");
		    }
		    fprintf(hFileDAT, "\n\n");
		}

	}
    ++uiPageCount;
    if(fTouched){
	fprintf(hFileDAT,"\n\n");
	for(i=0; i < 70; i++){
	    fprintf(hFileDAT, "=");
	}
	    ++cTouched;
	    fprintf(hFileDAT,"\n\nThis page has been touched.");
    }
    fprintf(hFileDAT,"\n\n");
    for(i=0; i < 70; i++){
	fprintf(hFileDAT, "=");
    }

    fprintf(hFileDAT,"\n\n%-28s %10ld bytes\n\n","Cumulative function size:", cbFxnCum);
	fprintf(hFileDAT,"%-28s %10d bytes\n\n", "Size of functions touched:", ulMaxBytes);
    fprintf(hFileDAT,"%-28s %10d\n\n", "Total page count:", uiPageCount);
    fprintf(hFileDAT,"%-28s %10d\n\n", "Total pages touched:", cTouched);
   WsIndicator( WSINDF_FINISH, NULL, 0 );

}


/*
 *			
 ***LP wspDumpExit
 *					
 *							
 ***							
 *							
 * Effects:							
 *								
 *	Frees up resources (as necessary).  Exits with the specified
 *	exit code, or returns void if exit code is NOEXIT.			
 *								
 ***								
 * Returns:							
 *	
 *	Void, else exits.
 */

VOID
wspDumpExit(uiExitCode, fPrintMsg, uiMsgCode, ulParam1, pszParam2)
UINT	uiExitCode;
USHORT	fPrintMsg;
UINT	uiMsgCode;
ULONG	ulParam1;
PSZ	pszParam2;
{


   /* Print message, if necessary. */
   if (fPrintMsg == TRUE)
   {
      printf(pchMsg[uiMsgCode], szProgName, pszVersion, ulParam1, pszParam2);
   }

   // Special case:  do NOT exit if called with NOEXIT.
   if (uiExitCode == NOEXIT)
      return;

   wspDumpCleanup();
   exit(uiExitCode);
}


/*
 *			
 ***LP wspDumpCleanup
 *					
 *							
 ***							
 *							
 * Effects:							
 *								
 *	Frees up resources (as necessary).		
 *								
 ***								
 * Returns:							
 *	
 *	Void.
 */
void
wspDumpCleanup( void )
{
	_fcloseall();

   free( szFileWSP );
   free( szFileTMI );
   if (fRandom)
      free( szFileWSR );
   if (fDatFile)
      free( szDatFile );
}



int __cdecl wspCompare(const void *fxn1, const void *fxn2)
{
    return (((PFXN)fxn1)->ulOrigIndex < ((PFXN)fxn2)->ulOrigIndex ? -1:
			((PFXN)fxn1)->ulOrigIndex == ((PFXN)fxn2)->ulOrigIndex ? 0:
			1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstune\wstune.h ===
#define	INCL_DOS
#define	INCL_DOSERRORS
#define CCHMAXPATHCOMP	256
#define MAXLINE    300  // mdg 98/4

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wsdata.h>
#include <..\wsfslib\wserror.h>
#include <limits.h>
#include <..\wsfslib\wsfslib.h>

#define SdPrint(_x_)	DbgPrint _x_


extern CHAR *szProgName; /* so all parts of the program will know the name */
extern CHAR *pszVersion;	// Current program version number
#ifdef DEBUG
extern BOOL fDbgVerbose;
#endif   // DEBUG

BOOL wspDumpMain( CHAR *szBaseFile, CHAR *szDatExt, BOOL fRandom, BOOL fVerbose );
BOOL wsReduceMain( CHAR *szFileWSP );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstune\wstune.c ===
/*
 * Module Name:	 WSTUNE.C
 *
 * Program:	 WSTUNE
 *
 *
 * Description:
 *
 * Shell to call former programs WSDUMP and WSREDUCE
 *
 *
 *	Microsoft Confidential
 *
 *	Copyright (c) Microsoft Corporation 1992-1998
 *
 *	All Rights Reserved
 *
 * Modification History:
 *
 *	8-31-92:	Made single exe from wspdump, wsreduce and wstune	marklea
 * 4-13-98: QFE                                                DerrickG (mdg):
 *          - support for long file names (LFN) of input/output files
 *          - based .TMI file name exclusively on .WSP name for consistency
 *          - removed limit on symbol name lengths
 *          - removed -F & -V flags for non-debug; made verbose global for WsRed...()
 *          - made program name & version global; read version from ntverp.h
 *         
 *
 */
#include "wstune.h"

#include <ntverp.h>



#define COMMAND_LINE_LEN 128
#define FILE_NAME_LEN 40

#define FAKE_IT 1

#define ERR fprintf(stderr

VOID wsTuneUsage(VOID);


CHAR *szProgName = "WSTUNE";
CHAR *pszVersion = VER_PRODUCTVERSION_STR;   // Current product version number
INT nMode;
#ifdef DEBUG
BOOL fDbgVerbose = FALSE;
#endif   // DEBUG

/* main()
 *
 * parses command line args
 */
INT __cdecl main(INT argc,CHAR **argv)
{
   CHAR 	*szBaseName = NULL;
	CHAR 	*szNull;
	BOOL 	fOutPut = FALSE;
	BOOL	fNoReduce = FALSE;
	BOOL	fNoDump = FALSE;
	INT		cArgCnt = 0;

   ConvertAppToOem( argc, argv );
   nMode = 0; // default flags set

    while (--argc && (**(++argv) == '-' || **argv=='/'))
    {
        while(*(++(*argv))) switch (**argv)
        {
			case '?':
				wsTuneUsage();
				break;

#ifdef DEBUG
         case 'f':
			case 'F':
				nMode |= FAKE_IT;
				break;
#endif   // DEBUG
			case 'O':
			case 'o':
				fOutPut = TRUE;
				break;
			case 'N':
			case 'n':
				fNoDump = TRUE;
				break;
			case 'D':
			case 'd':
				fNoReduce = TRUE;
				break;
#ifdef DEBUG
         case 'V':
         case 'v':
            fDbgVerbose = TRUE;
            break;
#endif   // DEBUG
         case 'P':
         case 'p':
            fWsIndicator = TRUE;
            break;


         default: ERR,"%s: Unrecognized switch: %c\n",
                    szProgName,**argv);
                    return(-1);
        }
    }

    /* any files? */
    if (argc <1)
    {
	   wsTuneUsage();
	   return(-1);
    }

    /* now we go to work -- walk through the file names on the command line */
    while (argc--)
    {
      szBaseName = *(argv++);

      printf("%s: using \042%s\042\n",szProgName,szBaseName);

		if (szNull = strchr(szBaseName, '.'), szNull) {
			*szNull = '\0';
		}

      /* WSREDUCE file.WSP */
      if (!(nMode & FAKE_IT)){
		   if (!fNoReduce){
				wsReduceMain( szBaseName );
			}
		}

		if (!fNoDump){
			
			/* WSPDUMP /V /Ffile.WSP /Tfile.TMI /Rfile.WSR > file.DT */

			if(!(nMode & FAKE_IT)){
            wspDumpMain( szBaseName, (fOutPut ? ".DT" : NULL), TRUE, TRUE );
			}

			/* wspdump /Ffile.wsp /Tfile.tmi > file.DN */

			if (!(nMode & FAKE_IT) && fOutPut){
            wspDumpMain( szBaseName, ".DN", FALSE, FALSE );
			}
		}
    }
   return 0;   // mdg 98/4
}


/*
 *			
 * VOID wsTuneUsage	(VOID)
 *					
 *							
 * Effects:							
 *								
 *	Prints out usage message, and exits with an error.			
 *								
 * Returns:							
 *	
 *	Exits with ERROR.	
 */

VOID wsTuneUsage(VOID)
{
   printf("\nUsage: %s [/O] [/D] [/N] [?] moduleName1[.WSP] [...]\n\n", szProgName);
   printf(
      "  /O   Dump analysis data to file (*.DT tuned, *.DN not tuned)\n"
      "  /N   Analyze bitstring data only, create .WSR and .PRF files (turns off /O)\n"
      "  /D   Dump analysis data only; use existing .WSR file (turns off /N)\n"
#ifdef DEBUG
      "  /F   Fake run for command-line parser debugging\n"
      "  /V   Verbose mode for debugging\n"
#endif   // DEBUG
      "  /P   Display a progress indicator\n"
      "  /?   Display this usage message\n\n"
      "       \"moduleNameX\" is the name(s) of the module file(s) to tune.\n\n"
      );
	printf("%s %s\n", szProgName, pszVersion);

   exit(ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\dlg.h ===
#define IDD_MAIN                    100
#define IDS_USERID                  102
#define IDS_LOGONSESSION            104
#define IDC_DEFAULTOWNER            106
#define IDL_DISABLEDGROUPS          111
#define IDB_DISABLEPRIVILEGE        112
#define IDB_ENABLEPRIVILEGE         113
#define IDL_ENABLEDPRIVILEGES       117
#define IDL_DISABLEDPRIVILEGES      118
#define IDL_ENABLEDGROUPS           123
#define IDB_DISABLEGROUP            124
#define IDB_ENABLEGROUP             125
#define IDC_PRIMARYGROUP            126
#define IDB_MORE                    110
#define IDS_TOKENID                 208
#define IDS_EXPIRATIONTIME          209
#define IDS_TOKENTYPE               210
#define IDS_IMPERSONATION           211
#define IDS_DYNAMICCHARGED          212
#define IDS_DYNAMICAVAILABLE        213
#define IDS_MODIFIEDID              214
#define IDD_MORE                    101
#define IDD_WINDOWLIST              220
#define IDD_WINDOWLISTDELETE        221
#define IDLB_WINDOWLIST             222
#define IDD_ABOUT                   4000
#define IDD_ACTIVEWINDOW            4500
#define IDD_                        200
#define IDEF_GROUPNAME              202
#define IDD_GROUPADD                300
#define IDD_GROUPDELETE             400
#define IDCB_GROUPLIST              401
#define IDD_GROUPSELECT             600
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\pos.c ===
#include "xerox.h"
#include "pos.h"

BOOL GetLastPosition(
RECT *prc)
{
    HKEY hKey;
    DWORD dwType = 0;
    DWORD cb;

    if (ERROR_SUCCESS !=
            RegOpenKey(HKEY_CURRENT_USER, "Software\\Microsoft\\Xerox", &hKey)) {
        return(FALSE);
    }
    RegQueryValueEx(hKey, "Position", 0, &dwType, (LPSTR)prc, &cb);
    if (dwType != REG_BINARY || cb != sizeof(RECT)) {
        RegCloseKey(hKey);
        return(FALSE);
    }
    RegCloseKey(hKey);
    return(TRUE);
}



BOOL SetLastPosition(
RECT *prc)
{
    HKEY hKey;

    if (ERROR_SUCCESS !=
            RegCreateKey(HKEY_CURRENT_USER,
                    "Software\\Microsoft\\Xerox", &hKey)) {
        return(FALSE);
    }
    RegSetValueEx(hKey, "Position", 0, REG_BINARY, (LPSTR)prc, sizeof(RECT));
    RegCloseKey(hKey);
    return(TRUE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\group.h ===
typedef struct tagTITLELIST {
    struct tagTITLELIST *next;
    LPSTR pszTitle;
    LPSTR pszClass;
} TITLELIST, *PTITLELIST;

typedef struct tagGROUP {
    struct tagGROUP *next;
    LPSTR pszName;
    PTITLELIST ptl;
} GROUP, *PGROUP;


BOOL GroupListInit(HWND hwnd, BOOL fIsCB);
BOOL DeleteGroupDefinition(LPSTR szName);
BOOL AddGroupDefinition(LPSTR szName, HWND hwndList);
BOOL SelectGroupDefinition(LPSTR szName, HWND hwndList, BOOL DisplayMissingWin);
LPSTR GetCurrentGroup(VOID);
VOID SetNoCurrentGroup(HWND, LPSTR);
PGROUP FindGroup(LPSTR szName);
int CountGroups(VOID);
VOID SaveGroups(VOID);
VOID FreeGroups(VOID);
VOID LoadGroups(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wst\wstune\wsreduce.c ===
/*
 * Module Name:	 WSREDUCE.C
 *
 * Program:	 WSREDUCE
 *
 *
 * Description:
 *
 * Performs data reduction on the function reference data collected
 * by WST.DLL.  Analyzes the WSP file information, and produces
 * a suggested list for the ordering of functions within the tuned
 * modules.  An ASCII version of the reordered function list is written
 * to stdout.  In addition, a WSR file for each reduced module is
 * produced for subsequent use by WSPDUMP /R.
 *
 * The reduction algorithm employed by WSREDUCE is described in detail
 * in WSINSTR.DOC.  Briefly, each function monitored by the working set tuner
 * is considered to be a vertex in a graph.  There is an edge from vertex
 * "A" to vertex "B" if the function reference strings for "A" and "B"
 * have any overlapping 1 bits.  Likewise, there is an edge from vertex "B"
 * to vertex "A".  The edges between vertices are weighted depending on
 * the relative importance of the ending vertex, and the number of
 * overlapping bits between the start and end vertices.  The relative
 * importance of the end vertices, and the weighted edges between
 * vertices, is stored in a decision matrix.  A greedy algorithm is run on
 * the decision matrix to determine a better ordering for the measured
 * functions.
 *
 *
 *	Microsoft Confidential
 *
 *	Copyright (c) Microsoft Corporation 1992
 *
 *	All Rights Reserved
 *
 * Modification History:
 *
 *	Modified for NT June 13, 1992	MarkLea.
 * 4-23-98: QFE - Performance unacceptable on high function counts      DerrickG (mdg):
 *          - new WSP file format for large symbol counts (ULONG vs. USHORT)
 *          - support for long file names (LFN) of input/output files
 *          - removed buggy reference to WSDIR env. variable
 *          - removed command-line parsing from wsReduceMain()
 *          - based .TMI & .WSR file names exclusively on .WSP name for consistency
 *          - removed limit on symbol name lengths - return allocated name from WsTMIReadRec()
 *          - removed unused code and symbols
 *          - Analyzed the code blocked off by OPTIMIZE - it doesn't produce the same
 *            output as non-OPTIMIZEd code, and is buggy (won't build as is) - removed.
 *          - Removed multiple module capabilities from code (shell sends one at a time)
 *          - I addressed memory and performance issues by using a smaller allocation
 *            for WsDecision (USHORT vs. long), using one value to mark a taken vertex
 *            (as opposed to half the value space by using -1), and an optional
 *            progress indicator to reassure users. Modified wsRedScaleWsDecision()
 *            to maximize the scaled values (using some more float math).
 *          - Added "pnEdges" and "nEdgeCount" to function structure. If the number
 *            of set functions is < USHRT_MAX (very likely, even for very large
 *            projects), allocate as needed a sorted index for WsRedReorder(). This
 *            cuts dramatically the number of passes through the matrix searching for
 *            the next edge to consider, and permits some other optimizations. The
 *            optimized algorithm produces identical results for the important high
 *            usage high overlap functions, but could diverge in the results for low
 *            usage (2 or 1 hits) low overlap functions. Differences are not
 *            significant from a results performance perspective - a better algorithm
 *            would give marginally better results. The original algorithm is in place
 *            bracketed with "#ifdef SLOWMO".
 *         
 *
 */

#include "wstune.h"
/*
 *	    Function prototypes.
 */

VOID wsRedInitialization( VOID );
VOID wsRedInitModules( VOID );
VOID wsRedInitFunctions( VOID );
VOID wsRedSetup( VOID );
VOID wsRedSetWsDecision( VOID );
VOID wsRedScaleWsDecision( VOID );
VOID wsRedWeightWsDecision( VOID );
#ifdef   SLOWMO
UINT wsRedChooseEdge( UINT );
#else    // SLOWMO
UINT wsRedChooseEdgeOpt( UINT ); // mdg 98/4 Alternate optimized edge chooser
INT  __cdecl wsRedChooseEdgeOptCmp ( const UINT *, const UINT * );
BOOL wsRedChooseEdgeOptAlloc( UINT uiIndex );
UINT wsRedChooseEdgeOptNextEdge( UINT uiIndex, BOOL bNoSelectOpt );
#endif   // SLOWMO
VOID wsRedReorder( VOID );
VOID wsRedOutput( VOID );
VOID wsRedOpenWSR( FILE **);
VOID wsRedExit( UINT, USHORT, UINT, ULONG, PSZ );
VOID wsRedCleanup(VOID);

/*
 *	    Type definitions and structure declarations.
 */

				/* Data reduction per module information */
struct wsrmod_s {
	FILE	 *wsrmod_hFileWSR;	// module's WSR file pointer
	FILE	 *wsrmod_hFileTMI;		// module's TMI file pointer
	FILE	 *wsrmod_hFileWSP;		// module's WSP file handle
	union {
		PCHAR	wsrmod_pchModName;// pointer to module base name
		PCHAR	wsrmod_pchModFile;// pointer to WSP file name
	} wsrmod_un;
	ULONG	wsrmod_ulOffWSP;	// offset of first function bitstring
};

typedef struct wsrmod_s wsrmod_t;

				/* Data reduction per function information */
struct wsrfxn_s {
	PCHAR	wsrfxn_pchFxnName;	// pointer to function name
	ULONG	wsrfxn_cbFxn;		// Size of function in bytes
	BOOL	wsrfxn_fCandidate;	// Candidate flag
#ifndef  SLOWMO
   UINT     nEdgesLeft;    // Count of sorted edges left to consider in WsDecision for this function
   UINT     nEdgesAlloc;   // Number of items allocated in pnEdges
   UINT *   pnEdges;       // Allocated array of sorted edges for this function
#endif   // SLOWMO
};

typedef struct wsrfxn_s wsrfxn_t;



/*
 *	Global variable declaration and initialization.
 */

static char *szFileWSP = NULL;   // WSP file name
static char	*szFileTMI = NULL;   // TMI file name
static char *szFileWSR = NULL;   // WSR file name

static ULONG	rc = NO_ERROR;	// Return code
static ULONG	ulTmp;			// Temp variable for Dos API returns
static UINT	    cTmiFxns = 0;	// Number of functions in tmi file
static UINT		cFxnsTot = 0;	// Total number of functions
static UINT		cSnapsTot = 0;	// Total number of snapshots
static UINT		cbBitStr = 0;	// Number of bytes per fxn bitstring
#ifdef DEBUG
static BOOL		fVerbose = FALSE;	// Flag for verbose mode
#endif /* DEBUG */
#ifndef TMIFILEHACK
static BOOL	fFxnSizePresent = FALSE; // Flag for function size availability
#endif /* !TMIFILEHACK */

static wsrmod_t WsrMod; 		// Module information
static wsrmod_t *pWsrMod = &WsrMod; // Pointer for legacy use
static wsrfxn_t *WsrFxn;		// Pointer to function information
static ULONG	*FxnBits;		// Pointer to dword of bitstring
static ULONG	*FxnOrder;		// Pointer to ordered list of
                              //	function ordinals
typedef USHORT  WsDecision_t;
#define WSDECISION_TAKEN   USHRT_MAX   // Reserve highest value for special code
#define WsDecision_MAX     (WSDECISION_TAKEN-1) // Use fullest spread for decision matrix
static WsDecision_t	**WsDecision;  // Decision matrix for data reduction; mdg 98/4 use small alloc for large symbol counts
static ULONG	ulRefHi1 = 0;		// Highest diagonal value (for WsRedScaleWsDecision)
static ULONG	ulRefHi2 = 0;		// Second highest diagonal value (for WsRedScaleWsDecision)
static UINT    uiSelected = 0;   // Highest function ordinal selected (for WsRedReorder)
static UINT    cFxnOrder = 0;    // Count of ordered functions
#ifndef  SLOWMO
static UINT    nFxnToSort;       // To pass static value to wsRedChooseEdgeOptCmp()
#endif   // SLOWMO

static FILE   	*hFileWLK = NULL; // Handle to file containing ordered
HGLOBAL			hMem[10];
ULONG			ulFxnIndex;		// Index of original TMI order of function.

#ifdef TMR
ULONG		pqwTime0[2];
#endif /* TMR */

/*
 * Procedure wsReduceMain
 *
 *
 ***
 * Effects:
 *
 * Performs data reduction and analysis on the input modules' function reference
 * data.
 *
 *	szBaseName	Specifies a module WSP file name
 */

BOOL wsReduceMain( CHAR *szBaseName )
{
	size_t	i;
    char *   pSlash;

    szFileWSP = malloc( i = strlen( szBaseName ) + 5 );
    if (szFileWSP) {
        szFileWSP = strcat( strcpy(szFileWSP , szBaseName ), ".WSP" );
    } else {
        exit(1);
    }
    szFileTMI = malloc( i );
    if (szFileTMI) {
        szFileTMI = strcat( strcpy( szFileTMI, szBaseName ), ".TMI" );
    } else {
        free(szFileWSP);
        exit(1);
    }
#ifdef DEBUG
    fVerbose = fDbgVerbose;
#endif   // DEBUG

   // Create output file in current directory
    if (NULL != (pSlash = strrchr( szBaseName, '\\' ))
        || NULL != (pSlash = strrchr( szBaseName, '/' ))
        || NULL != (pSlash = strrchr( szBaseName, ':' )))
    {
        ++pSlash;
        szFileWSR = malloc(strlen( pSlash ) + 5 );
        if (szFileWSR) {
            szFileWSR = strcat( strcpy(szFileWSR, pSlash ), ".WSR" );
        } else {
            free(szFileTMI);
            free(szFileWSP);
            exit(1);
        }
    } else {
        szFileWSR = malloc( i );
        if (szFileWSR) {
            szFileWSR = strcat( strcpy( szFileWSR, szBaseName ), ".WSR" );
        } else {
            free(szFileTMI);
            free(szFileWSP);
            exit(1);
        }
    }

#ifdef TMR
	DosTmrQueryTime((PQWORD)pqwTime0);
	printf("Top of Main, 0x%lx:0x%lx\n", pqwTime0[1], pqwTime0[0]);
#endif /* TMR */

	pWsrMod->wsrmod_un.wsrmod_pchModFile = szFileWSP;
#ifdef DEBUG
   printf("\t%s\n", pWsrMod->wsrmod_un.wsrmod_pchModFile);
#endif /* DEBUG */

	// Initialize module and function information structures.
   wsRedInitialization();

	// Set up weighted decision matrix.
	wsRedSetup();

	// Perform the function reference data analysis.
	wsRedReorder();

	// Output the analysis results.
	wsRedOutput();

	// Cleanup memory allocations.
	wsRedCleanup();
   free( szFileWSP );
   free( szFileWSR );
   free( szFileTMI );

	return(NO_ERROR);
}

/*
 *
 ***LP wsRedInitialization
 *
 *
 * Effects:
 *	- Calls wsRedInitModules to:
 *		o Open and validate each module's WSP file.
 *		o Open and validate each module's TMI file.
 *	- Calls wsRedInitFunctions to:
 *		o Set up WsrFxn[] with per function information.
 *		o Allocate FxnBits[].
 *	- Allocates WsDecision[][].
 *	- Allocates and initializes DiagonalFxn[].
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedInitialization()
{
	UINT	 i;			// Loop counter


	// Setup module information.
	wsRedInitModules();

	// Setup function information for each module.
	wsRedInitFunctions();

	// Allocate the decision matrix, WsDecision[cFxnsTot][cFxnsTot].
	WsDecision = (WsDecision_t **) AllocAndLockMem((cFxnsTot * cFxnsTot * sizeof(WsDecision_t)) + (cFxnsTot * sizeof(WsDecision_t *)), &hMem[1]);
	if (WsDecision == NULL)
		wsRedExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				(cFxnsTot+1)*cFxnsTot*sizeof(WsDecision_t), "WsDecision[][]");
   for (i = 0; i < cFxnsTot; i++)
	{
      WsDecision[i] = (WsDecision_t *) (WsDecision+cFxnsTot)+(i*cFxnsTot);
	}

}

/*
 *
 ***LP wsRedInitModules
 *
 *
 * Effects:
 *	- Opens and validates each module's WSP file.
 *	- Opens and validates each module's TMI file.
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedInitModules()
{
	wsphdr_t 	WspHdr;						// WSP file header
	UINT		cFxns = 0;					// Number of functions for this module
	ULONG		ulTimeStamp = 0;			// Time stamp
	ULONG		ulTDFID = 0;				// TDF Identifier


	/* Open module's input WSP file.  Read and validate
	 * WSP file header.
	 */

	rc = WsWSPOpen(pWsrMod->wsrmod_un.wsrmod_pchModFile,
			&(pWsrMod->wsrmod_hFileWSP), (PFN) wsRedExit,
			&WspHdr, ERROR, PRINT_MSG );
	if (NULL == (pWsrMod->wsrmod_un.wsrmod_pchModName = malloc( 1 + WspHdr.wsphdr_dtqo.dtqo_cbPathname )))
		wsRedExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				WspHdr.wsphdr_dtqo.dtqo_cbPathname + 1,
				pWsrMod->wsrmod_un.wsrmod_pchModFile);
   rc = fread( pWsrMod->wsrmod_un.wsrmod_pchModName, WspHdr.wsphdr_dtqo.dtqo_cbPathname,
      1, pWsrMod->wsrmod_hFileWSP );
   if (rc != 1)
		wsRedExit(ERROR, PRINT_MSG, MSG_FILE_BAD_HDR, (ULONG)-1L,
				pWsrMod->wsrmod_un.wsrmod_pchModFile);
   pWsrMod->wsrmod_un.wsrmod_pchModName[WspHdr.wsphdr_dtqo.dtqo_cbPathname] = '\0';

	ulTimeStamp = WspHdr.wsphdr_ulTimeStamp;
	cSnapsTot = WspHdr.wsphdr_ulSnaps;
	cbBitStr = cSnapsTot * sizeof(ULONG);

	pWsrMod->wsrmod_ulOffWSP = WspHdr.wsphdr_ulOffBits;

	/*
	 * Open associated TMI file.  Assume it lives in same directory.
	 * Read and validate TMI header. Increment cFxnsTot.
	 */
	cTmiFxns = WsTMIOpen(szFileTMI, &(pWsrMod->wsrmod_hFileTMI),
				(PFN) wsRedExit,
				0, (PCHAR)0);
	cFxns = WspHdr.wsphdr_dtqo.dtqo_SymCnt;

#ifdef DEBUG
	printf("%s file header: # fxns = %ld, TDF ID = 0x%x\n", szFileTMI,
			cFxns, (UINT) WspHdr.wsphdr_dtqo.dtqo_usID);
#endif /* DEBUG */

	cFxnsTot = cFxns;

	// If no function data to analyze, just exit without error.
	if (cFxnsTot == 0)
		wsRedExit(NO_ERROR, NO_MSG, NO_MSG, 0, NULL);
}


/*
 *
 ***LP wsRedInitFunctions
 *
 *
 * Effects:
 *	- Sets up WsrFxn[] with per function information.
 *	- Allocates FxnBits[].
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedInitFunctions()
{
	UINT	uiFxn = 0;		// Function number
	UINT	cFxns = 0;		// Number of functions for this module


	// Allocate memory for per function info, WsrFxn[cFxnsTot].
	WsrFxn = (wsrfxn_t *) AllocAndLockMem(cFxnsTot*sizeof(wsrfxn_t), &hMem[3]);
	if (WsrFxn == NULL)
		wsRedExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				cFxnsTot * sizeof(wsrfxn_t), "WsrFxn[]");

   WsIndicator( WSINDF_NEW, "Load Functions", cFxnsTot );
	// Initialize WsrFxn[cFxnsTot].
   uiFxn = 0;		// loop index init
	cFxns = cFxnsTot; // loop invariant
#ifdef DEBUG
   if (fVerbose)
   {
		printf("Initializing WsrFxn[] for %s:\n\tstart/end fxn indices (%d/%d)\n",
			pWsrMod->wsrmod_un.wsrmod_pchModName, uiFxn,
			cFxns - 1);

		printf("TMI file handle: %ld\n",pWsrMod->wsrmod_hFileTMI);
   }
#endif /* DEBUG */
	for (; uiFxn < cFxns; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		WsrFxn[uiFxn].wsrfxn_cbFxn =
			WsTMIReadRec(&(WsrFxn[uiFxn].wsrfxn_pchFxnName),&ulFxnIndex,&ulTmp,pWsrMod->wsrmod_hFileTMI,
				 (PFN) wsRedExit, (PCHAR)0);
#ifdef DEBUG
		if (fVerbose)
			printf("\tWsrFxn[%d] %s\n",
				uiFxn, WsrFxn[uiFxn].wsrfxn_pchFxnName );
#endif /* DEBUG */
		WsrFxn[uiFxn].wsrfxn_fCandidate = TRUE;


	}

	// Close TMI file.
	fclose(pWsrMod->wsrmod_hFileTMI);

   WsIndicator( WSINDF_FINISH, NULL, 0 );

	// Allocate space to hold 32 snapshots for each function.
	FxnBits = (ULONG *) AllocAndLockMem(cFxnsTot*sizeof(ULONG), &hMem[4]);
	if (FxnBits == NULL)
		wsRedExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				cFxnsTot * sizeof(ULONG), "FxnBits[]");
}

/*
 *
 ***LP wsRedSetup
 *
 *
 * Effects:
 *
 * Initializes the data structures used to analyze the function
 * reference bitstrings, including the weighted decision matrix.
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedSetup()
{
	wsRedSetWsDecision();		// set up initial decision matrix
	wsRedScaleWsDecision();		// scale the decision matrix
	wsRedWeightWsDecision();	// weight the matrix "edge" entries
}

/*
 *
 ***LP wsRedSetWsDecision
 *
 *
 * Effects:
 *
 * Initializes and weights the decision matrix, WsDecision[][].
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedSetWsDecision()
{
   UINT	i = 0, j = 0;		// Temporary loop indexes
   UINT	uiFxn = 0;		// Function number
   UINT	uiFBits = 0;		// Loop index for bitstring dwords
   UINT	clFBits = 0;		// Count of fxn bitstring dwords
   ULONG	ulResult = 0;		// Returned from procedure call
   FILE	*hFile;			// File handle

   /* For each dword of snapshot bitstrings...*/
   clFBits = (cbBitStr + sizeof(ULONG) - 1) / sizeof(ULONG);
   WsIndicator( WSINDF_NEW, "Fill In Matrix", clFBits * cFxnsTot );
   for (uiFBits = 0; uiFBits < clFBits; uiFBits++)
   {
      ULONG       ulOffWSP;

      WsIndicator( WSINDF_PROGRESS, "Reading Snaps ", 0 );
      // Fill in FxnBits for this snapshot
#ifdef DEBUG
      if (fVerbose)
         printf( "Setting up FxnBits snapshot %lu for %s\n",
            uiFBits, pWsrMod->wsrmod_un.wsrmod_pchModName );
#endif /* DEBUG */
      hFile = pWsrMod->wsrmod_hFileWSP;
      ulOffWSP = uiFBits + pWsrMod->wsrmod_ulOffWSP;
      for ( uiFxn = 0; uiFxn < cFxnsTot; uiFxn++, ulOffWSP += cbBitStr) // Loop functions
      {
         // Seek to next dword of function's bitstring.
         if ((rc = fseek( hFile, ulOffWSP, SEEK_SET )) != NO_ERROR)
            wsRedExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET,rc,
               pWsrMod->wsrmod_un.wsrmod_pchModName);

         // Read next dword of function's bitstring.
         rc = fread( &(FxnBits[uiFxn]), sizeof(ULONG), 1, hFile );
         if(rc != 1)
            wsRedExit(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
               pWsrMod->wsrmod_un.wsrmod_pchModName);
      }  // for each function

      WsIndicator( WSINDF_PROGRESS, "Fill In Matrix", 0 );
      hFile = pWsrMod->wsrmod_hFileWSP;
#ifdef DEBUG
      if (fVerbose)
         printf("Setting up WsDecision[][] for %s:\n\tstart/end fxn indices (%d/%d)\n",
            pWsrMod->wsrmod_un.wsrmod_pchModName,
            uiFxn, cFxnsTot - 1);
#endif /* DEBUG */
      /* For each function... */
      for ( uiFxn = 0; uiFxn < cFxnsTot; uiFxn++ )
      {
         WsIndicator( WSINDF_PROGRESS, NULL, (uiFBits * cFxnsTot) + uiFxn );
         // Get the current snapshot
         ulTmp = FxnBits[uiFxn];
#ifdef DEBUG
         if (fVerbose)
            printf("\tFxnBits[%d] = 0x%lx\n", uiFxn, ulTmp);
#endif /* DEBUG */

         /* If there are bits set... */
         if (ulTmp != 0)
         {
            /* Sum the "on" bits  and add the result
             * to WsDecision[uiFxn][uiFxn].
             */
            ulResult = 0;
	         while (ulTmp)
            {
               ++ulResult;
               ulTmp &= ulTmp - 1;
            }
            ulTmp = WsDecision[uiFxn][uiFxn] += (WsDecision_t)ulResult;
            if (ulTmp > ulRefHi2)   // Set the highest two diagonal values on the last pass
               if (ulTmp > ulRefHi1)
               {
                  ulRefHi2 = ulRefHi1;
                  ulRefHi1 = ulTmp;
                  uiSelected = uiFxn;  // Remember highest value's index
               }
               else
                  ulRefHi2 = ulTmp;

            /* Sum the overlapping "on" bits for this
             * function's dword with each preceding
             * function's dword, and add the results to
             * WsDecision[][].
             */

            for (i = 0; i < uiFxn; i++)
            {
	            ulTmp = FxnBits[i] & FxnBits[uiFxn];
               if (ulTmp)  // mdg 98/4
               {
	               ulResult = 0;
	               while (ulTmp)
                  {
                     ++ulResult;
                     ulTmp &= ulTmp - 1;
                  }
                  WsDecision[uiFxn][i] += (WsDecision_t)ulResult;
                  WsDecision[i][uiFxn] += (WsDecision_t)ulResult;
               }

            }   /* End For each previous function's dword */
         }	/* End If there are bits set...*/
      }	/* End For each function... */
   }	/* End For each dword of bitstrings */
   WsIndicator( WSINDF_FINISH, NULL, 0 );

#ifdef DEBUG
	if (fVerbose)
	{
		printf("\nRAW MATRIX:\n");
		for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
		{
			printf("row %4d:\n", uiFxn);
			for (i = 0; i < cFxnsTot; i++)
				printf("0x%lx ", (LONG)WsDecision[uiFxn][i]);
			printf("\n");
		}
	}
#endif /* DEBUG */

}

/*
 *
 ***LP wsRedOpenWSR
 *
 *
 * Effects:
 *	Opens the output WSR files, one per module.  If only one module
 *	is being reduced, also opens a WLK file, setting the WLK file handle
 *	as a side effect.
 *
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedOpenWSR(FILE **phFileWLK)
{
	/* Close WSP file, and open module output file. */
	fclose(pWsrMod->wsrmod_hFileWSP);

	if ((pWsrMod->wsrmod_hFileWSR = fopen(szFileWSR, "w"))
				== NULL)
	{
		wsRedExit(ERROR, PRINT_MSG,MSG_FILE_OPEN,rc, szFileWSR);
	}

	/* We're only analyzing ONE module. Also open a WLK
	 * file.  This file will contain the function names in their
	 * reordered sequence.  The linker will use this file to
	 * automatically reorder functions.  Note that we reuse szFileWSR
	 * here.
	 */

	strcpy(strstr(szFileWSR, ".WSR"), ".PRF");
	if ((*phFileWLK = fopen(szFileWSR, "w")) == NULL)
		wsRedExit(ERROR, PRINT_MSG,MSG_FILE_OPEN,rc, szFileWSR);
}

/*
 *
 ***LP wsRedScaleWsDecision
 *
 *
 * Effects:
 *
 * If necessary, scales the diagonal values of the matrix to avoid overflow
 * during calculations of the weighted edges (below).  Sets up DiagonalFxn[]
 * as a side effect.  Note that we go through gyrations to set
 * DiagonalFxn up backwards, so that qsort() will handle ties a little better.
 *
 * Returns:
 *
 *	Void.
 */

VOID
wsRedScaleWsDecision()
{
	UINT	i = 0, j = 0;		// Temporary loop indexes
	UINT	uiFxn = 0;			// Function number
	double	fTmp;				// Temporary float variable
	WsDecision_t	lTmp;

	fTmp = (double)ulRefHi1 * (double)ulRefHi2;
	if (fTmp > WsDecision_MAX)
	{
		// Scale down the diagonal.  Don't allow rescaled entries
		// to be zero if they were non-zero before scaling.

		fTmp /= WsDecision_MAX;
		printf("%s %s: WARNING -- Scaling back the reduction matrix by %f.\n",
					    szProgName, pszVersion, fTmp);
		for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
		{
			lTmp = WsDecision[uiFxn][uiFxn];
			if (lTmp)
			{
				lTmp = (WsDecision_t)(lTmp / fTmp);  // Discard any remainders to avoid potential overflows
				if (lTmp == 0)
					WsDecision[uiFxn][uiFxn] = 1;
				else
					WsDecision[uiFxn][uiFxn] = lTmp;
			}
		}
#ifdef DEBUG
		if (fVerbose)
		{
			printf("\nSCALED MATRIX:\n");
			for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
			{
				printf("row %4d:\n", uiFxn);
				for (i = 0; i < cFxnsTot; i++)
					printf("0x%lx ", (LONG)WsDecision[uiFxn][i]);
				printf("\n");
			}
		}
#endif /* DEBUG */
	}

#ifdef DEBUG
	if (fVerbose)
	{
		printf("Got ulRefHi1 = %ld, ulRefHi2 = %ld\n",
				ulRefHi1, ulRefHi2);
	}
#endif /* DEBUG */

}

/*
 *
 ***LP wsRedWeightWsDecision
 *
 *
 * Effects:
 *
 * Weights the decision matrix edges from start vertex to end vertex,
 * depending on the relative importance of the end vertex.
 *
 * Returns:
 *
 *	Void.
 */

VOID
wsRedWeightWsDecision()
{
	UINT	i = 0, j = 0;		// Temporary loop indexes
	UINT	uiFxn = 0;		// Function number

   WsIndicator( WSINDF_NEW, "Weight Matrix ", cFxnsTot );
	for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
   {
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		for (i = 0; i < cFxnsTot; i++)
		{
			if (uiFxn == i)
				continue;
         if (WsDecision[uiFxn][i])  // mdg 98/4
            WsDecision[uiFxn][i] *= WsDecision[i][i];
		}
   }
   WsIndicator( WSINDF_FINISH, NULL, 0 );

#ifdef DEBUG
	if (fVerbose)
	{
		printf("\nWEIGHTED MATRIX:\n");
		for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
		{
			printf("row %4d:\n", uiFxn);
			for (i = 0; i < cFxnsTot; i++)
				printf("0x%lx ", (LONG)WsDecision[uiFxn][i]);
			printf("\n");
		}
	}
#endif /* DEBUG */

}

/*
 *
 ***LP wsRedReorder
 *
 * Requires:
 *
 * Effects:
 *
 * A greedy algorithm is used to determine a better ordering for the functions
 * whose reference patterns are represented in the decision matrix.  The
 * algorithm is as follows:
 *
 *	o Select the function whose value on the diagonal is greatest.
 *	  The selected function becomes the current starting vertex,
 *	  and is first on the list of ordered functions.  Mark that it
 *	  is no longer a candidate function.  Note that this does NOT mean
 *	  that its vertex is removed from the graph.
 *
 *	o While there is more than one function remaining as a candidate:
 *
 *	  - Choose the edge of greatest weight leading from the current
 *	    starting vertex.  Ties are broken as follows:  If one of the
 *	    tied ending vertices is in the selected set and the other is
 *	    not, choose the edge whose ending vertex is already selected
 *	    (because we already know that vertex is "important"); further
 *	    ties are broken by choosing the end vertex whose diagonal value
 *	    is greatest.
 *
 *	  - If the ending vertex chosen above is still a candidate (i.e., not
 *	    already selected), then select it for the list of ordered
 *	    functions, and mark that it is no longer a candidate.
 *
 *	  - Set the matrix entry for the chosen edge to some invalid value,
 *	    so that edge will never be chosen again.
 *
 *	  - Set current starting vertex equal to the ending vertex chosen
 *	    above.
 *
 *	o Select the one remaining function for the list of ordered functions.
 *
 * mdg 98/4: Added "pnEdges" and "nEdgeCount" to function structure. If the number
 *            of set functions is < USHRT_MAX (very likely, even for very large
 *            projects), allocate as needed a sorted index for WsRedReorder(). This
 *            cuts dramatically the number of passes through the matrix searching for
 *            the next edge to consider.
 *
 * Returns:
 *
 *	Void.
 */

VOID
wsRedReorder()
{
	UINT	uiFxn = 0;		// Function number
	UINT	i = 0;			// Temporary loop index
	UINT	cCandidates = 0;	// Count of candidates remaining
	UINT	uiEdge = 0;		// Function ordinal edge selected

	/* Reuse FxnBits[] for the ordered list of functions, FxnOrder[]. */
   WsIndicator( WSINDF_NEW, "Reorder Matrix", cFxnsTot );
	FxnOrder = FxnBits;
	memset((PVOID) FxnOrder, 0, cFxnsTot * sizeof(ULONG));

	cCandidates = cFxnsTot;

	FxnOrder[cFxnOrder++] = uiSelected;
	WsrFxn[uiSelected].wsrfxn_fCandidate = FALSE;
	--cCandidates;

	while (cCandidates > 1)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, cFxnsTot - cCandidates );
		/* Follow highest weighted edge from selected vertex. */
#ifdef   SLOWMO
      uiEdge = wsRedChooseEdge(uiSelected);
#else    // SLOWMO
      uiEdge = wsRedChooseEdgeOpt( uiSelected );
#endif   // SLOWMO
#ifdef DEBUG
		if (fVerbose)
			printf("choose edge (%d->%d)\n", uiSelected, uiEdge);
#endif
		uiSelected = uiEdge;
		if (WsrFxn[uiEdge].wsrfxn_fCandidate)
		{
			FxnOrder[cFxnOrder++] = uiSelected;
			WsrFxn[uiSelected].wsrfxn_fCandidate = FALSE;
			--cCandidates;
		}
	}
   WsIndicator( WSINDF_FINISH, NULL, 0 );

	if (cCandidates == 1)
	{
		for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
			if (WsrFxn[uiFxn].wsrfxn_fCandidate)
			{
				FxnOrder[cFxnOrder++] = uiFxn;
				break;
			}
	}
}

#ifdef   SLOWMO
/*
 *
 ***LP wsRedChooseEdge
 *
 *
 * Effects:
 *
 *	"Selects" a function from the candidate pool, based on weighted
 *	edge from 'index' function to a candidate function.
 *
 *
 *
 * Returns:
 *
 *	Ordinal number of selected function.
 *
 */

UINT
wsRedChooseEdge(UINT uiIndex)
{
	UINT	uiFxn = 0;		// Function ordinal number.
	WsDecision_t	iMaxWt = WSDECISION_TAKEN; // Highest weighted edge encountered.
	UINT	uiRet = 0;		// Return index.
	for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
	{
		if (uiFxn == uiIndex
         || WsDecision[uiIndex][uiFxn] == WSDECISION_TAKEN)
			continue;
		if (WsDecision[uiIndex][uiFxn] > iMaxWt
         || iMaxWt == WSDECISION_TAKEN )
		{
			iMaxWt = WsDecision[uiIndex][uiFxn];
			uiRet = uiFxn;
		}
		else if (WsDecision[uiIndex][uiFxn] == iMaxWt)
		{
			/* Need tiebreak.  If 'uiFxn' has already been selected,
			 * we know it is important, so choose it.  Otherwise,
			 * and in the case where more than one of the tied
			 * functions has already been selected, choose based
			 * on the diagonal value.
			 */
			if ((WsrFxn[uiFxn].wsrfxn_fCandidate == FALSE) &&
				(WsrFxn[uiRet].wsrfxn_fCandidate))
				/* Choose 'uiFxn', it's been selected before */
				uiRet = uiFxn;
         else
			if (WsDecision[uiFxn][uiFxn] > WsDecision[uiRet][uiRet])
            uiRet = uiFxn;
		}
	}
	WsDecision[uiIndex][uiRet] = WsDecision[uiRet][uiIndex] = WSDECISION_TAKEN;
	return(uiRet);
}
#else // SLOWMO

/*
 *
 ***LP wsRedChooseEdgeOpt
 *
 *
 * Effects:
 *
 *	"Selects" a function from the candidate pool, based on weighted
 *	edge from 'index' function to a candidate function. Allocates a sorted
 * index (highest to lowest) to each function's edges on demand. Uses the
 * current highest value (with a few checks) as the selection. This
 * optimized algorithm produces identical results for the important high
 * usage high overlap functions, but diverges in the results for low usage
 * (2 or 1 hits) low overlap functions. Differences are not significant
 * from a performance perspective - a better algorithm would give marginally
 * better results.
 *
 *
 *
 * Returns:
 *
 *	Ordinal number of selected function.
 *
 */

UINT
wsRedChooseEdgeOpt(UINT uiIndex)
{
	UINT        uiRet;
   wsrfxn_t *  pWsrFxn = &WsrFxn[uiIndex];

   // Allocate and sort edges list if it doesn't already exist for this function
   if (wsRedChooseEdgeOptAlloc( uiIndex ))
   {
		wsRedExit( ERROR, PRINT_MSG, MSG_NO_MEM,
         (cFxnsTot - 1) * sizeof(*pWsrFxn->pnEdges), "WsrFxn[].pnEdges" );
   }

   // Check remaining edges
   uiRet = wsRedChooseEdgeOptNextEdge( uiIndex, FALSE );

   if (uiRet == cFxnsTot)
   // What should we do here? The algorithm we're copying falls through
   // and arbitrarily returns 0. It seems we should pick the most overlapped
   // non-Candidate, or the heaviest Candidate and restart from there.
   {
   	WsDecision_t	iMaxWt;
      static UINT    nFxnOrdStart = 0; // Remember last value to restart there
      static UINT    nFxnTotStart = 0; // Remember last value to restart there
      UINT           nSelIndex;
      UINT           nFxn;

      // Search for most overlapped non-Candidate that's not uiIndex ('uiIndex' should be empty by now)
      iMaxWt = WSDECISION_TAKEN;
      for (nFxn = nFxnOrdStart; nFxn < cFxnOrder; ++nFxn)
      {
         UINT        nLocalIndex = FxnOrder[nFxn];
         UINT        nRetCheck;

			if (!WsrFxn[nLocalIndex].nEdgesLeft)
         {
            if (nFxnOrdStart == nFxn)  // Haven't found available edge yet?
               ++nFxnOrdStart;   // All non-Candidates already have been allocated, so they can be skipped next time
            continue;
         }
         // Get the first available value remaining
         nRetCheck = wsRedChooseEdgeOptNextEdge( nLocalIndex, TRUE );
         if (nRetCheck != cFxnsTot
            && nRetCheck != uiIndex)
         {
            // See if this one's heavier
            if (WsDecision[nLocalIndex][nRetCheck] > iMaxWt
               || iMaxWt == WSDECISION_TAKEN)
            {
               nSelIndex = nLocalIndex;
               iMaxWt = WsDecision[nSelIndex][nRetCheck];
               uiRet = nRetCheck;
            }
            else if (WsDecision[nLocalIndex][nRetCheck] == iMaxWt // On tie, use heaviest function
               && WsDecision[nRetCheck][nRetCheck] > WsDecision[uiRet][uiRet])   // Assume uiRet != cFxnsTot by now
            {
               nSelIndex = nLocalIndex;
               uiRet = nRetCheck;
            }
         }
      }
      if (uiRet != cFxnsTot)  // Found an overlapped non-Candidate?
      {
         WsDecision[nSelIndex][uiRet] = WsDecision[uiRet][nSelIndex] = WSDECISION_TAKEN;
         return uiRet;
      }
      else  // Didn't find an overlapped non-Candidate?
      {
         // Search for heaviest Candidate - assume at least two are left: see wsRedReorder()
         iMaxWt = WSDECISION_TAKEN;
         for (nFxn = nFxnTotStart; nFxn < cFxnsTot; ++nFxn)
         {
            if (!WsrFxn[nFxn].wsrfxn_fCandidate)
            {
               if (nFxnTotStart == nFxn)  // Haven't found unused value yet?
                  ++nFxnTotStart;   // If it's not a candidate now, it won't be again either
               continue;
            }
            if (nFxn == uiIndex)
               continue;
            if (WsDecision[nFxn][nFxn] > iMaxWt
               || iMaxWt == WSDECISION_TAKEN)
            {
               iMaxWt = WsDecision[nFxn][nFxn];
               uiRet = nFxn;
            }
         }
      }
   }

	WsDecision[uiIndex][uiRet] = WsDecision[uiRet][uiIndex] = WSDECISION_TAKEN;
	return uiRet;
}

// Comparison function for qsort - uses external nFxnToSort for static index
INT
__cdecl
wsRedChooseEdgeOptCmp ( const UINT *pn1, const UINT *pn2 )
{
   WsDecision_t   Val1 = WsDecision[nFxnToSort][*pn1],
                  Val2 = WsDecision[nFxnToSort][*pn2];
   return Val1 > Val2 ? -1 // higher values preferred
      : Val1 < Val2 ? 1
      // If the same, prefer the highest valued diagonal
      : (Val1 = WsDecision[*pn1][*pn1]) > (Val2 = WsDecision[*pn2][*pn2]) ? -1   
      : Val1 < Val2 ? 1
      // Prefer prior function if no other differences
      : *pn1 < *pn2 ? -1
      : 1;
}

// Allocate and sort edges list for a function if not already allocated
// Return TRUE on failure to allocate, FALSE if successful (even if list is empty)
// Creates sorted index list from all non-zero unused WsDecision entries for this row
//  except for the diagonal. Sorts from greatest to lowest: see wsRedChooseEdgeOptCmp().
//  If no such entries exist, marks the function edges as allocated, but with none
//  left to scan; doesn't actually allocate any memory.
BOOL
wsRedChooseEdgeOptAlloc( UINT uiIndex )
{
   wsrfxn_t *  pWsrFxn = &WsrFxn[uiIndex];

   if (pWsrFxn->nEdgesAlloc == 0
      && pWsrFxn->pnEdges == NULL)
   {
      UINT     nEdgeTot, nFxn;
      // Allocate maximum size initially
      pWsrFxn->pnEdges = malloc( (cFxnsTot - 1) * sizeof(*pWsrFxn->pnEdges) );
      if (pWsrFxn->pnEdges == NULL) // No more memory?
         return TRUE;
      // Fill in array
      for (nEdgeTot = nFxn = 0; nFxn < cFxnsTot; ++nFxn)
      {
         if (nFxn == uiIndex) // Skip diagonal
            continue;
         if (WsDecision[uiIndex][nFxn] > 0  // Edge still available? No point in considering 0
            && WsDecision[uiIndex][nFxn] != WSDECISION_TAKEN)
            pWsrFxn->pnEdges[nEdgeTot++] = nFxn;
      }
      if (nEdgeTot > 0) // Edges available?
      {
         if (nEdgeTot != (cFxnsTot - 1))  // Extra space allocated?
         {
            // Make it smaller
            UINT     *pNewAlloc = realloc( pWsrFxn->pnEdges, nEdgeTot * sizeof(*pWsrFxn->pnEdges) );
            if (pNewAlloc != NULL)
               pWsrFxn->pnEdges = pNewAlloc;
         }
         // Fill in remaining structure members
         pWsrFxn->nEdgesAlloc = pWsrFxn->nEdgesLeft = nEdgeTot;
         // Sort highest to lowest
         nFxnToSort = uiIndex;   // Set static for sort function
         qsort( pWsrFxn->pnEdges, nEdgeTot, sizeof(*pWsrFxn->pnEdges),
            (int (__cdecl *)(const void *, const void *))wsRedChooseEdgeOptCmp );
      }
      else  // pWsrFxn->nEdgesAlloc == NULL
      {
         // Set structure members to indicate nothing left
         pWsrFxn->nEdgesAlloc = 1;  // non-zero indicates some allocation happened
         pWsrFxn->nEdgesLeft = 0;
         free( pWsrFxn->pnEdges );  // Eliminate allocation - nothing left to check
         pWsrFxn->pnEdges = NULL;
      }
   }
   return FALSE;
}

// Get next edge for given function; highest overlap of most-used function
// Returns "cFxnsTot" if no edge exists; otherwise the function index of next edge
// Side-effect: optimizes search for next pass; frees edge index if no longer needed
// Since choosing an edge marks WsDecision entries as used (WSDECISION_TAKEN), we
//  must step over any of these entries. Once these entries and the first unused entry
//  have been selected, we don't need to consider them anymore. However, if
//  'bNoSelectOpt' is TRUE, only optimize leading skipped entries (not the selected
//  entry, since it may not be taken).
UINT
wsRedChooseEdgeOptNextEdge( UINT uiIndex, BOOL bNoSelectOpt )
{
   wsrfxn_t *  pWsrFxn = &WsrFxn[uiIndex];
   UINT        uiRet = cFxnsTot;

   if (pWsrFxn->nEdgesLeft > 0)
   {
      UINT           nMaxIx,
                     nNextIx = pWsrFxn->nEdgesAlloc - pWsrFxn->nEdgesLeft;
      WsDecision_t   iMax, iNext;
      UINT           nRetCheck;

      // Get the first available value remaining
      while ((iMax = WsDecision[uiIndex][nRetCheck = pWsrFxn->pnEdges[nMaxIx = nNextIx++]])
          == WSDECISION_TAKEN
         && nNextIx < pWsrFxn->nEdgesAlloc);
      // Check next available value for equivalence
      if (iMax != WSDECISION_TAKEN)
      {
         UINT     nMaxIxNext = nMaxIx; // Save index of next used entry

         uiRet = nRetCheck;
         for (; nNextIx < pWsrFxn->nEdgesAlloc; ++nNextIx)
         {
            nRetCheck = pWsrFxn->pnEdges[nNextIx];
            iNext = WsDecision[uiIndex][nRetCheck];
            if (iNext != WSDECISION_TAKEN)
            {
               if (iNext != iMax // only need to check for equality since already sorted
                  || !WsrFxn[uiRet].wsrfxn_fCandidate)   // Already selected - choose this one
                  break;
               else
               {
			         /* Need tiebreak.  If 'nRetCheck' has already been selected,
			          * we know it is important, so choose it.  Otherwise,
			          * and in the case where more than one of the tied
			          * functions have already been selected, choose based
			          * on the diagonal value (i.e. keep previous choice since
                   * sort already accounts for diagonal if equal vertices).
			          */
			         if (!WsrFxn[nRetCheck].wsrfxn_fCandidate)
				      // Choose 'nRetCheck' - it's been selected before
                  {
				         uiRet = nRetCheck;
                     nMaxIxNext = nMaxIx - 1;   // First used entry will be checked again; don't skip it
                  }
               }
            }
            else if (nMaxIxNext == (nNextIx - 1))  // Skip unavailable values after first used entry only
               ++nMaxIxNext;
         }
         if (!bNoSelectOpt && nMaxIxNext != nMaxIx)
            nMaxIx = nMaxIxNext; // Skip over first used entry and unused entries after it
      }
      else if (bNoSelectOpt)  // This is the last one, so step over it anyway
         ++nMaxIx;
      // Adjust the optimization indexes
      pWsrFxn->nEdgesLeft = pWsrFxn->nEdgesAlloc - nMaxIx - (bNoSelectOpt ? 0 : 1);
      if (pWsrFxn->nEdgesLeft == 0)
      {
         free( pWsrFxn->pnEdges );  // Eliminate allocation - nothing left to check
         pWsrFxn->pnEdges = NULL;
      }
#ifdef YOUVE_REALLY_GOT_MEMORY_PROBLEMS
      else if (pWsrFxn->nEdgesLeft < pWsrFxn->nEdgesAlloc / 2  // Periodically get rid of some unused memory
         && pWsrFxn->nEdgesLeft > 50)
      {
         // Move edges to lower part of allocation and reallocate
         UINT *      pNewAlloc;
         nNextIx = pWsrFxn->nEdgesAlloc - pWsrFxn->nEdgesLeft;
         MoveMemory( pWsrFxn->pnEdges, &pWsrFxn->pnEdges[nNextIx], pWsrFxn->nEdgesLeft * sizeof(*pWsrFxn->pnEdges) );
         pNewAlloc = realloc( pWsrFxn->pnEdges, pWsrFxn->nEdgesLeft * sizeof(*pWsrFxn->pnEdges) );
         if (pNewAlloc != NULL)
            pWsrFxn->pnEdges = pNewAlloc;
         pWsrFxn->nEdgesAlloc = pWsrFxn->nEdgesLeft;
      }
#endif   // YOUVE_REALLY_GOT_MEMORY_PROBLEMS
   }
   return uiRet;
}

#endif   // SLOWMO

/*
 *
 ***LP wsRedOutput
 *
 *
 * Effects:
 *
 * Prints the reordered list of functions, and writes each module's
 * ordered list of function ordinals to the module's associated WSR file.
 * If only one module is being processed, then we also write the ordered
 * list of function names to a WLK file.
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedOutput()
{
	UINT		uiFxn;
   UINT     uiFxnOrd;
	wsrfxn_t 	*pWsrFxn;
								  // fxn names for linker reordering

	// Open one WSR file per module.  If only one module is reduced,
	// then also open a WLK file.  Handle to WLK file is set in
	// wsRedOpenWSR().
	wsRedOpenWSR(&hFileWLK);

   WsIndicator( WSINDF_NEW, "Saving Results", cTmiFxns );
   for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		pWsrFxn = &(WsrFxn[uiFxnOrd = FxnOrder[uiFxn]]);

		/* Print the function information. */
#ifdef DEBUG
      if (fVerbose)
#ifndef TMIFILEHACK
		if (fFxnSizePresent == FALSE)
			printf("    %s: %s\n",
				pWsrMod->wsrmod_un.wsrmod_pchModName,
				pWsrFxn->wsrfxn_pchFxnName);
		else
#endif /* !TMIFILEHACK */
			printf("    (0x%08lx bytes) %s: %s\n",
				pWsrFxn->wsrfxn_cbFxn,
				pWsrMod->wsrmod_un.wsrmod_pchModName,
				pWsrFxn->wsrfxn_pchFxnName);
#endif   // DEBUG

		/* Write the function's ordinal number to its
		 * module's associated WSR output file.
		 */
		fprintf(pWsrMod->wsrmod_hFileWSR, "%ld\n",
				uiFxnOrd);

		/* Write the function name to the WLK file, for linker use. */
		if (hFileWLK != NULL &&
			strcmp("???", pWsrFxn->wsrfxn_pchFxnName) &&
			strcmp("_penter", pWsrFxn->wsrfxn_pchFxnName))
			fprintf(hFileWLK, "%s\n", pWsrFxn->wsrfxn_pchFxnName);

	}

	for (uiFxn = cFxnsTot; uiFxn < cTmiFxns; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		pWsrFxn = &(WsrFxn[FxnOrder[0]]);

		/* Write the function's ordinal number to its
		 * module's associated WSR output file.
		 */
		fprintf(pWsrMod->wsrmod_hFileWSR, "%ld\n",
				uiFxn);


	}
	/* Close the WSR files. */
	fclose(pWsrMod->wsrmod_hFileWSR);
	pWsrMod->wsrmod_hFileWSR = NULL;
   WsIndicator( WSINDF_FINISH, NULL, 0 );

}

/*
 *
 ***LP wsRedExit
 *
 ***
 * Requires:
 *
 *
 ***
 *
 * Effects:
 *
 *	Frees up resources (as necessary).  Exits with the specified
 *	exit code, or returns void if exit code is NOEXIT.
 *
 ***
 * Returns:
 *
 *	Void, else exits.
 */

VOID
wsRedExit(UINT uiExitCode, USHORT fPrintMsg, UINT uiMsgCode, ULONG ulParam1, PSZ pszParam2)
{


   /* Print message, if necessary. */
   if (fPrintMsg)
   {
      printf(pchMsg[uiMsgCode], szProgName, pszVersion, ulParam1, pszParam2);
   }

   // Special case:  do NOT exit if called with NOEXIT.
   if (uiExitCode == NOEXIT)
      return;

   wsRedCleanup();   // mdg 98/4
   exit(uiExitCode);
}

VOID wsRedCleanup(VOID)
{
	UINT	x;

   free( pWsrMod->wsrmod_un.wsrmod_pchModName );
   pWsrMod->wsrmod_un.wsrmod_pchModName = NULL;
   for (x = 0; x < cFxnsTot; x++) {
      free( WsrFxn[x].wsrfxn_pchFxnName );
      WsrFxn[x].wsrfxn_pchFxnName = NULL;
#ifndef  SLOWMO
      if (WsrFxn[x].pnEdges != NULL)
      {
         free( WsrFxn[x].pnEdges );
         WsrFxn[x].pnEdges = NULL;
      }
#endif   // SLOWMO
   }
   for (x=0;x < 5 ; x++ ) {
		UnlockAndFreeMem(hMem[x]);
	}

	/* Close the WLK file. */
   if (NULL != hFileWLK)
	   fclose(hFileWLK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\pos.h ===
BOOL GetLastPosition(RECT *prc);
BOOL SetLastPosition(RECT *prc);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\yapt\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\group.c ===
#include "xerox.h"
#include "group.h"

PGROUP pGroups = NULL;
LPSTR pszCurrentGroup = NULL;

/*
 * Adds the names of all defined groups to the listbox/combo box given.
 *
 * Returns TRUE if success and there are >0 groups defined.
 */
BOOL GroupListInit(
HWND hwnd,
BOOL fIsCB)
{
    UINT addStringMsg = LB_ADDSTRING;
    PGROUP pGroup;

    if (pGroups == NULL) {
        return(FALSE);
    }
    if (fIsCB) {
        addStringMsg = CB_ADDSTRING;
    }
    pGroup = pGroups;
    while (pGroup) {
        SendMessage(hwnd, addStringMsg, 0, (LONG_PTR)pGroup->pszName);
        pGroup = pGroup->next;
    }
    return(TRUE);
}



BOOL DeleteGroupDefinition(
LPSTR szName)
{
    PGROUP pGroup, pGroupPrev;
    PTITLELIST ptl;

    pGroupPrev = NULL;
    pGroup = pGroups;
    while (pGroup) {
        if (!_stricmp(pGroup->pszName, szName)) {
            if (pGroupPrev == NULL) {
                pGroups = pGroup->next;
            } else {
                pGroupPrev->next = pGroup->next;
            }
            while (pGroup->ptl != NULL) {
                ptl = pGroup->ptl;
                pGroup->ptl = ptl->next;
                Free(ptl->pszTitle);
                Free(ptl->pszClass);
                Free(ptl);
            }
            Free(pGroup);
            if (pGroups != NULL) {
                pszCurrentGroup = pGroups->pszName;
            } else {
                pszCurrentGroup = NULL;
            }
            return(TRUE);
        }
        pGroupPrev = pGroup;
        pGroup = pGroup->next;
    }
    return(FALSE);
}


BOOL AddGroupDefinition(
LPSTR szName,
HWND hwndList)
{
    PGROUP pGroup, pGroupEnd;
    PTITLELIST ptl;
    HWND hwnd;
    int cItems, cb;
    char szClass[MAX_STRING_BYTES];

    /*
     *  Don't allow duplicate groups.
     *  This is how an existing group can be replaced.
     */
    DeleteGroupDefinition(szName);

    pGroup = Alloc(sizeof(GROUP));
    if (pGroup == NULL) {
        return(FALSE);
    }
    pGroup->pszName = Alloc(strlen(szName) + 1);
    if (pGroup->pszName == NULL) {
        Free(pGroup);
        return(FALSE);
    }
    strcpy(pGroup->pszName, szName);

    pGroup->ptl = NULL;
    cItems = (int)SendMessage(hwndList, LB_GETCOUNT, 0, 0);
    while (cItems--) {
        ptl = Alloc(sizeof(TITLELIST));
        if (ptl != NULL) {
            cb = (int)SendMessage(hwndList, LB_GETTEXTLEN, cItems, 0);
            if (cb) {
                ptl->pszTitle = Alloc(cb + 1);
                if (ptl->pszTitle != NULL) {
                    SendMessage(hwndList, LB_GETTEXT, cItems, (LONG_PTR)ptl->pszTitle);
                    hwnd = (HWND)SendMessage(hwndList, LB_GETITEMDATA, cItems, 0);
                    GetClassName(hwnd, szClass, sizeof(szClass));
                    ptl->pszClass = Alloc(strlen(szClass) + 1);
                    if (ptl->pszClass != NULL) {
                        strcpy(ptl->pszClass, szClass);
                        ptl->next = pGroup->ptl;
                        pGroup->ptl = ptl;
                    } else {
                        Free(ptl->pszTitle);
                        Free(ptl);
                    }

                } else{
                    Free(ptl);
                }
            } else {
                Free(ptl);
            }
        }
    }
    if (pGroup->ptl == NULL) {
        Free(pGroup);
        return(FALSE);
    }

    /*
     *  Put it on the end of the list.  This is an awkward attempt
     *  at making the initial group the first group defined.  Probably
     *  should save this info in the registry.
     */
    pGroup->next = NULL;

    if (pGroups != NULL) {
        pGroupEnd = pGroups;
        while (pGroupEnd->next != NULL) {
            pGroupEnd = pGroupEnd->next;
        }
        pGroupEnd->next = pGroup;
    } else {
        pGroups = pGroup;
    }

    pszCurrentGroup = pGroup->pszName;
    return(TRUE);
}





BOOL SelectGroupDefinition(
LPSTR szName,
HWND hwndList,
BOOL DisplayMissingWin)
{
    PGROUP pGroup;
    HWND hwndAdd;
    PTITLELIST ptl;

    if (szName == NULL) {
        return(FALSE);
    }
    pGroup = FindGroup(szName);
    if (pGroup == NULL) {
        return(FALSE);
    }
    while (SendMessage(hwndList, LB_GETCOUNT, 0, 0)) {
        SendMessage(hwndList, LB_DELETESTRING, 0, 0);
    }
    ptl = pGroup->ptl;
    while (ptl) {
        hwndAdd = FindWindow(ptl->pszClass, ptl->pszTitle);
        if (DisplayMissingWin || (hwndAdd != NULL)) {
            if (hwndAdd == NULL) {
                hwndAdd = INVALID_HANDLE_VALUE;
            }
            AddLBItemhwnd(hwndList, ptl->pszTitle, (LONG_PTR)hwndAdd);
        }

        ptl = ptl->next;
    }
    pszCurrentGroup = pGroup->pszName;
    return(TRUE);
}



LPSTR GetCurrentGroup()
{
    return(pszCurrentGroup);
}

VOID SetNoCurrentGroup(HWND hwnd, LPSTR szTitle)
{
   SetWindowText(hwnd, szTitle);
   pszCurrentGroup = NULL;
}


PGROUP FindGroup(
LPSTR szName)
{
    PGROUP pGroup;

    pGroup = pGroups;
    while (pGroup) {
        if (!_stricmp(szName, pGroup->pszName)) {
            return(pGroup);
        }
        pGroup = pGroup->next;
    }
    return(NULL);
}



int CountGroups()
{
    PGROUP pGroup;
    int c = 0;

    pGroup = pGroups;
    while (pGroup) {
        c++;
        pGroup = pGroup->next;
    }
    return(c);
}


VOID SaveGroups()
{
    DWORD cbSave = 1; // for last NULL terminator.
    int cTitles;
    PGROUP pGroup;
    LPSTR pBuf, psz;
    LPWORD pw;
    HKEY hKey;
    PTITLELIST ptl;

    if (ERROR_SUCCESS !=
            RegCreateKey(HKEY_CURRENT_USER,
                    "Software\\Microsoft\\Xerox", &hKey)) {
        return;
    }

    pGroup = pGroups;
    while (pGroup) {
        cbSave += strlen(pGroup->pszName) + 1;
        ptl = pGroup->ptl;
        while (ptl) {
            cbSave += strlen(ptl->pszTitle) + 2 + strlen(ptl->pszClass) + 2;
            ptl = ptl->next;
        }
        pGroup = pGroup->next;
    }
    if (cbSave == 0) {
        return;
    }
    pBuf = psz = Alloc(cbSave);
    if (pBuf == NULL) {
        return;
    }
    RegSetValueEx(hKey, "Groups", 0, REG_MULTI_SZ, "\0\0", 2);
    pGroup = pGroups;
    while (pGroup) {
        strcpy(psz, pGroup->pszName);
        psz += strlen(psz) + 1;
        ptl = pGroup->ptl;
        while (ptl) {
            *psz++ = '\t';
            strcpy(psz, ptl->pszTitle);
            psz += strlen(psz) + 1;
            *psz++ = '\t';
            strcpy(psz, ptl->pszClass);
            psz += strlen(psz) + 1;
            ptl = ptl->next;
        }
        pGroup = pGroup->next;
    }
    *psz = '\0';    // double NULL terminate last string.
    RegSetValueEx(hKey, "Groups", 0, REG_MULTI_SZ, pBuf, cbSave);
    RegCloseKey(hKey);
    Free(pBuf);
}


VOID FreeGroups()
{
    PTITLELIST ptl;
    PGROUP pGroup;

    pszCurrentGroup = NULL;
    while (pGroups) {
        while (pGroups->ptl) {
            ptl = pGroups->ptl;
            Free(ptl->pszTitle);
            Free(ptl->pszClass);
            pGroups->ptl = ptl->next;
            Free(ptl);
        }
        pGroup = pGroups;
        pGroups = pGroups->next;
        Free(pGroup);
    }
}


VOID LoadGroups()
{
    int cTitles;
    HKEY hKey;
    DWORD cbLoad = 0;
    DWORD dwType;
    LPSTR pBuf, psz;
    PTITLELIST ptl;
    PGROUP pGroup, pGroupEnd = NULL;

    FreeGroups();
    if (ERROR_SUCCESS !=
            RegOpenKey(HKEY_CURRENT_USER, "Software\\Microsoft\\Xerox", &hKey)) {
        return;
    }
    RegQueryValueEx(hKey, "Groups", 0, &dwType, NULL, &cbLoad);
    if (dwType != REG_MULTI_SZ) {
        RegCloseKey(hKey);
        return;
    }
    if (cbLoad) {
        pBuf = psz = Alloc(cbLoad);
        if (pBuf == NULL) {
            return;
        }
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, "Groups", 0, &dwType, pBuf, &cbLoad)) {
            Free(pBuf);
            return;
        }
        while (*psz) {
            pGroup = Alloc(sizeof(GROUP));
            if (pGroup == NULL) {
                Free(pBuf);
                return;
            }
            pGroup->pszName = Alloc(strlen(psz) + 1);
            if (pGroup->pszName == NULL) {
                Free(pBuf);
                Free(pGroup);
                return;
            }
            strcpy(pGroup->pszName, psz);
            pGroup->ptl = NULL;
            psz += strlen(psz) + 1;
            while (*psz == '\t') {
                psz++;
                ptl = Alloc(sizeof(TITLELIST));
                if (ptl == NULL) {
                    Free(pBuf);
                    return;
                }
                ptl->pszTitle = Alloc(strlen(psz));
                if (ptl->pszTitle == NULL) {
                    Free(pBuf);
                    Free(ptl);
                    return;
                }
                strcpy(ptl->pszTitle, psz);
                psz += strlen(psz) + 2;
                ptl->pszClass = Alloc(strlen(psz));
                if (ptl->pszClass == NULL) {
                    Free(pBuf);
                    Free(ptl);
                    return;
                }
                strcpy(ptl->pszClass, psz);
                psz += strlen(psz) + 1;
                ptl->next = pGroup->ptl;
                pGroup->ptl = ptl;
            }

            /*
             *  Restore groups to origional order.
             */
            if (pGroupEnd == NULL) {
                pGroups = pGroup;
                pGroupEnd = pGroup;
            } else {
                pGroupEnd->next = pGroup;
                pGroupEnd = pGroup;
            }
            pGroup->next = NULL;
        }
        Free(pBuf);

        /*
         *  Set default current group to first in list.
         */
        if (pGroups != NULL) {
            pszCurrentGroup = pGroups->pszName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\util.h ===
PVOID   Alloc(SIZE_T);
SIZE_T  GetAllocSize(PVOID);
BOOL    Free(PVOID);

INT       AddItem(HWND, INT, LPSTR, LONG_PTR, BOOL);
INT       AddItemhwnd(HWND, LPSTR, LONG_PTR, BOOL);
LONG_PTR FindData(HWND, LONG_PTR, BOOL);

// Useful macros

#define AddLBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, FALSE))

#define AddCBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, TRUE))

#define AddLBItemhwnd(hwnd, string, data) \
        (AddItemhwnd(hwnd, string, data, FALSE))

#define AddCBItemhwnd(hwnd, string, data) \
        (AddItemhwnd(hwnd, string, data, TRUE))

#define FindLBData(hwnd, data) \
        (FindData(hwnd, data, FALSE))

#define FindCBData(hwnd, data) \
        (FindData(hwnd, data, TRUE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\util.c ===
/****************************************************************************

   PROGRAM: UTIL.C

   PURPOSE: System utility routines

****************************************************************************/

#include "xerox.h"
#include <string.h>


/****************************************************************************

   FUNCTION: Alloc

   PURPOSE: Allocates memory to hold the specified number of bytes

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID
Alloc(
    SIZE_T   Bytes
    )
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    // Lock down the memory
    //
    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    //
    // Store the handle at the start of the memory block and return
    // a pointer to just beyond it.
    //

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


/****************************************************************************

   FUNCTION:  GetAllocSize

   PURPOSE: Returns the allocated size of the specified memory block.
            The block must have been previously allocated using Alloc

   RETURNS : Size of memory block in bytes or 0 on error

****************************************************************************/

SIZE_T
GetAllocSize(
    PVOID   Buffer
    )
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    return(LocalSize(hMem) - sizeof(hMem));
}


/****************************************************************************

   FUNCTION: Free

   PURPOSE: Frees the memory previously allocated with Alloc

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL
Free(
    PVOID   Buffer
    )
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}


/****************************************************************************

    FUNCTION: AddItem

    PURPOSE:  Adds the item string and data to the specified control
              The control is assumed to be a list-box unless fCBox == TRUE
              in which case the control is assumed to be a ComboBox

    RETURNS:  Index at which the item was added or < 0 on error

****************************************************************************/
INT
AddItem(
    HWND      hDlg,
    INT       ControlID,
    LPSTR     String,
    LONG_PTR  Data,
    BOOL      fCBox
    )
{
    HWND    hwnd;
    INT     iItem;
    USHORT  AddStringMsg = LB_ADDSTRING;
    USHORT  SetDataMsg = LB_SETITEMDATA;

    if (fCBox) {
        AddStringMsg = CB_ADDSTRING;
        SetDataMsg = CB_SETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    iItem = (INT)SendMessage(hwnd, AddStringMsg, 0, (LONG_PTR)String);

    if (iItem >= 0) {
        SendMessage(hwnd, SetDataMsg, iItem, Data);
    }

    return(iItem);
}


/****************************************************************************

    FUNCTION: AddItemhwnd

    PURPOSE:  Adds the item string and data to the specified control
              The control is assumed to be a list-box unless fCBox == TRUE
              in which case the control is assumed to be a ComboBox

    RETURNS:  Index at which the item was added or < 0 on error

****************************************************************************/
INT
AddItemhwnd(
    HWND       hwnd,
    LPSTR      String,
    LONG_PTR   Data,
    BOOL       fCBox
    )
{
    INT     iItem;
    USHORT  AddStringMsg = LB_ADDSTRING;
    USHORT  SetDataMsg = LB_SETITEMDATA;

    if (fCBox) {
        AddStringMsg = CB_ADDSTRING;
        SetDataMsg = CB_SETITEMDATA;
    }

    iItem = (INT)SendMessage(hwnd, AddStringMsg, 0, (LONG_PTR)String);

    if (iItem >= 0) {
        SendMessage(hwnd, SetDataMsg, iItem, Data);
    }

    return(iItem);
}


/****************************************************************************

    FUNCTION: FindData

    PURPOSE:  Searches for the specified data in a combo box or lbox.

    RETURNS:  Index of matching item or < 0 on error

****************************************************************************/
LONG_PTR
FindData(
    HWND     hwnd,
    LONG_PTR data,
    BOOL     fCBox
    )
{
    INT     cItems;
    USHORT  GetCountMsg = LB_GETCOUNT;
    USHORT  GetDataMsg = LB_GETITEMDATA;

    if (fCBox) {
        GetCountMsg = CB_GETCOUNT;
        GetDataMsg = CB_GETITEMDATA;
    }

    cItems = (INT)SendMessage(hwnd, GetCountMsg, 0, 0);

    if (cItems >= 0) {

        INT      iItem;
        LONG_PTR ItemData;

        for (iItem =0; iItem < cItems; iItem ++) {
            ItemData = SendMessage(hwnd, GetDataMsg, iItem, 0);
            if (data == ItemData) {
                return(iItem);
            }
        }
    }
    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\xerox.c ===
/****************************************************************************

   PROGRAM: xerox.c

   PURPOSE: Copies keyboard input to multiple target windows.

****************************************************************************/

#include "xerox.h"
#include "string.h"
#include "group.h"
#include "pos.h"
#include "stdio.h"


#define cmPaste              0xFFF1
#define VK_V                 0x56      //Virtual Key V
#define KEY_IS_DOWN          0x8000

// #define TESTING

static char pszMainWindowClass[] = "Main Window Class";
char szTitle[] = "Xerox";

HANDLE hInst;
HACCEL hAccel;

HWND    hwndMain;
HWND    hwndList;   // handle of listbox containing targets.


BOOL    InitApplication(HANDLE);
BOOL    InitInstance(HANDLE, INT);

INT_PTR APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL    PostToTargets(HWND, UINT, WPARAM, LPARAM);

INT_PTR APIENTRY WindowListDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL    WindowListDlgInit(HWND);
BOOL    CALLBACK WindowListWindowEnum(HWND, LPARAM);
INT     WindowListDlgEnd(HWND, HWND*);

INT_PTR APIENTRY AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY GroupAddDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY GroupDeleteDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY GroupSelectDlgProc(HWND hDlg, UINT msg, WPARAM wParam,LPARAM lParam);


/****************************************************************************

   FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

   PURPOSE: calls initialization function, processes message loop

****************************************************************************/

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    MSG Message;

    if (!hPrevInstance) {
        if (!InitApplication(hInstance)) {
            return (FALSE);
        }
    }

    if (!InitInstance(hInstance, nCmdShow)) {
        return (FALSE);
    }

    while (GetMessage(&Message, NULL, 0, 0)) {
        if (!TranslateAccelerator(hwndMain, hAccel, &Message)) {
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
    }

    SaveGroups();
    FreeGroups();
    return ((int)Message.wParam);
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

****************************************************************************/

BOOL InitApplication(HANDLE hInstance)
{
    WNDCLASS  wc;


    // Register the main window class

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPICON));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  (LPSTR)IDM_MAINMENU;
    wc.lpszClassName = pszMainWindowClass;

    return (RegisterClass(&wc));
}


/****************************************************************************

    FUNCTION:  InitInstance(HANDLE, int)

    PURPOSE:  Saves instance handle and creates main window

****************************************************************************/

BOOL InitInstance(HANDLE hInstance, INT nCmdShow)
{
    RECT rc;
    BOOL fLastPosSet;

    LoadGroups();

    // Store instance in global
    hInst = hInstance;

    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCEL));
    fLastPosSet = GetLastPosition(&rc);

    // Create the main window
    hwndMain = CreateWindow(
            pszMainWindowClass,
            szTitle,
            WS_OVERLAPPEDWINDOW,
            fLastPosSet ? rc.left : CW_USEDEFAULT,
            fLastPosSet ? rc.top : CW_USEDEFAULT,
            fLastPosSet ? rc.right - rc.left : CW_USEDEFAULT,
            fLastPosSet ? rc.bottom - rc.top : CW_USEDEFAULT,
            NULL,
            NULL,
            hInstance,
            NULL);

    if (hwndMain == NULL) {
        return(FALSE);
    }

    if (GetCurrentGroup() != NULL) {
        SelectGroupDefinition(GetCurrentGroup(), hwndList, FALSE);
    }

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    return (TRUE);
}


/****************************************************************************

    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LONG)

    PURPOSE:  Processes messages for main window

    COMMENTS:

****************************************************************************/

INT_PTR
APIENTRY
MainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HMENU hMenu;
    BOOL Result;
    RECT rcWindow;
    WINDOWPLACEMENT wpWndPlacement;
    HWND hwndAdd, hwndDelete;
    CHAR string[MAX_STRING_BYTES];
    INT  ItemDelete;

    INT     TargetCount;
    INT     Index;
    HWND    hwndTarget;
    WINDOWPLACEMENT wndpl;
    INT  NumberOfItems = 0;
    INT  counter;
    HWND WindowHandleList[MAX_WINDOWS];
    INT  SelectedWindows[MAX_WINDOWS];

    switch (message) {

    case WM_CREATE:

        GetWindowRect(hwnd, &rcWindow);

        if (GetCurrentGroup() != NULL) {
            wsprintf(string, "%s - (%s)", szTitle, GetCurrentGroup());
            SetWindowText(hwnd, string);
        }

        hwndList = CreateWindow(
                "LISTBOX",
                NULL,                   // Title
                WS_CHILD | WS_VISIBLE | LBS_MULTIPLESEL,
                0, 0,                   // x,y
                rcWindow.right - rcWindow.left,
                rcWindow.bottom - rcWindow.top,
                hwnd,                   // owner
                NULL,                   // menu
                hInst,
                NULL);

        //
        // Attach all threads to our input state
        //
#ifndef TESTING
        Result = AttachThreadInput(
                    0,
                    GetCurrentThreadId(),
                    TRUE // Attaching
                    );
        if (!Result) {
        }
#endif // !TESTING
        return(0); // Continue creating window

    case WM_INITMENU:
        hMenu = (HMENU)wParam;
        EnableMenuItem(hMenu, IDM_GROUPRSTWIN, GetCurrentGroup() != NULL ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, IDM_GROUPMINWIN, GetCurrentGroup() != NULL ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, IDM_GROUPDELETE, CountGroups() ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, IDM_GROUPSELECT, CountGroups() ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, IDM_TARGETDELETE,
                (SendMessage(hwndList, LB_GETCURSEL, 0, 0) != LB_ERR) ?
                MF_ENABLED : MF_GRAYED);
        break;

    case WM_SIZE:

        //
        // Keep the listbox in sync with the main window
        //

        MoveWindow(hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
        return(0);


    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        /*
         *  Restore the windows of the current group.  Assumes that everything
         *  can be restored.
         */
        case IDM_GROUPRSTWIN:

            TargetCount = (INT)SendMessage(hwndList, LB_GETCOUNT, 0, 0);
            if (TargetCount == LB_ERR) {
                break;
            }

            for (Index = 0; Index < TargetCount; Index ++) {
                hwndTarget = (HWND)SendMessage(hwndList, LB_GETITEMDATA, Index, 0);

                ShowWindow(hwndTarget, SW_RESTORE);
            }

            SetFocus(hwndMain);
            break;

        /*
         *  Minimize the windows of the current group.  Assumes that everything
         *  can be minimized.
         */
        case IDM_GROUPMINWIN:

            TargetCount = (INT)SendMessage(hwndList, LB_GETCOUNT, 0, 0);
            if (TargetCount == LB_ERR) {
                break;
            }

            for (Index = 0; Index < TargetCount; Index ++) {
                hwndTarget = (HWND)SendMessage(hwndList, LB_GETITEMDATA, Index, 0);

                ShowWindow(hwndTarget, SW_MINIMIZE);
            }
            break;

        case IDM_TARGETADD:

            hwndAdd = (HWND)DialogBox(hInst,(LPSTR)IDD_WINDOWLIST, hwnd, WindowListDlgProc);

            SetNoCurrentGroup(hwnd, szTitle);
            break;

        case IDM_TARGETDELETE:

            NumberOfItems = (INT)SendMessage(hwndList, LB_GETSELCOUNT, 0, 0);

            if (SendMessage(hwndList, LB_GETSELITEMS, (WPARAM)&NumberOfItems, (LPARAM)SelectedWindows) != NumberOfItems)
            {
                break;
            }

            if (NumberOfItems > 0)
            {
                counter = NumberOfItems;
                while ( counter-- > 0) {

                    SendMessage(hwndList, LB_DELETESTRING, (WPARAM)WindowHandleList[counter], 0);
                }
            }
            SendMessage(hwndList, LB_SETSEL, 1, (LPARAM)(max(0, WindowHandleList[0] - 1)));
            SetNoCurrentGroup(hwnd, szTitle);
            break;

        case IDM_GROUPADD:
            //
            // Defines a 'group' of processes to equal the current target list
            //
            if (((LPSTR)DialogBox(hInst, MAKEINTRESOURCE(IDD_GROUPADD), hwnd, GroupAddDlgProc)) != NULL) {

                wsprintf(string, "%s - (%s)", szTitle, GetCurrentGroup());
                SetWindowText(hwnd, string);
            }
            break;

        case IDM_GROUPDELETE:
            DialogBox(hInst, MAKEINTRESOURCE(IDD_GROUPDELETE), hwnd, GroupDeleteDlgProc);

            if (GetCurrentGroup() == NULL) {
                SetWindowText(hwnd, szTitle);
            } else {
                SelectGroupDefinition(GetCurrentGroup(), hwndList, FALSE);
                wsprintf(string, "%s - (%s)", szTitle, GetCurrentGroup());
                SetWindowText(hwnd, string);
            }
            break;

        case IDM_GROUPSELECT:
            if (DialogBox(hInst, MAKEINTRESOURCE(IDD_GROUPSELECT), hwnd, GroupSelectDlgProc)) {

                wsprintf(string, "%s - (%s)", szTitle, GetCurrentGroup());
                SetWindowText(hwnd, string);
            }
            break;

        case IDM_REFRESHITEMS:
            SelectGroupDefinition(GetCurrentGroup(), hwndList, FALSE);
            break;

        case IDM_ABOUT:
            DialogBox(hInst,(LPSTR)IDD_ABOUT, hwnd, AboutDlgProc);
            break;

        default:
            break;
        }
        break;


    case WM_DESTROY:

        //
        // Detach all threads from our input state
        //
#ifndef TESTING
        Result = AttachThreadInput(
                    0,
                    GetCurrentThreadId(),
                    FALSE // Detaching
                    );
        if (!Result) {
        }
#endif // !TESTING
        GetWindowPlacement( hwndMain, &wpWndPlacement );
        SetLastPosition(&wpWndPlacement.rcNormalPosition);
        PostQuitMessage(0);
        break;

    case WM_PARENTNOTIFY:

       if (LOWORD(wParam) == WM_RBUTTONDOWN) {
         // send cmPaste message.
         PostToTargets(hwndList,WM_SYSCOMMAND,cmPaste,lParam);
       }
       break;

    case WM_NCRBUTTONDOWN:

       // send cmPaste message.
       PostToTargets(hwndList,WM_SYSCOMMAND,cmPaste,lParam);
       break;


    case WM_KEYDOWN:

       //
       // Forward key messages to all targets
       //
       switch (wParam) {
       case VK_INSERT:
          if (GetKeyState(VK_SHIFT) & KEY_IS_DOWN) {
             PostToTargets(hwndList,WM_SYSCOMMAND,cmPaste,lParam);
             return (DefWindowProc(hwnd, message, wParam, lParam));
          }
          break;

       case VK_V:
          if (GetKeyState(VK_CONTROL) & KEY_IS_DOWN) {
             PostToTargets(hwndList,WM_SYSCOMMAND,cmPaste,lParam);
             return (DefWindowProc(hwnd, message, wParam, lParam));
          }
          break;

       }


    case WM_KEYUP:


        //
        // Forward key messages to all targets
        //
#ifndef TESTING
        PostToTargets(hwndList, message, wParam, lParam);
#endif // !TESTING
        // drop through to default processing...

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return 0;
}


/****************************************************************************

    FUNCTION: PostToTargets(HWND)

    PURPOSE:  Posts a message to all target windows

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
PostToTargets(
    HWND    hwndList,
    UINT    message,
    WPARAM  wparam,
    LPARAM  lparam
    )
{
    INT     TargetCount;
    INT     Index;
    HWND    hwndTarget;
    BOOL    Restarted = FALSE;

RestartPost:
    TargetCount = (INT)SendMessage(hwndList, LB_GETCOUNT, 0, 0);
    if (TargetCount == LB_ERR) {
        return(FALSE);
    }

    for (Index = 0; Index < TargetCount; Index ++) {
        hwndTarget = (HWND)SendMessage(hwndList, LB_GETITEMDATA, Index, 0);
        if ((hwndTarget != INVALID_HANDLE_VALUE) &&
             !PostMessage(hwndTarget, message, wparam, lparam)) {
            if (Restarted) {
                return(FALSE);
            }
            if (!SelectGroupDefinition(GetCurrentGroup(), hwndList, TRUE)) {
                return(FALSE);
            }
            Restarted = TRUE;
            goto RestartPost;
        }
    }

    return(TRUE);
}



/****************************************************************************

    FUNCTION: WindowListDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

****************************************************************************/

INT_PTR
APIENTRY
WindowListDlgProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT  NumberOfWindows = 0;
    INT  counter = 0;
    HWND WindowHandleList[MAX_WINDOWS];
    CHAR string[MAX_STRING_BYTES];

    switch (message) {

    case WM_INITDIALOG:

        if (!WindowListDlgInit(hDlg)) {
            // Failed to initialize dialog, get out
            EndDialog(hDlg, FALSE);
        }

        return (TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDLB_WINDOWLIST:
            switch (HIWORD(wParam)) {

            case LBN_DBLCLK:
                break;  // drop through

            default:
                return(0);
            }

            // drop through on double click ...

        case IDOK:
            NumberOfWindows = WindowListDlgEnd(hDlg, WindowHandleList);

            if (NumberOfWindows > 0)
            {
                while ( counter++ < NumberOfWindows) {

                    //
                    // If the window is already in our list, don't add it
                    //
                    if (FindLBData(hwndList, (DWORD_PTR)WindowHandleList[counter - 1]) >= 0) {
                        continue;
                    }

                    //
                    // Don't add ourselves to the list
                    //
                    if (WindowHandleList[counter - 1] == GetParent(hDlg)) {
                        continue;
                    }

                    //
                    // Add the window to the list
                    //
                    if (GetWindowText(WindowHandleList[counter - 1], string, sizeof(string)) > 0) {

                        if (AddLBItemhwnd(hwndList, string, (LONG_PTR)WindowHandleList[counter - 1]) < 0) {
                        }
                    }
                }
            }

            // We're done, drop through to enddialog...

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            return TRUE;
            break;

        default:
            // We didn't process this message
            return FALSE;
            break;
        }
        break;

    default:
        // We didn't process this message
        return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: WindowListDlgInit(HWND)

    PURPOSE:  Initialise the window list dialog

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
WindowListDlgInit(
    HWND    hDlg
    )
{
    // Fill the list box with top-level windows and their handles
    EnumWindows(WindowListWindowEnum, (LONG_PTR)hDlg);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: WindowListWindowEnum

    PURPOSE:  Window enumeration call-back function.
              Adds each window to the window list-box

    RETURNS:  TRUE to continue enumeration, FALSE to stop.

****************************************************************************/
BOOL
CALLBACK
WindowListWindowEnum(
    HWND    hwnd,
    LPARAM  lParam
    )
{
    HWND    hDlg = (HWND)lParam;
    CHAR    string[MAX_STRING_BYTES];

    //
    // Don't add ourselves to the list
    //

    if (hwnd == hDlg) {
        return(TRUE);
    }

    //
    // Don't add our main window to the list
    //

    if (hwnd == hwndMain) {
        return(TRUE);
    }

    if (GetWindowText(hwnd, string, MAX_STRING_BYTES) != 0) {

        // This window has a caption, so add it to the list-box

        AddLBItem(hDlg, IDLB_WINDOWLIST, string, (LONG_PTR)hwnd);
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: WindowListDlgEnd(HWND, *HWND)

    PURPOSE:  Cleans up after window list dialog

    RETURNS:  Number of window handles the user has selected or NULL

****************************************************************************/
INT
WindowListDlgEnd(
    HWND    hDlg,
    HWND   *WindowList
    )
{
    HWND    hwndListBox = GetDlgItem(hDlg, IDLB_WINDOWLIST);
    HWND    hwndEdit;
    INT     iItem, NumberOfItems;
    INT     SelectedWindows[MAX_WINDOWS];

    NumberOfItems = (INT)SendMessage(hwndListBox, LB_GETSELCOUNT, 0, 0);

    if (SendMessage(hwndListBox, LB_GETSELITEMS, (WPARAM)&NumberOfItems, (LPARAM)SelectedWindows) != NumberOfItems)
    {
        return 0;
    }

    iItem = 0;
    while (iItem++ < NumberOfItems)
    {
        // Read selection from list-box and get its hwnd

        WindowList[iItem-1] = (HWND)SendMessage(hwndListBox, LB_GETITEMDATA, SelectedWindows[iItem - 1], 0);
    }
    return (NumberOfItems);
}



/****************************************************************************

    FUNCTION: AboutDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for About dialog

****************************************************************************/

INT_PTR
APIENTRY
AboutDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    switch (message) {

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:

            // we're done, drop through to quit dialog....

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            return TRUE;
            break;

        default:
            // We didn't process this message
            return FALSE;
            break;
        }
        break;

    default:
        // We didn't process this message
        return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


INT_PTR
APIENTRY
GroupAddDlgProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    char szName[MAX_STRING_BYTES];
    int item;

    switch (msg) {
    case WM_INITDIALOG:
        GroupListInit(GetDlgItem(hDlg, IDCB_GROUPLIST), TRUE);
        SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_SETCURSEL, 0, 0);
        return(TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if (GetDlgItemText(hDlg, IDEF_GROUPNAME, szName, sizeof(szName)) > 0) {
                if (!AddGroupDefinition(szName, hwndList)) {
                    EndDialog(hDlg, 0);
                }
            } else {
                MessageBeep(0);
                return(0);
            }
            EndDialog(hDlg, (INT_PTR)GetCurrentGroup());
            return(0);

        case IDCANCEL:
            EndDialog(hDlg, 0);
            return(0);

        case IDCB_GROUPLIST:
            switch (HIWORD(wParam)) {
            case CBN_SELCHANGE:
                item = (int)SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETCURSEL, 0, 0);
                if (item != CB_ERR) {
                    SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETLBTEXT, item, (LPARAM)szName);
                    SetDlgItemText(hDlg, IDEF_GROUPNAME, szName);
                }
                return(0);
            }
            break;
        }
    }
    return(0);
}



INT_PTR
APIENTRY
GroupDeleteDlgProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    char szName[MAX_STRING_BYTES];
    int item;

    switch (msg) {
    case WM_INITDIALOG:
        GroupListInit(GetDlgItem(hDlg, IDCB_GROUPLIST), TRUE);
        SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_SETCURSEL, 0, 0);
        return(TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if ((item = (int)SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETCURSEL, 0, 0)) != CB_ERR) {
                SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETLBTEXT, item, (LPARAM)szName);
                DeleteGroupDefinition(szName);
            } else {
                MessageBeep(0);
                return(0);
            }
            EndDialog(hDlg, (INT_PTR)szName);
            return(0);

        case IDCANCEL:
            EndDialog(hDlg, 0);
            return(0);
        }
    }
    return(0);
}


INT_PTR
APIENTRY
GroupSelectDlgProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    char szName[MAX_STRING_BYTES];
    int item;

    switch (msg) {
    case WM_INITDIALOG:
        GroupListInit(GetDlgItem(hDlg, IDCB_GROUPLIST), TRUE);
        if (GetCurrentGroup() != NULL) {
            item = (int)SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_FINDSTRING, -1, (LPARAM)(LPSTR)GetCurrentGroup());
            SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_SETCURSEL, item, 0);
        } else {
            SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_SETCURSEL, 0, 0);
        }
        return(TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if ((item = (int)SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETCURSEL, 0, 0)) != CB_ERR) {
                SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETLBTEXT, item, (LPARAM)szName);
                SelectGroupDefinition(szName, hwndList, FALSE);
            } else {
                MessageBeep(0);
                return(0);
            }
            EndDialog(hDlg, (INT_PTR)szName);
            return(0);

        case IDCANCEL:
            EndDialog(hDlg, 0);
            return(0);
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\yapt\yapt.h ===
#include <windows.h>

#define READ          0
#define WRITE         1
#define SEQ           0
#define RAND          1

#define FILE_SIZE     20 * 1024 * 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\exthdr\zexthdr.c ===
#include    <zext.h>
#include    <stddef.h>

int __acrtused = 1;

/***

    The data below must match the structure in ..\ext.h

    Think VERY carefully before you ever change any of this.  We
    currently support using extensions written for previous versions
    of the editor without recompiling.  This means that just about
    ANY change to this data, or it's initialization will break that.

    When adding a new import, consider appending to the table rather
    than replacing one currently in the table.
***/

extern struct cmdDesc     cmdTable;
extern struct swiDesc     swiTable;

EXTTAB ModInfo = {
    VERSION,
    sizeof (struct CallBack),
    &cmdTable,
    &swiTable,
    {   NULL}
};

void
EntryPoint ()
{
    WhenLoaded( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\xerox\xerox.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>

#ifndef RC_INVOKED
#include <port1632.h>
#endif

#include "dlg.h"

typedef PVOID   *PPVOID;

// Resource ids
#define IDM_MAINMENU                    3000
#define IDM_ABOUT                       3001
#define IDM_TARGETADD                   3002
#define IDM_TARGETDELETE                3003
#define IDI_APPICON                     3005
#define IDM_GROUPADD                    3006
#define IDM_GROUPDELETE                 3007
#define IDM_GROUPSELECT                 3008
#define IDR_ACCEL                       3009
#define IDM_GROUPRSTWIN                 3010
#define IDM_GROUPMINWIN                 3011
#define IDM_REFRESHITEMS                3012

// Define the maximum number of selected windows
#define MAX_WINDOWS             255

// Define the maximum length of a resource string
#define MAX_STRING_LENGTH       255
#define MAX_STRING_BYTES        (MAX_STRING_LENGTH + 1)

#ifndef RC_INVOKED
#include "util.h"
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\zextens\filter.c ===
/*** filter.c - Microsoft Editor Filter Extension
*
* Purpose:
*  Provides a new editting function, filter, which replaces its argument with
*  the the argument run through an arbitrary operating system filter program.
*
*   Modifications
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/

#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>			/* prototypes for string fcns	*/
#include "zext.h"


//
//  Prototypes
//
void	 pascal EXTERNAL SetFilter  (char far *);


//
//  Global data
//
PFILE	pFileFilt	= 0;			/* handle for filterfile*/
char	*szNameFilt	= "<filter-file>";	/* name of filter file	*/
char	*szTemp1	= "filter1.tmp";	/* name of 1st temp file*/
char	*szTemp2	= "filter2.tmp";	/* name of 2nd temp file*/
char    filtcmd[BUFLEN] = "";                   /* filter command itself*/




/*** filter - Editor filter extension function
*
* Purpose:
*  Replace seleted text with that text run through an arbitrary filter
*
*  NOARG       - Filter entire current line
*  NULLARG     - Filter current line, from cursor to end of line
*  LINEARG     - Filter range of lines
*  BOXARG      - Filter characters with the selected box
*
*  NUMARG      - Converted to LINEARG before extension is called.
*  MARKARG     - Converted to Appropriate ARG form above before extension is
*		 called.
*
*  STREAMARG   - Treated as BOXARG
*
*  TEXTARG     - Set new filter command
*
* Input:
*  Editor Standard Function Parameters
*
* Output:
*  Returns TRUE on success, file updated, else FALSE.
*
*************************************************************************/
flagType pascal EXTERNAL
filter (
    unsigned int argData,                   /* keystroke invoked with       */
    ARG far      *pArg,                     /* argument data                */
    flagType     fMeta                      /* indicates preceded by meta   */
    )
{
    char    buf[BUFLEN];                    /* buffer for lines             */
    int     cbLineMax;                      /* max lein length in filtered  */
    LINE    cLines;                         /* count of lines in file       */
    LINE    iLineCur;                       /* line being read              */
    PFILE   pFile;                          /* file handle of current file  */

	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)fMeta;

    //
    //  Identify ourselves, get a handle to the current file and discard the
    //  contents of the filter file.
    //
    DoMessage ("FILTER extension");
    pFile = FileNameToHandle ("", "");
    DelFile (pFileFilt);

    //
    // Step 1, based on the argument type, copy the selected region into the
    // (upper left most position of) filter-file.
    //
    // Note that TEXTARG is a special case that allows the user to change the name
    // of the filter command to be used.
    //
    switch (pArg->argType) {
        case NOARG:                         /* filter entire line           */
            CopyLine (pFile,
                      pFileFilt,
                      pArg->arg.noarg.y,
                      pArg->arg.noarg.y,
                      (LINE) 0);
            break;

        case NULLARG:                       /* filter to EOL                */
            CopyStream (pFile,
                        pFileFilt,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y,
                        255,
                        pArg->arg.nullarg.y,
                        (COL) 0,
                        (LINE) 0);
            break;

        case LINEARG:                       /* filter line range            */
            CopyLine (pFile,
                      pFileFilt,
                      pArg->arg.linearg.yStart,
                      pArg->arg.linearg.yEnd,
                      (LINE) 0);
            break;

        case BOXARG:                        /* filter box                   */
            CopyBox (pFile,
                     pFileFilt,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop,
                     pArg->arg.boxarg.xRight,
                     pArg->arg.boxarg.yBottom,
                     (COL) 0,
                     (LINE) 0);
            break;

        case TEXTARG:
            SetFilter (pArg->arg.textarg.pText);
            return 1;
        }

    //
    // Step 2, write the selected text to disk
    //
    if (!FileWrite (szTemp1, pFileFilt)) {
        DoMessage("FILTER: ** Error writing temporary file **");
        return 0;
    }

    //
    // Step 3, create the command to be executed:
    //   user specified filter command + " " + tempname 1 + " >" + tempname 2
    // Then perform the filter operation on that file, creating a second temp file.
    //
    strcpy (buf,filtcmd);
    strcat (buf," ");
    strcat (buf,szTemp1);
    strcat (buf," >");
    strcat (buf,szTemp2);

    if (!DoSpawn (buf, FALSE)) {
        DoMessage("FILTER: ** Error executing filter **");
        return 0;
    }

    //
    // Step 4, delete the contents of the filter-file, and replace it by reading
    // in the contents of that second temp file.
    //
    DelFile (pFileFilt);

    if (!FileRead (szTemp2, pFileFilt)) {
        DoMessage("FILTER: ** Error reading temporary file **");
        return 0;
    }

    //
    // Step 5, calculate the maximum width of the data we got back from the
    // filter. Then, based again on the type of region selected by the user,
    // DISCARD the users select region, and copy in the contents of the filter
    // file in an equivelant type.
    //
    cLines = FileLength (pFileFilt);
    cbLineMax = 0;
    for (iLineCur = 0; iLineCur < cLines; iLineCur++) {
        cbLineMax = max (cbLineMax, GetLine (iLineCur, buf, pFileFilt));
    }

    switch (pArg->argType) {
        case NOARG:                         /* filter entire line           */
            DelLine  (pFile,
                      pArg->arg.noarg.y,
                      pArg->arg.noarg.y);
            CopyLine (pFileFilt,
                      pFile,
                      (LINE) 0,
                      (LINE) 0,
                      pArg->arg.noarg.y);
            break;

        case NULLARG:                       /* filter to EOL                */
            DelStream  (pFile,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y,
                        255,
                        pArg->arg.nullarg.y);
            CopyStream (pFileFilt,
                        pFile,
                        (COL) 0,
                        (LINE) 0,
                        cbLineMax,
                        (LINE) 0,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y);
            break;

        case LINEARG:                       /* filter line range            */
            DelLine  (pFile,
                      pArg->arg.linearg.yStart,
                      pArg->arg.linearg.yEnd);
            CopyLine (pFileFilt,
                      pFile,
                      (LINE) 0,
                      cLines-1,
                      pArg->arg.linearg.yStart);
            break;

        case BOXARG:                        /* filter box                   */
            DelBox  (pFile,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop,
                     pArg->arg.boxarg.xRight,
                     pArg->arg.boxarg.yBottom);
            CopyBox (pFileFilt,
                     pFile,
                     (COL) 0,
                     (LINE) 0,
                     cbLineMax-1,
                     cLines-1,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop);
            break;
    }

    //
    // Clean-up: delete the temporary files we've created
    //
    strcpy (buf, "DEL ");
    strcat (buf, szTemp1);
    DoSpawn (buf, FALSE);
    strcpy (buf+4, szTemp2);
    DoSpawn (buf, FALSE);

    return 1;
}



/*** SetFilter - Set filter command to be used
*
* Purpose:
*  Save the passed string paramater as the filter command to be used by the
*  filter function. Called either because the "filtcmd:" switch has been
*  set, or because the filter command recieved a TEXTARG.
*
* Input:
*  szCmd	= Pointer to asciiz filter command
*
* Output:
*  Returns nothing. Command saved
*
*************************************************************************/
void pascal EXTERNAL
SetFilter (
    char far *szCmd
    )
{
    strcpy (filtcmd,szCmd);
}


void
filterWhenLoaded (
    void
    )
{
    pFileFilt = FileNameToHandle (szNameFilt,szNameFilt);
    if (!pFileFilt) {
        pFileFilt = AddFile(szNameFilt);
        FileRead (szNameFilt, pFileFilt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\zextens\init.c ===
/*** filter.c - Microsoft Editor Filter Extension
*
* Purpose:
*  Provides a new editting function, filter, which replaces its argument with
*  the the argument run through an arbitrary operating system filter program.
*
*   Modifications
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/
#define EXT_ID  " Z Extensions 1.00 "##__DATE__##" "##__TIME__

#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>			/* prototypes for string fcns	*/
#include "zext.h"

void     pascal          id                 (char *);
void     pascal EXTERNAL SetFilter          (char far *);
flagType pascal EXTERNAL filter             (CMDDATA, ARG far *, flagType);
void     pascal          filterWhenLoaded   (void);

flagType pascal EXTERNAL justify            (CMDDATA, ARG far *, flagType);
void     pascal          justifyWhenLoaded  (void);

flagType pascal EXTERNAL StartExt           (CMDDATA, ARG far *, flagType);
flagType pascal EXTERNAL Case               (CMDDATA, ARG far *, flagType);
flagType pascal EXTERNAL ShowBuildMessage   (CMDDATA, ARG far *, flagType);
flagType pascal EXTERNAL SlmOut             (CMDDATA, ARG far *, flagType);
void     pascal          partyWhenLoaded    (void);

flagType pascal EXTERNAL PMatch             (CMDDATA, ARG far *, flagType);
void     pascal          PMatchWhenLoaded   (void);

flagType pascal EXTERNAL tglcase            (CMDDATA, ARG far *, flagType);
void     pascal          tglcaseWhenLoaded  (void);

flagType pascal EXTERNAL ucase              (CMDDATA, ARG far *, flagType);
flagType pascal EXTERNAL lcase              (CMDDATA, ARG far *, flagType);
void     pascal          ulcaseWhenLoaded   (void);

flagType pascal EXTERNAL wincopy            (CMDDATA, ARG far *, flagType);
flagType pascal EXTERNAL wincut             (CMDDATA, ARG far *, flagType);
flagType pascal EXTERNAL windel             (CMDDATA, ARG far *, flagType);
flagType pascal EXTERNAL winpaste           (CMDDATA, ARG far *, flagType);
void     pascal          winclipWhenLoaded  (void);

extern flagType just2space;
extern int      justwidth;
extern flagType iconizeOnExit;


/*** WhenLoaded - Extension Initialization
*
* Purpose:
*  Executed when extension gets loaded. Identify self, create <filter-file>,
*  and assign default keystroke.
*
* Input:
*  none
*
* Output:
*  Returns nothing. Initializes various data.
*
*************************************************************************/
void EXTERNAL
WhenLoaded (
    void
    )
{
    filterWhenLoaded();
    justifyWhenLoaded();
    partyWhenLoaded();
    PMatchWhenLoaded();
    tglcaseWhenLoaded();
    ulcaseWhenLoaded();
    winclipWhenLoaded();
    id ("ZEXTENS: ");
}



/*** id - identify extension
*
* Purpose:
*  identify ourselves, along with any passed informative message.
*
* Input:
*  pszMsg	= Pointer to asciiz message, to which the extension name
*		  and version are appended prior to display.
*
* Output:
*  Returns nothing. Message displayed.
*
*************************************************************************/
void pascal id (
    char *pszFcn                                    /* function name        */
    )
{
    char    buf[BUFLEN];                            /* message buffer       */

    strcpy (buf,pszFcn);
    strcat (buf,EXT_ID);
    DoMessage (buf);
}





//
//  Switch communication table to the editor
//
struct swiDesc	swiTable[] = {
    {"filtcmd",       (PIF)SetFilter,         SWI_SPECIAL},
    {"just2space",    toPIF(just2space),      SWI_BOOLEAN},
    {"justwidth",     toPIF(justwidth),       SWI_NUMERIC | RADIX10},
    {"iconizeonexit", toPIF(iconizeOnExit),   SWI_BOOLEAN},
    {0, 0, 0}
    };


//
//  Command communiation table to the editor
//
struct cmdDesc	cmdTable[] = {
    {"filter",      filter,     0, KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG | MARKARG | NUMARG | TEXTARG | MODIFIES},
    {"justify",     justify,    0, MODIFIES | NOARG | NULLARG | LINEARG | BOXARG | TEXTARG },
    {"startext",    StartExt,   0,      NOARG   },
    {"MapCase",     Case,       0, NOARG | NULLARG | LINEARG | BOXARG | NUMARG },
    {"BuildMessage",ShowBuildMessage, 0, NOARG | NULLARG | TEXTARG },
    {"SlmOut",      SlmOut,     0, NOARG | NULLARG | TEXTARG },
    {"pmatch",      PMatch,     0, CURSORFUNC },
    {"tglcase",     tglcase,    0, KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG | MARKARG | NUMARG | MODIFIES},
    {"ucase",       ucase,      0, MODIFIES | KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG },
    {"lcase",       lcase,      0, MODIFIES | KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG },
    {"wincopy",     wincopy,    0, KEEPMETA | NOARG  | BOXARG | LINEARG | STREAMARG | MARKARG | NULLEOL | NUMARG },
    {"wincut",      wincut,     0, NOARG  | BOXARG | LINEARG | STREAMARG | MARKARG | NULLEOL | NUMARG | MODIFIES},
    {"windel",      windel,     0, NOARG  | BOXARG | LINEARG | STREAMARG | NULLARG | MODIFIES},
    {"winpaste",    winpaste,   0, KEEPMETA | NOARG  | BOXARG | LINEARG | STREAMARG | TEXTARG | MODIFIES},
    {0, 0, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\yapt\yapt.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    yapt.c

Abstract:

    This module contains the code for the Yet Another Performance Tool utility.

Author:

    Chuck Park (chuckp) 07-Oct-1994

Revision History:


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <assert.h>

#include "yapt.h"


//
// Test proc. declarations
//

BOOLEAN
ReadSequential(
    ULONG Iterations
    );

BOOLEAN
WriteSequential(
    ULONG Iterations
    );

BOOLEAN
ReadRandom(
    ULONG Iterations
    );

BOOLEAN
WriteRandom(
    ULONG Iterations
    );

//
// Common util. functions
//

BOOLEAN
CreateTestFile(
    );

ULONG
GetRandomOffset(
    ULONG    min,
    ULONG    max
    );


BOOL
GetSectorSize(
    PDWORD SectorSize,
    PCHAR  DrvLetter
    );

VOID
LogError(
    PCHAR ErrString,
    DWORD UniqueId,
    DWORD ErrCode
    );

BOOLEAN
ParseCmdLine(
    INT Argc,
    CHAR *Argv[]
    );

BOOLEAN
ValidateOption(
    CHAR Switch,
    CHAR *Value
    );

VOID
VerifyFileName(
    IN CHAR *FileName
    );

VOID
Usage(
    VOID
    );

VOID
__cdecl
Log(
    ULONG LogLevel,
    PCHAR String,
    ...
    );

DWORD
YaptSetFileCompression(
    IN HANDLE FileHandle,
    IN USHORT CompressionFormat
    );

//
// Default parameters
//

#define DEFAULT_BUFFER_SIZE 65536
#define DEFAULT_FILE_SIZE   (20*1024*1024);

ULONG  SectorSize = 512;
ULONG  BufferSize = DEFAULT_BUFFER_SIZE;
ULONG  FileSize   = DEFAULT_FILE_SIZE;
UCHAR FileName[MAX_PATH] = "test.dat";
UCHAR  Test       = READ;
UCHAR  Access     = SEQ;
ULONG  Verbose    = 0;
ULONG  Iterations = 10;
UCHAR  ReuseFile  = TRUE;
UCHAR  Yes        = FALSE;
BOOLEAN ReadOnly  = FALSE;


INT
_cdecl main (
    INT Argc,
    CHAR *Argv[]
    )
{
    UCHAR testCase;

    //
    // Parse cmd line
    //

    if (!ParseCmdLine(Argc,Argv)) {
        return 1;
    }

    //
    // Create the test file
    //

    if (!CreateTestFile()) {
        return 2;
    }

    //
    // Call appropriate test routine.
    //

    testCase = (Test << 1) | Access;
    switch (testCase) {
        case 0:

           if (!ReadSequential(Iterations)) {
               return 3;
           }
            break;

        case 1:

            //
            // Read random
            //

            if (!ReadRandom(Iterations)) {
                return 3;
            }

            break;

        case 2:

            if (!WriteSequential(Iterations)) {
                return 3;
            }

            break;

        case 3:

            //
            // Write random
            //

            if (!WriteRandom(Iterations)) {
                return 3;
            }

            break;

        default:
            printf("Invalid test case\n");
            return 3;
    }



    return 0;

}

BOOLEAN
CreateTestFile(
    VOID
    )
{
    PUCHAR     buffer;
    HANDLE     port = INVALID_HANDLE_VALUE;
    HANDLE     fileHandle;
    OVERLAPPED overlapped,*overlapped2;
    DWORD      bytesTransferred,bytesTransferred2;
    DWORD_PTR  key;
    ULONG      numberWrites;
    BOOL       status;
    ULONG      i;

    DWORD      currentSize;

    buffer = VirtualAlloc(NULL,
                          DEFAULT_BUFFER_SIZE,
                          MEM_COMMIT,
                          PAGE_READWRITE);

    if ( !buffer ) {
        printf("Error allocating buffer %x\n",GetLastError());
        return FALSE;
    }

    if(ReuseFile) {

        fileHandle = CreateFile(FileName,
                                ReadOnly ? GENERIC_READ :
                                           (GENERIC_READ | GENERIC_WRITE),
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                                NULL);



        if(fileHandle != INVALID_HANDLE_VALUE) {

            Log(1, "Using existing test file %s\n", FileName);
            goto InitializeTestFile;

        } else {

            Log(1, "Error %d opening existing test file\n", GetLastError());
        }

    } else {

        DeleteFile(FileName);

    }

    fileHandle = CreateFile(FileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                            NULL);

InitializeTestFile:

    if ( fileHandle == INVALID_HANDLE_VALUE ) {
        printf("Error opening file %s %d\n",FileName,GetLastError());
        return FALSE;
    }

    currentSize = GetFileSize(fileHandle, NULL);

    if(currentSize >= FileSize) {

        goto EndCreateTestFile;

    } else if(ReadOnly) {

        FileSize = currentSize;
        goto EndCreateTestFile;
    }

    //
    // Uncompress the file - compressed files will always do cached I/O even
    // if you tell them not to.  If this fails assume it's because the
    // underlying file system doesn't handle compression.
    //

    Log(1, "Trying to decompress %s\n", FileName);

    YaptSetFileCompression(fileHandle, COMPRESSION_FORMAT_NONE);

    port = CreateIoCompletionPort(fileHandle,
                                  NULL,
                                  (DWORD_PTR)fileHandle,
                                  0);
    if ( !port ) {
        printf("Error creating completion port %d\n",GetLastError());
        return FALSE;
    }

    Log(1,"Creating test file %s",FileName);

    memset(&overlapped, 0, sizeof(overlapped));

    numberWrites = FileSize / BufferSize;

    for (i = 0; i < numberWrites; i++) {

retryWrite:
        status = WriteFile(fileHandle,
                           buffer,
                           BufferSize,
                           &bytesTransferred,
                           &overlapped);

        if ( !status && GetLastError() != ERROR_IO_PENDING ) {
            if (GetLastError() == ERROR_INVALID_USER_BUFFER ||
                GetLastError() == ERROR_NOT_ENOUGH_QUOTA  ||
                GetLastError() == ERROR_WORKING_SET_QUOTA ||
                GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {

                goto retryWrite;
            }
            printf("Error creating test file %x\n",GetLastError());
            return FALSE;
        }

        Log(2,".");
        overlapped.Offset += BufferSize;
    }

    for (i = 0; i < numberWrites; i++ ) {
        status = GetQueuedCompletionStatus(port,
                                           &bytesTransferred2,
                                           &key,
                                           &overlapped2,
                                           (DWORD)-1);
        if ( !status ) {
            printf("Error on completion during test file create %x\n",GetLastError());
            return FALSE;
        }
    }

    Log(1,".. Complete.\n\n");

EndCreateTestFile:

    if(port != INVALID_HANDLE_VALUE) CloseHandle(port);
    if(fileHandle != INVALID_HANDLE_VALUE) CloseHandle(fileHandle);

    VirtualFree(buffer,
                DEFAULT_BUFFER_SIZE,
                MEM_DECOMMIT);

    return TRUE;
}


BOOLEAN
ReadSequential(
    ULONG Iterations
    )
{
    ULONG      j,
               outstandingRequests,
               remaining = Iterations;
    ULONG      start,end;
    DOUBLE     testTime,thruPut = 0.0,seconds = 0;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesRead,
               bytesRead2,
               errCode,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;


    printf("Starting Sequential Reads of %d Meg file, using %d K I/O size\n", FileSize / 1024*1024, BufferSize / 1024);

    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        Log(0,"Error allocating buffer: %x\n",GetLastError());
        return FALSE;
    }

    file = CreateFile(FileName,
                      ReadOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE),
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        Log(0,"Error opening Target file: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        Log(0,"Error creating completion port: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    while (remaining--) {

        start = GetTickCount();

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

        for (j = 0; j < FileSize / BufferSize; j++) {
            do {

                status = ReadFile(file,
                                  buffer,
                                  BufferSize,
                                  &bytesRead,
                                  &overlapped);

                errCode = GetLastError();

                if (!status) {
                    if (errCode == ERROR_IO_PENDING) {
                        break;
                    } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                               errCode == ERROR_INVALID_USER_BUFFER ||
                               errCode == ERROR_WORKING_SET_QUOTA ||
                               errCode == ERROR_NOT_ENOUGH_MEMORY) {
                        //
                        // Allow this to retry.
                        //

                    } else {
                        Log(0,"Error in ReadFile: %x\n",errCode);
                        VirtualFree(buffer,
                                    BufferSize + SectorSize - 1,
                                    MEM_DECOMMIT);
                        return FALSE;
                    }

                }

            } while (!status);

            outstandingRequests++;
            overlapped.Offset += BufferSize;
        }

        for (j = 0; j < outstandingRequests; j++) {

            status = GetQueuedCompletionStatus(port,
                                               &bytesRead2,
                                               &completionKey,
                                               &overlapped2,
                                               (DWORD)-1);

            if (!status) {
                Log(0,"GetQueuedCompletionStatus error: %x\n",GetLastError());
                VirtualFree(buffer,
                            BufferSize + SectorSize - 1,
                            MEM_DECOMMIT);
                return FALSE;
            }

        }

        end = GetTickCount();
        testTime = end - start;
        testTime /= 1000.0;
        seconds += testTime;
        Log(1,"Iteration %2d -> %4.3f MB/S\n",Iterations - remaining,(FileSize / testTime)/(1024*1024));
    }

    CloseHandle(port);
    CloseHandle(file);

    thruPut = FileSize * Iterations / seconds;
    printf("\nAverage Throughput %4.3f MB/S\n",thruPut/(1024*1024));

    VirtualFree(buffer,
                BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    return TRUE;
}


BOOLEAN
ReadRandom(
    ULONG Iterations
    )
{
    ULONG      j,
               outstandingRequests,
               remaining = Iterations;
    ULONG      start,end;
    DOUBLE     testTime,thruPut = 0.0,seconds = 0;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesRead,
               bytesRead2,
               errCode,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;

    ULONG      min = FileSize,max = 0;


    printf("Starting Random Reads of %d Meg file, using %d K I/O size\n", FileSize / 1024*1024, BufferSize / 1024);

    version = GetVersion() >> 16;
    srand((unsigned)time(NULL));

    buffer = VirtualAlloc(NULL,
                          BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        Log(0,"Error allocating buffer: %x\n",GetLastError());
        return FALSE;
    }

    file = CreateFile(FileName,
                      ReadOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE),
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        Log(0,"Error opening Target file: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        Log(0,"Error creating completion port: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    while (remaining--) {

        start = GetTickCount();

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

        for (j = 0; j < FileSize / BufferSize; j++) {
            do {

                status = ReadFile(file,
                                  buffer,
                                  BufferSize,
                                  &bytesRead,
                                  &overlapped);

                errCode = GetLastError();

                if (!status) {
                    if (errCode == ERROR_IO_PENDING) {
                        break;
                    } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                               errCode == ERROR_INVALID_USER_BUFFER ||
                               errCode == ERROR_WORKING_SET_QUOTA ||
                               errCode == ERROR_NOT_ENOUGH_MEMORY) {
                        //
                        // Allow this to retry.
                        //

                    } else {
                        Log(0,"Error in ReadFile: %x\n",errCode);
                        VirtualFree(buffer,
                                    BufferSize + SectorSize - 1,
                                    MEM_DECOMMIT);
                        return FALSE;
                    }

                }

            } while (!status);

            outstandingRequests++;
            overlapped.Offset = GetRandomOffset(0,FileSize - BufferSize);
            if (overlapped.Offset > max) {
                max = overlapped.Offset;
            }
            if (overlapped.Offset < min) {
                min = overlapped.Offset;
            }
        }

        for (j = 0; j < outstandingRequests; j++) {

            status = GetQueuedCompletionStatus(port,
                                               &bytesRead2,
                                               &completionKey,
                                               &overlapped2,
                                               (DWORD)-1);

            if (!status) {
                Log(0,"GetQueuedCompletionStatus error: %x\n",GetLastError());
                VirtualFree(buffer,
                            BufferSize + SectorSize - 1,
                            MEM_DECOMMIT);
                return FALSE;
            }

        }

        end = GetTickCount();
        testTime = end - start;
        testTime /= 1000.0;
        seconds += testTime;
        Log(1,"Iteration %2d -> %4.3f MB/S\n",Iterations - remaining,(FileSize / testTime)/(1024*1024));

    }

    CloseHandle(port);
    CloseHandle(file);

    thruPut = FileSize * Iterations / seconds;
    printf("\nAverage Throughput %4.3f MB/S\n",thruPut/(1024*1024));
    Log(2,"Min = %Lu, Max = %Lu, FileSize = %Lu\n",min,max,FileSize);

    VirtualFree(buffer,
                BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    return TRUE;
}


BOOLEAN
WriteSequential(
    ULONG Iterations
    )
{
    ULONG      j,
               outstandingRequests,
               remaining = Iterations;
    ULONG      start,end;
    DOUBLE     testTime,thruPut = 0.0,seconds = 0;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesWritten,
               bytesWritten2,
               errCode,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;


    if(ReadOnly) {
        printf("Can't run write tests on a read only file\n");
        return FALSE;
    }

    printf("Starting Sequential Writes of %d Meg file, using %d K I/O size\n", FileSize / 1024*1024, BufferSize / 1024);

    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        Log(0,"Error allocating buffer: %x\n",GetLastError());
        return FALSE;
    }

    file = CreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        Log(0,"Error opening Target file: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        Log(0,"Error creating completion port: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    while (remaining--) {

        start = GetTickCount();

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

        for (j = 0; j < FileSize / BufferSize; j++) {
            do {

                status = WriteFile(file,
                                  buffer,
                                  BufferSize,
                                  &bytesWritten,
                                  &overlapped);

                errCode = GetLastError();

                if (!status) {
                    if (errCode == ERROR_IO_PENDING) {
                        break;
                    } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                               errCode == ERROR_INVALID_USER_BUFFER ||
                               errCode == ERROR_WORKING_SET_QUOTA ||
                               errCode == ERROR_NOT_ENOUGH_MEMORY) {
                        //
                        // Allow this to retry.
                        //

                    } else {
                        Log(0,"Error in WriteFile: %x\n",errCode);
                        VirtualFree(buffer,
                                    BufferSize + SectorSize - 1,
                                    MEM_DECOMMIT);
                        return FALSE;
                    }

                }

            } while (!status);

            outstandingRequests++;
            overlapped.Offset += BufferSize;
        }

        for (j = 0; j < outstandingRequests; j++) {

            status = GetQueuedCompletionStatus(port,
                                               &bytesWritten2,
                                               &completionKey,
                                               &overlapped2,
                                               (DWORD)-1);

            if (!status) {
                Log(0,"GetQueuedCompletionStatus error: %x\n",GetLastError());
                VirtualFree(buffer,
                            BufferSize + SectorSize - 1,
                            MEM_DECOMMIT);
                return FALSE;
            }

        }

        end = GetTickCount();
        testTime = end - start;
        testTime /= 1000.0;
        seconds += testTime;
        Log(1,"Iteration %2d -> %4.3f MB/S\n",Iterations - remaining,(FileSize / testTime)/(1024*1024));

    }

    CloseHandle(port);
    CloseHandle(file);

    thruPut = FileSize * Iterations / seconds;
    printf("\nAverage Throughput %4.3f MB/S\n",thruPut/(1024*1024));

    VirtualFree(buffer,
                BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    return TRUE;
}


BOOLEAN
WriteRandom(
    ULONG Iterations
    )
{
    ULONG      j,
               outstandingRequests,
               remaining = Iterations;
    ULONG      start,end;
    DOUBLE     testTime,thruPut = 0.0,seconds = 0;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesWritten,
               bytesWritten2,
               errCode,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;
    ULONG      min = FileSize,max = 0;

    if(ReadOnly) {
        printf("Can't run write tests on a read only file\n");
        return FALSE;
    }

    printf("Starting Random Writes of %d Meg file, using %d K I/O size\n", FileSize / 1024*1024, BufferSize / 1024);

    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        Log(0,"Error allocating buffer: %x\n",GetLastError());
        return FALSE;
    }

    file = CreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        Log(0,"Error opening Target file: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        Log(0,"Error creating completion port: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    while (remaining--) {

        start = GetTickCount();

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

        for (j = 0; j < FileSize / BufferSize; j++) {
            do {

                status = WriteFile(file,
                                  buffer,
                                  BufferSize,
                                  &bytesWritten,
                                  &overlapped);

                errCode = GetLastError();

                if (!status) {
                    if (errCode == ERROR_IO_PENDING) {
                        break;
                    } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                               errCode == ERROR_INVALID_USER_BUFFER ||
                               errCode == ERROR_WORKING_SET_QUOTA ||
                               errCode == ERROR_NOT_ENOUGH_MEMORY) {
                        //
                        // Allow this to retry.
                        //

                    } else {
                        Log(0,"Error in WriteFile: %x\n",errCode);
                        VirtualFree(buffer,
                                    BufferSize + SectorSize - 1,
                                    MEM_DECOMMIT);
                        return FALSE;
                    }

                }

            } while (!status);

            outstandingRequests++;
            overlapped.Offset = GetRandomOffset(0,FileSize - BufferSize);
            if (overlapped.Offset > max) {
                max = overlapped.Offset;
            }
            if (overlapped.Offset < min) {
                min = overlapped.Offset;
            }
        }

        for (j = 0; j < outstandingRequests; j++) {

            status = GetQueuedCompletionStatus(port,
                                               &bytesWritten2,
                                               &completionKey,
                                               &overlapped2,
                                               (DWORD)-1);

            if (!status) {
                Log(0,"GetQueuedCompletionStatus error: %x\n",GetLastError());
                VirtualFree(buffer,
                            BufferSize + SectorSize - 1,
                            MEM_DECOMMIT);
                return FALSE;
            }

        }

        end = GetTickCount();
        testTime = end - start;
        testTime /= 1000.0;
        seconds += testTime;
        Log(1,"Iteration %2d -> %4.3f MB/S\n",Iterations - remaining,(FileSize / testTime)/(1024*1024));

    }

    CloseHandle(port);
    CloseHandle(file);

    thruPut = FileSize * Iterations / seconds;
    printf("\nAverage Throughput %4.3f MB/S\n",thruPut/(1024*1024));
    Log(2,"Min = %Lu, Max = %Lu, FileSize = %Lu\n",min,max,FileSize);

    VirtualFree(buffer,
                BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    return TRUE;
}


ULONG
GetRandomOffset(
    ULONG    min,
    ULONG    max
    )
{

    INT base = rand();
    ULONG retval = ((max - min) / RAND_MAX) * base;
    retval += SectorSize - 1;
    retval &= ~(SectorSize - 1);
    if (retval < min) {
        return min;
    } else if (retval > max ){
        return max & ~(SectorSize - 1);
    } else{
        return retval;
    }

}

BOOLEAN
ParseCmdLine(
    INT Argc,
    CHAR *Argv[]
    )
{

    INT i;
    CHAR *switches = " ,-";
    CHAR swtch,*value,*str;
    BOOLEAN gotSwitch = FALSE;


    if (Argc <= 1) {

        //
        // Using defaults
        //

        return TRUE;
    }

    for (i = 1; i < Argc; i++) {
        str = Argv[i];
        value = strtok(str, switches);
        if (gotSwitch) {
            if (!ValidateOption(swtch,value)) {
                Usage();
                return FALSE;
            } else {
                gotSwitch = FALSE;
            }
        } else {
            gotSwitch = TRUE;
            swtch = value[0];
            if (value[1] || swtch == '?') {
                Usage();
                return FALSE;
            }
        }
    }
    if (gotSwitch) {

        Usage();
        return FALSE;
    } else {
        return TRUE;
    }

}

BOOLEAN
ValidateOption(
    CHAR Switch,
    CHAR *Value
    )
{
    Switch = (CHAR)toupper(Switch);
    switch (Switch) {

        case 'F':

            VerifyFileName(Value);
            strcpy(FileName,Value);
            break;

        case 'T':
            if (_stricmp(Value,"READ")==0) {
                Test = READ;
            } else if (_stricmp(Value,"WRITE")==0) {
                Test = WRITE;
            } else {
                return FALSE;
            }

            break;

        case 'A':

            if (_strnicmp(Value,"SEQ",3)==0) {
                Access = SEQ;
            } else if (_strnicmp(Value,"RAND",4)==0) {
                Access = RAND;
            } else {
                return FALSE;
            }

            break;

        case 'B':
            BufferSize = atol(Value);

            //
            // TODO:Adjust buffersize to multiple of a sector and #of K.
            //

            BufferSize *= 1024;
            break;

        case 'S':

            FileSize = atol(Value);

            //
            // TODO: Adjust filesize to multiple of buffersize and #of Meg.
            //

            FileSize *= 1024*1024;
            break;

        case 'V':

            Verbose = atol(Value);
            break;

        case 'I':

            Iterations = atol(Value);
            break;

        case 'R':

            if(tolower(Value[0]) == 'y') {
                ReuseFile = TRUE;
            } else {
                ReuseFile = FALSE;
            }

            break;

        case 'O':

            if(tolower(Value[0]) == 'y') {
                ReadOnly = TRUE;
            } else {
                ReadOnly = FALSE;
            }

            break;

        default:
            return FALSE;
    }
    return TRUE;
}

VOID
Usage(
    VOID
    )
{

    fprintf(stderr,"usage: YAPT (Yet another performance tool)\n"
            "               -f [filename]\n"
            "               -t [Test:Read,Write]\n"
            "               -a [Access Mode:Seq or Random]\n"
            "               -b [buffer size in KB]\n"
            "               -s [filesize]\n"
            "               -i [Iterations]\n"
            "               -v [Verbosity: 0-2]\n"
            "               -r [Reuse test file: yes, no]\n"
            "               -o [Read Only: yes, no]\n"
           );
}

VOID
__cdecl
Log(
    ULONG LogLevel,
    PCHAR String,
    ...
    )
{

    CHAR Buffer[256];

    va_list argp;
    va_start(argp, String);

    if (LogLevel <= Verbose) {
        vsprintf(Buffer, String, argp);
        printf("%s",Buffer);
    }

    va_end(argp);
}

DWORD
YaptSetFileCompression(
    IN HANDLE FileHandle,
    IN USHORT CompressionFormat
    )

{
    DWORD bytesReturned;

    assert(FileHandle != INVALID_HANDLE_VALUE);

    if(!DeviceIoControl(
            FileHandle,
            FSCTL_SET_COMPRESSION,
            &CompressionFormat,
            sizeof(CompressionFormat),
            NULL,
            0,
            &bytesReturned,
            NULL)) {

    }

    return GetLastError();
}

VOID
VerifyFileName(
    IN CHAR *FileName
    )

{
    CHAR input[32];

    if(Yes) return;

    if(((FileName[0] == '\\') || (FileName[0] == '/')) &&
       ((FileName[1] == '\\') || (FileName[1] == '/')) &&
       ((FileName[2] == '.')  || (FileName[2] == '?')) &&
       ((FileName[3] == '\\') || (FileName[3] == '/'))) {

        printf("\n\t%s looks like a raw device\n"
               "\tdo you want to continue?  ", FileName);

        fflush(stdout);

        if(fgets(input, 32, stdin) == NULL) {

            printf("\nQuitting\n");
            exit(-1);
        }

        if(tolower(input[0]) != 'y') {

            printf("\nNegative response - quitting\n");
            exit(-1);
        }

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ync\ync.c ===
#include "string.h"

#include <stdio.h>
#include <conio.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

/*  YNC is a Yes No Cancel program
 *  ===============================================================================
 *  Usage: ync [/c choices] text ...
 *
 *  "choices" is a string of characters, default "ync".
 *  YNC echos its text parameters and the text " [choices]" and waits for the
 *  user to type one of the choices.  When one of the choices is typed, the
 *  index of the choice is returned.
 *
 *  Rtns -1 if no parameters specified or /c but no choices or CONTROL-C input.
 *
 *  Beeps on all other input.
 *
 *  Good for use in make batch files.cd \lib
 *
 *      ync your query?
 *      if errorlevel 2 goto cancel
 *      if errorlevel 1 goto no
 *      :yes
 *      ...
 *      goto continue
 *      :no
 *      ...
 *      goto continue
 *      :cancel
 *      ...
 *      :continue
 *
 *  or
 *      ync /c acr abort cancel, retry
 *      ync /c acr "abort cancel, retry"
 */

#define BEL   0x07
#define LF    0x0a
#define CR    0x0d
#define CTRLC 0x03
char *strYNC = "ync";

// Forward Function Declarations...
void chkusage( int );

void chkusage(argc)
int argc;
{
    if (!argc) {
        printf("Usage: ync [/c choices] text ...\n");
        exit (-1);
        }
}

__cdecl main(argc, argv)
int argc;
char *argv[];
{
    char ch;
    char *s;
    char *pChoices = strYNC;

    ConvertAppToOem( argc, argv );
    SHIFT(argc, argv)
    chkusage(argc);
    while (argc) {
        s = argv[0];
        if (fSwitChr(*s++)) {
            if (*s == 'c' || *s == 'C') {
                SHIFT(argc, argv);
                chkusage(argc);
                pChoices = argv[0];
                }
            else
                printf("ync: invalid switch - %s\n", argv[0]);
            }
        else {
            _cputs(*argv);
            _putch(' ');
            }
        SHIFT(argc, argv);
    }

    _putch('[');
    _cputs(pChoices);
    _putch(']');
    while (!(s = strchr(pChoices, ch = (char)_getch()))) {
        if (ch == CTRLC) {
            exit(-1);
        } else {
            _putch(BEL);
        }
    }

    _putch(ch);
    _putch(LF);
    _putch(CR);

    return( (int)(s - pChoices) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\zextens\justify.c ===
/*
** Justify Z extension
**
** History:
**	12-Sep-1988 mz	Made WhenLoaded match declaration
**	01-Sep-1988	Corrected hang when flush-justifying a line with no
**			spaces.
**	14-Aug-1988	Corrected right-justification on non-column-1 based
**			lines. Corrected justification over multiple
**			paragraphs.
**	30-Mar-1988	Extracted from "myext".
**
*/
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "zext.h"

#ifndef TRUE
    #define TRUE	-1
    #define FALSE	0
#endif

void        pascal near DumpLine (char far *, PFILE, COL, COL, LINE, char far *, int);
int     pascal near NextLine (char far *, PFILE, LINE, LINE far *, int far *);
flagType    pascal near isterm (char);
void        pascal near _stat (char *);

flagType just2space = TRUE;
int justwidth   = 79;

/*************************************************************************
**
** justify
** justify paragraph(s)
**
** NOARG:	Justify between columns 0 and 78, from the current line to
**		blank line.
** NULLARG:	Justify between current column and 78, from the current line to
**		blank line.
** LINEARG:	Justify between current column and 78, the specified lines.
** "STREAMARG": Justify between specified columns from current line to blank.
**		(handled by boxarg)
** BOXARG:	justify between specified columns the specified rows
** TEXTARG:	Justify between columns 0 and 78, from the current line to
**		blank line, prepending each resulting line with the textarg.
*/
flagType pascal EXTERNAL
justify (
        CMDDATA  argData,
        ARG far  *pArg,
        flagType fMeta
        )
{
    int cbLine;             /* length of line just read	*/
    char    inbuf[BUFLEN];                  /* input buffer                 */
    PFILE   pFile;              /* file handle			*/
    char far *pText;            /* pointer to prepending text	*/
    COL x1;             /* justify to left column	*/
    COL x2;             /* justify to right columne	*/
    LINE    y1;             /* start line			*/
    LINE    y2;             /* end line			*/
    LINE    yOut;               /* output line			*/

    //
    //	Unreferenced parameters
    //
    (void)argData;

    switch (pArg->argType) {

        case NOARG:                 /* justify paragraph	*/
            x1 = 0;                 /* between cols 0...	*/
            x2 = justwidth;             /*	...and 79	*/
            y1 = pArg->arg.noarg.y;         /* current line...	*/
            y2 = -1;                /*	...to blank line*/
            pText = 0;              /* there is no text	*/
            break;

        case NULLARG:               /* justify indented	*/
            x1 = pArg->arg.nullarg.x;       /* between cur col...	*/
            x2 = justwidth;             /*	...and 79	*/
            y1 = pArg->arg.nullarg.y;       /* current line...	*/
            y2 = -1;                /*	...to blank line*/
            pText = 0;              /* there is no text	*/
            break;

        case LINEARG:               /* justify line range	*/
            x1 = 0;                 /* between cols 0...	*/
            x2 = justwidth;             /*	...and 79	*/
            y1 = pArg->arg.linearg.yStart;      /* and range of lines	*/
            y2 = pArg->arg.linearg.yEnd;
            pText = 0;              /* there is no text	*/
            break;

        case BOXARG:                /* justify box		*/
            x1 = pArg->arg.boxarg.xLeft;        /* from left corner...	*/
            x2 = pArg->arg.boxarg.xRight;       /*	    ...to right */
            y1 = pArg->arg.boxarg.yTop;     /* from top...		*/
            y2 = pArg->arg.boxarg.yBottom;      /*	   ...to bottom */
            pText = 0;              /* there is no text	*/
            break;

        case TEXTARG:               /* justify & prepend	*/
            x1 = 0;                 /* between 0... 	*/
            x2 = justwidth;             /*	  ...and 79	*/
            y1 = pArg->arg.textarg.y;       /* current line...	*/
            y2 = -1;                /*     ...to blank line */
            pText = pArg->arg.textarg.pText;    /* there IS text	*/
            break;
    }
    pFile = FileNameToHandle ("", "");

    if (y1 == y2)                   /* if same line, then	*/
        y2 = -1;                    /* just to blank line	*/
    if (x1 == x2)                   /* if same column	*/
        x2 = justwidth;             /* then just to default */
    if (x2 < x1) {                  /* if bas-ackwards	*/
        x1 = 0;                 /* revert to default	*/
        x2 = justwidth;
    }

    /*
    ** while we can get data within the specified limits, format each new line
    ** and output back to the file.
    */
    inbuf[0] = 0;
    yOut = y1;
    while (NextLine(inbuf,pFile,y1,&y2,&cbLine)) {
        /*
        ** if the line was blank, NextLine returned TRUE becase we're formating a
        ** range of text. This means we've reached the end of one paragraph. We dump
        ** the text collected so far (if any), and then a blank line.
        */
        if (cbLine == 0) {
            if (inbuf[0]) {
                DumpLine(inbuf,pFile,x1,x2,yOut++,pText,0);
                y1++;
                if (y2 != (LINE)-1)
                    y2++;
            }
            DumpLine("",pFile,x1,x2,yOut++,pText,0);/* dump blank line	*/
            y1++;
            if (y2 != (LINE)-1)
                y2++;
        } else
            /*
            ** inbuf contains the data collected so far for output. Output one newly
            ** formated line at a time until the contents of inbuf are narrower than
            ** our output columns.
            */
            while ((COL)strlen(inbuf) > (x2-x1)) {  /* while data to output */
                DumpLine(inbuf,pFile,x1,x2,yOut++,pText,fMeta);
                y1++;               /* line moves with insert*/
                if (y2 != (LINE)-1)
                    y2++;
            }
    }
    /*
    ** Dump any partial last line. Then if we were formatting to a blank line,
    ** dump out one of those too.;
    */
    if (inbuf[0])
        DumpLine (inbuf,pFile,x1,x2,yOut++,pText,0); /* dump last line	 */
    if (y2 == -1)
        DumpLine (NULL,pFile,x1,x2,yOut++,pText,0);  /* dump blank line	 */

    return TRUE;

    /* end justify */

}

/*** NextLine - Get next line from file
*
*  Get next line from file, remove leading and trailing spaces, and append
*  it to the input buffer. Each line is deleted from the file as it is
*  read in. This means that the target terminator, (*py2), is decremented
*  by one for each line read in.
*
* Input:
*  pBuf 	= pointer to input buffer
*  pFile	= file pointer
*  y1		= line # to read
*  py2		= pointer to line # to stop at (updated)
*  pcbLine	= pointer to place to put the count of bytes read
*
* Output:
*  Returns TRUE on a line being read & more reformatting should occurr.
*
*************************************************************************/
int pascal near NextLine (
                         char far *pBuf,                 /* input buffer 	*/
                         PFILE   pFile,                  /* file pointer 	*/
                         LINE    y1,                 /* line # to read	*/
                         LINE far *py2,                  /* line # to stop at	*/
                         int far *pcbLine                /* loc to place bytes read*/
                         ) {
    flagType fRet       = TRUE;
    char far *pT;                   /* working pointer	*/
    char    workbuf[BUFLEN];                        /* working buffer       */


    *pcbLine = 0;
    workbuf[0] = 0;
    /*
    ** If asked for line that is not in file, we're done.
    */
    if (y1 >= FileLength(pFile))
        return FALSE;
    /*
    ** if current line past range, (and range is not "-1"), then we're done.
    */
    if ((*py2 != (LINE)-1) && (y1 > *py2))
        return FALSE;
    /*
    ** Get the next line in the file & remove it.
    */
    *pcbLine = GetLine(y1, workbuf, pFile);
    DelLine(pFile, y1, y1);
    if (*py2 == 0)
        fRet = FALSE;
    else if (*py2 != (LINE)-1)
        (*py2)--;
    /*
    ** If the line is blank, and the range is "-1", we're done.
    */
    if (!*pcbLine && (*py2 == -1))
        return FALSE;

    /*
    ** strip leading spaces in newly input line
    */
    pT = workbuf;                   /* point into line	*/
    while (*pT == ' ')
        pT++;                   /* skip leading spaces	*/
    /*
    ** If existing buffer is non-empty, append a space & set pointer to end
    */
    if (strlen(pBuf)) {             /* if non-null string	*/
        pBuf += strlen(pBuf);           /* point to null	*/
        *pBuf++ = ' ';              /* append space 	*/
        if (isterm(*(pBuf-2)))          /* if sentence term...	*/
            *pBuf++ = ' ';              /* append another	*/
    }
    /*
    ** append new line, but compress multiple spaces into one
    */
    while (*pT) {                   /* copy line over	*/
        if (isterm(*pT))                /* if sentence term...	*/
            if (*(pT+1) == ' ') {           /*   ...space		*/
                *pBuf++ = *pT++;            /* copy period		*/
                *pBuf++ = *pT;          /* copy space		*/
            }
        if ((*pBuf++ = *pT++) == ' '    )       /* copy a char		*/
            while (*pT == ' ') pT++;        /* skip multiple spaces */
    }
    if (*(pBuf-1) == ' ')               /* if a trailing space	*/
        pBuf--;                 /* remove it		*/
    *pBuf = 0;

    return fRet;
    /* end NextLine */}

/*** DumpLine - Dump one line of text to the file
*
*  Dump one line of text to the file. Prepend any required text or spaces,
*  and perform word break/cut at right hand column.
*
* Input:
*  pBuf     = Pointer to the buffer containing data to output. If NULL, pText
*	      will not be prepended to output text.
*  pFile
*  x1
*  x2
*  yOut
*  pText
*  fFlush
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void pascal near DumpLine (
                          char far *pBuf,                 /* data to output	*/
                          PFILE   pFile,                  /* file to output to	*/
                          COL x1,                 /* left-hand column	*/
                          COL x2,                 /* right-hand column	*/
                          LINE    yOut,                   /* line to output to	*/
                          char far *pText,                /* text to prepend	*/
                          int fFlush                  /* flush both sides	*/
                          ) {
    int i;
    char far *pT;
    char far *pT2;
    char    workbuf[BUFLEN];                        /* working buffer       */
    char    flushbuf[BUFLEN];                       /* working buffer       */
    char    fSpace;                 /* space seen flag	*/

    /*
    ** Start by prepending any text, and then filling out to the left hand column
    ** to justify to.
    */
    workbuf[0] = 0;                 /* start with null	*/
    if (pText && pBuf)
        strcpy(workbuf,pText);          /* if starting with text*/
    i = strlen(workbuf);                /* length of line-so-far*/
    while (i++ < x1)
        strcat(workbuf," ");            /* fill out with spaces */

    /*
    ** Append the data to be output, and then starting at the right column, scan
    ** back for a space to break at. If one is not found before the left hand
    ** column, then break at the right hand column. Copy any line left over back
    ** to the passed in buffer
    */
    if (pBuf) {
        strcat(workbuf,pBuf);           /* get total line	*/
        *pBuf = 0;                  /* empty input buffer	*/
    }
    if ((COL)strlen(workbuf) > x2) {            /* if we need to cut	*/
        pT = &workbuf[x2];              /* point at potential cut*/
        while ((pT > (char far *)&workbuf[0]) && (*pT != ' ')) pT--; /* back up to space*/
        if (pT <= (char far *)&workbuf[x1]) {   /* if none found in range*/
            if (pBuf)
                strcpy(pBuf,&workbuf[x2]);      /* copy remainder of line*/
            workbuf[x2] = 0;            /* and terminate this one*/
        } else {
            while (*++pT == ' ');           /* Skip leading spaces	 */
            if (pBuf)
                strcpy(pBuf,pT);            /* copy remainder of line*/
            *pT = 0;                /* and terminate this one*/
        }
    }
    /*
    ** This code is invoked when the user wants to justify both right and left
    ** sides of his text. We determine how many spaces we need to add, and scan
    ** through and add one space to each run of spaces until we've added enough
    */
    if (fFlush) {                   /* right & left justify?*/
        pT = workbuf + strlen(workbuf) - 1;
        if (pT)
            while (*pT == ' ')
                *pT-- = 0;
        if (strchr(workbuf,' ')) {
            while ((i = x2 - strlen(workbuf)) > 0) {/* count of spaces to add */
                strcpy(flushbuf,workbuf);       /* start with unmodified*/
                pT = workbuf + x1;
                pT2 = flushbuf + x1;        /* skip fixed part	*/
                fSpace = FALSE;         /* assume no spaces	*/
                while (*pT) {           /* while data to copy	*/
                    if ((*pT == ' ') && i) {    /* time to insert a space*/
                        fSpace = TRUE;      /* we've seen a space   */
                        *pT2++ = ' ';
                        i--;
                        while (*pT == ' ')
                            *pT2++ = *pT++;     /* copy run of spaces	*/
                    }
                    if (*pT)
                        *pT2++ = *pT++;     /* copy line		*/
                    else if (!fSpace)
                        break;          /* no embedded spaces	*/
                }
                *pT2 = 0;
                strcpy(workbuf,flushbuf);       /* copy back		*/
                if (!fSpace)
                    break;
            }
        }
    }

    CopyLine ((PFILE) NULL, pFile, yOut, yOut, yOut); /* create new line	*/
    PutLine (yOut, workbuf, pFile);         /* output line		*/

    /* end DumpLine */

}

/*************************************************************************
**
** isterm
** returns true/false based on the character being a sentence terminator:
** one of '.', '?', '!'. Also, always returns false if just2space is off.
*/
flagType pascal near isterm(
                           char c               /* character to test		*/
                           )
{
    return (flagType)(just2space && ((c == '.') || (c == '!') || (c == '?')));
    /* end isterm */}


/*
** WhenLoaded
** Executed when these extensions get loaded. Identify self & assign keys.
*/
void justifyWhenLoaded () {
    PSWI    pwidth;

    if (pwidth = FindSwitch("rmargin"))
        justwidth = *pwidth->act.ival;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\console.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.h

Abstract:

    Interface to the console-management functions for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/




//
//  Some common typedefs...
//
typedef ULONG   ROW,            *PROW;              //  row
typedef ULONG   COLUMN,         *PCOLUMN;           //  column
typedef DWORD   KBDMODE,        *PKBDMODE;          //  Keyboard mode
typedef DWORD   ATTRIBUTE,      *PATTRIBUTE;        //  Screen Attribute
typedef PVOID   PSCREEN;                            //  The screen



//
//  Console Input Mode flags. They are the same as the NT flags
//
#define CONS_ENABLE_LINE_INPUT      ENABLE_LINE_INPUT
#define CONS_ENABLE_PROCESSED_INPUT ENABLE_PROCESSED_INPUT
#define CONS_ENABLE_ECHO_INPUT      ENABLE_ECHO_INPUT
#define CONS_ENABLE_WINDOW_INPUT    ENABLE_WINDOW_INPUT
#define CONS_ENABLE_MOUSE_INPUT     ENABLE_MOUSE_INPUT

//
//	Cursor styles
//
#define 	CURSOR_STYLE_UNDERSCORE 	0
#define 	CURSOR_STYLE_BOX			1


//
//  The information about a screen is retrieved in the following
//  structure:
//
typedef struct SCREEN_INFORMATION {
    ROW     NumberOfRows;       //  Number of rows
    COLUMN  NumberOfCols;       //  Number of columns
    ROW     CursorRow;          //  Cursor row position
    COLUMN  CursorCol;          //  Cursor column position
} SCREEN_INFORMATION, *PSCREEN_INFORMATION;




//
//  The information about each keystroke is returned in
//  the KBDKEY structure.
//
typedef struct KBDKEY {
    WORD    Unicode;        // character unicode
    WORD    Scancode;       // key scan code
    DWORD   Flags;          // keyboard state flags
} KBDKEY, *PKBDKEY;

//
//  The following macros access particular fields within the
//  KBDKEY structure. They exist to facilitate porting of OS/2
//  programs.
//
#define KBDKEY_ASCII(k)     (UCHAR)((k).Unicode)
#define KBDKEY_SCAN(k)      ((k).Scancode)
#define KBDKEY_FLAGS(k)     ((k).Flags)


#define NEXT_EVENT_NONE 	0
#define NEXT_EVENT_KEY		1
#define NEXT_EVENT_WINDOW	2

//
// ControlKeyState flags. They are the same as the NT status flags.
//
#define CONS_RIGHT_ALT_PRESSED     RIGHT_ALT_PRESSED
#define CONS_LEFT_ALT_PRESSED      LEFT_ALT_PRESSED
#define CONS_RIGHT_CTRL_PRESSED    RIGHT_CTRL_PRESSED
#define CONS_LEFT_CTRL_PRESSED     LEFT_CTRL_PRESSED
#define CONS_SHIFT_PRESSED         SHIFT_PRESSED
#define CONS_NUMLOCK_PRESSED       NUMLOCK_ON
#define CONS_SCROLLLOCK_PRESSED    SCROLLLOCK_ON
#define CONS_CAPSLOCK_PRESSED      CAPSLOCK_ON
#define CONS_ENHANCED_KEY          ENHANCED_KEY





//
//  Screen Management functions
//
PSCREEN
consoleNewScreen (
    void
    );

BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    );

PSCREEN
consoleGetCurrentScreen (
    void
    );

BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    );

BOOL
consoleGetScreenInformation (
    PSCREEN             pScreen,
    PSCREEN_INFORMATION pScreenInformation
    );

BOOL
consoleSetScreenSize (
     PSCREEN Screen,
     ROW     Rows,
     COLUMN  Cols
	);



//
//  Cursor management
//
BOOL
consoleSetCursor (
     PSCREEN pScreen,
     ROW     Row,
     COLUMN  Col
    );

//
//	Cursor style
//
BOOL
consoleSetCursorStyle (
     PSCREEN pScreen,
     ULONG   Style
	);



//
//  Screen output functions
//
ULONG
consoleWriteLine (
    PSCREEN     pScreen,
     PVOID       pBuffer,
     ULONG       BufferSize,
     ROW         Row,
     COLUMN      Col,
     ATTRIBUTE   Attribute,
     BOOL        Blank
    );

BOOL
consoleShowScreen (
     PSCREEN     pScreen
    );

BOOL
consoleClearScreen (
     PSCREEN     pScreen,
     BOOL        ShowScreen
    );

BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    );

BOOL
consoleScrollVert (
    PSCREEN      pScreen,
    ROW          Top,
    COLUMN       Left,
    ROW          Bottom,
    COLUMN       Right,
    INT          Rows
    );






//
//  Input functions
//
BOOL
consoleFlushInput (
    void
    );

BOOL
consoleIsKeyAvailable (
	void
	);

BOOL
consoleDoWindow (
	void
	);

BOOL
consoleGetKey (
    PKBDKEY        pKey,
     BOOL           fWait
    );

BOOL
consolePutKey (
     PKBDKEY     pKey
    );

BOOL
consolePutMouse (
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    );

BOOL
consolePeekKey (
    PKBDKEY     pKey
	);

BOOL
consoleGetMode (
    PKBDMODE   Mode
    );

BOOL
consoleSetMode (
     KBDMODE        Mode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\zextens\party.c ===
/*
** MEP Party extension
**
** History:
**	17-Oct-1991	Ported to NT
**
*/

#define _CTYPE_DISABLE_MACROS
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "zext.h"
#include <winuserp.h>

#ifndef TRUE
#define TRUE	-1
#define FALSE	0
#endif

HWND hwndSelf;

flagType iconizeOnExit = TRUE;

flagType pascal DoCaseLine(
    PFILE CurFile,
    LINE y,
    COL x,
    COL maxX,
    flagType LowerCase
    )
{
    flagType Modified;
    int cb;
    char buf[ BUFLEN ], *s;

    cb = GetLine( y, buf, CurFile );
    s = &buf[ x ];
    if (maxX != 0) {
        if (maxX - x < cb) {
            cb = maxX - x + 1;
            }
        }
    else {
        cb -= x;
        }

    Modified = FALSE;
    while (cb--) {
        if (LowerCase) {
            if (*s >= 'A' && *s <= 'Z') {
                *s -= 'A' - 'a';
                Modified = TRUE;
                }
            }
        else {
            if (*s >= 'a' && *s <= 'z') {
                *s += 'A' - 'a';
                Modified = TRUE;
                }
            }

        s++;
        }

    if (Modified) {
        PutLine( y, buf, CurFile );
        }

    return( TRUE );
}


flagType pascal EXTERNAL
Case(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    int i;
    PFILE CurFile;

    CurFile = FileNameToHandle("",NULL);
    switch( pArg->argType ) {
        case NOARG:
            return( DoCaseLine( CurFile, pArg->arg.noarg.y, 0, 0, fMeta ) );
            break;

        case NULLARG:
            return( DoCaseLine( CurFile,
                                pArg->arg.nullarg.y,
                                pArg->arg.nullarg.x,
                                0,
                                fMeta
                              )
                  );
            break;

        case LINEARG:
            for (i=pArg->arg.linearg.yStart; i<=pArg->arg.linearg.yEnd; i++) {
                if (!DoCaseLine( CurFile, (LINE)i, 0, 0, fMeta )) {
                    return( FALSE );
                    }
                }

            return( TRUE );
            break;

        case BOXARG:
            for (i=pArg->arg.boxarg.yTop; i<=pArg->arg.boxarg.yBottom; i++) {
                if (!DoCaseLine( CurFile,
                                 (LINE)i,
                                 pArg->arg.boxarg.xLeft,
                                 pArg->arg.boxarg.xRight,
                                 fMeta
                               )
                   ) {
                    return( FALSE );
                    }
                }

            return( TRUE );
            break;

        default:
            BadArg();
            return( FALSE );
        }

    argData;
}

int CountMsgFiles;
int MsgFileIndex;
HANDLE MsgFiles[ 2 ];
int MsgFileOffsetIndex;
LONG MsgFileOffsets[ 3 ];

char
GetHexDigit(
    ULONG value,
    int index
    )
{
    int digit;

    if (index < 4) {
        index <<= 2;
        digit = (int)((value >> index) & 0xF);
        }
    else {
        digit = 0;
        }
    if (digit <= 9) {
        return( (char)(digit+'0') );
        }
    else {
        return( (char)((digit-10)+'A') );
        }
}

void
MyFormatMessage(
    char *buf,
    char *msg,
    long value1,
    long value2
    );

void
MyFormatMessage(
    char *buf,
    char *msg,
    long value1,
    long value2
    )
{
    char c, *src, *dst;
    long value;

    src = msg;
    dst = buf;
    while (c = *src++) {
        if (c == '%' && src[1] == 'x') {
            if (*src == '1') {
                value = value1;
                }
            else {
                value = value2;
                }

            *dst++ = GetHexDigit( value, 3 );
            *dst++ = GetHexDigit( value, 2 );
            *dst++ = GetHexDigit( value, 1 );
            *dst++ = GetHexDigit( value, 0 );
            src++;
            src++;
            }
        else {
            *dst++ = c;
            }
        }

    *dst = '\0';
    DoMessage( buf );
}

flagType pascal EXTERNAL
ShowBuildMessage(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    int i, BytesRead, BytesScanned, linenum;
    ULONG NewOffset;
    char LineBuffer[ 256 ], *s, *s1;

    if (!fMeta && CountMsgFiles == 0) {
        MsgFileIndex = 0;
        MsgFiles[ MsgFileIndex ] = CreateFile( "build.wrn",
                                               GENERIC_READ,
                                               FILE_SHARE_READ,
                                               NULL,
                                               OPEN_EXISTING,
                                               0,
                                               NULL
                                             );
        if (MsgFiles[ MsgFileIndex ] != INVALID_HANDLE_VALUE) {
            CountMsgFiles++;
            MsgFileIndex++;
            }

        MsgFiles[ MsgFileIndex ] = CreateFile( "build.err",
                                               GENERIC_READ,
                                               FILE_SHARE_READ,
                                               NULL,
                                               OPEN_EXISTING,
                                               0,
                                               NULL
                                             );
        if (MsgFiles[ MsgFileIndex ] != INVALID_HANDLE_VALUE) {
            CountMsgFiles++;
            MsgFileIndex++;
            }

        MsgFileIndex = 0;
        MsgFileOffsetIndex = 0;
        MsgFileOffsets[ 0 ] = 0L;
        MsgFileOffsets[ 1 ] = 0L;
        MsgFileOffsets[ 2 ] = 0L;
        }
    else
    if (fMeta && CountMsgFiles != 0) {
        for (i=0; i<CountMsgFiles; i++) {
            CloseHandle( MsgFiles[ i ] );
            }

        CountMsgFiles = 0;
        return( TRUE );
        }

    if (CountMsgFiles == 0) {
        DoMessage( "No BUILD.WRN or BUILD.ERR message file." );
        return( FALSE );
        }

    switch( pArg->argType ) {
        case NULLARG:
            if (MsgFileOffsetIndex-- == 0) {
                MsgFileOffsetIndex = 2;
                }
            //
            // fall through
            //

        case NOARG:
retrymsgfile:
            NewOffset = SetFilePointer( MsgFiles[ MsgFileIndex ],
                                        MsgFileOffsets[ MsgFileOffsetIndex ],
                                        NULL,
                                        FILE_BEGIN
                                      );
            if (NewOffset == -1) {
                MyFormatMessage( LineBuffer,
                                 "SetFilePointer( %1x ) failed - rc == %2x",
                                 MsgFileOffsets[ MsgFileOffsetIndex ],
                                 GetLastError()
                               );
                DoMessage( LineBuffer );
                return( FALSE );
                }

            if (!ReadFile( MsgFiles[ MsgFileIndex ],
                           LineBuffer,
                           sizeof( LineBuffer ),
			   ( LPDWORD )&BytesRead,
                           NULL
                         )
               ) {
                MyFormatMessage( LineBuffer,
                                 "ReadFile( %1x ) failed - rc == %2x",
                                 (ULONG)BytesRead,
                                 GetLastError()
                               );
                DoMessage( LineBuffer );
                return( FALSE );
                }

            s = LineBuffer;
            BytesScanned = 0;
            while (BytesScanned < BytesRead) {
                BytesScanned++;
                if (*s == '\n') {
                    *s = '\0';
                    break;
                    }
                else
                if (*s == '\r' && s[1] == '\n') {
                    *s = '\0';
                    BytesScanned++;
                    break;
                    }
                else {
                    s++;
                    }
                }

            if (BytesScanned == 0) {
                if (++MsgFileIndex == CountMsgFiles) {
                    for (i=0; i<CountMsgFiles; i++) {
                        CloseHandle( MsgFiles[ i ] );
                        }

                    CountMsgFiles = 0;
                    DoMessage( "no more BUILD messages" );
                    return( FALSE );
                    }
                else {
                    MsgFileOffsetIndex = 0;
                    MsgFileOffsets[ 0 ] = 0L;
                    MsgFileOffsets[ 1 ] = 0L;
                    MsgFileOffsets[ 2 ] = 0L;
                    goto retrymsgfile;
                    }
                }
            else {
                NewOffset = MsgFileOffsets[ MsgFileOffsetIndex ];

                if (++MsgFileOffsetIndex == 3) {
                    MsgFileOffsetIndex = 0;
                    }

                MsgFileOffsets[ MsgFileOffsetIndex ] = NewOffset + BytesScanned;
                }

            s = LineBuffer;
            while (*s) {
                if (*s == '(') {
                    *s++ = '\0';
                    s1 = s;
                    while (s1 > LineBuffer && s1[-1] == ' ') {
                        *--s1 = '\0';
                        }

                    s1 = s;
                    while (*s && isdigit( *s )) {
                        s++;
                        }
                    *s++ = '\0';
                    linenum = atoi( s1 );
                    while (*s) {
                        if (*s++ == ':') {
                            PFILE pOldFile;
                            DWORD fOldFileFlags;

                            //
                            // Switch to correct file for message.  If we change to
                            // a different file and the old one was modified, write
                            // it out.
                            //

                            pOldFile = FileNameToHandle( "", NULL );
                            fOldFileFlags = 0;
                            GetEditorObject( 0xFF | RQ_FILE_FLAGS,  pOldFile, (PVOID)&fOldFileFlags );
                            fChangeFile( FALSE, LineBuffer );
                            if (pOldFile != FileNameToHandle( "", NULL ) &&
                                fOldFileFlags & DIRTY) {
                                FileWrite( "", pOldFile );
                            }
                            MoveCur( 0, (LINE)(linenum-1) );
                            fExecute( "begline" );
                            DoMessage( s+1 );
                            return( TRUE );
                            }
                        }
                    }
                else {
                    s++;
                    }
                }
            goto retrymsgfile;

        default:
            BadArg();
            return( FALSE );
        }

    return( TRUE );

    argData;
}

char ErrorText[ 64 ],
     Arguments[ 64 + MAX_PATH ],
     PathName[ MAX_PATH ];

flagType pascal EXTERNAL
SlmOut(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    PFILE pCurFile;
    char *FileName;
    DWORD fFileFlags;
    char OldCurrentDirectory[MAX_PATH];

    pCurFile = FileNameToHandle( (char far *)"", (char far *)NULL );
    fFileFlags = 0;
    GetEditorObject( 0xFF | RQ_FILE_FLAGS,  pCurFile, (PVOID)&fFileFlags );
    GetEditorObject( 0xFF | RQ_FILE_NAME, pCurFile, (PVOID)PathName );

    FileName = PathName + strlen( PathName );
    while (FileName > PathName) {
        if (*--FileName == '\\') {
            *FileName++ = '\0';
            break;
            }
        }

    if (FileName == PathName) {
        DoMessage( "Unable to get directory for file" );
        return( FALSE );
        }

    if (GetCurrentDirectory(sizeof(OldCurrentDirectory), OldCurrentDirectory) == 0) {
        DoMessage( "Unable to save current directory setting" );
        return( FALSE );
        }

    if (SetCurrentDirectory(PathName) != 0) {
        strcpy( Arguments, "arg " );

        if (fMeta) {
            strcpy( Arguments, "cd & in -i " );
            }
        else {
            strcpy( Arguments, "cd & out -z " );
            }
        strcat( Arguments, FileName );
        strcat( Arguments, " & if ERRORLEVEL 1 pause" );
        DoSpawn( Arguments, FALSE );
        if (!fMeta && fFileFlags & DIRTY) {
            FileWrite( "", pCurFile );
            SetEditorObject( 0xFF | RQ_FILE_MODTIME, pCurFile, (PVOID)NULL );
            if (fFileFlags & DIRTY) {
                DoMessage( "Modified file has been checked out." );
                }
            else {
                DoMessage( "Current file has been checked out." );
                }
            }
        else {
            if (fMeta) {
                fExecute( "refresh" );
                DoMessage( "Changes to current file discarded.  No longer checked out." );
                }
            else {
                SetEditorObject( 0xFF | RQ_FILE_MODTIME, pCurFile, (PVOID)NULL );
                DoMessage( "Current file has been checked out." );
                }
            }

        SetCurrentDirectory(OldCurrentDirectory);
        return( TRUE );
        }
    else {
        DoMessage( "Unable to change current directory" );
        return( FALSE );
        }

    argData;
    pArg;
    fMeta;
}


HANDLE EditorStartEvent;
HANDLE EditorStopEvent;
HANDLE EditorSharedMemory;
LPSTR EditorMemoryPointer;
HWND hPrevWindow = NULL;
char CommandLineBuffer[ 256 ];


HWND
GetWindowHandleOfEditor( void );

void SwitchToProgram( HWND hwnd );

void
SwitchToTaskManager( void );

flagType pascal EXTERNAL
StartExt(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    PFILE pCurFile;
    int fFileFlags;

    if (!fMeta) {
        pCurFile = FileNameToHandle( "", NULL );
        fFileFlags = 0;
        GetEditorObject( 0xFF | RQ_FILE_FLAGS,  pCurFile, (PVOID)&fFileFlags );
        if (fFileFlags & DIRTY)
            FileWrite( "", pCurFile );
        }

    if (hPrevWindow) {
        SetEvent( EditorStopEvent );
        SwitchToProgram( hPrevWindow );
        hPrevWindow = NULL;
        }
    else {
        SwitchToTaskManager();
        }

    fExecute( "savetmpfile" );

    return TRUE;
    argData;
    pArg;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
WaitForStartEventThread(
    PVOID Parameter
    )
{
    CHAR szFileName[ 256 ];
    LPSTR s, lpName, lpValue, lpNewCmdLine, lpEditorMem;
    PINPUT_RECORD pEvent, pEvents;
    DWORD NumberOfEvents, NumberOfEventsWritten;

    while (TRUE) {
        WaitForSingleObject( EditorStartEvent, INFINITE );
        lpEditorMem = EditorMemoryPointer;

        hPrevWindow = *(HWND *)lpEditorMem;
        lpEditorMem += sizeof( hPrevWindow );

        SetCurrentDirectory( lpEditorMem );
        while( *lpEditorMem++ ) {
            }

        lpNewCmdLine = CommandLineBuffer;
        while( *lpNewCmdLine++ = *lpEditorMem++ ) {
            }

        while (*lpEditorMem) {
            lpName = lpEditorMem;
            while (*lpEditorMem) {
                if (*lpEditorMem++ == '=') {
                    lpValue = lpEditorMem;
                    lpValue[ -1 ] = '\0';
                    while (*lpEditorMem++) {
                        }
                    SetEnvironmentVariableA( lpName, lpValue );
                    lpValue[ -1 ] = '=';
                    break;
                    }
                }
            }

        s = CommandLineBuffer;
        while (*s == ' ')
            s++;

        if (*s) {
            NumberOfEvents = 1 + strlen( s ) + 1;
            pEvents = HeapAlloc( GetProcessHeap(), 0, NumberOfEvents * sizeof( *pEvent ) );
            pEvent = pEvents;
            pEvent->EventType = KEY_EVENT;
            FuncNameToKeyEvent( "arg", &pEvent->Event.KeyEvent);
            pEvent += 1;
            while (*s) {
                pEvent->EventType = KEY_EVENT;
                FuncNameToKeyEvent( (char *)(BYTE)*s++, &pEvent->Event.KeyEvent);
                pEvent += 1;
                }
            pEvent->EventType = KEY_EVENT;
            FuncNameToKeyEvent( "setfile", &pEvent->Event.KeyEvent);
            pEvent += 1;
            WriteConsoleInput( GetStdHandle( STD_INPUT_HANDLE ),
                               pEvents,
                               NumberOfEvents,
                               &NumberOfEventsWritten
                             );
            HeapFree( GetProcessHeap(), 0, pEvents );
            }
        }

    return TRUE;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



void
SwitchToProgram(
    HWND hwnd
    )
{
    if (hwndSelf && iconizeOnExit) {
        ShowWindow( hwndSelf, SW_MINIMIZE );
        }

    SetForegroundWindow( hwnd );
    ShowWindow( hwnd, SW_RESTORE);
}

void
SwitchToTaskManager( void )
{
    HWND hwnd;
    wchar_t szTitle[ 256 ];

    /*
     * Search the window list for task manager window.
     */
    hwnd = GetWindow( GetDesktopWindow(), GW_CHILD );
    while (hwnd) {
        /*
         * Only look at non-visible, non-owned, Top Level Windows.
         */
        if (!IsWindowVisible( hwnd ) && !GetWindow( hwnd, GW_OWNER )) {
            //
            // Use internal call to get current Window title that does NOT
            // use SendMessage to query the title from the window procedure
            // but instead returns the most recent title displayed.
            //

            InternalGetWindowText( hwnd,
                                   (LPWSTR)szTitle,
                                   sizeof( szTitle )
                                 );
            if (!_wcsicmp( L"Task List", szTitle )) {
                SwitchToProgram( hwnd );
                break;
                }
            }

        hwnd = GetWindow( hwnd, GW_HWNDNEXT );
        }

    return;
}


flagType
StartExtLoaded( void );

flagType
StartExtLoaded ()
{
    HANDLE Thread;
    DWORD ThreadId;

    hwndSelf = GetWindowHandleOfEditor();
    EditorStartEvent = CreateEvent( NULL, FALSE, FALSE, "EditorStartEvent" );
    if (EditorStartEvent == NULL) {
        DoMessage( "Create of EditorStartEvent failed" );
        return FALSE;
        }

    EditorStopEvent = CreateEvent( NULL, FALSE, FALSE, "EditorStopEvent" );
    if (EditorStopEvent == NULL) {
        DoMessage( "Create of EditorStopEvent failed" );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    EditorSharedMemory = CreateFileMapping( INVALID_HANDLE_VALUE,
                                            NULL,
                                            PAGE_READWRITE,
                                            0,
                                            8192,
                                            "EditorSharedMemory"
                                          );
    if (EditorSharedMemory == NULL) {
        DoMessage( "Create of EditorStartMemory failed" );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    EditorMemoryPointer = MapViewOfFile( EditorSharedMemory,
                                         FILE_MAP_READ | FILE_MAP_WRITE,
                                         0,
                                         0,
                                         8192
                                       );
    if (EditorMemoryPointer == NULL) {
        DoMessage( "MapView of EditorStartMemory failed" );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        CloseHandle( EditorSharedMemory );
        return FALSE;
        }

    Thread = CreateThread( NULL,
                           8192,
                           (LPTHREAD_START_ROUTINE)WaitForStartEventThread,
                           0,
                           0,
                           &ThreadId
                         );

    if (Thread == NULL) {
        DoMessage( "Can't start environment thread" );
        UnmapViewOfFile( EditorMemoryPointer );
        CloseHandle( EditorSharedMemory );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    if (!SetThreadPriority( Thread, THREAD_PRIORITY_ABOVE_NORMAL )) {
        DoMessage( "Can't set priority of environment thread" );
        }

    CloseHandle( Thread );

    return TRUE;
}

void partyWhenLoaded(void)
{
    if (StartExtLoaded()) {
        CountMsgFiles = 0;
        }
}


HWND
GetWindowHandleOfEditor( void )
{
    #define MY_BUFSIZE 1024                 // buffer size for console window titles
    HWND hwndFound;                         // this is what we return to the caller
    char pszNewWindowTitle[ MY_BUFSIZE ];   // contains fabricated WindowTitle
    char pszOldWindowTitle[ MY_BUFSIZE ] = {0};   // contains original WindowTitle

    // fetch current window title

    GetConsoleTitle( pszOldWindowTitle, MY_BUFSIZE );

    // format a "unique" NewWindowTitle

    wsprintf( pszNewWindowTitle, "%d/%d", GetTickCount(), GetCurrentProcessId() );

    // change current window title

    SetConsoleTitle( pszNewWindowTitle );

    // insure window title has been updated

    Sleep(40);

    // look for NewWindowTitle

    hwndFound = FindWindow( NULL, pszNewWindowTitle );

    // restore original window title

    SetConsoleTitle( pszOldWindowTitle );

    return( hwndFound );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\zextens\pmatch.c ===
#include "zext.h"

/*
 *  Modifications
 *  12-Sep-1988 mz  Made WhenLoaded match declaration
 *
 */

#define fLeftSide(ch) ((ch) == '[' || (ch) == '{' || (ch) == '(' || (ch) == '<' )
#define EOF (int)0xFFFFFFFF
#define BOF (int)0xFFFFFFFE
#define EOL (int)0xFFFFFFFD

#ifndef TRUE
#define FALSE	0
#define TRUE	(!FALSE)
#endif

#ifndef NULL
#define NULL	((void *) 0)
#endif

#define SQ  '\''
#define DQ  '\"'
#define ANYCHAR '\0'
#define BACKSLASH '\\'

/****************************************************************************
 *									    *
 *  Handle apostrophes ( which look like single quotes, but don't come in   *
 *  pairs ) by defining a maximum number of chars that can come between     *
 *  single quotes. 4 will handle '\000' and '\x00'			    *
 *									    *
 ****************************************************************************/

#define SQTHRESH 4

flagType pascal EXTERNAL PMatch (unsigned, ARG far *, flagType);
char MatChar (char);
void openZFile (void);
void lopen (PFILE, int, int) ;
int rgetc (void);
int ngetc (void);
int lgetc (void);
void pos (COL far *, LINE far *);
flagType ParenMatch (int, flagType);


/****************************************************************************
 *									    *
 *  PMatch(argData, pArg, fMeta)					    *
 *									    *
 *	argData - ignored						    *
 *	pArg	- ignored						    *
 *	fMeta	- TRUE means search for first matchable character	    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if matching character was found.				    *
 *	FALSE if not.							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes location of cursor.					    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	     <pmatch>: If the cursor is on a "match" character, find the    *
 *		       match and move the cursor there.  If not, do	    *
 *		       nothing. 					    *
 *									    *
 *	<arg><pmatch>: Same as <pmatch>, but search forward for a "match"   *
 *		       character if we're not on one.                       *
 *									    *
 *	Always ignore characters between quotes.			    *
 *									    *
 *	Match characters currently supported are:			    *
 *									    *
 *		'{'  and  '}'						    *
 *		'['  and  ']'						    *
 *		'('  and  ')'						    *
 *		'<'  and  '>'						    *
 *									    *
 *  NOTES:								    *
 *									    *
 *	This is defined as a CURSORFUNC, and therefore can be used to	    *
 *	select text as part of an argument.  For example, to grab the body  *
 *	of a function, go to the opening brace of the body and do	    *
 *	<arg><pmatch><pick>.						    *
 *									    *
 ****************************************************************************/

flagType pascal EXTERNAL PMatch (
unsigned int argData,
ARG far * pArg,
flagType fMeta
)
{
    COL x;
    LINE y;
    char ch;


	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)pArg;

	/* Set up file functions */
	openZFile ();

	/* If current character has no match ... */
	if (!MatChar (ch = (char)ngetc()))
	{
	    if (fMeta)
	    {	/* Move forward looking for first matchable character */

		if (!ParenMatch (ANYCHAR, TRUE))  return FALSE;

		pos ((COL far *)&x, (LINE far *)&y);
		MoveCur (x, y);
		return TRUE;
	    }
	    else  return FALSE;
	}

	if (ParenMatch ((int)ch, (flagType)fLeftSide(ch)))
	{				       /*  We got one		    */
	    pos ((COL far *)&x, (LINE far *)&y);

	    MoveCur (x, y);

	    return TRUE;
	}

	return FALSE;				/* No match found	     */
}


/****************************************************************************
 *									    *
 *  ParenMatch (chOrig, fForward)					    *
 *									    *
 *	chOrig	 - character we are trying to match.			    *
 *	fForward - TRUE means search forward, FALSE search backwards	    *
 *	Returns TRUE if match found, false otherwise			    *
 *									    *
 *  RETURNS:								    *	    *
 *									    *
 *	TRUE if matching character found, FALSE if not. 		    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes internal cursor location				    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Search for the next character that "pairs" with 'ch'.  Account for  *	*
 *	nesting.  Ignore all characters between double quotes and single    *
 *	quotes.  Recognize escaped quotes.  Account for apostrophes.	    *
 *									    *
 ****************************************************************************/

flagType ParenMatch (
    int chOrig,
    flagType fForward
    )
{
    int lvl = 0, state	 = 0, sqcnt = 0;
    int (*nextch)(void)  = (int (*)(void))(fForward ? rgetc : lgetc);
    int (*_ungetch)(void) = (int (*)(void))(fForward ? lgetc : rgetc);
    int ch, chMatch;


	if (chOrig) chMatch = (int)MatChar ((char)chOrig);

    while ((ch = (*nextch)()) >= 0)
	    switch (state)
	    {
		case 0: /* Regular text */
		    if (ch == SQ)
			if (fForward)	state = 1;
			else		state = 5;
		    else if (ch == DQ)
			if (fForward)	state = 3;
			else		state = 7;
		    else
			if (chOrig != ANYCHAR)
			    if (ch == chOrig) lvl++;	   /* Nest in one    */
			    else
			    {
				if (ch == chMatch)	   /* Nest out or ...*/
				    if (!lvl--) goto found;/* Found it!      */
			    }
			else
			    if ((flagType)MatChar ((char)ch)) goto found;  /* Found one!     */

		    break;

		case 1: /* Single quote moving forwards */
		    sqcnt++;
		    if (ch == BACKSLASH)    state = 2;
		    else if (ch == SQ ||	/* We matched the ', or ...  */
			     sqcnt > SQTHRESH ) /* ... we gave up trying     */
					    {
					    sqcnt = 0;
					    state = 0;
					    }
		    break;

		case 2: /* Escaped character inside single quotes */
		    sqcnt++;
		    state = 1;
		    break; 

		case 3: /* Double quote moving forwards */
		    if (ch == BACKSLASH)    state = 4;
		    else if (ch == DQ)	    state = 0;
		    break;

		case 4: /* Escaped character inside double quotes */
		    state = 3;
		    break;

		case 5: /* Single quote moving backwards */
		    sqcnt++;
		    if (ch == SQ)	state = 6;
		    else if (sqcnt > SQTHRESH)
					{
					sqcnt = 0;
					state = 0;
					}
		    break;		

		case 6: /* Check for escaped single quote moving backwards  */
		    sqcnt++;
		    if (ch == BACKSLASH)    state = 5;
		    else
		    {
			sqcnt = 0;
			(*_ungetch)();
			state = 0;
		    }
		    break;

		case 7: /* Double quote moving backwards */
		    if (ch == DQ)   state = 8;
		    break;		

		case 8: /* Check for escaped double quote moving backwards  */
		    if (ch == BACKSLASH)    state = 7;
		    else
		    {
			(*_ungetch)();
			state = 0;
		    }
		    break;
	    }

	return FALSE;

	found:	return TRUE;
}


/****************************************************************************
 *									    *
 *  MatChar(ch) 							    *
 *									    *
 *	ch - Character to match 					    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Character that matches the argument				    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	None.								    *
 *									    *
 *  DESCRIPTION 							    *
 *									    *
 *	Given one character out of one of the pairs {}, [], (), <>, return  *
 *	the other one.							    *
 *									    *
 ****************************************************************************/

char MatChar (
    char ch
    )
{
    switch (ch)
    {
	case '{': return '}';
	case '}': return '{';
	case '[': return ']';
	case ']': return '[';
	case '(': return ')';
	case ')': return '(';
	case '<': return '>';
	case '>': return '<';
	default : return '\0';
    }
}


/****************************************************************************
 *									    *
 *  Extension specific file reading state.				    *
 *									    *
 *  The static globals record the current state of file reading.  The	    *
 *  pmatch extension reads through the file either forwards or backwards.   *
 *  The state is kept as the current column and row, the contents of the    *
 *  current line, the length of the current line and the file, and some     *
 *  flags.								    *
 *									    *
 ****************************************************************************/

static char	LineBuf[BUFLEN];    /* Text of current line in file	    */
static COL	col	;   /* Current column in file (0-based) 	    */
static LINE	line	;   /* Current line in file   (0-based) 	    */
static int	numCols ;   /* Columns of text on curent line		    */
static LINE	numLines;   /* Number of lines in the file		    */
static PFILE	pFile	;   /* File to be reading from			    */
static flagType fEof	;   /* TRUE ==> end-of-file reached last time	    */
static flagType fBof	;   /* TRUE ==> begin-of-file reached last time     */
char   CurFile[] = ""	;   /* Current file to Z			    */


/****************************************************************************
 *									    *
 *  openZFile() 							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals pFile, fEof, fBof, col, line, numCols, numLines     *
 *	and LineBuf							    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Opens the current file.  This must be called before trying to read  *
 *	the file.  This is not a true "open" because it need not be closed  *
 *									    *
 ****************************************************************************/

void openZFile ()
{
    COL x;
    LINE y;

	GetTextCursor ((COL far *)&x, (LINE far *)&y);

				/* Get Z handle for current file	    */
	pFile	 = FileNameToHandle (CurFile, CurFile);
	fEof	 = FALSE;	/* We haven't read the end of file          */
	fBof	 = FALSE;	/* We haven't read the beginning of file    */
	col	 = x;		/* We start where Z is now in the file	    */
	line	 = y;		/* We start where Z is now in the file	    */
				/* We pre-read the current line 	    */
	numCols  = GetLine (line, (char far *)LineBuf, pFile);
				/* We find the length of file (in lines)    */
	numLines = FileLength (pFile);
}


/****************************************************************************
 *									    *
 *  rgetc ()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Next character in file, not including line terminators.  EOF if     *
 *	there are no more.						    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals col, numCols, numLines, LineBuf, fEof, fBof and     *
 *	line.								    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Advances current file position to the right, then returns the	    *
 *	character found there.	Reads through blank lines if necessary	    *
 *									    *
 ****************************************************************************/

int
rgetc ()
{

    if (fEof)  return (int)EOF; /* We already hit EOF last time 	    */

    if (++col >= numCols)   /* If next character is on the next line ...    */
    {
			    /* ... get next non-blank line (or EOF)	    */
	while ( ++line < numLines  &&
		!(numCols = GetLine (line, (char far *)LineBuf, pFile)));

	if (line >= numLines)
	{		    /* Oh, no more lines			    */
	    fEof = TRUE;
	    return (int)EOF;
	}

	col = 0;	    /* We got a line, so start in column 0	    */
    }

    fBof = FALSE;	    /* We got something, so we can't be at BOF      */
    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  ngetc()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Character at current position.	EOF or BOF if we are at end or top  *
 *	of file.							    *
 *									    *
 ****************************************************************************/

int
ngetc()
{
    if (fEof) return (int)EOF;
    if (fBof) return (int)BOF;

    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  lgetc ()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Previous character in file, not including line terminators.  EOF    *
 *	if there are no more.						    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals col, numCols, numLines, LineBuf, fEof, fBof and     *
 *	line.								    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Decrements current file position to the right, then returns the     *
 *	character found there.	Reads through blank lines if necessary	    *
 *									    *
 ****************************************************************************/

int
lgetc ()
{
    if (fBof)  return (int)BOF;  /* We already it BOF last time 		  */

    if (--col < 0)
    {			    /* If prev character is on prev line ...	     */
			    /* ... get prev non-blank line (or BOF)	     */
	while ( --line >= 0  &&
		!(numCols = GetLine (line, (char far *)LineBuf, pFile)));

	if (line < 0)
	{		    /* We're at the top of the file                  */
	    fBof = TRUE;
	    return (int)BOF;
	}

	col = numCols - 1;   /* We got a line, so start at last character    */
    }

    fEof = (int)FALSE;
    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  pos (&x, &y)							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Fills memory at *x and *y with current file position.		    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Gets the current file position.  Far pointers are needed because    *
 *	SS != DS.							    *
 *									    *
 ****************************************************************************/

void pos (fpx, fpy)
COL far *fpx;
LINE far *fpy;
{
    *fpx = col;
    *fpy = line;
}


/****************************************************************************
 *									    *
 *  WhenLoaded ()							    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Attach to ALT+P and issue sign-on message.			    *
 *									    *
 ****************************************************************************/

void PMatchWhenLoaded ()
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\zextens\tglcase.c ===
/*** tglcase.c - case toggling editor extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  Contains the tglcase function.
*
* Revision History:
*
*   28-Jun-1988 LN  Created
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/

#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>			/* prototypes for string fcns	*/
#include "zext.h"
/*
** Internal function prototypes
*/
void	 pascal 	 id	    (char *);
flagType pascal EXTERNAL tglcase    (unsigned int, ARG far *, flagType);

/*************************************************************************
**
** tglcase
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType pascal EXTERNAL tglcase (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    )
{
PFILE	pFile;				/* file handle of current file	*/
COL	xStart; 			/* left border of arg area	*/
LINE	yStart; 			/* starting line of arg area	*/
COL	xEnd;				/* right border of arg area	*/
LINE	yEnd;				/* ending line of arg area	*/
int	cbLine; 			/* byte count of current line	*/
COL	xCur;				/* current column being toggled */
char	buf[BUFLEN];			/* buffer for line being toggled*/
register char c;			/* character being analyzed	*/

	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)fMeta;

id ("");
pFile = FileNameToHandle ("", "");

switch (pArg->argType) {
/*
** For the various argument types, set up a box (xStart, yStart) - (xEnd, yEnd)
** over which the case conversion code below can operate.
*/
    case NOARG: 			/* case switch entire line	*/
	xStart = 0;
	xEnd = 256;
	yStart = yEnd = pArg->arg.noarg.y;
	break;

    case NULLARG:			/* case switch to EOL		*/
	xStart = pArg->arg.nullarg.x;
	xEnd = 32765;
	yStart = yEnd = pArg->arg.nullarg.y;
	break;

    case LINEARG:			/* case switch line range	*/
	xStart = 0;
	xEnd = 32765;
	yStart = pArg->arg.linearg.yStart;
	yEnd = pArg->arg.linearg.yEnd;
	break;

    case BOXARG:			/* case switch box		*/
	xStart = pArg->arg.boxarg.xLeft;
	xEnd   = pArg->arg.boxarg.xRight;
	yStart = pArg->arg.boxarg.yTop;
	yEnd   = pArg->arg.boxarg.yBottom;
	break;
    }
/*
** Within the range of lines yStart to yEnd, get each line, and if non-null,
** check each character. If alphabetic, replace with it's case-converted
** value. After all characters have been checked, replace line in file.
*/
while (yStart <= yEnd) {
    if (cbLine = GetLine (yStart, buf, pFile)) {
	for (xCur = xStart; (xCur <= min(cbLine, xEnd)); xCur++) {
	    c = buf[xCur];
	    if ((c >= 'A') && (c <= 'Z'))
		c += 'a'-'A';
	    else if ((c >= 'a') && (c <= 'z'))
		c += 'A'-'a';
	    buf[xCur] = c;
	    }
	PutLine (yStart++, buf, pFile);
	}
    }
return 1;
}

/*************************************************************************
**
** WhenLoaded
** Executed when extension gets loaded.
**
** Entry:
**  none
*/
void tglcaseWhenLoaded ()
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\zextens\winclip.c ===
/*** winclip.c - windows clipboard editor extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  Contains the tglcase function.
*
* Revision History:
*
*   28-Jun-1988 LN  Created
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/

#include <windows.h>
#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>                     /* prototypes for string fcns   */

#undef  pascal
#include "zext.h"

#define M_FALSE     ((flagType)0)
#define M_TRUE      ((flagType)(-1))

#define BUFLEN_MAX  (BUFLEN-1)

/*
** Internal function prototypes
*/
#ifdef DEBUG
    #define DPRINT(p) DoMessage(p)
#else
    #define DPRINT(p)
#endif

HWND ghwndClip;
HINSTANCE ghmod;
int gfmtArgType;

void DeleteArg( PFILE pFile, int argType, COL xStart, LINE yStart,
                COL xEnd, COL yEnd );

void InsertText( PFILE pFile, LPSTR pszText, DWORD dwInsMode,
                 COL xStart, LINE yStart );
flagType pascal EXTERNAL WinCutCopy (ARG *pArg, flagType fCut, flagType fClip);
LPSTR EndOfLine( LPSTR psz );
LPSTR EndOfBreak( LPSTR psz );
int ExtendLine( LPSTR psz, int cchSZ, char ch, int cchNew );

/*************************************************************************
**
** wincopy
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType
pascal
EXTERNAL
wincopy (
        unsigned int argData,       /* keystroke invoked with	*/
        ARG *pArg,                          /* argument data                */
        flagType fMeta              /* indicates preceded by meta	*/
        )
{

    return WinCutCopy( pArg, M_FALSE, M_FALSE );
}

flagType
pascal
EXTERNAL
wincut (
       unsigned int argData,       /* keystroke invoked with	*/
       ARG *pArg,                          /* argument data                */
       flagType fMeta              /* indicates preceded by meta	*/
       )
{

    return WinCutCopy( pArg, M_TRUE, fMeta );
}

flagType
pascal
EXTERNAL
WinCutCopy (
           ARG *pArg,
           flagType fCut,
           flagType fNoClip
           )
{
    PFILE   pFile;                          /* file handle of current file  */
    COL xStart, xEnd;
    LINE yStart, yEnd;
    char achLine[BUFLEN];
    HANDLE hText;
    LPSTR pszText;
    int     iLine, cchLine;
    flagType fRet = M_TRUE;
    int     argSave, argType;

    pFile = FileNameToHandle ("", "");


    argSave = argType = pArg->argType;

    switch ( argType ) {
        case BOXARG:                        /* case switch box              */
            xStart = pArg->arg.boxarg.xLeft;
            xEnd   = pArg->arg.boxarg.xRight + 1;
            yStart = pArg->arg.boxarg.yTop;
            yEnd   = pArg->arg.boxarg.yBottom + 1;

            /* At this point...
             *  [xy]Start is Inclusive, [xy]End is EXCLUSIVE of the box arg
             */

#ifdef DEBUG
            wsprintf( achLine, " BoxDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
            DoMessage( achLine );
#endif
            break;

        case NOARG:
            /* convert NOARG to a STREAMARG on whole current line */
            argType = STREAMARG;
            argSave = LINEARG;
            xStart = 0;
            yStart = pArg->arg.noarg.y;
            xEnd = 0;
            yEnd = yStart + 1;
            break;

        case TEXTARG:
            /*
             * Text args are only for real text.  NumArgs and MarkArgs are
             * converted to stream or box args by the editor since we say
             * we accept NUMARG and MARKARG during initialization.
             */
            argType = STREAMARG;
            argSave = STREAMARG;
            xStart = pArg->arg.textarg.x;
            xEnd = lstrlen(pArg->arg.textarg.pText) + xStart;
            yStart = yEnd = pArg->arg.textarg.y;
            break;

        case LINEARG:                       /* case switch line range       */
            /* convert LINEARG to a STREAMARG so we don't get lots of white space*/
            argType = STREAMARG;
            xStart = 0;
            xEnd = 0;
            yStart = pArg->arg.linearg.yStart;
            yEnd = pArg->arg.linearg.yEnd + 1;
#ifdef DEBUG
            wsprintf( achLine, " LineDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
            DoMessage( achLine );
#endif

            /* At this point...
             *  [xy]Start is Inclusive, [xy]End is EXCLUSIVE of the line arg
             */

            break;

        case STREAMARG:
            /*
             * Set Start == first char pos in stream, End == first char pos
             * AFTER stream.
             */
            xStart = pArg->arg.streamarg.xStart;
            xEnd = pArg->arg.streamarg.xEnd;
            yStart = pArg->arg.streamarg.yStart;
            yEnd = pArg->arg.streamarg.yEnd;
#ifdef DEBUG
            wsprintf( achLine, " StreamDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
            DoMessage( achLine );
#endif
            break;

        default:
#ifdef DEBUG
            wsprintf( achLine, " Unknown Arg: 0x%04x", argType );
            DoMessage( achLine );
            return M_TRUE;
#endif
            return M_FALSE;
    }

    if (!fNoClip) {
        if (argType == STREAMARG) {
            int cch = 0;
            int iChar;

            for ( iLine = yStart; iLine <= yEnd; iLine++ )
                cch += GetLine (iLine, achLine, pFile) + 3;

            hText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cch);

            if (hText == NULL) {
                DoMessage( " winclip: Out of Memory" );
                return M_FALSE;
            }

            pszText = GlobalLock(hText);


            iChar = xStart;

            for ( iLine = yStart; iLine < yEnd; iLine++ ) {
                cchLine = GetLine (iLine, achLine, pFile);

                /* Incase we start after the end of the line */
                if (cchLine < iChar)
                    cch = 0;
                else
                    cch = cchLine - iChar;

                CopyMemory(pszText, &achLine[iChar], cch);
                pszText += cch;
                strcpy( pszText, "\r\n" );
                pszText += 2;
                iChar = 0;

            }

            /* Get partial last line */
            if (xEnd != 0) {
                cchLine = GetLine (iLine, achLine, pFile);

                /* if line is short, then pad it out */
                cchLine = ExtendLine( achLine, cchLine, ' ', xEnd );

                if (cchLine < iChar)
                    cchLine = 0;
                else
                    cchLine = xEnd - iChar;

                CopyMemory(pszText, &achLine[iChar], cchLine);
                pszText += cchLine;
            }

        } else {
            LINE iLine;
            int cchBox = xEnd - xStart;

            hText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                                (yEnd - yStart) * (cchBox + 3));

            if (hText == NULL) {
                DoMessage( " winclip: Out of Memory" );
                return M_FALSE;
            }

            pszText = GlobalLock(hText);

            for ( iLine = yStart; iLine < yEnd; iLine++ ) {
                cchLine = GetLine (iLine, achLine, pFile);

                if (argType == BOXARG)
                    cchLine = ExtendLine( achLine, cchLine, ' ', xEnd );

                if (cchLine < xStart )
                    cchLine = 0;
                else
                    cchLine -= xStart;

                cchLine = min(cchLine, cchBox);

                CopyMemory(pszText, &achLine[xStart], cchLine);
                pszText += cchLine;
                strcpy( pszText, "\r\n" );
                pszText += 2;

            }
        }

        *pszText = '\0';

        GlobalUnlock(hText);

        if (OpenClipboard(ghwndClip)) {
            EmptyClipboard();

            /*
             * Set the text into the clipboard
             */
            if (SetClipboardData(CF_TEXT, hText) == hText) {
                /*
                 * Remember the Arg type for pasting back
                 */
                if (gfmtArgType != 0) {
                    DWORD *pdw;
                    HANDLE hArgType = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                                                  sizeof(DWORD));

                    if (hArgType != NULL && (pdw = GlobalLock(hArgType)) != NULL) {
                        *pdw = (DWORD)(argSave);

                        GlobalUnlock(hArgType);

                        SetClipboardData(gfmtArgType, hArgType);
                    }
                }
            } else {
                /* An error occured writing text to clipboard */

                wsprintf(achLine, " winclip: Error (%ld) setting data",
                         GetLastError());
                DoMessage( achLine );
                fRet = M_FALSE;
            }

            CloseClipboard();
        }
    }

    /*
     * No need to free the handle, USER32 will do it (yes it keeps
     * track of the client side handle) when we set the next clipboard
     * data.  (Love that Win3.1 compatibility!)
     */
    if (fRet && fCut)
        DeleteArg( pFile, argType, xStart, yStart, xEnd, yEnd );


    return fRet;
}

/*************************************************************************
**
** winpaste
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType
pascal
EXTERNAL
winpaste (
         unsigned int argData,       /* keystroke invoked with	*/
         ARG *pArg,                          /* argument data                */
         flagType fMeta              /* indicates preceded by meta	*/
         )
{
    PFILE   pFile;                          /* file handle of current file  */
    COL xStart, xEnd;
    LINE yStart, yEnd;
    int argType;
    UINT fmtData = CF_TEXT;
    DWORD dwInsMode = STREAMARG;
    HANDLE hText;
    LPSTR pszText;

    /*
     * Get the clipboard text and insertion type
     */
    if (pArg->argType == TEXTARG) {
        int i, j;
        char achLine[3 + 1 + 3 + 1 + 1 + BUFLEN + 1 + 1 + 5 + 1];
        char *p;

        /*
         * Quick hack to make text arg pastes work like the do in Z
         */
        j = pArg->arg.textarg.cArg;
        if (j > 2)
            j = 2;

        achLine[0] = '\0';
        for ( i = 0; i < j; i++ )
            lstrcat(achLine, "arg ");

        p = achLine + lstrlen(achLine);
        wsprintf( p, "\"%s\" paste", pArg->arg.textarg.pText );
        return fExecute( achLine );
    }

    /* if no text then return FALSE */
    if (!IsClipboardFormatAvailable(fmtData)) {

        /* No text, try display text */
        fmtData = CF_DSPTEXT;

        if (!IsClipboardFormatAvailable(fmtData)) {
            /* bummer! no text at all, return FALSE */
            DoMessage( " winclip: invalid clipboard format" );
            return M_FALSE;
        }
    }

    if (!OpenClipboard(ghwndClip))
        return M_FALSE;

    hText = GetClipboardData(fmtData);
    if (hText == NULL || (pszText = GlobalLock(hText)) == NULL) {
        CloseClipboard();
        return M_FALSE;
    }


    /* Get insert mode */

    if (IsClipboardFormatAvailable(gfmtArgType)) {
        DWORD *pdw;
        HANDLE hInsMode;

        hInsMode = GetClipboardData(gfmtArgType);

        if (hInsMode != NULL && (pdw = GlobalLock(hInsMode)) != NULL) {
            dwInsMode = *pdw;

            GlobalUnlock(hInsMode);
        }
    }



    pFile = FileNameToHandle ("", "");

    argType = pArg->argType;

    switch ( argType ) {
        case BOXARG:                        /* case switch box              */
            /*
             * Set [xy]Start inclusive of box arg,
             *     [xy]End   exclusive of box arg.
             */
            xStart = pArg->arg.boxarg.xLeft;
            xEnd   = pArg->arg.boxarg.xRight + 1;
            yStart = pArg->arg.boxarg.yTop;
            yEnd   = pArg->arg.boxarg.yBottom + 1;
            break;

        case LINEARG:           /* case switch line range	*/
            /*
             * Set [xy]Start inclusive of line arg,
             *     [xy]End   exclusive of line arg.
             */
            xStart = 0;
            xEnd = BUFLEN + 1;
            yStart = pArg->arg.linearg.yStart;
            yEnd = pArg->arg.linearg.yEnd + 1;
            break;

        case STREAMARG:
            /*
             * Set [xy]Start inclusive of stream
             *     xEnd is EXCLUSIVE of stream
             *     yEnd is INCLUSIVE of stream
             */
            xStart = pArg->arg.streamarg.xStart;
            xEnd = pArg->arg.streamarg.xEnd;
            yStart = pArg->arg.streamarg.yStart;
            yEnd = pArg->arg.streamarg.yEnd;
            break;

        case NOARG:
            xStart = pArg->arg.noarg.x;
            xEnd = xStart + 1;
            yStart = pArg->arg.noarg.y;
            yEnd = yStart + 1;
            break;

        default:
            GlobalUnlock(hText);
            CloseClipboard();
            return M_FALSE;
    }


    /*
     * Delete any selection
     */
    DeleteArg( pFile, argType, xStart, yStart, xEnd, yEnd );

    /*
     * Insert new text with correct mode
     */
    InsertText( pFile, pszText, dwInsMode, xStart, yStart );

    GlobalUnlock(hText);
    CloseClipboard();

    return M_TRUE;
}

/*************************************************************************
**
** windel
**
**
*/
flagType
pascal
EXTERNAL
windel (
       unsigned int argData,               /* keystroke invoked with       */
       ARG *pArg,                          /* argument data                */
       flagType fMeta                      /* indicates preceded by meta   */
       )
{
    int argType = pArg->argType;

    if (argType == NOARG)
        return fExecute("delete");

    if (argType == NULLARG) {
        int c, x, y;
        c = pArg->arg.nullarg.cArg;
        x = pArg->arg.nullarg.x;
        y = pArg->arg.nullarg.y;

        pArg->argType = STREAMARG;
        pArg->arg.streamarg.xStart = x;
        pArg->arg.streamarg.xEnd = 0;
        pArg->arg.streamarg.yStart = y;
        pArg->arg.streamarg.yEnd = y + 1;
        pArg->arg.streamarg.cArg = c;
    }

    return WinCutCopy (pArg, M_TRUE, fMeta);
}

/*************************************************************************
**
** WhenLoaded
** Executed when extension gets loaded. Identify self & assign default
** keystroke.
**
** Entry:
**  none
*/
void
winclipWhenLoaded ()
{
#if 0
    WNDCLASS wc;

    ghmod = GetModuleHandle(NULL);

    wc.style = 0;
    wc.lpfnWndProc = (WNDPROC)DefWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = ghmod;
    wc.hIcon = NULL;
    wc.hCursor =  NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;   /* Name of menu resource in .RC file. */
    wc.lpszClassName = "WinClipWClass"; /* Name used in call to CreateWindow. */

    if (RegisterClass(&wc) && (ghwndClip = CreateWindow( "WinClipWClass",
                                                         "ClipWindow", WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, NULL, NULL,
                                                         ghmod, NULL)) == NULL ) {
        DoMessage( " winclip: Initialization failed!" );
    }
#else
    ghwndClip = NULL; //assign clipboard to this thread instead
#endif

    gfmtArgType = RegisterClipboardFormat( "Z Arg Type" );
}


void
DeleteArg(
         PFILE pFile,
         int argType,
         COL xStart,
         LINE yStart,
         COL xEnd,
         COL yEnd
         )
{

    switch ( argType ) {

        case STREAMARG:
            DelStream(pFile, xStart, yStart, xEnd, yEnd);
            break;

        case LINEARG:
            DelStream(pFile, 0, yStart, 0, yEnd);
            break;


        case BOXARG: {
                LINE iLine;

                for ( iLine = yStart; iLine < yEnd; iLine++ ) {
                    DelStream( pFile, xStart, iLine, xEnd, iLine );
                }

                break;
            }


        default:
            break;
    }
}




void
InsertText(
          PFILE pFile,
          LPSTR pszText,
          DWORD dwInsMode,
          COL xStart,
          LINE yStart
          )
{
    char ch;
    int  cchLine, cchText, cchCopy;
    LPSTR pszNL;
    char achLine[BUFLEN];
    char achEnd[BUFLEN];

    switch ( dwInsMode ) {
        case STREAMARG:
            /*
             * Split current line,
             * tack first line from buffer to end of new line
             * put the new lines in file
             * shove the last line to the beggining of the 2nd half of the line
             */
            DPRINT( "  Stream Paste" );
            if ( *pszText == '\0' )
                break;


            pszNL = EndOfLine(pszText);

            cchLine = GetLine( yStart, achLine, pFile );

            if (cchLine < xStart)
                cchLine = ExtendLine( achLine, cchLine, ' ', xStart );

            cchText = (int)(pszNL - pszText);
            if (xStart + cchText >= BUFLEN_MAX) {
                cchText = BUFLEN_MAX - xStart;
                pszNL = pszText + cchText;
            }

            strcpy( achEnd, &achLine[xStart] );
            cchLine -= xStart;

            CopyMemory( &achLine[xStart], pszText, cchText );
            cchText += xStart;
            achLine[cchText] = '\0';


            while ( *pszNL ) {
                PutLine( yStart++, achLine, pFile );
                CopyLine( NULL, pFile, 0, 0, yStart );

                pszText = EndOfBreak(pszNL);
                pszNL = EndOfLine(pszText);

                cchText = (int)(pszNL - pszText);

                CopyMemory( achLine, pszText, cchText );
                achLine[cchText] = '\0';
            }

            cchCopy = 0;
            if (cchLine + cchText > BUFLEN_MAX) {
                cchCopy = (cchLine + cchText) - BUFLEN_MAX;
                cchLine = cchLine - cchCopy;
            }

            CopyMemory( &achLine[cchText], achEnd, cchLine );
            achLine[cchLine+cchText] = '\0';
            PutLine( yStart++, achLine, pFile );

            if (cchCopy != 0) {
                CopyLine( NULL, pFile, 0, 0, yStart );
                CopyMemory( achLine, &achEnd[cchLine], cchCopy );
                achLine[cchCopy] = '\0';
                PutLine( yStart++, achLine, pFile);
            }
            break;

        case BOXARG:
            /*
             * Insert the text as a block into the middle of each line.
             * This could be tricky since we need to pad all short lines
             * out with spaces to match the lenght of the longest line
             * in the text.
             */

            DPRINT( "  Box Paste" );
            while ( *pszText ) {
                pszNL = EndOfLine(pszText);

                cchLine = GetLine( yStart, achLine, pFile );

                if (cchLine < xStart)
                    cchLine = ExtendLine( achLine, cchLine, ' ', xStart );

                cchText = (int)(pszNL - pszText);
                if (cchLine + cchText > BUFLEN_MAX)
                    cchText = BUFLEN_MAX - cchLine;

                /* insert text in middle of line */
                strcpy( achEnd, &achLine[xStart] );
                CopyMemory( &achLine[xStart], pszText, cchText );
                strcpy( &achLine[xStart + cchText], achEnd );

                /* put line in file */
                PutLine( yStart++, achLine, pFile );

                pszText = EndOfBreak(pszNL);
            }
            break;

        case LINEARG:
            /*
             * shove the lines in the buffer before the current line
             */
            DPRINT( "  Line Paste" );
            while ( *pszText ) {
                pszNL = EndOfLine(pszText);
                ch = *pszNL;
                *pszNL = '\0';
                CopyLine( NULL, pFile, 0, 0, yStart );
                PutLine( yStart++, pszText, pFile);
                *pszNL = ch;
                pszText = EndOfBreak(pszNL);
            }
            break;

        default:
            break;
    }

}


LPSTR
EndOfLine(
         LPSTR psz
         )
{
    int c;

    c = 0;
    while ( *psz && *psz != '\r' && *psz != '\n' && c++ < BUFLEN_MAX )
        psz++;

    return psz;
}

LPSTR
EndOfBreak(
          LPSTR psz
          )
{
    char chSkip;

    switch ( *psz ) {
        case '\r':
            chSkip = '\n';
            break;

        case '\n':
            chSkip = '\r';
            break;

        default:
            return psz;

    }

    if (*(++psz) == chSkip)
        psz++;

    return psz;
}


int
ExtendLine(
          LPSTR psz,
          int cchLine,
          char ch,
          int cchTotal
          )
{

    if ( cchLine >= cchTotal )
        return cchLine;

    if (cchTotal > BUFLEN_MAX)
        cchTotal = BUFLEN_MAX;

    psz = &psz[cchLine];

    while ( cchLine++ < cchTotal )
        *psz++ = ch;

    *psz = '\0';

    return cchLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\cmds.h ===
/***  CMDS.H
*
*       Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   18-Aug-1988 bw  Initial version, stripped from KEY.C and KEYCW.C
*   07-Sep-1988 bw  Add RECORD_PLAYBACK stuff
*   26-Sep-1988 bp  Add <topfile>, <endfile> and <message>
*   26-Sep-1988 bp  Modified syntax (1+x vs x+1)  to reduce nesting in macro expansion
*   11-Oct-1988 bw  Add <selcur> to CW version
*   17-Oct-1988 bw  Add <record>
*   14-Oct-1988 ln  Add <nextmsg>
*   18-Oct-1988 bw  Add <tell>
*   18-Oct-1988 ln  Add <debugmode>
*   24-Oct-1988 bw  Add <noedit>
*   24-Oct-1988 bw  Add <lastselect>
*   26-Oct-1988 bp  Add <print>
*   27-Oct-1988 bp  Change  <topfile> to <begfile>
*   21-Nov-1988 bp  Add <saveall>
*   01-Dec-1988 bw  Add <resize>
*   10-Dec-1988 bp  Add <repeat>
*   14-Dec-1988 ln  Add <mgrep>
*   16-Dec-1988 ln  Add <mreplace>
*   04-Jan-1989 bp  Add <menukey>
*   11-Jan-1989 ln  Zoom->maximize
*   17-Jan-1989 bw  Add <selmode> in CW version
*   30-Jan-1989 bw  Remove <dumpscreen> (replaced with ScrollLock Key)
*   15-Feb-1989 bp  Add <prompt>
*
*  WARNING -- it is important that the ordering here reflects EXACTLY the
*  ordering in the cmdDesc table in table.c
*
*************************************************************************/


#define CMD_doarg           (PCMD)&cmdTable[0]
#define CMD_assign          1 + CMD_doarg
#define CMD_backtab         2 + CMD_doarg
#define CMD_begfile         3 + CMD_doarg
#define CMD_begline         4 + CMD_doarg
#define CMD_boxstream       5 + CMD_doarg
#define CMD_cancel          6 + CMD_doarg
#define CMD_cdelete         7 + CMD_doarg
#define CMD_compile         8 + CMD_doarg
#define CMD_zpick           9 + CMD_doarg
#define CMD_curdate        10 + CMD_doarg
#define CMD_curday         11 + CMD_doarg
#define CMD_curtime        12 + CMD_doarg
#define CMD_delete         13 + CMD_doarg
#define CMD_down           14 + CMD_doarg
#define CMD_emacscdel      15 + CMD_doarg
#define CMD_emacsnewl      16 + CMD_doarg
#define CMD_endfile        17 + CMD_doarg
#define CMD_endline        18 + CMD_doarg
#define CMD_environment    19 + CMD_doarg
#define CMD_zexecute       20 + CMD_doarg
#define CMD_zexit          21 + CMD_doarg
#define CMD_graphic        22 + CMD_doarg
#define CMD_home           23 + CMD_doarg
#define CMD_information    24 + CMD_doarg
#define CMD_zinit          25 + CMD_doarg
#define CMD_insert         26 + CMD_doarg
#define CMD_insertmode     27 + CMD_doarg
#define CMD_lastselect     28 + CMD_doarg
#define CMD_textarg        29 + CMD_doarg
#define CMD_ldelete        30 + CMD_doarg
#define CMD_left           31 + CMD_doarg
#define CMD_linsert        32 + CMD_doarg
#define CMD_mark           33 + CMD_doarg
#define CMD_message        34 + CMD_doarg
#define CMD_meta           35 + CMD_doarg
#define CMD_mgrep          36 + CMD_doarg
#define CMD_mlines         37 + CMD_doarg
#define CMD_mpage          38 + CMD_doarg
#define CMD_mpara          39 + CMD_doarg
#define CMD_mreplace       40 + CMD_doarg
#define CMD_msearch        41 + CMD_doarg
#define CMD_mword          42 + CMD_doarg
#define CMD_newline        43 + CMD_doarg
#define CMD_nextmsg        44 + CMD_doarg
#define CMD_noedit         45 + CMD_doarg
#define CMD_noop           46 + CMD_doarg
#define CMD_put            47 + CMD_doarg
#define CMD_pbal           48 + CMD_doarg
#define CMD_plines         49 + CMD_doarg
#define CMD_ppage          50 + CMD_doarg
#define CMD_ppara          51 + CMD_doarg
#define CMD_zprint         52 + CMD_doarg
#define CMD_prompt         53 + CMD_doarg
#define CMD_psearch        54 + CMD_doarg
#define CMD_pword          55 + CMD_doarg
#define CMD_qreplace       56 + CMD_doarg
#define CMD_quote          57 + CMD_doarg
#define CMD_record         58 + CMD_doarg
#define CMD_refresh        59 + CMD_doarg
#define CMD_repeat         60 + CMD_doarg
#define CMD_replace        61 + CMD_doarg
#define CMD_restcur        62 + CMD_doarg
#define CMD_right          63 + CMD_doarg
#define CMD_saveall        64 + CMD_doarg
#define CMD_savecur        65 + CMD_doarg
#define CMD_savetmp        66 + CMD_doarg
#define CMD_sdelete        67 + CMD_doarg
#define CMD_searchall      68 + CMD_doarg
#define CMD_setfile        69 + CMD_doarg
#define CMD_setwindow      70 + CMD_doarg
#define CMD_zspawn         71 + CMD_doarg
#define CMD_sinsert        72 + CMD_doarg
#define CMD_tab            73 + CMD_doarg
#define CMD_tell           74 + CMD_doarg
#define CMD_unassigned     75 + CMD_doarg
#define CMD_undo           76 + CMD_doarg
#define CMD_up             77 + CMD_doarg
#define CMD_window         78 + CMD_doarg
#define CMD_focus          79 + CMD_doarg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\extint.h ===
/*** extint.h - include for for internal extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains definitions required by extensions which are internal to Microsoft
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#if defined(CW)
#if !defined(EDITOR)
#define CC 1				/* use a real C compiler	*/
#define cwExtraWnd  5			/* number of extra bytes in PWND*/
#define DLG_CONST			/* are dialogs type const?	*/
#define HELP_BUTTON

#include <cwindows.h>			/* CW definitions		*/
#include <csdm.h>			/* SDM definitions		*/
#include <csdmtmpl.h>			/* SDM dialog template stuff	*/

#define EXTINT	1			/* extint included.		*/
#include "ext.h"			/* real ext.h			*/

#include "menu.h"			/* menu id's & other defs       */
#endif

/************************************************************************
*
*  types and globals needed for handling menu command and dialog boxes.
*  DLGDATA holds all the info needed to handle a dialog boxed menu
*  command.
*
*************************************************************************/
typedef struct DlgData {
    DLG * pDialog;	/* Dialog Template			    */
    int     cbDialog;	    /* size of that template			*/
    WORD    cabi;	    /* CAB index				*/
    flagType (*pfnCab)(HCAB, flagType, TMC); /* massager*/
    } DLGDATA;
#endif

/************************************************************************
*
*  Additional exports.
*
*************************************************************************/
#ifndef EDITOR
TMC		    PerformDialog   (DLGDATA *);
void		    DlgHelp	    (int);
void		    DoEnableTmc     (TMC, BOOL);
flagType	    DoSetDialogCaption	(char *);
void		    DoSzToCab	    (unsigned, char *, WORD);
char *		    DoSzFromCab     (unsigned, char *, WORD, WORD);
void		    DoGetTmcText    (TMC, char *, WORD);
WORD		    DoGetTmcVal     (TMC);
void		    DoSetTmcListWidth (TMC, WORD);
void		    DoSetTmcText    (TMC, char *);
void		    DoSetTmcVal     (TMC, WORD);
void		    DoRedisplayListBox (TMC);
void		    DoTmcListBoxAddString (TMC, char *, BOOL);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\extens\zextens\ulcase.c ===
/*
** ULcase Z extension
**
** History:
**  30-Mar-1988     Broken out of "myext"
**  12-Sep-1988 mz  Made WhenLoaded match declaration
*/
#include <ctype.h>

#include "zext.h"

#ifndef TRUE
#define TRUE    -1
#define FALSE   0
#endif

#ifndef NULL
#define NULL    ((char *) 0)
#endif

flagType pascal ulcase (ARG *, int, int, int);

/*************************************************************************
**
** ucase
** convert arg to upper case.
*/
flagType pascal EXTERNAL
ucase (
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{

(void)argData;
(void)fMeta;
return ulcase (pArg, 'a', 'z', 'A'-'a');
}

/*************************************************************************
**
** lcase
** convert arg to lower case.
*/
flagType pascal EXTERNAL
lcase (
    CMDDATA  argData,
    ARG far *pArg,
    flagType fMeta
    )
{
(void)argData;
(void)fMeta;
return ulcase (pArg, 'A', 'Z', 'a'-'A');
}

/*
** ulcase
** convert arg case.
*/
flagType pascal ulcase (pArg, cLow, cHigh, cAdj)
ARG *pArg;                          /* argument data                */
int     cLow;                           /* low char of range to check for */
int     cHigh;                          /* high char of range to check for */
int     cAdj;                           /* adjustment to make           */
{
PFILE   pFile;
COL     xStart;
LINE    yStart;
COL     xEnd;
LINE    yEnd;
int     i;
COL     xT;
char    buf[BUFLEN];


pFile = FileNameToHandle ("", "");

switch (pArg->argType) {

    case NOARG:                                 /* case switch entire line */
        xStart = 0;
        xEnd = 32765;
        yStart = yEnd = pArg->arg.noarg.y;
        break;

    case NULLARG:                               /* case switch to EOL   */
        xStart = pArg->arg.nullarg.x;
        xEnd = 32765;
        yStart = yEnd = pArg->arg.nullarg.y;
        break;

    case LINEARG:                               /* case switch line range */
        xStart = 0;
        xEnd = 32765;
        yStart = pArg->arg.linearg.yStart;
        yEnd = pArg->arg.linearg.yEnd;
        break;

    case BOXARG:                                /* case switch box      */
        xStart = pArg->arg.boxarg.xLeft;
        xEnd   = pArg->arg.boxarg.xRight;
        yStart = pArg->arg.boxarg.yTop;
        yEnd   = pArg->arg.boxarg.yBottom;
        break;
    }

while (yStart <= yEnd) {
    i = GetLine (yStart, buf, pFile);
    xT = xStart;                                /* start at begin of box*/
    while ((xT <= i) && (xT <= xEnd)) {         /* while in box         */
        if ((int)buf[xT] >= cLow && (int)buf[xT] <= cHigh)
            buf[xT] += (char)cAdj;
        xT++;
        }
    PutLine (yStart++, buf, pFile);
    }

return TRUE;
}

/*
** WhenLoaded
** Executed when these extensions get loaded.
*/
void ulcaseWhenLoaded () {
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\msg.h ===
#define	MSGERR_INV_ARG	8001
#define	MSGERR_ARG_REQ	8002
#define	MSGERR_NOEDIT	8003
#define	MSGERR_NOREP	8004
#define	MSGERR_NOCREAT	8005
#define	MSGERR_OPEN	8006
#define	MSGERR_RONLY	8007
#define	MSGERR_SPACE	8008
#define	MSGERR_DEL	8009
#define	MSGERR_REN	8010
#define	MSGERR_OLDVER	8011
#define	MSGERR_SAVEDIR	8012
#define	MSGERR_STFILE	8013
#define	MSGERR_UNDO	8014
#define	MSGERR_REDO	8015
#define	MSGERR_ITHREAD	8016
#define	MSGERR_CTHREAD	8017
#define	MSGERR_PTHREAD	8018
#define	MSGERR_TOOLS	8019
#define	MSGERR_ZFORMAT	8020
#define	MSGERR_ZTELL	8021
#define	MSGERR_CMPCMD	8022
#define	MSGERR_CMPCMD2	8023
#define	MSGERR_CMPFULL	8024
#define	MSGERR_CMPCANT	8025
#define	MSGERR_CMPSRC	8026
#define	MSGERR_PRTFULL	8027
#define MSGERR_PRTCANT  8028
#define MSGERR_NOMEM    8029
#define MSGERR_QUIT     8030
#define	MSG_ASSIGN_HDR	9001
#define	MSG_SWITCH_HDR	9025
#define	MSG_KEYS_HDR1	9050
#define	MSG_KEYS_HDR2	9054
#define	MSG_ASG_FUNC	9061
#define	MSG_ASG_MACROS	9062
#define	MSG_ASG_NUMER	9063
#define	MSG_ASG_BOOL	9064
#define	MSG_ASG_TEXT	9065
#define	MSG_ASG_CLIP	9066
#define	MSG_ASG_LINES	9067
#define	MSG_ASG_PAGES	9068
#define	MSG_PRESS_ANY	10000
#define	MSG_ARGCOUNT	10001
#define	MSG_NEXTFILE	10002
#define	MSG_SAVING	10003
#define	MSG_TELLPROMPT	10004
#define	MSG_SAVEALL	10005
#define	MSG_SAVEONE	10006
#define	MSG_QUEUED	10007
#define	MSG_CMPDONE	10008
#define	MSG_PRINTING	10009
#define	MSG_SCANFILE	10010
#define	MSG_ASN_MISS	10100
#define	MSG_ASN_MISSK	10101
#define	MSG_ASN_UNKKEY	10102
#define	MSG_ASN_INUSE	10103
#define	MSG_ASN_MROOM	10104
#define	MSG_ASN_NOTSWI	10105
#define	MSG_ASN_ILLSET	10106
#define	MSG_ASN_WINCHG	10107
#define	MSG_ASN_UNSUP	10108
#define	MSG_ASN_INVAL	10109
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\version.h ===
#define rmj		2
#define rmm		0
#define rup		0
#define szVerName	"( Windows NT )"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\mouse.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mouse.h

Abstract:

    Mouse management for MEP

Author:

    Ramon Juan San Andres (ramonsa) 07-Nov-1991


Revision History:


--*/


//
//  Mouse flags
//
#define MOUSE_CLICK_LEFT      0x0001
#define MOUSE_CLICK_RIGHT     0x0002
#define MOUSE_DOUBLE_CLICK    0x0010


//
//  The Mouse handler
//
void DoMouse( ROW Row, COLUMN Col, DWORD MouseFlags );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\keys.h ===
/* Virtual Keys, Standard Set  =*/


EDITOR_KEY    TranslateKey    (KBDKEY KbdKey);
flagType      KeyCodeToKeyEvent (WORD Code, PKEY_EVENT_RECORD pKeyEvent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\keyboard.h ===
void            InitKeyboard ( void );
BOOL            TypeAhead       ( void );
KBDKEY          ReadChar        ( void );

void		    KbHook	    ( void );
void		    KbUnHook	    ( void );
KBDMODE 	    KbGetMode	    ( void );
void		    KbSetMode	    ( KBDMODE Mode );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\menu.h ===
/*** menu.h  - macros and constants for menu.c
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#if !defined(CW)
# error This module must be compiled with /DCW
#else

#define DLG_CONST

/****************************************************************************
 *									    *
 * Editor constants							    *
 *									    *
 *  C_MENUSTRINGS_MAX							    *
 *  C_CITEM_MAX 							    *
 *									    *
 ****************************************************************************/

#define C_MENUSTRINGS_MAX 128
#define C_ITEM_MAX	  21


/****************************************************************************
 *									    *
 * Actions associated with menu items					    *
 *									    *
 * Each menu item keeps a value in bParamUser that tells wich kind of action*
 * it is associated with (dialog box, command, macro or "other") and gives  *
 * an index to the associated table (DialogData, CommandData or MacroData). *
 *									    *
 ****************************************************************************/

/*
 * COMDATA structure used for menu items directly relating to editor commands
 */
typedef struct comData {
    PCMD     pCmd;			 /* pointer to command	       */
    flagType fKeepArg;			 /* arg to be used or not      */
    };

/*
 * Mask to get the menu item type
 */
#define iXXXMENU	0xC0

/*
 * Menu item action types
 */
#define iDLGMENU	0x00
#define iCOMMENU	0x40
#define iMACMENU	0x80
#define iOTHMENU	0xC0

/*
 * CommandData indices for menu items directly relating to editor commands
 */
#define iCOMNEXT	iCOMMENU		/*  0 */
#define iCOMSAVEALL	(1 + iCOMNEXT)		/*  1 */
#define iCOMSHELL	(1 + iCOMSAVEALL)	/*  2 */
#define iCOMUNDO	(1 + iCOMSHELL) 	/*  3 */
#define iCOMREPEAT	(1 + iCOMUNDO)		/*  0 */
#define iCOMCUT 	(1 + iCOMREPEAT)	/*  0 */
#define iCOMCOPY	(1 + iCOMCUT)		/*  4 */
#define iCOMPASTE	(1 + iCOMCOPY)		/*  0 */
#define iCOMDROPANCHOR	(1 + iCOMPASTE) 	/*  5 */
#define iCOMANCHOR	(1 + iCOMDROPANCHOR)	/*  0 */
#define iCOMBOXMODE	(1 + iCOMANCHOR)	/*  0 */
#define iCOMREADONLY	(1 + iCOMBOXMODE)	/*  6 */
#define iCOMFINDSEL	(1 + iCOMREADONLY)	/*  0 */
#define iCOMFINDLAST	(1 + iCOMFINDSEL)	/*  7 */
#define iCOMNEXTERR	(1 + iCOMFINDLAST)	/*  8 */
#define iCOMDEBUGBLD	(1 + iCOMNEXTERR)	/*  9 */
#define iCOMRECORD	(1 + iCOMDEBUGBLD)	/* 10 */
#define iCOMRESIZE	(1 + iCOMRECORD)	/* 11 */
#define iCOMMAXIMIZE	(1 + iCOMRESIZE)	/* 12 */

/*
 * MacroData indices for menu items directly relating to pre-defined macros
 */
#define iMACSAVE	iMACMENU		/*  0 */
#define iMACQUIT	(1 + iMACSAVE)		/*  1 */
#define iMACREDO	(1 + iMACQUIT)		/*  2 */
#define iMACCLEAR	(1 + iMACREDO)		/*  3 */
#define iMACPREVERR	(1 + iMACCLEAR) 	/*  4 */
#define iMACSETERR	(1 + iMACPREVERR)	/*  5 */
#define iMACCLEARLIST	(1 + iMACSETERR)	/*  6 */
#define iMACERRWIN	(1 + iMACCLEARLIST)	/*  7 */
#define iMACHSPLIT	(1 + iMACERRWIN)	/*  8 */
#define iMACVSPLIT	(1 + iMACHSPLIT)	/*  9 */
#define iMACCLOSE	(1 + iMACVSPLIT)	/* 10 */
#define iMACASSIGNKEY	(1 + iMACCLOSE) 	/* 11 */
#define iMACRESTORE	(1 + iMACASSIGNKEY)	/* 12 */



/****************************************************************************
 *									    *
 * Menu items with variable content and/or meaning: We store their set of   *
 * data in an ITEMDATA structure and do the update with the UPDITEM macro   *
 *									    *
 ****************************************************************************/

/*
 * ITEMDATA structure used for menu items with variable content and/or meaning
 */
typedef struct {
    BYTE ichHilite;
    BYTE bParamUser;
    WORD wParamUser;
    } ITEMDATA, *PITEMDATA;

/*
 *  UPDITEM (pItem, pItemData)
 *
 *  Where:
 *	pItem	    is an object of type PMENUITEM
 *	pItemData   is an object of type PITEMDATA
 *
 *  Will update Item with ItemData data:
 *
 *	pItem->ichHilite	with pItemData->ichHilite
 *	pItem->bParamUser	with pItemData->bParamUser
 *	pItem->wParamUser	with pItemData->wParamUser
 */
#define UPDITEM(pItem, pItemData) \
    (pItem)->ichHilite	= (pItemData)->ichHilite, \
    (pItem)->bParamUser = (pItemData)->bParamUser,\
    (pItem)->wParamUser = (pItemData)->wParamUser


/****************************************************************************
 *									    *
 * Prdefined Menus and Menuitems data					    *
 *									    *
 * Note:								    *
 *									    *
 *  MENU ID's are comprised of two parts:                                   *
 *									    *
 *    . The high byte identifies the parent menu			    *
 *    . The low byte identifies the actual menu item.			    *
 *									    *
 *  The low byte - 1 can be used as an index into the respective menu	    *
 *  tables providing that the item is in the STATIC part of the menu	    *
 *									    *
 *  For the 'dynamic' part of certain predefined menus, we use id's with    *
 *  low byte values with high bit set. This allow us to still use the low   *
 *  byte as an index for any extension-supplied items we might insert	    *
 *  between the static part and the dynamic part.			    *
 *									    *
 *  Menus with dynamic parts are the File and Run menus (for now..)	    *
 *									    *
 ****************************************************************************/

/*
 * File Menu
 *
 * Note: Alternate files items are dynamic
 *
 */
#define MID_FILE    0x0000
#define RX_FILE     2
#define ICH_FILE    0
#define CCH_FILE    4
#define CCIT_FILE   12
#define WP_FILE     ((12<<9)|(21<<4)|0)

#define MID_NEW 	(MID_FILE + 1)
#define MID_OPEN	(MID_FILE + 2)
#define MID_MERGE	(MID_FILE + 3)
#define MID_NEXT	(MID_FILE + 4)
#define MID_SAVE	(MID_FILE + 5)
#define MID_SAVEAS	(MID_FILE + 6)
#define MID_SAVEALL	(MID_FILE + 7)

#define MID_PRINT	(MID_FILE + 9)
#define MID_SHELL	(MID_FILE + 10)

#define MID_EXIT	(MID_FILE + 12)

#define MID_FILE1	(MID_FILE + 0x80 + 0)
#define MID_FILE2	(MID_FILE + 0x80 + 1)
#define MID_FILE3	(MID_FILE + 0x80 + 2)
#define MID_FILE4	(MID_FILE + 0x80 + 3)
#define MID_FILE5	(MID_FILE + 0x80 + 4)
#define MID_FILE6	(MID_FILE + 0x80 + 5)
#define MID_FILE7	(MID_FILE + 0x80 + 6)
#define MID_MORE	(MID_FILE + 0x80 + 7)


/*
 * Edit Menu
 */
#define MID_EDIT    0x0100
#define RX_EDIT     8
#define ICH_EDIT    0
#define CCH_EDIT    4
#define CCIT_EDIT   18
#define WP_EDIT     ((18<<9)|(18<<4)|1)

#define MID_UNDO	(MID_EDIT + 1)
#define MID_REDO	(MID_EDIT + 2)
#define MID_REPEAT	(MID_EDIT + 3)

#define MID_CUT 	(MID_EDIT + 5)
#define MID_COPY	(MID_EDIT + 6)
#define MID_PASTE	(MID_EDIT + 7)
#define MID_CLEAR	(MID_EDIT + 8)

#define MID_DROPANCHOR	(MID_EDIT + 10)
#define MID_ANCHOR	(MID_EDIT + 11)

#define MID_BOXMODE	(MID_EDIT + 13)
#define MID_READONLY	(MID_EDIT + 14)

#define MID_SETREC	(MID_EDIT + 16)
#define MID_RECORD	(MID_EDIT + 17)
#define MID_EDITMACROS	(MID_EDIT + 18)


/*
 * Search Menu
 */
#define MID_SEARCH    0x0200
#define RX_SEARCH     14
#define ICH_SEARCH    0
#define CCH_SEARCH    6
#define CCIT_SEARCH   14
#define WP_SEARCH     ((14<<9)|(14<<4)|2)

#define MID_FIND	(MID_SEARCH + 1)
#define MID_FINDSEL	(MID_SEARCH + 2)
#define MID_FINDLAST	(MID_SEARCH + 3)
#define MID_REPLACE	(MID_SEARCH + 4)
#define MID_FINDFILE	(MID_SEARCH + 5)

#define MID_NEXTERR	(MID_SEARCH + 7)
#define MID_PREVERR	(MID_SEARCH + 8)
#define MID_SETERR	(MID_SEARCH + 9)
#define MID_ERRWIN	(MID_SEARCH + 10)

#define MID_GOTOMARK	(MID_SEARCH + 12)
#define MID_DEFMARK	(MID_SEARCH + 13)
#define MID_SETMARK	(MID_SEARCH + 14)


/*
 * Make Menu
 */
#define MID_MAKE    0x0300
#define RX_MAKE     22
#define ICH_MAKE    0
#define CCH_MAKE    4
#define CCIT_MAKE   8
#define WP_MAKE     ((8<<9)|(8<<4)|3)

#define MID_COMPILE	(MID_MAKE + 1)
#define MID_BUILD	(MID_MAKE + 2)
#define MID_REBUILD	(MID_MAKE + 3)
#define MID_TARGET	(MID_MAKE + 4)

#define MID_SETLIST	(MID_MAKE + 6)
#define MID_EDITLIST	(MID_MAKE + 7)
#define MID_CLEARLIST	(MID_MAKE + 8)


/*
 * Run Menu
 *
 * Note: User menu items are dynamic
 *
 */
#define MID_RUN    0x0400
#define RX_RUN	   28
#define ICH_RUN    0
#define CCH_RUN    3
#define CCIT_RUN   5
#define WP_RUN	   ((5<<9)|(12<<4)|4)

#define MID_EXECUTE	(MID_RUN + 1)
#define MID_DEBUG	(MID_RUN + 2)

#define MID_RUNAPP	(MID_RUN + 4)
#define MID_CUSTOM	(MID_RUN + 5)

#define MID_USER1	(MID_RUN + 0x80 + 0)
#define MID_USER2	(MID_RUN + 0x80 + 1)
#define MID_USER3	(MID_RUN + 0x80 + 2)
#define MID_USER4	(MID_RUN + 0x80 + 3)
#define MID_USER5	(MID_RUN + 0x80 + 4)
#define MID_USER6	(MID_RUN + 0x80 + 5)

/*
 * Window Menu
 */
#define MID_WINDOW    0x0500
#define RX_WINDOW     33
#define ICH_WINDOW    0
#define CCH_WINDOW    6
#define CCIT_WINDOW   5
#define WP_WINDOW     ((5<<9)|(5<<4)|5)

#define MID_SPLITH	(MID_WINDOW + 1)
#define MID_SPLITV	(MID_WINDOW + 2)
#define MID_SIZE	(MID_WINDOW + 3)
#define MID_MAXIMIZE	(MID_WINDOW + 4)
#define MID_CLOSE	(MID_WINDOW + 5)

/*
 * Options Menu
 */
#define MID_OPTIONS    0x0600
#define RX_OPTIONS     41
#define ICH_OPTIONS    0
#define CCH_OPTIONS    7
#define CCIT_OPTIONS   4
#define WP_OPTIONS     ((4<<9)|(4<<4)|6)

#define MID_DEBUGBLD	(MID_OPTIONS + 1)
#define MID_ENVIRONMENT (MID_OPTIONS + 2)
#define MID_ASSIGNKEY	(MID_OPTIONS + 3)
#define MID_SETSWITCH	(MID_OPTIONS + 4)


/*
 * Extension Menus are last+1 through last+n
 */
#define MID_EXTENSION	0x700




#if !defined(EXTINT)
/****************************************************************************
 *									    *
 *  FARDATA.C  global variables 					    *
 *									    *
 ****************************************************************************/

int	       cMenuStrings;

char *	   MenuTitles [];
char *	   HelpStrings [];
char *	   HelpContexts [];

char *	   MacroData [];
struct comData CommandData [];

ITEMDATA       InitItemData [];

ITEMDATA       SelModeItemData [];
ITEMDATA       MaximizeItemData [];
#endif

#endif	/* if defined(CW) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\zext.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ext.h

Abstract:

	Microsoft Editor extension definitions.

#ifndef SHIP

    NOTES:
       THIS FILE IS SHIPPED WITH THE PRODUCT!!!!

       BE VERY carefull what gets put into this file. Technically, if it
       is NOT required for extension writers, it does NOT belong here.

    1) This note, the file history and all code within "#ifndef SHIP" and
       "#if defined EDITOR" conditionals should be REMOVED before shipping.

Author:

	Ramon Juan San Andres (ramonsa) 06-Nov-1990 ported from M 1.02

Revision History:

    26-Nov-1991 mz  Strip off near/far


#endif

--*/


#include <windows.h>


//
//  Macro Definitions
//
// BUFLEN is the maximum line length that can be passed or will be returned
// by the editor.
//
#define BUFLEN    2048

//
//  NT versions of the editor no longer use 16-bit specific attributes.
//  Set them into ignore state
//

#define near
#define far
#define LOADDS
#define EXPORT
#define EXTERNAL
#define INTERNAL

#undef pascal
#define pascal

//
// RQ_... are various request types supported for Get/Set EditorObject
//
#define RQ_FILE         0x1000          // GetEditorObject: File request
#define RQ_FILE_HANDLE  0x1000          //      File Handle
#define RQ_FILE_NAME    0x1100          //      ASCIIZ filename
#define RQ_FILE_FLAGS   0x1200          //      flags
#define RQ_FILE_REFCNT  0x1300          //      reference count
#define RQ_FILE_MODTIME 0x1400          //      modified time
#define RQ_WIN          0x2000          // Window request
#define RQ_WIN_HANDLE   0x2000          //      Window Handle
#define RQ_WIN_CONTENTS 0x2100          //      Window Contents
#define RQ_WIN_CUR      0x2200          //      Current Window
#define RQ_COLOR        0x9000          // Color request
#define RQ_CLIP         0xf000          // clipboard type

#define RQ_THIS_OBJECT	0x00FF		// function is directed to input object

#define RQ_FILE_INIT	0x00FE		// file is init file

//
// toPif is used when placing numeric or boolean switches in the swiDesc table
// to eliminate C 5.X compiler warnings.
//
// For example: { "Switchname", toPIF(switchvar), SWI_BOOLEAN },
//
#define toPIF(x)  (PIF)(LONG_PTR)(void  *)&x


//
// Editor color table endicies. (Colors USERCOLORMIN - USERCOLORMAX are
// unassigned and available for extension use).
//
#define FGCOLOR         21              // foreground (normal) color
#define HGCOLOR         (1 + FGCOLOR)   // highlighted region color
#define INFCOLOR        (1 + HGCOLOR)   // information color
#define SELCOLOR        (1 + INFCOLOR)  // selection color
#define WDCOLOR         (1 + SELCOLOR)  // window border color
#define STACOLOR        (1 + WDCOLOR)   // status line color
#define ERRCOLOR        (1 + STACOLOR)  // error message color
#define USERCOLORMIN    (1 + ERRCOLOR)  // begining of extension colors
#define USERCOLORMAX    35              // end of extension colors


//
//  General type Definitions
//
typedef int  COL;                       // column or position with line

#if !defined (EDITOR)

#if !defined( _FLAGTYPE_DEFINED_ )
#define _FLAGTYPE_DEFINED_ 1
typedef char flagType;
#endif
typedef long	LINE;					// line number within file
typedef void*	PFILE;					// editor file handle

#if !defined (EXTINT)

typedef void*	 PWND;					// editor window handle

#endif	//	EXTINT

#endif	//	EDITOR


typedef char buffer[BUFLEN];            // miscellaneous buffer
typedef char linebuf[BUFLEN];           // line buffer
typedef char pathbuf[MAX_PATH];         // Pathname buffer


typedef struct fl {                     // file location
    LINE    lin;                        // - line number
    COL     col;                        // - column
} fl;

typedef struct sl {                     // screen location
    int     lin;                        // - line number
    int     col;                        // - column
} sl;

typedef struct rn {                     // file range
    fl      flFirst;                    // - Lower line, or leftmost col
    fl      flLast;                     // - Higher, or rightmost
} rn;


typedef struct lineAttr {               // Line color attribute info
    unsigned char attr;                 // - Attribute of piece
    unsigned short len;                 // - Bytes in colored piece
} lineAttr;

#if !defined (cwExtraWnd)

typedef struct ARC {
	BYTE axLeft;
	BYTE ayTop;
	BYTE axRight;
	BYTE ayBottom;
} ARC;
#endif // cwExtraWnd


//
//  Argument defininition structures.
//
//  We define a structure for each of the argument types that may be
//  passed to an extension function. Then, we define the structure
//  argType which is used to pass these arguments around in a union.
//
typedef struct  noargType {             // no argument specified
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
} NOARGTYPE;

typedef struct textargType {            // text argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
    char    *pText;                     // - ptr to text of arg
} TEXTARGTYPE;

typedef struct  nullargType {           // null argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
} NULLARGTYPE;

typedef struct lineargType {            // line argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yStart;                     // - starting line of range
    LINE    yEnd;                       // - ending line of range
} LINEARGTYPE;

typedef struct streamargType {          // stream argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yStart;                     // - starting line of region
    COL     xStart;                     // - starting column of region
    LINE    yEnd;                       // - ending line of region
    COL     xEnd;                       // - ending column of region
} STREAMARGTYPE;

typedef struct boxargType {             // box argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yTop;                       // - top line of box
    LINE    yBottom;                    // - bottom line of bix
    COL     xLeft;                      // - left column of box
    COL     xRight;                     // - right column of box
} BOXARGTYPE;

typedef union ARGUNION {
        struct  noargType       noarg;
	struct	textargType	textarg;
	struct	nullargType	nullarg;
	struct	lineargType	linearg;
	struct	streamargType	streamarg;
        struct  boxargType      boxarg;
} ARGUNION;

typedef struct argType {
    int         argType;
    ARGUNION    arg;
} ARG;



//
//  Function definition table definitions
//
typedef ULONG_PTR CMDDATA;
typedef flagType (*funcCmd)(CMDDATA argData, ARG *pArg, flagType fMeta);

typedef struct cmdDesc {                // function definition entry
    char     *name;                     // - pointer to name of fcn
    funcCmd  func;                      // - pointer to function
    CMDDATA  arg;                       // - used internally by editor
    unsigned argType;                   // - user args allowed
} CMD, *PCMD;


typedef unsigned short KeyHandle;

#define NOARG       0x0001              // no argument specified
#define TEXTARG     0x0002              // text specified
#define NULLARG     0x0004              // arg + no cursor movement
#define NULLEOL     0x0008              // null arg => text from arg->eol
#define NULLEOW     0x0010              // null arg => text from arg->end word
#define LINEARG     0x0020              // range of entire lines
#define STREAMARG   0x0040              // from low-to-high, viewed 1-D
#define BOXARG      0x0080              // box delimited by arg, cursor

#define NUMARG      0x0100              // text => delta to y position
#define MARKARG     0x0200              // text => mark at end of arg

#define BOXSTR      0x0400              // single-line box => text

#define FASTKEY     0x0800              // Fast repeat function
#define MODIFIES    0x1000              // modifies file
#define KEEPMETA    0x2000              // do not eat meta flag
#define WINDOWFUNC  0x4000              // moves window
#define CURSORFUNC  0x8000              // moves cursor



//
//  Switch definition table defintions
//
typedef flagType (*PIF)(char  *);
typedef char*	 (*PIFC)(char *);

typedef union swiAct {                  // switch location or routine
    PIF       pFunc;                    // - routine for text
    PIFC      pFunc2;                   // - routine for text
    int       *ival;                    // - integer value for NUMERIC
    flagType  *fval;                    // - flag value for BOOLEAN
} swiAct;

typedef struct swiDesc {                // switch definition entry
    char    *name;                      // - pointer to name of switch
    swiAct  act;                        // - pointer to value or fcn
    int     type;                       // - flags defining switch type
} SWI, *PSWI;


#define SWI_BOOLEAN 0                   // Boolean switch
#define SWI_NUMERIC 1                   // hex or decimal switch
#define SWI_SCREEN  4                   // switch affects screen
#define SWI_SPECIAL 5                   // textual switch
#define SWI_SPECIAL2 6                  // #5, returning an error string
#define RADIX10 (0x0A << 8)             // numeric switch is decimal
#define RADIX16 (0x10 << 8)             // numeric switch is hex


//
//  Get/Set EditorObject data structures
//
typedef struct winContents{             // define window contents
    PFILE       pFile;                  // - handle of file displayed
    ARC         arcWin;                 // - location of window
    fl          flPos;                  // - upper left corner wrt file
} winContents;


//
// FILE flags values
//
#define DIRTY       0x01                // file had been modified
#define FAKE        0x02                // file is a pseudo file
#define REAL        0x04                // file has been read from disk
#define DOSFILE     0x08                // file has CR-LF
#define TEMP        0x10                // file is a temp file
#define NEW         0x20                // file has been created by editor
#define REFRESH     0x40                // file needs to be refreshed
#define READONLY    0x80                // file may not be editted

#define DISKRO      0x0100              // file on disk is read only
#define MODE1       0x0200              // Meaning depends on the file
#define VALMARKS    0x0400              // file has valid marks defined



//
//  Event processing definitions
//
typedef struct mouseevent {             // mouse event data
    short msg;                          // type of message
    short wParam;                       // CW wParam
    long  lParam;                       // CW lParam
    sl    sl;                           // screen location of mouse event
    fl    fl;                           // file location (if event in win)
} MOUSEEVENT, *PMOUSEEVENT;


typedef struct KEY_DATA {
    BYTE    Ascii;                      //   Ascii code
    BYTE    Scan;                       //   Scan code
    BYTE    Flags;                      //   Flags
    BYTE    Unused;                     //   Unused byte
} KEY_DATA, *PKEY_DATA;

//
//  Following are the values for the Flags field of KEY_DATA
//
#define FLAG_SHIFT      0x01
#define FLAG_CTRL       0x04
#define FLAG_ALT        0x08
#define FLAG_NUMLOCK    0x20


typedef union KEY_INFO {
    KEY_DATA    KeyData;
    long        LongData;
} KEY_INFO, *PKEY_INFO;


typedef union EVTARGUNION {
        KEY_INFO        key;            // keystroke for key event
        char  *         pfn;            // asciiz filename
        PMOUSEEVENT     pmouse;         // ptr to mouse event data
        union Rec       *pUndoRec;      // undo information
} EVTARGUNION;

typedef struct EVTargs {                // arguments to event dispatches
    PFILE       pfile;                  // -file handle for file events
    EVTARGUNION arg;
} EVTargs, *PEVTARGS;


typedef struct eventType {              // event definition struct
    unsigned         evtType;           // - type
    flagType (*func)(EVTargs  *);	// - handler
    struct eventType *pEVTNext;         // - next handler in list
    PFILE            focus;             // - applicable focus
    EVTargs          arg;               // - applicable agruments
} EVT, *PEVT;

#define EVT_RAWKEY	    1		// ALL keystrokes
#define EVT_KEY 	    2		// Editting keystrokes
#define EVT_GETFOCUS	    3		// file GETs focus.
#define EVT_LOSEFOCUS	    4		// file looses focus.
#define EVT_EXIT	    5		// about to exit.
#define EVT_SHELL	    6		// about to sell or compile
#define EVT_UNLOAD	    7		// about to be unloaded.
#define EVT_IDLE	    8		// idle event
#define EVT_CANCEL	    9		// do-nothing cancel
#define EVT_REFRESH	    10		// about to refresh a file
#define EVT_FILEREADSTART   11          // about to read file
#define EVT_FILEREADEND     12          // finshed reading file
#define EVT_FILEWRITESTART  13          // about to write file
#define EVT_FILEWRITEEND    14          // finshed writing file
//			    15
//			    16
//			    17
//			    18
//			    19
#define EVT_EDIT	    20		// editting action
#define EVT_UNDO	    21		// undone action
#define EVT_REDO	    22		// redone action


//
//  Undo, Redo and Edit event structs
//
#define EVENT_REPLACE     0
#define EVENT_INSERT      1
#define EVENT_DELETE      2
#define EVENT_BOUNDARY    3

#if !defined (EDITOR)
typedef struct replaceRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of repalcement
    LINE    line;                       // start of replacement
} REPLACEREC;

typedef struct insertRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of file
    LINE    line;                       // line number that was operated on
    LINE    cLine;                      // number of lines inserted
} INSERTREC;

typedef struct deleteRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of file
    LINE    line;                       // line number that was operated on
    LINE    cLine;                      // Number of lines deleted
} DELETEREC;

typedef struct boundRec {
    int     op;                         // operation (BOUND)
    long    dummy[2];                   // editor interal
    int     flags;                      // flags of file
    long    modify;                     // Date/Time of last modify
    fl      flWindow;                   // position in file of window
    fl      flCursor;                   // position in file of cursor
} BOUNDREC;

typedef union Rec {
    struct replaceRec r;
    struct insertRec  i;
    struct deleteRec  d;
    struct boundRec   b;
} REC;
#endif  // editor



//
//  Build command definitions
//
#define MAKE_FILE               1       // rule is for a filename
#define MAKE_SUFFIX             2       // rule is a suffix rule
#define MAKE_TOOL               4       // rule is for a tool
#define MAKE_BLDMACRO           8       // rule is for a build macro
#define MAKE_DEBUG              0x80    // rule is debug version


#define LOWVERSION  0x0015              // lowest version of extensions we handle
#define HIGHVERSION 0x0015              // highest version of extensions we handle

#define VERSION     0x0015              // our current version

typedef struct ExtensionTable {
    long	version;
    long	cbStruct;
    PCMD	cmdTable;
    PSWI	swiTable;
    struct CallBack {
	PFILE	    (*AddFile) (char  *);
	flagType    (*BadArg) (void);
	char	    (*Confirm) (char *, char *);
	void	    (*CopyBox) (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
	void	    (*CopyLine) (PFILE, PFILE, LINE, LINE, LINE);
	void	    (*CopyStream) (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
	void	    (*DeRegisterEvent) (EVT  *);
	flagType    (*DeclareEvent) (unsigned, EVTargs	*);
	void	    (*DelBox) (PFILE, COL, LINE, COL, LINE);
	void	    (*DelFile) (PFILE);
	void	    (*DelLine) (PFILE, LINE, LINE);
	void	    (*DelStream) (PFILE, COL, LINE, COL, LINE);
	void	    (*Display) (void);
        int         (*DoMessage) (char  *);
        flagType    (*DoSpawn) (char  *, flagType);
	flagType    (*fChangeFile) (flagType, char  *);
	void	    (*Free) (void  *);
	flagType    (*fExecute) (char  *);
        int         (*fGetMake) (int, char  *, char  *);
	LINE	    (*FileLength) (PFILE);
	PFILE	    (*FileNameToHandle) (char  *, char	*);
	flagType    (*FileRead) (char  *, PFILE);
	flagType    (*FileWrite) (char	*, PFILE);
	PSWI	    (*FindSwitch) (char  *);
	flagType    (*fSetMake) (int, char  *, char  *);
        flagType    (*FuncNameToKeyEvent) (char *, PKEY_EVENT_RECORD);
	flagType    (*GetColor) (LINE, lineAttr  *, PFILE);
	void	    (*GetTextCursor) (COL  *, LINE	*);
	flagType    (*GetEditorObject) (unsigned, void *, void	*);
	char *	    (*GetEnv) (char  *);
        int         (*GetLine) (LINE, char  *, PFILE);
	char *	    (*GetListEntry) (PCMD, int, flagType);
        flagType    (*GetString) (char  *, int, char  *, flagType);
        int         (*KbHook) (void);
	void	    (*KbUnHook) (void);
        void *      (*Malloc) (size_t);
	void	    (*MoveCur) (COL, LINE);
	char *	    (*NameToKeys) (char  *, char  *);
	PCMD	    (*NameToFunc) (char  *);
	flagType    (*pFileToTop) (PFILE);
	void	    (*PutColor) (LINE, lineAttr  *, PFILE);
	void	    (*PutLine) (LINE, char  *, PFILE);
        int         (*REsearch) (PFILE, flagType, flagType, flagType, flagType, char  *, fl  *);
	long	    (*ReadChar) (void);
	PCMD	    (*ReadCmd) (void);
	void	    (*RegisterEvent) (EVT  *);
        void        (*RemoveFile) (PFILE);
	flagType    (*Replace) (char, COL, LINE, PFILE, flagType);
	char *	    (*ScanList) (PCMD, flagType);
        int         (*search) (PFILE, flagType, flagType, flagType, flagType, char  *, fl  *);
	void	    (*SetColor) (PFILE, LINE, COL, COL, int);
	flagType    (*SetEditorObject) (unsigned, void *, void	*);
	void	    (*SetHiLite) (PFILE, rn, int);
	flagType    (*SetKey) (char  *, char  *);
	flagType    (*SplitWnd) (PWND, flagType, int);
	} CallBack;
    } EXTTAB;

//
//	Editor low level function prototypes.
//
//  This list defines the routines within the editor which may be called
//  by extension functions.
//
#if !defined (EDITOR)

extern EXTTAB ModInfo;

#define AddFile(x)		    ModInfo.CallBack.AddFile(x)
#define BadArg			    ModInfo.CallBack.BadArg
#define Confirm(x,y)		    ModInfo.CallBack.Confirm(x,y)
#define CopyBox(x,y,z,a,b,c,d,e)    ModInfo.CallBack.CopyBox(x,y,z,a,b,c,d,e)
#define CopyLine(x,y,z,a,b)	    ModInfo.CallBack.CopyLine(x,y,z,a,b)
#define CopyStream(x,y,z,a,b,c,d,e) ModInfo.CallBack.CopyStream(x,y,z,a,b,c,d,e)
#define DeRegisterEvent(x)	    ModInfo.CallBack.DeRegisterEvent(x)
#define DeclareEvent(x,y)	    ModInfo.CallBack.DeclareEvent(x,y)
#define DelBox(x,y,z,a,b)	    ModInfo.CallBack.DelBox(x,y,z,a,b)
#define DelFile(x)		    ModInfo.CallBack.DelFile(x)
#define DelLine(x,y,z)		    ModInfo.CallBack.DelLine(x,y,z)
#define DelStream(x,y,z,a,b)	    ModInfo.CallBack.DelStream(x,y,z,a,b)
#define Display 		    ModInfo.CallBack.Display
#define DoMessage(x)		    ModInfo.CallBack.DoMessage(x)
#define DoSpawn(x,y)                ModInfo.CallBack.DoSpawn(x,y)
#define fChangeFile(x,y)	    ModInfo.CallBack.fChangeFile(x,y)
#define Free(x) 		    ModInfo.CallBack.Free(x)
#define fExecute(x)		    ModInfo.CallBack.fExecute(x)
#define fGetMake(x,y,z) 	    ModInfo.CallBack.fGetMake(x,y,z)
#define FileLength(x)		    ModInfo.CallBack.FileLength(x)
#define FileNameToHandle(x,y)	    ModInfo.CallBack.FileNameToHandle(x,y)
#define FileRead(x,y)		    ModInfo.CallBack.FileRead(x,y)
#define FileWrite(x,y)		    ModInfo.CallBack.FileWrite(x,y)
#define FindSwitch(x)		    ModInfo.CallBack.FindSwitch(x)
#define fSetMake(x,y,z) 	    ModInfo.CallBack.fSetMake(x,y,z)
#define FuncNameToKeyEvent(x,y)     ModInfo.CallBack.FuncNameToKeyEvent(x,y)
#define GetColor(x,y,z) 	    ModInfo.CallBack.GetColor(x,y,z)
#define GetTextCursor(x,y)	    ModInfo.CallBack.GetTextCursor(x,y)
#define GetEditorObject(x,y,z)	    ModInfo.CallBack.GetEditorObject(x,y,z)
#define GetEnv(x)		    ModInfo.CallBack.GetEnv(x)
#define GetLine(x,y,z)		    ModInfo.CallBack.GetLine(x,y,z)
#define GetListEntry(x,y,z)	    ModInfo.CallBack.GetListEntry(x,y,z)
#define GetString(x,a,y,z)          ModInfo.CallBack.GetString(x,a,y,z)
#define KbHook			    ModInfo.CallBack.KbHook
#define KbUnHook		    ModInfo.CallBack.KbUnHook
#define Malloc(x)		    ModInfo.CallBack.Malloc(x)
#define MoveCur(x,y)                ModInfo.CallBack.MoveCur(x,y)
#define NameToKeys(x,y) 	    ModInfo.CallBack.NameToKeys(x,y)
#define NameToFunc(x)		    ModInfo.CallBack.NameToFunc(x)
#define pFileToTop(x)		    ModInfo.CallBack.pFileToTop(x)
#define PutColor(x,y,z) 	    ModInfo.CallBack.PutColor(x,y,z)
#define PutLine(x,y,z)		    ModInfo.CallBack.PutLine(x,y,z)
#define REsearch(x,y,z,a,b,c,d)     ModInfo.CallBack.REsearch(x,y,z,a,b,c,d)
#define ReadChar		    ModInfo.CallBack.ReadChar
#define ReadCmd 		    ModInfo.CallBack.ReadCmd
#define RegisterEvent(x)	    ModInfo.CallBack.RegisterEvent(x)
#define RemoveFile(x)		    ModInfo.CallBack.RemoveFile(x)
#define Replace(x,y,z,a,b)	    ModInfo.CallBack.Replace(x,y,z,a,b)
#define ScanList(x,y)		    ModInfo.CallBack.ScanList(x,y)
#define search(x,y,z,a,b,c,d)	    ModInfo.CallBack.search(x,y,z,a,b,c,d)
#define SetColor(x,y,z,a,b)	    ModInfo.CallBack.SetColor(x,y,z,a,b)
#define SetEditorObject(x,y,z)	    ModInfo.CallBack.SetEditorObject(x,y,z)
#define SetHiLite(x,y,z)	    ModInfo.CallBack.SetHiLite(x,y,z)
#define SetKey(x,y)		    ModInfo.CallBack.SetKey(x,y)
#define SplitWnd(x,y,z) 	    ModInfo.CallBack.SplitWnd(x,y,z)

void	    WhenLoaded		(void);

#endif // EDITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\build.c ===
/*** build.c - utilities for build process
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip out near/far
*
*
*************************************************************************/
#include "z.h"


/***
*
* Structures & Types
*
*************************************************************************/
/*
 * BUILDCMD - Build command linked list element
 */
struct BuildCmdType {
    struct BuildCmdType *pNext; 	/* next in list 		*/
    int     flags;			/* command type 		*/
    char    *pRule;			/* pointer to rule/filename	*/
    char    *pCmd;			/* pointer to command text	*/
    };

typedef struct BuildCmdType BUILDCMD;

/***
*
* Module data
*
*************************************************************************/
static	BUILDCMD    *pBuildCmdHead	= NULL; /* head of linked list	*/
static	BUILDCMD    *pBuildCmdCur	= NULL; /* most recent lookup	*/

/*** fSetMake - Define Build Command
*
*  Defines the filename extensions (.C, .BAS, etc) to which a given tool
*  command line applies OR the tool class which a command line defines.
*
* Input:
*  SetType =	MAKE_SUFFIX	= define suffix rule
*		MAKE_FILE	= define command for specfic file
*		MAKE_TOOL	= define tool command line
*		MAKE_DEBUG	= definition is for DEBUG, else RELEASE
*
*  fpszCmd =	Formatted  command  string.  Uses current extmake formatting
*		rules. (%s, etc.)
*
*  fpszExt =	If MAKE_EXT	= suffixes (i.e. ".c.obj")
*		If MAKE_FILE	= filename (must include ".")
*		If MAKE_TOOL	= tool name (no "." allowed)
*
* Output:
*  Returns TRUE on success. FALSE on any error.
*
*************************************************************************/
flagType
fSetMake (
    int      SetType,
    char *fpszCmd,
    char *fpszExt
    ) {
    buffer  buf;

    assert (fpszCmd && fpszExt && SetType);
    while (*fpszCmd == ' ') {
        fpszCmd++;
    }
    if (fGetMake (SetType, (char *)buf, fpszExt)) {
        /*
         * If it already existed, then just free teh previous definitions, in
         * preparation for replacement.
         */
        assert (pBuildCmdCur->pCmd);
        assert (pBuildCmdCur->pRule);
        pBuildCmdCur->pCmd  = ZEROREALLOC (pBuildCmdCur->pCmd, strlen(fpszCmd)+1);
        pBuildCmdCur->pRule = ZEROREALLOC (pBuildCmdCur->pRule,strlen(fpszExt)+1);
	strcpy ((char *)pBuildCmdCur->pCmd, fpszCmd);
	strcpy ((char *)pBuildCmdCur->pRule,fpszExt);
    } else {
        /*
         * It didn't already exist, so create a new struct at the head of the list,
         * to be filled in below.
         */
        pBuildCmdCur = (BUILDCMD *)ZEROMALLOC (sizeof(BUILDCMD));
        pBuildCmdCur->pNext = pBuildCmdHead;
	pBuildCmdCur->pCmd  = ZMakeStr (fpszCmd);
	pBuildCmdCur->pRule = ZMakeStr (fpszExt);
        pBuildCmdHead = pBuildCmdCur;
    }
    pBuildCmdCur->flags = SetType;
    return TRUE;
}



/*** fGetMake - Return Build Command
*
*  Returns the	command line which applies to a file or filename extension.
*
* Input:
*  GetType =	    MAKE_SUFFIX     = return suffix rule
*		    MAKE_FILE	    = return command for specfic file
*		    MAKE_TOOL	    = return tool command line
*		    MAKE_DEBUG	    = definition is for DEBUG, else RELEASE
*
*  fpszCmdDst =     Location  to place the formatted command string. Must be
*		    BUFLEN bytes long.
*
*  fpszExt =	    If MAKE_EXT     = suffixes	(i.e.  ".c.obj") for desired
*				      command.
*		    If MAKE_FILE    = filename for desired command
*		    If MAKE_TOOL    = name of tool
*
* Output:
*  Returns 0 on any error, else returns the GetType.
*
*************************************************************************/
int
fGetMake (
    int     GetType,
    char *fpszCmdDst,
    char *fpszExt
    ) {
    assert (fpszCmdDst && fpszExt && GetType);
    /*
     * Here we just walk the linked list looking for an entry whose flags match,
     * and, if a file or suffix rule, whose rule matches.
     */
    for (pBuildCmdCur = pBuildCmdHead;
         pBuildCmdCur;
         pBuildCmdCur = pBuildCmdCur->pNext) {

        if (pBuildCmdCur->flags == GetType) {
	    if (!_stricmp((char *)pBuildCmdCur->pRule,fpszExt)) {
		strcpy (fpszCmdDst,(char *)pBuildCmdCur->pCmd);
                return pBuildCmdCur->flags;
            }
        }
    }
    return 0;
}


/*** hWalkMake - return make commands one at a time.
*
*  Allow an external anyone to walk the command list.
*
* Input
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
unsigned
short
hWalkMake (
    unsigned short handle,
    int     *Type,
    char    *pszRuleDest,
    char    *pszCmdDest
    ) {

    if (handle) {
        pBuildCmdCur = ((BUILDCMD *)handle)->pNext;
    } else {
        pBuildCmdCur = pBuildCmdHead;
    }

    if (pBuildCmdCur) {
        *Type = pBuildCmdCur->flags;
        strcpy (pszRuleDest, pBuildCmdCur->pRule);
        strcpy (pszCmdDest,  pBuildCmdCur->pCmd);
    }
    return (unsigned short) pBuildCmdCur;
}


/*** fShowMake - Show current build commands
*
*  Append a textual representation of the current build commands to the
*  passed pFile
*
* Input:
*  pFile	= File handle to be added to
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
ShowMake (
    PFILE   pFile
    ) {
    buffer  buf;

    assert (pFile);
    /*
     * Here we just walk the linked list and append lines with the info
     */
    for (pBuildCmdCur = pBuildCmdHead;
         pBuildCmdCur;
         pBuildCmdCur = pBuildCmdCur->pNext) {

        if (TESTFLAG (pBuildCmdCur->flags, MAKE_FILE)) {
            sprintf (buf, "    extmake:[%s]", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_SUFFIX)) {
            sprintf (buf, "    extmake:%s", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_TOOL)) {
            sprintf (buf, "    extmake:*%s", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_BLDMACRO)) {
            sprintf (buf, "    extmake:$%s", pBuildCmdCur->pRule);
        } else {
            assert (FALSE);
        }
        sprintf (strend(buf), "%s %s"
                    , TESTFLAG (pBuildCmdCur->flags, MAKE_DEBUG) ? ",D" : RGCHEMPTY
                    , pBuildCmdCur->pCmd
                );
        AppFile (buf, pFile);
    }
}


/*** SetExt - assign a particular compile action to a particular action.
*
*  This is called during any initialization to cause a string to be
*  associated with a particular compile action.
*
* Input:
*  val		= char pointer to a string of the form:
*		    .ext string 	    = define .ext.obj rule
*		    .ext.ext string	    = define .ext.ext rule
*		    filename.ext string     = define rule for filename.ext
*		    command string	    = define rule for command
*
*		  During build any %s's in the string are replaced with the
*		  name of the file being compiled.
*
* Output:
*  Returns TRUE, or FALSE if any errors are found.
*
*************************************************************************/
char *
SetExt (
    char *val
    ) {

    buffer  extbuf;                         /* buffer to work on extension  */
    REGISTER int maketype   = 0;            /* type of build command        */
    char    *pCompile;                      /* pointer to command portion   */
    char    *pExt;                          /* pointer to extension portion */
    REGISTER char *pT;                      /* temp pointer                 */
    buffer  tmpval;                         /* (near) buffer to work on     */

    assert (val);
    strcpy ((char *) tmpval, val);
    /*
     * seperate the extension part from the command part. If there is no command,
     * that's an error.
     */
    ParseCmd (tmpval, &pExt, &pCompile);
    if (*pCompile == '\0') {
        return "extmake: Command missing";
    }
    /*
     * CONSIDER: this syntax is somewhat ugly, and unclean to parse
     *
     * Copy the extension part to a local buffer, so we can work on it. Set make
     * type based on the following rules:
     *
     *      Starts with dot:            --> suffix rule.
     *      Starts with "*"             --> tool rule.
     *      Starts with "$"             --> build macro
     *      Starts with "["             --> filename rule.
     *      "text"                      --> Special old-style "tool rule" for TEXT
     *      text <= 3 characters        --> old style suffix rule
     *
     *      In all cases: contains ",d" --> DEBUG rule.
     */
    _strlwr (pExt);
    strcpy (extbuf, pExt);

    if (pT = strstr (extbuf,",d")) {
        maketype = MAKE_DEBUG;
        *pT = 0;
    }

    if (extbuf[0] == '.') {
        maketype |= MAKE_SUFFIX;
    } else if (extbuf[0] == '[') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_FILE;
        if (pT = strchr (extbuf,']')) {
            *pT = 0;
        }
    } else if (extbuf[0] == '*') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_TOOL;
    } else if (extbuf[0] == '$') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_BLDMACRO;
    } else if (!_stricmp (extbuf, "text")) {
        maketype |= MAKE_TOOL;
    } else if (strlen(extbuf) <= 3) {
        ((unsigned short *)extbuf)[0] = (unsigned short)'.';
        strcat (extbuf,pExt);
        strcat (extbuf,".obj");
        maketype |= MAKE_SUFFIX;
    } else  {
        return "extmake: Bad syntax in extension";
    }

    if (fSetMake (maketype, (char *)pCompile, (char *)extbuf)) {
        return NULL;
    } else {
        return "extmake: Error in command line";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\assign.c ===
/****  assign.c - keyboard reassignment and switch setting
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*        26-Nov-1991 mz        Strip out near/far
*
*
*************************************************************************/
#include "z.h"


#define DEBFLAG CMD

/****************************************************************************
 *                                                                          *
 *  Assignment types.  Used by UpdToolsIni                                  *
 *                                                                          *
 ****************************************************************************/

#define ASG_MACRO   0
#define ASG_KEY     1
#define ASG_SWITCH  2


/*** NameToFunc - map a user-specified function name into internal structure
 *
 *  Given a name of a function, find it in the system table or in the set
 *  of defined macros.  Return the pointer to the command structure
 *
 *  Since, with user-defined extensions as well as macros, there is the
 *  possibility of name collision (effectively masking one function) we allow
 *  disambiguation by specifying an extension name ala .DEF file format:
 *
 *        func       - look up func in macro table and then in extensions
 *                     in order of installation
 *        exten.func - look up func in exten only.
 *
 *  pName    = char pointer to potential name
 *
 *  Returns pointer to command structure if found, NULL otherwise
 *
 *************************************************************************/
PCMD
FindNameInCmd (
    char    *pName,
    PCMD    pCmd
    ) {
    while (pCmd->name) {
        if (!_stricmp (pName, pCmd->name)) {
            return pCmd;
        }
        pCmd++;
    }
    return NULL;
}


PCMD
NameToFunc (
    char    *pName
    ) {

    /* see if an extension override is present */
    {
        char *pExt = pName;
        PCMD pCmd;
        int i;

        pName = strbscan (pExt, ".");
        if (*pName != '\0') {
            *pName++ = '\0';
            for (i = 0; i < cCmdTab; i++) {
                if (!_stricmp (pExt, pExtName[i])) {
                    pCmd = FindNameInCmd (pName, cmdSet[i]);
                    pName[-1] = '.';
                    return pCmd;
                }
            }
            return NULL;
        }
        pName = pExt;
    }

    {
        REGISTER int k;

        for (k = 0; k < cMac; k++) {
            if (!_stricmp (pName, rgMac[k]->name)) {
                return rgMac[k];
            }
        }
    }


    {
        int i;
        REGISTER PCMD pCmd;

        /* look up function name in table */
        for (i = 0; i < cCmdTab; i++) {
            if ((pCmd = FindNameInCmd (pName, cmdSet[i])) != NULL) {
                return pCmd;
            }
        }
        return NULL;
    }
}



/*** DoAssign - make assignment
*
* Purpose:
*  Executes the keystroke and macro assignment strings passed to it by either
*  the assign command processor, or the tools.ini file processor.
*
* Input:
*  asg  = Pointer to asciiz assignment string. The line is assumed
*         to be clean (see GetTagLine).
*
* Output:
*  TRUE is assignment made
*
*************************************************************************/
flagType
DoAssign (
    char    *asg
    ) {

    REGISTER char *p;
    flagType fRet;

    asg = whiteskip (asg);
    RemoveTrailSpace (asg);

    if (*(p = strbscan(asg,":")) == 0) {
        return disperr (MSG_ASN_MISS, asg);
    }

    *p++ = 0;
    _strlwr (asg);
    RemoveTrailSpace (asg);
    p = whiteskip (p);

    if (*p == '=') {
        fRet = SetMacro (asg, p = whiteskip (p+1));
    } else {
        fNewassign = TRUE;
        if (NameToFunc (asg) == NULL) {
            fRet = SetSwitch (asg, p);
        } else {
            fRet = SetKey (asg, p);
            if (!fRet) {
                if (*p == '\0') {
                    disperr (MSG_ASN_MISSK, asg);
                } else {
                    disperr (MSG_ASN_UNKKEY, p);
                }
            }
        }
    }
    return fRet;
}


/*** SetMacro - define a keystroke macro
*
* Input:
*  name         = lowercase macro name
*  p            = sequence of editor functions and/or quoted text
*
* Output:
*
*************************************************************************/
flagType
SetMacro (
    char const *name,
    char const *p
    ) {

    REGISTER PCMD pFunc;
    int i, j;

    /* MACRO-NAME:=functions */
    /* see if macro already defined */
    for (i = 0; i < cMac; i++) {
        if (!strcmp (rgMac[i]->name, name)) {
            for (j = 0; j < cMacUse; j++) {
                if ((char *) mi[j].beg == rgMac[j]->name) {
                    return disperr (MSG_ASN_INUSE, name);
                }
            }
            break;
        }
    }

    if (i != cMac) {
        /*
         * redefining a macro: realloc exiting text
         */
        rgMac[i]->arg = (CMDDATA)ZEROREALLOC ((char *) rgMac[i]->arg, strlen(p)+1);
        strcpy ((char *) rgMac[i]->arg, p);
        return TRUE;
    }

    if (cMac >= MAXMAC) {
        return disperr (MSG_ASN_MROOM, name);
    }

    pFunc = (PCMD) ZEROMALLOC (sizeof (*pFunc));
    pFunc->arg = (ULONG_PTR) ZMakeStr (p);
    pFunc->name = ZMakeStr (name);
    pFunc->func = macro;
    pFunc->argType = KEEPMETA;
    rgMac[cMac++] = pFunc;


    return TRUE;
}


/*** assign - assign editting function
*
*  Handle key, switch and macro assignments
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
assign (
    CMDDATA argData,
    REGISTER ARG *pArg,
    flagType fMeta
    ) {

    fl      flNew;
    linebuf abuf;
    char * pBuf = NULL;

    switch (pArg->argType) {

    case NOARG:
        GetLine (pArg->arg.noarg.y, abuf, pFileHead);
        return DoAssign (abuf);

    case TEXTARG:
        strcpy ((char *) abuf, pArg->arg.textarg.pText);
        if (!strcmp(abuf, "?")) {
            AutoSave ();
            return fChangeFile (FALSE, rgchAssign);
            }
        return DoAssign (abuf);

    /*  NULLARG is transformed into text to EOL */
    case LINEARG:
        flNew.lin = pArg->arg.linearg.yStart;
        while (    flNew.lin <= pArg->arg.linearg.yEnd &&
                (pBuf = GetTagLine (&flNew.lin, pBuf, pFileHead))) {
            if (!DoAssign (pBuf)) {
                flNew.col = 0;
                cursorfl (flNew);
                if (pBuf) {
                    FREE (pBuf);
                }
                return FALSE;
            }
        }
        if (pBuf) {
            FREE (pBuf);
        }
        return TRUE;

    /*  STREAMARG is illegal    */
    case BOXARG:
        for (flNew.lin = pArg->arg.boxarg.yTop; flNew.lin <= pArg->arg.boxarg.yBottom; flNew.lin++) {
            fInsSpace (pArg->arg.boxarg.xRight, flNew.lin, 0, pFileHead, abuf);
            abuf[pArg->arg.boxarg.xRight+1] = 0;
            if (!DoAssign (&abuf[pArg->arg.boxarg.xLeft])) {
                flNew.col = pArg->arg.boxarg.xLeft;
                cursorfl (flNew);
                return FALSE;
            }
        }
        return TRUE;
    }

    return FALSE;

    argData; fMeta;
}


/*** FindSwitch - lookup switch
*
*  Locate switch descriptor, given it's name
*
* Input:
*  p                = pointer to text switch name
*
* Output:
*  Returns PSWI, or NULL if not found.
*
*************************************************************************/
PSWI
FindSwitch (
    char *p
    ) {

    REGISTER PSWI pSwi;
    int i;

    for (i = 0; i < cCmdTab; i++) {
        for (pSwi = swiSet[i]; pSwi != NULL && pSwi->name != NULL; pSwi++) {
            if (!strcmp (p, pSwi->name)) {
                return pSwi;
            }
        }
    }
    return NULL;
}


/*** SetSwitch - Set a switch to a particular value
*
*  Given a switch name, and a value to set it to, perform the assignment
*
* Input:
*  p             = pointer to switch name (possibly prefexed by "no" if a
*                  boolean
*  val           = new value to set switch to
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
SetSwitch (
    char    *p,
    char    *val
    ) {

    PSWI    pSwi;
    int     i;
    flagType f;
    char    *pszError;
    fl      flNew;                          /* new location of cursor       */

    f = TRUE;

    /*  figure out if no is a prefix or not
     */

    if ((pSwi = FindSwitch (p)) == NULL) {
        if (!_strnicmp ("no", p, 2)) {
            p += 2;
            f = FALSE;
            if ((pSwi = FindSwitch (p)) != NULL && pSwi->type != SWI_BOOLEAN) {
                pSwi = NULL;
            }
        }
    }

    if (pSwi == NULL) {
        return disperr (MSG_ASN_NOTSWI, p);
    }

    switch (pSwi->type & 0xFF) {
    case SWI_BOOLEAN:
        if (*val == 0) {
            *pSwi->act.fval = f;
            return TRUE;
        } else if (!f) {
            printerror ("Boolean switch style conflict");
            return FALSE;
        } else if (!_stricmp (val, "no")) {
            *pSwi->act.fval = FALSE;
            return TRUE;
        } else if (!_stricmp (val, "yes")) {
            *pSwi->act.fval = TRUE;
            return TRUE;
        }
        break;

    case SWI_NUMERIC:
        if (!f) {
            if (*val == 0) {
                val = "0";
            } else {
                break;
            }
        }
        if (*val != 0) {
            *pSwi->act.ival = ntoi (val, pSwi->type >> 8);
            return TRUE;
        }
        break;

    case SWI_SCREEN:
        /* change screen parameters */
        i = atoi (val);
        if (i == 0) {
            return disperr (MSG_ASN_ILLSET);
        }
        if ((cWin > 1) &&
            (((pSwi->act.ival == (int *)&XSIZE) && (i != XSIZE)) ||
             ((pSwi->act.ival == (int *)&YSIZE) && (i != YSIZE)))) {
            disperr (MSG_ASN_WINCHG);
            return FALSE;
        }
        if ((pSwi->act.ival == (int *)&XSIZE && !fVideoAdjust (i, YSIZE)) ||
            (pSwi->act.ival == (int *)&YSIZE && !fVideoAdjust (XSIZE, i))) {
            return disperr (MSG_ASN_UNSUP);
        }
        SetScreen ();
        if (pInsCur && (YCUR(pInsCur) - YWIN(pInsCur) > YSIZE)) {
            flNew.col = XCUR(pInsCur);
            flNew.lin = YWIN(pInsCur) + YSIZE - 1;
            cursorfl (flNew);
        }
        domessage (NULL);
        return TRUE;

    case SWI_SPECIAL:
        /* perform some special initialization */
        if ( ! (*pSwi->act.pFunc) (val) ) {
            return disperr (MSG_ASN_INVAL, pSwi->name, val);
        }
        return TRUE;

    case SWI_SPECIAL2:
        /* perform special initialization with possible error return string */
        if (pszError = (*pSwi->act.pFunc2) (val)) {
            printerror (pszError);
            return FALSE;
        }
        return TRUE;

    default:
        break;
    }

    return FALSE;
}


/*** AckReplace - Acknowledge changes to <assign> file.
*
* Purpose:
*
*   To be called whenever a line in the current file changes. Allows
*   special handling for some files.
*
* Input:
*   line  - Number of the line that changed
*   fUndo - TRUE if this replacement is an <undo> operation.
*
* Output: None
*
* Notes:
*
*   Currently, this means making changes to <assign> take effect immediately.
*   If the user has changed the current line without leaving it, we flag
*   the change so it will take place after they leave. If the user is
*   elsewhere, the change takes place now.
*
*************************************************************************/

static flagType fChanged = FALSE;

void
AckReplace (
    LINE line,
    flagType fUndo
    ) {


    if (pInsCur->pFile == pFileAssign) {
        if (YCUR(pInsCur) == line || fUndo) {
            fChanged = (flagType)!fUndo;
        } else {
            DoAssignLine (line);
        }
    }
}



/*** AckMove - Possibly parse line in <assign> file.
*
* Purpose:
*
*   To be called whenever the cursor moves to a new line in the current
*   file.  This allows special line processing to take place after a
*   line has been changed.
*
* Input:
*   lineOld -        Number of line we're moving from.
*   lineNew -        Number of line we're moving to.
*
* Output: None.
*
* Notes:
*
*   Currently, this makes the <assign> file work.  If the line we are
*   moving from has changed, we make the assignment.  We rely on AckReplace
*   to set fChanged ONLY when the affected file is <assign>.
*
*************************************************************************/

void
AckMove (
    LINE lineOld,
    LINE lineNew
    ) {
    if (pInsCur->pFile== pFileAssign && fChanged && lineOld != lineNew ) {
        fChanged = FALSE;
        DoAssignLine (lineOld);
    }
}



/*** DoAssignLine - Take line from current file and <assign> with it
*
* Purpose:
*
*   Used by the Ack* functions to perform an <assign> when the time is
*   right.
*
* Input:
*   line -  Line in the file to read.
*
* Output: None
*
*************************************************************************/

#define CINDEX(clr) ((&clr-&ColorTab[0])+isaUserMin)

void
DoAssignLine (
    LINE line
    ) {
    fl      flNew;
    char    *pch;
    struct lineAttr rgColor[2];

    flNew.lin = line;
    if ((pch = GetTagLine (&flNew.lin, NULL, pInsCur->pFile)) &&
        flNew.lin == line+1) {
        if (!DoAssign(pch)) {
            flNew.col = XCUR(pInsCur);
            flNew.lin--;
            cursorfl (flNew);
            DelColor (line, pInsCur->pFile);
        } else {
            /*
             * Hilite the changed line so we can find it again
             */
            rgColor[0].attr = rgColor[1].attr = (unsigned char)CINDEX(hgColor);
            rgColor[0].len  = (unsigned short)slSize.col;
            rgColor[1].len  = 0xFFFF;
            PutColor (line, rgColor, pInsCur->pFile);
        }
    }
}



/*** UpdToolsIni - Update one entry in the tools.ini file
*
* Purpose:
*
*   Used for automatic updates, such as when the <assign> file is saved.
*
*   The posible values for asgType are:
*
*        ASG_MACRO   - This is a macro assignment.
*        ASG_KEY     - This assigns a function to a key.
*        ASG_SWITCH  - THis assigns a value to a switch.
*
* Input:
*   pszValue   - Complete string to enter, as in "foo:value".
*   asgType    - Type of assignment.
*
* Output: None
*
* Notes:
*
*   If necessary, the string will be broken across several lines using
*   the continuation character.
*
*   UNDONE: This "effort" has not been made"
*   Every effort is made to preserve the user's tools.ini format.  To this
*   end:
*
*        o When an entry already exists for the given switch or function,
*          the new value is written over the old value, with the first
*          non-space character of each coinciding.
*
*        o If an entry does not exist, a new entry is made at the end
*          of the section, and is indented to match the previous entry.
*
*   We find an existing string by searching through the tagged sections
*   in the same order in which they are read, then pick the last instance
*   of the string.  In other words, the assignment we replace will be
*   the one that was actually used.  This order is assumed to be:
*
*                    [NAME]
*                    [NAME-os version]
*                    [NAME-video type]
*                    [NAME-file extension]
*                    [NAME-..] (if no file extension section)
*
*   If we are not replacing an existing string, we add the new string at
*   the end of the [Z] section.
*
*   The string pszAssign is altered.
*
*************************************************************************/

void
UpdToolsIni (
    char * pszAssign
    ) {

    char * pchLeft;
    char * pchRight;
    int asgType;
    LINE lReplace, lAdd = 0L, l;
    linebuf lbuf;
    flagType fTagFound = TRUE;

    if (pFileIni == NULL || pFileIni == (PFILE)-1) {
        /*
        ** We assume here that pFileIni has no
        ** value because there is no TOOLS.INI file
        */
        if (CanonFilename ("$INIT:tools.ini", lbuf)) {
            pFileIni = AddFile (lbuf);
            assert (pFileIni);
            pFileIni->refCount++;
            SETFLAG (FLAGS(pFileIni), DOSFILE);
            FileRead (lbuf, pFileIni, FALSE);
        } else {
            return;
        }
    }

    /* First, figure out what is what */
    pchLeft = whiteskip (pszAssign);
    pchRight = strchr (pchLeft, ':');
    *pchRight++ = '\0';
    if (*pchRight == '=') {
        asgType = ASG_MACRO;
        pchRight++;
    } else {
        asgType = NameToFunc (pchLeft) ? ASG_KEY : ASG_SWITCH;
    }
    pchRight = whiteskip (pchRight);


    // First, let's search through the [NAME] section.  If
    // we are replacing, we search for the line to replace.
    // If we are not, we are simply trying to find the end.
    //
    lReplace = 0L;

    if (0L < (l = FindMatchLine (NULL, pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)!l;
    }

    //sprintf (lbuf, "%d.%d", _osmajor, _osminor);
    //if (_osmajor >= 10 && !_osmode) {
    //    strcat (lbuf, "R");
    //}
    if (0L < (l = FindMatchLine (lbuf, pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)(fTagFound || (flagType)!l);
    }

    if (0L < (l = FindMatchLine (VideoTag(), pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)(fTagFound || (flagType)!l);
    }

    // UNDONE: This should try to read the extension section
    // currently "active".  What it does is read the extension
    // section appropriate to the current file.  If these are
    // not the same, it fails.
    //
    if (extention (pInsCur->pFile->pName, lbuf)) {
        if (0L < (l = FindMatchLine (lbuf, pchLeft, pchRight, asgType, &lAdd))) {
            lReplace = l;
        } else if (l == -1L) {
            if (0L < (l = FindMatchLine ("..", pchLeft, pchRight, asgType, &lAdd))) {
                lReplace = l;
            } else {
                fTagFound = (flagType)(fTagFound || (flagType)!l);
            }
        }
    }


    // If we are not supposed to replace a line,
    // or if we are but we can't find a suitable
    // line, we simply insert the new line
    //
    strcpy (lbuf, pchLeft);
    if (asgType == ASG_MACRO) {
        strcat (lbuf, ":= ");
    } else {
        strcat (lbuf, ": ");
    }
    strcat (lbuf, pchRight);

    if (!fTagFound) {
        lAdd = 1L;
        InsLine (FALSE, 0L, 1L, pFileIni);
        sprintf (buf, "[%s]", pNameEditor);
        PutTagLine (pFileIni, buf, 0L, 0);
    }

    if (lReplace == 0L) {
        assert (lAdd <= pFileIni->cLines);
        InsLine (FALSE, lAdd, 1L, pFileIni);
    } else {
        lAdd = lReplace;
    }

    PutLine (lAdd, lbuf, pFileIni);
}


/*** FindMatchLine - Find a line to replace in TOOLS.INI
*
* Purpose:
*
*   Called from UpdToolsIni to find the right place to update
*
* Input:
*   pszTag  -        Which tagged section to look in
*   pszLeft -        Left side of the assignment
*   pszRight-        Right side of the assignment
*   asgType -        Type of assignment (one of ASG_*)
*   plAdd   -        Returns line number of place to insert a new line
*
* Output:
*
*   Returns line number in pFileIni of matchine line, 0L if there is
*   no match and -1L if the specified tag does not exist.
*
*************************************************************************/

LINE
FindMatchLine (
    char * pszTag,
    char * pszLeft,
    char * pszRight,
    int    asgType,
    LINE * plAdd
    ) {

    char pszTagBuf[80];
    char * pchRight, * pchLeft;
    LINE lCur, lNext, lReplace = 0L;
    flagType fUser = FALSE;
    flagType fExtmake = FALSE;
    int cchExt;

    strcpy (pszTagBuf, pNameEditor);
    if (pszTag) {
        strcat (pszTagBuf, "-");
        strcat (pszTagBuf, pszTag);
    }

    if ((LINE)0 == (lNext = LocateTag (pFileIni, pszTagBuf))) {
        return -1L;
    }

    if (!_stricmp (pszLeft, "user")) {
        fUser = TRUE;
    } else if (!_stricmp (pszLeft, "extmake")) {
        pchRight = whitescan (pszRight);
        cchExt = (int)(pchRight - pszRight);
        fExtmake = TRUE;
    }

    // Get each line in the current section, checking the right
    // or left side for a match with the passed-in string.
    //
    pchLeft = NULL;
    while (lCur = lNext, pchLeft = GetTagLine (&lNext, pchLeft, pFileIni)) {
        pchRight = strbscan (pchLeft, ":");
        *pchRight = '\0';
        if (pchRight[1] == '=') {
            if (asgType != ASG_MACRO) {
                continue;
            }
            pchRight++;
        } else if (asgType == ASG_MACRO) {
                continue;
        }
        pchRight = whiteskip (pchRight);

        switch (asgType) {
            case ASG_KEY:
                if (!_stricmp (pszRight, pchRight)) {
                    lReplace = lCur;
                }
                break;

            case ASG_SWITCH:
                if (!_stricmp (pszLeft, pchLeft)) {
                    lReplace = lCur;
                }
                break;

            case ASG_MACRO:
                if (fUser) {
                    continue;
                }

                if (!_stricmp (pszLeft, pchLeft)) {
                    if (!(fExtmake && _strnicmp (pszRight, pchRight, cchExt))) {
                        lReplace = lCur;
                    }
                }
                break;

            default:
                assert (FALSE);
        }
    }

    if (!pszTag) {
        *plAdd = lCur;
    }
    return lReplace;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\cmd.c ===
/*** cmd.c - handle simple keyboard interactions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


#define DEBFLAG CMD

struct cmdDesc	cmdUnassigned = {   "unassigned",   unassigned,     0, FALSE };

/*** unassigned - function assigned to unassigned keystrokes
*
*  display an informative message about the unassigned key
*
* Input:
*  Standard editing function
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
unassigned (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    buffer buf;

    CodeToName ( (WORD)argData, buf);
    if (buf[0]) {
        printerror ("%s is not assigned to any editor function",buf);
    }

    return FALSE;

    pArg; fMeta;
}



/*** confirm - ask our dear user a yes/no question
*
* Purpose:
*  Asks the user a yes/no question, and gets his single character response. If
*  in a macro, the reponse may also come from the macro stream, or from the
*  passed "if in a macro" default response.
*
* Input:
*  fmtstr	= prompt format string
*  arg		= prompt format parameters
*
* Output:
*  TRUE if 'y', else FALSE.
*
*************************************************************************/
flagType
confirm (
    char *fmtstr,
    char *arg
    ) {
    return (flagType)(askuser ('n', 'y', fmtstr, arg) == 'y');
}


/*** confirmx - ask our dear user a yes/no question, no defaults
*
* Purpose:
*  Asks the user a yes/no question, and gets his single character response. If
*  in a macro, the reponse may also come from the macro stream, or from the
*  passed "if in a macro" default response.
*
* Input:
*  fmtstr	= prompt format string
*  arg		= prompt format parameters
*
* Output:
*  TRUE if 'y', FALSE if 'n'  Anything else and it keeps asking
*
*************************************************************************/
flagType
confirmx (
    char *fmtstr,
    char *arg
    ) {
    while (TRUE) {
        switch (askuser (0, 0, fmtstr, arg)) {
        case -1:
        case 'n':
            return FALSE;

        case 'y':
            return TRUE;

        default:
            bell();     // Make them be explicit
            break;
        }
    }
}


/*** askuser - ask our dear user a question
*
* Purpose:
*  Asks the user a question, and gets his single character response. If in
*  a macro, the reponse may also come from the macro stream, or from the
*  passed "if in a macro" default response.
*
* Input:
*  defans	= default answer for non-alpha responses
*  defmac	= default answer if executing in a macro and no "<" is present
*  fmtstr	= prompt format string
*  arg		= prompt format parameters
*
* Output:
*   the lowercase character response.  If the user presses <cancel>, the
*   integer -1 is returned.
*
*************************************************************************/
int
askuser (
    int defans,
    int defmac,
    char *fmtstr,
    char *arg
    ) {
    int c;
    int x;
    PCMD  pcmd;

    switch (c = fMacResponse()) {
    case 0:
        if ((c = defmac) == 0) {
            goto askanyway;
        }
        break;

    default:
        break;

    case -1:
    askanyway:
	DoDisplay ();
	consoleMoveTo( YSIZE, x = domessage (fmtstr, arg));
    pcmd = ReadCmd();
	c = (int)(pcmd->arg & 0xff);
	SETFLAG (fDisplay,RCURSOR);
        if ((PVOID)pcmd->func == (PVOID)cancel) {
	    sout (x, YSIZE, "cancelled", infColor);
	    return -1;
        } else {
            if (!isalpha (c)) {
                c = defans;
            }
	    vout (x, YSIZE, (char *)&c, 1, infColor);
        }
	break;
    }
    return tolower(c);
}


/*** FlushInput - remove all typeahead.
*
*  FlushInput is called when some action invalidates all input.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
FlushInput (
    void
    ) {
    register BOOL MoreInput;
    while (MoreInput = TypeAhead()) {
        ReadCmd ();
    }
}

/*** fSaveDirtyFile - Prompt the user to save or lose dirty files
*
* Purpose:
*
*   Called just before exit to give the user control over soon-to-be-lost
*   editing changes.
*
* Input: None.
*
* Output:
*
*   Returns TRUE if the user wants to exit, FALSE if not.
*
*************************************************************************/
flagType
fSaveDirtyFiles (
    void
    ) {

    REGISTER PFILE pFile;
    int cDirtyFiles = 0;
    flagType fAgain;
    buffer buf;

    assert (_pfilechk());
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
            if (++cDirtyFiles == 2) {
                do {
                    fAgain = FALSE;
                    switch (askuser (-1, -1, GetMsg (MSG_SAVEALL, buf), NULL)) {
                        case 'y':
                            SaveAllFiles ();
                            return TRUE;

                        case 'n':
                            break;

                        case -1:
                            return FALSE;

                        default:
                            fAgain = TRUE;
                    }
                } while (fAgain);
            }

            do {
                fAgain = FALSE;
                switch (askuser (-1, -1, GetMsg (MSG_SAVEONE, buf), pFile->pName)) {
                    case 'y':
                        FileWrite (pFile->pName, pFile);

                    case 'n':
                        break;

                    case -1:
                        return FALSE;

                    default:
                        fAgain = TRUE;
                }
            } while (fAgain);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\cdelete.c ===
/*** cdelete.c - delete the previous character in a line
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "z.h"

/*** cdelete - character delete function
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
cdelete (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    return DoCDelete (FALSE);

    argData; pArg; fMeta;
}


/*** emacsdel - emacs character delete function
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
emacscdel (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    return DoCDelete (TRUE);

    argData; pArg; fMeta;

}


/*** DoCDelete - perform character deletion
*
*  Delete the character at the current cursor location
*
* Input:
*  fEmacs	- EMACs type delete flag
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
DoCDelete (
    flagType fEmacs
    ) {

    fl      fl;                             /* file loc to position at      */
    int     x;
    char    *p;
    linebuf tempbuf;
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;

    fl.col = XCUR(pInsCur);
    fl.lin = YCUR(pInsCur);
    /*
     * xCursor is zero. If yCursor is also zero (top of file), we can't move
     * back, so nothing to delete. Otherwise, move to end of previous line, and
     * if emacs & insert mode, join the lines.
     */
    if (fl.col == 0) {
        if (fl.lin == 0) {
            return FALSE;
        } else {
            fl.lin--;
            fl.col = LineLength (fl.lin, pFileHead);
            if (fInsert && fEmacs) {
                DelStream (pFileHead, fl.col, fl.lin, 0, fl.lin + 1);
            }
        }
    } else {
        /*
         * column is non-zero, so back it up one.
         */
        GetLine (fl.lin, tempbuf, pFileHead);
        x = cbLog (tempbuf);
        fl.col = DecCol (fl.col, tempbuf);
        /*
         * we're in the middle of a line. If in insert mode, back up the cursor, and
         * delete the character there.
         */
        if (fInsert) {
            DelBox (pFileHead, fl.col, fl.lin, fl.col, fl.lin);
        } else {
            /*
             * we're in the middle of a line, but not insert mode. Get the text of the
             * line & pointer to character.
             */
            p = pLog (tempbuf, fl.col, TRUE);
            /*
             * If emacs, and we're actually IN text, then replace the character with a
             * space.
             */
            if (fEmacs) {
                if (fl.col+1 <= x && *p != ' ') {
                    *p = ' ';
                    // SetColor (pFileHead, fl.lin, fl.col, 1, fgColor);
                    PutLine (fl.lin, tempbuf, pFileHead);
                }
            }
            /*
             * if we're beyond the end of the line, just position to the end of the line.
             */
            else if (fl.col+1 > x) {
                fl.col = x;
            }
            /*
             * if the first non-blank character is PAST the current position, then just
             * position at the begining of the line.
             */
            else if ((colPhys (tempbuf, whiteskip (tempbuf)) > fl.col)) {
                fl.col = 0;
            }
            /*
             * finaly, when all else fails, back up, and replace the character under the
             * cursor with a space.
             */
            else if (*p != ' ') {
                *pLog (tempbuf,fl.col,TRUE) = ' ';
                if (fColor = GetColor (fl.lin, rgla, pFileHead)) {
                    ShiftColor (rgla, fl.col, -1);
                    ColorToLog (rgla, buf);
                }
                PutLine (fl.lin, tempbuf, pFileHead);
                if (fColor) {
                    PutColor (fl.lin, rgla, pFileHead);
                }
            }
        }
    }
    cursorfl (fl);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\inc\ztype.h ===
/*** ztype.h - forward declarations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Editor functions - forward type declarations to allow for type-checking
*
*   Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/


flagType          assign         (CMDDATA, ARG *, flagType);
flagType          backtab        (CMDDATA, ARG *, flagType);
flagType          begfile        (CMDDATA, ARG *, flagType);
flagType          begline        (CMDDATA, ARG *, flagType);
flagType          BoxStream      (CMDDATA, ARG *, flagType);
flagType          cancel         (CMDDATA, ARG *, flagType);
flagType          cdelete        (CMDDATA, ARG *, flagType);
flagType          compile        (CMDDATA, ARG *, flagType);
flagType          curdate        (CMDDATA, ARG *, flagType);
flagType          curday         (CMDDATA, ARG *, flagType);
flagType          curtime        (CMDDATA, ARG *, flagType);
flagType          delete         (CMDDATA, ARG *, flagType);
flagType          doarg          (CMDDATA, ARG *, flagType);
flagType          down           (CMDDATA, ARG *, flagType);
flagType          emacscdel      (CMDDATA, ARG *, flagType);
flagType          emacsnewl      (CMDDATA, ARG *, flagType);
flagType          endfile        (CMDDATA, ARG *, flagType);
flagType          endline        (CMDDATA, ARG *, flagType);
flagType          environment    (CMDDATA, ARG *, flagType);
flagType          zexecute       (CMDDATA, ARG *, flagType);
flagType          zexit          (CMDDATA, ARG *, flagType);
flagType          graphic        (CMDDATA, ARG *, flagType);
flagType          home           (CMDDATA, ARG *, flagType);
flagType          information    (CMDDATA, ARG *, flagType);
flagType          zinit          (CMDDATA, ARG *, flagType);
flagType          insert         (CMDDATA, ARG *, flagType);
flagType          insertmode     (CMDDATA, ARG *, flagType);
flagType          lastselect     (CMDDATA, ARG *, flagType);
flagType          ldelete        (CMDDATA, ARG *, flagType);
flagType          left           (CMDDATA, ARG *, flagType);
flagType          linsert        (CMDDATA, ARG *, flagType);
flagType          macro          (CMDDATA, ARG *, flagType);
flagType          mark           (CMDDATA, ARG *, flagType);
flagType          zmessage       (CMDDATA, ARG *, flagType);
flagType          meta           (CMDDATA, ARG *, flagType);
flagType          mgrep          (CMDDATA, ARG *, flagType);
flagType          mlines         (CMDDATA, ARG *, flagType);
flagType          mpage          (CMDDATA, ARG *, flagType);
flagType          mpara          (CMDDATA, ARG *, flagType);
flagType          mreplace       (CMDDATA, ARG *, flagType);
flagType          msearch        (CMDDATA, ARG *, flagType);
flagType          mword          (CMDDATA, ARG *, flagType);
flagType          newline        (CMDDATA, ARG *, flagType);
flagType          nextmsg        (CMDDATA, ARG *, flagType);
flagType          noedit         (CMDDATA, ARG *, flagType);
flagType          noop           (CMDDATA, ARG *, flagType);
flagType          pbal           (CMDDATA, ARG *, flagType);
flagType          zpick          (CMDDATA, ARG *, flagType);
flagType          plines         (CMDDATA, ARG *, flagType);
flagType          ppage          (CMDDATA, ARG *, flagType);
flagType          ppara          (CMDDATA, ARG *, flagType);
flagType          zPrint         (CMDDATA, ARG *, flagType);
flagType          psearch        (CMDDATA, ARG *, flagType);
flagType          searchall      (CMDDATA, ARG *, flagType);
flagType          put            (CMDDATA, ARG *, flagType);
flagType          pword          (CMDDATA, ARG *, flagType);
flagType          qreplace       (CMDDATA, ARG *, flagType);
flagType          quote          (CMDDATA, ARG *, flagType);
flagType          record         (CMDDATA, ARG *, flagType);
flagType          refresh        (CMDDATA, ARG *, flagType);
flagType          repeat         (CMDDATA, ARG *, flagType);
flagType          zreplace       (CMDDATA, ARG *, flagType);
flagType          sdelete        (CMDDATA, ARG *, flagType);
flagType          restcur        (CMDDATA, ARG *, flagType);
flagType          right          (CMDDATA, ARG *, flagType);
flagType          saveall        (CMDDATA, ARG *, flagType);
flagType          savetmpfile    (CMDDATA, ARG *, flagType);
flagType          savecur        (CMDDATA, ARG *, flagType);
flagType          setfile        (CMDDATA, ARG *, flagType);
flagType          setwindow      (CMDDATA, ARG *, flagType);
flagType          sinsert        (CMDDATA, ARG *, flagType);
flagType          zspawn         (CMDDATA, ARG *, flagType);
flagType          tab            (CMDDATA, ARG *, flagType);
flagType          ztell          (CMDDATA, ARG *, flagType);
flagType          lasttext       (CMDDATA, ARG *, flagType);
flagType          promptarg      (CMDDATA, ARG *, flagType);
flagType          unassigned     (CMDDATA, ARG *, flagType);
flagType          zundo          (CMDDATA, ARG *, flagType);
flagType          up             (CMDDATA, ARG *, flagType);
flagType          window         (CMDDATA, ARG *, flagType);
flagType          focus          (CMDDATA, ARG *, flagType);
flagType          SetWinCur      (int);

/*************************************************************************
 *
 *  Exported entries
 *
 *  Direct Exports
 */
PFILE                    AddFile         (char *);
char                     BadArg          (void);
void                     CopyBox         (PFILE,PFILE,COL ,LINE ,COL ,LINE ,COL ,LINE);
void                     CopyLine        (PFILE,PFILE,LINE ,LINE ,LINE);
void                     CopyStream      (PFILE,PFILE,COL ,LINE ,COL ,LINE ,COL ,LINE);
flagType                 DeclareEvent    (unsigned, EVTargs *);
void                     RegisterEvent   (EVT *pEVTDef);
void                     DeRegisterEvent (EVT *pEVTDef);
void                     DelBox          (PFILE, COL, LINE, COL, LINE);
void                     DelStream       (PFILE, COL, LINE, COL, LINE);
void                     DoDisplay       (void);
LINE                     FileLength      (PFILE);
int                      fGetMake        (int, char *, char *);
flagType                 fSetMake        (int, char *, char *);
unsigned short           hWalkMake       (unsigned short, int *, char *, char *);
void                     GetTextCursor   (COL *, LINE *);
flagType                 GetEditorObject (unsigned, void *, void *);
void                     MoveCur         (COL ,LINE);
flagType                 pFileToTop      (PFILE);
void                     postspawn       (flagType);
flagType                 prespawn        (flagType);

PCMD                     ReadCmd         (void);
void                     RemoveFile      (PFILE);
flagType                 Replace         (char, COL, LINE, PFILE, flagType);
/*
 * Routines "      ed" through a filter in load.c
 */
void                     DelFile         (PFILE, flagType);
void                     DelLine         (flagType, PFILE, LINE ,LINE);
void                     Display         (void);
char                     fChangeFile     (char , char *);
flagType                 fExecute        (char *);
PFILE                    FileNameToHandle (const char *, const char *);
flagType                 FileRead        (char *,PFILE, flagType);
flagType                 FileWrite       (char *,PFILE);
PSWI                     FindSwitch      (char *);
flagType                 GetColor        (LINE, struct lineAttr *, PFILE);
flagType                 GetColorUntabbed(LINE, struct lineAttr *, PFILE);
int                      GetLine         (LINE ,char *,PFILE);
int                      GetLineUntabed  (LINE ,char *,PFILE);
void                     PutColor        (LINE, struct lineAttr *, PFILE);
void                     PutColorPhys    (LINE, struct lineAttr *, PFILE);
void                     PutLine         (LINE, char *, PFILE);
void                     DelColor        (LINE, PFILE);
int                      REsearch        (PFILE, flagType, flagType, flagType, flagType, struct patType *, fl *);
int                      search          (PFILE, flagType, flagType, flagType, flagType, char *, fl *);
flagType                 SetKey          (char *,char *);
char *                   GetTagLine      (LINE *, char *, PFILE);
void                     PutTagLine      (PFILE, char *, LINE, COL);


/*
 *  Switch setting functions
 */
char *            SetBackup              (char *);
char *            SetCursorSizeSw        (char *);
char *            SetExt                 (char *);
char *            SetFileTab             (char *);
char *            SetLoad                (char *);
char *            SetMarkFile    (char *);
flagType          SetPrintCmd    (char *);
flagType          SetROnly               (char *);
flagType          SetTabDisp             (char *);
flagType          SetTrailDisp   (char *);
char *            SetKeyboard    (char *);

/*           definitions.
 */
char *   SetCursorSize  ( int );
void              resetarg       (void);
void              delarg         (ARG *);
flagType          fCursor        (PCMD);
flagType          fWindow        (PCMD);
flagType          Arg            (flagType);
void              IncArg         (void);
flagType          fGenArg        (ARG *, unsigned int);
void              UpdateHighLight(COL, LINE, flagType);
PCMD              NameToFunc     (char *);
flagType          DoAssign       (char *);
flagType          SetNamedKey    (char *,char *);
flagType          SetMacro       (const char *, const char *);
flagType          SetSwitch      (char *,char *);
flagType          DoCDelete      (char);
char              confirm        (char *, char *);
char              confirmx       (char *, char *);
int               askuser        (int, int, char *,char *);
void              FlushInput     (void);
char *            BuildFence     (const char *, const char *, char *);
void                     DoFence        (char *, flagType);
void              cursorfl       (fl);
void              docursor       (COL ,LINE);
int               dobol          (void);
int               doeol          (void);
int               doftab         (int);
int               dobtab         (int);
flagType          DoText         (int ,int);
flagType          SplitWnd       (PWND, flagType, int);
void              DoStatus       (void);
void              redraw         (PFILE, LINE ,LINE);
void              newscreen      (void);
void              newwindow      (void);
void              noise          (LINE);
void     __cdecl  StatusCat      (unsigned int, char *, char *, ...);
void              bell           (void);
void              makedirty      (PFILE);
void              doscreen       (COL ,LINE ,COL ,LINE);
void              delay          (int);
void              SetScreen      (void);
void              HighLight      (COL ,LINE ,COL ,LINE);
void              AdjustLines    (PFILE, LINE ,LINE);
flagType          UpdateIf       (PFILE, LINE, flagType);
PWND              IsVispFile     (PFILE, PWND);
ULONG             ZWrite        (ULONG Row, ULONG Col, PVOID pBuffer, ULONG BufferSize, DWORD attr, BOOL BlankToEndOfLine, BOOL ShowIt);
flagType          fInRange       (long ,long ,long);
int               DisplayLine    (int, char *, struct lineAttr **, char *, struct lineAttr **);
void              ShowTrailDisp  (buffer, int);
char *          GetFileTypeName(void);
void              SetFileType    (PFILE);
flagType          fInitFileMac   (PFILE);
void              AutoSave       (void);
void              AutoSaveFile   (PFILE);
void              IncFileRef     (PFILE);
void              DecFileRef     (PFILE);
char              fChangeDrive   (const char *);
void		  zputsinit	 (void);
int		  zputs 	 (char *, int, FILEHANDLE);
int		  zputsflush	 (FILEHANDLE);
void              ReestimateLength (PFILE,FILEHANDLE,long);
LINE              readlines      (PFILE, FILEHANDLE);
char              fReadOnly      (char *);
void              SaveAllFiles   (void);
char              LoadDirectory  (char *,PFILE);
char              LoadFake       (char *,PFILE);
char              SaveFake       (char *,PFILE);
char              fScan          (fl,flagType (         *)(void),char, flagType);
void              setAllScan     (char);
PCMD              getstring      (char *,int, char *,PCMD,flagType);
void              ScrollOut      (char *, char *, int, int, flagType);
flagType          edit           (char);
flagType          szEdit         (char *);
void              FreeMacs       (void);
void              CodeToName     (WORD ,char *);
WORD              NameToCode     (char *);
void              FuncOut        (PCMD, PFILE);
char *            FuncToKey      (PCMD, char *);
void              UnassignedOut  (PFILE);
char *            FuncToKeys     (PCMD, char *);
PCMD              ReadCmdAndKey  (char *);
int               tblFind        (char * [],char * ,flagType);
char              parseline      (char *,char * *,char * *);
int               csoftcr        (COL ,LINE ,char *);
int               softcr         (void);
flagType          mtest          (void);
flagType          mlast          (void);
flagType          fFindLabel     (struct macroInstanceType *,buffer);
void              mPopToTop      (void);
PCMD              mGetCmd        (void);
flagType          fParseMacro    (struct macroInstanceType *, char *);
int               fMacResponse   (void);

flagType             GoToMark       (char *);
PFILE                FindMark       (char *, fl *, flagType);
MARK *               FindLocalMark  (char *, flagType);
MARK *               GetMarkFromLoc (LINE, COL);
void                 MarkInsLine    (LINE, LINE, PFILE);
void                 MarkDelLine    (PFILE, LINE, LINE);
void                 MarkDelStream  (PFILE, COL, LINE, COL, LINE);
void                 MarkDelBox     (PFILE, COL, LINE, COL, LINE);
flagType             fReadMarks     (PFILE);
void                 WriteMarks     (PFILE);
void                 UpdMark        (FILEMARKS **, char *, LINE, COL, flagType);
void                 DefineMark     (char *, PFILE, LINE, COL, flagType);
void                 DeleteMark     (char *);
void                 DelPMark       (MARK *);
void                 MarkCopyLine   (PFILE, PFILE, LINE, LINE, LINE);
void                 MarkCopyBox    (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
FILEMARKS *          GetFMFromFile  (PFILE, COL, LINE, COL, LINE);
void                 AddFMToFile    (PFILE, FILEMARKS *, COL, LINE);
void                 FreeCache      (void);
flagType             fCacheMarks    (PFILE);
void                 AdjustMarks    (MARK *, LINE);
flagType             fMarkIsTemp    (char *);
flagType             fFMtoPfile     (PFILE, FILEMARKS *);
PVOID                FMtoVM         (FILEMARKS *);
PVOID                GetMarkRange   (PFILE, LINE, LINE);
void                 PutMarks       (PFILE, PVOID, LINE);
int                  flcmp          (fl *, fl *);

char              fDoBal         (void);
int               InSet          (char ,char *);
void              pick           (COL ,LINE ,COL ,LINE ,int);
void              ReplaceEdit    (char *,char *);
void              simpleRpl      (char *);
void              patRpl         (void);
char              fDoReplace     (void);
flagType          doreplace      (flagType, ARG *, flagType, flagType);
void              AppFile        (char *, PFILE);
void              appmsgs        (int, PFILE);
void              showasg        (PFILE);
flagType          infprint       (PFILE,PFILE);
void              showinf        (PFILE);
void              ShowMake       (PFILE);
int               TabMin         (int ,char *,char *);
int               TabMax         (int ,char *,char *);
int               LineLength     (LINE ,PFILE);
void              InsertLine     (LINE, char *, PFILE);
LINE    __cdecl   zprintf        (PFILE, LINE, char const *, ...);
int               gettextline    (char ,LINE ,char *,PFILE, char);
int               getcolorline   (flagType, LINE, struct lineAttr *, PFILE);
void              puttextline    (flagType, flagType, LINE, char *, PFILE);
void              putcolorline   (flagType, LINE, struct lineAttr *, PFILE);
void              BlankLines     (LINE ,PVOID);
void              BlankColor     (LINE, PVOID);
void              growline       (LINE ,PFILE);
void              InsLine        (flagType, LINE ,LINE ,PFILE);
flagType          fInsSpace      (COL ,LINE ,int ,PFILE, linebuf);
flagType          fInsSpaceColor (COL ,LINE ,int ,PFILE, linebuf, struct lineAttr *);
void              delspace       (COL ,LINE ,int ,PFILE, linebuf);
int               fcolcpy        (struct lineAttr * , struct lineAttr * );
void              ShiftColor     (struct lineAttr [], COL, int);
void              SetColor       (PFILE, LINE, COL, COL, int);
void              CopyColor      (PFILE, PFILE, LINE, COL, COL, LINE, COL);
void              SetColorBuf    (struct lineAttr *, COL, int, int);
flagType          fGetColorPos   (struct lineAttr **, COL *);
void              ColorToPhys    (struct lineAttr *, LINE, PFILE);
void              ColorToLog     (struct lineAttr *, char *);

void              SetHiLite      (PFILE, rn, int);
void              ClearHiLite    (PFILE, flagType);
flagType          UpdHiLite      (PFILE, LINE, COL, COL, struct lineAttr **);
void              UpdOneHiLite   (struct lineAttr *, COL, COL, flagType, INT_PTR);
void              rnOrder        (rn *);

void              BoxToStream    (ARG *);
void              StreamToBox    (ARG *);

void              AckReplace     (LINE, flagType);
void              AckMove        (LINE, LINE);
void              DoAssignLine   (LINE);
void              UpdToolsIni    (char *);
LINE              FindMatchLine  (char *, char *, char *, int, LINE *);

void              GetCurPath     (char *);
flagType          SetCurPath     (char *);

flagType          ExpungeFile    (void);
void              FreeFileVM     (PFILE);
PFILE             pFileLRU       (PFILE);


void              saveflip       (void);
void              restflip       (void);
void              movewin        (COL ,LINE);
void              SortWin        (void);
int               WinInsert      (PWND);
char              Adjacent       (int ,int);
char              WinClose       (int);
char              fDoWord        (void);
PCMD              zloop          (flagType);
flagType          zspawnp        (char const *, flagType);
flagType          DoCancel       (void);
char              testmeta       (void);
char *            ZMakeStr       (const char *);
void              TCcursor       (char ,char);

#define sout(x,y,p,clr)         ((int)x + ZWrite(y, x, p, strlen(p), clr, FALSE, fReDraw))
#define soutb(x,y,p,clr)        ((int)x + ZWrite(y, x, p, strlen(p), clr, TRUE, fReDraw))
#define vout(x,y,p,c,clr)       ((int)x + ZWrite(y, x, p, c, clr, FALSE, fReDraw))
#define voutb(x,y,p,c,clr)      ((int)x + ZWrite(y, x, p, c, clr, TRUE, fReDraw))

#define consoleMoveTo(y, x)     consoleSetCursor(ZScreen, y, x)


int               coutb          (int ,int ,char *,int ,struct lineAttr *);
void              ToRaw          (void);
void              ToCooked       (void);
char *            VideoTag       (void);
char *            whiteskip      (char const *);
char *            whitescan      (char const *);
int               RemoveTrailSpace (char *);
char *            DoubleSlashes  (char *);
char *            UnDoubleSlashes(char *);
flagType  __cdecl FmtAssign      (char *, ...);
flagType          SendCmd        (PCMD);
void              RecordCmd      (PCMD);
void              RecordString   (char *);
void              AppendMacroToRecord (PCMD);
flagType          fSyncFile      (PFILE, flagType);
void              RemoveInstances(PFILE);
int               FileStatus     (PFILE, char *);
void              SetModTime     (PFILE);
time_t            ModTime        (char *);
void              LengthCheck    (LINE, int, char *);
void              IntError       (char *);
#if 0
flagType          CheckForDirt   (void);
#else
flagType          fSaveDirtyFiles(void);
#endif
flagType          InitExt        (char *);
LINE              DoInit         (char *, char *, LINE);
char *            IsTag          (char *);
LINE              LocateTag      (PFILE, char *);
char *            GetIniVar      (char *, char *);
int               loadini        (flagType);
int               init           (void);
void              WriteTMPFile   (void);
flagType          ReadTMPFile    ();
void              RemoveTop      (void);
flagType          dosearch       (flagType, ARG *, flagType, flagType);
int               REsearchS      (PFILE, flagType, flagType, flagType, flagType, char *, fl *);
void                     mgrep1file     (char *, struct findType *, void *);
void                     mrepl1file     (char *, struct findType *, void *);
flagType         mgrep1env  (char *, va_list);
flagType          fFileAdvance   (void);
LINE              SetFileList    (void);
void              TopLoop        (void);
void              LeaveZ         (void);
DECLSPEC_NORETURN void              CleanExit      (int, flagType);
flagType          fPushEnviron   (char *, flagType);
flagType          fIsNum         (char *);
void              InitNames      (char *);
void              ParseCmd       (char *, char **, char **);
flagType          fIsBlank       (PFILE, LINE);
flagType          fVideoAdjust   (int, int);


flagType __cdecl  disperr        (int, ...);
flagType __cdecl  dispmsg        (int, ...);
int      __cdecl  domessage      (char *, ...);
int      __cdecl  printerror     (char *,...);
char *            GetMsg         (unsigned, char *);
void              CreateUndoList (PFILE);
void              LinkAtHead     (PVOID, union Rec *,PFILE);
int               FreeUndoRec    (flagType,PFILE);
int               UnDoRec        (PFILE);
void		  LogReplace	 (PFILE, LINE, LINEREC *, struct colorRecType *);
void              LogInsert      (PFILE, LINE, LINE);
void              LogDelete      (PFILE, LINE, LINE);
void              LogBoundary    (void);
int               ReDoRec        (PFILE);
flagType          fIdleUndo      (flagType);
void              FlushUndoBuffer (void);
void              RemoveUndoList (PFILE);
flagType          fundoable      (flagType);
LINE              updateLine     (PFILE, LINE);
LINE              unupdateLine   (PFILE, LINE);

int                      ZFormat        (REGISTER char *, const REGISTER char *, va_list);

/*  Declarations controlled by C runtime
 */
int                      CtrlC          (ULONG);

#if defined (DEBUG)

void *                   DebugMalloc        (int, BOOL, char *, int);
void *                   DebugRealloc       (void *, int, BOOL, char *, int);
void                     DebugFree          (void *, char *, int);
unsigned                 DebugMemSize       (void *, char *, int);

#endif
/*
 *          Debugging assertion support
 */
#ifdef DEBUG
void              _assertexit    (char *, char *, int);
void              _heapdump      (char *);
flagType          _pfilechk      (void);
flagType          _pinschk       (PINS);
void *            _nearCheck     (void *, char *, char *, int);
#endif

void *                   ZeroMalloc     (int);
void *                   ZeroRealloc    (void *, int);
unsigned                 MemSize        (void *);

/*  Assembly declarations
 */
int                      fstrnicmp      (char *, char *, int);
char *               fstrcpy        (char *, char *);
int                      fstrlen        (char *);
int               zfstrcmp       (char *, char *);
int               fstricmp       (char *, char *);
int               iHash          (long, int);

int               Untab         (int, const char*, int, char*, char);
COL               AlignChar     (COL, const char*);

void              KbHookAsm      (void);
flagType          SetKBType      (void);
void              GetScreenSize (int *, int *);
flagType          SetScreenSize (int, int);
void              SetVideoState  (int);
void              SaveScreen     (void);
void              RestoreScreen  (void);
void                                     WindowChange ( ROW     Rows,  COLUMN   Cols);
int               LineOut        (int, int, const char *, int, int);
int               LineOutB       (int, int, const char *, int, int);
void              HWInit         (void);
void              HWReset        (void);
flagType          Idle           (void);
//void            Yield          (void);
//char *                  lsearch        (char *, int, char *, int);

int               DosLoadModuleHack (char *, int, char *, unsigned int *);
void                     IdleThread     ( void );
int               OS2toErrno     (int);
char *            OS2toErrText   (int, char *);

flagType          fMapEnv        (char *pSrc, char *pDst, int cbDst);
flagType          fSetEnv        (char *p);
void              showenv        (PFILE pFile);
/*
 * Extension Load/Auto-Load
 */
#if defined (HELP_HACK )
char *                  HelpLoad(void);
#endif
char *           load       (char *, flagType);
void             AutoLoadExt    (void);
flagType         AutoLoadDir    (char *, va_list);
void                     AutoLoadFile   (char *, struct findType *, void *);

/*
 * Printing
 */

flagType          DoPrint        (PFILE, flagType);
PFILE             GetTmpFile     (void);


void                     CleanPrint     (char *, flagType);



/*
 * Background Threads
 */

BTD*              BTCreate      (char *);
flagType          BTAdd         (BTD *, PFUNCTION, char *);
flagType          BTKill        (BTD *);
flagType          BTKillAll     (void);
flagType          BTWorking     (void);
void              BTIdle        (void);
void                     BThread       (BTD *);


/*
 * List handling module
 */
void              ListWalker     (PCMD, flagType (         *)(PCMD, char *, PMI, int), flagType);
char *            ScanList       (PCMD, flagType);
char *            ScanMyList     (PCMD, PMI, buffer, flagType);
flagType          fParseList     (PMI,char *);
flagType          fScanPush      (PMI);
flagType          fScanPop       (PMI);
PCMD              GetListHandle  (char *, flagType);
void              AddStrToList   (PCMD, char *);
flagType          fInList        (PCMD, char *, flagType);
flagType          fDelStrFromList(PCMD, char *, flagType);
flagType          CheckAndDelStr (PCMD, char *, PMI, int);
char *            GetListEntry   (PCMD, int, flagType);
int               ListLen        (PCMD, flagType);
flagType          fEmptyList     (PCMD);
void              InitParse      (PCMD, PMI);
void              Listize        (char *);
char *            CanonFilename  (char * src, char * dst);
flagType          fEnvar         (char *);
void              ClearList      (PCMD);
/*
 * real tabs
 */
char *                   pLog           (char*, COL, flagType);
int               cbLog          (char *);
COL               colPhys        (char *, char *);
COL               DecCol         (COL, char *);
COL               IncCol         (COL, char *);


FILEHANDLE  ZFOpen    (LPBYTE FileName,  ACCESSMODE  Access, SHAREMODE  Share, BOOL fCreate);
void        ZFClose   (FILEHANDLE Handle );
DWORD       ZFRead    (PVOID  pBuffer, DWORD  Size, FILEHANDLE  Handle);
DWORD       ZFWrite   (PVOID pBuffer,  DWORD Size, FILEHANDLE  Handle);
DWORD       ZFSeek    (FILEHANDLE  Handle, DWORD  Distance,  MOVEMETHOD  MoveMethod);

#pragma intrinsic( memset,      memcpy )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\arg.c ===
/*** arg.c - argument handler
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip out near/far
*
*************************************************************************/
#include "z.h"


typedef flagType (*FUNCSAVED)(CMDDATA, ARG *, flagType);

PVOID   vaHiLiteSave    = (PVOID)(-1L);
fl      flLastArg;
fl      flLastCursor;

//
// Globals set by SendCmd and used by repeat to repeat the last command
//
flagType    fOKSaved = FALSE;
FUNCSAVED   funcSaved;
CMDDATA     argDataSaved;
ARG         argSaved;
flagType    fMetaSaved;



/*** doarg - perform arg processing
*
*  doarg is the editor function that is used to indicate the beginning of
*  an argument to an editor function.
*
* Input:
*  Standard Editting Function (Everything ignored).
*
* Output:
*  Returns the value returned by editor function that terminates arg. If
*  invalid arg was found, then the return is FALSE.
*
*************************************************************************/
flagType
doarg (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    return Arg (FALSE);
    argData; pArg; fMeta;
}



/*** resetarg - throw away all arg input and restore cursor position.
*
*  Several functions (cancel, invalid args) discard the current arg context.
*  We parse the current arg input and then reset the cursor to the original
*  position.
*
* Input:
*  nothing
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
resetarg (void)
{
    UpdateHighLight (-1, -1L, FALSE);
    pInsCur->pFile->vaHiLite = vaHiLiteSave;
    vaHiLiteSave = (PVOID)(-1L);
    if (argcount)
        pInsCur->flCursorCur = flArg;
    argcount = 0;
}



/*** fCursor - decide if an editor function is a cursor movement function
*
*  When reading in an argument, editor functions that move the cursor are
*  allowed as long as no text has been input.  fCursor defines that set
*  of allowed functions.
*
* Input:
*  pCmd 	= pointer to the internal editor function
*
* Output:
*  Returns TRUE if pCmd is a cursor movement function
*
*************************************************************************/
flagType
fCursor (
    PCMD pCmd
    ) {
    return (flagType) TESTFLAG (pCmd->argType, CURSORFUNC);
}



/*** fWindow - decide if an editor function is a window movement function
*
*  After highlighting text, we are allowed to move the window about via
*  window movement functions without removing the highlight.  fWindow
*  defines that set of window functions.
*
* Input:
*  pf		= pointer to the internal editor function
*
* Output:
*  Returns TRUE if pf is a window movement function
*
*************************************************************************/
flagType fWindow (
    PCMD pCmd
    ) {
    return (flagType) TESTFLAG (pCmd->argType, WINDOWFUNC);
}



/*** Arg - perform all low-level arg processing
*
*  Arg () is responsible for the display of the arg, handling all cursor
*  movement, handling textarg input.
*
* Input:
*  fToText	= TRUE => go immediately to text arg processing, else allow
*		  allow cursor movement
*  fRestore	= TRUE => Establish a test selection before continuing
* Output:
*  Returns value returned by editor function that terminates arg. If invalid
*  arg was found, then the return is FALSE.
*
*************************************************************************/
flagType
Arg (
    flagType fRestore
    ) {
    REGISTER PCMD pFunc = NULL;
    char     p[20];
    char     tbuf[20];

    /*
     * We are being called for a lastselect.  Restore the
     * text selection stored in pInsCur and continue
     */
    if (fRestore) {
	vaHiLiteSave = pInsCur->pFile->vaHiLite;
	ClearHiLite (pInsCur->pFile, FALSE);
	flArg = pInsCur->flArg;
	cursorfl (pInsCur->flCursor);
	UpdateHighLight (XCUR(pInsCur), YCUR(pInsCur), TRUE);
	argcount++;
    } else {
	IncArg ();
    }

    if (!mtest()) {
        dispmsg (MSG_ARGCOUNT,argcount);
    }

    /*
     * Loop to do do cursor movements and display any extra arg indicators
     */

    fInSelection = TRUE;

    while (TRUE) {
        if ((pFunc = zloop (ZL_BRK)) == NULL) {
	    return FALSE;
        } else if ((PVOID)pFunc->func == (PVOID)doarg) {
	    argcount++;
            if (!mtest()) {
                dispmsg (MSG_ARGCOUNT,argcount);
            }
        } else if (fCursor (pFunc) || (PVOID)pFunc->func == (PVOID)meta) {
	    fRetVal = SendCmd (pFunc);
	    UpdateHighLight ( XCUR(pInsCur), YCUR(pInsCur), TRUE);
        } else {
            break;
        }
    }

    fInSelection = FALSE;

    /*
     * Get text arg, if needed.
     * Note that we only accept textarg if no cursor movement occured
     */
    if (   (((PVOID)pFunc->func == (PVOID)graphic) ||
            ((PVOID)pFunc->func == (PVOID)quote))
	&& (pInsCur->flCursorCur.lin == flArg.lin)
	&& (pInsCur->flCursorCur.col == flArg.col)
       ) {
	fTextarg = TRUE;
	sprintf(p,GetMsg(MSG_ARGCOUNT, tbuf), argcount);
	strcat (p, ": ");
	textbuf[0] = '\0';
        pFunc = getstring (textbuf, sizeof(textbuf), p, pFunc, FALSE);
    }

    /*
     * If textarg ended in valid function, execute it.
     */
    if (pFunc != NULL) {
	if (!fTextarg) {
	    pInsCur->flArg = flArg;
	    pInsCur->flCursor = pInsCur->flCursorCur;
        }
	return (SendCmd (pFunc));
    }

    return FALSE;
}



/*** IncArg - Increment the arg count
*
* If first arg, save current highlight info on th file, and clear any
* highlighting on screen. Set flArg to be the arg start position, and
* highlight that position.
*
* Input:
*   Nothing
*
* Output:
*   Nothing
*
*************************************************************************/
void IncArg (
) {
    if (!argcount++) {
	vaHiLiteSave = pInsCur->pFile->vaHiLite;
	ClearHiLite (pInsCur->pFile, FALSE);
	flArg = pInsCur->flCursorCur;
	UpdateHighLight (XCUR(pInsCur)+1, YCUR(pInsCur), TRUE);
    }
}



/**** fGenArg - generate the argument based upon editor state
*
*  fGenArg is called to convert the combination of arg, cursor, and
*  additional text into an argument structure to be handed to the editor
*  functions.
*
* Input:
*  pArg 	= pointer to arg structure that will be filled in
*  flags	= bit vector indicating type of arg processing required
*
* Globals:
*  argcount	= number of times ARG has been hit
*  fBoxArg	= Determines argument type (non-CW)
*  SelMode	= Determines argument type (CW)
*  flArg	= File location of arg cursor (may be updated)
*  fTextarg	= TRUE => textarg is present
*  pInsCur	= used for current user cursor location
*  textbuf	= buffer containing any text argument
*
* Output:
*  Returns TRUE if a valid argument was parsed off, FALSE otherwise
*
*************************************************************************/
flagType
fGenArg (
    REGISTER ARG *pArg,
    unsigned int flags
    ) {
    int cArg = argcount;
    long numVal  = 0;			/* value of numarg		*/
    flagType fTextArgLocal = fTextarg;

    fTextarg = FALSE;
    argcount = 0;
    if (cArg == 0) {
	if (TESTFLAG (flags, NOARG)) {
	    pArg->argType = NOARG;
	    pArg->arg.noarg.y = YCUR(pInsCur);
	    pArg->arg.noarg.x = XCUR(pInsCur);
	    return TRUE;
        } else {
            return FALSE;
        }
    } else {
	fl  flLow;
	fl  flHigh;
	fl  flCur;

	flCur = pInsCur->flCursorCur;

	cursorfl (flArg);
	/*  Specially handle text arguments.  User may specify a
	 *  number or a mark that will define the other endpoint
	 *  of an arg region.
	 */
	if (fTextArgLocal) {
	    if (TESTFLAG (flags, NUMARG) && fIsNum (textbuf)) {

		numVal = atol (textbuf);
		if (numVal != 0)
		    flArg.lin = lmax ((LINE)0, flArg.lin + numVal + (numVal > 0 ? -1 : 1));
		fTextArgLocal = FALSE;
            } else if (TESTFLAG (flags,MARKARG) && FindMark (textbuf, &flArg, FALSE)) {
                fTextArgLocal = FALSE;
            }
        }

	flLow.col  = min  (flArg.col, flCur.col);
	flHigh.col = max  (flArg.col, flCur.col);
	flLow.lin  = lmin (flArg.lin, flCur.lin);
	flHigh.lin = lmax (flArg.lin, flCur.lin);

	/*  flArg represents the location of one part of an argument
	 *  and the current cursor position represent the location of the
	 *  other end.	Based upon the flags, we ascertain what type of
	 *  argument is intended.
	 */
	if (fTextArgLocal) {
	    if (TESTFLAG (flags, TEXTARG)) {
		pArg->argType = TEXTARG;
		pArg->arg.textarg.cArg = cArg;
		pArg->arg.textarg.y = flCur.lin;
		pArg->arg.textarg.x = flCur.col;
		pArg->arg.textarg.pText = (char *) textbuf;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (flCur.col == flArg.col && flCur.lin == flArg.lin && numVal == 0) {
	    if (TESTFLAG (flags, NULLARG)) {
		pArg->argType = NULLARG;
		pArg->arg.nullarg.cArg = cArg;
		pArg->arg.nullarg.y = flCur.lin;
		pArg->arg.nullarg.x = flCur.col;
		return TRUE;
            } else if (TESTFLAG (flags, NULLEOL | NULLEOW)) {
		fInsSpace (flArg.col, flArg.lin, 0, pFileHead, textbuf);
                if (TESTFLAG (flags, NULLEOW)) {
                    *whitescan (pLog(textbuf, flArg.col, TRUE)) = 0;
                }
		strcpy (&textbuf[0], pLog (textbuf, flArg.col, TRUE));
		pArg->argType = TEXTARG;
		pArg->arg.textarg.cArg = cArg;
		pArg->arg.textarg.y = flCur.lin;
		pArg->arg.textarg.x = flCur.col;
		pArg->arg.textarg.pText = (char *) textbuf;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (TESTFLAG (flags, BOXSTR) && flCur.lin == flArg.lin) {
	    fInsSpace (flHigh.col, flArg.lin, 0, pFileHead, textbuf);
	    *pLog (textbuf, flHigh.col, TRUE) = 0;
	    strcpy (&textbuf[0], pLog (textbuf, flLow.col, TRUE));
	    pArg->argType = TEXTARG;
	    pArg->arg.textarg.cArg = cArg;
	    pArg->arg.textarg.y = flArg.lin;
	    pArg->arg.textarg.x = flArg.col;
	    pArg->arg.textarg.pText = (char *) textbuf;
	    return TRUE;
        } else if (fBoxArg) {
	    if (TESTFLAG (flags, LINEARG) && flArg.col == flCur.col) {
		pArg->argType = LINEARG;
		pArg->arg.linearg.cArg = cArg;
		pArg->arg.linearg.yStart = flLow.lin;
		pArg->arg.linearg.yEnd	 = flHigh.lin;
		return TRUE;
            } else if (TESTFLAG (flags, BOXARG) && flArg.col != flCur.col) {
		pArg->argType = BOXARG;
		pArg->arg.boxarg.cArg = cArg;
		pArg->arg.boxarg.yTop = flLow.lin;
		pArg->arg.boxarg.yBottom = flHigh.lin;
		pArg->arg.boxarg.xLeft = flLow.col;
		pArg->arg.boxarg.xRight = flHigh.col-1;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (TESTFLAG (flags, STREAMARG)) {
            pArg->argType = STREAMARG;
            pArg->arg.streamarg.cArg = cArg;
            if (flCur.lin > flLow.lin) {
                pArg->arg.streamarg.yStart = flArg.lin;
                pArg->arg.streamarg.xStart = flArg.col;
                pArg->arg.streamarg.yEnd = flCur.lin;
                pArg->arg.streamarg.xEnd = flCur.col;
            } else if (flArg.lin == flCur.lin) {
                pArg->arg.streamarg.yStart = pArg->arg.streamarg.yEnd = flArg.lin;
                pArg->arg.streamarg.xStart = flLow.col;
                pArg->arg.streamarg.xEnd = flHigh.col;
            } else {
                pArg->arg.streamarg.yStart = flCur.lin;
                pArg->arg.streamarg.xStart = flCur.col;
                pArg->arg.streamarg.yEnd = flArg.lin;
                pArg->arg.streamarg.xEnd = flArg.col;
            }
            return TRUE;
        } else {
            return FALSE;
        }
    }
}



/*** BadArg - inform the user that an invalid arg was input
*
*  Clear arg & print standard error message.
*
* Input:
*  none
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
BadArg ()
{
    resetarg ();
    return disperr (MSGERR_INV_ARG);
}



/*** SendCmd - take a CMD and call it with the appropriate argument parsing
*
*  If the function to be executed is not a window movement command nor a
*  cursor movement command, we remove any highlighting that is present. For
*  cleanliness, we pass a NOARG to cursor and window functions if none is
*  specified. If the function takes args, we decode them. Any errors report
*  back at this point. Finally, we dispatch to the function, sending him the
*  appropriate argument.
*
* Input:
*  pCmd 	    = pointer to command to execute.
*
* Output:
*  Returns value returned by command
*
*************************************************************************/
flagType
SendCmd (
PCMD pCmd
) {
    ARG arg;
    flagType fMeta = (flagType) (TESTFLAG (pCmd->argType, KEEPMETA) ? FALSE : testmeta ());
    flagType fArg  = (flagType) argcount;

    arg.argType = NOARG;
    arg.arg.noarg.x = XCUR(pInsCur);
    arg.arg.noarg.y = YCUR(pInsCur);

    if (TESTFLAG(pCmd->argType, GETARG)) {
	if (!fGenArg (&arg, pCmd->argType)) {
            if (fArg) {
		BadArg ();
            } else {
                disperr (MSGERR_ARG_REQ);
            }
	    return FALSE;
        }
        if (!fCursor (pCmd) && ! fWindow (pCmd)) {

            //  Not a coursor position.
            //  discard any pre-existing highlighting.

            PVOID        vaSave;

	    vaSave = pInsCur->pFile->vaHiLite;
	    pInsCur->pFile->vaHiLite = vaHiLiteSave;
            vaHiLiteSave = (PVOID)(-1L);
	    ClearHiLite (pInsCur->pFile, TRUE);

	    pInsCur->pFile->vaHiLite = vaSave;
        } else if (vaHiLiteSave == (PVOID)(-1L)) {

            // Preserve pre-existing hilighting

	    vaHiLiteSave = pInsCur->pFile->vaHiLite;
	    ClearHiLite (pInsCur->pFile, FALSE);
        }
	resetarg ();
    }

    if (   TESTFLAG (pCmd->argType, MODIFIES)
        && (TESTFLAG (pFileHead->flags, READONLY) || fGlobalRO)) {
        return disperr (MSGERR_NOEDIT);
    }

    if (!fMetaRecord || (PVOID)pCmd->func == (PVOID)record) {
        if (((PVOID)pCmd->func != (PVOID)repeat) && !mtest()) {
            if (argSaved.argType == TEXTARG) {
                FREE (argSaved.arg.textarg.pText);
            }
            funcSaved    = (FUNCSAVED)pCmd->func;
	    argDataSaved = pCmd->arg;
	    argSaved	 = arg;
	    fMetaSaved	 = fMeta;
            if (arg.argType == TEXTARG) {
		argSaved.arg.textarg.pText = ZMakeStr (arg.arg.textarg.pText);
            }
	    fOKSaved = TRUE;
        }
	return (*pCmd->func) (pCmd->arg, (ARG *)&arg, fMeta);
    }

    return FALSE;
}



/*** repeat - repeat the last command
*
*  repeat is the editor function that is used to repeat the last executed function
*
* Input:
*  Standard Editting Function. (Everything ignored)
*
* Output:
*  Returns .....
*
*************************************************************************/
flagType
repeat (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    return fOKSaved
	    ? (*funcSaved) (argDataSaved, (ARG *) &argSaved, fMetaSaved)
            : disperr (MSGERR_NOREP);

    argData; pArg; fMeta;
}


/*** lasttext - perform arg processing on the dialog line
*
*  TextArg is the editor function that is used to allow reediting of a text
*  arg on the dialog line.
*
*  If used with a selection, the first line of the selection is presented
*  for editing.
*
* Input:
*  Standard Editting Function.
*
* Output:
*  Returns .....
*
* Globals:
*  textbuf	= buffer containing any the argument
*
*************************************************************************/
flagType
lasttext (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    REGISTER PCMD pFunc = NULL;
    int 	  cArg	= 0;
    char	  p[20];
    char	  tbuf[20];

    switch (pArg->argType) {
	case NULLARG:
	    cArg = pArg->arg.nullarg.cArg;

	case NOARG:
	    cArg ++;
	    break;

	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, textbuf);
	    *pLog (textbuf, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    strcpy (textbuf, pLog (textbuf, pArg->arg.boxarg.xLeft, TRUE));
	    cArg = pArg->arg.boxarg.cArg;
	    break;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, textbuf, pFileHead);
	    cArg = pArg->arg.linearg.cArg;
	    break;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, textbuf);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (textbuf, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    strcpy (textbuf, pLog (textbuf, pArg->arg.streamarg.xStart, TRUE));
	    cArg = pArg->arg.streamarg.cArg;
	    break;

	default:
	    break;
    }

    while (cArg--) {
        IncArg();
    }

    sprintf(p,GetMsg(MSG_ARGCOUNT, tbuf), argcount);
    strcat (p, ": ");
    if (pFunc = getstring (textbuf, sizeof(textbuf), p, NULL, GS_INITIAL)) {
	fTextarg = TRUE;
	return (SendCmd (pFunc));
    } else {
        return FALSE;
    }

    argData; fMeta;
}


/*** promptarg - Prompt the use for a textarg on the dialog line
*
*  If used with a selection, the first line of the selection is used
*  as prompt string.
*
* Input:
*  Standard Editting Function.
*
* Output:
*  Returns .....
*
* Globals:
*  textbuf	= buffer containing any the argument
*
*************************************************************************/
flagType
promptarg (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    REGISTER PCMD pFunc = NULL;
    linebuf	  lbPrompt;
    int 	  cArg = 0;

    switch (pArg->argType) {
	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, lbPrompt);
	    *pLog (lbPrompt, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    strcpy (lbPrompt, pLog (lbPrompt, pArg->arg.boxarg.xLeft, TRUE));
	    cArg = pArg->arg.boxarg.cArg;
	    break;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, lbPrompt, pFileHead);
	    cArg = pArg->arg.linearg.cArg;
	    break;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, lbPrompt);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (lbPrompt, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    strcpy (lbPrompt, pLog (lbPrompt, pArg->arg.streamarg.xStart, TRUE));
	    cArg = pArg->arg.streamarg.cArg;
	    break;

        case TEXTARG:
	    strcpy ((char *) lbPrompt, pArg->arg.textarg.pText);
	    cArg = pArg->arg.textarg.cArg;
	    break;

	default:
	    break;
    }

    while (cArg--) {
        IncArg();
    }

    textbuf[0] = '\0';

    pFunc = getstring (textbuf, sizeof(textbuf), lbPrompt, NULL, GS_NEWLINE | GS_KEYBOARD);
    if (pFunc && ((PVOID)pFunc->func != (PVOID)cancel)) {
	fTextarg = TRUE;
	return TRUE;
    } else {
        return FALSE;
    }

    argData; fMeta;
}



/*** UpdateHighLight - Highlight screen during <arg> text selection.
*
*  Maintains screen highlighting information.
*
* Input:
*  x, y 	= position of cursor. (y == -1L causes highlighting to be
*		  removed)
*  fBoxToLine	= TRUE => Turn boxarg into a linearg if arg and cursor
*		  columns are the same
*
* Global:
*  flArg	= Position in file when <arg> was hit.
*
* Output:
*
*************************************************************************/
void
UpdateHighLight (
    COL      x,
    LINE     y,
    flagType fBoxToLine
    ) {

    static fl flCursor          = {-1, -1L};
    rn      rnHiLite;

    /*
     * if remove request, clear it out
     */
    if (y == -1L) {
        ClearHiLite (pInsCur->pFile,TRUE);
        flCursor.lin = -1L;
    } else if (fBoxArg) {
        /*
         * Transition points where we remove highlighting before updating new
         * highlighting:
         *
         *  currently columns are equal, and new highlight would not be.
         *  currently columns are not equal, and new highlight would be.
         *  New cursor position differs in BOTH x and y positions from old.
         *  new position equals the arg position
         */
        if (   ((flCursor.col == flArg.col) && (x != flCursor.col))
                || ((flCursor.col != flArg.col) && (x == flArg.col))
                || ((flCursor.col != x) && (flCursor.lin != y))
                || ((flArg.col == x) && (flArg.lin == y))
            ) {
            ClearHiLite (pInsCur->pFile,TRUE);
        }
        flCursor.lin = y;
        flCursor.col = x;
        /*
         * define New Highlight square
         */
        rnHiLite.flFirst = flArg;
        rnHiLite.flLast  = flCursor;
        /*
         * Ending column is off-by-one. If unequal, adjust accordingly.
         */
        if (rnHiLite.flFirst.col < rnHiLite.flLast.col) {
            rnHiLite.flLast.col--;
        } else if (   (rnHiLite.flFirst.col == rnHiLite.flLast.col)
             && (rnHiLite.flFirst.lin != rnHiLite.flLast.lin)) {
            /*
             * If columns are same, and lines are different, then highlight entire lines.
             */

            rnHiLite.flFirst.col = 0;
            rnHiLite.flLast.col  = sizeof(linebuf);
	}
        SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
    } else {  /* !fBoxArg */

        /*
         *  If we're on the arg line, we can just clear the highlighting
         *  and redraw.
         */
	if (y == flArg.lin) {
	    ClearHiLite (pInsCur->pFile, TRUE);

	    rnHiLite.flFirst = flArg;
	    rnHiLite.flLast.col = x;
	    rnHiLite.flLast.lin = y;

            if (x > flArg.col) {
                rnHiLite.flLast.col--;
            }

	    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
        } else {
            /*
             *  We're not on the arg line.  If we have changed lines, we have
             *  to eliminate the range that specifies the line we're on.
             *  Currently, this means we have to clear the entire hiliting and
             *  regenerate.
             *  If we have not changed lines, only the current line will be updated
             */

	    if (flCursor.lin != y) {
		ClearHiLite (pInsCur->pFile, TRUE);

                /*
                 *  First, generate the arg line
                 */
		rnHiLite.flFirst    = flArg;
		rnHiLite.flLast.lin = flArg.lin;

                if (y < flArg.lin) {
		    rnHiLite.flLast.col = 0;
                } else {
                    rnHiLite.flLast.col = sizeof(linebuf);
                }

		SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);

                /*
                 *  Now generate the block between the arg and the current
                 *  lines.
                 */
		rnHiLite.flFirst.col = 0;
		rnHiLite.flLast.col  = sizeof(linebuf);

		if (y < flArg.lin) {
		    rnHiLite.flFirst.lin = y + 1;
		    rnHiLite.flLast.lin  = flArg.lin - 1;
                } else {
		    rnHiLite.flFirst.lin = flArg.lin + 1;
		    rnHiLite.flLast.lin  = y - 1;
                }

                if (rnHiLite.flLast.lin - rnHiLite.flFirst.lin >= 0) {
                    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
                }
	    }

            /*
             *  Now do the current line
             */
	    rnHiLite.flFirst.lin = y;
	    rnHiLite.flLast.lin  = y;
	    rnHiLite.flLast.col  = x;

            if (y < flArg.lin) {
		rnHiLite.flFirst.col = sizeof(linebuf);
            } else {
		rnHiLite.flFirst.col = 0;
		rnHiLite.flLast.col--;
            }

	    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
	}
	flCursor.col = x;
	flCursor.lin = y;
    }

    fBoxToLine;
}


/*** BoxStream - Editor command - toggles box/stream modes
*
*  Toggles the user between box and stream selection modes.
*
* Input:
*  Standard Editting function. (Though everything is ignored)
*
* Output:
*   Returns TRUE if we are now in box mode, FALSE for stream.
*
*************************************************************************/
flagType
BoxStream (
    CMDDATA   argData,
    ARG * pArg,
    flagType  fMeta
    ) {

    fBoxArg = (flagType) !fBoxArg;
    if (argcount) {
        UpdateHighLight (-1, -1L, TRUE);
        UpdateHighLight (XCUR(pInsCur), YCUR(pInsCur), TRUE);
    }
    return fBoxArg;

    argData; pArg; fMeta;
}


/*** lastselect - Restore last text selection
*
* Purpose:
*
*   To quickly restore the user text selection after a function has been
*   executed.  This function does not exit until the user completes their
*   selection.
*
* Input:
*
*   The usual editor command arguments.  None is used.
*
* Output:
*
*   Returns FALSE if we are already in text selection mode, TRUE otherwise.
*
* Notes:
*
*   The items we must save and restore are:
*
*		flArg	 - Spot where user hit <arg>
*		flCursor - Spot where cursor was last
*
*   Note that the boxstream state and the argcount are not preserved.
*
*   We rely on Arg () to set up for us.
*
*************************************************************************/

flagType
lastselect (
    CMDDATA   argData,
    ARG * pArg,
    flagType  fMeta
    ) {
    if (argcount) {
        return FALSE;
    }

    Arg (TRUE);

    return TRUE;

    argData; pArg;  fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\delete.c ===
/*  sdelete.c - stream delete of characters
 *
 *  Modifications:
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "z.h"


flagType
delete (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {
    switch (pArg->argType) {
	case BOXARG:
	case LINEARG:
	    ldelete (argType, pArg, fMeta);
	    break;

	default:
	    sdelete (argType, pArg, fMeta);
	    break;
    }
    return TRUE;
}



flagType
sdelete (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {

    fl  fl;

    switch (pArg->argType) {

    case NOARG:
	/* reduce line by one character.  No length overflow is possible */
	DelBox (pFileHead, XCUR (pInsCur), YCUR (pInsCur), XCUR (pInsCur), YCUR (pInsCur));
        return TRUE;

    /*	TEXTARG illegal 	    */
    case NULLARG:
        if (!fMeta) {
	    pick (pArg->arg.nullarg.x, pArg->arg.nullarg.y,
                  0, pArg->arg.nullarg.y+1, STREAMARG);
        }
	DelStream (pFileHead, pArg->arg.nullarg.x, pArg->arg.nullarg.y,
                   0, pArg->arg.nullarg.y+1);
        return TRUE;

    case LINEARG:
    case BOXARG:
	BoxToStream (pArg);

    case STREAMARG:
        if (!fMeta) {
	    pick (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
                  pArg->arg.streamarg.xEnd,   pArg->arg.streamarg.yEnd, STREAMARG);
        }
	DelStream (pFileHead,
		   pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		   pArg->arg.streamarg.xEnd, pArg->arg.streamarg.yEnd);
	fl.col = pArg->arg.streamarg.xStart;
	fl.lin = pArg->arg.streamarg.yStart;
	cursorfl (fl);
	return TRUE;
    }

    return FALSE;

    argType;
}



/*** BoxToStream - Convert a box/line arg to a stream arg
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
BoxToStream (
    ARG * pArg
    ) {

    ARG arg;

    arg = *pArg;

    pArg->argType = STREAMARG;

    if (arg.argType == LINEARG) {
        pArg->arg.streamarg.yStart = arg.arg.linearg.yStart;
        pArg->arg.streamarg.yEnd   = arg.arg.linearg.yEnd;
        pArg->arg.streamarg.xStart = pArg->arg.streamarg.xEnd = flArg.col;
    } else {
        pArg->arg.streamarg.yStart = arg.arg.boxarg.yTop;
        pArg->arg.streamarg.yEnd   = arg.arg.boxarg.yBottom;

        if ((flArg.lin == arg.arg.boxarg.yTop    &&
             flArg.col == arg.arg.boxarg.xLeft)   ||
            (flArg.lin == arg.arg.boxarg.yBottom  &&
             flArg.col == arg.arg.boxarg.xRight + 1)) {
            pArg->arg.streamarg.xStart = arg.arg.boxarg.xLeft;
            pArg->arg.streamarg.xEnd   = arg.arg.boxarg.xRight + 1;
        } else {
            pArg->arg.streamarg.xStart = arg.arg.boxarg.xRight + 1;
            pArg->arg.streamarg.xEnd   = arg.arg.boxarg.xLeft;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\console.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.c

Abstract:

    Interface to the console for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/

#include "z.h"




//
//  EVENT BUFFER
//
//   The event buffer is used to store event records from the input
//   queue.
//
#define     INITIAL_EVENTS	32
#define     MAX_EVENTS		64
#define     EVENT_INCREMENT	4

#define     ADVANCE		TRUE
#define     NOADVANCE		FALSE
#define     WAIT		TRUE
#define     NOWAIT		FALSE

//
//  For accessing fields of an event record
//
#define     EVENT_TYPE(p)   ((p)->EventType)
#define     EVENT_DATA(p)   ((p)->Event)

//
//  For casting event records
//
#define     PMOUSE_EVT(p)   (&(EVENT_DATA(p).MouseEvent))
#define     PWINDOW_EVT(p)  (&(EVENT_DATA(p).WindowBufferSizeEvent))
#define     PKEY_EVT(p)     (&(EVENT_DATA(p).KeyEvent))
#define     PMENU_EVT(p)    (&(EVENT_DATA(p).MenuEvent))
#define     PFOCUS_EVT(p)   (&(EVENT_DATA(p).FocusEvent))
//
//  The event buffer structure
//
typedef struct EVENT_BUFFER {
    DWORD		MaxEvents;		    //	Max number of events in buffer
    DWORD		NumberOfEvents; 	    //	Number of events in buffer
    DWORD		EventIndex;		    //	Event Index
    BOOL		BusyFlag;		    //	Busy flag
    CRITICAL_SECTION	CriticalSection;	    //	To maintain integrity
    CRITICAL_SECTION	PeekCriticalSection;	    //	While peeking
    PINPUT_RECORD	EventBuffer;		    //	Event Buffer
} EVENT_BUFFER, *PEVENT_BUFFER;





//
//  Screen attributes
//
#define     BLACK_FGD	    0
#define     BLUE_FGD	    FOREGROUND_BLUE
#define     GREEN_FGD	    FOREGROUND_GREEN
#define     CYAN_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN)
#define     RED_FGD	    FOREGROUND_RED
#define     MAGENTA_FGD     (FOREGROUND_BLUE | FOREGROUND_RED)
#define     YELLOW_FGD	    (FOREGROUND_GREEN | FOREGROUND_RED)
#define     WHITE_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED)

#define     BLACK_BGD	    0
#define     BLUE_BGD	    BACKGROUND_BLUE
#define     GREEN_BGD	    BACKGROUND_GREEN
#define     CYAN_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN)
#define     RED_BGD	    BACKGROUND_RED
#define     MAGENTA_BGD     (BACKGROUND_BLUE | BACKGROUND_RED)
#define     YELLOW_BGD	    (BACKGROUND_GREEN | BACKGROUND_RED)
#define     WHITE_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED)



//
//  The AttrBg and AttrFg arrays are used for mapping DOS attributes
//  to the new attributes.
//
WORD AttrBg[ ] = {
    BLACK_BGD,				    // black
    BLUE_BGD,				    // blue
    GREEN_BGD,				    // green
    CYAN_BGD,				    // cyan
    RED_BGD,				    // red
    MAGENTA_BGD,			    // magenta
    YELLOW_BGD, 			    // brown
    WHITE_BGD,				    // light gray
    BACKGROUND_INTENSITY | BLACK_BGD,	    // dark gray
    BACKGROUND_INTENSITY | BLUE_BGD,	    // light blue
    BACKGROUND_INTENSITY | GREEN_BGD,	    // light green
    BACKGROUND_INTENSITY | CYAN_BGD,	    // light cyan
    BACKGROUND_INTENSITY | RED_BGD,	    // light red
    BACKGROUND_INTENSITY | MAGENTA_BGD,     // light magenta
    BACKGROUND_INTENSITY | YELLOW_BGD,	    // light yellow
    BACKGROUND_INTENSITY | WHITE_BGD	    // white
};

WORD AttrFg[  ] = {
    BLACK_FGD,				    // black
    BLUE_FGD,				    // blue
    GREEN_FGD,				    // green
    CYAN_FGD,				    // cyan
    RED_FGD,				    // red
    MAGENTA_FGD,			    // magenta
    YELLOW_FGD, 			    // brown
    WHITE_FGD,				    // light gray
    FOREGROUND_INTENSITY | BLACK_FGD,	    // dark gray
    FOREGROUND_INTENSITY | BLUE_FGD,	    // light blue
    FOREGROUND_INTENSITY | GREEN_FGD,	    // light green
    FOREGROUND_INTENSITY | CYAN_FGD,	    // light cyan
    FOREGROUND_INTENSITY | RED_FGD,	    // light red
    FOREGROUND_INTENSITY | MAGENTA_FGD,     // light magenta
    FOREGROUND_INTENSITY | YELLOW_FGD,	    // light yellow
    FOREGROUND_INTENSITY | WHITE_FGD	    // white
};

//
//  GET_ATTRIBUTE performs the mapping from old attributes to new attributes
//
#define GET_ATTRIBUTE(x)    (AttrFg[x & 0x000F ] | AttrBg[( x & 0x00F0 ) >> 4])


//
//  The LINE_INFO structure contains information about each line in the
//  screen buffer.
//
typedef struct _LINE_INFO {

    BOOL    Dirty;              //  True if has not been displayed
    BOOL    Garbage;            //  True if contents are garbage
    int     colMinChanged;      //  if dirty, smallest col changed
    int     colMaxChanged;      //  if dirty, biggest col changed
    PCHAR_INFO  Line;           //  Pointer to the line.

} LINE_INFO, *PLINE_INFO;

#define ResetLineInfo(pli)               \
    {   pli->Dirty          = FALSE;     \
        pli->Garbage        = TRUE;      \
        pli->colMinChanged  = 10000;     \
        pli->colMaxChanged  = -1;        \
	}

//
//  The SCREEN_DATA structure contains the information about individual
//  screens.
//
typedef struct SCREEN_DATA {
    HANDLE              ScreenHandle;       //  Handle to screen
    PLINE_INFO          LineInfo;           //  Array of line info.
    PCHAR_INFO          ScreenBuffer;       //  Screen buffer
    ULONG               MaxBufferSize;      //  Max. buffer size
    ATTRIBUTE           AttributeOld;       //  Attribute - original
    WORD                AttributeNew;       //  Attribute - converted
    ROW                 FirstRow;           //  First row to update
    ROW                 LastRow;            //  Last row to update
    CRITICAL_SECTION	CriticalSection;    //	To maintain integrity
    DWORD               CursorSize;         //  Cursor Size
    SCREEN_INFORMATION	ScreenInformation;  //	Screen information
} SCREEN_DATA, *PSCREEN_DATA;


//
//  Static global data
//
static EVENT_BUFFER	EventBuffer;		    //	Event buffer
static HANDLE		hInput; 		    //	handle to stdin
static HANDLE		hOutput;		    //	handle to stdout
static HANDLE		hError; 		    //	handle to stderr
static PSCREEN_DATA	OutputScreenData;	    //	Screen data for hOutput
static PSCREEN_DATA	ActiveScreenData;	    //	Points to current screen data
static BOOL		Initialized = FALSE;	    //	Initialized flag


#if defined (DEBUG)
    static char DbgBuffer[128];
#endif


//
//  Local Prototypes
//
BOOL
InitializeGlobalState (
    void
    );


PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    );

BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    );

PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    );

void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    );

BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    );

BOOL
MenuEvent (
    PMENU_EVENT_RECORD pEvent
    );

BOOL
FocusEvent (
    PFOCUS_EVENT_RECORD pEvent,
    PKBDKEY		pKey
    );

BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    );


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    );


BOOL
InitializeGlobalState (
    void
    )
/*++

Routine Description:

    Initializes our global state data.

Arguments:

    None.

Return Value:

    TRUE if success
    FALSE otherwise.

--*/
{


    //
    //	Initialize the event buffer
    //
    InitializeCriticalSection( &(EventBuffer.CriticalSection) );
    InitializeCriticalSection( &(EventBuffer.PeekCriticalSection) );
    EventBuffer.NumberOfEvents	= 0;
    EventBuffer.EventIndex	= 0;
    EventBuffer.BusyFlag	= FALSE;
    EventBuffer.EventBuffer = MALLOC( INITIAL_EVENTS * sizeof(INPUT_RECORD) );

    if ( !EventBuffer.EventBuffer ) {
	return FALSE;
    }

    EventBuffer.MaxEvents = INITIAL_EVENTS;


    //
    //	Get handles to stdin, stdout and stderr
    //
    hInput  = GetStdHandle( STD_INPUT_HANDLE );
    hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    hError  = GetStdHandle( STD_ERROR_HANDLE );


    //
    //	Initialize the screen data for hOutput
    //
    if ( !(OutputScreenData = MakeScreenData( hOutput )) ) {
	return FALSE;
    }


    //
    //	Current screen is hOutput
    //
    ActiveScreenData = OutputScreenData;


    return (Initialized = TRUE);

}





PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    )
/*++

Routine Description:

    Allocates memory for a SCREEN_DATA information and initializes it.

Arguments:

    ScreenHandle    -	Supplies handle of screen.

Return Value:

    POINTER to allocated SCREEN_DATA structure

--*/
{
    PSCREEN_DATA		ScreenData;	//  Pointer to screen data
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.


    //
    //	Allocate space for the screen data.
    //
    if ( !(ScreenData = (PSCREEN_DATA)MALLOC(sizeof(SCREEN_DATA))) ) {
	return NULL;
    }

    //
    //	Allocate space for our copy of the screen buffer.
    //
    GetConsoleScreenBufferInfo( ScreenHandle,
				&ScrInfo );

    ScreenData->MaxBufferSize = ScrInfo.dwSize.Y    *
				ScrInfo.dwSize.X;

    ScreenData->ScreenBuffer = (PCHAR_INFO)MALLOC( ScreenData->MaxBufferSize *
						    sizeof(CHAR_INFO));

    if ( !ScreenData->ScreenBuffer ) {
        FREE( ScreenData );
        return NULL;
    }

    //
    //	Allocate space for the LineInfo array
    //
    ScreenData->LineInfo = (PLINE_INFO)MALLOC( ScrInfo.dwSize.Y * sizeof( LINE_INFO ) );
    if ( !ScreenData->LineInfo ) {
        FREE( ScreenData->ScreenBuffer );
        FREE( ScreenData );
        return NULL;
    }


    //
    //	Memory has been allocated, now initialize the structure
    //
    ScreenData->ScreenHandle = ScreenHandle;

    ScreenData->ScreenInformation.NumberOfRows = ScrInfo.dwSize.Y;
    ScreenData->ScreenInformation.NumberOfCols = ScrInfo.dwSize.X;

    ScreenData->ScreenInformation.CursorRow = ScrInfo.dwCursorPosition.Y;
    ScreenData->ScreenInformation.CursorCol = ScrInfo.dwCursorPosition.X;

    ScreenData->AttributeNew = ScrInfo.wAttributes;
    ScreenData->AttributeOld = 0x00;

    ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow  = 0;

    InitializeCriticalSection( &(ScreenData->CriticalSection) );

    InitLineInfo( ScreenData );

    return ScreenData;
}





BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    )
/*++

Routine Description:

    Initializes the LineInfo array.

Arguments:

    ScreenData	    -	Supplies pointer to screen data.

Return Value:

    TRUE if initialized, false otherwise.

--*/
{

    ROW 	Row;
    COLUMN	Cols;
    PLINE_INFO	LineInfo;
    PCHAR_INFO	CharInfo;


    LineInfo = ScreenData->LineInfo;
    CharInfo = ScreenData->ScreenBuffer;
    Row      = ScreenData->ScreenInformation.NumberOfRows;
    Cols     = ScreenData->ScreenInformation.NumberOfCols;

    while ( Row-- ) {

        ResetLineInfo (LineInfo);

        LineInfo->Line      = CharInfo;

        LineInfo++;
        CharInfo += Cols;

    }

    return TRUE;
}





PSCREEN
consoleNewScreen (
    void
    )
/*++

Routine Description:

    Creates a new screen.

Arguments:

    None.

Return Value:

    Pointer to screen data.

--*/
{
    PSCREEN_DATA		ScreenData;	   //  Screen data
    HANDLE			NewScreenHandle;
    SMALL_RECT			NewSize;
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.
    CONSOLE_CURSOR_INFO 	CursorInfo;

    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if ( !InitializeGlobalState() ) {
	    return NULL;
	}
    }

    //
    //	Create a new screen buffer
    //
    NewScreenHandle = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
						FILE_SHARE_WRITE | FILE_SHARE_READ,
						NULL,
						CONSOLE_TEXTMODE_BUFFER,
						NULL );

    if (NewScreenHandle == INVALID_HANDLE_VALUE) {
	//
	//  No luck
	//
	return NULL;
    }

    //
    //	We want the new window to be the same size as the current one, so
    //	we resize it.
    //
    GetConsoleScreenBufferInfo( ActiveScreenData->ScreenHandle,
				&ScrInfo );

    NewSize.Left    = 0;
    NewSize.Top     = 0;
    NewSize.Right   = ScrInfo.srWindow.Right - ScrInfo.srWindow.Left;
    NewSize.Bottom  = ScrInfo.srWindow.Bottom - ScrInfo.srWindow.Top;

    SetConsoleWindowInfo( NewScreenHandle, TRUE, &NewSize );

    //
    //	Now we create a screen data structure for it.
    //
    if ( !(ScreenData = MakeScreenData(NewScreenHandle)) ) {
	CloseHandle(NewScreenHandle);
	return NULL;
    }


    CursorInfo.bVisible = TRUE;
    ScreenData->CursorSize = CursorInfo.dwSize = 25;

    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
			   &CursorInfo );

    //
    //	We are all set. We return a pointer to the
    //	screen data.
    //
    return (PSCREEN)ScreenData;
}





BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Closes a screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if screen closed.
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    //
    //	We cannot close the active screen
    //
    if ( !ScreenData || (ScreenData == ActiveScreenData) ) {
	return FALSE;
    }

    if (ScreenData->ScreenHandle != INVALID_HANDLE_VALUE) {
	CloseHandle(ScreenData->ScreenHandle);
    }

    FREE( ScreenData->LineInfo );
    FREE( ScreenData->ScreenBuffer );
    FREE( ScreenData );

    return TRUE;
}





PSCREEN
consoleGetCurrentScreen (
    void
    )
/*++

Routine Description:

    Returns the current screen.

Arguments:

    none.

Return Value:

    Pointer to currently active screen data.

--*/
{
    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if (!InitializeGlobalState()) {
	    return NULL;
	}
    }

    return (PSCREEN)ActiveScreenData;
}





BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if the active screen set
    FALSE otherwise.

--*/
{
    BOOL	    ScreenSet	  = TRUE;
    PSCREEN_DATA    CurrentScreen = ActiveScreenData;


    EnterCriticalSection( &(CurrentScreen->CriticalSection) );

    ScreenSet = SetConsoleActiveScreenBuffer( ((PSCREEN_DATA)pScreen)->ScreenHandle);

    if (ScreenSet) {
	ActiveScreenData = (PSCREEN_DATA)pScreen;
    }

    LeaveCriticalSection( &(CurrentScreen->CriticalSection) );

    return ScreenSet;
}





BOOL
consoleGetScreenInformation (
    PSCREEN            pScreen,
    PSCREEN_INFORMATION    pScreenInfo
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen	-   Supplies pointer to screen data.
    pScreenInfo -   Supplies pointer to screen info buffer

Return Value:

    TRUE if the screen info returned
    FALSE otherwise.

--*/
{

    PSCREEN_DATA ScreenData = (PSCREEN_DATA)pScreen;

    if (!ScreenData) {
	return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    memcpy(pScreenInfo, &(ScreenData->ScreenInformation), sizeof(SCREEN_INFORMATION));

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}



BOOL
consoleSetScreenSize (
    PSCREEN pScreen,
    ROW Rows,
    COLUMN  Cols
    )
/*++

Routine Description:

    Sets the screen size

Arguments:

    pScreen	-   Supplies pointer to screen data.
    Rows	-   Number of rows
    Cols	-   Number of columns

Return Value:

    TRUE if screen size changed successfully
    FALSE otherwise.

--*/
{

    PSCREEN_DATA		ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_SCREEN_BUFFER_INFO	ScreenBufferInfo;
    SMALL_RECT			ScreenRect;
    COORD			ScreenSize;
    USHORT			MinRows;
    USHORT			MinCols;
    ULONG			NewBufferSize;
    BOOL			WindowSet   = FALSE;
    BOOL			Status	    = FALSE;

    //
    //	Won't attempt to resize larger than the largest window size
    //
    ScreenSize = GetLargestConsoleWindowSize( ScreenData->ScreenHandle );

    if ( (Rows > (ROW)ScreenSize.Y) || (Cols > (COLUMN)ScreenSize.X) ) {
        return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    //
    //	Obtain the current screen information.
    //
    if ( GetConsoleScreenBufferInfo( ScreenData->ScreenHandle, &ScreenBufferInfo ) ) {

        //
        //  If the desired buffer size is smaller than the current window
        //  size, we have to resize the current window first.
        //
        if ( ( Rows < (ROW)
                   (ScreenBufferInfo.srWindow.Bottom -
                ScreenBufferInfo.srWindow.Top + 1) ) ||
             ( Cols < (COLUMN)
                   (ScreenBufferInfo.srWindow.Right -
                ScreenBufferInfo.srWindow.Left + 1) ) ) {

            //
            //  Set the window to a size that will fit in the current
            //  screen buffer and that is no bigger than the size to
            //  which we want to grow the screen buffer.
            //
            MinRows = (USHORT)min( (int)Rows, (int)(ScreenBufferInfo.dwSize.Y) );
            MinCols = (USHORT)min( (int)Cols, (int)(ScreenBufferInfo.dwSize.X) );

            ScreenRect.Top  = 0;
            ScreenRect.Left = 0;
            ScreenRect.Right    = (SHORT)MinCols - (SHORT)1;
            ScreenRect.Bottom   = (SHORT)MinRows - (SHORT)1;

            WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

            if ( !WindowSet ) {
                //
                //  ERROR
                //
                goto Done;
            }
        }

        //
        //  Set the screen buffer size to the desired size.
        //
        ScreenSize.X = (WORD)Cols;
        ScreenSize.Y = (WORD)Rows;

        if ( !SetConsoleScreenBufferSize( ScreenData->ScreenHandle, ScreenSize ) ) {

            //
            //  ERROR
            //
            //
            //  Return the window to its original size. We ignore the return
            //  code because there is nothing we can do about it.
            //
            SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &(ScreenBufferInfo.srWindow) );
            goto Done;
        }

        //
        //  resize the screen buffer. Note that the contents of the screen
        //  buffer are not valid anymore. Someone else will have to update
        //  them.
        //
        NewBufferSize = Rows * Cols;

        if (ScreenData->MaxBufferSize < NewBufferSize ) {
            ScreenData->ScreenBuffer = REALLOC( ScreenData->ScreenBuffer, NewBufferSize * sizeof(CHAR_INFO));
            ScreenData->MaxBufferSize = NewBufferSize;
            ScreenData->LineInfo = REALLOC( ScreenData->LineInfo, Rows * sizeof( LINE_INFO ) );
        }

        //
        //  Set the Window Size. We know that we can grow the window to this size
        //  because we tested the size against the largest window size at the
        //  beginning of the function.
        //
        ScreenRect.Top      = 0;
        ScreenRect.Left     = 0;
        ScreenRect.Right    = (SHORT)Cols - (SHORT)1;
        ScreenRect.Bottom   = (SHORT)Rows - (SHORT)1;

        WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

        if ( !WindowSet ) {
            //
            //  We could not resize the window. We will leave the
            //  resized screen buffer.
            //
            //  ERROR
            //
            InitLineInfo( ScreenData );
            goto Done;
        }

        //
        //  Update the screen size
        //
        ScreenData->ScreenInformation.NumberOfRows = Rows;
        ScreenData->ScreenInformation.NumberOfCols = Cols;

        InitLineInfo( ScreenData );

        //
        //  Done
        //
        Status = TRUE;

    } else {

        //
        //  ERROR
        //
        Status = FALSE;
    }

Done:
    //
    //	Invalidate the entire screen buffer
    //
    ScreenData->FirstRow    = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow     = 0;

    LeaveCriticalSection( &(ScreenData->CriticalSection) );
    return Status;

}




BOOL
consoleSetCursor (
    PSCREEN pScreen,
    ROW Row,
    COLUMN  Col
    )
/*++

Routine Description:

    Moves the cursor to a certain position.

Arguments:

    pScreen -	Supplies pointer to screen data
    Row     -	Supplies row coordinate
    Col     -	Supplies column coordinate

Return Value:

    TRUE if moved
    FALSE otherwise.

--*/
{

    PSCREEN_DATA    ScreenData	= (PSCREEN_DATA)pScreen;
    COORD	    Position;
    BOOL	    Moved	= FALSE;


    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if (pScreen == OriginalScreen ||
        (Row != ScreenData->ScreenInformation.CursorRow) ||
	(Col != ScreenData->ScreenInformation.CursorCol) ) {

	assert( Row < ScreenData->ScreenInformation.NumberOfRows);
	assert( Col < ScreenData->ScreenInformation.NumberOfCols);

	Position.Y = (SHORT)Row;
	Position.X = (SHORT)Col;

	if ( SetConsoleCursorPosition( ScreenData->ScreenHandle,
				       Position )) {
	    //
	    //	Cursor moved, update the data
	    //
	    ScreenData->ScreenInformation.CursorRow    =   Row;
	    ScreenData->ScreenInformation.CursorCol    =   Col;

	    Moved = TRUE;
	}
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Moved;
}




BOOL
consoleSetCursorStyle (
    PSCREEN pScreen,
    ULONG   Style
    )

/*++

Routine Description7:

    Sets the cursor style. The two available styles are: underscrore and
    box

Arguments:

    Style	-   New cursor style

Return Value:

    True if cursor style set

--*/

{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;

    CursorInfo.bVisible = TRUE;

    if ( Style == CURSOR_STYLE_UNDERSCORE ) {

	CursorInfo.dwSize = 25;

    } else if ( Style == CURSOR_STYLE_BOX ) {

	CursorInfo.dwSize = 100;

    } else {

	return FALSE;

    }

    ScreenData->CursorSize = CursorInfo.dwSize;

    return SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				  &CursorInfo );

}





ULONG
consoleWriteLine (
    PSCREEN     pScreen,
    PVOID       pBuffer,
    ULONG       BufferSize,
    ROW         Row,
    COLUMN      Col,
    ATTRIBUTE   Attribute,
    BOOL        Blank
    )
/*++

Routine Description7:

    Writes a buffer to the screen with the specified attribute and blanks
    to end of row.

Arguments:

    pScreen	-   Supplies pointer to screen data
    pBuffer	-   Supplies pointer to buffer
    BufferSize	-   Supplies the size of the buffer
    Row 	-   Supplies row coordinate
    Col 	-   Supplies column coordinate
    Attr	-   Supplies the attribute
    Blank	-   TRUE if we should blank to end of last row written.

Return Value:

    Number of bytes written

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    PLINE_INFO	    LineInfo;
    PCHAR_INFO	    CharInfo;
    CHAR_INFO	    Char;
    WORD	    Attr;

    char *	    p = (char *)pBuffer;

    COLUMN      ColsLeft;   //  Available columns
    COLUMN      InfoCols;   //  Columns taken from buffer
    COLUMN      BlankCols;  //  Columns to be blanked
    COLUMN	    Column;	    //	Counter;

    //
    //	We will ignore writes outside of the screen buffer
    //
    if ( ( Row >= ScreenData->ScreenInformation.NumberOfRows ) ||
         ( Col >= ScreenData->ScreenInformation.NumberOfCols ) ) {
        return TRUE;
    }

    //
    //	Ignore trivial writes
    //
    if (BufferSize == 0 && !Blank) {
        return TRUE;
    }


    EnterCriticalSection( &(ScreenData->CriticalSection) );


    //
    //	We will truncate writes that are too long
    //
    if ( (Col + BufferSize) >= ScreenData->ScreenInformation.NumberOfCols ) {
        BufferSize = ScreenData->ScreenInformation.NumberOfCols - Col;
    }

    LineInfo = ScreenData->LineInfo + Row;
    CharInfo = LineInfo->Line + Col;

    ColsLeft  = ScreenData->ScreenInformation.NumberOfCols - Col;
    InfoCols  = min( BufferSize, ColsLeft );
    BlankCols = Blank ? (ColsLeft - InfoCols) : 0;

    //
    //	Set the attribute
    //
    if ( Attribute != ScreenData->AttributeOld ) {
        ScreenData->AttributeOld  = Attribute;
        ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }
    Attr = ScreenData->AttributeNew;

    //
    //	set up default attribute
    //
    Char.Attributes = Attr;

    //
    //	set up number of columns to draw
    //
    Column = InfoCols;

    //
    //	draw chars in all specified columns
    //
    while ( Column-- ) {

        //
        //  use character from input string
        //
        Char.Char.AsciiChar = *p++;

        //
        //  update change portions of line info
        //
        if (LineInfo->Garbage ||
            CharInfo->Attributes != Char.Attributes ||
            CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

            LineInfo->colMinChanged = min (LineInfo->colMinChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->Dirty = TRUE;
	    }

        //
        //  set up new character
        //
        *CharInfo++ = Char;
    }


    //
    //	Blank to end of line
    //
    Char.Attributes     = Attr;
    Char.Char.AsciiChar = ' ';
    Column              = BlankCols;

    while ( Column-- ) {

        //
        //  update change portions of line info
        //
        if (LineInfo->Garbage ||
            CharInfo->Attributes != Char.Attributes ||
            CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

            LineInfo->colMinChanged = min (LineInfo->colMinChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->Dirty = TRUE;
        }

        *CharInfo++ = Char;
    }


    //
    //	Update row information
    //
    if ( Row < ScreenData->FirstRow ) {
        ScreenData->FirstRow = Row;
    }
    if ( Row > ScreenData->LastRow ) {
        ScreenData->LastRow = Row;
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return (ULONG)(InfoCols + BlankCols);
}





BOOL
consoleShowScreen (
    PSCREEN     pScreen
    )
/*++

Routine Description:

    Moves data from our screen buffer to the console screen buffer.

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if done
    FALSE otherwise

--*/
{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;
    PLINE_INFO		LineInfo;
    BOOL		Shown	   = FALSE;
    ROW 		FirstRow;
    ROW 		LastRow;
    COLUMN		LastCol;

    COORD		Position;
    COORD		Size;
    SMALL_RECT		Rectangle;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ( ScreenData->FirstRow <= ScreenData->LastRow ) {

	Size.X = (SHORT)(ScreenData->ScreenInformation.NumberOfCols);
	Size.Y = (SHORT)(ScreenData->ScreenInformation.NumberOfRows);

	FirstRow = ScreenData->FirstRow;
	LineInfo = ScreenData->LineInfo + FirstRow;

	LastCol  = ScreenData->ScreenInformation.NumberOfCols-1;

	//
	//  Find next dirty block
	//
	while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
	    FirstRow++;
	    LineInfo++;
	}

	while ( FirstRow <= ScreenData->LastRow ) {

	    int colLeft, colRight;

	    //
	    //	Get the block
	    //

	    LastRow  = FirstRow;

	    //
	    //	set up for left/right boundary accrual
	    //

	    colLeft = LastCol + 1;
	    colRight = -1;

	    while ( (LastRow <= ScreenData->LastRow) && LineInfo->Dirty ) {

		//
		//  accrue smallest bounding right/left margins
		//

		colLeft = min (colLeft, LineInfo->colMinChanged);
		colRight = max (colRight, LineInfo->colMaxChanged);

		//
		//  reset line information
		//

		ResetLineInfo (LineInfo);

		//
		//  advance to next row
		//

		LastRow++;
		LineInfo++;
	    }
	    LastRow--;


	    //
	    //	Write the block
	    //
	    assert( FirstRow <= LastRow );

	    Position.X = (SHORT)colLeft;
	    Position.Y = (SHORT)FirstRow;

	    Rectangle.Top    = (SHORT)FirstRow;
	    Rectangle.Bottom = (SHORT)LastRow;
	    Rectangle.Left = (SHORT) colLeft;
	    Rectangle.Right = (SHORT) colRight;

	    //
	    //	Performance hack: making the cursor invisible speeds
	    //	screen updates.
	    //
	    CursorInfo.bVisible = FALSE;
	    CursorInfo.dwSize	= ScreenData->CursorSize;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    Shown = WriteConsoleOutput( ScreenData->ScreenHandle,
					ScreenData->ScreenBuffer,
					Size,
					Position,
					&Rectangle );

#if defined (DEBUG)
	    if ( !Shown ) {
		char DbgB[128];
                sprintf(DbgB, "Z: WriteConsoleOutput Error %d\n", GetLastError() );
		OutputDebugString( DbgB );
	    }
#endif
	    assert( Shown );

	    CursorInfo.bVisible = TRUE;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    FirstRow = LastRow + 1;

	    //
	    //	Find next dirty block
	    //
	    while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
		FirstRow++;
		LineInfo++;
	    }
	}

	ScreenData->LastRow  = 0;
	ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;

    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Shown;

}





BOOL
consoleClearScreen (
    PSCREEN     pScreen,
    BOOL        ShowScreen
    )
/*++

Routine Description:

	Clears the screen

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if screen cleared
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    ROW 	    Rows;
    BOOL	    Status = TRUE;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    Rows = ScreenData->ScreenInformation.NumberOfRows;

    while ( Rows-- ) {
	consoleWriteLine( pScreen, NULL, 0, Rows, 0, ScreenData->AttributeOld, TRUE );
    }

    if (ShowScreen) {
	Status = consoleShowScreen( pScreen );
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Status;
}



BOOL
consoleScrollVert (
    PSCREEN      pScreen,
    ROW          Top,
    COLUMN       Left,
    ROW          Bottom,
    COLUMN       Right,
    INT          Rows
    )
/*++

Routine Description:

    Scrolls

Arguments:

    pScreen     -   Supplies pointer to screen data
    Top         -   Supplies top row
    Left        -   Supplies left column
    Bottom      -   Supplies bottom row
    Right       -   Supplies right column
    Rows        -   Number of rows to scroll

Return Value:

    TRUE if scrolled
    FALSE otherwise

--*/

{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    SMALL_RECT      Rect;
    COORD           Coord;
    CHAR_INFO       CharInfo;
    BOOL            Ok;
    PLINE_INFO      LineInfo;
    ROW             R;

    if ( Rows ) {

        EnterCriticalSection( &(ScreenData->CriticalSection) );

        //
        //  If there is something to flush, we flush it now
        //
        if ( ScreenData->FirstRow <= ScreenData->LastRow ) {
            consoleShowScreen( pScreen );
        }


        //
        //  Scroll
        //
	Coord.X = (SHORT)Left;
	Coord.Y = (SHORT)Top;

	Rect.Left   = (SHORT)Left;
	Rect.Top    = (SHORT)Top;
	Rect.Right  = (SHORT)Right;
	Rect.Bottom = (SHORT)Bottom;

        if ( Rows > 0 ) {

            Rect.Top    += (USHORT)Rows;

        } else {

            Rect.Bottom += (USHORT)Rows;
            Coord.Y     -= (USHORT)Rows;
        }


        CharInfo.Char.AsciiChar  = ' ';
        CharInfo.Attributes = ScreenData->AttributeNew;

        Ok = ScrollConsoleScreenBuffer(
                ScreenData->ScreenHandle,
                &Rect,
                NULL,
                Coord,
                &CharInfo
                );

        //
        //  Mark all the lines in our buffer as containing garbage
        //
        LineInfo = ScreenData->LineInfo + Top;
        R        = Bottom - Top + 1;

        while ( R-- ) {
            LineInfo->Garbage = TRUE;
            LineInfo++;
        }

        LeaveCriticalSection( &(ScreenData->CriticalSection) );
    }

    return Ok;
}






BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    )
/*++

Routine Description:

    Sets the console attribute

Arguments:

    pScreen	-   Supplies pointer to screen data
    Attribute	-   Supplies the attribute

Return Value:

    TRUE if Attribute set
    FALSE otherwise

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if (Attribute != ScreenData->AttributeOld) {
	ScreenData->AttributeOld = Attribute;
	ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}









BOOL
consoleFlushInput (
    void
    )
/*++

Routine Description:

    Flushes input events.

Arguments:

    None.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    EventBuffer.NumberOfEvents = 0;

    return FlushConsoleInputBuffer( hInput );
}







BOOL
consoleGetMode (
    PKBDMODE pMode
    )
/*++

Routine Description:

    Get current console mode.

Arguments:

    pMode   -	Supplies a pointer to the mode flag variable

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    return GetConsoleMode( hInput,
			   pMode );
}






BOOL
consoleSetMode (
    KBDMODE Mode
    )
/*++

Routine Description:

    Sets the console mode.

Arguments:

    Mode    -	Supplies the mode flags.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    return SetConsoleMode( hInput,
			   Mode );
}


BOOL
consoleIsKeyAvailable (
    void
    )
/*++

Routine Description:

    Returns TRUE if a key is available in the event buffer.

Arguments:

    None.

Return Value:

    TRUE if a key is available in the event buffer
    FALSE otherwise

--*/

{
    BOOL	    IsKey = FALSE;
    PINPUT_RECORD   pEvent;
    DWORD           Index;

    EnterCriticalSection( &(EventBuffer.CriticalSection) );

    for (Index=EventBuffer.EventIndex; Index < EventBuffer.NumberOfEvents; Index++) {
        pEvent = EventBuffer.EventBuffer + Index;
	if ( ((EVENT_TYPE(pEvent)) == KEY_EVENT) &&
	     (PKEY_EVT(pEvent))->bKeyDown ) {
	    IsKey = TRUE;
	    break;
	}
    }

    LeaveCriticalSection( &(EventBuffer.CriticalSection) );

    if (!IsKey) {
        EnterCriticalSection(&(EventBuffer.PeekCriticalSection));

        pEvent = NextEvent( NOADVANCE, NOWAIT );

        LeaveCriticalSection(&(EventBuffer.PeekCriticalSection));

        EnterCriticalSection( &(EventBuffer.CriticalSection) );

        if (pEvent != NULL) {
            for (Index=EventBuffer.EventIndex; Index < EventBuffer.NumberOfEvents; Index++) {
                pEvent = EventBuffer.EventBuffer + Index;
                if ( ((EVENT_TYPE(pEvent)) == KEY_EVENT) &&
                     (PKEY_EVT(pEvent))->bKeyDown ) {
                    IsKey = TRUE;
                    break;
                }
            }
        }

        LeaveCriticalSection( &(EventBuffer.CriticalSection) );
    }

    return IsKey;
}




BOOL
consoleDoWindow (
    void
    )

/*++

Routine Description:

    Responds to a window event

Arguments:

    None.

Return Value:

    TRUE if window changed
    FALSE otherwise

--*/

{

    PINPUT_RECORD   pEvent;

    pEvent = NextEvent( NOADVANCE, NOWAIT );

    if (( EVENT_TYPE(pEvent) ) == WINDOW_BUFFER_SIZE_EVENT) {

	pEvent = NextEvent( ADVANCE, WAIT );
	WindowEvent(PWINDOW_EVT(pEvent));
    }

    return FALSE;

}





BOOL
consolePeekKey (
    PKBDKEY Key
    )

/*++

Routine Description:

    Gets the next key from the input buffer if the buffer is not empty.


Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/

{

    PINPUT_RECORD   pEvent;
    BOOL	    Done    = FALSE;
    BOOL	    IsKey   = FALSE;

    EnterCriticalSection(&(EventBuffer.PeekCriticalSection));

    do {

	pEvent = NextEvent( NOADVANCE, NOWAIT );

	if ( pEvent ) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)){
		    IsKey = TRUE;
		    Done  = TRUE;
		}
		break;

	    case MOUSE_EVENT:
		Done = TRUE;
		break;


	    case WINDOW_BUFFER_SIZE_EVENT:
		Done = TRUE;
		break;

            case MENU_EVENT:
            case FOCUS_EVENT:
                Done = TRUE;
                break;

	    default:
		assert( FALSE );
		break;
	    }

	    if ( !Done ) {
		NextEvent( ADVANCE, NOWAIT );
	    }

	} else {
	    Done = TRUE;
	}

    } while ( !Done );

    LeaveCriticalSection(&(EventBuffer.PeekCriticalSection));

    return IsKey;

}






BOOL
consoleGetKey (
    PKBDKEY        Key,
     BOOL           fWait
    )
/*++

Routine Description:

    Gets the next key from  the input buffer.

Arguments:

    Key     -	Supplies a pointer to a key structure
    fWait   -	Supplies a flag:
		if TRUE, the function blocks until a key is ready.
		if FALSE, the function returns immediately.

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/
{

    PINPUT_RECORD   pEvent;

    do {
	pEvent = NextEvent( ADVANCE, fWait );

	if (pEvent) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)) {
		    return TRUE;
		}
		break;

	    case MOUSE_EVENT:
		MouseEvent(PMOUSE_EVT(pEvent));
		break;

	    case WINDOW_BUFFER_SIZE_EVENT:
		WindowEvent(PWINDOW_EVT(pEvent));
		break;

            case MENU_EVENT:
                MenuEvent(PMENU_EVT(pEvent));
            break;

            case FOCUS_EVENT:
                if (FocusEvent(PFOCUS_EVT(pEvent), Key)) {
		    return TRUE;
		}
            break;

	    default:
		break;
	    }
	}
    } while (fWait);

    return FALSE;
}


BOOL
consolePutKey (
    PKBDKEY     Key
    )
/*++

Routine Description:

    Puts a key in the console's input buffer

Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;

    InputRecord.EventType   =	KEY_EVENT;

    InputRecord.Event.KeyEvent.bKeyDown 	  =   FALSE;
    InputRecord.Event.KeyEvent.wRepeatCount	  =   0;
    InputRecord.Event.KeyEvent.wVirtualKeyCode	  =   Key->Scancode;
    InputRecord.Event.KeyEvent.wVirtualScanCode   =   0;
    InputRecord.Event.KeyEvent.uChar.UnicodeChar  =   Key->Unicode;
    InputRecord.Event.KeyEvent.dwControlKeyState  =   Key->Flags;

    if ( PutEvent( &InputRecord )) {
	InputRecord.Event.KeyEvent.bKeyDown	  =   TRUE;
	return PutEvent( &InputRecord );
    }
    return FALSE;
}


BOOL
consolePutMouse(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Puts a mose event in the console's input buffer

Arguments:

    Row 	-   Supplies the row
    Col 	-   Supplies the column
    MouseFlags	-   Supplies the flags

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;
    COORD	    Position;
    DWORD	    Flags;

    InputRecord.EventType   =	MOUSE_EVENT;

    Position.Y = (WORD)(Row - 1);
    Position.X = (WORD)(Col - 1);

    Flags = 0;

    if ( MouseFlags & MOUSE_CLICK_LEFT ) {
	Flags |= FROM_LEFT_1ST_BUTTON_PRESSED;
    }
    if ( MouseFlags & MOUSE_CLICK_RIGHT ) {
	Flags |= RIGHTMOST_BUTTON_PRESSED;
    }
    if ( MouseFlags & MOUSE_DOUBLE_CLICK ) {
	Flags |= DOUBLE_CLICK;
    }

    InputRecord.Event.MouseEvent.dwMousePosition    =	Position;
    InputRecord.Event.MouseEvent.dwButtonState	    =	Flags;
    InputRecord.Event.MouseEvent.dwControlKeyState  =	0;
    InputRecord.Event.MouseEvent.dwEventFlags	    =	0;

    return PutEvent( &InputRecord );
}



BOOL
consoleIsBusyReadingKeyboard (
    )
/*++

Routine Description:

    Determines if the console is busy reading the keyboard

Arguments:

    None

Return Value:

    TRUE if console is busy reading the keyboard.

--*/
{
    BOOL    Busy;

    EnterCriticalSection(&(EventBuffer.CriticalSection));
    Busy = EventBuffer.BusyFlag;
    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return Busy;
}



BOOL
consoleEnterCancelEvent (
    )
{

    INPUT_RECORD    Record;
    DWORD           dw;

    Record.EventType = KEY_EVENT;
    Record.Event.KeyEvent.bKeyDown            = TRUE;
    Record.Event.KeyEvent.wRepeatCount	      = 0;
    Record.Event.KeyEvent.wVirtualKeyCode     = VK_CANCEL;
    Record.Event.KeyEvent.wVirtualScanCode    = 0;
    Record.Event.KeyEvent.uChar.AsciiChar     = 0;
    Record.Event.KeyEvent.dwControlKeyState   = 0;

    PutEvent( &Record );

    Record.Event.KeyEvent.bKeyDown = TRUE;
    WriteConsoleInput( hInput, &Record, 1, &dw );

    return TRUE;
}


PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    )
/*++

Routine Description:

    Returns pointer to next event record.

Arguments:

    fAdvance	-   Supplies a flag:
		    if TRUE: Advance to next event record
		    if FALSE: Do not advance to next event record

    fWait	-   Supplies a flag:
		    if TRUE, the  blocks until an event is ready.
		    if FALSE, return immediately.

Return Value:

    Pointer to event record, or NULL.

--*/
{
    PINPUT_RECORD  pEvent;
    BOOL Success;

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If the busy flag is set, then the buffer is in the process of
    //	being read. Only one thread should want to wait, so it is
    //	safe to simply return.
    //
    if ( EventBuffer.BusyFlag ) {
	assert( !fWait );
	LeaveCriticalSection(&(EventBuffer.CriticalSection));
	return NULL;
    }

    if (EventBuffer.NumberOfEvents == 0) {

	//
	//  No events in buffer, read as many as we can
	//
	DWORD NumberOfEvents;

	//
	//  If the buffer is too big, resize it
	//
	if ( EventBuffer.MaxEvents > MAX_EVENTS ) {

	    EventBuffer.EventBuffer = REALLOC( EventBuffer.EventBuffer,
					       MAX_EVENTS * sizeof( INPUT_RECORD ) );

	    EventBuffer.MaxEvents = MAX_EVENTS;
	    assert( EventBuffer.EventBuffer );
            if ( !EventBuffer.EventBuffer ) {
                CleanExit( 1, 0 );
                }
	}

	Success = PeekConsoleInput( hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &NumberOfEvents);

	if ((!Success || (NumberOfEvents == 0)) && (!fWait)) {
	    //
	    //	No events available and don't want to wait,
	    //	return.
	    //
	    LeaveCriticalSection(&(EventBuffer.CriticalSection));
	    return NULL;
	}

	//
	//  Since we will block, we have to leave the critical section.
	//  We set the Busy flag to indicate that the buffer is being
	//  read.
	//
	EventBuffer.BusyFlag = TRUE;
	LeaveCriticalSection(&(EventBuffer.CriticalSection));

        Success = ReadConsoleInput( hInput,
                                    EventBuffer.EventBuffer,
                                    NumberOfEvents,
                                    &EventBuffer.NumberOfEvents);

	EnterCriticalSection(&(EventBuffer.CriticalSection));

	EventBuffer.BusyFlag = FALSE;

	if (!Success) {
#if defined( DEBUG )
            // OutputDebugString(" Error: Cannot read console events\n");
	    assert( Success );
#endif
	    EventBuffer.NumberOfEvents = 0;
	}
	EventBuffer.EventIndex = 0;
    }

    if (EventBuffer.NumberOfEvents == 0) {
#if defined( DEBUG )
        // OutputDebugString(" Error: Cannot read console events\n");
        assert( Success );
#endif
        LeaveCriticalSection(&(EventBuffer.CriticalSection));
        return NULL;
        }

    pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

    //
    //	If Advance flag is set, we advance the pointer to the next
    //	record.
    //
    if (fAdvance) {
        if (--(EventBuffer.NumberOfEvents)) {

	    switch (EVENT_TYPE(pEvent)) {

	    case KEY_EVENT:
	    case MOUSE_EVENT:
            case WINDOW_BUFFER_SIZE_EVENT:
            case MENU_EVENT:
            case FOCUS_EVENT:
		(EventBuffer.EventIndex)++;
		break;

	    default:
#if defined( DEBUG)
		sprintf(DbgBuffer, "WARNING: unknown event type %X\n", EVENT_TYPE(pEvent));
		OutputDebugString(DbgBuffer);
#endif
		(EventBuffer.EventIndex)++;
		break;
	    }
	}
    }


    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return pEvent;
}





void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes mouse events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None..

--*/
{
    static  BOOL    Pressed = FALSE;
	    DWORD   MouseFlags;

    //
    //	We only know left and right mouse buttons
    //
    pEvent->dwButtonState &= ( FROM_LEFT_1ST_BUTTON_PRESSED | RIGHTMOST_BUTTON_PRESSED );

    //
    //  Let the editor handle the mouse event
    //
    MouseFlags = 0x00;
    if ( pEvent->dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED ) {
        MouseFlags |=  MOUSE_CLICK_LEFT;
    }
    if ( pEvent->dwButtonState & RIGHTMOST_BUTTON_PRESSED ) {
        MouseFlags |=  MOUSE_CLICK_RIGHT;
    }
    if ( pEvent->dwEventFlags & DOUBLE_CLICK ) {
        MouseFlags |=  MOUSE_DOUBLE_CLICK;
    }

    DoMouse( pEvent->dwMousePosition.Y+1,
        pEvent->dwMousePosition.X+1,
        MouseFlags );

    Pressed = (BOOL)pEvent->dwButtonState;
}





BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    )
/*++

Routine Description:

    Processes window size change events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{

    ROW     Rows;
    COLUMN  Cols;
    ULONG   NewBufferSize;
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.

    UNREFERENCED_PARAMETER( pEvent );

    GetConsoleScreenBufferInfo( ActiveScreenData->ScreenHandle,
				&ScrInfo );

    Rows = ScrInfo.dwSize.Y;
    Cols = ScrInfo.dwSize.X;

    if ( Rows > ActiveScreenData->ScreenInformation.NumberOfRows ||
	 Cols > ActiveScreenData->ScreenInformation.NumberOfCols ) {

	//
	//  resize the screen buffer. Note that the contents of the screen
	//  buffer are not valid anymore. Someone else will have to update
	//  them.
	//
	NewBufferSize = Rows * Cols;

	if (ActiveScreenData->MaxBufferSize < NewBufferSize ) {
	    ActiveScreenData->ScreenBuffer = REALLOC( ActiveScreenData->ScreenBuffer, NewBufferSize * sizeof(CHAR_INFO));
	    ActiveScreenData->MaxBufferSize = NewBufferSize;
	    ActiveScreenData->LineInfo = REALLOC( ActiveScreenData->LineInfo, Rows * sizeof( LINE_INFO ) );
	}

	//
	//  Set the size
	//
	ActiveScreenData->ScreenInformation.NumberOfRows = Rows;
	ActiveScreenData->ScreenInformation.NumberOfCols = Cols;

	ActiveScreenData->FirstRow = ActiveScreenData->ScreenInformation.NumberOfRows;
	ActiveScreenData->LastRow  = 0;

	InitLineInfo( ActiveScreenData );

	//
	//  Let the editor respond the the event
	//
	WindowChange( Rows, Cols );
	return TRUE;
    }

    return FALSE;
}


BOOL
MenuEvent (
    PMENU_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes menu events

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( pEvent );
    return TRUE;
}

BOOL
FocusEvent (
    PFOCUS_EVENT_RECORD pEvent,
    PKBDKEY		pKey
    )
/*++

Routine Description:

    Processes focus events

Arguments:

    pEvent  -	Supplies pointer to event record
    pKey    -	Supplies pointer to key structure to fill out.

Return Value:

    None

--*/
{
    pKey->Unicode   = 0;
    pKey->Scancode  = 5;        // Scan code 5 is for focus events
    if (pEvent->bSetFocus) {
        pKey->Flags = 0;
    } else {
        pKey->Flags = CONS_SHIFT_PRESSED;
    }

    return TRUE;
}


BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    )
/*++

Routine Description:

    Processes key events.

Arguments:

    pEvent  -	Supplies pointer to event record
    pKey    -	Supplies pointer to key structure to fill out.

Return Value:

    TRUE if key structured filled out, FALSE otherwise.

--*/
{
    // static BOOL AltPressed = FALSE;

    if (pEvent->bKeyDown) {

	WORD  Scan = pEvent->wVirtualKeyCode;

	//
	//  Pressing the ALT key generates an event, but we filter this
	//  out.
	//
        if ( Scan == VK_MENU && pEvent->uChar.UnicodeChar == 0 ) {
            return FALSE;
        }

	if (Scan != VK_NUMLOCK &&   // NumLock
	    Scan != VK_CAPITAL &&   // Caps Lock
	    Scan != VK_SHIFT   &&   // Shift
	    Scan != VK_CONTROL ) {  // Ctrl

	    pKey->Unicode   = pEvent->uChar.UnicodeChar;
	    pKey->Scancode  = pEvent->wVirtualKeyCode;
	    pKey->Flags     = pEvent->dwControlKeyState;

	    return TRUE;

	} else {

	    return FALSE;

	}

    } else {

	return FALSE;

    }
}


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    )
{

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If no space at beginning of buffer, resize and shift right
    //
    if ( EventBuffer.EventIndex == 0 ) {

	EventBuffer.EventBuffer = REALLOC( EventBuffer.EventBuffer,
					   (EventBuffer.MaxEvents + EVENT_INCREMENT) * sizeof(INPUT_RECORD));

	if ( !EventBuffer.EventBuffer ) {
	    CleanExit(1, 0);
	}

	memmove( EventBuffer.EventBuffer + EVENT_INCREMENT,
		 EventBuffer.EventBuffer ,
		 EventBuffer.NumberOfEvents * sizeof(INPUT_RECORD) );

	EventBuffer.EventIndex = EVENT_INCREMENT;
    }

    //
    //	Add event
    //
    EventBuffer.EventIndex--;
    EventBuffer.NumberOfEvents++;

    memcpy( EventBuffer.EventBuffer + EventBuffer.EventIndex,
	    InputRecord,
	    sizeof(INPUT_RECORD ));

    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\compile.c ===
/*** compile.c - perform asynch compile
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


static char    szFencePost[]   = "+++   M ";
static LINE    yComp	       = 0;   /* last line viewed in compile log */

/*** compile - <compile> editor function
*
*  Implements the <compile> editor function:
*	compile 		= display compile status
*	arg compile		= compile using command based on file extension
*	arg text compile	= compile using command associated with text
*	arg arg text compile	= compile using "text" as command
*	[arg] arg meta compile	= Kill current background compile
*
* Input:
*  Standard editing function.
*
* Output:
*  Returns TRUE if compile succesfully started or queued.
*
*************************************************************************/
flagType
compile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
) {
    static char szStatus[]	= "no compile in progress";
    
    buffer	pCmdBuf;		    /* compile command to execute   */
    buffer	pFileBuf;		    /* current filename.ext	    */
    buffer	pMsgBuf;

    int 	rc;			    /* Used to pick up return codes */


    switch (pArg->argType) {
    
        case NOARG:

	    domessage (fBusy(pBTDComp) ? szStatus+3 : szStatus);
	    return (flagType) (fBusy(pBTDComp));
    
        case NULLARG:

            if (fMeta) {
                return (flagType) BTKill (pBTDComp);
            }

	    /*
	     * no text was entered, we use default settings according to filename
	     * or extension. Form filename.ext in pFileBuf, get filename extension
	     * into pCmdBuf, and append .obj for the suffix rule.
	     */
	    fileext (pFileHead->pName, pFileBuf);
	    extention (pFileBuf, pCmdBuf);

	    /*
	     * if we don't find a command specifically for this file, or a
	     * command for this suffix rule, trying both DEBUG and non-debug
	     * in both cases, print error and return.
	     */
	    if (!(fGetMake (MAKE_FILE, (char *)pMsgBuf, (char *)pFileBuf))) {
            //if (!(fGetMake (MAKE_SUFFIX, (char *)pMsgBuf, (char *)pCmdBuf))) {
                strcat (pCmdBuf, ".obj");
                if (!(fGetMake (MAKE_SUFFIX, (char *)pMsgBuf, (char *)pCmdBuf))) {
                    return disperr (MSGERR_CMPCMD2, pFileBuf);
                }
            //}
        }

	    /*
	     * pMsgBuf has the user specified compile command, pFileBuf has
	     * the filename. sprintf them together into pCmdBuf.
	     */
	    UnDoubleSlashes (pMsgBuf);
            if ( (rc = sprintf (pCmdBuf, pMsgBuf, pFileBuf)) == 0) {
                return disperr (rc, pMsgBuf);
            }
	    break;
    
        case TEXTARG:
	   /*
	    * text was entered. If 1 arg, use the command associated with "text",
	    * else use the text itself.
	    */
	    strcpy ((char *) buf, pArg->arg.textarg.pText);
	    if (pArg->arg.textarg.cArg == 1) {
		if (!fGetMake (MAKE_TOOL, (char *)pMsgBuf, (char *)"text")) {
                    return disperr (MSGERR_CMPCMD);
                }
		UnDoubleSlashes (pMsgBuf);
                if (rc = sprintf (pCmdBuf, pMsgBuf, buf)) {
                    return disperr (rc, pMsgBuf);
                }
            } else {
                strcpy (pCmdBuf, buf);
            }
	    break;
    
        default:
	    assert (FALSE);
    }
    /*
     * At this point, pCmdBuf has the formatted command we are to exec off, and
     * pFileBuf has the filename.ext of the current file. (pMsgBuf is free)
     */

    AutoSave ();
    Display ();

    /*
     * If there's no activity underway and the log file is not empty and
     * the user wants to flush it: Let's flush !
     */
    if (   !fBusy(pBTDComp)
	&& (pBTDComp->pBTFile)
	&& (pBTDComp->pBTFile->cLines)
	&& (confirm ("Delete current contents of compile log ? ", NULL))
	   ) {
	DelFile (pBTDComp->pBTFile, FALSE);
	yComp = 0;
    }

    /*
     * The log file will be updated dynamically
     */
    UpdLog(pBTDComp);

    /*
     * Send jobs
     */
    if (pBTDComp->cBTQ > MAXBTQ-2) {
        return disperr (MSGERR_CMPFULL);
    }

    if ( BTAdd (pBTDComp, (PFUNCTION)DoFence, pCmdBuf)
        && BTAdd (pBTDComp, NULL,    pCmdBuf)) {
	return dispmsg (MSG_QUEUED, pCmdBuf);
    } else {
        return disperr (MSGERR_CMPCANT);
    }

    argData;
}
    

/*** nextmsg - <nextmsg> editor function
*
*  Implements the <nextmsg> editor function:
*	nextmsg 		= move to next compile error within "pasture"
*	arg numarg nextmsg	= move to "nth" next compile error within the
*				  pasture, where "n" may be a signed long.
*	arg nextmsg		= move to next compile error within the pasture
*				  that does not refer to current file
*	meta nextmsg		= jump the fence into the next pasture.
*				  Discard previous pasture.
*	arg arg nextmsg 	= if current file is compile log, then set
*				  the current location for next error to the
*				  current line in the log. If the file is NOT
*				  the compile log, and it is visible in a
*				  window, change focus to that window. If the
*				  file is NOT visible, then split the current
*				  window to make it visible. If we cannot
*				  split, then do nothing.
*
*  Attempt to display the next error message from the compile. Also make
*  sure that if being displayed, the <compile> psuedo file moves with us.
*
* Input:
*  Standard editing function.
*
* Output:
*  Returns TRUE if message read, or function yCompeted. FALSE if no more
*  messages or no log to begin with.
*
*************************************************************************/

struct msgType {
    char    *pattern;
    int     cArgs;
    };

static struct msgType CompileMsg [] =
{   {	"%s %ld %d:",	    3	    },	    /* Zibo grep		     */
    {	"%[^( ](%ld,%d):",  3	    },	    /* new masm 		     */
    {	"%[^( ](%ld):",     2	    },	    /* cmerge/masm		     */
    {	"%[^: ]:%ld:",	    2	    },	    /* bogus unix GREP		     */
    {	"\"%[^\" ]\", line %ld:", 2 },	    /* random unix CC		     */
    {	NULL,		    0	 }  };

flagType
nextmsg (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    FILEHANDLE  fh;                    /* handle for locating file         */
    flagType	fHopping   = FALSE;	/* TRUE = hopping the fence	    */
    pathbuf	filebuf;		/* filename from error message	    */
    fl		flErr;			/* location of error		    */
    flagType	fLook;			/* look at this error message?	    */
    int 	i;			/* everyone's favorite index        */
    LINE	oMsgNext    = 1;	/* relative message number desired  */
    char	*p;			/* temp pointer 		    */
    char	*pText; 		/* pointer into text buffer	    */
    rn		rnCur;			/* range highlighted in log	    */
    pathbuf	tempbuf;		/* text arg buffer		    */
    linebuf	textbuf;		/* text arg buffer		    */
    
    /*
     * if there's no log, there's no work.
     */
    if (!PFILECOMP || !PFILECOMP->cLines) {
        return FALSE;
    }
    
    switch (pArg->argType) {
    
        case NULLARG:
            /*
             * arg arg: if current file is <compile>, set yComp to current position
             * therein & get next message. If more than one window, move to the next
             * window in the system before doing that.
             */
            if (pArg->arg.nullarg.cArg >= 2) {
		if (pFileHead == PFILECOMP) {
		    yComp = lmax (YCUR(pInsCur) - 1, 0L);
                    if (cWin > 1) {
                        pArg->argType = NOARG;
                        window (0, pArg, FALSE);
                    }
                    break;
                }
                /*
                 * If the file is visible, the we can just make it current, adn we're done.
                 */
		else for (i=cWin; i; ) {
		    pInsCur = WININST(&WinList[--i]);
		    if (pInsCur->pFile == PFILECOMP) {
                        SetWinCur (i);
			return TRUE;
                    }
                }
                /*
                 * The file is not visible, see if we can split the window and go to it.
                 */
		if ((WINYSIZE(pWinCur) > 20) && (cWin < MAXWIN)) {
		    if (SplitWnd (pWinCur, FALSE, WINYSIZE(pWinCur) / 2)) {
			newscreen ();
			SETFLAG (fDisplay, RCURSOR|RSTATUS);
                        SetWinCur (cWin-1);
			fChangeFile (FALSE, rgchComp);
			flErr.lin = 0;
			flErr.col = 0;
			cursorfl (flErr);
			return TRUE;
                    }
                }
		return FALSE;
            }
            /*
             * Null arg: get the first line of the next file. That is signified by the
             * special case offset of 0.
             */
            else {
                oMsgNext = 0;
            }

        case NOARG:
            /*
             * meta: hop to next fence. Begin deleting lines util a fence is reached, or
             * until there are no more lines. Set up to then read the next message line.
             */
            if (fMeta) {
                do {
		    DelLine (FALSE, PFILECOMP, 0L, 0L);
		    GetLine (0L, textbuf, PFILECOMP);
                } while (strncmp (textbuf, szFencePost, sizeof(szFencePost)-1)
                   && PFILECOMP->cLines);
                yComp = 0;
            }
            /*
             * No arg: we just get the next line (offset = 1)
             */
	    break;
        
        case TEXTARG:
            /*
             * text arg is an absolute or relative message number. If it is absolute, (no
             * leading plus or minus sign), we reset yComp to 0 to get the n'th line
             * from the begining of the log.
             */
	    strcpy ((char *)textbuf, pArg->arg.textarg.pText);
            pText = textbuf;
            if (*pText == '+') {
                pText++;
            }
            if (!fIsNum (pText)) {
                return BadArg ();
            }
            if (isdigit(textbuf[0])) {
                yComp = 0;
            }
            oMsgNext = atol (pText);
            break;
        
        default:
    	    assert (FALSE);
    }
    /*
     * Ensure that the compile log file has no highlighting.
     */

    ClearHiLite (PFILECOMP, TRUE);

    /*
     * This loop gets executed once per line in the file as we pass over them. We
     * break out of the loop when the desired error line is found, or we run out
     * of messages
     *
     * Entry:
     *  yComp    = line # previously viewed. (0 if no messages viewed yet)
     *  oMsgNext = relative message number we want to view, or 0, indicating
     *             first message of next file.
     */
    while (TRUE) {
        /*
         * Move to check next line.
         */
        if (oMsgNext >= 0) {
    	    yComp++;
        } else if (oMsgNext < 0) {
            yComp--;
        }
        /*
         * read current line from the log file & check for fences & end of file. If
         * we encounter a fence or off the end, declare that there are no more
         * messages in this pasture.
         */

	NoUpdLog(pBTDComp);

	GetLine (lmax (yComp,1L), textbuf, PFILECOMP);
	if (   (yComp <= 0L)
	    || (yComp > PFILECOMP->cLines)
	    || !strncmp (textbuf, szFencePost, sizeof(szFencePost)-1)
	   ) {
	    UpdLog(pBTDComp);
            if (!fBusy(pBTDComp) || (yComp <= 0L)) {
                yComp = 0;
            }
            domessage ("No more compilation messages" );
            return FALSE;
        }
        /*
         * Attempt to isolate file, row, column from the line.
         */
        for (i = 0; CompileMsg[i].pattern != NULL; i++) {
            flErr.lin = 0;
            flErr.col = 0;
            if (sscanf (textbuf, CompileMsg[i].pattern, filebuf, &flErr.lin,
                    &flErr.col) == CompileMsg[i].cArgs) {
                break;
            }
        }
        /*
         * If A validly formatted line was found, and we can find a message (After :)
         * then skip spaces prior to the error message (pointed to by p), pretty up
         * the file, convert it to canonicalized form
         */
        if (   CompileMsg[i].pattern 
            && (*(p = strbscan (textbuf+strlen(filebuf), ":"))) 
           ) {
	    p = whiteskip (p+1);
            if (filebuf[0] != '<') {
		rootpath (filebuf, tempbuf);
            } else {
                strcpy (tempbuf, filebuf);
            }
            /*
             * Adjust the error message counter such that we'll display the "nth" message
             * we encounter. Set flag to indicate whether we should look at this
             * error message.
             */
	    fLook = FALSE;
	    if (oMsgNext > 0) {
                if (!--oMsgNext) {
                    fLook = TRUE;
                }
            } else if (oMsgNext < 0) {
                if (!++oMsgNext) {
                    fLook = TRUE;
                }
            } else {
                fLook = (flagType) _strcmpi (pFileHead->pName, tempbuf);
            }
    
	    if (fLook) {
                /*
                 * if about to change to new file, check for existance first, and if found,
                 * autosave our current file.
                 */
                if (_strcmpi(pFileHead->pName, tempbuf)) {
                    fh = ZFOpen(tempbuf, ACCESSMODE_READ, SHAREMODE_RW, FALSE);
                    if (fh == NULL) {
                        return disperr (MSGERR_CMPSRC, tempbuf);
                    }
                    ZFClose (fh);
		    AutoSave ();
                }
                /*
                 * Change the current file to that listed in the error message. If successfull,
                 * then also change our cursor location to that of the error.
                 */
		if (filebuf[0] != 0) {
                    if (!fChangeFile (FALSE, strcpy (buf, tempbuf))) {
                        return FALSE;
                    }
		    if (flErr.lin--) {
                        if (flErr.col) {
			    flErr.col--;
                        } else {
			    cursorfl (flErr);
			    flErr.col = dobol ();
                        }
			cursorfl (flErr);
                    }
                }
                /*
                 * Update the contents of the compile log, if it happens to be displayed.
                 */
		rnCur.flLast.lin = rnCur.flFirst.lin = lmax (yComp,0L);
		rnCur.flFirst.col = 0;
		rnCur.flLast.col = sizeof(linebuf);
		SetHiLite (PFILECOMP, rnCur, HGCOLOR);
		UpdateIf (PFILECOMP, lmax (yComp,0L), FALSE);
                /*
                 * Place the actual error message text on the dialog line.
                 */
                if ((int)strlen(p) >= XSIZE) {
                    p[XSIZE] = '\0';
                }
		domessage( "%s", p );
		return TRUE;
            }
        }
    }

    argData;
}


/*** DoFence - Build Fence message line & put it in the log file
*
*  Builds the line output to the compile log which seperates succesive
*  compiles and puts it into the log file.
*
*  "+++ PWB Compile: [drive:pathname] command"
*
* Input:
*  pCmd 	= ptr to command to execute (Series of null terminated strings)
*
* Output:
*  Returns nothing
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

void
DoFence (
    char *pCmd,
    flagType fKilled
    ) {
    linebuf pFenceBuf;

    if (!fKilled) {
	AppFile (BuildFence ("Compile", pCmd, pFenceBuf), pBTDComp->pBTFile);
	UpdateIf (pBTDComp->pBTFile, pBTDComp->pBTFile->cLines - 1, FALSE);
    }
}


// #pragma check_stack ()


/*** BuildFence - Build Fence message line
*
*  Builds the line output to the compile log which seperates succesive
*  compiles.
*
*  "+++ PWB Compile: [drive:pathname] command"
*
* Input:
*  pFunction	= pointer to function name being dealt with
*  pCmd 	= ptr to command to execute (Series of null terminated strings)
*  pFenceBuf	= ptr to buffer in wich to put constructed fence
*
* Output:
*  Returns nothing
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

char *
BuildFence (
    char const *pFunction,
    char const *pCmd,
    char       *pFenceBuf
    ) {
    strcpy (pFenceBuf, szFencePost);
    strcat (pFenceBuf, pFunction);
    strcat (pFenceBuf, ": [");
    GetCurPath (strend (pFenceBuf));
    strcat (pFenceBuf, "] ");
    strcat (pFenceBuf, pCmd);
    return (pFenceBuf);
}

// #pragma check_stack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\dline.c ===
/*** dline.c - return one display line
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


/*** fInRange - return true if the arguments are in order
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
fInRange (
    long a,
    long x,
    long b
    ) {
    return (flagType) (((a <= x) && (x <= b)) || ((a >= x) && (x >= b)));
}



/*
 * Characters used in window borders
 */

#define DHBAR	((char)0xCD)
#define DVBAR	((char)0xBA)
#define DLTEE	((char)0xB9)
#define DUTEE	((char)0xCA)
#define DRTEE	((char)0xCC)
#define DDTEE	((char)0xCB)
#define DCRSS	((char)0xCE)

/*** DisplayLine - Get's the i'th display line of a window
*
*  Gets exactly what needs to be shown in the i'th line of the screen.
*  This takes care of showing trailing spaces, drawing borders, etc...
*
* Input:
*  yScrLine	- Get i'th line showing in the window
*  pchScrLine	- pointer to line buffer where the screen line is to be put
*  pplaScrLine	- pointer to pointer to place to put color info
*  pchFileLine	- pointer to line buffer
*  pplaFileLine - pointer to pointer to place to put color info
*
* Note:
*  If there is only one window on the screen then we only need one line
*  buffer and one color buffer. DoText should have taken care of this so
*  pchFileLine and *pplaFileLine should be both NULL.
*
* Output:
*  Returns Length of string in pchScrLine
*
****************************************************************************/
int
DisplayLine (
    int               yScrLine,
    char             *pchScrLine,
    struct lineAttr **pplaScrLine,
    char             *pchFileLine,
    struct lineAttr **pplaFileLine
    ) {

    int 	     iWnd;
    REGISTER PWND    pWnd;
    PINS	     pIns;
    PFILE	     pFile;

    int 	     cch;
    REGISTER char   *pch;

    /*
     * one window, speed hack:
     *
     * if there is only one window, just grab the line, append any trailing
     * space display, move the applicable portion of the line to the head of
     * the buffer, space fill out to the window width, and get the color info
     * for the line.
     */
    if (cWin == 1) {

	/*
	 * we always get the detab'ed (non-RAW) line for displaying.
	 */
	cch = gettextline (FALSE,
			   yScrLine + YWIN(pInsCur),
			   pchScrLine,
			   pFileHead,
			   tabDisp);
	ShowTrailDisp (pchScrLine, cch);

	/*
	 * Scroll left to match instance
	 */
	if (XWIN(pInsCur)) {
	    cch = max (0, min (cch - XWIN(pInsCur), XSIZE));
	    memmove( pchScrLine, (pchScrLine + XWIN(pInsCur)), cch );
        } else {
            cch = min (cch, XSIZE);
        }

	/*
	 * Pad end of line with blanks
	 */
        if (cch < XSIZE) {
	    memset ((char *) pchScrLine + cch, ' ', XSIZE - cch);
        }
	pchScrLine[XSIZE] = 0;

	/*
	 * Get color and hiliting info from the file
	 * (UpdHilite takes care of left scroll)
	 */
	GetColorUntabbed ((LINE)(yScrLine + YWIN(pInsCur)), *pplaScrLine, pFileHead);
	UpdHiLite (pFileHead,
		   (LINE) (yScrLine + YWIN(pInsCur)),
		   XWIN(pInsCur),
		   XWIN(pInsCur) + XSIZE - 1,
		   pplaScrLine);
	return XSIZE;
    }

    /*
     * Multiple windows
     *
     * initially set up the line to be all dashes (horizontal screen split)
     * with window borders color
     */
    memset ((char *) (pchScrLine), DHBAR, XSIZE);
    pchScrLine[XSIZE] = 0;
    (*pplaScrLine)->len   = 0xffff;
    (*pplaScrLine)->attr  = WDCOLOR;

    /*
     * for each active window
     */
    for (iWnd = 0, pWnd = WinList; iWnd < cWin; iWnd++, pWnd++) {
	/*
	 * if the display line is in the window
	 */
	if (fInRange ((long) WINYPOS(pWnd),
		      (long) yScrLine,
		      (long) (WINYPOS(pWnd) + WINYSIZE(pWnd) - 1))) {
	    /*
	     * Do window on right
	     */
            if (WINXPOS(pWnd)) {
		switch (*(pch = pchScrLine + WINXPOS(pWnd) - 1) & 0xFF) {
		    case DHBAR:
			*pch = DLTEE;
			break;
		    case DRTEE:
			*pch = DVBAR;
			break;
		    case DUTEE:
			*pch = DLTEE;
			break;
		    case DCRSS:
			*pch = DLTEE;
			break;
                }
            }
	    /*
	     * blank the window
	     */
	    memset ((char *) pchScrLine + WINXPOS(pWnd), ' ', WINXSIZE(pWnd));
	    UpdOneHiLite (*pplaScrLine,
			  WINXPOS(pWnd),
			  WINXSIZE(pWnd),
			  TRUE,
			  FGCOLOR);

	    /*
	     * retrieve the window instance and current file
	     */
	    pIns = pWnd->pInstance;
	    pFile = pIns->pFile;

	    /*
	     * get the correct line from the file
	     */
	    cch = gettextline (FALSE,
			       (LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			       pchFileLine,
			       pFile,
			       tabDisp);
	    ShowTrailDisp (pchFileLine, cch);

	    /*
	     * if line is visible
	     */
	    if (cch >= XWIN (pIns)) {

		/*
		 * move the visible portion of the line into the buffer
		 */
		memmove((char*)( pchScrLine + WINXPOS( pWnd )),
			(char*)( pchFileLine + XWIN( pIns )),
			min (cch-XWIN(pIns), WINXSIZE(pWnd)));

		/*
		 * Get color and hiliting info from the file
		 * (UpdHilite takes care of left scroll)
		 */
		GetColorUntabbed ((LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			  *pplaFileLine,
			  pFile);
		UpdHiLite (pFile,
			   (LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			   XWIN(pIns),
			   XWIN(pIns) + WINXSIZE(pWnd) - 1,
			   pplaFileLine);

		/*
		 * Put it in the screen buffer
		 */
		UpdOneHiLite (*pplaScrLine,
			      WINXPOS(pWnd),
			      WINXSIZE(pWnd),
			      FALSE,
			      (INT_PTR) *pplaFileLine);
            }
	    /*
	     * do window left
	     */
	    switch (*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF) {
		case DHBAR:
		    *pch = DRTEE;
		    break;
		case DLTEE:
		    *pch = DVBAR;
		    break;
		case DCRSS:
		    *pch = DRTEE;
		    break;
            }
        } else {
            /*
             * test for break immediately above
             */
            if (WINYPOS(pWnd) + WINYSIZE(pWnd) == yScrLine) {
                switch (*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF) {
                    case DHBAR:
                        *pch = DUTEE;
                        break;
                    case DDTEE:
                        *pch = DCRSS;
                        break;
                }
            } else {
                /*
                 * test for break immediately below
                 */
                if (WINYPOS(pWnd)-1 == yScrLine) {
                    switch (*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF) {
                        case DHBAR:
                            *pch = DDTEE;
                            break;
                        case DUTEE:
                            *pch = DCRSS;
                            break;
                    }
                }
            }
        }
    }
    pchScrLine[XSIZE] = 0;
    return XSIZE;
}



/*** SetTrailDisp - set character displayed for trailing spaces.
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
SetTrailDisp (
    char * val
    ) {
    buffer locval;

    strcpy ((char *) locval, val);

    trailDisp = (char) atoi (locval);

    newscreen ();
    return TRUE;
}



/*** ShowTrailDisp
*
* Input:
*
* Output:
*
*************************************************************************/
void
ShowTrailDisp (
    buffer buf,
    int len
    ) {
    REGISTER char * p;

    if (trailDisp) {
        p = &buf[len];
        while (p > buf && p[-1] == ' ') {
            *--p = trailDisp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\display.c ===
/*** display.c - display the current file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#define INCL_SUB
#define INCL_MESSAGES

#include "z.h"

#define DEBFLAG DISP



/*** Display & DoDisplay - update the physical display
*
*  We examine all the hints left around for us by the editing and attempt to
*  make a minimal set of changes to the screen. We will do this until one of
*  the following conditions exist:
*
*   - the screen is completely updated
*   - there is a keystroke waiting for us
*
*  When one occurs, we return.
*
*  The hints that are left around are as follows:
*
*   fDisplay is a bit field indicating what part of the general display needs
*   to be updated. The fields (and the corresponding areas) are:
*
*	RTEXT	    the window on the file(s)
*	RSTATUS     the status line on the bottom of the screen
*	RCURSOR     the cursor
*	RHIGH	    the region [xhlStart,yhlStart] [xhlEnd,yhlEnd] is to be
*		    highlighted on the screen.
*
*  fChange[i] is a bit field for each line of the display indicating how the
*  line might have changed. The fields are:
*
*      FMODIFY	   the line has changed somewhat; ideally, we merely compare
*		       each character in the new line (retrieved with GetLine)
*		       with the one kept in the screen shadow array.
*
*  Display checks first to see if we are in a macro, and returns if we are.
*  DoDisplay does not check.
*
* Input:
*  none, other than various globals mentioned above.
*
* Output:
*  screen updated or key hit (or macro in progress for Display).
*
*************************************************************************/

void
Display (
    void
    ) {
    if (!mtest ()) {
        DoDisplay ();
    }
}



void
DoDisplay (
    void
	) {

    int Row, Col;

    if (pFileHead == NULL) {
        return;
    }

    if (TESTFLAG (fDisplay, RCURSOR)) {

        Row = YCUR(pInsCur) - YWIN(pInsCur) + WINYPOS(pWinCur);
        Col = XCUR(pInsCur) - XWIN(pInsCur) + WINXPOS(pWinCur);

	if ( Row >= YSIZE || Col >= XSIZE ) {
            docursor( XCUR(pInsCur), YCUR(pInsCur) );
        }
    }

	/*
     * If text needs updating, do so. Return immediately if a keystroke was
     * pressed.
	 */
	if (TESTFLAG (fDisplay, RTEXT) && !DoText (0, YSIZE)) {
		return;
    }

	if ((fDisplayCursorLoc && TESTFLAG (fDisplay, RCURSOR)) ||
	    TESTFLAG (fDisplay, RSTATUS)) {
        DoStatus ();
    }

    if (TESTFLAG (fDisplay, RCURSOR)) {

        Row = YCUR(pInsCur) - YWIN(pInsCur) + WINYPOS(pWinCur);
        Col = XCUR(pInsCur) - XWIN(pInsCur) + WINXPOS(pWinCur);

        consoleMoveTo( Row, Col );
		RSETFLAG (fDisplay, RCURSOR);
	}
}


/*** DoText - Update window text
*
* Purpose:
*  Update given window until entirely accurate or until there are      *
*  are keystrokes waiting to be entered.  Use the hints in fDisplay    *
*  and fChange to guide the update.				       *
*
* Input:
*  yLow        0-based beginning line number of display update
*  yHigh       0-based ending line number of display update
*
* Output:
*  Returns TRUE if successfully updated screen					*
*	   FALSE if keystrokes are awaiting					*
*
*************************************************************************/

flagType
DoText (
    int yLow,
    int yHigh
    ) {

	REGISTER int		yCur;
	int 				yMin = -1;
	int 				yMax = 0;

	flagType			fReturn = TRUE;

	struct lineAttr 	*plaFile = NULL;
	struct lineAttr 	*plaScr  = NULL;
	struct lineAttr 	*plaFileLine;
	struct lineAttr 	*plaScrLine;

	char				*pchFileLine = NULL;
	char				pchScrLine[ 2 * sizeof(linebuf) * (1 + sizeof(struct lineAttr))];
	int 				cchScrLine;

	// int				chkpnt = yHigh - yLow > 25 ? 20 : 5;
	int					chkpnt = yHigh - yLow > 25 ? 10 : 3;


	fReDraw = FALSE;

	plaScr = (struct lineAttr *) (pchScrLine + sizeof(linebuf));
    if (cWin > 1) {
		pchFileLine = pchScrLine + sizeof(linebuf) * (1 + sizeof(struct lineAttr));
		plaFile = (struct lineAttr *) (pchFileLine + sizeof(linebuf));
    }

    /*
     * For each line in the window, if the line is marked changed, update it.
     */
	for (yCur = yLow; yCur < yHigh; ) {

		if (TESTFLAG(fChange[yCur], FMODIFY)) {
            if (yMin == -1) {
                yMin = yCur;
            }
			yMax = yCur;

			/*
			 * get and display the line
			 */
			plaScrLine	= plaScr;
			plaFileLine = plaFile;
			cchScrLine = DisplayLine (yCur, pchScrLine, &plaScrLine, pchFileLine, &plaFileLine);
			coutb (0, yCur, pchScrLine, cchScrLine, plaScrLine);

			RSETFLAG(fChange[yCur],FMODIFY);
			/*
			 * if it is time to check, and there is a character waiting, stop
			 * the update process, and go process it
			 */
			if ( (yCur % chkpnt == 0) && TypeAhead() ) {
				fReturn = FALSE;
				break;
			}
		}
		yCur++;
	}

    if (fReturn) {
        RSETFLAG (fDisplay, RTEXT);
	}
	//
	//	Update the screen
	//
    fReDraw = TRUE;
	vout(0,0,NULL,0,0);
	return fReturn;
}



/*** DoStatus - Update the status line
*
* Purpose:
*  Creates and displays the status line on the bottom of the screen.
*
* Input:
*  None, other than the various globals that go into the status line.
*
* Output:
*  Returns status line output
*
*************************************************************************/

#define CINDEX(clr)     (unsigned char) ((&clr-&ColorTab[0])+isaUserMin)

void
DoStatus (
    void
    ) {
    struct lineAttr rglaStatus[10];		/* color array for status line	*/
    int 	    cch;
    int         ilaStatus  = 0;        /* index into color array       */
    int         i;
    char        *pchEndBuf;           /* save for end of buffer       */
    char        buf[512];


    /*
     * Start with filename, and file type
     */
    strcpy (buf, pFileHead->pName);
    strcat (buf, " (");
    strcpy ((char *)strend(buf), GetFileTypeName ());

    /*
     * Add other file characterisctics
     */
    if (!TESTFLAG (FLAGS (pFileHead), DOSFILE)) {
        strcat (buf," NL");
    }

    if (TESTFLAG (FLAGS (pFileHead), TEMP)) {
        strcat (buf, " temp");
    }

    if ((TESTFLAG (FLAGS (pFileHead), READONLY)) | fGlobalRO) {
        strcat (buf, " No-Edit");
    }

    if (TESTFLAG (FLAGS (pFileHead), DISKRO)) {
        strcat (buf, " RO-File");
    }

    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus++].len = (unsigned char) strlen (buf);

    if (TESTFLAG (FLAGS(pFileHead), DIRTY)) {
	strcat (buf, " modified");
	rglaStatus[ilaStatus].attr = CINDEX(errColor);
	rglaStatus[ilaStatus++].len = 9;
    }

    pchEndBuf = strend (buf);
    sprintf (strend(buf), ") Length=%ld ", pFileHead->cLines);

    /*
     * Add current location
     */
    if (fDisplayCursorLoc) {
	sprintf (strend(buf), "Cursor=(%ld,%d)", YCUR(pInsCur)+1, XCUR(pInsCur)+1);
    } else {
        sprintf (strend(buf), "Window=(%ld,%d)", YWIN(pInsCur)+1, XWIN(pInsCur)+1);
    }
    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus++].len = (unsigned char) (strend(buf) - pchEndBuf);

    /*
     * Add global state indicators
     */
    if (fInsert | fMeta | fCtrlc | fMacroRecord) {
	rglaStatus[ilaStatus].attr = CINDEX(infColor);
	rglaStatus[ilaStatus].len = 0;
	if (fInsert) {
	    strcat (buf, " insert");
	    rglaStatus[ilaStatus].len += 7;
        }
	if (fMeta) {
	    strcat (buf, " meta");
	    rglaStatus[ilaStatus].len += 5;
        }
	if (fCtrlc) {
	    strcat (buf, " cancel");
	    rglaStatus[ilaStatus].len += 7;
	    fCtrlc = FALSE;
	    FlushInput ();
        }
	if (fMacroRecord) {
	    strcat (buf, " REC");
	    rglaStatus[ilaStatus].len += 4;
        }
	ilaStatus++;
    }

    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus].len = 0xffff;
	pchEndBuf = buf;

    /*
     * if the net result is too long, eat the first part of the filename with
     * an elipses (Leave room for BC as well).
     */
    cch = strlen(buf) - (XSIZE - 4);

    if (cch > 0) {
		pchEndBuf = buf + cch;
		pchEndBuf[0] = '.';
		pchEndBuf[1] = '.';
		pchEndBuf[2] = '.';

        i = 0;

        while ( cch && i <= ilaStatus  ) {

            if ( (int)rglaStatus[i].len > cch ) {

                rglaStatus[i].len -= (unsigned short) cch;
				cch = 0;

			} else {

                cch -= rglaStatus[i].len;
                rglaStatus[i].len = 0;

			}

            i++;
		}
	}

	fReDraw = FALSE;
    coutb (0, YSIZE+1, pchEndBuf, strlen(pchEndBuf), rglaStatus);

	fReDraw = TRUE;
	voutb (XSIZE-2, YSIZE+1, BTWorking() ? "BP" : "  ", 2, errColor);

	RSETFLAG (fDisplay,  RSTATUS);

}



/*** newscreen - Mark entire screen dirty
*
*  Forces entire screen to be redrawn.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
newscreen (
    void
    ) {

	REGISTER int iLine = YSIZE;

	while (iLine--) {
		SETFLAG ( fChange[iLine], FMODIFY );
	}

	SETFLAG (fDisplay, RTEXT);
}



/*** redraw - Mark a range of lines in file dirty
*
*  Marks a range of lines in a file as needing to be updated. Each window that
*  they occur in is marked.
*
* Input:
*  pFile	     = File handle containing dirty lines
*  linFirst, linLast = Range of lines to mark
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
redraw (
    PFILE pFile,
    LINE  linFirst,
    LINE  linLast
    ) {

    LINE	  linFirstUpd, linLastUpd;
    REGISTER PINS pInsTmp;

    int                         iWinTmp;
    REGISTER struct windowType *pWinTmp;

	if (linFirst > linLast) {
	linFirstUpd = linLast;
	linLast     = linFirst;
	linFirst    = linFirstUpd;
    }

    for (iWinTmp = 0, pWinTmp = WinList; iWinTmp < cWin; iWinTmp++, pWinTmp++) {
        if (pWinTmp->pInstance) {
            if (pFile == pWinTmp->pInstance->pFile) {
                pInsTmp = pWinTmp->pInstance;
                linFirstUpd = WINYPOS(pWinTmp) + lmax (0L, linFirst-YWIN(pInsTmp)-1);
                linLastUpd  = WINYPOS(pWinTmp) + lmin ((long) (WINYSIZE(pWinTmp) - 1), linLast - YWIN(pInsTmp));
                while (linFirstUpd <= linLastUpd) {
                    SETFLAG (fChange[linFirstUpd++],FMODIFY);
                }
            }
        }
    }
	SETFLAG (fDisplay, RTEXT);
}



/*** newwindow - Mark current window dirty
*
*  Mark all lines in the current window as needing to be updated
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
newwindow (
    void
    ) {

    REGISTER int iLine;

	//
    // We ignore the next two assertions, because of a more involved problem of
    // screen size being set up AFTER  instances and window layout have been read
    // in on start up. This means that for a short period of time, these
    // conditions might actually exist. We check for the error and limit the
    // access of the fchange array for now.
    //
    //    assert (MEMSIZE (fChange) >= WINYSIZE (pWinCur));
    //    assert (WINYSIZE (pWinCur) + WINYPOS (pWinCur) <= YSIZE);

    for (iLine = 0; iLine < WINYSIZE (pWinCur); iLine++) {
        if (iLine + WINYPOS(pWinCur) < YSIZE) {
            SETFLAG (fChange[iLine + WINYPOS(pWinCur)],FMODIFY);
        }
    }
	SETFLAG (fDisplay, RTEXT);
}



/*** noise
*
* Input:
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
noise (
    REGISTER LINE lin
    ) {

    char szTinyBuf[10];

    if (lin && cNoise) {
		if ((lin % cNoise) == 0) {
            sprintf (szTinyBuf, " %ld", lin);
			soutb (XSIZE-10, YSIZE+1, szTinyBuf, fgColor);
        }
    }

}



/*** dispmsg - display retrieved message on help/status line
*
*  Places a message on the help/status line. It is removed the next time
*  activity occurrs on that line.
*
*  In the CW version, the resulting (formatted) message is placed in the
*  local heap, and actually displayed by the WndProc for the help window.
*
* Input:
*  iMsg 	= index for message string to be retrieved and displayed.
*		  The string may have embedded printf formatting. If iMsg
*		  is zero, the status line is cleared.
*  ...		= variable number of args per the formatted string
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
__cdecl
dispmsg (
    int     iMsg,
    ...
    ) {

	buffer	fmtstr;				/* retrieved formatting string		*/
    //buffer  textbuf;            /* formatted output line            */
    char    textbuf[ 512 ];
	int 	len;				/* Length of message				*/
    va_list Argument;

    va_start(Argument, iMsg);

    if (fMessUp = (flagType)iMsg) {
		GetMsg (iMsg, fmtstr);
		ZFormat (textbuf, fmtstr, Argument);
		len = strlen(textbuf);
        if (len > (XSIZE-1)) {
			//
			//	message is too long, we will truncate it
			//
            textbuf[XSIZE-1] = '\0';
		}
	} else {
		textbuf[0] = ' ';
		textbuf[1] = '\0';
    }

    fReDraw = TRUE;
    soutb (0, YSIZE, textbuf, infColor);

    va_end(Argument);

    return TRUE;
}



/*** disperr - display error message on status line
*
*  prints a formatted error message on the status line, and then waits for a
*  keystroke. Once hit, the message is cleared.
*
* Input:
*  iMsg 	= index for message string to be retrieved and displayed.
*		  The string may have embedded printf formatting.
*  ...		= variable number of args per the formatted string
*
* Output:
*  returns FALSE
*
*************************************************************************/
flagType
__cdecl
disperr (
    int     iMsg,
    ...
    ) {

    buffer  pszFmt;			/* retrieved formatting string	*/
    buffer  bufLocal;			/* formatted output line	*/
    va_list Arguments;

    assert (iMsg);
    GetMsg (iMsg, pszFmt);

    va_start(Arguments, iMsg);

    ZFormat (bufLocal, pszFmt, Arguments);

    fReDraw = TRUE;
    bell ();
    FlushInput ();
    soutb (0, YSIZE, bufLocal, errColor);
    if (fErrPrompt) {
		asserte (*GetMsg (MSG_PRESS_ANY, bufLocal));
        soutb (XSIZE-strlen(bufLocal)-1, YSIZE, bufLocal, errColor);
        SetEvent( semIdle );
		ReadChar ();
        WaitForSingleObject(semIdle, INFINITE);
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
		soutb(0, YSIZE, bufLocal, errColor);
    }

    va_end(Arguments);

    return FALSE;
}



/*** domessage - display a message on the help-status line
*
*  Places a message on the help/status line. It is removed the next time
*  activity occurrs on that line.
*
*  In the CW version, the resulting (formatted) message is placed in the
*  local heap, and actually displayed by the WndProc for the help window.
*
* Input:
*  pszFmt	- Printf formatting string
*  ...		- variable number of args as per the formatting string
*
* Output:
*  Returns nothing
*
* UNDONE: all calls to domessage should be replaced by calls to dispmsg
*
*************************************************************************/
int
__cdecl
domessage (
    char    *pszFmt,
    ...
	) {


#define NEEDED_SPACE_AFTER_MESSAGE      12

    char    bufLocal[512];
	va_list Arguments;
	int 	Length;
	char   *Msg;

    va_start(Arguments, pszFmt);

    if (fMessUp = (flagType)(pszFmt != NULL)) {
        ZFormat (bufLocal, pszFmt, Arguments);
	} else {
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
    }

    fReDraw = TRUE;

	va_end(Arguments);

	//
	//	We have to make sure that the message is not too long for
	//	this line. If it is, se only display the last portion of it.
	//
	Length = strlen( bufLocal );

	if ( Length > XSIZE - NEEDED_SPACE_AFTER_MESSAGE ) {
		Msg = (char *)bufLocal + (Length - ( XSIZE - NEEDED_SPACE_AFTER_MESSAGE ));
		Length =  XSIZE - NEEDED_SPACE_AFTER_MESSAGE;
	} else {
		Msg = (char *)bufLocal;
	}

	soutb( 0, YSIZE, Msg, infColor );

	return	Length;

}



/*** printerror - print error message on status line
*
*  prints a formatted error message on the status line, and then waits for a
*  keystroke. Once hit, the message is cleared.
*
* Input:
*  printf style parameters
*
* Output:
*  Number of characters output in error message
*
*************************************************************************/
int
__cdecl
printerror (
    char *pszFmt,
    ...
    ) {

    buffer       bufLocal;
    va_list      Arguments;
    REGISTER int cch;

    va_start(Arguments, pszFmt);

    ZFormat (bufLocal, pszFmt, Arguments);

    fReDraw = TRUE;
    bell ();
    FlushInput ();
    cch = soutb (0, YSIZE, bufLocal, errColor);
    if (fErrPrompt) {
		asserte (*GetMsg (MSG_PRESS_ANY, bufLocal));
        soutb (XSIZE-strlen(bufLocal)-1, YSIZE, bufLocal, errColor);
        SetEvent( semIdle );
		ReadChar ();
        WaitForSingleObject(semIdle, INFINITE);
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
		soutb(0, YSIZE, bufLocal, errColor);
    }

    va_end(Arguments);

    return cch;
}



/*** bell
*
* Input:
*
* Output:
*
*************************************************************************/
void
bell (
    void
    ) {

    printf ("%c", BELL);

}



/*** makedirty
*
*
* Input:
*
* Output:
*
*************************************************************************/
void
makedirty (
    REGISTER PFILE pFileDirty
    ) {
    if (!TESTFLAG(FLAGS(pFileDirty),DIRTY)) {
        if (pFileDirty == pFileHead) {
            SETFLAG (fDisplay, RSTATUS);
        }
	SETFLAG (FLAGS(pFileDirty), DIRTY);
    }
}



/*** delay
*
* Input:
*
* Output:
*
*************************************************************************/
void
delay (
    int cSec
    ) {

    time_t lTimeNow, lTimeThen;

    if (mtest () && !mlast ()) {
        return;
    }
    time (&lTimeThen);
    do {
        if (TypeAhead ()) {
            return;
        }
	Sleep (100);
	time (&lTimeNow);
    } while (lTimeNow - lTimeThen < cSec + 1);
}



/*** SetScreen
*
* Purpose:
*   SetScreen () - Set up the editor's internal structures to match the screen
*   size described by ySize and xSize.	Set the hardware to the mode in
*   Zvideo.
*
* Input:
*
* Output:
*
*************************************************************************/
void
SetScreen (
    void
    ) {
    fChange = ZEROREALLOC (fChange, YSIZE * sizeof (*fChange));
    SETFLAG (fDisplay, RSTATUS);
    if (cWin == 1) {
	WINXSIZE(pWinCur) = XSIZE;
	WINYSIZE(pWinCur) = YSIZE;
    }
    newscreen ();
	// SetVideoState(Zvideo);
}



/*** HighLight
*
*
* Input:
*
* Output:
*
*************************************************************************/
void
HighLight (
    COL  colFirst,
    LINE linFirst,
    COL  colLast,
    LINE linLast
    ) {

    rn	rnCur;

    rnCur.flFirst.lin = linFirst;
    rnCur.flFirst.col = colFirst;
    rnCur.flLast.lin  = linLast;
    rnCur.flLast.col  = colLast;

    SetHiLite (pFileHead, rnCur, INFCOLOR);
}



/*** AdjustLines - change all information relevant to deletion/insertion of
*		   lines in a file.
*
* Purpose:
*  When we are deleting or inserting lines, there is some updating that we
*  need to do to retain some consistency in the user's view of the screen.
*  The updating consists of:
*
*      Adjusting all window instances of this window to prevent "jumping".
*      We enumerate all window instances.  If the top of the window is
*      above or inside the deleted/inserted range, do nothing.	If the top of
*      the window is below the inserted/deleted range, we modify the cursor
*      and window position to prevent the window from moving on the text
*      being viewed.
*
*      Ditto for all flip positions
*
* Input:
*  pFile       file that is being modified
*  lin	       beginning line of modification
*  clin        number of lines being inserted (> 0) or deleted (< 0)
*
* Output:
*
*************************************************************************/
void
AdjustLines (
    PFILE pFile,
    LINE  lin,
    LINE  clin
    ) {

    int 	  iWin;
    REGISTER PINS pInsTmp;

    /* walk all instances looking for one whose pFile matches
     */

    for (iWin = 0; iWin < cWin; iWin++) {
        for (pInsTmp = WININST(WinList + iWin);  pInsTmp != NULL; pInsTmp = pInsTmp->pNext) {
	    if (pInsTmp != pInsCur && pInsTmp->pFile == pFile) {
		/* adjust current position if necessary
		 */
		if (YWIN(pInsTmp) >= lin) {
		    YWIN(pInsTmp) = lmax ((LINE)0, YWIN(pInsTmp) + clin);
		    YCUR(pInsTmp) = lmax ((LINE)0, YCUR(pInsTmp) + clin);
                }
		/* adjust flip position if necessary
		 */
		if (YOLDWIN(pInsTmp) >= lin) {
		    YOLDWIN(pInsTmp) = lmax ((LINE)0, YOLDWIN(pInsTmp) + clin);
		    YOLDCUR(pInsTmp) = lmax ((LINE)0, YOLDCUR(pInsTmp) + clin);
                }
            }
        }
    }
}




/*** UpdateIf - Move the cursor position if a particlar file is displayed
*
*  Used to update the view on windows which are not necessarily the current
*  window. Examples: tying together the compile error log with the current
*  view on the source code.
*
* Input:
*  pFileChg	= pointer to the file whose display is to be updated.
*  yNew 	= New cursor line position.
*  fTop 	= cursor line should be positionned at top/bottom of the window
*
* Output:
*  Returns TRUE if on-screen and updated.
*
*************************************************************************/
flagType
UpdateIf (
    PFILE    pFileChg,
    LINE     linNew,
    flagType fTop
    ) {

    PINS     pInsCur;
    PWND     pWndFound	 = NULL;
    flagType fFound	= FALSE;

    /*
     * If this is the top file, we don't want to do anything
     */
    if (pFileChg == pFileHead) {
        return FALSE;
    }

    /*
     * Walk the window list, and check to see if the top instance (file
     * currently in view) is the one we care about. If so, update its cursor
     * and window position.
     */
    while (pWndFound = IsVispFile (pFileChg, pWndFound)) {
	if (pWndFound != pWinCur) {
	    pInsCur = WININST(pWndFound);
	    YCUR(pInsCur) = linNew;
	    XCUR(pInsCur) = 0;
	    YWIN(pInsCur) = fTop ?
			YCUR(pInsCur) :
			lmax (0L, YCUR(pInsCur) - (WINYSIZE(pWndFound)-1));
	    XWIN(pInsCur) = 0;
	    fFound = TRUE;
        }
    }

    /*
     * If any visible instances of the file were discovered above, redraw the
     * entire file, such that all windows will be updated, regardless of view.
     */
    if (fFound) {
        redraw (pFileChg, 0L, pFileChg->cLines);
    }

    return fFound;
}



/*** IsVispFile - See if pfile is visibke
*
*  Determines if a particular pFile is currently visible to the user, and
*  returns a pointer to the window first found in.
*
* Input:
*  pFile	= pFile of interest
*  pWin 	= pWin to start at, or NULL to start at begining
*
* Output:
*  Returns pWin of first window found, or NULL
*
*************************************************************************/
PWND
IsVispFile (
    PFILE           pFile,
    REGISTER PWND   pWnd
    ) {

    /*
     * If NULL starting pWnd specified, then start at first one.
     */
    if (!pWnd++) {
        pWnd = &WinList[0];
    }

    /*
     * for all remaining windows currently active, check top instance for pFile
     * of interest
     */
    for (; pWnd < &WinList[cWin]; pWnd++) {
        if (WININST(pWnd)->pFile == pFile) {
            return pWnd;
        }
    }
    return NULL;
}





/*** GetMsg - Message Retriever
*
* Purpose:
*  Get an error message from the message segment and copy it to a
*  buffer, returning a pointer to the buffer.
*
* Input:
*  iMsg 	 = Message number to get
*  pchDst	 = pointer to place to put it
*
* Output:
*  returns pDest
*
* Exceptions:
*  None
*
*************************************************************************/
char *
GetMsg (
    unsigned  iMsg,
    char     *pchDst
    ) {

    char *pch;
    WORD   i;

    for (i=0; (MsgStr[i].usMsgNo != (WORD)iMsg) && (MsgStr[i].usMsgNo != 0); i++);
    pch = MsgStr[i].pMsgTxt;

    strcpy ((char *)pchDst, pch);

    return pchDst;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\env.c ===
/*  env.c - manipulate editor environment
 *
 *  Modifications:
 *
 *	26-Nov-1991 mz	Strip off near/far
 *
 */

#include "z.h"

/*  environment - function to perform environment manipulation
 *
 *  set environment
 *  display environment
 *  perform env substitution
 *
 *  fn	sets environment
 *  meta fn does env substitution
 *
 *  noarg	    sets current line into env
 *  textarg	    sets text into env		    single ? displays env
 *  nullarg	    sets to eol into env
 *  linearg	    sets each line into env
 *  streamarg	    sets each fragment into env
 *  boxarg	    sets each fragment into env
 *
 *  meta noarg	    maps current line
 *  meta textarg    illegal
 *  meta nullarg    maps to eol
 *  meta linearg    maps each line
 *  meta streamarg  maps each fragment
 *  meta boxarg     maps each fragment
 *
 *  argData	keystroke
 *  pArg	definition of arguments
 *  fMeta	TRUE => meta was invoked
 *
 *  Returns:	TRUE if operation was successful
 *		FALSE otherwise
 */

static char *pmltl = "Mapped line %ld too long";



flagType
environment (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ){

    linebuf ebuf, ebuf1;
    LINE l;
    int ol;

    if (!fMeta) {
	/*  Perform environment modifications
	 */
        switch (pArg->argType) {

	case NOARG:
	    GetLine (pArg->arg.noarg.y, ebuf, pFileHead);
            return fSetEnv (ebuf);

	case TEXTARG:
	    strcpy ((char *) ebuf, pArg->arg.textarg.pText);
            return fSetEnv (ebuf);

	case NULLARG:
	    fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, ebuf);
            return fSetEnv (&ebuf[pArg->arg.nullarg.x]);

	case LINEARG:
	    for (l = pArg->arg.linearg.yStart; l <= pArg->arg.linearg.yEnd; l++) {
		GetLine (l, ebuf, pFileHead);
		if (!fSetEnv (ebuf)) {
		    docursor (0, l);
		    return FALSE;
                }
            }
            return TRUE;

	case BOXARG:
	    for (l = pArg->arg.boxarg.yTop; l <= pArg->arg.boxarg.yBottom; l++) {
		fInsSpace (pArg->arg.boxarg.xRight, l, 0, pFileHead, ebuf);
		ebuf[pArg->arg.boxarg.xRight+1] = 0;
		if (!fSetEnv (&ebuf[pArg->arg.boxarg.xLeft])) {
		    docursor (pArg->arg.boxarg.xLeft, l);
		    return FALSE;
                }
            }
            return TRUE;

        }
    } else {
	/*  Perform environment substitutions
	 */
        switch (pArg->argType) {

	case NOARG:
	    GetLine (pArg->arg.noarg.y, ebuf, pFileHead);
	    if (!fMapEnv (ebuf, ebuf, sizeof(ebuf))) {
		printerror (pmltl, pArg->arg.noarg.y+1);
		return FALSE;
            }
	    PutLine (pArg->arg.noarg.y, ebuf, pFileHead);
            return TRUE;

	case TEXTARG:
            return BadArg ();

	case NULLARG:
	    fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, ebuf);
	    if (!fMapEnv (&ebuf[pArg->arg.nullarg.x],
			  &ebuf[pArg->arg.nullarg.x],
			  sizeof(ebuf) - pArg->arg.nullarg.x)) {
		printerror (pmltl, pArg->arg.nullarg.y+1);
		return FALSE;
            }
	    PutLine (pArg->arg.nullarg.y, ebuf, pFileHead);
            return TRUE;

	case LINEARG:
	    for (l = pArg->arg.linearg.yStart; l <= pArg->arg.linearg.yEnd; l++) {
		GetLine (l, ebuf, pFileHead);
		if (!fMapEnv (ebuf, ebuf, sizeof (ebuf))) {
		    printerror (pmltl, l+1);
		    docursor (0, l);
		    return FALSE;
                }
		PutLine (l, ebuf, pFileHead);
            }
            return TRUE;

	case BOXARG:
	    for (l = pArg->arg.boxarg.yTop; l <= pArg->arg.boxarg.yBottom; l++) {
		fInsSpace (pArg->arg.boxarg.xRight, l, 0, pFileHead, ebuf);
		ol = pArg->arg.boxarg.xRight + 1 - pArg->arg.boxarg.xLeft;
		memmove ( ebuf1, &ebuf[pArg->arg.boxarg.xLeft], ol);
		ebuf1[ol] = 0;
		if (!fMapEnv (ebuf1, ebuf1, sizeof (ebuf1)) ||
		    strlen (ebuf1) + strlen (ebuf) - ol >= sizeof (ebuf)) {
		    printerror (pmltl, l+1);
		    docursor (0, l);
		    return FALSE;
                }
		strcat (ebuf1, &ebuf[pArg->arg.boxarg.xRight + 1]);
		strcpy (&ebuf[pArg->arg.boxarg.xLeft], ebuf1);
		PutLine (l, ebuf, pFileHead);
            }
            return TRUE;

        }
    }

    return FALSE;
    argData;
}




/*  fMapEnv - perform environment substitutions
 *
 *  pSrc	character pointer to pattern string
 *  pDst	character pointer to destination buffer
 *  cbDst	amount of space in destination
 *
 *  Returns	TRUE if successful substitution
 *		FALSE if length overflow
 */
flagType
fMapEnv (
    char *pSrc,
    char *pDst,
    int cbDst
    ) {

    buffer tmp;
    char *pTmp, *p, *pEnd, *pEnv;
    int l;

    /*	when we find a $()-surrounded token, we'll null-terminate it using p
     *	and attempt to find it in the environment.  If we find it, we replace
     *	it.  If we don't find it, we drop it out.
     */

    pTmp = tmp;
    pEnd = pTmp + cbDst;

    while (*pSrc  != 0) {
    if (pSrc[0] == '$' && pSrc[1] == '(' && *(p = strbscan (pSrc + 2, ")")) != '\0') {
            *p = '\0';
            //pEnv = getenv(pSrc + 2);
            pEnv = getenvOem(pSrc + 2);
	    *p = ')';
            if (pEnv != NULL) {
                if ((l = strlen (pEnv)) + pTmp > pEnd) {
                    free(pEnv);
		    return FALSE;
                } else {
		    strcpy (pTmp, pEnv);
		    pTmp += l;
                }
                free(pEnv);
            }
	    pSrc = p + 1;
	    continue;
        }
        if (pTmp > pEnd) {
	    return FALSE;
        } else {
            *pTmp++ = *pSrc++;
        }
    }
    *pTmp = '\0';
    strcpy (pDst, tmp);
    return TRUE;
}




/*  fSetEnv - take some text and set it in the environment
 *
 *  We ignore leading/trailing blanks.	"VAR=blah" is done with quotes removed.
 *
 *  p		character pointer to text
 *
 *  returns	TRUE if successfully set
 *		FALSE otherwise
 */
flagType
fSetEnv (
    char *p
    ){
    char *p1;

    p = whiteskip (p);
    RemoveTrailSpace (p);
    /*	Handle quoting
     */
    p1 = strend (p) - 1;

    if (strlen (p) > 2 && *p == '"' && *p1 == '"') {
	p++;
	*p1 = 0;
    }

    if (!strcmp (p, "?")) {
	AutoSave ();
	return fChangeFile (FALSE, "<environment>");
    }

    if ((p = ZMakeStr (p)) == NULL) {
        return FALSE;
    }

//    if (putenv (p)) {
    if (putenvOem (p)) {
        FREE (p);
	return FALSE;
    }

    FREE (p);
    return TRUE;
}




/*  showenv - dump the environment into a file
 *
 *  pFile	file where output goes
 */
void
showenv (
    PFILE pFile
    ){

    int i;

    DelFile (pFile, FALSE);
    for (i = 0; environ[i] != NULL; i++) {
        AppFile (environ[i], pFile);
    }
    RSETFLAG (FLAGS(pFile), DIRTY);
    SETFLAG (FLAGS(pFile), READONLY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\cursor.c ===
/*** cursor.c -  cursor movement functions
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"

void
GetTextCursor (
    COL  *px,
    LINE *py
    ) {
    *px = XCUR(pInsCur);
    *py = YCUR(pInsCur);
}


/*** docursor/cursorfl - Move cursor to new location, adjust windows as needed
*
* Purpose:
*
*   This moves the cursor to a new file position in the current file.
*   If this position is not visible, the current window is readjusted.
*   The rules for vertical adjustment are:
*
*	If the new location is within 'vscroll' lines of the current
*	window, scroll by vscroll lines in the appropriate direction.
*
*	If the new location is further away, adjust the window so that
*	the new location is 'hike' lines from the top.
*
*   The rules for horizontal adjustment is:
*
*	If the new location is within 'hscroll' lines of the current
*	window, scroll by hscroll lines in the appropriate direction
*
*	If the new location is further away, adjust the window so that
*	the new location is 'hscroll' lines from the edge that's in
*	the direction we moved.
*
*   cursorfl is the same as docursor, but takes an fl instead.
*
*   if realtabs is on, cursor is snapped to right hand column of underlying
*   tab characters.
*
* Input:
*  x		- new file column   (docursor only)
*  y		- new file line     (docursor only)
*  fl		- new file position (cursorfl only)
*
* Globals:
*  pWinCur	- Window and
*  pInsCur	-	     file to operate in.
*
* Output:
*   Returns nothing
*
*************************************************************************/
void
docursor (
    COL  x,
    LINE y
    ) {

    fl  fl;

    fl.col = x;
    fl.lin = y;
    cursorfl(fl);
}


void
cursorfl (
    fl  flParam
    ) {
    fl	flNew;			/* New cursor position, window relative */
    fl	flWin;			/* Window position after adjustments	*/
    sl	slScroll;		/* h & vscroll, scaled to window size	*/
    linebuf	buf;

    flParam.col = max( 0, flParam.col );
	flParam.lin = lmax( (LINE)0, flParam.lin );

	/*
     * if real tabs are on, snap to right of any tab we might be over
     */
    if (fRealTabs && fTabAlign) {
        GetLine (flParam.lin, buf, pFileHead);
        if (flParam.col < cbLog(buf)) {
            flParam.col = AlignChar (flParam.col, buf);
        }
    }

    slScroll.col = XSCALE (hscroll);
    slScroll.lin = YSCALE (vscroll);

    flWin = pInsCur->flWindow;

    /* Check for horizontal window adjustments                      */

    flNew.col = flParam.col - flWin.col;
    if (flNew.col < 0) {            /* We went off the left edge    */
        flWin.col -= slScroll.col;
        if (flNew.col < -slScroll.col) { /* One hscroll wont do it    */
            flWin.col += flNew.col + 1;
        }
    } else if (flNew.col >= WINXSIZE(pWinCur)) {   /* off the right edge   */
        flWin.col += slScroll.col;
        if (flNew.col >= WINXSIZE(pWinCur) + slScroll.col) {  /* ...more than hscroll */
            flWin.col += flNew.col - WINXSIZE(pWinCur);
        }
    }

    /* Check for vertical window adjustments                        */

	flNew.lin = flParam.lin - flWin.lin;					/* Too far off, use hike		*/

	if (flNew.lin < -slScroll.lin || flNew.lin >= WINYSIZE(pWinCur) + slScroll.lin) {

        flWin.lin = flParam.lin - YSCALE(hike);
    } else if (flNew.lin < 0) {                      /* Off the top                  */
        flWin.lin -= slScroll.lin;
    } else if (flNew.lin >= WINYSIZE(pWinCur)) {     /* Off the bottom               */
        flWin.lin += slScroll.lin;
    }

    flWin.col = max (0, flWin.col);         /* Can't move window beyond 0   */
    flWin.lin = lmax ((LINE)0, flWin.lin);

    doscreen (flWin.col, flWin.lin, flParam.col, flParam.lin);
}

/*** doscreen - update screen window and cursor locations
*
* Purpose:
*  Performs reasonable bounds checking on the input parameters, and sets the
*  window position and cursor location to values which are legal
*  approximiations for out of range values.
*
* Input:
*  wx,wy	= Proposed new window position (top left corner of screen)
*  cx,cy	= Proposed new cursor position
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
doscreen(
    REGISTER COL  wx,
    REGISTER LINE wy,
    COL  cx,
    LINE cy
    ) {

    COL dx;
    LINE dy, yOld;
    LINE First, Last;

    /*
     * limit window x position to somewhere near our max line length
     * limit window y position to last line of the file (only if we know the
     * length)
     */
    wx =  max( 0, min( wx, (COL)sizeof(linebuf)-(WINXSIZE(pWinCur) - XSCALE (hscroll))));
    wy = lmax( (LINE)0, TESTFLAG (pFileHead->flags, REAL) ? lmin( wy, pFileHead->cLines - 1 ) : wy );

    /*
     * dx,dy is window movement delta, if a change, save it.
     */
    dx = wx - XWIN(pInsCur);
    dy = wy - YWIN(pInsCur);

    if ( dx || dy ) {
        saveflip ();


        if ( dy > 0 ) {

            First = YWIN(pInsCur) + WINYSIZE(pWinCur);
            Last  = YWIN(pInsCur) + WINYSIZE(pWinCur) + dy;

        } else {

            First = YWIN(pInsCur) + dy;
            Last  = YWIN(pInsCur);
        }
    }

    XCUR(pInsCur) =  min (max( wx, min( cx, wx+WINXSIZE(pWinCur)-1 ) ), sizeof(linebuf)-2);
    yOld = YCUR(pInsCur);
    YCUR(pInsCur) = lmax( wy, lmin( cy, wy+WINYSIZE(pWinCur)-1 ) );
    AckMove (yOld, YCUR(pInsCur));
    XWIN(pInsCur) = wx;
    YWIN(pInsCur) = wy;

    if ( dx || dy ) {
        SETFLAG (fDisplay, RSTATUS);

	//  If we're not in a macro and it makes sense to scroll quickly
	//  do it

	if ( !mtest () && dy  && !fInSelection &&
            (Last < pFileHead->cLines-1) && (abs(dy) < WINYSIZE(pWinCur)) ) {


	    consoleSetAttribute( ZScreen, fgColor );
	    consoleScrollVert( ZScreen, WINYPOS(pWinCur), WINXPOS(pWinCur),
			       WINYPOS(pWinCur)+WINYSIZE(pWinCur)-1,
			       WINXPOS(pWinCur)+WINXSIZE(pWinCur)-1, dy  );

	    //	We've scrolled the window.  However, the update state in
	    //	fChange[] is out of date.  We need to scroll it in parallel
	    //	However, since the fChange array is for the SCREEN and not
	    //	for the window, we can't simply SCROLL it.  Perhaps, one day,
	    //	we can make it per-window but for now, we just force
	    //	a synchronous update which can be ugly in a macro.

            redraw( pFileHead, First, Last);
	    DoDisplay ();

        } else {
            newwindow ();
        }
    }
    SETFLAG (fDisplay, RCURSOR);
}


/*** dobol - returns column position of first non-blank character
*
* Input:
*  none
*
* Global:
*  pInsCur	- Current instance
*  pFileHead	- Current file
*
* Output:
*  Returns column of first non-blank character
*
*************************************************************************/
int
dobol (
    void
    ) {

    REGISTER char *p = buf;

    GetLine (YCUR(pInsCur), p, pFileHead);
    return colPhys (p, (whiteskip (p)));
}

int
doeol (
    void
    ) {
    return LineLength (YCUR(pInsCur), pFileHead);
}


/*** doftab - tab function
*
*  Moves the cursor ahead one tab stop. If realtabs and tab align are on,
*  moves to first tab stop off of the current character.
*
* Input:
*  col	    = current column
*
* Output:
*  Returns new column
*
*************************************************************************/
int
doftab (
    int     col
    ) {
    REGISTER int newcol;

    if (tabstops) {
        newcol = col + tabstops - (col%tabstops);

        if (fRealTabs && fTabAlign) {
            linebuf buf;

            GetLine (YCUR(pInsCur), buf, pFileHead);
            while (col >= AlignChar(newcol,buf))
            newcol += tabstops;
	}
        return newcol;
    } else {
        return col;
    }
}


int
dobtab (
    REGISTER int col
    ) {
    return col - (tabstops ? (1 + (col-1)%tabstops) : 0);
}


flagType
left (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    int x = XCUR(pInsCur);

    docursor(fMeta ? XWIN(pInsCur) :  XCUR(pInsCur)-1, YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
right (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    linebuf  buf;

    if (fMeta) {
	docursor (XWIN(pInsCur)+WINXSIZE(pWinCur)-1, YCUR(pInsCur));
    } else if (fRealTabs && fTabAlign) {
	GetLine (YCUR(pInsCur), buf, pFileHead);
	docursor(colPhys(buf, pLog(buf,XCUR(pInsCur),FALSE)+1), YCUR(pInsCur));
    } else {
        docursor (XCUR(pInsCur)+1, YCUR(pInsCur));
    }
    return (flagType)(XCUR(pInsCur) < LineLength (YCUR(pInsCur), pFileHead));

    argData; pArg;
}



flagType
up (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {


    LINE	    y = YCUR(pInsCur);
    LINE	    LinesUp = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more up keys and add them up.
    //	Do this only if NOT in a macro
    //

    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x110)
		LinesUp++;
	    else
	    if (KeyInfo.KeyCode == 0x111 && LinesUp > 0)
		LinesUp--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }

    while ( LinesUp-- )
	docursor (XCUR(pInsCur), fMeta ? YWIN(pInsCur) : YCUR(pInsCur)-1 );

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg;
}



flagType
down (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    LinesDown = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more up keys and add them up.
    //	Do this only if NOT in a macro
    //
    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x111)
		LinesDown++;
	    else
	    if (KeyInfo.KeyCode == 0x110 && LinesDown > 0)
		LinesDown--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }

    while ( LinesDown--)
	docursor (XCUR(pInsCur), fMeta ? YWIN(pInsCur)+WINYSIZE(pWinCur)-1 : YCUR(pInsCur)+1);

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg;
}



flagType
begline (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (fMeta ? 0 : dobol(), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
endline (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (fMeta ? WINXSIZE(pWinCur) : doeol(), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
home (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;

    if (fMeta) {
	docursor (XWIN(pInsCur)+WINXSIZE(pWinCur)-1,
		  YWIN(pInsCur)+WINYSIZE(pWinCur)-1 );
    } else {
        cursorfl (pInsCur->flWindow);
    }
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));
    argData; pArg;  fMeta;
}



flagType
tab (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor( doftab( XCUR(pInsCur)), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg; fMeta;
}



flagType
backtab (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (dobtab (XCUR(pInsCur)), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg; fMeta;
}



flagType
fIsBlank (
    PFILE pFile,
    LINE line
    ) {
    linebuf buf;

    return (flagType)(gettextline (TRUE, line, buf, pFile, ' ') == 0
		      || (*whiteskip (buf) == 0));
}



/*  ppara - move cursor forward by paragraphs
 *
 *  <ppara> moves forward to the beginning of the next paragraph.  This
 *  is defined as moving to line i where line i-1 is blank, line i
 *  is non-blank and line i is after the one the cursor is on.	If we are
 *  beyond end-of-file, the cursor is not moved.
 *
 *  <meta><ppara> moves forward to the first blank line beyond the current/
 *  next paragraph.  This is defined as moving to line i where line i-1 is
 *  non-blank, line i is blank and line i is after the one the cursor is on.
 *  If we are beyond end-of-file, the cursor is not moved.
 */
flagType
ppara (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    LINE y;
    LINE y1 = YCUR(pInsCur);

    if (YCUR(pInsCur) >= pFileHead->cLines) {
        return FALSE;
    }

    if (!fMeta) {
        for (y = YCUR(pInsCur) + 1; y < pFileHead->cLines; y++) {
            if (fIsBlank (pFileHead, y-1) && !fIsBlank (pFileHead, y)) {
                break;
            }
        }
    } else {
        for (y = YCUR(pInsCur) + 1; y < pFileHead->cLines; y++) {
            if (!fIsBlank (pFileHead, y-1) && fIsBlank (pFileHead, y)) {
                break;
            }
        }
    }

    docursor (0, y);
    return (flagType)(y1 != YCUR(pInsCur));

    argData; pArg;
}




/*  mpara - move cursor backward by paragraphs
 *
 *  <mpara> moves backward to the beginning of the previous paragraph.	This
 *  is defined as moving to line i where line i-1 is blank, line i
 *  is non-blank and line i is before the one the cursor is on.  If we are
 *  at the beginning of the file, the cursor is not moved.
 *
 *  <meta><mpara> moves backward to the first blank line before the current/
 *  next paragraph.  This is defined as moving to line i where line i-1 is
 *  non-blank, line i is blank and line i is before the one the cursor is on.
 *  If we are at the beginning of the file, the cursor is not moved.
 */
flagType
mpara (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    LINE y;
    LINE y1 = YCUR(pInsCur);

    if (YCUR(pInsCur) == 0) {
        return FALSE;
    }

    if (!fMeta) {
        for (y = YCUR(pInsCur) - 1; y > 0; y--) {
            if (fIsBlank (pFileHead, y-1) && !fIsBlank (pFileHead, y)) {
                break;
            }
        }
    } else {
        for (y = YCUR(pInsCur) - 1; y > 0; y--) {
            if (!fIsBlank (pFileHead, y-1) && fIsBlank (pFileHead, y)) {
                break;
            }
        }
    }

    docursor (0, y);
    return (flagType)(y1 != YCUR(pInsCur));

    argData; pArg;
}



/*** ppage - moves the cursor down by pages
*
* Purpose: <ppage> moves the cursor one page forward. The size of the
*	    page is actually the vertical size of the current window.
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at end
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/

flagType
ppage (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    PagesDown = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more  keys and add them up.
    //	Do this only if NOT in a macro
    //

    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x113)
		PagesDown++;
	    else
	    if (KeyInfo.KeyCode == 0x112 && PagesDown > 0)
		PagesDown--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }


    if (PagesDown > 0)
	doscreen (XWIN(pInsCur), YWIN(pInsCur)+(PagesDown * WINYSIZE(pWinCur)),
		  XCUR(pInsCur), YCUR(pInsCur)+(PagesDown * WINYSIZE(pWinCur)) );

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg; fMeta;
}



/*** mppage - moves the cursor up page by page
*
* Purpose: <mpage> moves the cursor one page backwards. The size of the
*	    page is actually the vertical size of the current window.
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at top
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
mpage (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    PagesUp = 1;
    KBDKEY	    Key;
    EDITOR_KEY	KeyInfo;

    //
    //	Check if there are more  keys and add them up.
    //	Do this only if NOT in a macro
    //
    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x112)
		PagesUp++;
	    else
	    if (KeyInfo.KeyCode == 0x113 && PagesUp > 0)
		PagesUp--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }


    if (PagesUp > 0)
	doscreen (XWIN(pInsCur), YWIN(pInsCur)-(PagesUp * WINYSIZE(pWinCur)),
		  XCUR(pInsCur), YCUR(pInsCur)-(PagesUp * WINYSIZE(pWinCur)));

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg; fMeta;
}



/*** endfile - Sets the cursor at end of file
*
* Purpose:
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at end
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
endfile (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;
    doscreen (0, pFileHead->cLines - YSCALE (hike), 0, pFileHead->cLines );
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));

    argData; pArg; fMeta;
}



/*** begfile - Sets the cursor at top of file
*
* Purpose:
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at top
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
begfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;
    doscreen( 0, (LINE)0, 0, (LINE)0 );
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));

    argData; pArg; fMeta;
}


flagType
savecur (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    pInsCur->flSaveWin = pInsCur->flWindow;
    pInsCur->flSaveCur = pInsCur->flCursorCur;
    return pInsCur->fSaved = TRUE;

    argData; pArg; fMeta;
}



flagType
restcur (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    if (pInsCur->fSaved) {
	pInsCur->flWindow = pInsCur->flSaveWin;
	pInsCur->flCursorCur = pInsCur->flSaveCur;
	pInsCur->fSaved = FALSE;
        SETFLAG (fDisplay, RSTATUS | RCURSOR);
	newwindow ();
	return TRUE;
    } else {
        return FALSE;
    }

    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\event.c ===
/*** event.c - handle events for z extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "z.h"

EVT *pEVTHead	    = NULL;	    /* head of event chain	    */


/*** DeclareEvent - post the ocurrance of an event, and pass message
*
* Called by the various pieces of code that actualy detect event ocurrance,
* this routine traverses the event handler list, and invokes the event handler
* for each with matching criteria.
*
* event 	- Event Type.
* pargs 	- Pointer to any args to be passed to the handling routine
*
* Returns	- TRUE if the event has been consumed, and should be further
*		  ignored by the caller. Else FALSE.
*
*************************************************************************/
flagType
DeclareEvent (
    unsigned event,
    EVTargs *pargs
    ) {

    EVT *pEVTCur;

    //
    // For each in chain, if:
    //      - event type matches
    //      - focus is not specified, (all files) or matches the current focus
    //      - if it's a keyboard event, either no key was specified, or the
    //        matching key was specified
    // then we invoke the handler.
    //
    for (pEVTCur = pEVTHead; pEVTCur; pEVTCur = pEVTCur->pEVTNext) {
	assert (pEVTCur->pEVTNext != pEVTCur);
        if (pEVTCur->evtType != event) {
            //
            //  Skip events that don't match
            //
        } else if (pEVTCur->focus != NULL && pEVTCur->focus != pFileHead) {
            //
            //  Skip events that aren't for this file
            //
        } else if ((event == EVT_KEY || event == EVT_RAWKEY) &&
            pEVTCur->arg.arg.key.LongData != 0 && pEVTCur->arg.arg.key.LongData != pargs->arg.key.LongData) {
            //
            //  Skip events that don't match keystrokes
            //
        } else if (pEVTCur->func (pargs) != 0) {
            //
            //  Event handler eats event, don't propogate it
            //
            return TRUE;
        }
    }
    return FALSE;
}




/* RegisterEvent - Register Event handler
 *
 * Called by the extension that wishes to recieve event notification. Just
 * places ptr at head of list.
 *
 * pEVTDef	- Pointer to Event Definition struct.
 *
 */
void
RegisterEvent (
    EVT *pEVTDef
    ) {
    pEVTDef->pEVTNext = pEVTHead;
    pEVTHead = pEVTDef;
}



/* DeRegisterEvent - DeRegister Event handler
 *
 * Called by the extension that wishes to stop recieving event notification.
 * Just removes struct from list.
 *
 * pEVTDef	- Pointer to Event Definition struct.
 *
 */
void
DeRegisterEvent (
    EVT *pEVTDef
    ) {

    EVT *pEVTCur;

    if (pEVTHead) {
        if (pEVTHead == pEVTDef) {
	    pEVTHead = pEVTDef->pEVTNext;
        } else {
	    for (pEVTCur=pEVTHead; pEVTCur; pEVTCur=pEVTCur->pEVTNext) {
		if (pEVTCur->pEVTNext == pEVTDef) {
		    pEVTCur->pEVTNext = pEVTDef->pEVTNext;
		    break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\file.c ===
/*** file.c - file management
*
*   The internal file structure uses a combination of local memory
*   (managed by LMAlloc and free) and virtual memory (managed by malloc/ffree
*   and (pb|VA)To(pb|VA)).
*
*   We maintain one record for each file that Z has "in memory".  If a file
*   appears in multiple windows, there is only one record for that file.
*   Each window is treated as a separate instance of the editor, with a
*   separate record for each file that is present in that window.
*
*   Graphically, this appears as follows:
*
*    WinList (set of windows on the screen) 0 ... cWin-1
*   +---------------+---------------+---------------+---------------+
*   |   Window 1    |   Window 2    |   Window 3    |   Window 4    |
*   |               |               |               |               |
*   |windowType     |               |               |               |
*   |               |               |               |               |
*   |pInstance-+    |pInstance-+    |pInstance-+    |pInstance-+    |
*   +----------|----+----------|----+----------|----+----------|----+
*              |               v               v               |
*              v              ...             ...              v
*     +-------------+          pFileHead              +-------------+
*     |instanceType |              |                  |instanceType |
*     |             |   +----------+-----------+      |             |
*   +--pNext        |   |          v           |    +--pNext        |
*   | |pFile------------+   +-------------+    |    | |pFile        |
*   | +-------------+       |fileType     |    |    | +-------------+
*   |                       |             |    |    |
*   +------+              +--pFileNext    |    |    +------+
*          |           +-----pName        |    |           |
*          v           |  | +-------------+    |           v
*     +-------------+  |  |                    |      +-------------+
*     |instanceType |  |  |                    |      |instanceType |
*     |             |  |  |                    |      |             |
*   +--pNext        |  |  +--------+           |    +--pNext        |
*   | |pFile----+   |  |           |           +-------pFile        |
*   | +---------|---+  |           v                | +-------------+
*   |           |      |    +-------------+         |
*   +------+    v      |    |fileType     |         +------+
*          |   ...     |    |             |                |
*          v           |  +--pFileNext    |                v
*         ...          |  | |pName        |               ...
*          +-----------+  | +-------------+
*          |              |
*          v              |
*       +--------+        |
*       |filename|        +--------+
*       +--------+                 |
*                                  v
*                                 ...
*
*   Modifications:
*
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/

#include "z.h"

#define DIRTY       0x01                /* file had been modified       */
#define FAKE        0x02                /* file is a pseudo file        */
#define REAL        0x04                /* file has been read from disk */
#define DOSFILE     0x08                /* file has CR-LF               */
#define TEMP        0x10                /* file is a temp file          */
#define NEW         0x20                /* file has been created by editor*/
#define REFRESH     0x40                /* file needs to be refreshed   */
#define READONLY    0x80                /* file may not be editted      */



#define DEBFLAG FILEIO

/*** AutoSave - take current file and write it out if necessary
*
* AutoSave is called when it makes sense to be paranoid about saving the
* file.  We save the file only when autosaving is enabled and when the
* file is real and dirty.
*
* Input:
*  none
*
* Output:
*  none
*
*************************************************************************/
void
AutoSave (
    void
    ) {
    AutoSaveFile (pFileHead);
}


/*** AutoSaveFile - AutoSave a specific file
*
* Called when it makes sense to be paranoid about saving a specific file. We
* save the file only when autosaving is enabled and when the file is real and
* dirty.
*
* Input:
*  pFile        = File to be autosaved
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
AutoSaveFile (
    PFILE   pFile
    ) {
    if (fAutoSave && (FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
        fSyncFile (pFile, TRUE);
        FileWrite (NULL, pFile);
    }
}



/*  GetFileTypeName - return the text corresponding to the file type
 *
 *  GetFileTypeName takes the file type as set in the file structure of the
 *  current file and returns the textual string corresponding to that type.
 *
 *  returns         character pointer to the type-specific text
 */
char *
GetFileTypeName (
    void
    ) {
    if (TESTFLAG (FLAGS (pFileHead),FAKE)) {
        return "pseudo";
    }
    return mpTypepName[FTYPE (pFileHead)];
}



/*  SetFileType - set the file type of a file based upon its extension
 *
 *  pFile           pointer to file whose type will be determined
 */
void
SetFileType (
    PFILE pFile
    ) {
    pathbuf fext;
    REGISTER int i;

    extention (pFile->pName, fext);

    for (i = 0; ftypetbl[i].ext; i++) {
        if (!strcmp (ftypetbl[i].ext, (char *)&fext[1])) {
            break;
        }
    }

    FTYPE(pFile) = ftypetbl[i].ftype;
}




/*  fChangeFile  - change the current file, drive or directory.  We form the
 *  canonicalized name and attempt to find it in our internal list.  If
 *  present, then things are simple:  relink it to the head of the current
 *  window instance set.  If not present, then we need to read it in.
 *
 *  The actual algorithm is much simpler:
 *
 *      If file not in file list then
 *          create new entry in file list
 *      Find file in file list
 *      If file not in window instance list then
 *          add file to top of window instance list
 *      while files in window instance list do
 *          select top file
 *          if file is in memory then
 *              change succeeded
 *          else
 *          if read in succeeds then
 *              change succeeded
 *          pop off top file
 *      change failed
 *
 *
 *  fShort      TRUE => allow searching for short names
 *  name        name of file.
 *
 *  Returns:    TRUE if change succeeded
 *              FALSE otherwise
 */
flagType
fChangeFile (
    flagType  fShort,
    char      *name
    ) {

    PFILE    pFileTmp;
    pathbuf  bufCanon;
    flagType fRead;
    char     *p;

    //
    // If they explicitly specified .\ skip shortname checks
    //
    if (name[0] == '.' && name[1] == '\\') {
        fShort = FALSE;
        }

    //
    //  Turn file name into canonical form
    //

    if (!CanonFilename (name, bufCanon)) {

        //
        // We may have failed because a drive or directory
        // went away.  If the file named is on the file
        // list, we remove it.
        //

        printerror ("Cannot access %s - %s", name, error () );

        pFileTmp = FileNameToHandle (name, (fShort && fShortNames) ? name : NULL);
        if (pFileTmp != NULL) {
            RemoveFile (pFileTmp);
        }

        return FALSE;
    }

    //
    //  name     has the input name
    //  bufCanon has the full "real" name
    //
    //  Check to see if the file is in the current file set
    //

    pFileTmp = FileNameToHandle (bufCanon, (fShort && fShortNames) ? name : NULL);

    if (pFileTmp == NULL) {

        //
        //  File not loaded.  If it is a directory, change to it
        //

        if (strlen (bufCanon) == 2 && bufCanon[1] == ':') {
            bufCanon[2] = '\\';
        }

        if (_chdir (bufCanon) != -1) {
            domessage ("Changed directory to %s", bufCanon);
            return TRUE;
        }

        //
        //  Must be a file.  Create a new internal file for it
        //
        pFileTmp = AddFile (bufCanon);
    }

    //
    //  Bring the found file to the top of the MRU list
    //

    pFileToTop (pFileTmp);

    //
    // if the file is not currently in memory, read it in
    //
    domessage (NULL);

    if (((FLAGS (pFileHead) & (REAL|REFRESH)) == REAL)
        || (fRead = FileRead (pFileHead->pName, pFileHead, TRUE))) {

        //  If we just read in the file AND the file is new then
        //  reset cached location to TOF.
        //
        if (fRead && TESTFLAG (FLAGS (pFileHead), NEW)) {
            YCUR(pInsCur) = 0;
            XCUR(pInsCur) = 0;
        }
        fSyncFile (pFileHead, TRUE);
        cursorfl (pInsCur->flCursorCur);
        fInitFileMac (pFileHead);

        //
        //  Set the window's title
        //
        p = pFileHead->pName + strlen(pFileHead->pName);
        while ( p > pFileHead->pName && *p != '\\' ) {
            p--;
        }
        if ( *p == '\\' ) {
            p++;
        }
        sprintf( bufCanon, "%s - %s", pOrigTitle, p );
        SetConsoleTitle( bufCanon );
        return TRUE;
    }

    // The file was not successfully read in.  Remove this instance and
    // return the indicated error.
    //
    RemoveTop ();

    return FALSE;
}




/*** fInitFileMac - Initialize macros associated with a file
*
*  Sets the curfile family of macros, and attempts to read any extension-
*  specific section from tools.ini.
*
* Input:
*  pFileNew     = File to set information for
*
* Output:
*  Returns TRUE if TOOLS.INI section found, else FALSE
*
*************************************************************************/
flagType
fInitFileMac (
    PFILE   pFileNew
    ) {

    char  fbuf[ 512 ];

    strcpy (fbuf, pFileNew->pName);
    FmtAssign ("curFile:=\"%s\"", DoubleSlashes (fbuf));

    filename (pFileNew->pName, fbuf);
    FmtAssign ("curFileNam:=\"%s\"", fbuf);

    if (!extention (pFileNew->pName, fbuf)) {
        fbuf[0] = '.';
        fbuf[1] = '\0';
    }
    FmtAssign ("curFileExt:=\"%s\"", fbuf);

    return InitExt (fbuf);
}




/*  AddFile - create a named file buffer
 *
 *  Create and initialize a named buffer.  The contents are initially
 *  empty.
 *
 *  p           character pointer to name
 *
 *  returns     file handle to internal file structure
 */
PFILE
AddFile (
    char *p
    ) {

    PFILE pFileTmp;
    PFILE pFileSrch;

#ifdef DEBUG
    /*
     * assert we're not attempting to add a duplicate entry
     */
    for (pFileTmp = pFileHead;
         pFileTmp != NULL;
         pFileTmp = pFileTmp->pFileNext) {

        assert (_stricmp ((char *)(pFileTmp->pName), p));
    }
#endif

    pFileTmp = (PFILE) ZEROMALLOC (sizeof (*pFileTmp));
#ifdef DEBUG
    pFileTmp->id = ID_PFILE;
#endif
    pFileTmp->pName = ZMakeStr (p);

    /*
     * Everything that we explicitly set NULL, we can assume, as LMAlloc init's
     * the allocated PFILE to all nulls.
     *
     *  pFileTmp->pFileNext = NULL;
     *  pFileTmp->cLines = 0;
     *  pFileTmp->refCount = 0;
     *  FLAGS(pFileTmp) = FALSE;
     *  pFileTmp->cUndo = 0;
     */
    pFileTmp->plr      = NULL;
    pFileTmp->pbFile   = NULL;
    pFileTmp->vaColor  = (PVOID)(-1L);
    pFileTmp->vaHiLite = (PVOID)(-1L);
        pFileTmp->vaMarks  = NULL;
    pFileTmp->vaUndoCur = pFileTmp->vaUndoHead = pFileTmp->vaUndoTail = (PVOID)(-1L);

    CreateUndoList (pFileTmp);
    /*
     * Place the file at the end of the pFile list
     */
    if (pFileHead == NULL) {
        pFileHead = pFileTmp;
    } else {
        for (pFileSrch = pFileHead;
             pFileSrch->pFileNext;
             pFileSrch = pFileSrch->pFileNext) {
            ;
        }
        pFileSrch->pFileNext = pFileTmp;
    }

    SetFileType (pFileTmp);

    return pFileTmp;
}




/*  IncFileRef - note a new reference to a file
 */
void
IncFileRef (
    PFILE pFile
    ) {
    pFile -> refCount++;
}





/*  DecFileRef - remove a reference to a file
 *
 *  When the reference count goes to zero, we remove the file from the memory
 *  set
 */
void
DecFileRef (
    PFILE pFileTmp
    ) {
    if (--(pFileTmp->refCount) <= 0) {
        RemoveFile (pFileTmp);
    }
}



/*  FileNameToHandle - return handle corresponding to the file name
 *
 *  FileNameToHandle is used to locate the buffer pointer corresponding to
 *  a specified file.  Short names are allowed.  If the input name is 0-length
 *  we return the current file.
 *
 *  pName       character pointer to name being located.  Case is significant.
 *  pShortName  short name of file.  This may be NULL
 *
 *  Returns     handle to specified file (if found) or NULL.
 */
PFILE
FileNameToHandle (
    char const *pName,
    char const *pShortName
    ) {

    char const *pBaseShortName;
    char const *pFileName;
    PFILE pFileTmp;
    pathbuf nbuf;
    size_t n, o;

    if (pName[0] == 0) {
        return pFileHead;
    }

    for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext)
        if (!_stricmp (pName, pFileTmp->pName))
            return pFileTmp;

    if ( pShortName != NULL && GetFileAttributes( pName ) == -1) {
        pBaseShortName = pShortName;
        pFileName = pShortName;
        while (pFileName = strchr(pFileName, '\\')) {
            pBaseShortName = ++pFileName;
        }
        n = strlen (pBaseShortName);
        for (pFileTmp = pFileHead->pFileNext; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext) {
            if (fileext (pFileTmp->pName, nbuf) &&
                !_strnicmp (pBaseShortName, nbuf, n)) {
                n = (size_t)(pBaseShortName - pShortName);
                if (n == 0) {
                    return pFileTmp;
                }

                if (path (pFileTmp->pName, nbuf) &&
                    (o = strlen(nbuf)-n) > 0 &&
                    !_strnicmp(nbuf+o, pShortName, n)
                   ) {
                    return pFileTmp;
                }
            }
        }

        if (fileext (pFileHead->pName, nbuf) &&
            !_strnicmp (pBaseShortName, nbuf, n)) {
            return pFileHead;
        }
    }

    return NULL;
}



/*** pFileToTop - make the specified file the top of the current window
*
* Search  the instance list in the current window for the file. If it is
* found, relink it to be the top one. Otherwise, allocate a new instance for
* it  and  place it at the top of the instance list. Also bring the file to
* the top of the pFileHead file list. Ensure that it is on the list to begin
* with.
*
* Input:
*  pFileTmp     = file to bring to top
*
* OutPut:
*  Returns FALSE if the pFile is invalid or NULL
*
*************************************************************************/
flagType
pFileToTop (
    PFILE pFileTmp
    ) {

    EVTargs e;
    PINS    pInsLast        = (PINS) &pInsCur;
    PINS    pInsTmp         = pInsCur;
    PFILE   pFilePrev;

    assert (_pfilechk());
    assert (_pinschk(pInsCur));

    /*
     * if we're about to lose focus, declare it
     */
    if (pFileTmp != pFileHead) {
        e.pfile = pFileHead;
        DeclareEvent (EVT_LOSEFOCUS,(EVTargs *)&e);
    }

    /*
     * Move file to head of file list. Ensure, at the same time, that the file
     * is in fact ON the list, and declare the event if in fact it is moved.
     */
    if (pFileTmp != pFileHead) {
        for (pFilePrev = pFileHead;
                         pFilePrev && (pFilePrev->pFileNext != pFileTmp);
             pFilePrev = pFilePrev->pFileNext ) {
            ;

        }

        if (!pFilePrev) {
            return FALSE;
        }

        pFilePrev->pFileNext = pFileTmp->pFileNext;
        pFileTmp->pFileNext = pFileHead;
        pFileHead = pFileTmp;

        e.pfile = pFileHead;
        DeclareEvent (EVT_GETFOCUS,(EVTargs *)&e);
    }

    /*
     * pFileTmp now points to a file structure for the correct file. Try to find
     * an instance of the file in the current window. If not in the instance
     * list, allocate it. If it is in the instance list, remove it.
     */
    while (pInsTmp != NULL) {
        if (pInsTmp->pFile == pFileTmp) {
            break;
        }
        pInsLast = pInsTmp;
        pInsTmp = pInsTmp->pNext;
    }

    if (pInsTmp == NULL) {
        pInsTmp = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
        pInsTmp->pFile = pFileTmp;
#ifdef DEBUG
        pInsTmp->id = ID_INSTANCE;
#endif
        IncFileRef (pFileTmp);
    } else {
        pInsLast->pNext = pInsTmp->pNext;
    }
    /*
     * Regardless, then, of where it came from, place the new instance back onto
     * the head of the list
     */
    pInsTmp->pNext = pInsCur;
    WININST(pWinCur) = pInsCur = pInsTmp;

    SETFLAG(fDisplay, RCURSOR | RSTATUS);
    newscreen ();

    return TRUE;

}



/*  RemoveTop - removes the top file in the current instance list
 *              If there is no next file, leave
 */
void
RemoveTop (
    void
    ) {
    PINS    pInsTmp = pInsCur;

    WININST(pWinCur) = pInsCur = pInsCur->pNext;
    FREE ((char *) pInsTmp);
    DecFileRef (pFileHead);
    if (pInsCur) {
        pFileToTop (pInsCur->pFile);
    }
}




/*** RemoveFile  - free up all resources attached to a particular file
*
* Purpose:
*
*   To free all memory used to keep track of a file.  If the file still
*   appears in some instance lists, it is removed from them.
*
* Input:
*
*   pFileRem - File in question
*
* Output:
*
*   Returns TRUE.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
RemoveFile (
    PFILE    pFileRem
    ) {

    PFILE pFilePrev = (PFILE) &pFileHead;
    PFILE pFileTmp = pFileHead;

    if (pFileRem->refCount > 0) {
        RemoveInstances (pFileRem);
    }

    while (pFileTmp != pFileRem) {
        pFilePrev = pFileTmp;
        pFileTmp = pFileTmp->pFileNext;
        if (pFileTmp == NULL) {
            IntError ("RemoveFile can't find file");
        }
    }


    /*
     * It's important that pFileNext be the first field in a pfile, and we assert
     * that here. This allows us to not special case pFileHead, but adjust it by
     * treating it as the pFileNext of a non-existant structure.
     */
    assert ((void *)&(pFilePrev->pFileNext) == (void *)pFilePrev);
    pFilePrev->pFileNext = pFileTmp->pFileNext;

    FreeFileVM (pFileTmp);

    FREE (pFileTmp->pName);

#if DEBUG
    pFileTmp->id = 0;
#endif

    FREE ((char *) pFileTmp);

    if (pFileTmp == pFileIni) {
        pFileIni = NULL;
    }
}



/*** RemoveInstances - Remove all instances of a file
*
* Purpose:
*
*  Used by RemoveFile to make sure that there are no file instances
*  referring to a given file
*
* Input:
*  pFile        = File in question
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
RemoveInstances (
    PFILE   pFile
    ) {

    PINS    pIns;
    PINS    pInsPrev;
    PWND    pWndCur;

    for (pWndCur = &WinList[0];
         pWndCur < &WinList[cWin];
         pWndCur++) {

        pInsPrev = NULL;
        pIns = WININST(pWndCur);
        while (pIns) {

            /*
             * assert not an infinite loop
             */
            assert (!pInsPrev || (pIns != WININST (pWndCur)));

            if (pIns->pFile == pFile) {
                if (!pInsPrev) {
                    WININST (pWndCur) = pIns->pNext;
                } else {
                    pInsPrev->pNext = pIns->pNext;
                }
                {
                    PINS pInsTmp = pIns;
                    pIns = pIns->pNext;
                    FREE(pInsTmp);
                }
            } else {
                pInsPrev = pIns;
                pIns = pIns->pNext;
            }
        }
        assert (_pinschk (WININST (pWndCur)));
    }
    //
    // If the resulting instance list for the current window becomes empty,
    // bring up the <untitled> file in it.
    //
    if (!(pInsCur = WININST (pWinCur))) {
        fChangeFile (FALSE, RGCHUNTITLED);
    }
}




/*  fSyncFile - Attempt to make logical file and physical file the same
 *
 *  When editing in a network or multi-tasking environment, we need to make
 *  sure that changes made underneath us are properly reflected to the
 *  user.  We do this by snapshotting the time-of-last-write and periodically
 *  comparing it with the version on disk.  When a mismatch is found, we
 *  prompt the user and give him the opportunity to reread the file
 *
 *  pFileLoc    file structure of interest
 *  fPrompt     TRUE => prompt user for permission to refresh, else just
 *              refresh.
 *
 *  returns     TRUE iff the logical file and the physical file are the same.
 */
flagType
fSyncFile (
    PFILE pFileLoc,
    flagType fPrompt
    ) {
    if (pFileLoc == NULL) {
        pFileLoc = pFileHead;
    }

    switch (FileStatus (pFileLoc, NULL)) {

    case FILECHANGED:
        if (!confirmx("%s has been changed.  Refresh? ", pFileLoc->pName)) {
            /* No, validate this edit session */
            SetModTime (pFileLoc);
            return FALSE;
        }

        FileRead (strcpy( buf, pFileLoc->pName ), pFileLoc, TRUE);
        RSETFLAG (FLAGS (pFileLoc), DIRTY);
        SETFLAG (fDisplay, RSTATUS);
        return TRUE;

    case FILEDELETED:
        domessage ("File has been deleted");
        break;

    default:
        break;

    }
    return TRUE;
}




/*  FileStatus - compare logical info about a file with file on disk
 *
 *  Compare the last modified time with the last snapshot.  If the filename
 *  contains metachars, the file is not believed to have changed.  Further, if
 *  the file is a pseudo file, it cannot have changed.
 *
 *  pFile       file of interest (contains mod time)
 *  pName       name of file to examine (when writing to diff. name)
 *
 *  returns     FILECHANGED if timestamps differ
 *              FILEDELETED if file on disk does not exist
 *              FILESAME    if timestamps are the same
 */
int
FileStatus (
    PFILE pFile,
    char *pName
    ){

    time_t modtime;

    if (TESTFLAG(FLAGS(pFile),FAKE)) {
        return FILESAME;
    }

    if (pName == NULL) {
        pName = pFile->pName;
    }

    if (*strbscan (pName, "?*") != 0) {
        return FILESAME;
    }

    if ((modtime = ModTime (pName)) == 0L) {
        return FILEDELETED;
    }

    if (pFile->modify != modtime) {
        return FILECHANGED;
    }

    return FILESAME;
}




/*  SetModTime - Snapshot a file's last-modification time
 *
 *  pFile       file of interest
 */
void
SetModTime (
    PFILE pFile
    ) {
    pFile->modify = ModTime (pFile->pName);
}



/*  ModTime - Return the time of last modification for a file
 *
 *  If the file does not exist or contains meta chars, return 0 as the time-
 *  stamp.
 *
 *  pName       character pointer to file name
 *
 *  Returns     last modification time of file.
 */

time_t
ModTime (
    char *pName
    ) {

    struct _stat statbuf;

    if (*strbscan (pName, "?*")) {
        return 0L;
    }

    if (_stat (pName, &statbuf) == -1) {
        return 0L;
    }

    return statbuf.st_mtime;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\fscan.c ===
/*** fscan.c - iterate a function across all characters in a file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	27-Nov-1991 mz	Strip procedure qualifiers
*
*************************************************************************/
#include "z.h"

/*** fScan - Apply (*pevent)() until it returns TRUE
*
*  Starting one character to the right of (x, y) (left for !fFor), move
*  through the file forward (backward for !fFor) and call pevent on each
*  character. Also call once at the end of each line on the '\0' character.
*
* Input:
*  flStart	- location in pFileHead at which to start scan
*  pevent	- function to call for done signal
*  fFor 	- TRUE means go forward through file, FALSE backwards
*  fWrap	- TRUE means wrap around the ends of the file, ending at the
*		  starting position. The range to be scanned (defined below)
*		  must include the appropriate start/end of the file.
*
* Globals:
*  rnScan	- Region to confine scan to.
*
*  Returns TRUE if pevent returned true for some file position FALSE if we
*  ran out of scanning region first.
*
*  During the life of fScan, the following globals are valid, and maybe
*  used by pevent:
*
*      flScan	    - Position in file pevent should look at.
*      scanbuf	    - Contents of line to be looking at.
*      scanreal     - Un-Detabbed version of same.
*      scanlen	    - Number of characters in scanbuf.
*
*  The line in scanbuf is detabbed, howver the pevent routine is called once
*  per physical character, if fRealTabs is true.
*
*************************************************************************/
flagType
fScan (
    fl      flStart,
    flagType (*pevent) (void),
    flagType fFor,
    flagType fWrap
    ) {

    LINE    yLim;                           /* limitting line for scanning  */

    flScan = flStart;

    if (!fFor) {
        /*
         * backwards scan.
         *
         * dec current column. If it steps outside of rnScan, then back up a line, and
         * set the column to the right hand column.
         */
        if (--flScan.col < rnScan.flFirst.col) {
            flScan.lin--;
            flScan.col = rnScan.flLast.col;
        }
        /*
         * While we are within the line range of rnScan, check for CTRL-C aborts, and
         * get each line.
         */
        yLim = rnScan.flFirst.lin;
        while (flScan.lin >= yLim) {
            if (fCtrlc) {
                return (flagType)!DoCancel();
            }
            scanlen = GetLine (flScan.lin, scanreal, pFileHead) ;
            scanlen = Untab (fileTab, scanreal, scanlen, scanbuf, ' ');
            /*
             * ensure that the scan column position is within range, and then for every
             * column in the rane of the current line, call the pevent routine
             */
            flScan.col = min ( (  flScan.col < 0
                                ? rnScan.flLast.col
                                : flScan.col)
                              , scanlen);

            while (flScan.col >= rnScan.flFirst.col) {
                if ((*pevent)()) {
                    return TRUE;
                }
                if (fRealTabs) {
                    flScan.col = colPhys (scanreal, (pLog (scanreal, flScan.col, TRUE) - 1));
                } else {
                    flScan.col--;
                }
            }
            /*
             * display status to user. If we just scanned to begining of file, and we are
             * to wrap, then set the new stop limit as the old start position, and set the
             * next line to be scanned as the last in the file.
             */
            noise (flScan.lin--);
            if ((flScan.lin < 0) && fWrap) {
                yLim = flStart.lin;
                flScan.lin = pFileHead->cLines - 1;
            }
        }
    } else {
        /*
         * forwards scan. Same structure as above, only in the other direction.
         */
        flScan.col++;
        yLim = rnScan.flLast.lin;
        while (flScan.lin <= yLim) {
            if (fCtrlc) {
                return (flagType)!DoCancel();
            }
            scanlen = GetLine (flScan.lin, scanreal, pFileHead);
            scanlen = Untab (fileTab, scanreal, scanlen, scanbuf, ' ');
            scanlen = min (rnScan.flLast.col, scanlen);
            while (flScan.col <= scanlen) {
                if ((*pevent)()) {
                    return TRUE;
                }
                if (fRealTabs) {
                    flScan.col = colPhys (scanreal, (pLog (scanreal, flScan.col, TRUE) + 1));
                } else {
                    flScan.col++;
                }
            }
            flScan.col = rnScan.flFirst.col;
            noise (++flScan.lin);
            if (fWrap && (flScan.lin >= pFileHead->cLines)) {
                flScan.lin = 0;
                if (flStart.lin) {
                    yLim = flStart.lin - 1;
                } else {
                    break;
                }
            }
        }
    }
    return FALSE;
}




/*** setAllScan - set maximal scan range
*
*  Sets scan range such that fScan operates on the entire file.
*
* Input:
*  fDir 	= TRUE => scan will procede forwards, else backwards
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
setAllScan (
    flagType fDir
    ) {
    rnScan.flFirst.col = 0;
    rnScan.flFirst.lin = fDir ? YCUR(pInsCur) : 0;
    rnScan.flLast.col  = sizeof(linebuf)-1;
    rnScan.flLast.lin  = pFileHead->cLines - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\fileio.c ===
/*** fileio.c - perform low-level file input and output
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#include "z.h"

int fdeleteFile( char *p );

/*  Large-buffer I/O routines
 *
 *  It is best for Z to read in data in large blocks.  The fewer times we
 *  issue system calls, the better.  The VM code has conveniently allocated
 *  us some large amount of space for us.  All we need to do is maintain
 *  a pointer to the next characters to read/write and a count of the number
 *  of characters in the buffer
 *
 *  The data structures used are:
 *
 *      char *getlbuf;
 *          This is a long pointer to the beginning of the buffer.
 *      char *getlptr;
 *          This is a long pointer to the next char position in the buffer.
 *      unsigned int getlsize;
 *          This is the length of the buffer in bytes.
 *
 *  The routines provided to access this are:
 *
 *      zputsinit ();
 *          Initializes for subsequent zputs's.
 *      zputs (buf, len, fh);
 *          Writes out from buf length len using getlbuf and fh.
 *          Returns EOF if no more room.
 *      zputsflush (fh);
 *          Flushes out the buffer.  Returns EOF if no more room.
 */

char         *getlbuf   = NULL;
char        *getlptr    = NULL;
// unsigned int    getlsize    = 0;
unsigned int    getlc       = 0;

// BUGBUG
//  FileExists is used because of problems with stat() and
//  FindFirstFile() which are not easily reproducible.
flagType FileExists (char  *path );

// BUGBUG
//  ZMove is used because FAT does not provide rename functionality
#define rename  ZMove
int ZMove ( char *oldname,   char *newname);



/*  zputsinit - initialize for future zputs's
 *
 *  Set next-char pointer to beginning.  Set count of chars to 0
 */
void
zputsinit (
    void
    )
{
    getlptr = getlbuf;
    getlc = 0;
}





/*** zputs - output a string
*
* Input:
*  p            = character pointer to data to be output
*  len          = number of bytes to output
*  fh           = DOS file handle to use
*
* Output:
*  Returns EOF if out-of-space
*
*************************************************************************/
int
zputs (
    char        *p,
    int         len,
    FILEHANDLE  fh
    )
{
    REGISTER unsigned int c;

    while (len != 0) {
        c = len;
        if (c > (unsigned)(getlsize-getlc)) {
            c = (unsigned)(getlsize-getlc);
        }
        memmove (getlptr, (char*)p, c);
        len -= c;
        getlptr += c;
        getlc += c;
        p += c;
        if (getlc == getlsize) {
            if (zputsflush (fh) == EOF) {
                return EOF;
            }
        }
    }
    return !EOF;
}





/*** zputsflush - dump out buffered data
*
* Input:
*  fh           = DOS file handle to use for output
*
* Output:
*  Returns EOF if disk full
*
*************************************************************************/
int
zputsflush (
    FILEHANDLE     fh
    )
{

    ULONG   bytesWritten;

    // rjsa DosWrite (fh, getlbuf, getlc, &bytesWritten);
    bytesWritten = ZFWrite(getlbuf, getlc, fh);
    if (bytesWritten != getlc) {
        return EOF;
    }
    zputsinit ();
    return !EOF;
}





/* ReestimateLength - reestimate the length of a file based on
 * the current file position and length in bytes
 */
void
ReestimateLength (
    PFILE       pFile,
    FILEHANDLE  fh,
    long        len
    )
{
    LINE avg;

    if (pFile->cLines == 0) {
        avg = 400;
    } else {
        avg = (ZFSeek (fh, 0L, FROM_CURRENT) - getlc) / pFile->cLines;
        avg = len / avg;
    }

    growline (avg + 1, pFile);
}





/* read lines from the specified handle.
 */
LINE
readlines (
    PFILE       pFile,
    FILEHANDLE  fh
    )
{
    LINE    line        = 0;            /* line number being read in          */
    long    bufpos      = 0L;           /* position of beg of buffer in file  */
    unsigned int buflen = 0;            /* number of bytes of data in buffer  */
    long    cbFile;                     // length of file
    char    *pb;


    cbFile = ZFSeek(fh, 0L, FROM_END);

    ZFSeek (fh, 0L, FROM_BEGIN);

    pFile->pbFile = MALLOC (cbFile);

    if ( pFile->pbFile == NULL ) {
        //
        //      No heap space, cannot read file
        //
        disperr (MSGERR_NOMEM);
        return -1;
    }

    //  Assume a non-dos file until we see a CR-LF.
    RSETFLAG (FLAGS (pFile), DOSFILE);

    //  Read entire file into buffer and set up for scan
    buflen = ZFRead (pFile->pbFile, cbFile, fh);
    pb = pFile->pbFile;

    //  Loop, while there's more data to parse
    while (buflen != 0) {
        LINEREC vLine;                  // line record of current line
        REGISTER int iCharPos = 0;      // logical line length (tabs expanded)

        vLine.cbLine   = 0;
        vLine.vaLine   = (PVOID)pb;
        vLine.Malloced = FALSE;

        //  Loop, processing each character in the line
        //
        //  Special char handling is as follows:
        //  0.  Lines are broken at end of input
        //  1.  Lines are broken when they overflow line buffers
        //  2.  Lines are broken at \n's or \r\n's.
        //  3.  Lines are broken at \0's since the editor relies on asciiz
        //  4.  Embedded \r's are retained.

        while (TRUE) {
            int c;                      // char being processed

            //  if no more data, break current line.
            if (buflen == 0)
                break;

            //  if \n or \0 then eat it and break current line
            if (pb[0] == '\n' || pb[0] == '\0') {
                pb++;
                buflen--;
                break;
                }

            //  if \r\n then eat them and break current line
            if (pb[0] == '\r' && buflen > 1 && pb[1] == '\n') {
                pb += 2;
                buflen -= 2;
                SETFLAG (FLAGS (pFile), DOSFILE);
                break;
                }

            //  if no more room to expand in a buffer, break current line
            if (iCharPos >= sizeof (linebuf)-1)
                break;

            //  Get current character
            c = *pb++;
            buflen--;

            //  We have a character that we allow in the
            //  line.  Advance length of logical line.
            if (c != 0x09)
                iCharPos++;
            else {
                //  Expand a tab to the next logical position
                iCharPos += 8 - (iCharPos & 7);

                //  if the tab causes overflow in the line length
                //  back up over the tab and break the line
                if (iCharPos >= sizeof(linebuf)-1) {
                    pb--;
                    buflen++;
                    break;
                }
            }

            //  Advance length of physical line
            vLine.cbLine++;
        }

        //  If the user halted reading the file in, undo everything
        if (fCtrlc) {
            FlushInput ();
            DelFile (pFile, FALSE);
            return -1;
        }

        //  Give the user feedback about our progress
        noise (line);

        //  If we're within 10 lines of the end of the line array then
        if (line >= pFile->lSize-10) {
            LINE avg;
            //  reestimate the number of lines

            if (pFile->cLines == 0)
                //  Assume 400 lines if the file is now empty
                avg = 400;
            else {
                //  compute average line length so far
                avg = (LINE)((pb - pFile->pbFile) / pFile->cLines);

                //  extrapolate number of lines in entire file from this
                //  average
                avg = cbFile / avg;
            }
            growline (avg + 1, pFile);
        }

        if (pFile->cLines <= line) {
            growline (line+1, pFile);
            pFile->cLines = line+1;
        }

        pFile->plr[line++] = vLine;
    }

    if (line == 0)
        SETFLAG (FLAGS (pFile), DOSFILE);

    RSETFLAG (FLAGS(pFile), DIRTY);
    newscreen ();
    return line;
}





/*** FileRead - read in a file
*
*  The file structure is all set up; all that needs to be done is to fill in
*  the lines parts. We delete everything currently in the file. If the file
*  is designated as a pseudo file (first char is a <), then we go and check
*  for the specially named files. Otherwise we try to read in the file. If
*  that fails, and we can, we try to create it. If everything fails, we
*  return FALSE.
*
* Input:
*  name         = pointer to file name to read
*  pFile        = file structure to read the file into.
*  fAsk         = TRUE -> ask to create if it doesn't exist
*
* Output:
*  Returns TRUE on read in.
*  Modifies global fUserCanceledRead
*
* Notes:
*  Hack (terrible one): Under CW, FileRead sets fUserCanceledRead anytime
*  there has been an attempt to read a non existent file AND the user
*  has been prompted for file creation AND the user canceled the operation
*
*  This is used by fFileAdvance (ZEXIT.C) and ReadStateFile (STATFILE.C)
*
*************************************************************************/
flagType
FileRead (
    char    *name,
    PFILE   pFile,
    flagType fAsk
    )
{

    EVTargs     e;
    FILEHANDLE  fh;
    flagType    fNew = FALSE;
    char        *n;
    buffer      Buf;

    assert (pFile);


    e.pfile = pFile;
    e.arg.pfn = (char *)name;
    if (DeclareEvent (EVT_FILEREADSTART, (EVTargs *)&e)) {
        return TRUE;
    }

    if (!mtest ()) {
        dispmsg (MSG_NEXTFILE, name);
    }

    /* process special names */
    if (*name == '<') {
        fNew = LoadFake (name, pFile);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return fNew;
    }

    DelFile (pFile, FALSE);

    if (*strbscan (name, "?*") != 0) {
        fNew = LoadDirectory (name, pFile);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return fNew;
    }

    if ((fh = ZFOpen (name, ACCESSMODE_READ, SHAREMODE_RW, FALSE)) == NULL) {
        if (!fAsk) {
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        if (!confirmx ("%s does not exist. Create? ", name)) {
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        if ((fh = ZFOpen (name, ACCESSMODE_WRITE, SHAREMODE_RW, TRUE)) == NULL) {
            n = name;
            if ( strlen(name) > 20 ) {
                strcpy( Buf, name + strlen(name)-20);
                Buf[0] = Buf[1] = Buf[2] = '.';
                n = Buf;
            }
            disperr (MSGERR_NOCREAT, n, error ());
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        SETFLAG (FLAGS (pFile), NEW);
        fNew = TRUE;
    }

    if (fNew) {
        PutLine((LINE)0, RGCHEMPTY, pFile);
        SETFLAG (FLAGS (pFile), DOSFILE);
    } else if (readlines (pFile, fh) == -1)  {
        DoCancel();
        ZFClose (fh);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return FALSE;
    }

    ZFClose (fh);
    SETFLAG (FLAGS(pFile), REAL);
    RSETFLAG (FLAGS(pFile), READONLY);

    if (fReadOnly (name)) {
        SETFLAG (FLAGS(pFile), DISKRO);
        if (!fEditRO) {
            SETFLAG (FLAGS(pFile), READONLY);
        }
    } else {
        RSETFLAG (FLAGS(pFile), DISKRO);
    }

    SetModTime (pFile);
    CreateUndoList (pFile);
    (void)fReadMarks (pFile);

    DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);

    return TRUE;
}





/*  fReadOnly - see if a file is read-only
 *
 *  p           full name of file
 *
 *  Returns:    TRUE iff file is read only
 */
flagType
fReadOnly (
    char *p
    )
{

    DWORD   Attr;

    Attr = GetFileAttributes(p);

    if ( Attr != -1 && (Attr & FILE_ATTRIBUTE_READONLY) != 0)
        return TRUE;
    else
        return FALSE;
}


int
__cdecl
ZFormatArgs (REGISTER char * Buf, const char * Format, ...)
{
    va_list arglist;
    int result;

    va_start (arglist, Format);
    result = ZFormat (Buf, Format, arglist);
    va_end (arglist);
    return result;
}

/*** FileWrite - Write file to disk
*
*  Writes out the specified file. If no name was given then use the name
*  originally assigned to the file; else use the given name. We start by
*  writing to a temp file (extention .$). If this succeeds, we fdelete the
*  source (for undeleteability) and rename the temp to the source.
*
* Input:
*  savename     = name to save as.
*  pFile        = file to be saved
*
* Returns:
*
*************************************************************************/
flagType
FileWrite (
    char    *savename,
    PFILE   pFile
    )
{

    EVTargs     e;
    FILEHANDLE  fh;                            /* file handle for output       */
    LINE        i;
    int         len, blcnt;
    pathbuf     fullname, tmpname, buf2;
    char        linebuffer[sizeof(linebuf) + 2];
    char        *p;
    PCMD        pCmd;
    flagType    fNewName  = FALSE;
    char        *fileEOL;
    int         cbfileEOL;

    //
    //  If we are trying to save a FAKE file with a <name>,
    //  we call SaveFake for special processing.
    //

    if (TESTFLAG (FLAGS(pFile), FAKE) && !savename &&
        (pFile->pName[0] == '\0' || pFile->pName[0] == '<')) {
        return SaveFake (pFile->pName, pFile);
    }

    //
    //  get a canonical form of the output file name.  If no name was
    //  input, use the name in the file itself
    //

    if (!savename || !*savename) {
        strcpy (fullname, pFile->pName);
    } else  if (rootpath (savename, fullname)) {
        return disperr (MSGERR_OPEN, savename, "");
    }

    savename = fullname;

    //
    // See if it is a directory.  If so, we cannot save to it.
    //

    {
        DWORD att = GetFileAttributes (fullname);

        if (att != -1 && TESTFLAG (att, FILE_ATTRIBUTE_DIRECTORY))
        return disperr (MSGERR_SAVEDIR, fullname);
    }

    //
    //  If the file is read-only, display a message and let the user direct
    //  us to use the readonly program to rectify it.
    //

    if (fReadOnly (fullname)) {
        disperr (MSGERR_RONLY, fullname);
        if (ronlypgm != NULL) {
            if (strstr (ronlypgm, "%s") != NULL) {
                fileext (fullname, buf);
                sprintf (tmpname, ronlypgm, buf);
                }
            else
                ZFormatArgs (tmpname, ronlypgm, fullname);
            if (confirmx ("Invoke: \"%s\" (y/n)?", tmpname))
                drive (fullname, buf);
                path (fullname, buf+strlen(buf));
                _getcwd (buf2, sizeof(buf2));
                _chdir(buf);
                if (zspawnp (tmpname, TRUE))
                    SetModTime (pFile);
                _chdir(buf2);
            }

        //
        //  We've given the user one chance to fix the read-onlyness of the
        //  file.  We now prompt him until he gives us a writeable name or
        //  cancels.
        //
    if ( !savename || !*savename ) {
        strcpy( tmpname, pFile->pName );
    } else {
        strcpy( tmpname, savename );
    }
    //tmpname[0] = '\0';
    while (fReadOnly (fullname)) {

        pCmd = getstring (tmpname, sizeof(tmpname), "New file name: ", NULL,
                              GS_NEWLINE | GS_INITIAL | GS_KEYBOARD);

            if ( pCmd == NULL || (PVOID)pCmd->func == (PVOID)cancel)
                return FALSE;

            CanonFilename (tmpname, fullname);

            if (!TESTFLAG(FLAGS(pFile), FAKE))
                fNewName = TRUE;
            }
        }

    //
    //  fullname is the name of the file we are writing
    //

    upd (fullname, ".$", tmpname);

    //
    //  Send notification about the beginning of the write operation
    //

    e.pfile = pFile;
    e.arg.pfn = (char *)savename;
    if (DeclareEvent (EVT_FILEWRITESTART, (EVTargs *)&e))
        return TRUE;


    if (!(fh = ZFOpen(tmpname, ACCESSMODE_RW, SHAREMODE_READ, FALSE))) {
        if (!(fh = ZFOpen(tmpname, ACCESSMODE_RW, SHAREMODE_READ, TRUE))) {
            disperr (MSGERR_OPEN, tmpname, error ());
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
        }
    }

    dispmsg (MSG_SAVING, fullname);
    blcnt = 0;
    zputsinit ();
    fileEOL = TESTFLAG (FLAGS (pFile), DOSFILE) ? "\r\n" : "\n";
    cbfileEOL = strlen (fileEOL);

    for (i = 0; i < pFile->cLines; i++) {

        /*
         * always get the RAW line for output. No tab conversions here.
         */

        len = gettextline (TRUE, i, linebuffer, pFile, ' ');

        if (!mtest ()) {
            noise (i);
        }

        if (fCtrlc) {
            DoCancel();
            ZFClose (fh);
            _unlink (tmpname);
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
        }

        if (len) {
            while (blcnt--) {
                if (zputs (fileEOL, cbfileEOL, fh) == EOF) {
                    if (!fCtrlc) {
                        disperr (MSGERR_SPACE, tmpname);
                    } else {
                        FlushInput ();
                    }
                    ZFClose (fh);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            blcnt = 0;
            if (zputs (linebuffer, len, fh) == EOF ||
                zputs (fileEOL, cbfileEOL, fh) == EOF) {

                if (!fCtrlc)
                    disperr (MSGERR_SPACE, tmpname);
                else
                    FlushInput ();
                ZFClose (fh);
                _unlink (tmpname);
                DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                return FALSE;
            }
        } else {
            blcnt++;
        }
    }

    if (zputsflush (fh) == EOF) {

        if (!fCtrlc) {
            disperr (MSGERR_SPACE, tmpname);
        } else {
            FlushInput ();
        }

        ZFClose (fh);
        _unlink (tmpname);
        DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
        return FALSE;
    }

    ZFClose (fh);

    /* fullname     NAME.EXT
     * tmpname      NAME.$
     * buf          temp buffer
     */
    rootpath (fullname, buf);
    strcpy (fullname, buf);

    /* fullname     full NAME.EXT
     * tmpname      NAME.$
     * buf          temp buffer
     */
    if (!_strcmpi (fullname, pFile->pName) && TESTFLAG (FLAGS (pFile), NEW)) {
        if (_unlink (fullname) == -1) {
            fileext (fullname, fullname);
            disperr (MSGERR_DEL, fullname, error ());
            _unlink (tmpname);
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
            }
        }
    else {
        switch (backupType) {

        case B_BAK:
            upd (fullname, ".bak", linebuffer);
            /* foo.bar => foo.bak */
            if (_unlink (linebuffer) == -1) {
                p = error ();
                if (FileExists(linebuffer)) {
                    fileext (linebuffer, linebuffer);
                    disperr (MSGERR_DEL, linebuffer, p);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            if (rename (fullname, linebuffer) == -1) {
                p = error ();
                if (FileExists(fullname)) {
                    disperr (MSGERR_REN, fullname, linebuffer, p);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            break;

        case B_UNDEL:
            /* remove foo.bar */
            i = fdeleteFile (fullname);
            if (i && i != 1) {
                _unlink (tmpname);
                DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                return disperr (MSGERR_OLDVER, fullname);
            }

        case B_NONE:
            if (_unlink (fullname) == -1) {
                p = error ();
                if (FileExists(fullname)) {
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    fileext (fullname, fullname);
                    return disperr (MSGERR_DEL, fullname, p);
                    }
                }
            }
        }

    if (rename (tmpname, fullname) == -1) {
        disperr (MSGERR_REN, tmpname, fullname, error ());
        _unlink (tmpname);
        DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
        return FALSE;
    }

    RSETFLAG (FLAGS (pFile), NEW);

    if (!_strcmpi (savename, pFile->pName) || fNewName) {
        if (fNewName) {
            /*
             * We gave a new name to this file and successfully saved it:
             * this becomes the new file's name
             */
            FREE (pFile->pName);
            pFile->pName = ZMakeStr (fullname);
        }
        RSETFLAG (FLAGS(pFile), (DIRTY | DISKRO));
        SETFLAG (fDisplay,RSTATUS);
        SetModTime( pFile );
    }

    WriteMarks (pFile);
    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);

    return TRUE;
}




/* fdeleteFile - Remove file the way RM does it - checks for undelcount
 *
 *      This code is extracted from Ztools. the only difference being that this
 *      checks for undelcount so our deleted stuff don't grow without bounds
 *
 * The delete operation is performed by indexing the file name in a separate
 * directory and then renaming the selected file into that directory.
 *
 * Returns:
 *
 *  0 if fdelete was successful
 *  1 if the source file did not exist
 *  2 if the source was read-only or if the rename failed
 *  3 if the index was not accessable
 */
int
fdeleteFile(
        char *p
    )
{
        char dir[MAXPATHLEN];                   /* deleted directory            */
        char idx[MAXPATHLEN];                   /* deleted index                        */
        char szRec[MAXPATHLEN];                 /* deletion entry in index      */
        char recbuf[MAXPATHLEN];
        int attr, fhidx;
        int errc;
        int count,c;

    fhidx = -1;

        //
        //      See if the file exists
        //
        if( ( attr = GetFileAttributes( p ) ) == -1) {
                errc = 1;
                goto Cleanup;
        }

        //
        //      What about read-only files?
        //
        if (TESTFLAG (attr, FILE_ATTRIBUTE_READONLY)) {
                errc = 2;
                goto Cleanup;
        }

        //
        //      Form an attractive version of the name
        //
    pname (p);

        //
        // generate deleted directory name, using defaults from input file
        //
    upd (p, RM_DIR, dir);

        //
        //      Generate index name
        //
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);

        //
        // make sure directory exists (reasonably)
        //
        if( _mkdir (dir) == 0 ) {
                SetFileAttributes(dir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }

        //
        // extract filename/extention of file being deleted
        //
    fileext (p, szRec);

        //
        // try to open or create the index
        //
    if ((fhidx = _open (idx, O_CREAT | O_RDWR | O_BINARY,
                           S_IWRITE | S_IREAD)) == -1) {
                errc = 3;
                goto Cleanup;
        }

        if (!convertIdxFile (fhidx, dir)) {
                errc = 3;
                goto Cleanup;
    }

        //
        // scan the index and count how many copies of this file already exist
        //
        for (count=c=0; readNewIdxRec( fhidx, recbuf, c++ ); ) {
                if ( !strcmp( szRec, recbuf )) {
                        count++;
                }
        }

    if (count < cUndelCount) {

                //
                //      Determine new name
                //
                sprintf (strend (dir), "\\deleted.%03x",
                         _lseek (fhidx, 0L, SEEK_END) / RM_RECLEN);

                //
                //      Move the file into the directory
                //
                _unlink (dir);

                if (rename(p, dir) == -1) {
                        errc = 2;
                        goto Cleanup;
                }

                //
                //      Index the file
                //
                if (!writeNewIdxRec (fhidx, szRec)) {
                        rename( dir, p );
                        errc = 2;
                        goto Cleanup;
                }
        } else {

                char buf1[MAXPATHLEN], buf2[MAXPATHLEN], *p1;

                strcpy (buf1, dir);
                strcat (buf1, "\\deleted.");
                p1 = strend (buf1);
                *buf2 = 0;

                _lseek( fhidx, 0L, SEEK_SET );

                for ( count=c=0; readNewIdxRec( fhidx, recbuf, c++ ); count++ ) {
                        if (!strcmp ( szRec, recbuf)) {
                                sprintf (p1, "%03x", count);
                if (! *buf2) {
                                        _unlink (buf1);
                } else {
                    rename (buf1, buf2);
                }
                                strcpy (buf2, buf1);
            }
        }
                rename (p, buf2);
        }

        errc = 0;

Cleanup:
        if ( fhidx != -1 ) {
                _close(fhidx);
        }

        return errc;
}




/*  SetBackup - assign the mode of file backup
 *
 *  This is called during initialization to set the backup type
 *
 *  val         char pointer to "undel", "none", "bak"
 *
 *  If any errors are found, SetBackup will return FALSE otherwise it returns
 *  TRUE.
 */
char *
SetBackup (
    char *val
    )
{
    buffer  bufLocal;

    strcpy ((char *) bufLocal, val);
    _strlwr (bufLocal);

    if (!strcmp (bufLocal, "undel")) {
        backupType = B_UNDEL;
    } else if (!strcmp (bufLocal, "bak")) {
        backupType = B_BAK;
    } else if (!strcmp (bufLocal, "none")) {
        backupType = B_NONE;
    } else {
        return "Backup type must be one of 'undel', 'bak or 'none'";
    }

    return NULL;
}





/*  SetFileTab - set the spacing of tab characters in the file
 *
 *  This is called during initialization to set the number of spaces per
 *  file tab character for output display.  This is for people
 *  who presume that 0x09 is not on 8-character boundaries.  The legal
 *  range for this value is 1-8.
 *
 *  val         char pointer to remainder of assignment
 *
 *  If any errors are found, SetFileTab will return FALSE, otherwise it returns
 *  TRUE.
 */
char *
SetFileTab (
    char *val
    )
{
    int i;
    buffer tmpval;

    strcpy ((char *) tmpval, val);

    i = atoi (tmpval);

    if (i < 1 || i > 8) {
        return "filetab: Value must be between 1 and 8";
    }

    fileTab = i;
    newscreen ();
    return NULL;
}





/*  SetROnly - set the read-only program
 *
 *  This is called during initialization to set the program called when
 *  trying to write a read-only program.
 *
 *  val         char pointer to remainder of assignment
 *
 *  If any errors are found, SetROnly will return FALSE, otherwise it returns
 *  TRUE.
 */
flagType
SetROnly (
    char *pCmd
    )
{

    if (ronlypgm != NULL)
        FREE (ronlypgm);

    if (strlen (pCmd) != 0)
        ronlypgm = ZMakeStr (pCmd);
    else
        ronlypgm = NULL;

    return TRUE;
}





/*  SortedFileInsert - take the passed in line and insert it into the file
 *
 *  pFile       file for insertion
 *  pStr        pointer to string
 */
void
SortedFileInsert (
    PFILE pFile,
    char *pStr
    )
{
    linebuf buf;
    LINE    hi, lo, mid;
    int     d;

    hi = pFile->cLines-1;
    lo = 0;

    while (lo <= hi) {
        mid = (hi + lo) / 2;
        GetLine (mid, buf, pFile);
        d = strcmp (pStr, buf);
        if (d < 0) {
            hi = mid - 1;
        } else if (d == 0) {
            return;
        } else {
            lo = mid + 1;
        }
    }

    /*  lo is the line # for insertion
     */
    InsertLine (lo, pStr, pFile);
}





struct ldarg {
    PFILE pFile;
    int   linelen;
    };


/*  LoadDirectoryProc - take enumerated file and place into file
 *
 *  szFile      pointer to file name to place into file
 *  pfbuf       pointer to find buffer
 *  pData       pointer to data for insertion
 */
void
LoadDirectoryProc (
    char * szFile,
    struct findType *pfbuf,
    void *pData
    )
{
    struct ldarg *pldarg = (struct ldarg *)pData;

    pldarg->linelen = max (pldarg->linelen, (int)strlen(szFile));
    SortedFileInsert (pldarg->pFile, szFile);

    pfbuf;
}


static char szNoMatchingFiles[] = "No matching files";


/*  LoadDirectory - load the matching contents of the name into a fake file.
 *
 *  name        matching pattern for files
 *
 *  Returns:    TRUE always
 */
flagType
LoadDirectory (
    char *fname,
    PFILE pFile
    )
{
    struct ldarg ldarg;

    ldarg.linelen = 0;
    ldarg.pFile = pFile;

    /*  Make sure undo believes that this file is fake.
     */
    SETFLAG (FLAGS(pFile), FAKE + REAL);

    /*  We walk the matching files, entering the names into the file one at
     *  a time in sorted order and, at the same time, determine the max string
     *  length.
     *  We then use CopyBox to collapse the file.
     */

    /*  Enumerate all lines into file
     */
    forfile ((char *)fname, A_ALL, LoadDirectoryProc, &ldarg);

    /*  If file is empty, note it
     */
    if (pFile->cLines == 0) {
        AppFile (szNoMatchingFiles, pFile);
    } else {

        /*  File is pFile->cLines long with a max line len of
         *  ldarg.linelen.  Since we are gathering the thing in columns
         *  we will have pwinCur->xSize / (ldarg.linelen + 2) columns, each of
         *  which will have pFile->cLines / # cols lines.
         */
        int ccol;
        LINE cline, i;

        ccol = max (WINXSIZE(pWinCur) / (ldarg.linelen + 2), 1);
        cline = (pFile->cLines + ccol - 1) / ccol;
        ldarg.linelen = WINXSIZE(pWinCur) / ccol;

        /*  Now, for each of the columns, copy them into position.  Remember
         *  that one column is ALREADY in position.
         */
        for (i = 1; i < ccol; i++) {
            /*  copy lines cline..2*cline - 1
             *  columns 0..ldarg.linelen  to
             *  line 0, column ldarg.linelen*i
             */
            CopyBox (pFile, pFile, 0,                       cline,
                                   ldarg.linelen-1,         2 * cline - 1,
                                   ldarg.linelen * (int) i, (LINE)0);
            DelLine (TRUE, pFile, cline, 2 * cline - 1);
        }
    }
    RSETFLAG (FLAGS(pFile), DIRTY);
    return TRUE;
}





/*  LoadFake - load a fake or pseudo file into memory.  Fake files are used
 *  for two purposes:  as temporary buffers or for information displays.
 *
 *  name        name of pseudo file
 *
 *  Returns:    TRUE always.
 */
flagType
LoadFake (
    char *name,
    PFILE pFile
    )
{
    SETFLAG (FLAGS(pFile), FAKE | REAL | REFRESH | DOSFILE);
    if (!strcmp (name, rgchInfFile)) {
        showinf (pFile);
    } else if (!strcmp (name, rgchAssign)) {
        showasg (pFile);
    } else if (!strcmp (name, "<environment>")) {
        showenv (pFile);
    } else {
         RSETFLAG (FLAGS(pFile), REFRESH);
    }
    return TRUE;
}




/*** SaveFake - "Save" a pseudo-file.  Meaning depends on file
*
* Purpose:
*
*   In some cases, "saving" a pseudo-file means something.  Currently
*   we have:
*
*       <assign> - Update changed lines to TOOLS.INI.
*
* Input:
*   savename -
*   pFile    -
*
* Output:
*
*   Returns TRUE if file was saved, FALSE if not
*
*************************************************************************/
flagType
SaveFake (
    char * savename,
    PFILE pFile
    )
{
    struct  lineAttr rnBuf[10];
    LINE    l;

    if (!_stricmp (pFile->pName, rgchAssign)) {
        for (l = 0; l < pFile->cLines; l++) {
            if (GetColor (l, rnBuf, pFile)) {
                GetLine (l, buf, pFile);
                UpdToolsIni (buf);
                DelColor (l, pFile);
                redraw (pFile, l, l);
            }
        }
    } else {
        return FALSE;
    }

    return TRUE;

    savename;
}





/*** SaveAllFiles - Find all dirty files and save them to disk
*
* Purpose:
*
*   To save all dirty files, of course.
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
SaveAllFiles (
    void
    )
{
    PFILE pFile;
    int i;

    i = 0;
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
            FileWrite (NULL, pFile);
            i++;
            }
        }

    domessage ("Save %d files", i);

}




FILEHANDLE
ZFOpen (
    LPBYTE      FileName,
    ACCESSMODE  Access,
    SHAREMODE   Share,
    BOOL        fCreate
    )
{
    FILEHANDLE  Handle;

    Handle = CreateFile(FileName, Access, Share, NULL, OPEN_EXISTING, 0, NULL);
    if ((Handle == INVALID_HANDLE_VALUE) && fCreate) {
        Handle = CreateFile(FileName, Access, Share, NULL, CREATE_NEW,
                             FILE_ATTRIBUTE_NORMAL, NULL);
    }
    if (Handle == INVALID_HANDLE_VALUE) {
        return (HANDLE)0;
    } else {
        return Handle;
    }
}




void
ZFClose (
    FILEHANDLE Handle
    )
{
    CloseHandle(Handle);
}



DWORD
ZFRead (
    PVOID       pBuffer,
    DWORD       Size,
    FILEHANDLE  Handle
    )
{
    DWORD BytesRead;
    if ( !ReadFile(Handle, pBuffer, Size, &BytesRead, NULL) ) {
        return 0;
    } else {
        return BytesRead;
    }
}




DWORD
ZFWrite (
    PVOID       pBuffer,
    DWORD       Size,
    FILEHANDLE  Handle
    )
{
    DWORD BytesWritten;

    if ( !WriteFile(Handle, pBuffer, Size, &BytesWritten, NULL) ) {
        return 0;
    } else {
        return BytesWritten;
    }
}


DWORD
ZFSeek (
    FILEHANDLE  Handle,
    DWORD       Distance,
    MOVEMETHOD  MoveMethod
    )
{
    assert (Handle != INVALID_HANDLE_VALUE);
    return SetFilePointer(Handle, Distance, NULL, MoveMethod);
}






flagType
FileExists (
    char    *path
    )
{
    return (flagType)((GetFileAttributes(path) == -1) ? FALSE : TRUE);
}


//
//  rename may be defined as ZMove, but now we want the real one, so
//  we undefine it.
//
#ifdef rename
#undef rename
#endif

int ZMove (
     char *oldname,
     char *newname
    )
{
    #define BUFFERSIZE (1024 * 32)

    FILE    *fhSrc, *fhDst;
    void    *buffer;
    size_t  BytesRead;
    size_t  BytesWritten;


    if (FileExists (newname)) {
        return -1;
    }

    //
    //  First, try the rename
    //
    if (rename(oldname, newname) == 0) {
        return 0;
    }

    //
    //  Cannot rename, try to copy
    //
        if (!(fhSrc = fopen(oldname, "r"))) {
                return -1;
        }

        if (!(fhDst = fopen(newname, "w"))) {
                fclose(fhSrc);
                return -1;
        }

    buffer = MALLOC(BUFFERSIZE);
    if ( !buffer ) {
        disperr (MSGERR_NOMEM);
        return -1;
    }

    do {
        BytesRead       = fread(buffer, 1, BUFFERSIZE, fhSrc);
        if (BytesRead) {
            BytesWritten    = fwrite(buffer, 1, BytesRead, fhDst);
        }

    } while (BytesRead);

    fclose(fhSrc);
    fclose(fhDst);

    FREE(buffer);

    return _unlink(oldname);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\insert.c ===
/*  sinsert.c - stream insert of characters
 *
 *  Modifications:
 *
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "z.h"


flagType
insert (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {

    switch (pArg->argType) {

	case BOXARG:
	case LINEARG:
	    linsert (argType, pArg, fMeta);
	    break;

	default:
	    sinsert (argType, pArg, fMeta);
	    break;
    }
    return TRUE;
}



flagType
sinsert (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    switch (pArg->argType) {

    case NOARG:
	CopyBox (NULL, pFileHead, pArg->arg.noarg.x, pArg->arg.noarg.y,
				  pArg->arg.noarg.x, pArg->arg.noarg.y,
				  pArg->arg.noarg.x, pArg->arg.noarg.y);
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	flHigh.col = 0;
	flHigh.lin++;
	CopyStream (NULL, pFileHead, pArg->arg.nullarg.x, pArg->arg.nullarg.y,
				     0, 		  pArg->arg.nullarg.y + 1,
				     pArg->arg.nullarg.x, pArg->arg.nullarg.y);
        return TRUE;

    case LINEARG:
    case BOXARG:
	BoxToStream (pArg);

    case STREAMARG:
	CopyStream (NULL, pFileHead,
		    pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		    pArg->arg.streamarg.xEnd,	pArg->arg.streamarg.yEnd,
		    pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart);
	return TRUE;
    }

    return FALSE;

    argData; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\key.c ===
/*** key.c - keyboard handling routines
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*	03-Dec-1990 ramonsa addapted from old key.c
*	26-Nov-1991 mz	    Strip off near/far
*
*************************************************************************/
#include "z.h"





//
//  CodeCmdMap
//
//      The KeyCode field in the KEY_INFO structure used within the editor
//  is just an index into this table.
//
//      This table contains pointers to the editor functions attached to
//  particular keystrokes.
//
PCMD CodeCmdMap [] =
    {

            //************************************************************
/*  Key  */ //
/* Index */ //  256 ASCII characters
            //
/* 0000 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0004 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0008 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 000C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0010 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0014 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0018 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 001C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0020 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0024 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0028 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 002C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0030 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0034 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0038 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 003C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0040 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0044 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0048 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 004C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0050 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0054 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0058 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 005C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0060 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0064 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0068 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 006C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0070 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0074 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0078 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 007C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0080 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0084 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0088 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 008C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0090 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0094 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0098 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 009C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00A0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00A4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00A8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00AC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00BC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00C0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00C4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00C8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00CC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00DC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00E0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00E4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00E8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00EC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00FC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,


            //**********************************************************
            //
            //  Special Keys
            //
            //
            //  Function Keys (f1-f12)
            //
/* 0100 */  CMD_unassigned, CMD_setfile,    CMD_psearch,    CMD_msearch,
/* 0104 */  CMD_unassigned, CMD_window,     CMD_zexecute,   CMD_zexit,
/* 0108 */	CMD_meta,		CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 010C */  CMD_begline,    CMD_endline,    CMD_left,       CMD_right,
            //    Up            Down            Pgup            Pgdown
/* 0110 */  CMD_up,         CMD_down,       CMD_mpage,      CMD_ppage,
            //    Ins           Del             Goto
/* 0114 */  CMD_insertmode, CMD_delete,     CMD_unassigned, CMD_unassigned,

            //
            //  Numeric white keys (Numlock on) 0-9
            //
/* 0118 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 011C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0120 */  CMD_graphic,    CMD_graphic,    CMD_unassigned, CMD_unassigned,

            //
            //  Numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 0124 */	CMD_graphic,	CMD_zpick,		CMD_graphic,	  CMD_graphic,
            //   NUMENTER
/* 0128 */  CMD_emacsnewl,  CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //  Named Keys :
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 012C */  CMD_unassigned, CMD_emacscdel,  CMD_tab,        CMD_unassigned,
            //  ESC         ENTER
/* 0130 */  CMD_cancel,     CMD_emacsnewl,  CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 0134 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0138 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 013C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  ALT+ 0-9
            //
/* 0140 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0144 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0148 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ a-z
            //
/* 014C */  CMD_doarg,      CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0150 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0154 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0158 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 015C */	CMD_unassigned, CMD_record, 	CMD_unassigned, CMD_unassigned,
/* 0160 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0164 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ function keys (f1-f12)
            //
/* 0168 */  CMD_unassigned, CMD_zprint,     CMD_unassigned, CMD_unassigned,
/* 016C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0170 */	CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ lower case punctuation
            //
            //    `               -               =              [
/* 0174 */  CMD_unassigned, CMD_unassigned, CMD_assign,     CMD_unassigned,
            //    ]               \               ;              '
/* 0178 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    ,                .              /
/* 017C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 0180 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Up            Down            Pgup            Pgdown
/* 0184 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Ins           Del             Goto
/* 0188 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ numeric white keys (Numlock on) 0-9
            //
/* 018C */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_noop,
/* 0190 */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_noop,
/* 0194 */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_unassigned,

            //
            //  ALT+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 0198 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 019C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ named keys:
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 01A0 */  CMD_unassigned, CMD_undo,       CMD_unassigned, CMD_unassigned,
            //  ESC         ENTER
/* 01A4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 01A8 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01AC */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01B0 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  CTRL+ 0-9
            //
/* 01B4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01B8 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01BC */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ a-z
            //
/* 01C0 */	CMD_mword,		CMD_boxstream,	CMD_ppage,		CMD_right,
/* 01C4 */	CMD_up, 		CMD_pword,		CMD_cdelete,	CMD_unassigned,
/* 01C8 */  CMD_unassigned, CMD_sinsert,    CMD_unassigned, CMD_replace,
/* 01CC */	CMD_mark,		CMD_linsert,	CMD_textarg,	CMD_quote,
/* 01D0 */	CMD_unassigned, CMD_mpage,		CMD_left,		CMD_tell,
/* 01D4 */	CMD_lastselect, CMD_insertmode, CMD_mlines, 	CMD_down,
/* 01D8 */  CMD_ldelete,    CMD_plines,     CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ function keys  (f1-f12)
            //
/* 01DC */  CMD_unassigned, CMD_unassigned, CMD_compile,    CMD_unassigned,
/* 01E0 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_zprint,
/* 01E4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ lower case punctuation
            //
            //    `               -               =              [
/* 01E8 */	CMD_unassigned, CMD_unassigned, CMD_noop,		CMD_pbal,
            //    ]               \               ;              '
/* 01EC */  CMD_setwindow,  CMD_qreplace,   CMD_unassigned, CMD_unassigned,
            //    ,                .              /
/* 01F0 */	CMD_unassigned, CMD_noop,		CMD_unassigned, CMD_unassigned,


            //
            //  CTRL+ numeric white keys (Numlock off)
            //
			//	  Home			End 			Left			Right
/* 01F4 */	CMD_home,		CMD_unassigned,	CMD_mword,		CMD_pword,
            //    Up            Down            Pgup            Pgdown
/* 01F8 */	CMD_unassigned, CMD_unassigned, CMD_begfile,	CMD_endfile,
            //    Ins           Del             Goto
/* 01FC */  CMD_zpick,      CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ numeric white keys (Numlock on) (0-9)
            //
/* 0200 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0204 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0208 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 020C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 0210 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ named keys
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 0214 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
			//	ESC 		ENTER
/* 0218 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 021C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0220 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0224 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  SHIFT+ function keys  (f1-f12)
            //
/* 0228 */  CMD_information,CMD_unassigned, CMD_nextmsg,    CMD_unassigned,
/* 022C */  CMD_unassigned, CMD_searchall,  CMD_refresh,    CMD_zinit,
/* 0230 */  CMD_zspawn,     CMD_information,CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 0234 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Up            Down            Pgup            Pgdown
/* 0238 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Ins           Del             Goto
/* 023C */  CMD_put,        CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric white keys (Numlock on) (0-9)
            //
/* 0240 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0244 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0248 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 024C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 0250 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ named keys
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 0254 */	CMD_graphic,	CMD_unassigned, CMD_backtab,	CMD_unassigned,
            //  ESC         ENTER
/* 0258 */  CMD_unassigned, CMD_emacsnewl,  CMD_focus,      CMD_noop,


            NULL
};

#define LAST_CODE 0x25b


typedef struct KEYNAME {
    WORD    KeyCode;                    // Key Code
    char    *pName;                     // name of key
} KEYNAME, *PKEYNAME;


//
//  CodeNameMap
//
//      This table maps KeyCodes to their corresponding printable name
//  and vice-versa.
//
KEYNAME CodeNameMap[] =
{

    {   0x0100, "f1"            },      {   0x0101, "f2"            },
    {   0x0102, "f3"            },      {   0x0103, "f4"            },
    {   0x0104, "f5"            },      {   0x0105, "f6"            },
    {   0x0106, "f7"            },      {   0x0107, "f8"            },
    {   0x0108, "f9"            },      {   0x0109, "f10"           },
    {   0x010A, "f11"           },      {   0x010B, "f12"           },

    {   0x010C, "home"          },      {   0x010D, "end"           },
    {   0x010E, "left"          },      {   0x010F, "right"         },
    {   0x0110, "up"            },      {   0x0111, "down"          },
    {   0x0112, "pgup"          },      {   0x0113, "pgdn"          },
    {   0x0114, "ins"           },      {   0x0115, "del"           },
    {   0x0116, "goto"          },

    {   0x0118, "num0"          },      {   0x0119, "num1"          },
    {   0x011A, "num2"          },      {   0x011B, "num3"          },
    {   0x011C, "num4"          },      {   0x011D, "num5"          },
    {   0x011E, "num6"          },      {   0x011F, "num7"          },
    {   0x0120, "num8"          },      {   0x0121, "num9"          },

    {   0x0124, "num-"          },      {   0x0125, "num+"          },
    {   0x0126, "num*"          },      {   0x0127, "num/"          },
    {   0x0128, "numenter"      },

    {   0x012C, "space"         },      {   0x012D, "bksp"          },
    {   0x012E, "tab"           },      {   0x012F, "bktab"         },
    {   0x0130, "esc"           },      {   0x0131, "enter"         },

    {   0x0140, "alt+0"         },      {   0x0141, "alt+1"         },
    {   0x0142, "alt+2"         },      {   0x0143, "alt+3"         },
    {   0x0144, "alt+4"         },      {   0x0145, "alt+5"         },
    {   0x0146, "alt+6"         },      {   0x0147, "alt+7"         },
    {   0x0148, "alt+8"         },      {   0x0149, "alt+9"         },

    {   0x014C, "alt+a"         },      {   0x014D, "alt+b"         },
    {   0x014E, "alt+c"         },      {   0x014F, "alt+d"         },
    {   0x0150, "alt+e"         },      {   0x0151, "alt+f"         },
    {   0x0152, "alt+g"         },      {   0x0153, "alt+h"         },
    {   0x0154, "alt+i"         },      {   0x0155, "alt+j"         },
    {   0x0156, "alt+k"         },      {   0x0157, "alt+l"         },
    {   0x0158, "alt+m"         },      {   0x0159, "alt+n"         },
    {   0x015A, "alt+o"         },      {   0x015B, "alt+p"         },
    {   0x015C, "alt+q"         },      {   0x015D, "alt+r"         },
    {   0x015E, "alt+s"         },      {   0x015F, "alt+t"         },
    {   0x0160, "alt+u"         },      {   0x0161, "alt+v"         },
    {   0x0162, "alt+w"         },      {   0x0163, "alt+x"         },
    {   0x0164, "alt+y"         },      {   0x0165, "alt+z"         },

    {   0x0168, "alt+f1"        },      {   0x0169, "alt+f2"        },
    {   0x016A, "alt+f3"        },      {   0x016B, "alt+f4"        },
    {   0x016C, "alt+f5"        },      {   0x016D, "alt+f6"        },
    {   0x016E, "alt+f7"        },      {   0x016F, "alt+f8"        },
    {   0x0170, "alt+f9"        },      {   0x0171, "alt+f10"       },
    {   0x0172, "alt+f11"       },      {   0x0173, "alt+f12"       },

    {   0x0174, "alt+`"         },      {   0x0175, "alt+-"         },
    {   0x0176, "alt+="         },      {   0x0177, "alt+["         },
    {   0x0178, "alt+]"         },      {   0x0179, "alt+\\"        },
    {   0x017A, "alt+;"         },      {   0x017B, "alt+'"         },
    {   0x017C, "alt+,"         },      {   0x017D, "alt+."         },
    {   0x017E, "alt+/"         },

    {   0x0180, "alt+home"      },      {   0x0181, "alt+end"       },
    {   0x0182, "alt+left"      },      {   0x0183, "alt+right"     },
    {   0x0184, "alt+up"        },      {   0x0185, "alt+down"      },
    {   0x0186, "alt+pgup"      },      {   0x0187, "alt+pgdn"      },
    {   0x0188, "alt+ins"       },      {   0x0189, "alt+del"       },
    {   0x018A, "alt+goto"      },

    {   0x018C, "alt+num0"      },      {   0x018D, "alt+num1"      },
    {   0x018E, "alt+num2"      },      {   0x018F, "alt+num3"      },
    {   0x0190, "alt+num4"      },      {   0x0191, "alt+num5"      },
    {   0x0192, "alt+num6"      },      {   0x0193, "alt+num7"      },
    {   0x0194, "alt+num8"      },      {   0x0195, "alt+num9"      },

    {   0x0198, "alt+num-"      },      {   0x0199, "alt+num+"      },
    {   0x019A, "alt+num*"      },      {   0x019B, "alt+num/"      },
    {   0x019C, "alt+numenter"  },

    {   0x01A0, "alt+space"     },      {   0x01A1, "alt+bksp"      },
    {   0x01A2, "alt+tab"       },      {   0x01A3, "alt+bktab"     },
    {   0x01A4, "alt+esc"       },      {   0x01A5, "alt+enter"     },

	{	0x01B4, "ctrl+0"		},		{	0x01B5, "ctrl+1"		},
	{	0x01B6, "ctrl+@"		},
    {   0x01B6, "ctrl+2"        },      {   0x01B7, "ctrl+3"        },
	{	0x01B8, "ctrl+4"		},		{	0x01B9, "ctrl+5"		},
	{	0x01BA, "ctrl+^"		},
    {   0x01BA, "ctrl+6"        },      {   0x01BB, "ctrl+7"        },
    {   0x01BC, "ctrl+8"        },      {   0x01BD, "ctrl+9"        },

    {   0x01C0, "ctrl+a"        },      {   0x01C1, "ctrl+b"        },
    {   0x01C2, "ctrl+c"        },      {   0x01C3, "ctrl+d"        },
    {   0x01C4, "ctrl+e"        },      {   0x01C5, "ctrl+f"        },
    {   0x01C6, "ctrl+g"        },      {   0x01C7, "ctrl+h"        },
    {   0x01C8, "ctrl+i"        },      {   0x01C9, "ctrl+j"        },
    {   0x01CA, "ctrl+k"        },      {   0x01CB, "ctrl+l"        },
    {   0x01CC, "ctrl+m"        },      {   0x01CD, "ctrl+n"        },
    {   0x01CE, "ctrl+o"        },      {   0x01CF, "ctrl+p"        },
    {   0x01D0, "ctrl+q"        },      {   0x01D1, "ctrl+r"        },
    {   0x01D2, "ctrl+s"        },      {   0x01D3, "ctrl+t"        },
    {   0x01D4, "ctrl+u"        },      {   0x01D5, "ctrl+v"        },
    {   0x01D6, "ctrl+w"        },      {   0x01D7, "ctrl+x"        },
    {   0x01D8, "ctrl+y"        },      {   0x01D9, "ctrl+z"        },

    {   0x01DC, "ctrl+f1"       },      {   0x01DD, "ctrl+f2"       },
    {   0x01DE, "ctrl+f3"       },      {   0x01DF, "ctrl+f4"       },
    {   0x01E0, "ctrl+f5"       },      {   0x01E1, "ctrl+f6"       },
    {   0x01E2, "ctrl+f7"       },      {   0x01E3, "ctrl+f8"       },
    {   0x01E4, "ctrl+f9"       },      {   0x01E5, "ctrl+f10"      },
    {   0x01E6, "ctrl+f11"      },      {   0x01E7, "ctrl+f12"      },

    {   0x01E8, "ctrl+`"        },      {   0x01E9, "ctrl+-"        },
    {   0x01EA, "ctrl+="        },      {   0x01EB, "ctrl+["        },
    {   0x01EC, "ctrl+]"        },      {   0x01ED, "ctrl+\\"       },
    {   0x01EE, "ctrl+;"        },      {   0x01EF, "ctrl+'"        },
    {   0x01F0, "ctrl+,"        },      {   0x01F1, "ctrl+."        },
    {   0x01F2, "ctrl+/"        },

    {   0x01F4, "ctrl+home"     },      {   0x01F5, "ctrl+end"      },
    {   0x01F6, "ctrl+left"     },      {   0x01F7, "ctrl+right"    },
    {   0x01F8, "ctrl+up"       },      {   0x01F9, "ctrl+down"     },
    {   0x01FA, "ctrl+pgup"     },      {   0x01FB, "ctrl+pgdn"     },
    {   0x01FC, "ctrl+ins"      },      {   0x01FD, "ctrl+del"      },
    {   0x01FE, "ctrl+goto"     },

    {   0x0200, "ctrl+num0"     },      {   0x0201, "ctrl+num1"     },
    {   0x0202, "ctrl+num2"     },      {   0x0203, "ctrl+num3"     },
    {   0x0204, "ctrl+num4"     },      {   0x0205, "ctrl+num5"     },
    {   0x0206, "ctrl+num6"     },      {   0x0207, "ctrl+num7"     },
    {   0x0208, "ctrl+num8"     },      {   0x0209, "ctrl+num9"     },

    {   0x020C, "ctrl+num-"     },      {   0x020D, "ctrl+num+"     },
    {   0x020E, "ctrl+num*"     },      {   0x020F, "ctrl+num/"     },
    {   0x0210, "ctrl+numenter" },

    {   0x0214, "ctrl+space"    },      {   0x0215, "ctrl+bksp"     },
    {   0x0216, "ctrl+tab"      },      {   0x0217, "ctrl+bktab"    },
	{	0x0218, "ctrl+esc"		},		{	0x0219, "ctrl+enter"	},

    {   0x0228, "shift+f1"      },      {   0x0229, "shift+f2"      },
    {   0x022A, "shift+f3"      },      {   0x022B, "shift+f4"      },
    {   0x022C, "shift+f5"      },      {   0x022D, "shift+f6"      },
    {   0x022E, "shift+f7"      },      {   0x022F, "shift+f8"      },
    {   0x0230, "shift+f9"      },      {   0x0231, "shift+f10"     },
    {   0x0232, "shift+f11"     },      {   0x0233, "shift+f12"     },

    {   0x0234, "shift+home"    },      {   0x0235, "shift+end"     },
    {   0x0236, "shift+left"    },      {   0x0237, "shift+right"   },
    {   0x0238, "shift+up"      },      {   0x0239, "shift+down"    },
    {   0x023A, "shift+pgup"    },      {   0x023B, "shift+pgdn"    },
    {   0x023C, "shift+ins"     },      {   0x023D, "shift+del"     },
    {   0x023E, "shift+goto"    },

    {   0x0240, "shift+num0"    },      {   0x0241, "shift+num1"    },
    {   0x0242, "shift+num2"    },      {   0x0243, "shift+num3"    },
    {   0x0244, "shift+num4"    },      {   0x0245, "shift+num5"    },
    {   0x0246, "shift+num6"    },      {   0x0247, "shift+num7"    },
    {   0x0248, "shift+num8"    },      {   0x0249, "shift+num9"    },

    {   0x024C, "shift+num-"    },      {   0x024D, "shift+num+"    },
    {   0x024E, "shift+num*"    },      {   0x024F, "shift+num/"    },
    {   0x0250, "shift+numenter"},

    {   0x0254, "shift+space"   },      {   0x0255, "shift+bksp"    },
    {   0x0256, "shift+tab"     },      {   0x0257, "shift+bktab"   },
    {   0x0258, "shift+esc"     },      {   0x0259, "shift+enter"   },
    {   0x025A, "getfocus"      },      {   0x025B, "losefocus"     },


    {   0x0000, NULL        }
};

char UnknownKey [] = "???";


/*** ReadCmd - read the next command from the keyboard.
*
*  ReadCmd is used whenever an editor function is being read. It reads a
*  keystroke and looks it up in the key definition table and returns the
*  matching function.
*
* Input:
*  none
*
* Globals:
*  keyCmd	= last key hit. Updated.
*
* Output:
*  Returns a pointer to function. If not a macro, the function's arg is the
*  keystroke actually used. In addition, the key used is placed in wKeyCmd.
*
*************************************************************************/
PCMD
ReadCmd (
    void
    ) {

    WORD    i;                              /* key code                 */
    EVTargs e;                              /* arg struct for declaring event*/

    do {
        if (!TypeAhead () ) {
            SetEvent( semIdle );
            keyCmd = TranslateKey (ReadChar ());
            WaitForSingleObject(semIdle, INFINITE);
        } else {
            keyCmd = TranslateKey (ReadChar ());
        }
        e.arg.key = keyCmd.KeyInfo;
    } while (DeclareEvent (EVT_RAWKEY, (EVTargs *)&e));

    if (fCtrlc && keyCmd.KeyCode == 0) {
        return NameToFunc ("cancel");
    }

    i = keyCmd.KeyCode;

    if (i > 0 && i <= LAST_CODE) {
        if ((PVOID)CodeCmdMap[i]->func != (PVOID)macro) {
            if ( (PVOID)CodeCmdMap[i]->func == (PVOID)(unassigned) ) {
                CodeCmdMap[i]->arg = (long)keyCmd.KeyCode;
            } else {
                CodeCmdMap[i]->arg = keyCmd.KeyInfo.LongData;
            }
		}
		return CodeCmdMap[i];
    }

	return (PCMD) &cmdUnassigned;
}



/*** FreeMacs - Unassign all keys assigned to macros
*
*  This routine is used to unassign all keys that are assigned to macro
*  definitions. Called immediately prior to releasing all macro definitions.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
FreeMacs (
    void
    ) {
    int     i       = 0;

    while (CodeCmdMap[i]) {
        if ((PVOID)CodeCmdMap[i]->func == (PVOID)macro) {
            CodeCmdMap[i] = CMD_unassigned;
        }
        i++;
    }
}









/*** CodeToName - convert a key codeinto a printable name for the keystroke
*
* Purpose:
*
*   If the index is >= 0x0100, we use the text corresponding to the key in
*   the special key table.  If the index is <= 0x00FF, we look up the
*   key (= index) in the special key table and use the corresponding string.
*   If the key is < 0x0020, we display it as ^ followed by a letter.  If
*   the key is >= 0x0080, we display the key as alt-ddd.  Otherwise, the
*   index itself is a printable character.
*
* Input:
*
*   index	Index of keystroke of interest
*
* Output:
*
*   p		buffer to place readable name
*
*************************************************************************/
void
CodeToName (
    WORD Code,
    char *p
    ) {

    WORD i = 0;
    char * pName = NULL;

    while (CodeNameMap[i].pName != NULL) {
        if (CodeNameMap[i].KeyCode == (WORD)Code) {
            pName = CodeNameMap[i].pName;
            break;
        }
        i++;
    }

    if (pName) {
        strcpy(p, pName);
    } else {
        *p = '\0';
    }
}





/*** NameToCode - convert a key name into a key code
*
* Purpose:
*
*   If the name is one character, then index = first char of name.  If name
*   is two characters and begins with ^, then index = control-second
*   character.	If the name is alt-ddd, then use ddd as the index.
*   Otherwise, look up name in key table, convert the found keystroke to an
*   index and return that index.
*
* Input:
*
*   pName	character pointer to name being indexed
*
* Output:
*
*   Returns     0-based index of matching key or 0 if not found
*
*************************************************************************/
WORD
NameToCode (
    char *pName
    )
{

    WORD i      = (WORD)strlen (pName);
    WORD Code   = 0;
    char Name[20];

    if (i == 1) {
        //
        //  Code is ascii
        //
        return (WORD)(pName[0]);
    } else if (i == 2 && pName[0] == '^') {
        sprintf(Name, "ctrl+%c", pName[1]);
    } else {
        strcpy(Name, pName);
    }

    i = 0;
    while (CodeNameMap[i].pName != NULL) {
        if (!strcmp(Name, CodeNameMap[i].pName)) {
            Code = CodeNameMap[i].KeyCode;
            break;
        }
        i++;
    }

    if (Code) {
        return Code;
    } else {
        return 0;
    }
}




/*** SetKey - associate an editor function with a keystroke
*
* SetKey is used to create a keyboard assignment. Any current assignment to
* the keystroke is discarded and each time that particular keystroke is
* seen, the corresponding editor function will be invoked.
*
* Input:
*  name		= local pointer to name of string being assigned
*  p		= pointer to keystroke
*
* Output:
*  Returns TRUE if a successful assignment was made.
*
*************************************************************************/
flagType
SetKey (
    char    *name,
    char    *p
    )
{

    WORD    Code;
    buffer  keybuf;
    PCMD    pCmd;

    if (strlen(strcpy (keybuf, p)) > 1) {
        _strlwr (keybuf) ;
    }
    Code = NameToCode (keybuf);
    if (Code) {
        if (pCmd = NameToFunc (name)) {
            CodeCmdMap[Code] = pCmd;
            return TRUE;
        }
    }
    return FALSE;
}



/*** FuncOut - append into a file current key assignments
*
* Purpose:
*
* Input:
*
*   pFunc	pointer to command structure
*   pFile	file to place text
*
* Output: None.
*
*************************************************************************/
void
FuncOut (
    PCMD pFunc,
    PFILE pFile
    ) {

    WORD     i;
    char     *p;
    flagType fFirst;

    if ((PVOID)pFunc->func != (PVOID)graphic && (PVOID)pFunc->func != (PVOID)unassigned) {
        sprintf (buf, "%20Fs:", pFunc->name);
        p = buf + 21;
        fFirst = TRUE;

        for (i = 0; CodeCmdMap[i] != NULL; i++) {
            if (CodeCmdMap[i] == pFunc) {
                CodeToName (i, p);
                AppFile (buf, pFile);
                fFirst = FALSE;
            }
        }

        if (fFirst) {
            sprintf (p, "is unassigned");
            buf[0] = ';';
            AppFile (buf, pFile);
        }
    }
}




/*** FuncToKeys - return all key names for a key attached to the given function
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
char *
FuncToKeys (
    PCMD pFunc,
    char * dst
    ) {

    WORD     i;
    flagType f = FALSE;

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if (CodeCmdMap[i] == pFunc) {
            if (f) {
                sprintf (strend (dst), " and ");
            }
	    f = TRUE;
            CodeToName (i, strend (dst));
        }
    }

    if (!f) {
        sprintf (strend (dst), "is unassigned");
    }

    return dst;
}




/*** FuncToKey - return a key name for a key attached to the given function
*
* Purpose:
*
*   used only by showasg ()
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
char *
FuncToKey (
    PCMD pFunc,
    char * dst
    ) {

    WORD i;

    dst[0] = '\0';

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if (CodeCmdMap[i] == pFunc) {
            CodeToName (i, dst);
            break;
        }
    }
    return dst;
}




/*** UnassignedOut - Dump the names of all unassigned keys to a file
*
* Purpose:
*
*   Used by showasg to generate the table of unassigned keys.
*
* Input:
*   pFile - File to dump to.
*
* Output: None
*
*************************************************************************/
void
UnassignedOut (
    PFILE pFile
    ) {

    WORD i, col = 0;
    char KeyName[20];

    buf[0] = ';';

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if ((PVOID)CodeCmdMap[i]->func == (PVOID)unassigned) {
            CodeToName (i, KeyName);
	    sprintf (buf + col * 16 + 1, "%14s |", KeyName);
	    if (col++ == 4) {
		AppFile (buf, pFile);
		col = 0;
            }
        }
    }
}





/****************************************************************************
 *									    *
 *  SetKeyboard - Handle 'keyboard:' editor switch			    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	In order to support the extra keys on the IBM Enhanced keyboards,   *
 *	it is necessary to use a separate INT 16H service to characters.    *
 *	This can cause two problems:					    *
 *									    *
 *	    1. If the keyboard is mistakenly identified as enhanced when    *
 *	       it is not, unpredictable bad things may happen.		    *
 *									    *
 *	    2. Mouse menus don't support the enhanced keyboard BIOS call.   *
 *	       There may be other programs that do not either.		    *
 *									    *
 *	The user can then set 'keyboard:compatible' to solve the problem.   *
 *	This will prevent the user of F11, F12 and the grey keys.	    *
 *									    *
 *	Switch values are:						    *
 *									    *
 *	    keyboard:enhanced	-  Use INT 16H, AH = 10H		    *	*
 *	    keyboard:compatible -  Use INT 16H, AH = 0			    *	*
 *	    keyboard:		-  Detect keyboard type and use that	    *
 *									    *
 *  INPUT:								    *
 *									    *
 *	lpszVal     String following the colon				    *
 *									    *
 *  OUTPUT:								    *
 *									    *
 *	Int16_CmdBase  Set to 0 or 10H					    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if lpszVal is acceptable					    *
 *	FALSE if lpszVal is not recognized				    *
 *	FALSE if lpszVal is 'enhanced', but we detect a compatible keyboard *
 *									    *
 ****************************************************************************/
char *
SetKeyboard (
    char *lpszVal
    ) {

    return NULL;

    lpszVal;
}



/*** ReadCmdAndKey - Read a key, return the command and key name
*
* Purpose:
*
*   This is used only by the <tell> function.  Waits for a key press,
*   then fills 'buf' with the name of the key.
*
* Input:
*   buf - Place for the key name
*
* Output:
*
*   buf  -  Gets filled with keyname.
*
*   Returns the PCMD attached to the key.
*
*************************************************************************/
PCMD
ReadCmdAndKey (
    char * buf
    ) {

    WORD        i;
    EVTargs     e;
    PCMD        pCmd;
    EDITOR_KEY  k;

    do {
        if (!TypeAhead () ) {
            SetEvent( semIdle);
            k = TranslateKey (ReadChar ());
            WaitForSingleObject( semIdle, INFINITE);
        } else {
            k = TranslateKey (ReadChar ());
        }
        e.arg.key = k.KeyInfo;
    } while (DeclareEvent (EVT_RAWKEY, (EVTargs *)&e));

    if (i = k.KeyCode) {
        CodeToName (i, buf);
        pCmd = CodeCmdMap[i];
    } else {
	strcpy (buf, UnknownKey);
	pCmd = CMD_unassigned;
    }

    return pCmd;
}

//
//      No-op, provided for compatibility with other versions of Z, which do
//	not map the entire keyboard
//
flagType
noop (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
	argData; pArg; fMeta;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\graphic.c ===
/*** graphic.c - simple single character editing
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


struct cmdDesc cmdGraphic = {	"graphic",  graphic,	0, FALSE };

/*** graphic - Editor <graphic> function
*
* Purpose:
*   Inserts character in text at current cursor position. Delete
*   previously selected text if any.
*
* Input:
*   the usual
*
* Output:
*   TRUE if character successfully inserted (FALSE means line too long)
*
* Notes:
*
*************************************************************************/
flagType
graphic (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    delarg (pArg);
    return edit ( ((KEY_DATA *)&argData)->Ascii );

    fMeta;
}





/*** szEdit - insert a string at the current position.
*
* Purpose:
*   Inserts character in text at current cursor position.
*
* Input:
*   sz		= String to be entered
*
* Output:
*   FALSE if the line was too long, else true.
*
* Notes:
*
*************************************************************************/
flagType
szEdit (
    char *sz
    )
{
    while (*sz) {
        if (!edit (*sz++)) {
            return FALSE;
        }
    }
    return TRUE;
}





/*** edit
*
* Purpose:
*   Inserts character in text at current cursor position.
*
* Input:
*   c		= Character to be entered
*
* Output:
*   FALSE if the line was too long, else true.
*
* Notes:
*
*************************************************************************/
flagType
edit (
    char c
    )
{
    COL     dx;
    fl      fl;                             /* loc to place cursor at       */
    COL     tmpx;
    COL     x;

    /*
     * point at current location
     */
    fl.col = XCUR(pInsCur);
    fl.lin = YCUR(pInsCur);

    if (fWordWrap && xMargin > 0) {

        /*
         * if space entered just past right margin, then copy everything to the right
         * of the space to the next line.
         */
	if (c == ' ' && fl.col >= xMargin) {
	    tmpx = softcr ();
	    CopyStream (NULL, pFileHead, fl.col, fl.lin,
					 tmpx,	 fl.lin+1,
					 fl.col, fl.lin);
	    fl.lin++;
	    fl.col = tmpx;
	    cursorfl (fl);
	    return TRUE;
        } else if (fl.col >= xMargin + 5) {

	    /*	move backward to the beginning of the current word
	     *	and break it there.
	     *
	     *	Make sure we have a line that contains the cursor
	     */
            fInsSpace (fl.col, fl.lin, 0, pFileHead, buf);

	    /*	We'll go backwards to find the first place where
	     *	the char there is non-space and the char to
	     *	the left of it is a space.  We'll break the line at
	     *	that place.
	     */
            for (x = fl.col - 1; x > 1; x--) {
                if (buf[x-1] == ' ' && buf[x] != ' ') {
                    break;
                }
            }

	    /*	if we've found the appropriate word, break it there
	     */
	    if (x > 1) {
		dx = fl.col - x;
		tmpx = softcr ();
		CopyStream (NULL, pFileHead, x,    fl.lin,
					     tmpx, fl.lin + 1,
					     x,    fl.lin);
		fl.col = tmpx + dx;
		fl.lin++;
		cursorfl (fl);
            }
        }
    }

    if (Replace (c, fl.col, fl.lin, pFileHead, fInsert)) {
	right ((CMDDATA)0, (ARG *)NULL, FALSE);
	return TRUE;
    } else {
	LengthCheck (fl.lin, 0, NULL);
	return FALSE;
    }
}





/*** quote - Editor <quote> function
*
* Purpose:
*   Inserts character in text at current cursor position. Delete
*   previously selected text if any.
*
* Input:
*   the usual
*
* Output:
*   TRUE if character successfully inserted (FALSE means line too long)
*
*************************************************************************/
flagType
quote (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    char c;

    delarg (pArg);

    while ((c = (char)(ReadCmd()->arg)) == 0) {
        ;
    }
    return edit (c);

    argData; fMeta;
}




/*** delarg - deletes current selected area
*
* Purpose:
*   <graphic> and <quote> delete previously selected text. Here we do it
*
* Input:
*   pArg    pointer to current ARG structure
*
* Output:
*   None
*
* Notes:
*
*************************************************************************/
void
delarg (
    ARG * pArg
    )
{
    fl      fl;

    switch (pArg->argType) {

	case STREAMARG:
	    DelStream (pFileHead,
		       pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		       pArg->arg.streamarg.xEnd,   pArg->arg.streamarg.yEnd   );
	    fl.col = pArg->arg.streamarg.xStart;
	    fl.lin = pArg->arg.streamarg.yStart;
            break;

	case LINEARG:
	    DelLine (TRUE, pFileHead,
		     pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd);
	    fl.col = 0;
	    fl.lin = pArg->arg.linearg.yStart;
            break;

	case BOXARG:
	    DelBox (pFileHead,
		       pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
		       pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom);
	    fl.col = pArg->arg.boxarg.xLeft;
	    fl.lin = pArg->arg.boxarg.yTop;
	    break;

	default:
	    return;
    }
    cursorfl(fl);
}





/*** Replace - edit character in a file
*
* Purpose:
*   Replace will take the specified character and place it into the
*   specified position in the specified file.  If the edit is a NOP
*   (overstriking the same character) then no modification takes place
*
* Input:
*   c		character to edit in file
*   x, y	column, row of file to be changed
*   pFile	file being modified
*   fInsert	TRUE => character is inserted before the position
*
* Output:
*    TRUE => line was successfully edited, FALSE => line was too long
*
* Notes:
*
*************************************************************************/
flagType
Replace (
    char    c,
    COL     x,
    LINE    y,
    PFILE   pFile,
    flagType fInsert
    )
{
    linebuf buf;                             /* working buffer               */
    struct  lineAttr rgla[sizeof(linebuf)];
    flagType fColor = FALSE, fSpace = 0;
    char    *pxLog;

    fColor = GetColor (y, rgla, pFile);

    if (fInsSpaceColor (x, y, fInsert ? 1 : 0, pFile, buf, fColor ? rgla : NULL)) {

        pxLog = pLog (buf, x, TRUE);

        if (cbLog(buf) <= x) {

            /*
             * If the logical length of the buffer is less than what we need, then it was
             * at least space filled by fInsert, and we just need to append our character
             * to the buffer
             */

            *(unsigned int UNALIGNED *)pxLog = (unsigned int)(unsigned char)c;

        } else if (fInsert || (*pxLog != c)) {

            /*
             * if we're inserting, or the character we're overtyping is different, place
             * the character. Be sure to check the new logical length of the line as well,
             * in case it was a tab that overflowed it.
             */

            *pxLog = c;
            if (cbLog(buf) >= sizeof(linebuf)) {
                return FALSE;
            }
        }

        if (fInsert) {
            MarkCopyBox (pFile, pFile, x, y, sizeof(linebuf), y, x+1, y);
        }

        PutLine (y, buf, pFile);
        if (fColor) {
            ColorToLog (rgla, buf);
            PutColor (y, rgla, pFile);
        }
        return TRUE;
    }
    return FALSE;
}





/*** curdate, curday and curtime - editting functions
*
* Purpose:
*  insert current day/date/time into text being editted
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE if text entered.
*
*************************************************************************/
flagType
curdate (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  buf;
    time_t  ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    sprintf (buf, "%.2s-%.3s-%.4s", s+8, s+4, s+20);
    return szEdit (buf);

    argData; pArg; fMeta;
}




flagType
curday (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  buf;
    time_t  ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    sprintf (buf, "%.3s",s);
    return szEdit (buf);

    argData; pArg; fMeta;
}





flagType
curtime (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  buf;
    time_t  ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    sprintf (buf, "%.8s",s+11);
    return szEdit (buf);


    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\getstr.c ===
/*** getstr.c - text argument handler
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


#define ISWORD(c) (isalnum(c) || isxdigit(c) || c == '_' || c == '$')



/*** getstring - one line editor
*
*  This routine handles the entering and editting of single line responses
*  on the dialog line.
*
* Input:
*  pb	   = pointer to destination buffer for user's response
*  prompt  = pointer to prompt string
*  pFunc   = first editting function to process
*  flags   = GS_NEWLINE  entry must be terminated by newline, else any other
*			 non-recognized function will do.
*	     GS_INITIAL  entry is highlighted, and if first function is
*			 graphic, the entry is replaced by that graphic.
*	     GS_KEYBOARD entry must from the keyboard (critical situation ?)
*
* Output:
*  Returns pointer to command which terminated the entry
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
PCMD
getstring (
    char    *pb,
    int     cbpb,
    char    *prompt,
    PCMD    pFunc,
    flagType flags
    ) {

    flagType fMetaTextArg;

    int xbeg;
    int iRespCur;	/* current position in response */

    if ((iRespCur = strlen(pb)) == 0) {
        RSETFLAG(flags, GS_INITIAL);
    }
    memset ((char *) pb+iRespCur, '\0', cbpb - iRespCur);

    if (pFunc != NULL) {
	xbeg = flArg.col;
    } else {
	iRespCur = 0;
	xbeg = XCUR(pInsCur);
    }

    fMetaTextArg = fMeta;

    /*
     * main editing loop. [Re]Display entry line & process editting action.
     */
    while (TRUE) {
	ScrollOut (prompt, pb, iRespCur, TESTFLAG(flags, GS_INITIAL) ? hgColor : fgColor, (flagType) TESTFLAG (flags, GS_KEYBOARD));
	RSETFLAG (fDisplay, RCURSOR);
        if (pFunc == NULL) {
	    if ((pFunc = (TESTFLAG (flags, GS_KEYBOARD) ? ReadCmd () : zloop (FALSE))) == NULL) {
		SETFLAG (fDisplay, RCURSOR);
		break;
            }
        }
	SETFLAG (fDisplay, RCURSOR);


        if ((PVOID)pFunc->func == (PVOID)newline ||
              (PVOID)pFunc->func == (PVOID)emacsnewl) {
            //
            //  newline functions: if allowed, terminate, else not allowed
            //  at all
            //
            if (!TESTFLAG(flags, GS_NEWLINE)) {
		bell ();
            } else {
                break;
            }
        } else if ((PVOID)pFunc->func == (PVOID)graphic ||
              (PVOID)pFunc->func == (PVOID)quote) {
            //
            //  graphic functions: place the graphic character into the
            //  response buffer. If erasing default response, then remove it
            //  from buffer.
            //
	    if (TESTFLAG(flags, GS_INITIAL)) {
		iRespCur = 0;
                memset ((char *) pb, '\0', cbpb);
            }
            if (pFunc->func == quote) {
                while ((pFunc->arg = ReadCmd()->arg) == 0) {
                    ;
                }
            }
            if (fInsert) {
                memmove ((char*) pb+iRespCur+1, (char*)pb+iRespCur, cbpb-iRespCur-2);
            }
            pb[iRespCur++] = (char)pFunc->arg;
        } else if ((PVOID)pFunc->func == (PVOID)insertmode) {
            //
            //  insert command.
            //
	    insertmode (0, (ARG *) NULL, FALSE);
        } else if ((PVOID)pFunc->func == (PVOID)meta) {
            //
            //  meta command
            //
	    meta (0, (ARG *) NULL, FALSE);
        } else if ((PVOID)pFunc->func == (PVOID)left ||
              (PVOID)pFunc->func == (PVOID)cdelete ||
              (PVOID)pFunc->func == (PVOID)emacscdel) {
            //
            //  Cursor leftward-movement functions: update cursor position
            //  and optionally remove characters from buffer.
            //
	    if (iRespCur > 0) {
		iRespCur--;
                if ((PVOID)pFunc->func != (PVOID)left) {
                    if (fInsert) {
                        memmove ( (char*) pb+iRespCur, (char*) pb+iRespCur+1, cbpb-iRespCur);
                    } else if (!pb[iRespCur+1]) {
			pb[iRespCur] = 0;
                    } else {
                        pb[iRespCur] = ' ';
                    }
                }
            }
        } else if ((PVOID)pFunc->func == (PVOID)right) {
            //
            //  Cursor right movement functions: update cursor position, and
            //  possibly get characters from current display.
            //
	    if (pFileHead && pb[iRespCur] == 0) {
		fInsSpace (xbeg+iRespCur, YCUR(pInsCur), 0, pFileHead, buf);
		pb[iRespCur] = buf[xbeg+iRespCur];
		pb[iRespCur+1] = 0;
            }
            iRespCur++;
        } else if ((PVOID)pFunc->func == (PVOID)begline ||
              (PVOID)pFunc->func == (PVOID)home) {
            //
            //  Home function: update cursor position
            //
	    iRespCur = 0;
        } else if ((PVOID)pFunc->func == (PVOID)endline) {
            //
            //  End function: update cursor position
            //
            iRespCur = strlen (pb);
        } else if ((PVOID)pFunc->func == (PVOID)delete ||
              (PVOID)pFunc->func == (PVOID)sdelete) {
            //
            //  Delete function: remove character
            //
            memmove ( (char*) pb+iRespCur, (char*) pb+iRespCur+1, cbpb-iRespCur);
        } else if ((PVOID)pFunc->func == (PVOID)insert ||
              (PVOID)pFunc->func == (PVOID)sinsert) {
            //
            //  Insert function: insert space
            //
            memmove ( (char*) pb+iRespCur+1, (char*) pb+iRespCur, cbpb-iRespCur-1);
            pb[iRespCur] = ' ';
        } else if((PVOID)pFunc->func == (PVOID)doarg) {
            //
            //  Arg function: clear from current position to end
            //  of response.
            //
            memset ((char *) pb+iRespCur, '\0', cbpb - iRespCur);
        } else if ((PVOID)pFunc->func == (PVOID)pword) {
            //
            //  Pword function: mive roght until the char to the left of
            //  the cursor is not part of a word, but the char under the
            //  cursor is.
            //
	    while (pb[iRespCur] != 0) {
		iRespCur++;
                if (!ISWORD (pb[iRespCur-1]) && ISWORD (pb[iRespCur])) {
                    break;
                }
            }
        } else if ((PVOID)pFunc->func == (PVOID)mword) {
            //
            //  Mword function
            //
            while (iRespCur > 0) {
		if (--iRespCur == 0 ||
                    (!ISWORD (pb[iRespCur-1]) && ISWORD (pb[iRespCur]))) {
                    break;
                }
            }
        } else if (TESTFLAG (pFunc->argType, CURSORFUNC)) {
            //
            //  Other cursor movement function: not allowed, so beep.
            //
            bell ();
        } else {
            //
            //  All other functions: if new line required to terminate,
            //  then beep, otherwise terminate and return the
            //  function terminated with.
            //
            if ((PVOID)pFunc != (PVOID)NULL) {
                if (TESTFLAG(flags, GS_NEWLINE) && (PVOID)pFunc->func != (PVOID)cancel) {
		    bell ();
                } else {
                    break;
                }
            }

        }
	/*
	 * process here to truncate any potential buffer overruns
	 */
        if (!TESTFLAG(pFunc->argType, KEEPMETA)) {
            fMeta = FALSE;
        }
	pFunc = NULL;
        if (iRespCur > cbpb - 2) {
            iRespCur = cbpb - 2;
	    pb[iRespCur+1] = 0;
	    bell ();
        }
	RSETFLAG(flags, GS_INITIAL);
    }

    fMeta = fMetaTextArg ^ fMeta;
    return pFunc;
}




/*** ScrollOut - Update dialog line
*
*  Place a prompt, and a portion of the users response, onto the dialog of the
*  screen. Update the cursor position to the requested position relative to
*  the begining of the users response. Always ensure that that cursor position
*  is within the text actually displayed.
*
* Input:
*  szPrompt	- Text of prompt
*  szResp	- Text of users response
*  xCursor	- Current X position within reponse that is to get cursor
*  coResp	- Color to display response as
*  fVisible	- Forces display
*
* Globals:
*  hscroll	- Horizontal scroll amount
*  infColor	- Color that prompt will be displayed with
*  slSize	- Version 1 only, contains line on screen for output.
*
* Output:
*  Dialog line updated.
*
*************************************************************************/
void
ScrollOut (
    char     *szPrompt,                      /* prompt text                  */
    char     *szResp,                        /* users response string        */
    int      xCursor,                        /* Current pos w/in response    */
    int      coResp,                         /* response color               */
    flagType fVisible                        /* force display                */
    ) {

    int     cbPrompt;			/* length of the prompt string	*/
    int     cbResp;			/* length of the text displayed */
    int     cbDisp;			/* This position must be disp'd */
    int     xOff;			/* offset of string trailer	*/

#define LXSIZE	 XSIZE

    if (!mtest () || mlast () || fVisible) {
	cbPrompt = strlen (szPrompt);
        cbResp   = strlen (szResp);

	/*
	 * The distance of the new cursor position is calculated from the
	 * left edge of the text to be displayed. If there is more text
	 * than there is window, we also adjust the left edge based on hscroll.
	 */
        if (xOff = max (xCursor - (LXSIZE - cbPrompt - 1), 0)) {
            xOff += hscroll - (xOff % hscroll);
        }

        cbDisp = min (LXSIZE-cbPrompt, cbResp-xOff);

	/*
	 * output the prompt, the reponse string in the requested color,
	 * if required blank what's left, and finally update the cursor
	 * position.
	 */
	vout (0, YSIZE, szPrompt, cbPrompt, infColor);
        vout (cbPrompt, YSIZE, (char *)(szResp + xOff), cbDisp, coResp);
        if (cbPrompt + cbDisp < LXSIZE) {
            voutb (cbPrompt + cbDisp, YSIZE, " ", 1, fgColor);
        }
        consoleMoveTo( YSIZE, xCursor-xOff+cbPrompt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\hilite.c ===
/*** hilite.c - editor multiple-file highlighting support
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains the common code to maintain multiple highlighted regions across
*   multiple files.
*
* Highlighting Overview
*
*   Each pFile contains a vm pointer to a linked list of blocks each of which
*   contain up to RNMAX ranges in the file currently highlighted. The ranges
*   are maintained in order of the first coordinate of the range (see below),
*   though they may overlap. Each block may not be completely full, due to the
*   insertion algorithm which maintains the order.
*
*		      +---------------+   +---------------+   +---------------+
*   pFile->vaHiLite-->|vaNext	      |-->|vaNext	  |-->|-1L	      |
*		      +---------------+   +---------------+   +---------------+
*		      |irnMac	      |   |irnMac	  |   |irnMac	      |
*		      +---------------+   +---------------+   +---------------+
*		      |rnHiLite[RNMAX]|   |rnHiLite[RNMAX]|   |rnHiLite[RNMAX]|
*		      +---------------+   +---------------+   +---------------+
*
*   Clearing all current highlighting for a file simply involves deallocating
*   the list of highlight ranges.
*
*   Adding a highlight region either updates an existing region (if the start
*   points are the same, and the new end point is the same in one direction and
*   greater in the other), or insertion of a new range in the sorted list. If
*   a block is full, when asertion is attempted in that block, the block will
*   be split in half, and a new block inserted into the linked list.
*
*   Each range is "normally" an ordered pair of coordinates (a range, or rn)
*   specifying the range of the file to be hilighted. However, Arg processing
*   always specifies that the first coordinate of this pair is the location at
*   which the user hit ARG, and the second is the travelling corrdinate as he
*   specifies the region on screen. For this reason, if the x coordinates are
*   in reverse order, the right-most coordinate is decremented by one to
*   reflect the correct highlighting for arguments.
*
*
* Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "z.h"

#define RNMAX	20			/* max number of rns per block	*/
					/* MUST BE EVEN 		*/

/*
 * HiLiteBlock - block of highlighting information as kept in VM
 */
struct HiLiteBlock {
    PVOID   vaNext;                     /* va of next block, or -1      */
    int     irnMac;			/* number of rns in block	*/
    rn	    rnHiLite[RNMAX];		/* ranges with highlighting	*/
    char    coHiLite[RNMAX];		/* colors to be used		*/
    };



/*** SetHiLite - Mark a range in a file to be highlighted
*
*  Marks the specfied range in a file as needing to be highlighted. The next
*  time that portion of the file is updated on screen, the highlighting
*  attributes will be applied.
*
* Input:
*  pFile	= file to be highlighted
*  rnCur	= Range to be highlighted
*  coCur	= Color to use for highlighting
*
* Output:
*
*************************************************************************/
void
SetHiLite (
    PFILE   pFile,
    rn      rnCur,
    int     coCur
    ) {

    struct HiLiteBlock	hbCur;		 /* block being worked on	 */
    int 		irnCur; 	 /* index into block		 */
    PVOID               vaCur;           /* va of current block          */
    PVOID               vaNew;           /* va of new split block        */
    PVOID               vaNext;          /* va of next block             */

    /*
     * If the file does not yet have one, allocate the first highlight block
     */
    if (pFile->vaHiLite == (PVOID)(-1L)) {
	irnCur = 0;
        hbCur.vaNext = (PVOID)(-1L);
	hbCur.irnMac = 0;
        vaCur = pFile->vaHiLite = MALLOC ((long)sizeof(hbCur));
    } else {
	vaCur = pFile->vaHiLite;
	while (1) {
            // rjsa VATopb (vaCur, (char *)&hbCur, sizeof(hbCur));
            memmove((char *)&hbCur, vaCur, sizeof(hbCur));
	    assert (hbCur.irnMac <= RNMAX);

	    /*
	     * search contents of current block for first range which occurs on
	     * the same or a later position than the new one.
	     */
	    for (irnCur = 0; irnCur<hbCur.irnMac; irnCur++) {
                if (hbCur.rnHiLite[irnCur].flFirst.lin > rnCur.flFirst.lin) {
                    break;
                }
		if (   (hbCur.rnHiLite[irnCur].flFirst.lin == rnCur.flFirst.lin)
                    && (hbCur.rnHiLite[irnCur].flFirst.col >= rnCur.flFirst.col)) {
                    break;
                }
            }
	    /*
	     * if we found something, exit the search, else move to next block,
	     * if there is one.
	     */
            if (irnCur != hbCur.irnMac) {
                break;
            }
            if (hbCur.vaNext == (PVOID)(-1L)) {
                break;
            }
            vaCur = hbCur.vaNext;
        }
    }

    /*
     * vaCur = va of block needing insertion/modification
     * irnCur = index of rn for same or later position
     * hbCur = contents of block last read
     *
     * if irnCur<RNMAX we operate on the current block, else we allocate a
     * new one, link it to the list, and place our new highlighted region
     * in it.
     */
    if (irnCur >= RNMAX) {
        hbCur.vaNext = MALLOC ((long)sizeof(hbCur));
        // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
        memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
        vaCur = hbCur.vaNext;
        hbCur.vaNext = (PVOID)(-1L);
		hbCur.irnMac = 1;
		hbCur.rnHiLite[0] = rnCur;
        // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
        memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
	return;
    }

    /*
     * If the upper first coordinate matches, and one of the second coordinates
     * then just update the second.
     */
    if (   (irnCur >= 0)
	&& (   (hbCur.rnHiLite[irnCur].flFirst.lin == rnCur.flFirst.lin)
	    && (hbCur.rnHiLite[irnCur].flFirst.col == rnCur.flFirst.col))
	&& (   (hbCur.rnHiLite[irnCur].flLast.lin == rnCur.flLast.lin)
	    || (hbCur.rnHiLite[irnCur].flLast.col == rnCur.flLast.col))
	&& (hbCur.coHiLite[irnCur] == (char)coCur)
	) {

	/*
	 * If the columns have changed, redraw the entire range (only the columns
	 * changed, but on all lines), otherwise just redraw those lines which
	 * have changed.
	 */
        if (hbCur.rnHiLite[irnCur].flLast.col != rnCur.flLast.col) {
            redraw (pFile,rnCur.flFirst.lin,rnCur.flLast.lin);
        } else {
            redraw (pFile,hbCur.rnHiLite[irnCur].flLast.lin,rnCur.flLast.lin);
        }
	hbCur.rnHiLite[irnCur].flLast = rnCur.flLast;
    } else {
	redraw (pFile,rnCur.flFirst.lin,rnCur.flLast.lin);

	/*
	 * if the block to be modified is full, then split it into two blocks.
	 */
	if (hbCur.irnMac == RNMAX) {
	    hbCur.irnMac = RNMAX/2;
	    vaNext = hbCur.vaNext;
            vaNew = hbCur.vaNext = MALLOC ((long)sizeof(hbCur));
            // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
            memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
	    memmove ((char *)&hbCur.rnHiLite[0],
		 (char *)&hbCur.rnHiLite[RNMAX/2]
		 ,(RNMAX/2)*sizeof(rn));
	    memmove ((char *)&hbCur.coHiLite[0],
		 (char *)&hbCur.coHiLite[RNMAX/2]
		 ,(RNMAX/2)*sizeof(char));
	    hbCur.vaNext = vaNext;
            // rjsa pbToVA ((char *)&hbCur, vaNew, sizeof(hbCur));
            memmove(vaNew, (char *)&hbCur, sizeof(hbCur));

	    /*
	     * select which of the two blocks (vaCur, the first half; or vaNew,
	     * the second) to operate on. ReRead the old block if required.
	     */
	    if (irnCur >= RNMAX/2) {
		vaCur = vaNew;
		irnCur -= RNMAX/2;
            } else {
                //rjsa VATopb (vaCur, (char *)&hbCur, sizeof(hbCur));
                memmove((char *)&hbCur, vaCur, sizeof(hbCur));
            }
        }

	/*
	 * Move the rn's that follow where we want to be, up by one,
	 * and insert ours.
	 */
        if (irnCur < hbCur.irnMac) {
	    memmove ((char *)&hbCur.rnHiLite[irnCur+1],
		 (char *)&hbCur.rnHiLite[irnCur]
                 ,(hbCur.irnMac - irnCur)*sizeof(rn));
        }
	memmove ((char *)&hbCur.coHiLite[irnCur+1],
	     (char *)&hbCur.coHiLite[irnCur]
	     ,(hbCur.irnMac - irnCur));
	hbCur.rnHiLite[irnCur] = rnCur;
	hbCur.coHiLite[irnCur] = (char)coCur;
	hbCur.irnMac++;
    }

    /*
     * update the block in vm
     */
    // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
    memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
}



/*** ClearHiLite - remove all highlighting from a file
*
*  Removes all highlighting information for a file, and marks those lines
*  affected as needing to be redrawn.
*
* Input:
*  pFile	= file affected.
*  fFree	= TRUE => free the VM used
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
ClearHiLite (
    PFILE   pFile,
    flagType fFree
    ) {

	struct HiLiteBlock	*hbCur, *hbNext;
    int 		irn;

	while (pFile->vaHiLite != (PVOID)(-1L)) {

		hbCur = ( struct HiLiteBlock *)(pFile->vaHiLite );

		assert (hbCur->irnMac <= RNMAX);

		/*
		 * for each of the highlight ranges in the block, mark the lines as
		 * needing to be redrawn, so that highlighting will be removed from
		 * the screen.
		 */
		for (irn = hbCur->irnMac; irn; ) {
			irn--;
			redraw (pFile
					,hbCur->rnHiLite[irn].flFirst.lin
					,hbCur->rnHiLite[irn].flLast.lin
					);
		}

		/*
		 * discard the vm used by the block, and point at the next block in
		 * the chain
		 */
		hbNext = hbCur->vaNext;
        if (fFree) {
            FREE(pFile->vaHiLite);
        }
		pFile->vaHiLite = hbNext;
    }
}



/*** UpdHiLite - Update a color buffer with highlighting information
*
*  Apply all highlighting ranges that apply to a particluar portion
*  of a line in a file to a color buffer. Ensure that areas outside
*  the highlight range are unaffected, and that areas within are
*  updated appropriately.
*
* Input:
*  pFile	= File being operated on
*  lin		= line
*  colFirst	= first col
*  colLast	= last col
*  ppla 	= Pointer to Pointer to lineattr array to be updated
*
* Output:
*  Returns TRUE if highlighting occurred.
*
*************************************************************************/
flagType
UpdHiLite (
    PFILE             pFile,
    LINE              lin,
    COL               colFirst,
    COL               colLast,
    struct lineAttr **ppla
    ) {

	struct HiLiteBlock	*hbCur;		 /* block being worked on	 */
    PVOID               vaCur;           /* va of current block          */
    int 		irnCur; 	 /* index into block		 */

    COL 		colHiFirst;
    COL 		colHiLast;
    COL 		colHiTmp;

    COL 		col;
    struct lineAttr    *pla;

    flagType		fRv = FALSE;	 /* highlighting occurred	 */

    /*
     * First we scroll it to the left (if needed)
     */
    if (colFirst) {
	for (col = 0, pla = *ppla;
	     col + pla->len <= colFirst;
             col += pla++->len) {
            ;
        }

        if (col < colFirst && pla->len != 0xff) {
            pla->len -= (unsigned short) (colFirst - col);
        }

	/*
	 * Take care here we modify THEIR pointer
	 */
	*ppla = pla;
    }

    /*
     * for all blocks of hiliting info
     */
    vaCur = pFile->vaHiLite;
	while (vaCur != (PVOID)(-1L)) {

		/*
		 * get block
		 */
		hbCur = (struct HiLiteBlock *)vaCur;
		assert (hbCur->irnMac <= RNMAX);

		/*
		 * for each range within the block
		 */
		for (irnCur = 0; irnCur<hbCur->irnMac; irnCur++) {
			/*
			 * is the range affecting the line we're looking for ?
			 */
			if (fInRange (hbCur->rnHiLite[irnCur].flFirst.lin
						 ,lin
						 ,hbCur->rnHiLite[irnCur].flLast.lin)) {

				/*
				 * Watch out: range coordinates might be inversed
				 */
				if (  (colHiFirst = hbCur->rnHiLite[irnCur].flFirst.col)
					> (colHiLast  = hbCur->rnHiLite[irnCur].flLast.col)) {

					colHiTmp   = colHiFirst - 1;
					colHiFirst = colHiLast;
					colHiLast  = colHiTmp;
                }


				/*
				 * is the range affecting the portion of line we're looking for ?
				 */
				if (!(colHiLast < colFirst || colHiFirst > colLast)) {
					/*
					 * Yes: signals work done and do the hilite
					 */
					fRv = TRUE;
					UpdOneHiLite (*ppla
								,max(colFirst, colHiFirst) - colFirst
								,min(colLast,	colHiLast ) - max(colFirst, colHiFirst) + 1
								,TRUE
								,(int) hbCur->coHiLite[irnCur]);
                }
            }
        }
		vaCur = hbCur->vaNext;
    }
    return fRv;
}



/*** UpdOneHiLite - Update the highlighting on one line of attributes
*
*  Modifies an existing attribute line to include highlighting.
*
* Input:
*  pla		   = Pointer to attribute information for line
*  colFirst	   = Starting column
*  colLast	   = Ending column
*  fattr (CW only) = TRUE: attr is color index
*		     FALSE: attr is pointer to lineAttr array
*  attr 	   = color index or pointer to lineAttr array to be used
*
* Output:
*  *pla updated
*
*************************************************************************/
void
UpdOneHiLite (
    struct lineAttr *pla,
    COL              colFirst,
    COL              len,
    flagType         fattr,
    INT_PTR          attr
    ) {

    struct lineAttr *plaFirstMod;   /* pointer to first cell to be modified    */
    struct lineAttr *plaLastMod;    /* pointer to last cell to be modified     */
    COL		     colLast = colFirst + len - 1;
    COL 	     colFirstMod;   /* starting column for first modified cell */
    COL 	     colLastMod;    /* starting column for last modified cell  */

    struct lineAttr *plaSrc;	    /* source pointer for moving cells	       */
    struct lineAttr *plaDst;	    /* destination pointer for moving cells    */
    struct lineAttr *plaSrcSav;     /* temporary pointer		       */

    struct lineAttr *plaExt;	    /* pointer to external array of lineAttr   */
    COL 	     colSrc;
    COL 	     colSrcEnd;

    struct lineAttr  rglaTmp[3];    /* buffer for creating cells	       */
    int 	     claTmp = 0;    /* number of cells to insert	       */

    /*
     * First we Find the first cell that will be affected by the change
     */
    for (colFirstMod = 0, plaFirstMod = pla;
	 colFirstMod + plaFirstMod->len <= colFirst;
         colFirstMod += plaFirstMod++->len) {
        ;
    }

    /*
     * Next we find the last cell that will be affected by the change
     */
    for (colLastMod = colFirstMod, plaLastMod = plaFirstMod;
	 colLastMod + plaLastMod->len <= colLast;
         colLastMod += plaLastMod++->len) {
        ;
    }

    /*
     * If the first affected cell doesn't start on our boundary, let's
     * create a new cell to be inserted
     */
    if (colFirstMod < colFirst) {
	rglaTmp[0].len	= (unsigned char) (colFirst - colFirstMod);
	rglaTmp[0].attr = plaFirstMod->attr;
	claTmp++;
    } else {
        rglaTmp[0].len = 0;
    }

    if (fattr) {
	/*
	 * Only one color for the updated range: we always create
	 * the cell of new color
	 */
	rglaTmp[1].len	= (unsigned char) (colLast - colFirst + 1);
	rglaTmp[1].attr = (unsigned char) attr;
	claTmp++;
    } else {
	/*
	 * Colors for the updated range come from an array of lineAttr
	 * We first get its address (this is a hack because 16 bit pointer
	 * can be cast to an int)
	 */
	plaExt = (struct lineAttr *) attr;

	/*
	 * Count the number of cells to copy.
	 */
	for (plaSrc = plaExt, colSrc = 0, colSrcEnd = colLast - colFirst + 1;
	     colSrc + plaSrc->len <= colSrcEnd;
             colSrc += plaSrc++->len, claTmp++) {
            ;
        }

	/*
	 * Build trailing cell if needed
	 */
	if (colSrc < colSrcEnd) {
            rglaTmp[1].len  = (unsigned char) (colSrcEnd - colSrc);
	    rglaTmp[1].attr = (unsigned char) plaSrc->attr;
	    claTmp++;
        } else {
            rglaTmp[1].len = 0;
        }
    }

    /*
     * If the last affected cell doesn't end on our boundary, we
     * create a new cell to be inserted. We take care of the final
     * cell.
     */
    if (colLastMod + plaLastMod->len > colLast + 1) {
        rglaTmp[2].len = (unsigned short) ((plaLastMod->len == 0xffff) ?
            0xffff :
	    colLastMod + (int) plaLastMod->len - colLast - 1);
	rglaTmp[2].attr = plaLastMod->attr;
	claTmp++;
    } else {
        rglaTmp[2].len = 0;
    }

    /*
     * Then we move the info tail to its new place if needed
     *
     * UNDONE: Here we could use Move() instead of copying cell by cell
     */
    if (plaLastMod->len != 0xffff) {
	plaDst = plaFirstMod + claTmp;
	plaSrc = plaLastMod + 1;
        if (plaDst < plaSrc) {
	    do {
		*plaDst++ = *plaSrc;
            } while (plaSrc++->len != 0xffff);
        } else {
            for (plaSrcSav = plaSrc; plaSrc->len != 0xffff; plaSrc++) {
                ;
            }
	    plaDst += plaSrc - plaSrcSav;
	    do {
		*plaDst-- = *plaSrc--;
            } while (plaSrc >= plaSrcSav);
        }
    }

    /*
     * Finally insert the created cells
     */
    for (plaDst = plaFirstMod, claTmp = 0; claTmp < 3; claTmp++) {
        if (claTmp == 1 && !fattr) {
	    /*
	     * UNDONE: Here we could use Move() instead of copying cell by cell
	     */
	    for (plaSrc = plaExt, colSrc = 0, colSrcEnd = colLast - colFirst + 1;
		 colSrc + plaSrc->len <= colSrcEnd;
                 plaDst++, colSrc += plaSrc++->len) {
                *plaDst = *plaSrc;
            }
        }
        if (rglaTmp[claTmp].len) {
            *plaDst++ = rglaTmp[claTmp];
        }
    }
}





/*** rnOrder - ensure that a range is in correct first/last order
*
*  Ensure that a range is in correct first/last order
*
* Input:
*  prn		= Pointer to range
*
* Output:
*  *prn updated
*
*************************************************************************/
void
rnOrder (
    rn      *prn
    ) {

    rn	    rnTmp;

    rnTmp.flFirst.lin = lmin (prn->flFirst.lin, prn->flLast.lin);
    rnTmp.flLast.lin  = lmax (prn->flFirst.lin, prn->flLast.lin);
    rnTmp.flFirst.col = min (prn->flFirst.col, prn->flLast.col);
    rnTmp.flLast.col  = max (prn->flFirst.col, prn->flLast.col);

    *prn = rnTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\lang.c ===
/*** lang.c - Language dependent routines
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#include "z.h"

typedef int ( __cdecl *STRCMP) (const char *, const char *);


/* return index+1 of first string s that is in table */
int
tblFind (
    char * tbl[],
    char * s,
    flagType fCase
    )
{
    int    i;
    STRCMP f;

    f = fCase ? (STRCMP)FNADDR(strcmp) : (STRCMP)FNADDR(_stricmp);
    for (i=0; tbl[i]; i++) {
        if (!(*f) (tbl[i], s)) {
            return i+1;
        }
    }
    return 0;
}




flagType
parseline (
    char *pbuf,
    char **ppbegtok,
    char **ppendtok
    ) {

    char *p1, *p2;

    p1 = whiteskip (pbuf);
    if (!*p1) {
	return FALSE;
    } else if (*(p2 = whitescan (p1))) {
	*p2++ = 0;
	p2 += strlen( p2 ) - 1;
	while (*p2)
            if (*p2 == ' ') {
		break;
            } else {
                p2--;
            }
        if (!*++p2) {
            p2 = NULL;
        }
    } else {
        p2 = NULL;
    }
    *ppbegtok = p1;
    *ppendtok = p2;
    return TRUE;
}




//
// csoftcr - perform C soft CR processing.
//
// Algorithm:
//  Given that you have just entered a newline at the end of a line:
//      If the original line begins with "}", tab back once.
//      else If the original line ends with "{" or begins with a C keyword, tab
//           in once.
//      else If the line >preceding< the original line >doen't< end with "{"
//           but does begin with a C keyword, tab back once.
//
//  C keywords used are: if, else, for, while, do, case, default.
//
int
csoftcr (
    COL  x,
    LINE y,
    char *pbuf
    ) {

    char *pbeg, *pend;

    if (parseline (pbuf, &pbeg, &pend)) {
        if (*pbeg == '}') {
	    return dobtab (x);
        } else if ( (pend && *pend == '{' ) || tblFind (cftab, pbeg, TRUE ) ) {
	    return doftab (x);
        } else if (y) {
	    GetLineUntabed (y-1, pbuf, pFileHead);
            if (parseline (pbuf, &pbeg, &pend)) {
                if ( !(pend && *pend == '{') && tblFind (cftab, pbeg, TRUE) ) {
                    return dobtab (x);
                }
            }
        }
    }
    return -1;
}




//
// softcr - perform semi-intelegent indenting.
//
// Algorithm:
//  Given that you have just entered a newline at the end of a line:
//      Move to the first non-blank position on the line.
//      If a C file, attempt to get new x position.
//      If not found, move to the first non-blank position on the following
//          line.
//      If that line was blank, stay in the original first non-blank position.
//
int
softcr (
    void
    ) {

    linebuf pbuf;
    char *p;
    int x1, x2;


    if (!fSoftCR) {
        return 0;
    }

    GetLineUntabed (YCUR(pInsCur), pbuf, pFileHead);

    if (*(p=whiteskip(pbuf)) == 0) {
        p = pbuf;
    }
    x1 = (int)(p - pbuf);

    switch (FTYPE(pFileHead)) {

    case CFILE:
	x2 = csoftcr (x1, YCUR(pInsCur), pbuf);
        break;

    default:
	x2 = -1;
        break;

    }

    if (x2 >= 0) {
        return x2;
    }

    GetLineUntabed (YCUR(pInsCur)+1, pbuf, pFileHead);
    if (pbuf[0] != 0) {
        if (*(p=whiteskip (pbuf)) != 0) {
            return (int)(p - pbuf);
        }
    }
    return x1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\keyboard.c ===
#include    "z.h"

void
InitKeyboard (
    void
    ) {

    KBDMODE    Mode;

    Mode = CONS_ENABLE_ECHO_INPUT | CONS_ENABLE_WINDOW_INPUT | CONS_ENABLE_MOUSE_INPUT ;
    consoleSetMode(Mode);
}



void
KbHook (
    void
    ){

	KBDMODE Mode = OriginalScreenMode & ~(CONS_ENABLE_LINE_INPUT | CONS_ENABLE_PROCESSED_INPUT | CONS_ENABLE_ECHO_INPUT );
	consoleSetMode(Mode);
	consoleFlushInput();
}



void
KbUnHook (
    void
	){

	consoleSetMode(OriginalScreenMode);
}




KBDMODE
KbGetMode (
    void
    ){

    KBDMODE Mode;

	consoleGetMode(&Mode);
    return Mode;
}



void
KbSetMode (
    KBDMODE Mode
    ){

	consoleSetMode(Mode);
}



BOOL
TypeAhead (
    void
    ) {
	return consoleIsKeyAvailable();
}





KBDKEY
ReadChar (
    void
    ) {

	KBDKEY	kbdi;
	consoleGetKey(&kbdi, TRUE);
	return kbdi;
}



void
GetScreenSize (
    int*    pYsize,
    int*    pXsize
    ) {

    SCREEN_INFORMATION  ScreenInformation;
    consoleGetScreenInformation( ZScreen, &ScreenInformation );
    *pYsize = (int)(ScreenInformation.NumberOfRows);
	*pXsize = (int)(ScreenInformation.NumberOfCols);

}




flagType
SetScreenSize (
    int     YSize,
    int     XSize
    ) {

	if (consoleSetScreenSize( ZScreen, YSize, XSize)) {
		return TRUE;
	}
	return FALSE;
}    




void
SetVideoState (
    int     handle
    ) {

    consoleClearScreen(ZScreen, TRUE);

    handle;
}    







void
SaveScreen (
    void
    ) {
    consoleSetCurrentScreen(ZScreen);
}




void
RestoreScreen (
    void
    ) {
    consoleSetCurrentScreen(OriginalScreen);
}



void
WindowChange (
	ROW 	Rows,
	COLUMN	Cols
	)
{

	char bufLocal[2];

	if ( (cWin > 1) && (( Rows > (ROW)(YSIZE+2) ) || ( Cols > (COLUMN)(XSIZE) )) ) {
		//
		//	Won't allow to grow the screen if we have more than one window.
		//
		consoleSetScreenSize(ZScreen, YSIZE+2, XSIZE );
		disperr (MSG_ASN_WINCHG);
		return;
	}

        if ( Rows == (ROW)YSIZE+3 ) {
                     //
                     //      Erase the status line.
                     //

                     bufLocal[0] = ' ';
                     bufLocal[1] = '\0';
                     soutb(0, YSIZE+1, bufLocal, fgColor);
             }

	YSIZE = Rows-2;
	XSIZE = Cols;
	// LeaveCriticalSection( &ScreenCriticalSection );
	SetScreen();
	Display();
}


/*	SetCursorSize - set the cursor size
 *
 */
char *
SetCursorSizeSw (
    char *val
    )
{
	int 	i;
	buffer	tmpval;

    strcpy ((char *) tmpval, val);

    i = atoi (tmpval);

	if (i != 0 && i != 1) {
		return "CursorSize: Value must be 0 or 1";
    }

	CursorSize = i;

	return SetCursorSize( CursorSize );

}


char *
SetCursorSize (
	int Size
    )
{
	ULONG	CursorStyle;

	if ( Size == 0 ) {
		CursorStyle = CURSOR_STYLE_UNDERSCORE;
	} else {
		CursorStyle = CURSOR_STYLE_BOX;
	}

	if ( !consoleSetCursorStyle( ZScreen, CursorStyle ) ) {
		return "CursorSize: Cannot set Cursor size";
	}

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\ldelete.c ===
/*** LDELETE.C
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"

flagType
ldelete (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    fl      fl;
    int     l;

    if (pArg->argType == STREAMARG) {
        StreamToBox (pArg);
    }

    switch (pArg->argType) {

    case NOARG:
        if (!fMeta) {
            pick (0, pArg->arg.noarg.y, 0, pArg->arg.noarg.y, LINEARG);
        }
	DelLine (TRUE, pFileHead, pArg->arg.noarg.y, pArg->arg.noarg.y);
	break;

    case NULLARG:
	l = LineLength (pArg->arg.nullarg.y, pFileHead);
        if (!fMeta) {
	    pick (min (l, pArg->arg.nullarg.x),   pArg->arg.nullarg.y,
		  max (l, pArg->arg.nullarg.x)-1, pArg->arg.nullarg.y,
                  BOXARG);
        }
	DelBox (pFileHead, min (l, pArg->arg.nullarg.x),   pArg->arg.nullarg.y,
			   max (l, pArg->arg.nullarg.x)-1, pArg->arg.nullarg.y);
	return TRUE;

    case LINEARG:
        if (!fMeta) {
	    pick (0, pArg->arg.linearg.yStart,
                  0, pArg->arg.linearg.yEnd, LINEARG);
        }
	DelLine (TRUE, pFileHead, pArg->arg.linearg.yStart,
				  pArg->arg.linearg.yEnd);
	fl.col = pInsCur->flCursorCur.col;
	fl.lin = pArg->arg.linearg.yStart;
	cursorfl (fl);
	break;

    case BOXARG:
        if (!fMeta) {
	    pick (pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
                  pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom, BOXARG);
        }
	DelBox (pFileHead, pArg->arg.boxarg.xLeft,    pArg->arg.boxarg.yTop,
			   pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom);
	fl.col = pArg->arg.boxarg.xLeft;
	fl.lin = pArg->arg.boxarg.yTop;
	cursorfl (fl);
	break;

    default:
	return FALSE;
    }
    return TRUE;

    argData;
}




/*** StreamToBox - Convert a stream arg to a box/line arg
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
StreamToBox (
    ARG * pArg
    ) {

    ARG arg;

    arg = *pArg;

    if (arg.arg.streamarg.xStart == arg.arg.streamarg.xEnd) {
        pArg->argType = LINEARG;

        pArg->arg.linearg.yStart = arg.arg.streamarg.yStart;
        pArg->arg.linearg.yEnd   = arg.arg.streamarg.yEnd;
    } else {
        pArg->argType = BOXARG;

        pArg->arg.boxarg.yTop    = arg.arg.streamarg.yStart;
        pArg->arg.boxarg.yBottom = arg.arg.streamarg.yEnd;

        if (arg.arg.streamarg.xEnd > arg.arg.streamarg.xStart) {
            pArg->arg.boxarg.xLeft  = arg.arg.streamarg.xStart;
            pArg->arg.boxarg.xRight = arg.arg.streamarg.xEnd - 1;
        } else {
            pArg->arg.boxarg.xLeft  = arg.arg.streamarg.xEnd;
            pArg->arg.boxarg.xRight = arg.arg.streamarg.xStart -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\linsert.c ===
/*** linsert.c - line insert
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#include "z.h"


flagType
linsert (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    linebuf lbuf;
    int l;

    if (pArg->argType == STREAMARG) {
        StreamToBox (pArg);
    }

    switch (pArg->argType) {
    case NOARG:
	CopyLine (NULL, pFileHead, pArg->arg.noarg.y, pArg->arg.noarg.y,
				   pArg->arg.noarg.y);
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	GetLine (pArg->arg.nullarg.y, lbuf, pFileHead);
	strcpy (lbuf, whiteskip (lbuf));
	l = strlen (lbuf) + 1;
        if (l + pArg->arg.nullarg.x > sizeof(linebuf)) {
            LengthCheck (pArg->arg.nullarg.y, 0, NULL);
        }
	memmove ((char *) lbuf + pArg->arg.nullarg.x,(char *) lbuf, 
	      sizeof(linebuf) - l - pArg->arg.nullarg.x);
	memset ((char *) lbuf, ' ', pArg->arg.nullarg.x);
	PutLine (pArg->arg.nullarg.y, lbuf, pFileHead);
        return TRUE;

    case LINEARG:
	CopyLine (NULL, pFileHead, pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd,
				   pArg->arg.linearg.yStart);
        return TRUE;

    case BOXARG:
	CopyBox (NULL, pFileHead, pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop,
				  pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom,
				  pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop);
	return TRUE;
    }

    return FALSE;

    argData; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\list.c ===
/***  LIST.C  File list handling functions
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   In order to operate on a list of files, instead of just the current
*   file, we use a file list.  This is a name, much like a macro name, whose
*   value is a bunch of strings and/or lists.  We can think of a typical
*   list this way:
*
*	    list:= "one two three" sub1 "four" sub2 "five"
*	    sub1:= "subone subtwo" sub2 "subthree"
*	    sub2:= "whatever something nothing"
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "z.h"

/****************************************************************************
 *
 *  LISTS:
 *
 *	A list is kept as a macro.  The interface defined here assumes
 *	the existence of M macro handling.
 *
 ****************************************************************************/

#define LITERAL 1

static buffer bufList;
static MI ScanStack[MAXUSE];
static int scanSP;


/*** ListWalker - Given a list head, call back with each list member
*
* Purpose:
*
*   To walk through a list and call back to a function with information
*   about each list element.  This function is used when the caller needs
*   access to the list itself.	When a copy of the list's elements is
*   sufficient, ScanList is preferred.
*
*   This function should not be used outside of this module.
*
* Input:
*   Parameters:
*	imac -> Index of list
*	pfn  -> Call back function
*
* Output:   None
*
* Notes:
*
*   The callback function takes four arguments:
*
*	pcmd -	The handle of the list currently being searched.  This is
*		important because it may be different from the original
*		during a recursive scan.
*
*	str  -	A buffer containing a copy of the current string
*
*	pmi  -	A pointer to the macro instance structure.  This contains:
*
*		    -> text - A pointer just beyond the current element
*		    -> beg  - The start of the current list.
*
*	i    - The index of the current element within the current sublist.
*
*************************************************************************/
void
ListWalker (
    PCMD     pcmd,
    flagType (*pfn)(PCMD, char *, PMI, int),
    flagType fRecurse
    ) {

    MI mi;
    int i;

    if (pcmd == NULL) {
        return;
    }

    assert ((PVOID)pcmd->func == (PVOID)macro);

    InitParse (pcmd, &mi);
    for (i = 0; fParseList (&mi, bufList); i++) {
        if (!fRecurse || TESTFLAG (mi.flags, LITERAL)) {
            if (!TESTFLAG (mi.flags, LITERAL)) {
                Listize (bufList);
            }
            if (!(*pfn)(pcmd, bufList, &mi, i)) {
                return;
            }
        }else {
            ListWalker (GetListHandle (bufList, FALSE), pfn, TRUE);
        }
    }
}





/*** ScanList - External list scanner, does not require keeping an instance
*
* Purpose:
*   To scan through a list.  Calling with a list handle will return the
*   first element of the list.	To get the rest of the list, call with
*   NULL until NULL is returned.
*
* Input:
*   Parameters:
*	pcmdStart -> Handle of list to start scanning, or NULL to get
*		     next element.
*	fRecurse  -> TRUE means go down sublists, FALSE means return
*		     sublist names with '@' prepended.
*
* Output:
*   Returns Pointer to next element, or NULL if there are no more.
*
* Note:
*   Does not allow multiple simultaneous scans.
*
*************************************************************************/
char *
ScanList (
    PCMD pcmdStart,
    flagType fRecurse
    ) {
    static MI mi;

    return ScanMyList (pcmdStart, &mi, bufList, fRecurse);
}





/*** ScanMyList - Real list scanner
*
* Purpose:
*   To scan through a list.  Calling with a list handle will return the
*   first element of the list.	To get the rest of the list, call with
*   NULL until NULL is returned.
*
* Input:
*   Parameters:
*	pcmdStart -> Handle of list to start scanning, or NULL to get
*		     next element.
*	pmi	  -> pointer to instance MI structure
*	bufScan   -> pointer to instance buffer
*	fRecurse  -> TRUE means go down sublists, FALSE means return
*		     sublist names with '@' prepended.
* Output:
*   Returns Pointer to next element, or NULL if there are no more.
*
* Note:
*   Allows multiple simultaneous scans.
*
*************************************************************************/
char *
ScanMyList (
    PCMD         pcmdStart,
    REGISTER PMI pmi,
    buffer       bufScan,
    flagType     fRecurse
    ) {

    if (pcmdStart) {
	scanSP = -1;		/* Clear list stack		      */
	InitParse (pcmdStart, pmi);
    }

    while (!fParseList(pmi, bufScan)) {  /* Pop till we find something   */
        if (!(fRecurse && fScanPop (pmi))) {
            return NULL;    /* We're completely done                */
        }
    }

    /* Push lists till we hit a string      */

    while (!TESTFLAG(pmi->flags, LITERAL)) {
	if (fRecurse) {
	    if (pcmdStart = GetListHandle (bufScan, FALSE)) {
		if (!fScanPush (pmi)) { /* Stack overflow */
		    printerror ("List Error: Nested too deeply at '%s'", bufScan);
		    return NULL;
                }
		InitParse (pcmdStart, pmi);
            } else {  /* Error! List does not exist */
		printerror ("List Error: '%s' does not exist", bufScan);
		return NULL;
            }

            if (!fParseList (pmi, bufScan)) {
                if (!fScanPop (pmi)) {
                    return NULL;
                }
            }
        } else {
	    Listize (bufScan);
	    break;
        }
    }
    return bufScan;
}




/*** fParseList - Return next list element
*
* Purpose:
*
*   To read a list.
*
* Input:
*   Parameters:
*	pmi ->	macroInstance.	Points to a macro value and the
*		element to be returned.
*
* Output:
*   Parameters:
*	pmi ->	The current element field is advanced.	The flags
*		field indicates whether we found a literal or a
*		sublist.
*	buf ->	Place to put the element.  If this is NULL, we do not
*		return the element.
*
*   Returns TRUE if something was found.
*
*************************************************************************/
flagType
fParseList (
    REGISTER PMI pmi,
    REGISTER char * buf
    ) {

    assert (pmi);
    assert (pmi->text);

    /* CONSIDER: DO we really want to ignore empty quote pairs? */
    /* Scan through any number of double quote pairs */
    while (*(pmi->text = whiteskip (pmi->text)) == '"') {
	pmi->flags ^= LITERAL;
	pmi->text++;
    }

    if (*pmi->text == '\0') {
        return FALSE;
    }

    if (buf) {	/* Copy to whitspace, " or end of string */
	while (!strchr ("\"\t ", *pmi->text)) {
            if (*pmi->text == '\\') {
                /* Backslashes protect characters */
                pmi->text++;
            }
	    *buf++ = *pmi->text++;
        }
	*buf = '\0';
    }
    return TRUE;
}





/****************************************************************************
 *
 *  List Stack Management.
 *
 *	ScanList uses a stack of MI's to keep track
 *	of what has been scanned so far.  The stack elements are kept in
 *	a private stack defined here.
 *
 ****************************************************************************/


/*** fScanPush - Save current list scan state
*
* Purpose:
*
*   Called by ScanList to save its place so a sublist can be scanned
*
* Input:
*   Parameters:
*	pmi ->	Pointer to instance to save.
*
* Output:
*   Returns FALSE for a stack overflow, TRUE otherwise.
*
*************************************************************************/
flagType
fScanPush (
    PMI pmi
    ) {

    if (scanSP >= (MAXUSE-1)) {
        return FALSE;
    }

    ScanStack[++scanSP] = *pmi;
    assert (scanSP >= 0);
    return TRUE;
}




/*** fScanPop - Restore previous scan state
*
* Purpose:
*
*   Restore state after scanning a sublist
*
* Input: None.
*
* Output:
*   Parameters:
*	pmi -> Place to put previous state
*
*   Returns TRUE if a meaningful pop took place, FALSE if there was no
*   previous state.
*
*************************************************************************/
flagType
fScanPop (
    PMI pmi /* register here increases code size */
    ) {

    if (scanSP < 0) {
        return FALSE;
    }

    *pmi = ScanStack[scanSP--];
    return TRUE;
}




/*** GetListHandle - Create a handle for the given list name
*
* Purpose:
*
*   It's much easier to deal with lists if the user can carry around something
*   that tells us how to access a list quickly.  Therefore, we use this to
*   take a literal name and return a PCMD of the macro
*
* Input:
*   Parameters:
*	sz  ->	Name to look for.
*
* Output:
*
*   Returns PLHEAD
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
PCMD
GetListHandle (
    char * sz,  /* register doesn't help */
    flagType fCreate
    )
{

    REGISTER PCMD * prgMac;

    for (prgMac = rgMac; prgMac < &rgMac[cMac]; prgMac++) {
        if (!strcmp ((*prgMac)->name, sz)) {
            return *prgMac;
        }
    }

    if (!fCreate) {
        return NULL;
    }

    SetMacro (sz, rgchEmpty);

    return rgMac[cMac-1];
}




/*** AddStrToList - Add a list item to the end of a list
*
* Purpose:
*
*   This is how we build lists, n'est-ce pas?
*
* Input:
*   Parameters:
*	pcmd->	List to append to
*	sz  ->	Item to add.  If this item begins with a @, then we add
*		a list (not the contents, the name).
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*   If the original string ends in a double quote ("), we assume that
*   this is a closing quote; the string ends with a literal.  If the
*   original ends with anything else, we assume that it is the end of
*   a list name.  If the string passed in begins with a '@', the rest
*   of the string is a list name.
*
*   To append a list to either type of original, we append a space and
*   the list name.
*
*   To append a literal to a literal terminated original, we replace the
*   original's double quote with a space, append the new string, then
*   append a double quote.
*
*   To append a literal to a list terminated original, we append a space
*   and double quote, the new string, then a double quote.
*
*   Backslashes are doubled.  This allows the list to be read by the
*   macro processor.
*
*************************************************************************/
void
AddStrToList (
    PCMD pcmd,
    char * sz   /* register doesn't help */
    ) {

    flagType fString = TRUE;	/* TRUE -> sz is a string, FALSE a list */
    flagType fQuote = FALSE;	/* TRUE means original ends in string	*/
    int len;			/* Length of original string		*/
    int lensz;			/* Length of new string 		*/
    int fudge = 0;		/* Additional spaces or quotes		*/
    REGISTER char * pchOld;	/* Original list			*/
    pathbuf szPathName; 	/* Place to put fully qualified filename*/

    if (!pcmd) {
        return;
    }

    // The user should not be able to pass in a non-macro PCMD.  The
    // user can specify a name for a list, and that name must be
    // translated into a PCMD by GetListHandle.  That function will
    // not return a PCMD for anything other than a macro.
    //
    assert ((PVOID)pcmd->func == (PVOID)macro);

    pchOld = (char *)pcmd->arg;

    len = RemoveTrailSpace (pchOld);

    if (sz[0] == '@') { /* We simply append this to the original    */
        sz[0] = ' ';
        fString = FALSE;
        strcpy (szPathName, sz);
    } else {
        CanonFilename (sz, szPathName);
        DoubleSlashes (szPathName);

        if (len && pchOld[len-1] == '"') {
            fQuote = TRUE;          /* We're appending a literal to */
            fudge = 1;              /* a list ending in a literal   */
            pchOld[len-1] = ' ';
        } else {
            fudge = 3;          /* Appending literal to non-literal */
        }
    }

    lensz = strlen (szPathName);

    /* Now generate new string  */

    pcmd->arg = (CMDDATA)ZEROREALLOC ((char *)pcmd->arg, len + lensz + fudge + 1);
    strcpy ((char *)pcmd->arg, pchOld);

    if (fString && !fQuote) {
        strcat ((char *)pcmd->arg, " \"");
    }

    strcat ((char *)pcmd->arg, szPathName);

    if (fString) {
        strcat ((char *)pcmd->arg, "\"");
    }
}




/***  fInList - Check to see if a string is already in the list
*
* Purpose:
*
*   To see if an element is in a list.
*
* Input:
*   Parameters:
*	pcmd -> List to look in
*	pch  -> Literal to look for
*
* Output:
*
*   Returns TRUE iff pch is in pcmd
*
*************************************************************************/
flagType
fInList (
    PCMD pcmd,
    char * pch,
    flagType fRecurse
    ) {

    char * pchList; /* register here increases code size */
    MI mi;

    for (pchList = ScanMyList (pcmd, &mi, bufList, fRecurse);
         pchList;
         pchList = ScanMyList (NULL, &mi, bufList, fRecurse)) {
        if (!_stricmp (pchList, pch)) {
            return TRUE;
        }
    }
    return FALSE;
}



/*** fDelStrFromList -
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fDelStrFromList (
    PCMD pcmd,
    char * pch,
    flagType fRecurse
    ) {

    strcpy (buf, pch);
    ListWalker (pcmd, CheckAndDelStr, fRecurse);

    return (flagType)(buf[0] == '\0');
}




/*** CheckAndDelStr - If str matches buf, remove it
*
* Purpose:
*
*   ListWalker callback function for fDelStrFromList.  Deletes a string from
*   a list.
*
* Input:
*   Parameters:
*	pcmd -> List to remove from
*	pch  -> Copy of the element to remove
*	pmi  -> Scan state
*	i    -> Index into pcmd of the element.
*
* Output:
*
*   Returns TRUE if successful
*
* Notes:
*
*   We use ListWalker instead of ScanList because we need access to the
*   list position itself, not a copy of the element.
*
*************************************************************************/
flagType
CheckAndDelStr(
    PCMD pcmd,
    char * pch,
    PMI pmi,            /* register doesn't help */
    int  i
    ) {

    char * pchNext; /* register doesn't help */

    if (!strcmp (pch, buf)) {
        DoubleSlashes (buf);
        pchNext = strbscan (pmi->text, " \t\"");
	memmove (pmi->text - strlen(buf), pchNext, strlen (pchNext) + 1);
        buf[0] = '\0';  /* signal success */
        return FALSE;
    }

    return TRUE;

    pcmd; i;
}




/*** GetListEntry - Given an index into a list, get the index'th element
*
* Purpose:
*
*   To get a particular list element when its position is known.
*
* Input:
*   Parameters:
*	pcmd  -> The list.
*	iList -> The index.
*
* Output:
*
*   Returns pointer to the element, or NULL if there is no iList'th element
*
*************************************************************************/
char *
GetListEntry (
    PCMD pcmd,
    int iList,
    flagType fRecurse
    ) {

    int i;
    REGISTER char * pchList;
    MI mi;

    for (pchList = ScanMyList (pcmd, &mi, bufList, fRecurse), i = 0;
         pchList && i < iList;
         pchList = ScanMyList (NULL, &mi, bufList, fRecurse), i++) {
        ;
    }
    return pchList;
}





/*** ListLen - Return the number of elements in the list
*
* Purpose:
*
*   To count the elements in a list. Useful when you don't want to toast
*   ScanList.
*
* Input:
*   Parameters:
*	pcmd -> The list.
*
* Output:
*
*   Returns Number of items in list.
*
*************************************************************************/
int
ListLen (
    PCMD pcmd,
    flagType fRecurse
    ) {

    MI mi;
    int i = 0;

    if (ScanMyList (pcmd, &mi, bufList, fRecurse)) {
        do {
            i++;
        }while (ScanMyList (NULL, &mi, bufList, fRecurse));
    }
    return i;
}




/*** fEmptyList - Test the list for being empty
*
* Purpose:
*
*   The fastest way to check for an empty list.  Useful when you don't
*   want to toast ScanList.
*
* Input:
*   Parameters:
*	pcmd -> The list, of course.
*
* Output:
*
*   Returns TRUE for empty list.
*
*************************************************************************/
flagType
fEmptyList (
    PCMD pcmd
    ) {

    MI mi;

    return (flagType)(NULL != ScanMyList (pcmd, &mi, bufList, FALSE));
}





/*** InitParse - set a search instance to the beginning of a list
*
* Purpose:
*
*   To set up a parsing instance to the beginning of a list.
*
* Input:
*   Parameters:
*	pcmd -> List
*	pmi  -> instance
*
* Output: None.
*
*************************************************************************/
void
InitParse (
    PCMD pcmd,
    PMI pmi     /* register doesn't help */
    ) {

    pmi->beg = pmi->text = (char *)pcmd->arg;
    pmi->flags = 0;
}




/*** Listize - Prepend a '@' to the argument
*
* Purpose:
*
*   To turn a string into a list name.	Works in place, assumes there is
*   room for it.
*
* Input:
*   Parameters:
*	sz -> Name to mess with
*
* Output: None.
*
*************************************************************************/
void
Listize (
    REGISTER char * sz
    ) {

    memmove ( sz+1, sz,strlen (sz)+1);
    sz[0] = '@';
}



/*** CanonFilename - Replace a simple filename with a full pathname
*
* Purpose:
*
*   To get a full pathname for a file.	The file need not exist.
*   The simple filename may be of the form $ENV:name or $(ENV):name.
*
* Input:
*
*   szName   -> Relative path/filename.
*   pchCanon -> Result.
*
* Output:
*
*   Returns pointer to full, lower-case pathaname with drive.
*
* Notes:
*
*   If szName has an $ENV specification and ENV is not defined, the
*   file is searched for in the root.
*   If given drive is a ghost drive, let the system prompt for a disk
*   change.
*
*************************************************************************/
char *
CanonFilename (
    char * szName,
    char * pchCanon
    ) {

    pathbuf buf;

    if ( strlen(szName) < sizeof(buf) ) {
        if (szName[0] == '<' || szName[0] == '\0') {
            strcpy (pchCanon, szName);
            return pchCanon;
        }

        strcpy (buf, szName);

        if ((szName[0] != '$' || findpath(szName, buf, TRUE))
             && !rootpath (buf, pchCanon)) {

            _strlwr (pchCanon);
            return pchCanon;
        }
    }
    return NULL;

}





/*** fEnvar - Check a filename for having a $ENV at the front
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fEnvar (
    char * szName
    ) {
    return (flagType)((szName[0] == '$') && strchr (szName, ':'));
}




/*** ClearList - Make a list empty
*
* Purpose:
*
*   To quickly empty an existing list.
*
* Input:
*   pcmd -> List to clear
*
* Output: None
*
*************************************************************************/
void
ClearList (
    PCMD pcmd
    ) {
    SetMacro (pcmd->name, rgchEmpty);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\mark.c ===
/*	mark.c - do marking and repositioning
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"

PFILE       pFileMark   = NULL;    /* mark file handle                     */
flagType    fCacheDirty = 0;       /* TRUE => cache has ben changed        */
PFILE       pFileCache  = NULL;    /* Cached file                          */
FILEMARKS * pfmCache    = NULL;    /* Cached marks                         */

/* Flags for mark.flags  */

#define MF_DIRTY    1	    /* Mark has changed, but is not written	*/
#define MF_TEMP     2
#define MF_DUMMY    4	    /* This is dummry last mark 		*/



/*** mark - <mark> editor function
*
* Purpose:
*
*		       <mark> - Goes to top of file
*		  <arg><mark> - Toggle last/current window position
*	 <arg> textarg <mark> - Goes to named mark
*   <arg><arg> textarg <mark> - Defines mark at cursor
*   <arg><arg> textarg <mark> - Removes named mark
*
* Input:
*
* Output:
*
*   Returns FALSE if you try to go to a non-existent mark, TRUE
*   otherwise.
*
*************************************************************************/
flagType
mark (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
        docursor (0, (LINE)0);
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
        if (fIsNum (mbuf)) {
            docursor (0, atol (mbuf)-1);
            return TRUE;
        }
        if (pArg->arg.textarg.cArg == 2) {
            if (fMeta) {
                DeleteMark (mbuf);
            } else {
                DefineMark (mbuf, pFileHead, pArg->arg.textarg.y+1, pArg->arg.textarg.x+1, FALSE);
            }
            return TRUE;
        } else {
            return GoToMark (mbuf);
        }

    case NULLARG:
        restflip();
        return TRUE;

    /*  LINEARG illegal             */
    /*  STREAMARG illegal           */
    /*  BOXARG illegal              */

    }

    return FALSE;
    argData;
}





/*** GoToMark - Move cursor to a mark
*
* Purpose:
*
*   Goes to the named mark.
*
* Input:
*   pszMark -	Name of mark to go to.
*
* Output:
*
*   Returns TRUE if mark exists, FALSE, otherwise.
*
*************************************************************************/
flagType
GoToMark (
    char * pszMark
    ) {

    PFILE pFile;
    fl fl;

    if (pFile = FindMark (pszMark, &fl, TRUE)) {
        if (TESTFLAG(FLAGS(pFile), REAL) ||
            FileRead (pFile->pName, pFile, FALSE)) {
            pFileToTop (pFile);
            cursorfl (fl);
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        printerror ("'%s': Mark not found", pszMark);
        return FALSE;
    }
}





/*** FindMark - Get a mark's file location - used from outside
*
* Purpose:
*
*   Find a mark
*
* Input:
*   pszMark - Mark to search for.
*   fCheckAllFiles - TRUE  => Search through all files for mark
*		     FALSE => Look in only the current file
*
* Output:
*   * pfl - fl of mark.
*
*   Returns pFile of file the mark is in, NULL if mark is not found.
*
*************************************************************************/
PFILE
FindMark (
    char * pszMark,
    fl * pfl,
    flagType fCheckAllFiles
    ) {

    REGISTER PFILE pFile;
    MARK UNALIGNED*  pm;
    char    szMark[BUFLEN];
    char    szFile[BUFLEN];
    linebuf lbuf;
    LINE    y, l;
    COL     x;

    // If we are checking the current file only,
    // make sure it's cached and check it.
    //
    if (!fCheckAllFiles) {
        if (fCacheMarks (pFileHead) &&
            (pm = FindLocalMark (pszMark, FALSE))) {
            *pfl = pm->fl;
            //return pFile;
            return pFileHead;
        } else {
            return NULL;
        }
    }

    // Now, trundle through the pFile list
    // looking at the marks we have already
    // read from the markfile.
    //
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (TESTFLAG (FLAGS(pFile), VALMARKS) && fCacheMarks (pFile)) {
            if (pm = FindLocalMark (pszMark, FALSE)) {
                *pfl = pm->fl;
                return pFile;
            }
        }
    }

    // None of the files we have read so far
    // has the mark defined. We'll make one
    // pass through the markfile to see if
    // it's there.
    //
    if (pFileMark) {
        for (l = 0L; l < pFileMark->cLines; l++) {
            GetLine (l, lbuf, pFileMark);
            if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, buf, &y, &x) >= 3)
            if (!_stricmp (szMark, pszMark)) {
                CanonFilename (buf, szFile);
                if (!(pFile = FileNameToHandle (szFile, NULL))) {
                    pFile = AddFile (szFile);
                }
                (void)fReadMarks (pFile);
                pfl->lin = y - 1;
                pfl->col = x - 1;
                return pFile;
            }
        }
    }
    return NULL;
}




/*** FindLocalMark - Find a mark in a FILEMARKS structure
*
* Purpose:
*
*   To find a mark in the cached marks.  If found, a pointer into
*   the cache is returned,
*
* Input:
*   pszMark	- Mark Name
*   fDirtyOnly	- TRUE => Return only changed marks.
*
* Output:
*
*   Returns pointer to mark.
*
*************************************************************************/
MARK *
FindLocalMark (
    char * pszMark,
    flagType fDirtyOnly
    ) {

    REGISTER MARK UNALIGNED * pm;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; (char *)pm += pm->cb) {
        if (!_stricmp (pszMark, pm->szName)) {
            if (fDirtyOnly && !TESTFLAG(pm->flags, MF_DIRTY)) {
                return NULL;
            } else {
                return (MARK *)pm;
            }
        }
        assert (pm->cb);
    }
    return NULL;
}





/*** GetMarkFromLoc - Return the first mark past a given location
*
* Purpose:
*
*   To get a pointer to a mark given its file location.
*
* Input:
*   x, y - Mark location
*
* Output:
*
*   Returns Pointer to the mark.
*
*************************************************************************/
MARK *
GetMarkFromLoc (
    LINE y,
    COL  x
    ) {

    REGISTER MARK UNALIGNED * pm;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; (char *)pm += pm->cb) {
        if (pm->fl.lin > y || ((pm->fl.lin == y) && (pm->fl.col >= x))) {
            break;
        }
    }
    return (MARK *) pm;
}




/*** SetMarkFile - Change markfile
*
* Purpose:
*
*   Changes to a new markfile.
*
* Input:
*   val - String after the 'markfile' switch
*
* Output:
*
*   Returns Error string if error, NULL otherwise
*
* Notes:
*
*   We:
*
* UNDONE:o Magically ensure that the current markfile is up to date and
*	  saved to disk.  This means, at the very least, that there
*	  can be no dirty files.
*
*	o Remove the current markfile from the file list.
*
*	o Read in the new markfile.
*
*	o Invalidate all current marks.  This is just marking them
*	  invalid in the PFILE.
*
*
*************************************************************************/
char *
SetMarkFile (
    char *val
    ) {

    REGISTER PFILE pFile;
    buffer  tmpval;
    pathbuf pathname;

    strcpy ((char *) tmpval, val);

    if (NULL == CanonFilename (tmpval, pathname)) {
        sprintf (buf, "'%s': name is malformed", tmpval);
        return buf;
    }

    if (!(pFile = FileNameToHandle (pathname, NULL))) {
        pFile = AddFile (pathname);
    }

    if (!TESTFLAG(FLAGS(pFile), REAL) && !FileRead (pathname, pFile, FALSE)) {
        RemoveFile (pFile);
        sprintf (buf, "'%s' - %s", pathname, error());
        return buf;
    }

    pFileMark = pFile;

    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (!TESTFLAG(FLAGS(pFile), FAKE)) {
            RSETFLAG (FLAGS(pFile), VALMARKS);
        }
    }
    return NULL;
}





/*** MarkInsLine - Adjust marks after an InsLine
*
* Purpose:
*
*   After InsLine inserts a bunch of blank lines, it calls this to update
*   any marks that would be "moved down".
*
* Input:
*   line - line number at which insertion took place
*   n	 - Number of new lines
*   pFile- File this occurred in
*
* Output: None
*
*************************************************************************/
void
MarkInsLine (
    LINE line,
    LINE n,
    PFILE pFile
    ) {

    MARK UNALIGNED * pm;

    if (!fCacheMarks (pFile)) {
        return;
    }

    if (pm = GetMarkFromLoc (line, 0)) {
        AdjustMarks ((MARK *)pm, n);
    }
}





/*** MarkDelStream - Adjust Marks after a DelStream
*
* Purpose:
*
*   After DelStream or DelLines removes a stream (DelLine removes a
*   "stream" with the beginning and ending points at the left and right
*   edges of the file), this takes care of updating any remaining
*   marks.
*
* Input:
*   pFile  - Affected file
*   xStart - 0-based starting point
*   yStart
*   xEnd   - 0-based ending point
*   yEnd
*
* Output: None
*
*************************************************************************/
void
MarkDelStream (
    PFILE pFile,
    COL  xStart,
    LINE yStart,
    COL  xEnd,
    LINE yEnd
    ) {

    REGISTER MARK UNALIGNED * pm;
    MARK UNALIGNED *      pmStart = NULL;
    MARK UNALIGNED *      pmEnd = NULL;
    fl          flStart;
    fl          flEnd;
    flagType    fAgain = FALSE;

    if (!fCacheMarks (pFile)) {
        return;
    }

    /* yEnd++;  WHY? */
    flStart.lin = yStart;
    flStart.col = xStart;
    flEnd.lin = yEnd;
    flEnd.col = xEnd;

    for (pm = pfmCache->marks; pmEnd == NULL ; (char *)pm += pm->cb) {
        // Look for first mark past beginning
        // of stream. Assume for the moment that
        // it is inside the stream
        //
        if (pmStart == NULL) {
            if (flcmp (&flStart, (fl *) &pm->fl) < 1) {
                pmStart = pm;
            } else {
                continue;
            }
        }

        // A first mark has been found. We start
        // looking for the first mark past the end
        // of the stream.  If these are the same,
        // there are no marks to remove.
        //
        if (flcmp (&flEnd, (fl *) &pm->fl) < 1) {
            // We know that we will end up here
            // because the last "mark" is higher
            // than any real mark
            //
            if ((pmEnd = pm) != pmStart)
                // We're here if there were
                // any marks inside the deleted
                // stream
                //
                memmove ((char *)pmStart,
                         (char *)pmEnd,
                         (size_t)(((char *)pfmCache + pfmCache->cb) - (char *)pmEnd) );

            if (pmStart->fl.lin == yEnd) {
                pmStart->fl.col -= xEnd;
            }
            AdjustMarks ((MARK *)pmStart, yStart - (yEnd + 1));
        }

        assert (pm->cb ||
                (TESTFLAG(pm->flags, MF_DUMMY) &&
                pm->fl.lin == 0x7FFFFFFF &&
                pm->fl.col == 0x7FFF));
    }
}






/*** MarkDelBox - Adjust Marks after a DelBox
*
* Purpose:
*
*   After deleting a box of text, we must remove any marks that are
*   defined inside it, then shift left any marks that are to the
*   right of it.
*
* Input:
*   pFile - Affected file
*   xLeft, yTop - Upper left hand corner of box
*   xRight, yBottom - Lower right hand corner of box
*
* Output: None
*
*************************************************************************/
void
MarkDelBox (
    PFILE pFile,
    COL  xLeft,
    LINE yTop,
    COL  xRight,
    LINE yBottom
    ) {

    MARK UNALIGNED *   pm;
    MARK UNALIGNED *   pmStart = NULL;
    MARK UNALIGNED *   pmEnd = NULL;
    fl       flUpLeft;
    fl       flLoRight;
    flagType fAgain;
    flagType fInBox = FALSE;	/* Marks are within box top/bottom */

    if (!fCacheMarks (pFile)) {
        return;
    }

    /* yBottom++;  WHY? */
    flUpLeft.lin = yTop;
    flUpLeft.col = xLeft;
    flLoRight.lin = yBottom;
    flLoRight.col = xRight;


    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; !fAgain && ((char *)pm += pm->cb)) {
        /* First, look for lowest possible mark */
        fAgain = FALSE;
        if (!fInBox) {
            if (flcmp (&flUpLeft, (fl *) &pm->fl) < 1) {
                fAgain = TRUE;
                fInBox = TRUE;
            } else {
                ;
            }
        } else if (flcmp ((fl *) &pm->fl, &flLoRight) < 1) {
            /* Now we're in range.  Check
            ** for being inside the box.
            */
            if (pm->fl.col >= xLeft) {
                if (pm->fl.col <= xRight) {
                    DelPMark ((MARK *) pm);
                    fAgain = TRUE;
                } else {   /* Mark to the right of box */
                    pm->fl.col -= xRight - xLeft + 1;
                }
            } else {
                ;
            }
        } else {
            if (pm->fl.lin == yBottom) {
                pm->fl.col -= xRight - xLeft + 1;
            } else {
                break;      /* We've gone past the box */
            }
        }
    }
}





/*** fReadMarks - Read marks from the current markfile
*
* Purpose:
*
*   Gets the current marks for a given file.
*
* Input:
*   pFile - File to read marks for.
*
* Output:
*
*   Returns TRUE if pFile has marks and they are in VM, FALSE otherwise.
*
*************************************************************************/
flagType
fReadMarks (
    PFILE pFile
    ) {

    FILEMARKS UNALIGNED * pfm = NULL;
    LINE        l;
    char        szMark[BUFLEN];
    char        szFile[BUFLEN];
    linebuf     lbuf;
    LINE        yMark;
    COL         xMark;


    if (TESTFLAG (FLAGS(pFile), VALMARKS)) {
		return (flagType)(pFile->vaMarks != NULL);
    }

    // psuedo files cannot have marks
    // saved in the markfile.
    //
    if (pFileMark == NULL || TESTFLAG(FLAGS(pFile), FAKE)) {
        return FALSE;
    }

    for (l = 0L; l < pFileMark->cLines; l++) {
        GetLine (l, lbuf, pFileMark);
        if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, szFile, &yMark, &xMark) >= 3) {
            if (!_stricmp (szFile, pFile->pName)) {
                UpdMark ((FILEMARKS **) &pfm, szMark, yMark, xMark, FALSE);
            }
        }
    }

    // Now pfm points to a good FILEMARKS structure.
    // First, throw away current marks.  Then, if we
    // actually found some marks for this file, we
    // put them in VM.
    //
    return fFMtoPfile (pFile, (FILEMARKS *)pfm);
}




/*** WriteMarks - Write Marks back out to the markfile.
*
* Purpose:
*
*   To update the markfile if any marks have changed
*
* Input:
*   pFile - owner of the marks
*
* Output: None.
*
*************************************************************************/
void
WriteMarks (
    PFILE pFile
    ) {

    REGISTER MARK UNALIGNED * pm;
    char            szMark[BUFLEN];
    char            szFile[BUFLEN];
    linebuf         lbuf;
    LINE            yMark, l;
    COL             xMark;

    if (pFileMark == NULL || TESTFLAG(FLAGS(pFile), FAKE)) {
        return;
    }

    if (!fCacheMarks (pFile)) {
        return;
    }

    // First, we read the whole file looking for marks for
    // this file.  When we find one, we look it up in the
    // cache to find the new value and write it back
    // out.  Unchanged marks are not re-written.
    //
    for (l = 0L; l < pFileMark->cLines; l++) {
        GetLine (l, lbuf, pFileMark);
        if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, szFile, &yMark, &xMark) >= 3) {
            if (!_stricmp (szFile, pFile->pName)) {
                if (pm = FindLocalMark (szMark, TRUE)) {
                    sprintf (lbuf, "%s %s %ld %d", szMark, szFile, pm->fl.lin+1, pm->fl.col+1);
                    PutLine (l, lbuf, pFileMark);
                    RSETFLAG (pm->flags, MF_DIRTY);
                }
            }
        }
    }

    // Now we read through the cache to find any new marks.  These
    // will be appended to the markfile.
    //
    for (   pm = pfmCache->marks;
            !TESTFLAG(pm->flags, MF_DUMMY);
            (char *)pm += pm->cb) {

        if (TESTFLAG (pm->flags, MF_DIRTY)) {
            sprintf (lbuf, "%s %s %ld %d", pm->szName,
                                          pFile->pName,
                                          pm->fl.lin + 1,
                                          pm->fl.col + 1);
            AppFile (lbuf, pFileMark);
        }
    }
}





/*** UpdMark - Add a mark to a FILEMARKS
*
* Purpose:
*
*   This creates the FILEMARKS structure, adds marks to it and
*   updates existing marks in it.  The caller does not need to
*   know which of these is going to happen.
*
* Input:
*   ppfm    - Pointer to a pointer to FILEMARKS.
*   pszMark - Mark name.
*   yMark   - Mark location (1-based)
*   xMark
*   fTemp   - TRUE => This marks should not be written to the markfile
*
* Output: None.  *ppfm may be changed
*
* Notes:
*
*   The first argument is a ** because the * will be updated when a
*   re-LMAlloc is required.
*
*************************************************************************/
void
UpdMark (
    FILEMARKS ** ppfm,
    char       * pszMark,
    LINE         yMark,
    COL          xMark,
    flagType     flags
    ) {

    FILEMARKS UNALIGNED * pfm;
    FILEMARKS UNALIGNED * pfmOld;         /* pfm prior to realloc     */
    REGISTER MARK UNALIGNED * pm;
    int      cbNewMark;
    fl       flMark;
    flagType fExist = FALSE;

    assert (ppfm);

    /* Convert to 0-based */
    flMark.lin = yMark-1;
    flMark.col = xMark-1;
    cbNewMark  = sizeof(MARK) + strlen(pszMark);

    // If we already have a FILEMARKS structure,
    // we look for the slot in pfm->marks
    // where the new mark will go.
    //
    if (pfm = *ppfm) {
        for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
            if (!_stricmp (pszMark, pm->szName)) {
                fExist = TRUE;
                break;
            }

            // Check for current mark coming later than
            // new mark
            //
            if (flcmp ((fl *) &pm->fl, &flMark) > 0) {
                break;
            }
        }
    } else {
        // New structure.  Allocate mem and create
        // a dummy mark.
        //
        pfm = (FILEMARKS *)ZEROMALLOC (sizeof(FILEMARKS));
        pfm->cb = sizeof(FILEMARKS);
        pm = pfm->marks;
        pm->cb = sizeof(MARK);
        pm->fl.lin = 0x7FFFFFFF;
        pm->fl.col = 0x7FFF;
        pm->szName[0] = '\0';
        pm->flags = MF_DUMMY;
    }

    // At this point, pfm points to the current FILEMARKS
    // structure, and pm points into that structure at
    // the place where the new mark will go, or the existing
    // mark be updated.
    //
    if (!fExist) {

        pfmOld = pfm;

        // First, get enough extra space for a new mark, adjusting pm
        // if a new alloc was required
        //
		pfm = (FILEMARKS *)ZEROREALLOC((PVOID)pfm, pfm->cb + cbNewMark);
        if (pfmOld != pfm) {
            pm = (MARK *)((char *)pfm + ((char *)pm - (char *)pfmOld));
        }

        // Now pm points to the location in pfm where
        // our new mark should go.  We will move the
        // original filemarks up to leave space for the
        // new one.
        //
        memmove ((char *)((char *)pm + cbNewMark),
                (char *)pm,
                (size_t)(pfm->cb - ((char *)pm - (char *)pfm)));

        strcpy (pm->szName, pszMark);
        pm->flags = 0;
        pm->cb = cbNewMark;

        pfm->cb += cbNewMark;
    }

    if (pfm == pfmCache) {
        fCacheDirty = TRUE;
    }
    pm->flags = flags;
    pm->fl = flMark;

    *ppfm = (FILEMARKS *)pfm;
}




/*** DefineMark - Add new mark / update existing mark
*
* Purpose:
*
*   This is called from the outside to create/update marks.
*
* Input:
*   pszMark - Mark's name
*   pFile   - File the mark will be in
*   y, x    - File location of the mark (1-based)
*   fTemp   - True -> the mark is temporary
*
* Output: None.
*
*************************************************************************/
void
DefineMark (
    char * pszMark,
    PFILE pFile,
    LINE y,
    COL  x,
    flagType fTemp
    ) {

    flagType fFirstMark = (flagType)!fCacheMarks (pFile);

    if (fFirstMark) {
        FreeCache ();
    }

    UpdMark (&pfmCache, pszMark, y, x, (flagType)(MF_DIRTY | (fTemp ? MF_TEMP : 0)));

    if (fFirstMark) {
	pFileCache = pFile;
	(void)fFMtoPfile (pFile, pfmCache);
    }
}





/*** DeleteMark - Remove a mark
*
* Purpose:
*
*   Un-define a mark.
*
* Input:
*   pszMark - Mark to remove
*
* Output: None
*
* Notes:
*
*   A message is displayed reporting on success or failure.
*
*************************************************************************/
void
DeleteMark (
    char * pszMark
    ) {

    REGISTER PFILE pFile;
    MARK UNALIGNED * pm;

    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (TESTFLAG (FLAGS(pFile), VALMARKS) && fCacheMarks (pFile)) {
            if (pm = FindLocalMark (pszMark, FALSE)) {
                DelPMark ((MARK *)pm);
                domessage ("%s: mark deleted", pszMark);
                return;
            }
        }
    }
    printerror ("%s: Mark not found", pszMark);
}




/*** DelPMark - Remove a mark when a pointer to the MARK is known
*
* Purpose:
*
*   Physically remove a mark from a FILEMARKS structure
*
* Input:
*   pm - Pointer (into pfmCache) of mark to remove
*
* Output: None
*
*************************************************************************/
void
DelPMark (
    MARK * pm
    ) {

    MARK UNALIGNED * p;
    int cb;

    p   = pm;
    cb  = p->cb;

	memmove ((char *)pm,
		     (char *)((char *)pm + cb),
		     (size_t)(((char *)pfmCache + pfmCache->cb) - ((char *)pm + cb)));

	pfmCache->cb -= cb;
}





/*** MarkCopyLine - Copy marks after a CopyLine call
*
* Purpose:
*
*   When CopyLine moves stuff from or to the clipboard, this moves marks
*   with it.
*
* Input:
*   pFileSrc - File moved from
*   pFileDst - File moved to
*   yStart   - First line from pFileSrc
*   yEnd     - Last number from pFileDst
*   yDst     - Target line in pFileDst
*
* Output: None
*
* Notes:
*
*   Marks are copied only from and to the clipboard.
*
*
*************************************************************************/
void
MarkCopyLine (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    LINE    yStart,
    LINE    yEnd,
    LINE    yDst
    ) {

    FILEMARKS * pfm;

    if (pFileSrc != pFilePick && pFileDst != pFilePick) {
        return;
    }

    if (NULL == (pfm = GetFMFromFile (pFileSrc, 0, yStart, sizeof(linebuf)-1, yEnd))) {
        return;
    }

    AddFMToFile (pFileDst, pfm, 0, yDst);

	if ( pfm ) {
		FREE (pfm);
	}
}




/*** MarkCopyBox - Copy marks after a CopyBox call
*
* Purpose:
*
*   When CopyBox moves stuff from or to the clipboard, this moves marks
*   with it.
*
* Input:
*   pFileSrc	    - File moved from
*   pFileDst	    - File moved to
*   xLeft, yTop     - Upper left corner of source box
*   xRight, yBottom - Lower right corner of source box
*   xDst, yDst	    - Upper left corner of target
*
* Output: None
*
* Notes:
*
*   Marks are copied only from and to the clipboard.
*
*************************************************************************/
void
MarkCopyBox (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom,
    COL     xDst,
    LINE    yDst
    )
{

    FILEMARKS UNALIGNED * pfm;

    /* User is inserting blank region. */
    if (pFileSrc == NULL) {
        pFileSrc = pFileDst;
        xDst = xRight + 1;
        xRight = sizeof(linebuf);
    } else if (pFileSrc != pFileDst &&
        pFileSrc != pFilePick &&
        pFileDst != pFilePick) {
        return;
    }

    if (NULL == (pfm = GetFMFromFile (pFileSrc, xLeft, yTop, xRight, yBottom))) {
        return;
    }

    AddFMToFile (pFileDst, (FILEMARKS *)pfm, xDst, yDst);

	if ( pfm ) {
		FREE (pfm);
	}
}





/*** GetFMFromFile - Generate a FILEMARKS for marks in a file region
*
* Purpose:
*
*   Generates a subset of a FILEMARKS structure whose marks fall
*   within a certain range.  Needed by MarkCopy*.
*
* Input:
*   pFile	    - File to get marks from
*   xLeft, yTop     - Start of range
*   xRight, yBottom - End of range
*
* Output:
*
*   Returns Pointer to new structure, NULL if there are no marks in range
*
*************************************************************************/
FILEMARKS *
GetFMFromFile (
    PFILE   pFile,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom
    )
{

    FILEMARKS UNALIGNED * pfm = NULL;
    REGISTER MARK UNALIGNED * pm;
    fl       flStart;
    fl       flEnd;
    flagType fInRange = FALSE;

    if (!fCacheMarks (pFile)) {
        return NULL;
    }

    flStart.lin = yTop;
    flStart.col = xLeft;
    flEnd.lin = yBottom;
    flEnd.col = xRight;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
        if ((fInRange || flcmp (&flStart, (fl *) &pm->fl) < 1) &&
            (flcmp ((fl *) &pm->fl, &flEnd) < 1)) {
            fInRange = TRUE;
            if ((pm->fl.col >= xLeft && pm->fl.col <= xRight)) {
                UpdMark (   (FILEMARKS **) &pfm,
                            pm->szName,
                            pm->fl.lin - yTop + 1,
                            pm->fl.col - xLeft + 1,
                            (flagType)pm->flags);
            }
        } else {
            break;  /* We're out of range again*/
        }
    }
    return (FILEMARKS *) pfm;
}




/*** AddFMToFile - Add a bunch of marks to a file
*
* Purpose:
*
*   Insert the marks from one FILEMARKS structure into another.  The
*   target structure is in pfmCache.
*
* Input:
*   pFile - Target file
*   pfm   - Source marks
*   cZero