rough all services and see if any one has hung
                // while starting.
                //
                ScLookForHungServices();

            }
            else if (Error == 0)
            {
                //
                // Reset ScServiceChangeStateEvent to non-signalled state
                //
                if (!ResetEvent(ScServiceChangeStateEvent))
                {
                    Error = GetLastError();
                    //
                    // This is a serious error--we cannot proceed.
                    //
                    SC_LOG1(ERROR, "Error reseting ScServiceChangeStateEvent "
                            FORMAT_DWORD "\n", Error);

                    ScLogEvent(
                        NEVENT_CALL_TO_FUNCTION_FAILED,
                        SC_RESET_EVENT,
                        Error
                        );

                    return Error;
                }
            }
            else if (Error == 0xffffffff)
            {
                //
                // An error has occurred
                //
                SC_LOG1(ERROR,
                        "Wait for ScServiceChangeStateEvent returned %d\n",
                        GetLastError());
                SC_ASSERT(FALSE);
            }
        }
        else if ((AllStarted && ExistsBlockedService) || IsBadDependencies)
        {
            //
            // Circular dependencies!
            //
            SC_LOG0(ERROR, "Detected circular dependencies!!\n");

            SC_LOG3(ERROR,
                    "AllStarted=" FORMAT_DWORD
                    ", ExistsBlockedService=" FORMAT_DWORD
                    ", IsBadDependencies=" FORMAT_DWORD "\n",
                    (DWORD) AllStarted, (DWORD) ExistsBlockedService,
                    (DWORD) IsBadDependencies);

            if (ARGUMENT_PRESENT(ServiceToStart))
            {
                SC_LOG1(ERROR, "    Demand starting " FORMAT_LPWSTR "\n",
                        ServiceToStart->DisplayName);

                ScLogEvent(
                    NEVENT_CIRCULAR_DEPENDENCY_DEMAND,
                    ServiceToStart->DisplayName
                    );
            }
            else
            {
                SC_LOG0(ERROR, "    Auto-starting services\n");

                ScLogEvent(NEVENT_CIRCULAR_DEPENDENCY_AUTO);

                ScHandleBadDependencies();
            }

            return ERROR_CIRCULAR_DEPENDENCY;
        }
    }
    while (! AllStarted);

    return NO_ERROR;
}


VOID
ScHandleServiceFailure(
    IN LPSERVICE_RECORD Service
    )
/*++

Routine Description:

    This function checks to see if the specified service failed to start.
    If so, it clears the SERVICE_START_NOW flag, and determine if we
    have to revert to last-known-good.

Arguments:

    Service - Supplies a pointer to the service record to examine if
        the service failed to start.

Return Value:

    None.

--*/
{

    if (Service->StartState == SC_START_FAIL) {

        //
        // Revert to last-known-good only if service is auto-start and
        // fail to start due to reasons other than failure to logon.
        //
        if ((Service->ErrorControl == SERVICE_ERROR_SEVERE ||
             Service->ErrorControl == SERVICE_ERROR_CRITICAL) &&
            CURRENTSTART_FLAG_IS_SET(Service) &&
            Service->StartError != ERROR_SERVICE_LOGON_FAILED) {

            SC_LOG1(DEPEND,
                    "ScHandleServiceFailure: "
                    "About to call ScRevertToLastKnownGood for " FORMAT_LPWSTR
                    "\n", Service->ServiceName);

            (void) ScRevertToLastKnownGood();
        }
    }
}


BOOL
ScDependenciesStarted(
    IN  LPSERVICE_RECORD Service,
    OUT BOOL *IsBadDependencies,
    OUT BOOL *AllStarted,
    OUT BOOL *ExistsBlockedService
    )
/*++

Routine Description:

    This function checks to see if the dependencies of the specified
    service are all started.  If any of the dependencies has failed to
    start, the specified service will be marked as failed to start.
    If any of the dependencies is not marked as starting now (because
    they are demand-start services), they are marked to be started now.

Arguments:

    Service - Supplies a pointer to the service which we want to check
        the start dependencies.

    IsBadDependencies - Receives the value of TRUE if the service we
        depend on belongs in a group that starts after the group we
        are in.   Otherwise, FALSE is returned.

    AllStarted - Receives the value of FALSE if we have marked
        a service as failed to be started because its dependent
        didn't start.  This means that our job of starting all services is
        not done and we have to loop through an additional time to resolve
        the state of any service that is dependent on it.

    ExistsBlockedService - Receives the value of TRUE if a dependent
        is not started or not failed to start.   This indicates that
        the specified service is still blocked from starting.

Return Value:

    TRUE - if all dependencies have already been started successfully.

    FALSE - if there exists one dependency that has not started or failed
        to start.

--*/
{

    BOOL AllDependenciesStarted = TRUE;
    LPDEPEND_RECORD DependEntry;
    LPSERVICE_RECORD DependService;
    LPLOAD_ORDER_GROUP DependGroup;
    DWORD GroupState;

    for (DependEntry = Service->StartDepend;
         DependEntry != NULL;
         DependEntry = DependEntry->Next)
    {
        switch (DependEntry->DependType)
        {

        case TypeDependOnUnresolved:

            //
            // Error with service setup because it depends on a group or
            // service which does not exists
            //

            SC_LOG2(ERROR, FORMAT_LPWSTR " depends on non-existing " FORMAT_LPWSTR
                    "\n", Service->DisplayName,
                    DependEntry->DependUnresolved->Name);

            if (Service->ErrorControl != SERVICE_ERROR_IGNORE)
            {
                ScLogEvent(
                    NEVENT_SERVICE_START_FAILED_NONE,
                    Service->DisplayName,
                    DependEntry->DependUnresolved->Name
                    );
            }

            ScCleanupStartFailure(Service, ERROR_SERVICE_DEPENDENCY_DELETED);

            *AllStarted = FALSE;

            return FALSE;


        case TypeDependOnService:

            //
            // Depend on a service
            //

            DependService = DependEntry->DependService;


            //
            // If dependency service already failed to start, the current service
            // is set as failed to start.
            //
            if (DependService->StartState == SC_START_FAIL)
            {
                DWORD  dwError;

                SC_LOG3(ERROR, FORMAT_LPWSTR " depends on " FORMAT_LPWSTR
                        " which failed to start because " FORMAT_DWORD "\n",
                        Service->DisplayName, DependService->DisplayName,
                        (DependService->StartError != NO_ERROR) ?
                         DependService->StartError :
                         DependService->ServiceStatus.dwWin32ExitCode);

                if (Service->ErrorControl != SERVICE_ERROR_IGNORE
                     &&
                    DependService->StartError != ERROR_NOT_SAFEBOOT_SERVICE
                     &&
                    !SetupInProgress(NULL, NULL))
                {
                    ScLogEvent(
                        NEVENT_SERVICE_START_FAILED_II,
                        Service->DisplayName,
                        DependService->DisplayName,
                        DependService->StartError != NO_ERROR ? 
                            DependService->StartError : DependService->ServiceStatus.dwWin32ExitCode
                        );
                }

                dwError = ERROR_NOT_SAFEBOOT_SERVICE;

                //
                // Walk through the list of service dependencies and pick
                // the more appropriate error code.  Do this to avoid
                // reporting ERROR_SERVICE_DEPENDENCY_FAIL on auto-start
                // and ERROR_NOT_SAFEBOOT_SERVICE on demand-start for the
                // same service.
                //
                for (DependEntry = Service->StartDepend;
                     DependEntry != NULL;
                     DependEntry = DependEntry->Next)
                {
                    if (DependEntry->DependType == TypeDependOnService
                         &&
                        DependEntry->DependService->StartError
                            != ERROR_NOT_SAFEBOOT_SERVICE)
                    {
                        //
                        // There was a "real" start failure
                        //
                        dwError = ERROR_SERVICE_DEPENDENCY_FAIL;
                        break;
                    }
                }

                ScCleanupStartFailure(Service, dwError);
                *AllStarted = FALSE;
                return FALSE;
            }

            if (DependService->StartState == SC_NEVER_STARTED)
            {
                *IsBadDependencies = IsDependOnLaterGroup(
                                         Service->MemberOfGroup,
                                         DependService->MemberOfGroup,
                                         TypeDependOnService
                                         );

                if (*IsBadDependencies) {
                    //
                    // Circular dependency!
                    //
                    SC_LOG1(ERROR, "Circular dependency!  " FORMAT_LPWSTR
                            " depends on service in a group which starts later\n",
                            Service->DisplayName);

                    if (Service->ErrorControl != SERVICE_ERROR_IGNORE)
                    {
                        ScLogEvent(
                            NEVENT_DEPEND_ON_LATER_SERVICE,
                            Service->DisplayName);
                    }

                    ScCleanupStartFailure(Service, ERROR_CIRCULAR_DEPENDENCY);

                    return FALSE;
                }

                //
                // No circular dependency.  Mark the dependency service
                // as START_NOW.
                //
                DependService->StartState = SC_START_NOW;
                DependService->StartError = NO_ERROR;

                *AllStarted = FALSE;
            }

            //
            // Get the current state of the dependency service
            //
            if (DependService->StartState != SC_START_SUCCESS)
            {
                AllDependenciesStarted = FALSE;

                if (DependService->StartState != SC_START_FAIL)
                {
                    //
                    // The current service is still blocked.
                    //
                    *ExistsBlockedService = TRUE;
                }
            }

            break;


        case TypeDependOnGroup:

            //
            // Depend on a group
            //

            DependGroup = DependEntry->DependGroup;

            GroupState = ScGetCurrentGroupState(DependGroup);

            switch (GroupState)
            {
            case GROUP_START_FAIL:

                SC_LOG2(ERROR, FORMAT_LPWSTR " depends on failed group "
                        FORMAT_LPWSTR "\n", Service->DisplayName,
                        DependGroup->GroupName);

                if (Service->ErrorControl != SERVICE_ERROR_IGNORE
                     &&
                    !g_SafeBootEnabled
                     &&
                    !SetupInProgress(NULL, NULL))
                {
                    ScLogEvent(
                        NEVENT_SERVICE_START_FAILED_GROUP,
                        Service->DisplayName,
                        DependGroup->GroupName
                        );
                }

                ScCleanupStartFailure(Service, ERROR_SERVICE_DEPENDENCY_FAIL);

                *AllStarted = FALSE;

                return FALSE;


            case GROUP_NOT_STARTED:

                *IsBadDependencies = IsDependOnLaterGroup(
                                         Service->MemberOfGroup,
                                         DependGroup,
                                         TypeDependOnGroup
                                         );

                if (*IsBadDependencies) {
                    //
                    // Circular dependency!
                    //
                    SC_LOG1(ERROR, "Circular dependency!  " FORMAT_LPWSTR
                            " depends on a group which starts later\n",
                            Service->DisplayName);

                    if (Service->ErrorControl != SERVICE_ERROR_IGNORE)
                    {
                        ScLogEvent(
                            NEVENT_DEPEND_ON_LATER_GROUP,
                            Service->DisplayName
                            );
                    }
                    ScCleanupStartFailure(Service, ERROR_CIRCULAR_DEPENDENCY);

                    return FALSE;
                }


                //
                // No circular dependency.  Mark the services in the
                // dependency group to START_NOW.
                //
                {
                    FOR_SERVICES_THAT(Svc,
                        BELONGS_TO(Svc, DependGroup) &&
                        Svc->StartState == SC_NEVER_STARTED)
                    {
                        Svc->StartState = SC_START_NOW;
                        Svc->StartError = NO_ERROR;
                    }
                }

                AllDependenciesStarted = FALSE;
                *ExistsBlockedService = TRUE;

                break;

            default:
                //
                // Otherwise group must be started.  Nothing to do.
                //
                SC_ASSERT(GroupState == GROUP_ONE_STARTED);
                break;

            }

            break;

        }
    }

    return AllDependenciesStarted;
}


BOOL
IsDependOnLaterGroup(
    IN LPLOAD_ORDER_GROUP ServiceGroup,
    IN LPLOAD_ORDER_GROUP DependOnGroup,
    IN DEPEND_TYPE DependType
    )
{
    LPLOAD_ORDER_GROUP Group;

    switch (DependType)
    {
        case TypeDependOnService:
            if (ServiceGroup == DependOnGroup) {
                //
                // It is OK for a service to depend on another service
                // in the same group.
                //
                return FALSE;
            }
            break;

        case TypeDependOnGroup:
            if (IS_SUBGROUP(ServiceGroup, DependOnGroup)) {
                //
                // It is circular dependency if a service depends on the
                // group it itself belongs to
                //
                return TRUE;
            }
            break;

        default:
            SC_LOG(ERROR, "IsDependOnLaterGroup: got invalid DependType %lu\n",
                   DependType);
            SC_ASSERT(FALSE);
            return FALSE;
    }

    if (ServiceGroup == NULL ||
        ServiceGroup->RefCount != MAXULONG ||
        DependOnGroup == NULL ||
        DependOnGroup->RefCount != MAXULONG) {

        //
        // Service we are starting belongs to a standalone group,
        // or service or group we depend on is standalone.
        //
        return FALSE;
    }

    //
    // Both the service's group and the depended on group are in the
    // load order group list.
    // The depended on group must not occur after the service's group.
    // TDI GROUP SPECIAL:  Also, if the depended on group is the TDI
    // group, then there is an implicit dependency on the PNP_TDI group,
    // so that must not occur after the service's group either.
    //
    for (Group = ServiceGroup->Next;
         Group != NULL;
         Group = Group->Next)
    {
        if (IS_SUBGROUP(Group, DependOnGroup)) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
ScCleanupStartFailure(
    LPSERVICE_RECORD Service,
    DWORD StartError
    )
{
    Service->StartState = SC_START_FAIL;
    Service->StartError = StartError;

    //
    // Clear ERROR_SERVICE_NEVER_STARTED in the Win32ExitCode field if
    // service failed to start.
    //
    CServiceRecordExclusiveLock RLock;

    if (Service->ServiceStatus.dwWin32ExitCode ==
        ERROR_SERVICE_NEVER_STARTED) {
        Service->ServiceStatus.dwWin32ExitCode = StartError;
    }

    //
    // For popup after user has logged on to indicate that some
    // service started at boot has failed.
    //
    if (Service->ErrorControl != SERVICE_ERROR_IGNORE) {
        ScPopupStartFail = TRUE;
    }

}


VOID
ScLookForHungServices(
    VOID
    )
/*++

Routine Description:

    This function loops through all services and queries the status
    of each service that is start pending.  It waits for the service to
    show signs of progress in starting by waiting for the wait-hint
    amount of time (in millisecs), and if the service is still start
    pending and checkpoint has not incremented, the service's exitcode
    is set to ERROR_SERVICE_START_HANG.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status;
    SERVICE_STATUS CurrentServiceStatus;
    STATUS_UNION   ServiceStatus;
    DWORD   OldCheckPoint;


    FOR_SERVICES_THAT(Service, Service->StartState == SC_START_PENDING)
    {
        ServiceStatus.Regular = &CurrentServiceStatus;

        status = ScQueryServiceStatus(
                     Service,
                     ServiceStatus,
                     FALSE
                     );

        if ((status == NO_ERROR) &&
            (CurrentServiceStatus.dwCurrentState == SERVICE_START_PENDING)) {

#define SC_POLL_FACTOR      10
#define SC_MAX_SLEEP_TIME   10000

            DWORD   SleepTime = 1;
            DWORD   i;
            DWORD   NumIterations;


            OldCheckPoint = CurrentServiceStatus.dwCheckPoint;

            //
            // Set up for the loop where we will poll the service status.
            // The maximum sleep time during this polling operation will
            // be 10 seconds.
            //

            //
            // If the wait hint is greater than 100 seconds, then
            // we want to modify the number of iterations through the
            // loop so that we only sleep for the MAX_SLEEP_TIME.
            //
            // If the wait hint is less than that, then we change the
            // sleep time to be less than 10 seconds, so that we go
            // through the loop a max of 10 times.
            //
            if (CurrentServiceStatus.dwWaitHint > 100000) {
                NumIterations = CurrentServiceStatus.dwWaitHint / SC_MAX_SLEEP_TIME;
                SleepTime = SC_MAX_SLEEP_TIME;
            }
            else {
                NumIterations = SC_POLL_FACTOR;
                if (CurrentServiceStatus.dwWaitHint > SC_POLL_FACTOR) {
                    SleepTime = CurrentServiceStatus.dwWaitHint / SC_POLL_FACTOR;
                }
            }

            for (i = 0; i < NumIterations; i++) {

                //
                // Wait a while for the checkpoint to increment, or
                // service to be out of start-pending state.
                //
                Sleep(SleepTime);

                status = ScQueryServiceStatus(
                             Service,
                             ServiceStatus,
                             FALSE
                             );

                if (status == NO_ERROR) {

                    if (CurrentServiceStatus.dwCurrentState != SERVICE_START_PENDING ||
                        (CurrentServiceStatus.dwCurrentState == SERVICE_START_PENDING &&
                         OldCheckPoint < CurrentServiceStatus.dwCheckPoint)) {

                        goto NextService;
                    }
                }

                SC_LOG2(DEPEND, "   Wait %ld on %ws for response\n", i + 1,
                        Service->ServiceName);
            }

            if ((status == NO_ERROR) &&
                (CurrentServiceStatus.dwCurrentState == SERVICE_START_PENDING) &&
                (OldCheckPoint == CurrentServiceStatus.dwCheckPoint)) {

                SC_LOG2(ERROR, "%ws hung on starting (wait hint %lu ms)\n",
                        Service->ServiceName,
                        CurrentServiceStatus.dwWaitHint);

                if (Service->ErrorControl != SERVICE_ERROR_IGNORE)
                {
                    ScLogEvent(
                        NEVENT_SERVICE_START_HUNG,
                        Service->DisplayName
                        );
                }

                ScCleanupStartFailure(Service, ERROR_SERVICE_START_HANG);

            }

        }

        if (status != NO_ERROR) {
            SC_LOG2(ERROR, "ScLookForHungService: ScQueryServiceStatus "
                    FORMAT_LPWSTR " failed " FORMAT_DWORD "\n",
                    Service->ServiceName, status);
            Service->StartState = SC_START_FAIL;
            Service->StartError = ERROR_GEN_FAILURE;
        }

NextService:
        ;
    }

}


VOID
ScHandleBadDependencies(
    VOID
    )
/*++

Routine Description:

    This function is called when a circular dependency is detected.

Arguments:

    None.

Return Value:

    None.

--*/
{

    FOR_SERVICES_THAT(Service,
        (Service->StartState == SC_START_NOW) &&
        (Service->ErrorControl == SERVICE_ERROR_SEVERE ||
         Service->ErrorControl == SERVICE_ERROR_CRITICAL) )
    {
        SC_LOG1(ERROR, "ScHandleBadDependencies: "
                "About to call ScRevertToLastKnownGood for "
                FORMAT_LPWSTR "\n", Service->DisplayName);

        ScLogEvent(
            NEVENT_SEVERE_SERVICE_FAILED,
            Service->DisplayName
            );

        ScRevertToLastKnownGood();
    }
}


BOOL
ScServiceToStartDependOn(
    LPSERVICE_RECORD ServiceToStart OPTIONAL,
    LPSERVICE_RECORD StartPendingService
    )
/*++

Routine Description:

    This function is called by ScStartMarkedServices (BIG LOOP) to determine
    if we have to wait for a pending service to complete.

    If ServiceToStart == NULL, we are auto-starting service and we always
    want to wait.

    If ServiceToStart is not NULL, we are demand starting a service.
    We have to wait if ServiceToStart depends on the StartPendingService.


Arguments:

    ServiceToStart - Supplies the service record pointer of the service
        being demand started.

    StartPendingService - Supplies the service record pointer of the
        service that is currently start pending.


Return Value:

    TRUE - If ServiceToStart depends on StartPendingService or
           ServiceToStart == NULL.

    FALSE - Otherwise.

--*/
{
    if (! ARGUMENT_PRESENT(ServiceToStart)) {
        return TRUE;
    }

    if (ServiceToStart->StartState == SC_START_FAIL) {
        return FALSE;
    }

    if (CURRENTSTART_FLAG_IS_SET(StartPendingService)) {
        SC_LOG2(DEPEND_DUMP, "Service %ws directly/indirectly depends on pending service %ws\n",
                ServiceToStart->ServiceName,
                StartPendingService->ServiceName);

        return TRUE;
    }

    SC_LOG(DEPEND_DUMP, "ScServiceToStartDependOn: Won't wait for pending "
           FORMAT_LPWSTR "\n", StartPendingService->ServiceName);

    return FALSE;
}


VOID
ScNotifyChangeState(
    VOID
    )
/*++

Routine Description:

    This function is called by RSetServiceStatus which a service state
    changes from start-pending to running or stopped.  This will
    notify the thread processing start dependencies that we can
    proceed with starting up services that depend on the one that
    called RSetServiceStatus.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (! SetEvent(ScServiceChangeStateEvent)) {

        SC_LOG1(ERROR, "ScNotifyChangeState: SetEvent error " FORMAT_DWORD "\n",
               GetLastError());
        SC_ASSERT(FALSE);
    }
}


BOOL
ScDependentsStopped(
    IN LPSERVICE_RECORD ServiceToStop
    )
/*++

Routine Description:

    This function checks to see if any service which depends on the
    specified service is active.  If so, it returns FALSE, otherwise
    if no service depends on the specified service, or all services
    which depend on the specified service is stopped, it returns
    TRUE.

    A service which is not in SERVICE_STOPPED is considered active.

Arguments:

    ServiceToStop - Supplies a pointer to the service to see if other
        active services depend on it.

Return Value:

    TRUE - if all services which depend on ServiceToStop are stopped,
        or there are no services which depend on ServiceToStop.

    FALSE - if one or more of the services which depend on ServiceToStop
        is active.

Note:
    The database lock must be acquired with share access before calling
    this routine.

--*/
{
    SC_ASSERT(ScServiceRecordLock.Have());

    LPDEPEND_RECORD StopDepend;

    for (StopDepend = ServiceToStop->StopDepend;
         StopDepend != NULL;
         StopDepend = StopDepend->Next)
    {
        if (StopDepend->DependService->ServiceStatus.dwCurrentState
            != SERVICE_STOPPED) {

            SC_LOG1(DEPEND, FORMAT_LPWSTR " is still ACTIVE\n",
                    StopDepend->DependService->ServiceName);

            return FALSE;
        }

        SC_LOG1(DEPEND, FORMAT_LPWSTR " is STOPPED\n",
                StopDepend->DependService->ServiceName);
    }

    return TRUE;
}


VOID
ScEnumDependents(
    IN     LPSERVICE_RECORD ServiceRecord,
    IN     LPENUM_SERVICE_STATUS_WOW64 EnumBuffer,
    IN     DWORD RequestedState,
    IN OUT LPDWORD EntriesRead,
    IN OUT LPDWORD BytesNeeded,
    IN OUT LPENUM_SERVICE_STATUS_WOW64 *EnumRecord,
    IN OUT LPWSTR *EndOfVariableData,
    IN OUT LPDWORD Status
    )
/*++

Routine Description:

    This function enumerates the stop depend list of the specified
    service in the order which the dependents should be stopped.

Arguments:

    ServiceRecord - Supplies a pointer to the service whose dependents
        are to be enumerated.

    EnumBuffer - Supplies a pointer to the first byte of the enum
        buffer we are writing to.  This is for duplicate entry checking.

    RequestedState - Supplies one or the bitwise or of SERVICE_ACTIVE
        and SERVICE_INACTIVE.

    BytesNeeded - Supplies a pointer to a variable to receive the
        running sum of bytes needed to enumerate all the entries.

    EnumRecord - Supplies a pointer into the next location in the
        output buffer to receive the next entry.  The pointer is
        updated on return.

    EndOfVariableData - Supplies a pointer past the last available
        byte in the output buffer so that variable length data
        can be written from the end of the buffer.  This pointer is
        updated on return.

    Status - Receives ERROR_MORE_DATA if dependent services does not
        entirely fit in the output buffer.  It should be initialized
        to NO_ERROR this function is called.


Return Value:

    None.

Note:
    The database lock must be acquired with share access before calling
    this routine.

--*/
{
    SC_ASSERT(ScServiceRecordLock.Have());

    LPDEPEND_RECORD StopDepend;

    for (StopDepend = ServiceRecord->StopDepend;
         StopDepend != NULL;
         StopDepend = StopDepend->Next)
    {
        if (StopDepend->DependService->StopDepend != NULL) {

            //
            // Stop dependent also have other services that depends on
            // it.  Recursively call this routine to enumerate its
            // dependents.
            //
            ScEnumDependents(
                StopDepend->DependService,
                EnumBuffer,
                RequestedState,
                EntriesRead,
                BytesNeeded,
                EnumRecord,
                EndOfVariableData,
                Status
                );

        }

        if (
            ((StopDepend->DependService->ServiceStatus.dwCurrentState
              != SERVICE_STOPPED) &&
             (RequestedState & SERVICE_ACTIVE))

              ||

            ((StopDepend->DependService->ServiceStatus.dwCurrentState
              == SERVICE_STOPPED) &&
             (RequestedState & SERVICE_INACTIVE))
           )   {

            SC_LOG1(DEPEND, "Enumerating dependent " FORMAT_LPWSTR "\n",
                    StopDepend->DependService->ServiceName);


            if (! ScFoundDuplicateDependent(
                       StopDepend->DependService->ServiceName,
                       EnumBuffer,
                       *EnumRecord
                       )) {

                *BytesNeeded += (sizeof(ENUM_SERVICE_STATUS_WOW64) +
                    (DWORD) WCSSIZE(StopDepend->DependService->ServiceName) +
                    (DWORD) WCSSIZE(StopDepend->DependService->DisplayName));

                if (*Status == NO_ERROR) {

                    if (((DWORD_PTR) *EnumRecord + sizeof(ENUM_SERVICE_STATUS_WOW64)) >=
                         (DWORD_PTR) *EndOfVariableData) {
                        *Status = ERROR_MORE_DATA;
                    }
                    else {

                        //
                        // Write the entry into output buffer
                        //
                        memcpy(
                            (PVOID) &((*EnumRecord)->ServiceStatus),
                            (PVOID) &(StopDepend->DependService->ServiceStatus),
                            sizeof(SERVICE_STATUS)
                            );

                        //
                        // Copy the ServiceName string data
                        //
                        if (! ScCopyStringToBufferW(
                                  StopDepend->DependService->ServiceName,
                                  (DWORD) wcslen(StopDepend->DependService->ServiceName),
                                  (LPWSTR) (*EnumRecord + 1),
                                  EndOfVariableData,
                                  (LPWSTR *) &((*EnumRecord)->dwServiceNameOffset),
                                  (LPBYTE) EnumBuffer))
                        {
                            *Status = ERROR_MORE_DATA;
                        }

                        //
                        // Copy the DisplayName string data
                        //
                        if (! ScCopyStringToBufferW(
                                  StopDepend->DependService->DisplayName,
                                  (DWORD) wcslen(StopDepend->DependService->DisplayName),
                                  (LPWSTR) ((*EnumRecord) + 1),
                                  EndOfVariableData,
                                  (LPWSTR *) &((*EnumRecord)->dwDisplayNameOffset),
                                  (LPBYTE) EnumBuffer))
                        {
                            *Status = ERROR_MORE_DATA;
                        }

                    }

                    if (*Status == NO_ERROR) {
                        (*EnumRecord)++;
                        (*EntriesRead)++;
                        SC_LOG0(DEPEND, "  Written into buffer successfully\n");
                    }
                    else {
                        SC_LOG0(DEPEND, "  Failed to fit into buffer\n");
                    }

                } // *Status is still NO_ERROR

            } // non-duplicate entry
        }
    }

}


BOOL
ScFoundDuplicateDependent(
    IN LPWSTR ServiceName,
    IN LPENUM_SERVICE_STATUS_WOW64 EnumBuffer,
    IN LPENUM_SERVICE_STATUS_WOW64 BufferEnd
    )
/*++

Routine Description:

    This function looks at service entries written to EnumBuffer for
    any service names that matches the specified ServiceName.

Arguments:

    ServiceName - Supplies the name of the service to look for.

    EnumBuffer - Supplies a pointer to the buffer to look for matching
        service name.

    BufferEnd - Supplies a pointer to the end of buffer.

Return Value:

    TRUE - if found a matching service name.

    FALSE - no matching service name found.

--*/
{
    LPENUM_SERVICE_STATUS_WOW64 EnumEntry;

    for (EnumEntry = EnumBuffer;
         EnumEntry < BufferEnd;
         EnumEntry++)
    {
        if (_wcsicmp((LPWSTR) ((LPBYTE) EnumEntry + EnumEntry->dwServiceNameOffset),
                     ServiceName) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


#ifndef _CAIRO_

VOID
ScCheckNetLogonDepend(
    LPSERVICE_RECORD    ServiceRecord,
    BOOL                DemandStarting
    )

/*++

Routine Description:

    If the current service is running in a remote account or if we are
    running on an Advanced Server (NtProductLanManNt), then this routine
    makes a (soft) dependency on Netlogon.  This dependency is not stored
    in the registry.

    Note that all services with account names that are UPNs will require
    the dependency on Netlogon.

Arguments:

    ServiceRecord - Pointer to the service record that is to be checked.

    DemandStarting - boolean that indicates if we are demand starting or
        auto starting.

Return Value:

    none - If something fails within this function, we will just press on
        since there isn't much we can do about it.

--*/
{
    DWORD   status;
    HKEY    ServiceNameKey;
    LPWSTR  DomainName;
    BOOL    bRemoteAccount=TRUE;
    LPSERVICE_RECORD    pNetLogonSR;

    //
    // Open the service name key.
    //
    status = ScOpenServiceConfigKey(
                 ServiceRecord->ServiceName,
                 KEY_READ,
                 FALSE,               // Create if missing
                 &ServiceNameKey
                 );

    if (status != NO_ERROR)
    {
        return;
    }

    //
    // Read the account name from the registry.
    //
    status = ScReadStartName(
                 ServiceNameKey,
                 &DomainName
                 );

    if (status != NO_ERROR || DomainName == NULL)
    {
        ScRegCloseKey(ServiceNameKey);
        return;
    }

    ScRegCloseKey(ServiceNameKey);

    if (_wcsicmp(DomainName, SC_LOCAL_SYSTEM_USER_NAME) == 0)
    {
        //
        // LocalSystem account, we don't need netlogon.
        //
        SC_LOG1(TRACE,"ScCheckNetLogonDepend: %ws Service is LocalSystem!\n",
            ServiceRecord->ServiceName);
        LocalFree(DomainName);
        return;
    }
    else if (wcsncmp(DomainName, L".\\", 2) == 0)
    {
        bRemoteAccount = FALSE;
        SC_LOG1(TRACE,"ScCheckNetLogonDepend: %ws Service has a local domain name\n",
            ServiceRecord->ServiceName);
    }
    else
    {
        //
        // Check for local-only accounts (domain name of NT AUTHORITY).  Note
        // that the domain name may be quoted.
        //
        LPWSTR lpTempDomain = DomainName;

        if (*lpTempDomain == '"')
        {
            lpTempDomain++;
        }

        if (_wcsnicmp(lpTempDomain,
                      SC_LOCAL_NTAUTH_NAME,
                      sizeof(SC_LOCAL_NTAUTH_NAME) / sizeof (WCHAR) - 1) == 0)
        {
            SC_LOG1(TRACE,
                    "ScCheckNetLogonDepend: %ws service is LocalService/NetworkService\n",
                    ServiceRecord->ServiceName);
            LocalFree(DomainName);
            return;
        }
    }

    LocalFree(DomainName);


    //
    // We know if it runs in a remote account or not.
    // Now we should check the product type.  If it is an
    // advanced server, or runs in an remote account, then
    // we need to start NetLogon.
    //
    if ((ScGlobalProductType == NtProductLanManNt) || (bRemoteAccount)) {
        //
        // Get the service record for NetLogon.
        //
        status = ScGetNamedServiceRecord(L"NetLogon", &pNetLogonSR);
        if (status != NO_ERROR) {
            return;
        }

        //
        // If it is already marked to start, then we don't
        // have to do anything right now.  If it isn't then
        // we should SetServiceStartRequest and create a
        // dependency.
        //
        if (CURRENTSTART_FLAG_IS_SET(pNetLogonSR)) {

            //
            // CurrentStartRequest of a dependency service is already
            // set to TRUE.  Just go on to next dependency.
            //
            SC_LOG2(DEPEND_DUMP, "DependService " FORMAT_LPWSTR
                    " CSR=TRUE already, USECOUNT=%lu\n",
                    pNetLogonSR->ServiceName,
                    pNetLogonSR->UseCount);
        }
        else {
            LPDEPEND_RECORD pDependRecord;

            SC_LOG(WHY, " Will start NetLogon because %ws runs in a remote account, or this is a server\n",
                    ServiceRecord->ServiceName);

            ScSetServiceStartRequest(pNetLogonSR,DemandStarting);

            //
            // Add the dependency to the service record and mark it as
            // temporary.
            //
            status = ScCreateDependRecord(TRUE,ServiceRecord,&pDependRecord);
            if (status != NO_ERROR) {
                return;
            }
            pDependRecord->DependType = TypeDependOnService;
            pDependRecord->DependService = pNetLogonSR;
        }
    }
    return;
}
#endif // _CAIRO_


BOOL
ScInHardwareProfile(
    IN  LPCWSTR ServiceName,
    IN  ULONG   GetDeviceListFlags
    )
/*++

Routine Description:

    This function checks whether a specified service is enabled in the
    current hardware profile.

Arguments:

    Service - Specifies the service of interest.

    GetDeviceListFlags - Specifies any special flags to be passed to
                         PNP_GetDeviceList.  The CM_GETIDLIST_DONOTGENERATE
                         flag indicates that a legacy device instance should
                         not be generated for the service.

Return Value:

    TRUE - if the service is enabled in the current hardware profile, or
        if this cannot be determined.

    FALSE - if the service is disabled in the current hardware profile.

--*/
{
    CONFIGRET   Status;
    BOOL        RetStatus;
    WCHAR       Buffer[200]; // default buffer on stack
    WCHAR *     pBuffer = Buffer;
    ULONG       cchLen;
    LPCWSTR     pDeviceID;

    //
    // Allocate a buffer for the list of device instances associated with
    // this service
    //
    Status = PNP_GetDeviceListSize(
                    NULL,                           // hBinding
                    ServiceName,                    // pszFilter
                    &cchLen,                        // list length in wchars
                    CM_GETIDLIST_FILTER_SERVICE);   // filter is a service name

    if (Status != CR_SUCCESS)
    {
        SC_LOG2(WARNING, "PNP_GetDeviceListSize failed %#lx for service %ws\n",
                       Status, ServiceName);
        return TRUE;
    }

    if (cchLen > LENGTH(Buffer))
    {
        SC_LOG2(DEPEND, "PNP_GetDeviceListSize wants a %lu-character buffer for service %ws\n",
                        cchLen, ServiceName);

        pBuffer = (WCHAR *) LocalAlloc(0, cchLen * sizeof(WCHAR));
        if (pBuffer == NULL)
        {
            SC_LOG(ERROR, "Couldn't allocate buffer for device list, error %lu\n",
                          GetLastError());
            return TRUE;
        }
    }
    else
    {
        cchLen = LENGTH(Buffer);
    }

    //
    // Initialize parameters for PNP_GetDeviceList, the same way as is
    // normally done in the client side of the API
    //
    pBuffer[0] = L'\0';

    //
    // Get the list of device instances that are associated with this service
    //
    // (For legacy services, the PNP manager makes up an artificial device
    // instance; but for PNP-aware services, we could get an empty device list.)
    //
    Status = PNP_GetDeviceList(
                    NULL,                           // binding handle
                    ServiceName,                    // pszFilter
                    pBuffer,                        // buffer for device list
                    &cchLen,                        // buffer length in wchars
                    CM_GETIDLIST_FILTER_SERVICE |   // filter is a service name
                    GetDeviceListFlags              // OR with passed in flag
                    );

    if (Status != CR_SUCCESS)
    {
        SC_LOG2(ERROR, "PNP_GetDeviceList failed %#lx for service %ws\n",
                       Status, ServiceName);
        RetStatus = TRUE;
        goto CleanExit;
    }

    //
    // Get each device instance's config flags.  The service is enabled in
    // the current hardware profile if at least one of its devices is enabled.
    //
    for (pDeviceID = pBuffer;
         pDeviceID[0] != L'\0';
         pDeviceID += wcslen(pDeviceID) + 1)
    {
        ULONG ConfigFlags;

        Status = PNP_HwProfFlags(
                        NULL,                       // binding handle
                        PNP_GET_HWPROFFLAGS,        // action: get, not set
                        pDeviceID,
                        0,                          // which profile: current one
                        &ConfigFlags,
                        NULL,
                        NULL,
                        0,
                        0                           // flags, MBZ
                        );

        if (Status == CR_SUCCESS)
        {
            if (!(ConfigFlags & (CSCONFIGFLAG_DISABLED |
                                 CSCONFIGFLAG_DO_NOT_CREATE)))
            {
                //
                // The device is enabled, so the service is enabled
                //
                RetStatus = TRUE;
                goto CleanExit;
            }
        }
        else
        {
            SC_LOG2(ERROR, "PNP_HwProfFlags failed %#lx for device %ws\n",
                           Status, pDeviceID);
        }
    }

    RetStatus = FALSE;
    SC_LOG(DEPEND, "The %ws service has no enabled device instances\n"
                   "          in this hardware profile.  Attempts to start\n"
                   "          it will result in ERROR_SERVICE_DISABLED.\n",
                   ServiceName);

CleanExit:

    if (pBuffer != Buffer)
    {
        LocalFree(pBuffer);
    }

    return RetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\control.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    control.cxx

Abstract:

    Contains code for setting up and maintaining the control interface
    and sending controls to services. Functions in this module:

    RControlService
    RI_ScSendTSMessage
    ScCreateControlInstance
    ScWaitForConnect
    ScSendControl
    ScInitTransactNamedPipe
    ScShutdownAllServices

Author:

    Dan Lafferty (danl)     20-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    13-Mar-1999     jschwart
    Added per-account security on the SCM <--> service control pipe

    07-Apr-1998     jschwart
    ScInitTransactNamedPipe:  Check registry for a user-supplied named
    pipe timeout value before setting it to the default.  With the old
    default (30000 ms), services could be double-started on a heavily
    loaded machine when the server would send to the client, the client's
    response would time out, and the server would assume it hadn't started.

    10-Mar-1998     jschwart
    Added ScSendPnPMessage and code to ScSendControl to enable passing
    of PnP-related service controls to services.  Got rid of flag added
    on 06-Aug-1997 since we can just check the passed-in OpCode instead

    06-Aug-1997     jschwart
        SendControl:  Added flag to tell SendControl if it is sending a
        shutdown message.  If so, it uses WriteFile, since using
        TransactNamedPipe with a poorly behaved service (that doesn't send
        an ACK back to the SCM) otherwise hangs the SCM.

        ShutdownAllServices:  Since SendControl now uses WriteFile (asynch
        write), added a case to the switch that checks to see if any services
        are still running.  If so, it gives them 30 seconds to become
        STOP_PENDING before it gives up and shuts itself down.

    05-Mar-1997     AnirudhS
    Eliminated limit of 100 pipe instances.

    04-Mar-1997     AnirudhS
    Added PARAMCHANGE, NETBINDADD, etc. controls for Plug and Play.

    28-May-1996     AnirudhS
    ScSendControl, ScWaitForConnect and ScCleanoutPipe:  If we time out
    waiting for a named pipe operation to complete, cancel it before
    returning.  Otherwise it trashes the stack if it does complete later.

    21-Feb-1995     AnirudhS
    ScShutdownAllServices: Fixed logic to wait for services in pending
    stop state.

    19-Oct-1993     Danl
    Initialize the Overlapped structures that are allocated on the stack.

    20-Jul-1993     danl
    SendControl:  If we get ERROR_PIPE_BUSY back from the transact call,
    then we need to clean out the pipe by reading it first - then do
    the transact.

    29-Dec-1992     danl
    Simplified calculation of elapsed time.  This removed complier
    warning about overflow in constant arithmetic.

    06-Mar-1992     danl
    SendControl: Fixed heap trashing problem where it didn't allocate
    the 4 extra alignment bytes in the case where there are no arguments.
    The registry name path becomes an argument even if there are no
    other agruments.  Therefore it requires alignment for any start cmd.

    20-Feb-1992     danl
    Get Pipe Handle only after we know we have an active service & the
    image record is good.

    20-Feb-1992     danl
    Only add 4 extra alignment bytes to control buffer when there
    are arguments to pass.

    31-Oct-1991     danl
    Fixed the logic governing the behavior under various service state
    and control opcode conditions.  Added State Table to description.
    This logic was taken directly from LM2.0.

    03-Sept-1991    danl
    Fixed alignment problem when marshalling args in ScSendControl.
    The array of offsets needs to be 4 byte aligned after the Service
    Name.

    20-Mar-1991     danl
    created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <stdlib.h>     // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <align.h>      // ROUND_UP_POINTER macro
#include <control.h>
#include <scseclib.h>   // ScCreateAndSetSD
#include "depend.h"     // ScDependentsStopped()
#include "driver.h"     // ScControlDriver()
#include "sclib.h"      // ScIsValidServiceName()
#include "scsec.h"      // ScStatusAccessCheck()

#include <dbt.h>        // PDEV_BROADCAST_HDR


//
// Constants
//
#define SC_DEFAULT_PIPE_TRANSACT_TIMEOUT    30000   // 30 sec
#define SC_PIPE_CLEANOUT_TIMEOUT            30      // 30 msec

//
// Registry key and value for the pipe timeout value
//
#define REGKEY_PIPE_TIMEOUT     L"System\\CurrentControlSet\\Control"
#define REGVAL_PIPE_TIMEOUT     L"ServicesPipeTimeout"

//
// Registry key, value, and constant for the shutdown performance metric
//
// #define SC_SHUTDOWN_METRIC

#ifdef SC_SHUTDOWN_METRIC

#define REGKEY_SHUTDOWN_TIMEOUT L"System\\CurrentControlSet\\Control"
#define REGVAL_SHUTDOWN_TIMEOUT L"ShutdownTimeout"

#endif  // SC_SHUTDOWN_METRIC

//
// STATIC DATA
//

/* static */ CRITICAL_SECTION   ScTransactNPCriticalSection;

//
// Globals
//
DWORD   g_dwScPipeTransactTimeout = SC_DEFAULT_PIPE_TRANSACT_TIMEOUT;


//
// Local Structure/Function Prototypes
//
typedef struct
{
    LPWSTR  lpServiceName;
    LPWSTR  lpDisplayName;
    HANDLE  hPipe;
}
TS_CONTROL_INFO, *PTS_CONTROL_INFO, *LPTS_CONTROL_INFO;

VOID
ScCleanOutPipe(
    HANDLE  PipeHandle
    );


/****************************************************************************/
DWORD
RControlService (
    IN  SC_RPC_HANDLE       hService,
    IN  DWORD               OpCode,
    OUT LPSERVICE_STATUS    lpServiceStatus
    )

/*++

Routine Description:

    RPC entry point for the RServiceControl API function.

    The following state table describes what is to happen under various
    state/Opcode conditions:

                                            [OpCode]

                                   STOP    INTERROGATE     OTHER
      [Current State]          _____________________________________
                              |           |            |            |
                      STOPPED |   (c)     |    (c)     |    (c)     |
                              |           |            |            |
                 STOP_PENDING |   (b)     |    (b)     |    (b)     |
                              |           |            |            |
                   START_PEND |   (a)     |    (d)     |    (b)     |
                              |           |            |            |
                      RUNNING |   (a)     |    (a)     |    (a)     |
                              |           |            |            |
                CONTINUE_PEND |   (a)     |    (a)     |    (a)     |
                              |           |            |            |
                PAUSE_PENDING |   (a)     |    (a)     |    (a)     |
                              |           |            |            |
                       PAUSED |   (a)     |    (a)     |    (a)     |
                              |___________|____________|____________|

    (a) Send control code to the service if the service is set up
        to receive this type of opcode.  If it is not set up to
        receive the opcode, return ERROR_INVALID_SERVICE_CONTROL.
        An example of this would be the case of sending a PAUSE to a
        service that is listed as NOT_PAUSABLE.

    (b) Do NOT send control code to the service.  Instead return
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL.

    (c) Do NOT send control code to the service.  Instead, return
        ERROR_SERVICE_NOT_ACTIVE.

    (d) Do NOT send control code to the service.  Instead, return
        the last known state of the service with a SUCCESS status.
        NOTE -- this case (and this case only) differs from the
        SDK doc, which hides the fact that you can interrogate a
        service that's in the START_PENDING state


Arguments:

    hService - This is a handle to the service.  It is actually a pointer
    to a service handle structure.

    OpCode - The control request code.

    lpServiceStatus - pointer to a location where the service status is to
    be returned.  If this pointer is invalid, it will be set to NULL
    upon return.

Return Value:

    The returned lpServiceStatus structure is valid as long as the returned
    status is NO_ERROR.

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The handle passed in was not a valid hService
    handle.

    NERR_InternalError - LocalAlloc or TransactNamedPipe failed, or
    TransactNamedPipe returned fewer bytes than expected.

    ERROR_SERVICE_REQUEST_TIMEOUT - The service did not respond with a status
    message within the fixed timeout limit (RESPONSE_WAIT_TIMEOUT).

    NERR_ServiceKillProc - The service process had to be killed because
    it wouldn't terminate when requested.

    ERROR_SERVICE_CANNOT_ACCEPT_CTRL - The service cannot accept control
    messages at this time.

    ERROR_INVALID_SERVICE_CONTROL - The request is not valid for this service.
    For instance, a PAUSE request is not valid for a service that
    lists itself as NOT_PAUSABLE.

    ERROR_INVALID_PARAMETER - The requested control is not valid.

    ERROR_ACCESS_DENIED - This is a status response from the service
    security check.


Note:
    Because there are multiple services in a process, we cannot simply
    kill the process if the service does not respond to a terminate
    request.  This situation is handled by first checking to see if
    this is the last service in the process.  If it is, then it is
    removed from the installed database, and the process is terminated.
    If it isn't the last service, then we indicate timeout and do
    nothing.

--*/

{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    serviceRecord;
    DWORD               currentState;
    DWORD               controlsAccepted;
    DWORD               controlsAcceptedMask = 0;
    HANDLE              pipeHandle = NULL;
    LPWSTR              serviceName;
    LPWSTR              displayName;
    ACCESS_MASK         desiredAccess;


    if (ScShutdownInProgress)
    {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

#ifdef SC_DEBUG

//****************************************************************************
    if (OpCode == 5555)
    {
        ScShutdownNotificationRoutine(CTRL_SHUTDOWN_EVENT);
    }
//****************************************************************************

#endif  // SC_DEBUG

    //
    // Set the desired access based on the control requested.
    // Figure out which "controls accepted" bits must be set for the
    // service to accept the control.
    //
    switch (OpCode) {
    case SERVICE_CONTROL_STOP:
        desiredAccess = SERVICE_STOP;
        controlsAcceptedMask = SERVICE_ACCEPT_STOP;
        break;

    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
        desiredAccess = SERVICE_PAUSE_CONTINUE;
        controlsAcceptedMask = SERVICE_ACCEPT_PAUSE_CONTINUE;
        break;

    case SERVICE_CONTROL_INTERROGATE:
        desiredAccess = SERVICE_INTERROGATE;
        break;

    case SERVICE_CONTROL_PARAMCHANGE:
        desiredAccess = SERVICE_PAUSE_CONTINUE;
        controlsAcceptedMask = SERVICE_ACCEPT_PARAMCHANGE;
        break;

    case SERVICE_CONTROL_NETBINDADD:
    case SERVICE_CONTROL_NETBINDREMOVE:
    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:
        desiredAccess = SERVICE_PAUSE_CONTINUE;
        controlsAcceptedMask = SERVICE_ACCEPT_NETBINDCHANGE;
        break;

    default:
        if ((OpCode >= OEM_LOWER_LIMIT) &&
            (OpCode <= OEM_UPPER_LIMIT)) {

            desiredAccess = SERVICE_USER_DEFINED_CONTROL;
        }
        else {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Was the handle opened with desired control access?
    //
    if (! RtlAreAllAccessesGranted(
          ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
          desiredAccess
          )) {

        return(ERROR_ACCESS_DENIED);
    }
    serviceRecord =
        ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;


    //
    // If this control is for a driver, call ScControlDriver and return.
    //
    if (serviceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER) {
        return(ScControlDriver(OpCode, serviceRecord, lpServiceStatus));
    }


    //
    // Obtain a shared lock on the database - read the data we need,
    // Then free the lock.
    //
    {
        CServiceRecordSharedLock RLock;

        //
        // Once we get to this point, copy in the last known
        // status to return to the caller (Bug #188874)
        //

        RtlCopyMemory(lpServiceStatus,
                      &(serviceRecord->ServiceStatus),
                      sizeof(SERVICE_STATUS));

        currentState     = serviceRecord->ServiceStatus.dwCurrentState;
        controlsAccepted = serviceRecord->ServiceStatus.dwControlsAccepted;
        serviceName      = serviceRecord->ServiceName;
        displayName      = serviceRecord->DisplayName;

        //
        // If we can obtain a pipe handle, do so.  Otherwise, return an error.
        // (but first release the lock).
        //
        if ((currentState != SERVICE_STOPPED) &&
            (serviceRecord->ImageRecord != NULL)) {

            pipeHandle = serviceRecord->ImageRecord->PipeHandle;

        }
        else {
            status = ERROR_SERVICE_NOT_ACTIVE;
        }
    }

    if (status != NO_ERROR) {
        return(status);
    }

    //
    // The control is not sent to the service if the service is in
    // either the STOP_PENDING or START_PENDING state EXCEPT - we
    // allow STOP controls to a service that is START_PENDING.
    //
    // If we decide not to allow the control to be sent, we either
    // return current info (INTERROGATE) or an error (any other opcode).
    //
    if (currentState == SERVICE_STOP_PENDING) {

        return(ERROR_SERVICE_CANNOT_ACCEPT_CTRL);
    }
    else if (currentState == SERVICE_START_PENDING) {

        switch(OpCode) {
        case SERVICE_CONTROL_INTERROGATE:
            //
            // Just return the last known status.  This behavior is unpublished.
            //
            return(NO_ERROR);

        case SERVICE_CONTROL_STOP:
            break;

        default:
            return(ERROR_SERVICE_CANNOT_ACCEPT_CTRL);
        }
    }

    //
    // Check if the service accepts the control.
    //
    if ( (controlsAccepted & controlsAcceptedMask) != controlsAcceptedMask ) {

        return(ERROR_INVALID_SERVICE_CONTROL);
    }

    //
    // Check for dependent services still running
    //
    BOOL fLastService = FALSE;
    if (OpCode == SERVICE_CONTROL_STOP) {

        CServiceRecordSharedLock RLock;

        if (! ScDependentsStopped(serviceRecord)) {
            return(ERROR_DEPENDENT_SERVICES_RUNNING);
        }

        if (serviceRecord->ImageRecord != NULL &&
            serviceRecord->ImageRecord->ServiceCount == 1) {

            fLastService = TRUE;
        }
    }

    //
    // Send the control request to the target service
    //
    status = ScSendControl(serviceName,    // ServiceName
                           displayName,    // DisplayName
                           pipeHandle,     // pipeHandle
                           OpCode,         // Opcode
                           NULL,           // CmdArgs (vector ptr)
                           0L,             // NumArgs
                           NULL);          // Ignore handler return value

    if (status == NO_ERROR) {
        //
        // If no errors occured, copy the latest status into the return
        // buffer.  The shared lock is required for this.
        //
        CServiceRecordSharedLock RLock;

        RtlCopyMemory(lpServiceStatus,
                      &(serviceRecord->ServiceStatus),
                      sizeof(SERVICE_STATUS));
    }
    else {

        SC_LOG2(ERROR,"RControlService:SendControl to %ws service failed %ld\n",
            serviceRecord->ServiceName, status);

        if (OpCode == SERVICE_CONTROL_STOP) {

            //
            // If sending the control failed, and the control was a request
            // to stop, and if this service is the only running service in
            // the process, we can force the process to stop.  ScRemoveService
            // will handle this if the ServiceCount is one.
            //

            if (fLastService) {
                SC_LOG0(TRACE,"RControlService:Forcing Service Shutdown\n");
                ScRemoveService(serviceRecord);
            }
        }
    }
    return(status);
}



/****************************************************************************/
DWORD
ScCreateControlInstance (
    OUT LPHANDLE    PipeHandlePtr,
    IN  DWORD       dwCurrentService,
    IN  PSID        pAccountSid
    )

/*++

Routine Description:

    This function creates an instance of the control pipe

Arguments:

    PipeHandlePtr - This is a pointer to a location where the pipe handle
                    is to be placed upon return.

    dwCurrentService - This is used to create a uniquely-named pipe

    pAccountSid - The SID of the account that is allowed to access this pipe

Return Value:

    NO_ERROR - The operation was successful.

    other - Any error returned by CreateNamedPipe could be returned.

--*/
{
    DWORD                status;

    NTSTATUS             ntstatus;
    SECURITY_ATTRIBUTES  SecurityAttr;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    WCHAR wszPipeName[sizeof(CONTROL_PIPE_NAME) / sizeof(WCHAR) + PID_LEN] = CONTROL_PIPE_NAME;

    SC_ACE_DATA AceData[1] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            GENERIC_ALL,                  &pAccountSid}

        };

    //
    // Generate the pipe name
    //
    _itow(dwCurrentService, wszPipeName + sizeof(CONTROL_PIPE_NAME) / sizeof(WCHAR) - 1, 10);

    //
    // Create a security descriptor for the control named pipe so
    // that we can grant access to it solely to the service's account
    //
    ntstatus = ScCreateAndSetSD(
           AceData,
           1,
           LocalSystemSid,
           LocalSystemSid,
           &SecurityDescriptor
           );

    if (! NT_SUCCESS(ntstatus)) {

        SC_LOG1(ERROR, "ScCreateAndSetSD failed " FORMAT_NTSTATUS
            "\n", ntstatus);
        return (RtlNtStatusToDosError(ntstatus));
    }

    SecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttr.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttr.bInheritHandle = FALSE;

    //
    // Create the service controller's end of the named pipe that will
    // be used for communicating control requests to the service process.
    // Use FILE_FLAG_FIRST_PIPE_INSTANCE to make sure that we're the
    // creator of the named pipe (vs. a malicious process that creates
    // the pipe first and thereby gains access to the client service
    // that connects to it).
    //

    *PipeHandlePtr = CreateNamedPipe (
            wszPipeName,
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
            PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE,
            1,                         // one instance per process
            8000,
            sizeof(PIPE_RESPONSE_MSG),
            CONTROL_TIMEOUT,           // Default Timeout
            &SecurityAttr);            // Security Descriptor

    status = NO_ERROR;

    if (*PipeHandlePtr == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        SC_LOG1(ERROR,
            "CreateControlInstance: CreateNamedPipe failed, %ld\n",status);
    }

    (void) RtlDeleteSecurityObject(&SecurityDescriptor);
    return(status);
}


/****************************************************************************/
DWORD
ScWaitForConnect (
    IN  HANDLE    PipeHandle,
    IN  HANDLE    hProcess       OPTIONAL,
    IN  LPWSTR    lpDisplayName,
    OUT LPDWORD   ProcessIdPtr
    )

/*++

Routine Description:

    This function waits until a connection is made to the pipe handle.
    It then waits for the first status message to be sent from the
    service process.

    The first message from the service contains the processId.  This
    helps to verify that we are talking to the correct process.

Arguments:

    PipeHandle - This is the handle to the pipe instance that is waiting
                 for a connect.

    hProcess - The handle to the service process.  We wait on this handle
               and the pipe handle in case the process exits before the
               pipe transaction times out.

    lpDisplayName - The name of the service for which we're waiting.

    ProcessIdPtr - This is a pointer to the location where the processId is
                   to be stored.

Return Value:

    NO_ERROR - The pipe is in the connected state.

    any error that ReadFile can produce may be returned.

Note:
    The ConnectNamedPipe called is done asynchronously and we wait
    on its completion using the pipe handle.  This can only work
    correctly when it is guaranteed that no other IO is issued
    while we are waiting on the pipe handle (except for the service
    itself to connect to the pipe with call to CreateFile).

--*/
{
    PIPE_RESPONSE_MSG   serviceResponseBuffer;
    DWORD               numBytesRead;
    BOOL                status;
    DWORD               apiStatus;
    OVERLAPPED          overlapped={0,0,0,0,0};// overlapped structure to implement
                           // timeout on TransactNamedPipe

    CONST HANDLE phHandles[] = { PipeHandle, hProcess };
    DWORD        dwCount     = (hProcess == NULL ? 1 : 2);

#if DBG

    DWORD   dwStartTick;
    DWORD   dwTotalTime;

#endif  // DBG


    SC_LOG(TRACE,"ServiceController waiting for pipe connect\n",0);

    overlapped.hEvent = (HANDLE) NULL;   // Wait on pipe handle

    //
    // Wait for the service to connect.
    //
    status = ConnectNamedPipe(PipeHandle, &overlapped);

    if (status == FALSE) {

        apiStatus = GetLastError();

        if (apiStatus == ERROR_IO_PENDING) {

#if DBG

            dwStartTick = GetTickCount();

#endif  // DBG

            //
            // Connection is pending
            //
            apiStatus = WaitForMultipleObjects(dwCount,
                                               phHandles,
                                               FALSE,     // Wait for any
                                               g_dwScPipeTransactTimeout);

#if DBG

            dwTotalTime = GetTickCount() - dwStartTick;

            if (dwTotalTime > SC_DEFAULT_PIPE_TRANSACT_TIMEOUT) {

                SC_LOG1(ERROR,
                        "ScWaitForConnect: Wait on ConnectNamedPipe took %u milliseconds\n",
                        dwTotalTime);
            }

#endif  // DBG

            if (apiStatus == WAIT_OBJECT_0) {

                //
                // Wait completed successfully -- the object that
                // signalled was the pipe handle
                //
                status = GetOverlappedResult(
                         PipeHandle,
                         &overlapped,
                         &numBytesRead,
                         TRUE
                         );

                if (status == FALSE) {
                    apiStatus = GetLastError();

                    SC_LOG(ERROR,
                           "ScWaitForConnect: GetOverlappedResult failed, rc=%lu\n",
                           apiStatus);

                    return apiStatus;

                }
            }

            else {

                //
                // Either the connection timed out or the service process
                // exited before calling StartServiceCtrlDispatcher
                //

                SC_LOG2(ERROR,
                        "ScWaitForConnect: Wait for connection for %u secs timed out --"
                            "service process DID %s exit\n",
                        g_dwScPipeTransactTimeout / 1000,
                        (apiStatus == WAIT_TIMEOUT ? "NOT" : ""));

                //
                // The service didn't respond.  Cancel the named pipe operation.
                //
                status = CancelIo(PipeHandle);

                if (status == FALSE) {

                    SC_LOG(ERROR, "ScWaitForConnect: CancelIo failed, %lu\n", GetLastError());
                }

                ScLogEvent(
                    NEVENT_CONNECTION_TIMEOUT,
                    g_dwScPipeTransactTimeout,
                    lpDisplayName
                    );

                return ERROR_SERVICE_REQUEST_TIMEOUT;
            }
        }
        else if (apiStatus != ERROR_PIPE_CONNECTED) {

            SC_LOG(ERROR,"ScWaitForConnect: ConnectNamedPipe failed, rc=%lu\n",
                   apiStatus);

            return apiStatus;
        }

        //
        // If we received the ERROR_PIPE_CONNECTED status, then things
        // are still ok.
        //
    }


    SC_LOG(TRACE,"WaitForConnect:ConnectNamedPipe Success\n",0);

    //
    // Wait for initial status message
    //
    overlapped.hEvent = (HANDLE) NULL;   // Wait on pipe handle

    status = ReadFile (PipeHandle,
                       (LPVOID)&serviceResponseBuffer,
                       sizeof(serviceResponseBuffer),
                       &numBytesRead,
                       &overlapped);

    if (status == FALSE) {

        apiStatus = GetLastError();

        if (apiStatus == ERROR_IO_PENDING) {

#if DBG

            dwStartTick = GetTickCount();

#endif  // DBG

            //
            // Connection is pending
            //
            apiStatus = WaitForSingleObject(PipeHandle, g_dwScPipeTransactTimeout);

#if DBG

            dwTotalTime = GetTickCount() - dwStartTick;

            if (dwTotalTime > SC_DEFAULT_PIPE_TRANSACT_TIMEOUT) {

                SC_LOG1(ERROR,
                        "ScWaitForConnect: Wait on ReadFile took %u milliseconds\n",
                        dwTotalTime);
            }

#endif  // DBG

            if (apiStatus == WAIT_TIMEOUT) {

                SC_LOG(ERROR,
                       "ScWaitForConnect: Wait for ReadFile for %u secs timed out\n",
                       g_dwScPipeTransactTimeout / 1000 );

                //
                // Cancel the named pipe operation.
                //
                status = CancelIo(PipeHandle);

                if (status == FALSE) {

                    SC_LOG(ERROR, "ScWaitForConnect: CancelIo failed, %lu\n", GetLastError());
                }

                ScLogEvent(
                    NEVENT_READFILE_TIMEOUT,
                    g_dwScPipeTransactTimeout
                    );

                return ERROR_SERVICE_REQUEST_TIMEOUT;


            } else if (apiStatus == 0) {

                //
                // Wait completed successfully
                //
                status = GetOverlappedResult(PipeHandle,
                                             &overlapped,
                                             &numBytesRead,
                                             TRUE);

                if (status == FALSE) {
                    apiStatus = GetLastError();

                    SC_LOG(ERROR,
                           "ScWaitForConnect: GetOverlappedResult for ReadFile failed, rc=%lu\n",
                           apiStatus);

                    return apiStatus;
                }
            }
        }
        else {
            SC_LOG(ERROR,"ScWaitForConnect: ReadFile failed, rc=%lu\n",
            apiStatus);
            return apiStatus;
        }
    }

    SC_LOG0(TRACE,"WaitForConnect:ReadFile success\n");

    SC_LOG(
        TRACE,
        "WaitForConnect:ReadFile buffer size = %ld\n",
        sizeof(serviceResponseBuffer));

    SC_LOG(
        TRACE,
        "WaitForConnect:ReadFile numBytesRead = %ld\n",
        numBytesRead);


    *ProcessIdPtr = serviceResponseBuffer.dwDispatcherStatus;

    return(NO_ERROR);
}


/****************************************************************************/
DWORD
ScValidatePnPService(
    IN  LPWSTR                   lpServiceName,
    OUT SERVICE_STATUS_HANDLE    *lphServiceStatus
    )
{
    DWORD               dwError;
    LPSERVICE_RECORD    lpServiceRecord;

    //
    // Make sure PnP is supplying a valid OUT parameter
    //
    SC_ASSERT(lphServiceStatus != NULL);

    //
    // Validate the format of the service name.
    //
    if (! ScIsValidServiceName(lpServiceName))
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Find the service record in the database.
    //

    CServiceListSharedLock LLock;

    dwError = ScGetNamedServiceRecord(lpServiceName,
                                      &lpServiceRecord);

    if (dwError != NO_ERROR)
    {
        return(dwError);
    }

    CServiceRecordSharedLock RLock;

    //
    // Make sure the service specified is the service
    // that requested device notification
    //
    dwError = ScStatusAccessCheck(lpServiceRecord);

    if (dwError == NO_ERROR)
    {
        *lphServiceStatus = (SERVICE_STATUS_HANDLE)lpServiceRecord;
    }

    return dwError;
}


DWORD
ScSendPnPMessage(
    IN  SERVICE_STATUS_HANDLE   hServiceStatus,
    IN  DWORD                   OpCode,
    IN  DWORD                   dwEventType,
    IN  LPARAM                  EventData,
    OUT LPDWORD                 lpdwHandlerRetVal
    )

/*++

Routine Description:

    This function is called by PnP when it needs to send a control to a
    service that has requested notification.  It simply packs the args and
    calls ScSendControl.

Arguments:

    OpCode - This is the opcode that is to be passed to the service.

    dwEventType - The PnP event that has occurred

    EventData - Pointer to other information the service may want


Return Value:

    ERROR_SERVICE_NOT_ACTIVE - The named service has no image record

    In addition, any value passed back from ScGetNamedImageRecord or ScSendControl

--*/

{
    LPSERVICE_RECORD    lpServiceRecord;
    CONTROL_ARGS        ControlArgs;
    LPWSTR              lpServiceName;
    LPWSTR              lpDisplayName;
    HANDLE              hPipe;

    //
    // Make sure this handle is valid (in case the service in question
    // was deleted and was signed up for device notifications)
    //
    // BUGBUG -- We should call a PnP callback and have it free up the
    //           node for the service in question if it's deleted
    //

    SC_ASSERT(((LPSERVICE_RECORD) hServiceStatus)->Signature == SERVICE_SIGNATURE);

    //
    // Make sure PnP is giving us a valid OUT parameter
    //
    SC_ASSERT(lpdwHandlerRetVal != NULL);

    lpServiceRecord = (LPSERVICE_RECORD)hServiceStatus;

    {
        //
        // Get the information we need then release the lock
        //
        CServiceRecordSharedLock  RLock;

        if (lpServiceRecord->ImageRecord == NULL)
        {
            return ERROR_SERVICE_NOT_ACTIVE;
        }

        lpServiceName = lpServiceRecord->ServiceName;
        lpDisplayName = lpServiceRecord->DisplayName;
        hPipe         = lpServiceRecord->ImageRecord->PipeHandle;
    }

    //
    // If it's a PnP device event, pass along the arguments for the named pipe
    //
    switch (OpCode) {

        case SERVICE_CONTROL_DEVICEEVENT:

            //
            // Make sure that either both the size and buffer are
            // 0 and NULL or that they're non-zero and non-NULL
            //
            SC_ASSERT(((PDEV_BROADCAST_HDR)EventData)->dbch_size && EventData ||
                      !((PDEV_BROADCAST_HDR)EventData)->dbch_size && !EventData);

            ControlArgs.PnPArgs.dwEventType     = dwEventType;
            ControlArgs.PnPArgs.dwEventDataSize = ((PDEV_BROADCAST_HDR)EventData)->dbch_size;
            ControlArgs.PnPArgs.EventData       = (VOID *)EventData;

            break;

        case SERVICE_CONTROL_POWEREVENT:
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE:

            //
            // Hardware Profile Change and Power messages have no LPARAM.
            // They just tell a service that something noteworthy has happened.
            //
            SC_ASSERT(EventData == NULL);

            ControlArgs.PnPArgs.dwEventType     = dwEventType;
            ControlArgs.PnPArgs.dwEventDataSize = 0;
            ControlArgs.PnPArgs.EventData       = NULL;
            break;


        default:
            SC_ASSERT(FALSE);
            break;
    }

    return ScSendControl(lpServiceName,
                         lpDisplayName,
                         hPipe,
                         OpCode,
                         &ControlArgs,
                         3,             // 3 PnP arguments
                         lpdwHandlerRetVal);
}


DWORD
RI_ScSendTSMessage (
    IN SC_RPC_HANDLE   hSCManager,
    IN DWORD           OpCode,
    IN DWORD           dwEvent,
    IN DWORD           cbData,
    IN LPBYTE          lpData
    )
{
    LPSERVICE_RECORD   lpServiceRecord;
    CONTROL_ARGS       ControlArgs;
    DWORD              dwAcceptedMask;
    DWORD              dwError;
    DWORD              dwNumServices = 0;
    DWORD              i;
    LPTS_CONTROL_INFO  lpControlInfo;

    lpServiceRecord = NULL;

    ControlArgs.PnPArgs.dwEventType     = dwEvent;
    ControlArgs.PnPArgs.dwEventDataSize = cbData;
    ControlArgs.PnPArgs.EventData       = lpData;

    if (OpCode != SERVICE_CONTROL_SESSIONCHANGE)
    {
        ASSERT(OpCode == SERVICE_CONTROL_SESSIONCHANGE);
        return ERROR_INVALID_PARAMETER;
    }

    dwAcceptedMask = SERVICE_ACCEPT_SESSIONCHANGE;

    //
    // Make sure that the caller is LocalSystem
    //

    dwError = ScStatusAccessCheck(NULL);

    if (dwError != NO_ERROR)
    {
        SC_LOG1(ERROR,
                "RI_ScSendTSMessage: ScStatusAccessCheck failed %d\n",
                dwError);

        return dwError;
    }

    {
        CServiceListSharedLock       LLock;
        CServiceRecordExclusiveLock  RLock;

        //
        // Go through the list and copy out the pointer to the service name and
        // the pipe handle for each service that wants to receive this control.
        // We do this so we can call ScSendControl for each service afterwards
        // without holding the locks required to traverse the list.  Note that
        // it's conceivable that the service name will be junk by the time
        // ScSendControl is called (if the service is deleted before the call)
        // but if that's the case, the pipe handle will be invalid, causing the
        // call to fail gracefully.
        //

        FOR_SERVICES_THAT(lpServiceRecord,
        (lpServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32) &&
        (lpServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED) &&
        (lpServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) &&
        (lpServiceRecord->ServiceStatus.dwControlsAccepted & dwAcceptedMask) &&
        (lpServiceRecord->ImageRecord != NULL)
        )
        {
            dwNumServices++;
        }

        if (dwNumServices == 0)
        {
            //
            // No services accept the control
            //
            return NO_ERROR;
        }

        lpControlInfo = (LPTS_CONTROL_INFO) LocalAlloc(LMEM_FIXED,
                                                       dwNumServices * sizeof(TS_CONTROL_INFO));

        if (lpControlInfo == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwNumServices = 0;

        FOR_SERVICES_THAT(lpServiceRecord,
        (lpServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32) &&
        (lpServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED) &&
        (lpServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) &&
        (lpServiceRecord->ServiceStatus.dwControlsAccepted & dwAcceptedMask) &&
        (lpServiceRecord->ImageRecord != NULL)
        )
        {
            //
            // Copy out the information we need
            //

            lpControlInfo[dwNumServices].lpServiceName = lpServiceRecord->ServiceName;
            lpControlInfo[dwNumServices].lpDisplayName = lpServiceRecord->DisplayName;
            lpControlInfo[dwNumServices].hPipe = lpServiceRecord->ImageRecord->PipeHandle;
            dwNumServices++;
        }
    }

    for (i = 0; i < dwNumServices; i++)
    {
        //
        // Send the control
        //

        dwError = ScSendControl(lpControlInfo[i].lpServiceName,
                                lpControlInfo[i].lpDisplayName,
                                lpControlInfo[i].hPipe,
                                OpCode,
                                &ControlArgs,
                                3,
                                NULL);

        //
        // Ignore any errors sending the control
        //

        if (dwError != NO_ERROR)
        {
            SC_LOG2(ERROR,
                    "RI_ScSendTSMessage:  Error %d sending control to %ws service\n",
                    dwError,
                    lpControlInfo[i].lpServiceName);
        }
    }

    LocalFree(lpControlInfo);

    return NO_ERROR;
}


/****************************************************************************/
DWORD
ScSendControl(
    IN  LPWSTR                  ServiceName,
    IN  LPWSTR                  DisplayName,
    IN  HANDLE                  PipeHandle,
    IN  DWORD                   OpCode,
    IN  LPCONTROL_ARGS          lpControlArgs OPTIONAL,
    IN  DWORD                   NumArgs,
    OUT LPDWORD                 lpdwHandlerRetVal OPTIONAL
    )

/*++

Routine Description:

    This function sends a control request to a service via a
    TransactNamedPipe call.  A buffer is allocated for the transaction,
    and then freed when done.

    LOCKS:
    Normally locks are not held when this function is called.  This is
    because we need to allow status messages to come in prior to the
    transact completing.  The exception is when we send the message
    to the control dispatcher to shutdown.  No status message is sent
    in response to that.

    There is a ScTransactNPCriticalSection that is held during the actual
    Transact.

Arguments:

    ServiceName - This is a pointer to a NUL terminated service name string.

    PipeHandle - This is the pipe handle to which the request is directed.

    OpCode - This is the opcode that is to be passed to the service.

    lpControlArgs - This is an optional pointer to a CONTROL_ARGS union,
    which can contain either an array of pointers to NUL-terminated
    strings (for the SERVICE_CONTROL_START case) or a structure that
    holds Plug-and-Play arguments (for the SERVICE_CONTROL_DEVICEEVENT,
    SERVICE_CONTROL_POWEREVENT, SERVICE_CONTROL_HARDWAREPROFILECHANGE,
    and SERVICE_CONTROL_SESSIONCHANGE cases).

    NumArgs - This indicates how many arguments are in the structure
    lpControlArgs contains.  For SERVICE_CONTROL_START, it's the number
    of strings in the argument array.  For Plug-and-Play events, it's
    the number of arguments in a Plug-and-Play message (currently 3)

    lpdwHandlerRetVal - The return value from the Service's control handler

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_GEN_FAILURE - An incorrect number of bytes was received
    in the response message.

    ERROR_ACCESS_DENIED - This is a status response from the service
    security check by the Control Dispatcher on the other end of the
    pipe.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate memory for the transaction
    buffer. (Local Alloc failed).

    other - Any error from TransactNamedPipe could be returned - Or any
        error from the Control Dispatcher on the other end of the pipe.

--*/
{
    DWORD               returnStatus = NO_ERROR;
    LPCTRL_MSG_HEADER   lpcmhBuffer;        // Message buffer
    DWORD               serviceNameSize;
    DWORD               sendBufferSize;
    BOOL                status;
    PIPE_RESPONSE_MSG   serviceResponseBuffer;
    DWORD               bytesRead;
    DWORD               i;

    static OVERLAPPED   overlapped={0,0,0,0,0}; // overlapped structure to implement
                                                // timeout on TransactNamedPipe
                                                // static because on shutdown, we'll
                                                // be firing off a bunch of async
                                                // writes, which write to the overlapped
                                                // structure upon completion, and we
                                                // don't want them trashing the stack

    if (ARGUMENT_PRESENT(lpdwHandlerRetVal))
    {
        //
        // Initialize the OUT pointer
        //
        *lpdwHandlerRetVal = NO_ERROR;
    }

    serviceNameSize = (DWORD) WCSSIZE(ServiceName);
    sendBufferSize = serviceNameSize + sizeof(CTRL_MSG_HEADER);

    //
    // Add an extra PVOID size to help settle alignment problems that
    // may occur when the array of pointers follows the service name string.
    //
    sendBufferSize += sizeof(PVOID);

    //
    // There are control arguments, so add their size to the buffer size
    //
    if (lpControlArgs != NULL) {

        if (OpCode == SERVICE_CONTROL_START_SHARE ||
            OpCode == SERVICE_CONTROL_START_OWN) {

            //
            // Service is starting
            //
            for (i = 0; i < NumArgs; i++) {
                sendBufferSize += (DWORD) WCSSIZE(lpControlArgs->CmdArgs[i]) +
                                  sizeof(LPWSTR);
            }
        }
        else {

            SC_ASSERT(OpCode == SERVICE_CONTROL_DEVICEEVENT ||
                      OpCode == SERVICE_CONTROL_HARDWAREPROFILECHANGE ||
                      OpCode == SERVICE_CONTROL_POWEREVENT ||
                      OpCode == SERVICE_CONTROL_SESSIONCHANGE);

            //
            // PnP event
            //
            sendBufferSize += sizeof(lpControlArgs->PnPArgs.dwEventType);
            sendBufferSize += sizeof(lpControlArgs->PnPArgs.dwEventDataSize);

            sendBufferSize += lpControlArgs->PnPArgs.dwEventDataSize;
        }
    }


    //
    // Allocate the buffer and set a pointer to it that knows the structure
    // of the header.
    //
    lpcmhBuffer = (LPCTRL_MSG_HEADER)LocalAlloc(LMEM_ZEROINIT, sendBufferSize);

    if (lpcmhBuffer == NULL) {
        SC_LOG(TRACE,"SendControl:LocalAlloc failed, rc=%d/n", GetLastError());
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    /////////////////////////////////////////////////////////////////////
    // Marshall the data into the buffer.
    //
    //
    // The Control Message looks like this for service start:
    //  CTRL_MSG_HEADER     Header
    //  WCHAR               ServiceName[?]
    //  LPWSTR              Argv0 offset
    //  LPWSTR              Argv1 offset
    //  LPWSTR              Argv2 offset
    //  LPWSTR              ...
    //  WCHAR               Argv0[?]
    //  WCHAR               Argv1[?]
    //  WCHAR               Argv2[?]
    //  WCHAR               ...
    //
    // and like this for PNP events:
    //  CTRL_MSG_HEADER     Header
    //  WCHAR               ServiceName[?]
    //  DWORD               wParam
    //  BYTE                lParam[?]
    //

    lpcmhBuffer->OpCode       = OpCode;
    lpcmhBuffer->Count        = sendBufferSize;

    //
    // Copy the service name to buffer and store the offset.
    //

    lpcmhBuffer->ServiceNameOffset = sizeof(CTRL_MSG_HEADER);
    wcscpy((LPWSTR)(lpcmhBuffer + 1), ServiceName);

    //
    // Pack message-specific arguments as necessary
    //
    switch (OpCode) {

        case SERVICE_CONTROL_START_SHARE:
        case SERVICE_CONTROL_START_OWN:

            if (NumArgs > 0) {

                //
                // Service start -- Determine the offset from the top of the argv
                // array to the first argv string.  Also determine the pointer value
                // for that location.
                //
                DWORD     dwOffset   = NumArgs * sizeof(LPWSTR);
                LPWSTR    *ppwszArgs;

                //
                // Calculate the beginning of the string area and the beginning
                // of the arg vector area.  Align the vector pointer on a PVOID
                // boundary.
                //

                ppwszArgs = (LPWSTR *)((LPBYTE)(lpcmhBuffer + 1) + serviceNameSize);
                ppwszArgs = (LPWSTR *)ROUND_UP_POINTER(ppwszArgs, sizeof(PVOID));

                lpcmhBuffer->ArgvOffset = (DWORD)((LPBYTE)ppwszArgs - (LPBYTE)lpcmhBuffer);
                lpcmhBuffer->NumCmdArgs = NumArgs;

                //
                // Copy the command arg strings to the buffer and update the argv
                // pointers with offsets.  Remember - we already have one argument
                // in there for the service registry path.
                //
                for (i = 0; i < NumArgs; i++) {

                    wcscpy((LPWSTR) ((LPBYTE)ppwszArgs + dwOffset),
                           lpControlArgs->CmdArgs[i]);

                    ppwszArgs[i] = (LPWSTR)(DWORD_PTR) dwOffset;
                    dwOffset    += (DWORD) WCSSIZE(lpControlArgs->CmdArgs[i]);
                }
            }
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
        case SERVICE_CONTROL_POWEREVENT:
        case SERVICE_CONTROL_SESSIONCHANGE:
        {
            LPDWORD   lpdwArgLocation;

            //
            // Calculate the location for the PnP/power arguments.
            // Align the pointer on a PVOID boundary.
            //
            lpdwArgLocation = (LPDWORD)((LPBYTE)(lpcmhBuffer + 1) + serviceNameSize);
            lpdwArgLocation = (LPDWORD)ROUND_UP_POINTER(lpdwArgLocation, sizeof(PVOID));

            lpcmhBuffer->ArgvOffset = (DWORD)((LPBYTE)lpdwArgLocation - (LPBYTE)lpcmhBuffer);

            //
            // Copy the wParam into the buffer
            //
            *lpdwArgLocation = lpControlArgs->PnPArgs.dwEventType;

            //
            // Copy the lParam into the buffer
            //
            RtlCopyMemory(lpdwArgLocation + 1,
                          lpControlArgs->PnPArgs.EventData,
                          lpControlArgs->PnPArgs.dwEventDataSize);
            break;
        }
    }


    // If the SCM is sending a shutdown message to a service, we want to just
    // use WriteFile instead of TransactNamedPipe, since a badly behaved service
    // that doesn't write back to the pipe leaves the SCM hanging and unable to
    // properly shut down the remaining services

    SC_LOG0(LOCKS,"SendControl: Entering TransactPipe Critical Section.\n");
    EnterCriticalSection(&ScTransactNPCriticalSection);

    if (OpCode == SERVICE_CONTROL_SHUTDOWN) {

        SC_LOG0(SHUTDOWN,
                "ScSendControl: Using WriteFile to send a service shutdown message.\n");

        status = WriteFile(
                    PipeHandle,
                    lpcmhBuffer,
                    sendBufferSize,
                    &bytesRead,
                    &overlapped);

        if (status || (returnStatus = GetLastError()) == ERROR_IO_PENDING) {
            returnStatus = NO_ERROR;
        }

        SC_LOG(SHUTDOWN, "ScSendControl returning with code %d\n", returnStatus);
    }
    else {
        //
        // The parameters are marshalled, now send the buffer and wait for
        // response.
        //

        SC_LOG(TRACE,"SendControl: Sending a TransactMessage.\n",0);

        returnStatus = NO_ERROR;
        status = TransactNamedPipe(PipeHandle,
                                   lpcmhBuffer,
                                   sendBufferSize,
                                   &serviceResponseBuffer,
                                   sizeof(PIPE_RESPONSE_MSG),
                                   &bytesRead,
                                   &overlapped);

        if (status == FALSE) {

            returnStatus = GetLastError();
            if (returnStatus == ERROR_PIPE_BUSY) {
                SC_LOG(ERROR, "Cleaning out pipe for %ws service\n", ServiceName);
                ScCleanOutPipe(PipeHandle);
                status = TRUE;
                returnStatus = NO_ERROR;
                status = TransactNamedPipe(PipeHandle,
                                           lpcmhBuffer,
                                           sendBufferSize,
                                           &serviceResponseBuffer,
                                           sizeof(PIPE_RESPONSE_MSG),
                                           &bytesRead,
                                           &overlapped);

                if (status == FALSE) {
                    returnStatus = GetLastError();
                }
            }
        }

        if (status == FALSE) {
            if (returnStatus != ERROR_IO_PENDING) {

                SC_LOG2(ERROR,
                        "SendControl:TransactNamedPipe to %ws service failed, rc=%lu\n",
                        ServiceName,
                        returnStatus);

                goto CleanUp;

            } else {

#if DBG

                DWORD   dwStartTick = GetTickCount();
                DWORD   dwTotalTime;

#endif  // DBG

                //
                // Transaction is pending
                //
                status = WaitForSingleObject(PipeHandle, g_dwScPipeTransactTimeout);

#if DBG

                dwTotalTime = GetTickCount() - dwStartTick;

                if (dwTotalTime > SC_DEFAULT_PIPE_TRANSACT_TIMEOUT) {

                    SC_LOG3(ERROR,
                            "ScSendControl: Pipe transaction to service %ws on "
                            "control %u took %u milliseconds\n",
                            ServiceName,
                            OpCode,
                            dwTotalTime);
                }

#endif  // DBG

                if (status == WAIT_TIMEOUT) {

                    SC_LOG2(ERROR,
                        "SendControl: Wait on transact to %ws service for %u millisecs timed out\n",
                        ServiceName, g_dwScPipeTransactTimeout);

                    //
                    // Cancel the named pipe operation.
                    // NOTE:  CancelIo cancels ALL pending I/O operations issued by
                    // this thread on the PipeHandle.  Since the service controller
                    // functions do nothing but wait after starting asynchronous
                    // named pipe operations, there should be no other operations.
                    //
                    status = CancelIo(PipeHandle);

                    if (status == FALSE) {

                        SC_LOG(ERROR, "SendControl: CancelIo failed, %lu\n", GetLastError());
                    }

                    ScLogEvent(
                        NEVENT_TRANSACT_TIMEOUT,
                        g_dwScPipeTransactTimeout,
                        ServiceName
                        );

                    returnStatus = ERROR_SERVICE_REQUEST_TIMEOUT;
                    goto CleanUp;

                } else if (status == 0) {

                    //
                    // Wait completed successfully
                    //
                    status = GetOverlappedResult(
                                 PipeHandle,
                                 &overlapped,
                                 &bytesRead,
                                 TRUE
                                 );

                    if (status == FALSE) {
                        returnStatus = GetLastError();
                        SC_LOG(ERROR,
                            "SendControl: GetOverlappedResult failed, rc=%lu\n",
                            returnStatus);
                        goto CleanUp;

                    }
                }
            }
        }

        //
        // Response received from the control dispatcher
        //
        if (bytesRead != sizeof(PIPE_RESPONSE_MSG)) {

            //
            // Successful transact, but we didn't get proper input.
            // (note: we should never receive more bytes unless there
            // is a bug in TransactNamedPipe).
            //

            SC_LOG(ERROR,
                "SendControl: Incorrect num bytes in response, num=%d",
                bytesRead);

            ScLogEvent(NEVENT_TRANSACT_INVALID);

            returnStatus = ERROR_GEN_FAILURE;
        }
        else {
            returnStatus = serviceResponseBuffer.dwDispatcherStatus;

            if (ARGUMENT_PRESENT(lpdwHandlerRetVal)) {
                *lpdwHandlerRetVal = serviceResponseBuffer.dwHandlerRetVal;
            }
        }
    }

CleanUp:
    SC_LOG(LOCKS,"SendControl: Leaving TransactPipe Critical Section.\n",0);

    LeaveCriticalSection(&ScTransactNPCriticalSection);

    LocalFree(lpcmhBuffer);

    if (returnStatus == NO_ERROR
         &&
        IS_CONTROL_LOGGABLE(OpCode)
         &&
        DisplayName != NULL && DisplayName[0] != L'\0')
    {
        ScLogControlEvent(NEVENT_SERVICE_CONTROL_SUCCESS,
                          DisplayName,
                          OpCode);
    }

    return(returnStatus);
}


VOID
ScInitTransactNamedPipe(
    VOID
    )

/*++

Routine Description:

    This function initializes the Critical Section that serializes
    calls to TransactNamedPipe and sets the pipe timeout value.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD   dwStatus;
    HKEY    hKeyControl;
    DWORD   dwValueType;
    DWORD   dwBufSize = sizeof(DWORD);


    InitializeCriticalSection(&ScTransactNPCriticalSection);

    //
    // Read the pipe timeout value from the registry if it exists.
    // If the read fails or the value's not there, use the default.
    //
    dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,     // hKey
                            REGKEY_PIPE_TIMEOUT,    // lpSubKey
                            0,
                            KEY_READ,               // Read access
                            &hKeyControl);          // Newly Opened Key Handle

    if (dwStatus == NO_ERROR) {

        dwStatus = RegQueryValueEx(hKeyControl,
                                   REGVAL_PIPE_TIMEOUT,
                                   NULL,
                                   &dwValueType,
                                   (LPBYTE)&g_dwScPipeTransactTimeout,
                                   &dwBufSize);

        if (dwStatus != NO_ERROR || dwValueType != REG_DWORD) {

            //
            // The value's either not there or bogus so just use the default
            //
            SC_LOG0(TRACE,
                    "ScInitTransactNamedPipe: Can't find ServicesPipeTimeout "
                    "value in registry\n");
        }

        RegCloseKey(hKeyControl);
    }
    else {

        //
        // Not an error for this function, although a missing control
        // key is probably relatively bad, so notify everybody
        //
        SC_LOG0(ERROR,
                "ScInitTransactNamedPipe: Can't find Control "
                "key in registry!\n");
    }

    SC_LOG1(TRACE,
            "ScInitTransactNamedPipe: Using pipe timeout value of %u\n",
            g_dwScPipeTransactTimeout);
}



VOID
ScShutdownAllServices(
    VOID
    )

/*++

Routine Description:

    (called at system shutdown).
    This function sends shutdown requests to all services that have
    registered an interest in shutdown notification.

    When we leave this routine, to the best of our knowledge, all the
    services that should stop have stopped - or are in some hung state.

    Note:  It is expected that the RPC entry points are no longer serviced,
    so we should not be receiving any requests that will add or delete
    service records.  Therefore, locks are not used when reading service
    records during the shutdown loop.


Arguments:

    none

Return Value:

    none

Note:


--*/

{
    DWORD               status;
    LPSERVICE_RECORD    *affectedServices;
    DWORD               serviceIndex        = 0;
    DWORD               arrayEnd            = 0;
    BOOL                ServicesStopping;
    DWORD               maxWait             = 0;
    DWORD               startTime;
    DWORD               arraySize;

#ifdef SC_SHUTDOWN_METRIC

    //
    // Local variables for shutdown performance metrics
    //
    DWORD               dwShutdownTimeout = 0;
    HKEY                hKeyControl;
    DWORD               dwValueType;
    DWORD               dwBufSize = sizeof(DWORD);

#endif  // SC_SHUTDOWN_METRIC


    //
    // Allocate a temporary array of services which we're interested in.
    // (This is purely an optimization to avoid repeated traversals of the
    // entire database of installed services.)
    //
    CServiceListSharedLock LLock;
    arraySize = ScGetTotalNumberOfRecords();

    affectedServices = (LPSERVICE_RECORD *)LocalAlloc(
                            LMEM_FIXED,
                            arraySize * sizeof(LPSERVICE_RECORD));

    if (affectedServices == NULL) {
        SC_LOG0(ERROR,"ScShutdownAllServices: LocalAlloc Failed\n");
        return;
    }

#ifdef SC_SHUTDOWN_METRIC

    //
    // Read the shutdown timeout value from the registry if it exists.
    // If the read fails or the value's not there, use the default.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,      // hKey
                     REGKEY_SHUTDOWN_TIMEOUT, // lpSubKey
                     0,
                     KEY_READ,                // Read access
                     &hKeyControl)            // Handle to newly-opened key

            == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKeyControl,
                        REGVAL_SHUTDOWN_TIMEOUT,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwShutdownTimeout,
                        &dwBufSize);

        RegCloseKey(hKeyControl);
    }

#endif  // SC_SHUTDOWN_METRIC

    //-------------------------------------------------------------------
    //
    // Loop through service list sending stop requests to all that
    // should receive such requests.
    //
    //-------------------------------------------------------------------
    SC_LOG0(SHUTDOWN,"***** BEGIN SENDING STOPS TO SERVICES *****\n");

    FOR_SERVICES_THAT(Service,
    (Service->ServiceStatus.dwServiceType & SERVICE_WIN32) &&
    (Service->ServiceStatus.dwCurrentState != SERVICE_STOPPED) &&
    (Service->ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) &&
    (Service->ServiceStatus.dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) &&
    (Service->ImageRecord != NULL)
    )
    {
        //
        // If the service is not in the stopped or stop pending
        // state, it should be ok to send the control.
        //
        SC_LOG1(SHUTDOWN,"Shutdown: Sending Stop to Service : %ws\n",
                Service->ServiceName);

        status = ScSendControl(Service->ServiceName,
                               Service->DisplayName,
                               Service->ImageRecord->PipeHandle,
                               SERVICE_CONTROL_SHUTDOWN,
                               NULL,                           // CmdArgs
                               0L,                             // NumArgs
                               NULL);                          // Ignore handler return value

        if (status != NO_ERROR) {
            SC_LOG1(ERROR,"ScShutdownAllServices: ScSendControl "
            "Failed for %ws\n",Service->ServiceName);
        }
        else {

            //
            // Save the services that have been sent stop requests
            // in the temporary array.
            //
            SC_ASSERT(serviceIndex < arraySize);

            if (serviceIndex < arraySize) {
                    affectedServices[serviceIndex++] = Service;
            }
        }
    }

    SC_LOG0(SHUTDOWN,"***** DONE SENDING STOPS TO SERVICES *****\n");

    //-------------------------------------------------------------------
    //
    // Now check to see if these services stopped.
    //
    //-------------------------------------------------------------------

    startTime     = GetTickCount();
    arrayEnd      = serviceIndex;
    ServicesStopping = (serviceIndex != 0);

    SC_LOG(SHUTDOWN,"Waiting for services to stop. Start time is %lu\n",
    startTime);

    while (ServicesStopping) {

        //
        // Wait a bit for the services to become stopped.
        //
        Sleep(500);

        //
        // We are going to check all the services in our shutdown
        // list and see if we still have services to wait on.
        //
        ServicesStopping = FALSE;
        maxWait = 0;

        for (serviceIndex = 0; serviceIndex < arrayEnd ; serviceIndex++) {

            Service = affectedServices[serviceIndex];

            //
            // If the service is in the stop pending state, then wait
            // a bit and check back.  Maximum wait time is the maximum
            // wait hint period of all the services.  If a service's
            // wait hint is 0, use 20 seconds as its wait hint.
            //
            // Note that this is different from how dwWaitHint is
            // interpreted for all other operations.  We ignore
            // dwCheckPoint here.
            //
            switch (Service->ServiceStatus.dwCurrentState) {

            case SERVICE_STOP_PENDING:

                SC_LOG2(SHUTDOWN,
                        "%ws Service is still pending, wait hint = %lu\n",
                        Service->ServiceName,
                        Service->ServiceStatus.dwWaitHint);

                if (Service->ServiceStatus.dwWaitHint == 0) {
                    if (maxWait < 20000) {
                        maxWait = 20000;
                    }
                }
                else {
                    if (maxWait < Service->ServiceStatus.dwWaitHint) {
                        maxWait = Service->ServiceStatus.dwWaitHint;
                    }
                }
                ServicesStopping = TRUE;
                break;

            case SERVICE_STOPPED:
                break;

            case SERVICE_RUNNING:

                if (maxWait < 30000) {
                    maxWait = 30000;
                }

                SC_LOG2(SHUTDOWN, "%ws Service is still running, maxWait is %lu\n",
                        Service->ServiceName, maxWait);

                ServicesStopping = TRUE;
                break;

            default:
                //
                // This is an error.  But we can't do anything about
                // it, so it will be ignored.
                //
                SC_LOG2(SHUTDOWN,"ERROR: %ws Service is in invalid state %#lx\n",
                        Service->ServiceName,
                        Service->ServiceStatus.dwCurrentState);
                break;

            } // end switch

        } // end for


        //
        // We have examined all the services.  If there are still services
        // with the STOP_PENDING, then see if we have timed out the
        // maxWait period yet.
        //
        if (ServicesStopping) {

#ifdef SC_SHUTDOWN_METRIC

            //
            // Performance hook for service shutdown -- if a shutdown
            // timeout was specified in the registry and it's been
            // longer than the timeout, print out a list of all the
            // unstopped services and break into the debugger.  Do this
            // on both free and checked builds.  Note that this must be
            // #if'ed out prior to shipping NT 5.0.
            //
            if (dwShutdownTimeout != 0
                &&
                (GetTickCount() - startTime) > dwShutdownTimeout) {

                //
                // Uh oh -- we've exceeded the max shutdown time
                //
                DbgPrint("\n[SC-SHUTDOWN] The following services failed to "
                             "shut down in %lu seconds:\n",
                         dwShutdownTimeout / 1000);

                for (serviceIndex = 0; serviceIndex < arrayEnd; serviceIndex++) {

                    Service = affectedServices[serviceIndex];

                    if (Service->ServiceStatus.dwCurrentState != SERVICE_STOPPED) {

                        DbgPrint("%ws service is still running (state = %lu)\n",
                                 Service->ServiceName,
                                 Service->ServiceStatus.dwCurrentState);
                    }
                }

                DebugBreak();
            }

#endif  // SC_SHUTDOWN_METRIC

            if ( (GetTickCount() - startTime) > maxWait ) {

                //
                // The maximum wait period has been exceeded. At this
                // point we should end this shutdown effort.  There is
                // no point in forcing shutdown.  So we just exit.
                //
                SC_LOG(ERROR,
                       "The Services didn't stop within the timeout "
                         "period of %lu.\n   --- There is still at least one "
                         "service running\n",
                       maxWait);

#if DBG
                SC_LOG0(ERROR, "The following Services failed to shut down:\n");

                for (serviceIndex = 0; serviceIndex < arrayEnd ; serviceIndex++) {

                    Service = affectedServices[serviceIndex];

                    if (Service->ServiceStatus.dwCurrentState != SERVICE_STOPPED) {

                        SC_LOG2(ERROR, "%ws Service is still running (Service state = %lu)\n",
                                Service->ServiceName, Service->ServiceStatus.dwCurrentState);
                    }
                }
#endif // DBG

                ServicesStopping = FALSE;
            }
        }
    }
    SC_LOG0(SHUTDOWN,"Done Waiting for services to stop\n");
}



VOID
ScCleanOutPipe(
    HANDLE  PipeHandle
    )

/*++

Routine Description:

    This function reads and throws away all data that is currently in the
    pipe.  This function is called if the pipe is busy when it shouldn't be.
    The PIPE_BUSY occurs when (1) the transact never returns, or (2) the
    last transact timed-out, and the return message was eventually placed
    in the pipe after the timeout.

    This function is called to fix the (2) case by cleaning out the pipe.

Arguments:

    PipeHandle - A Handle to the pipe to be cleaned out.

Return Value:

    none.

--*/
{
#define EXPUNGE_BUF_SIZE    100

    DWORD      status;
    DWORD      returnStatus;
    DWORD      numBytesRead=0;
    BYTE       msg[EXPUNGE_BUF_SIZE];
    OVERLAPPED overlapped={0,0,0,0,0};

    do {
        overlapped.hEvent = (HANDLE) NULL;   // Wait on pipe handle

        status = ReadFile (
                PipeHandle,
                msg,
                EXPUNGE_BUF_SIZE,
                &numBytesRead,
                &overlapped);

        if (status == FALSE) {
            returnStatus = GetLastError();

            if (returnStatus == ERROR_IO_PENDING) {

                status = WaitForSingleObject(
                        PipeHandle,
                        SC_PIPE_CLEANOUT_TIMEOUT);

                if (status == WAIT_TIMEOUT) {
                    SC_LOG0(ERROR, "ControlPipe was busy but we were unable to "
                    "clean it out in the timeout period\n");

                    //
                    // Cancel the named pipe operation.
                    //
                    status = CancelIo(PipeHandle);

                    if (status == FALSE) {
                        SC_LOG(ERROR,
                               "ScCleanOutPipe: CancelIo failed, %lu\n",
                               GetLastError());
                    }
                }
            }
            else {
            SC_LOG1(ERROR, "ControlPipe was busy.  The attempt to clean"
                "it out failed with %d\n", returnStatus);
            }
        }
    }
    while (status == ERROR_MORE_DATA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\driver.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DRIVER.H

Abstract:

    Prototypes for functions that control and get status from drivers.

Author:

    Dan Lafferty (danl)     28-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    28-Apr-1991     danl
        created

--*/
DWORD
ScLoadDeviceDriver(
    LPSERVICE_RECORD    ServiceRecord
    );

DWORD
ScControlDriver(
    DWORD               ControlCode,
    LPSERVICE_RECORD    ServiceRecord,
    LPSERVICE_STATUS    lpServiceStatus
    );

DWORD
ScGetDriverStatus(
    IN OUT LPSERVICE_RECORD    ServiceRecord,
    OUT    LPSERVICE_STATUS    lpServiceStatus OPTIONAL
    );

DWORD
ScUnloadDriver(
    LPSERVICE_RECORD    ServiceRecord
    );

VOID
ScNotifyNdis(
    LPSERVICE_RECORD    ServiceRecord
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\dataman.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dataman.cxx

Abstract:

    Contains code for the Service Control Database manager.  This includes
    all the linked list routines.  This file contains the following
    functions:
        ScGetOrderGroupList
        ScGetStandaloneGroupList
        ScGetServiceDatabase
        ScGetUnresolvedDependList

        ScActivateServiceRecord
        ScCreateImageRecord
        ScCreateServiceRecord
        ScFreeServiceRecord
        ScAddConfigInfoServiceRecord
        ScDecrementUseCountAndDelete
        ScProcessDeferredList
        ScFindEnumStart
        ScGetNamedImageRecord
        ScGetNamedServiceRecord
        ScGetDisplayNamedServiceRecord
        ScGetTotalNumberOfRecords
        ScInitDatabase
        ScProcessCleanup
        ScDeleteMarkedServices

        ScRemoveService
        ScDeleteImageRecord         (internal only)
        ScDeactivateServiceRecord
        ScTerminateServiceProcess   (internal only)
        ScUpdateServiceRecordConfig

        ScNotifyServiceObject

Author:

    Dan Lafferty (danl)     04-Feb-1992

Environment:

    User Mode -Win32

Revision History:

    22-Oct-1998     jschwart
        Convert SCM to use NT thread pool APIs
    22-Oct-1997     JSchwart  (after AnirudhS in _CAIRO_ 12-Apr-1995)
        Enabled changes made in ifdef _CAIRO_ on 12-Apr-1995.
        Removed ScNotifyServiceObject.
    08-Jan-1997     AnirudhS
        Replaced ScDatabaseLockFcn and ScGroupListLock with the new
        locking scheme in lock.cxx.  Rewrote ScDeferredList processing.
    04-Dec-1996     AnirudhS
        Added calls to service crash recovery code.
    12-Jul-1996     AnirudhS
        ScDecrementUseCountAndDelete: Don't actually process the deferred
        list in this routine, because a number of calling routines assume
        that the service record does NOT go away when they call this routine.
        Instead, process it when a database lock is released.
    25-Jun-1996     AnirudhS
        ScProcessCleanup: Fix the use of a freed service record.  Don't
        try to upgrade shared lock to exclusive, as it can deadlock.
    25-Oct-1995     AnirudhS
        ScAddConfigInfoServiceRecord: Fix heap corruption bug caused by
        security descriptor being freed twice, the second time by
        ScProcessDeferredList.
    20-Sep-1995     AnirudhS
        ScDeleteMarkedServices: Fix heap corruption bug caused by service
        record being deleted using LocalFree instead of HeapFree.
    26-Jun-1995     AnirudhS
        Added ScNotifyServiceObject.
    12-Apr-1995     AnirudhS
        Added AccountName field to image record.
    21-Jan-1994     Danl
        ScAddConfigInfoServiceRecord: If no DisplayName, or the DisplayName
        is an empty string, or the DisplayName is the same as the
        ServiceName, then just point to the ServiceName for the DisplayName.
    22-Oct-1993     Danl
        Moved Group and Dependency function into groupman.c.
    16-Sept-1993    Danl
        ScProcessCleanup: Get the shared lock prior to walking through the
        database looking for the one to cleanup.  Then get the exclusive
        lock to modify it.  Remove assert.
    12-Feb-1993     Danl
        ScActivateServiceRecord now increments the UseCount.  This is to
        balance the fact that we decrement the UseCount when we
        deactivate the service record.
    28-Aug-1992     Danl
        Re-Added ScGetTotalNumberOfRecords  function.  This is needed
        by the ScShutdownAllServices function.
    14-Apr-1992     JohnRo
        Use SC_ASSERT() macro.
        Made changes suggested by PC-LINT.
    10-Apr-1992     JohnRo
        Use ScImagePathsMatch() to allow mixed-case image names.
        Make sure DeleteFlag gets a value when service record is created.
        Added some assertion checks.
    04-Feb-1992     Danl
        created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <userenv.h>    // UnloadUserProfile
#include <stdlib.h>     // wide character c runtimes.
#include <ntrpcp.h>     // MIDL_user_allocate
#include <control.h>    // SendControl
#include "scconfig.h"   // ScGenerateServiceDB,ScInitSecurityProcess
#include "scsec.h"      // ScCreateScServiceObject
#include "account.h"    // ScRemoveAccount
#include <sclib.h>      // ScImagePathsMatch().
#include "bootcfg.h"    // ScDeleteRegTree().
#include <strarray.h>   // ScWStrArraySize

extern "C" {

#include <cfgmgr32.h>
#include "cfgmgrp.h"    // RegisterServiceNotification

}

//
// Macros
//

// for every service record in the database...
// (a slightly more efficient definition of this macro for use within
// this file)
//
#undef  FOR_ALL_SERVICES
#define FOR_ALL_SERVICES(SR)                                    \
             SC_ASSERT(ScServiceListLock.Have());               \
             for (LPSERVICE_RECORD SR = ServiceDatabase.Next;   \
                  SR != NULL;                                   \
                  SR = SR->Next)


//
// Defines and Typedefs
//
class DEFER_LIST
{
public:
    VOID                Add    (LPSERVICE_RECORD    ServiceRecord);
    VOID                Process();

private:
    DWORD               TotalElements;      // size of ServiceRecPtr array
    DWORD               NumElements;        // numElements in array
    LPSERVICE_RECORD *  ServiceRecordPtr;   // pointer to array
};




//
//  Globals
//
    //
    // These are the linked list heads for each of the databases
    // that are maintained.
    //

    IMAGE_RECORD      ImageDatabase;
    SERVICE_RECORD    ServiceDatabase;

    DWORD             ScTotalNumServiceRecs;// number of services

    //
    // Service Record index number.  This allows enumeration to be broken
    // up into several calls.
    //
    DWORD             ResumeNumber;

    //
    // The ScGlobalDeferredList points to a structure that contains an
    // array of pointers to service records. The first two elements in
    // the structure contain the size and number of element information
    // about the array.
    // Access to the list is guarded by ScServiceRecordLock.
    //
    DEFER_LIST        ScDeferredList;

    //
    // ServiceRecord Heap Information
    //
    // ServiceRecord Heap -  is where all the service records are allocated
    //  from.
    // OrderedHash Heap - Service Names can be found via a (very simple) hash
    //  table.  There is an array of pointers (one for each letter of
    //  alphabet), where each pointer points to the top of an array of
    //  pointers to service records.   All the service records in that array
    //  will have names beginning with the same letter.  The service record
    //  pointers will be ordered as to the frequency of access.
    //
    HANDLE      ServiceRecordHeap = NULL;
    HANDLE      OrderedHashHeap = NULL;


//
// Local Function Prototypes
//

VOID
ScDeferredListWorkItem(
    IN PVOID    pContext
    );


//****************************************************************************/
// Miscellaneous Short Functions
//****************************************************************************/

LPSERVICE_RECORD
ScGetServiceDatabase(
    VOID
    )
{
    return ServiceDatabase.Next;
}


/****************************************************************************/
VOID
ScActivateServiceRecord (
    IN LPSERVICE_RECORD     ServiceRecord,
    IN LPIMAGE_RECORD       ImageRecord
    )

/*++

Routine Description:

    This function can be called with or without a pointer to an ImageRecord.

    If it is called without the pointer to the ImageRecord, just the
    ServiceRecord is initialized to the START_PENDING state, and the UseCount
    is incremented.

    If it is called with the pointer to the ImageRecord, then the ImageRecord
    pointer is added to the ServiceRecord, and the ImageUseCount
    is incremented.

Arguments:

    ServiceRecord - This is a pointer to the ServiceRecord that is to be
        activated.

    ImageRecord - This is a pointer to the ImageRecord that the service
        record will point to.

Notes:

    This routine assumes that the Exclusive database lock has already
    been obtained.

Return Value:

    returns 0.  (It used to return a service count - but it wasn't used
    anywhere).

--*/
{
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ImageRecord == NULL)
    {
        ServiceRecord->ImageRecord = NULL;
        ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
        ServiceRecord->ServiceStatus.dwControlsAccepted = 0;
        ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
        ServiceRecord->ServiceStatus.dwServiceSpecificExitCode = 0;
        ServiceRecord->ServiceStatus.dwCheckPoint = 0;
        ServiceRecord->ServiceStatus.dwWaitHint = 2000;
        ServiceRecord->UseCount++;
        SC_LOG2(USECOUNT, "ScActivateServiceRecord: " FORMAT_LPWSTR
            " increment USECOUNT=%lu\n",
            ServiceRecord->ServiceName,
            ServiceRecord->UseCount);
    }
    else
    {
        //
        // Increment the service count in the image record.
        //
        ServiceRecord->ImageRecord = ImageRecord;
        ServiceRecord->ImageRecord->ServiceCount++;
    }

    return;
}

/****************************************************************************/
DWORD
ScCreateImageRecord (
    OUT     LPIMAGE_RECORD      *ImageRecordPtr,
    IN      LPWSTR              ImageName,
    IN      LPWSTR              AccountName,
    IN      DWORD               Pid,
    IN      HANDLE              PipeHandle,
    IN      HANDLE              ProcessHandle,
    IN      HANDLE              TokenHandle,
    IN      HANDLE              ProfileHandle,
    IN      DWORD               ImageFlags
    )

/*++

Routine Description:

    This function allocates storage for a new Image Record, and links
    it into the Image Record Database.  It also initializes all fields
    in the record with the passed in information.

Arguments:

    ImageRecordPtr - This is a pointer to where the image record pointer
        is to be placed.

    ImageName - This is a pointer to a NUL terminated string containing
        the name of the image file.

    AccountName - This is either NULL (to represent the LocalSystem account)
        or a pointer to a NUL terminated string containing the name of the
        account under which the image was started.

    Pid - This is the Process ID for that the image is running in.

    PipeHandle - This is a handle to the pipe that is used to communicat
        with the image process.

    ProcessHandle - This is a handle to the image process object.

    TokenHandle - This is a handle to the process's logon token.  It
        is NULL if the process runs in the LocalSystem context.

    ProfileHandle -

    ImageFlags -

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate buffer for the image
        record.

    ERROR_LOCKED - Exclusive access to the database could
        not be obtained.

Note:

    This routine temporarily acquires the exclusive database lock.

--*/
{
    LPIMAGE_RECORD      imageRecord;    // The new image record pointer
    LPIMAGE_RECORD      record ;        // Temporary pointer
    LPWSTR              stringArea;     // String area in allocated buffer.

    TOKEN_STATISTICS    TokenStats;
    DWORD               dwError;

    //
    // Allocate space for the new record (including the string)
    //

    imageRecord = (LPIMAGE_RECORD)LocalAlloc(LMEM_ZEROINIT,
                    sizeof(IMAGE_RECORD)
                    + WCSSIZE(ImageName)
                    + (AccountName ? WCSSIZE(AccountName) : 0)
                   );

    if (imageRecord == NULL)
    {
        SC_LOG(TRACE,"CreateImageRecord: Local Alloc failure rc=%ld\n",
            GetLastError());
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Copy the strings into the new buffer space.
    //

    stringArea = (LPWSTR)(imageRecord + 1);
    (VOID) wcscpy (stringArea, ImageName);
    imageRecord->ImageName = stringArea;

    if (AccountName)
    {
        stringArea += (wcslen(stringArea) + 1);
        (VOID) wcscpy (stringArea, AccountName);
        imageRecord->AccountName = stringArea;
    }
    else
    {
        imageRecord->AccountName = NULL;
    }

    //
    // Update the rest of the fields in the Image Record
    //

    imageRecord->Next = NULL;
    imageRecord->Pid = Pid;
    imageRecord->PipeHandle = PipeHandle;
    imageRecord->ProcessHandle = ProcessHandle;
    imageRecord->ServiceCount = 0;
    imageRecord->TokenHandle = TokenHandle;
    imageRecord->ProfileHandle = ProfileHandle;
    imageRecord->ObjectWaitHandle = NULL;
    imageRecord->ImageFlags = ImageFlags;

    if (TokenHandle == NULL)
    {
        LUID SystemLuid = SYSTEM_LUID;

        RtlCopyLuid(&imageRecord->AccountLuid, &SystemLuid);
    }
    else
    {
        //
        // Get the unique session ID for this process
        //
        if (!GetTokenInformation(TokenHandle,
                                 TokenStatistics,        // Information wanted
                                 &TokenStats,
                                 sizeof(TokenStats),     // Buffer size
                                 &dwError))              // Size required
        {
            dwError = GetLastError();

            SC_LOG1(ERROR,
                    "ScCreateImageRecord: GetTokenInformation FAILED %d\n",
                    dwError);

            LocalFree(imageRecord);
            return dwError;
        }

        imageRecord->AccountLuid.LowPart  = TokenStats.AuthenticationId.LowPart;
        imageRecord->AccountLuid.HighPart = TokenStats.AuthenticationId.HighPart;
    }

    //
    //  Add record to the Image Database linked list.
    //

    CServiceRecordExclusiveLock Lock;

    record = &ImageDatabase;
    ADD_TO_LIST(record, imageRecord);

    *ImageRecordPtr = imageRecord;

    return(NO_ERROR);
}

/****************************************************************************/
DWORD
ScCreateServiceRecord(
    IN  LPWSTR              ServiceName,
    OUT LPSERVICE_RECORD   *ServiceRecord
    )

/*++

Routine Description:

    This function creates a new "inactive" service record and adds it to
    the service record list.  A resume number is assigned so that it
    can be used as a key in enumeration searches.

    To initialize the service record with the fields from the registry,
    call ScAddConfigInfoServiceRecord.


Arguments:

    ServiceName - This is a pointer to the NUL terminated service name
        string.

    ServiceRecord - Receives a pointer to the service record created and
        inserted into the service record list.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a new
        service record failed.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.

--*/

{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    record;         // Temporary pointer
    LPWSTR              nameArea;       // NameString area in allocated buffer.
    DWORD               nameSize;       // num bytes in service name.

    SC_ASSERT(ScServiceListLock.HaveExclusive());

    // (The service record lock is not needed here since we don't touch
    // the service record after adding it to the service list)

    //
    // Allocate the new service record.
    //
    nameSize = (DWORD) WCSSIZE(ServiceName);

    (*ServiceRecord) = (LPSERVICE_RECORD)HeapAlloc(
                           ServiceRecordHeap,
                           HEAP_ZERO_MEMORY,
                           nameSize + sizeof(SERVICE_RECORD)
                           );

    if ((*ServiceRecord) == NULL)
    {
        SC_LOG0(ERROR,"CreateServiceRecord: HeapAlloc failure\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the ServiceName into the new buffer space.
    //

    nameArea = (LPWSTR)((LPBYTE)(*ServiceRecord) + sizeof(SERVICE_RECORD));
    (VOID) wcscpy (nameArea, ServiceName);

    //
    // At this point we have the space for a service record, and it
    // contains the name of the service.
    //

    //
    //  Fill in all the fields that need to be non-zero.
    //  Note:  The display name is initialized to point to the service name.
    //

    (*ServiceRecord)->ServiceName    = nameArea;
    (*ServiceRecord)->DisplayName    = nameArea;
    (*ServiceRecord)->ResumeNum      = ResumeNumber++;
    (*ServiceRecord)->Signature      = SERVICE_SIGNATURE;
    (*ServiceRecord)->ImageRecord    = NULL;
    (*ServiceRecord)->StartDepend    = NULL;
    (*ServiceRecord)->StopDepend     = NULL;
    (*ServiceRecord)->ErrorControl   = SERVICE_ERROR_NORMAL;
    (*ServiceRecord)->StatusFlag     = 0;
    (*ServiceRecord)->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    (*ServiceRecord)->ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_NEVER_STARTED;
    (*ServiceRecord)->StartState     = SC_NEVER_STARTED;


    //
    // Add the service to the service record linked list.
    //

    record = &ServiceDatabase;

    ADD_TO_LIST(record, (*ServiceRecord));

    ScTotalNumServiceRecs++;

    return(status);
}


/****************************************************************************/
VOID
ScFreeServiceRecord(
    IN  LPSERVICE_RECORD   ServiceRecord
    )

/*++

Routine Description:

    This function frees up a service record that has already been removed
    from the service record list.

Arguments:

    ServiceRecord - Receives a pointer to the service record to free.

--*/
{
    if (!HeapFree(ServiceRecordHeap, 0, ServiceRecord))
    {
        SC_LOG2(ERROR,
                "ScFreeServiceRecord: HeapFree for %ws service failed %d\n",
                ServiceRecord->ServiceName,
                GetLastError());
    }

    return;
}


/****************************************************************************/
DWORD
ScAddConfigInfoServiceRecord(
    IN  LPSERVICE_RECORD     ServiceRecord,
    IN  DWORD                ServiceType,
    IN  DWORD                StartType,
    IN  DWORD                ErrorControl,
    IN  LPWSTR               Group OPTIONAL,
    IN  DWORD                Tag,
    IN  LPWSTR               Dependencies OPTIONAL,
    IN  LPWSTR               DisplayName OPTIONAL,
    IN  PSECURITY_DESCRIPTOR Sd OPTIONAL
    )

/*++

Routine Description:

    This function adds the configuration information to the service
    record.

    NOTE: This function is called when the service controller is
    reading service entries from the registry at startup, as well as
    from RCreateServiceW.

Arguments:

    ServiceRecord - Pointer to the service record to modify.

    DisplayName - A string that is the displayable name for the service.

    ServiceType - Indicates whether the ServiceRecord is for a win32 service
        or a device driver.

    StartType - Specifies when to start the service: automatically at boot or
        on demand.

    ErrorControl - Specifies the severity of the error if the service fails
        to start.

    Tag - DWORD identifier for the service.  0 means no tag.

    Group - Name of the load order group this service is a member of.

    Dependencies - Names of services separated by colon which this service
        require to be started before it can run.

    Sd - Security descriptor for the service object.  If NULL, i.e. could
        not read from registry, create a default one.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a new
        service record or display name failed.

Note:

    This routine assumes that the caller has exclusively acquired both the
    database lock and the GroupListLock.

    If this call is successful, do the following before freeing the memory
    of the service record in ScDecrementUseCountAndDelete:

        ScDeleteStartDependencies(ServiceRecord);
        ScDeleteGroupMembership(ServiceRecord);
        ScDeleteRegistryGroupPointer(ServiceRecord);


--*/
{
    DWORD status;

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    //  Fill in the service record.
    //
    ServiceRecord->StartType = StartType;
    ServiceRecord->ServiceStatus.dwServiceType = ServiceType;
    ServiceRecord->ErrorControl = ErrorControl;
    ServiceRecord->Tag = Tag;

    //
    // The display name in the service record already points to the
    // ServiceName string.  If the DisplayName is present and different
    // from the ServiceName, then allocate storage for it and copy the
    // string there.
    //
    SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: Allocate for display name\n");

    if ((DisplayName != NULL) && (*DisplayName != L'\0') &&
        (_wcsicmp(DisplayName,ServiceRecord->ServiceName) != 0))
    {
        ServiceRecord->DisplayName = (LPWSTR)LocalAlloc(
                                            LMEM_FIXED,
                                            WCSSIZE(DisplayName));

        if (ServiceRecord->DisplayName == NULL)
        {
            SC_LOG(TRACE,"ScAddConfigInfoServiceRecord: LocalAlloc failure rc=%ld\n",
                GetLastError());

            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(ServiceRecord->DisplayName,DisplayName);
    }

    //
    // Create a default security descriptor for the service.
    //
    if (! ARGUMENT_PRESENT(Sd))
    {
        SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: create service obj\n");

        if ((status = ScCreateScServiceObject(
                          &ServiceRecord->ServiceSd
                          )) != NO_ERROR)
        {
            goto ErrorExit;
        }
    }
    else
    {
        SC_LOG1(SECURITY,
                "ScAddConfigInfoServiceRecord: Using " FORMAT_LPWSTR
                " descriptor from registry\n", ServiceRecord->ServiceName);
        ServiceRecord->ServiceSd = Sd;
    }

    SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: Get Group List Lock\n");

    //
    // Save the group membership information.
    //
    SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: create group memebership\n");
    if ((status = ScCreateGroupMembership(
                      ServiceRecord,
                      Group
                      )) != NO_ERROR)
    {
        goto ErrorExit;
    }

    SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: create Reg Grp Ptr\n");
    if ((status = ScCreateRegistryGroupPointer(
                      ServiceRecord,
                      Group
                      )) != NO_ERROR)
    {
        ScDeleteGroupMembership(ServiceRecord);
        goto ErrorExit;
    }


    //
    // Don't create dependencies list yet.  Just save the string in
    // the service record.
    //
    if ((Dependencies != NULL) && (*Dependencies != 0))
    {
        //
        // If StartType is BOOT_START or SYSTEM_START, it is invalid
        // for the service to be dependent on another service.  It can
        // only be dependent on a group.
        //
        // N.B. This check has been removed. There doesn't seem to be
        //      any point in enforcing it, and remote boot needs to
        //      allow NetBT to be dependent Tcpip.
        //

        DWORD DependenciesSize = 0;
        DWORD EntryByteCount;
        LPWSTR Entry = Dependencies;


        while (*Entry != 0)
        {
#if 0
            if (StartType == SERVICE_BOOT_START ||
                StartType == SERVICE_SYSTEM_START)
            {
                if (*Entry != SC_GROUP_IDENTIFIERW)
                {
                    SC_LOG1(ERROR, "ScAddConfigInfoServiceRecord: Boot or System "
                            "start driver " FORMAT_LPWSTR " must depend on a group\n",
                            ServiceRecord->DisplayName);

                    ScEvent(
                        EVENT_INVALID_DRIVER_DEPENDENCY,
                        ServiceRecord->DisplayName
                        );

                    status = ERROR_INVALID_PARAMETER;

                    ScDeleteGroupMembership(ServiceRecord);
                    ScDeleteRegistryGroupPointer(ServiceRecord);

                    goto ErrorExit;
                }
            }
#endif

            EntryByteCount = (DWORD) WCSSIZE(Entry);  // This entry and its null.
            DependenciesSize += EntryByteCount;

            Entry = (LPWSTR) ((DWORD_PTR) Entry + EntryByteCount);
        }

        DependenciesSize += sizeof(WCHAR);

        ServiceRecord->Dependencies = (LPWSTR)LocalAlloc(
                                          0,
                                          DependenciesSize
                                          );

        if (ServiceRecord->Dependencies == NULL)
        {
            ScDeleteGroupMembership(ServiceRecord);
            ScDeleteRegistryGroupPointer(ServiceRecord);
            goto ErrorExit;
        }

        RtlCopyMemory(ServiceRecord->Dependencies, Dependencies, DependenciesSize);
    }

    return NO_ERROR;

ErrorExit:
    if (DisplayName != NULL)
    {
        LocalFree(ServiceRecord->DisplayName);
    }

    RtlDeleteSecurityObject(&ServiceRecord->ServiceSd);

    //
    // Prevent ScProcessDeferredList from trying to free the same heap block
    // again later
    //
    ServiceRecord->ServiceSd = NULL;

    return status;
}

/****************************************************************************/
VOID
ScDecrementUseCountAndDelete(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function decrements the UseCount for a service, and it the
    UseCount reaches zero and the service is marked for deletion,
    it puts a pointer to the service record into an array of
    such pointers that is stored in a deferred list structure.  The
    pointer to this structure is stored at the global location called
    ScDeferredList.  Access to this list is synchronized by use of the
    ScServiceRecordLock.

    A large number of routines in the service controller walk the
    service database and sometimes call this function, either directly
    or indirectly.  It would complicate the programming of all those
    routines if they all had to assume that service records could get
    deleted under them.  Therefore, this function never actually deletes
    any service record.  Instead, it starts a separate thread that first
    acquires all three locks exclusively and then processes the deferred
    list.

    Note:  By jumping through hoops, it is possible to avoid creating
    that thread in certain cases, but since service deletion is a rather
    rare operation, it was not considered worthwhile to create very-
    difficult-to-maintain code to optimize it.


    NOTE:  The caller is expected to hold the Exclusive DatabaseLock
    prior to calling this function.

    The following functions call this routine:
        ScDeactivateServiceRecord
        RCloseServiceHandle
        ScGetDriverStatus
        ScStartServiceAndDependencies

Arguments:

    ServiceRecord - This is a pointer to the service record that is having
        its use count deleted.

Return Value:

    none.

--*/
{
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ServiceRecord->UseCount == 0)
    {
        //
        // The use count should not ever be zero when we enter this routine.
        //
        SC_LOG1(ERROR,"ScDecrementUseCountAndDelete: Attempt to decrement UseCount beyond zero.\n"
        "\t"FORMAT_LPWSTR" \n", ServiceRecord->ServiceName);
        SC_ASSERT(FALSE);
    }
    else
    {
        if ((ServiceRecord->UseCount == 1) &&
            (DELETE_FLAG_IS_SET(ServiceRecord)))
        {
            //
            // If the use count is one, we have a special case.  We want
            // to postpone decrementing this last time until we have the
            // group list lock.
            //

            //
            // Put the service record pointer in the list, and start a
            // separate thread to process the list.
            //
            ScDeferredList.Add(ServiceRecord);
        }
        else
        {
            //
            // If the use count is greater than one, or the service is
            // NOT marked for delete, then we want to decrement the use
            // count and that is all.
            //
            ServiceRecord->UseCount--;
            SC_LOG2(USECOUNT, "ScDecrementUseCountAndDelete: " FORMAT_LPWSTR
                " decrement USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);
        }
    }
    return;
}

/****************************************************************************/
VOID
DEFER_LIST::Add(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function adds a service record to the list of service records to
    be deleted.  It then starts a thread that will acquire all the locks
    and perform the actual deletion, if such a thread hasn't already been
    started.

    ScServiceRecordLock is used to ensure that only one thread accesses
    the deferred list at a time.

    The following functions call this routine:
        ScDecrementUseCountAndDelete

--*/
{
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (NumElements + 1 > TotalElements)
    {
        //
        // Reallocate the array with a bit more room
        //
        DWORD NewTotalElements = TotalElements + 4;
        LPSERVICE_RECORD * NewArray = (LPSERVICE_RECORD *)
            LocalAlloc(0, NewTotalElements * sizeof(LPSERVICE_RECORD));
        if (NewArray == NULL)
        {
            SC_LOG(ERROR, "DEFER_LIST::Add: LocalAlloc FAILED %lu\n", GetLastError());
            return;
        }

        if (ServiceRecordPtr != NULL)
        {
            RtlCopyMemory(NewArray, ServiceRecordPtr,
                          NumElements * sizeof(LPSERVICE_RECORD));
            LocalFree(ServiceRecordPtr);
        }

        TotalElements = NewTotalElements;
        ServiceRecordPtr = NewArray;
    }

    //
    // At this point we have a deferred list that can hold the new element.
    //

    ServiceRecordPtr[NumElements] = ServiceRecord;
    NumElements++;
    SC_LOG(LOCKS, "Added %ws service to deferred list\n",
                  ServiceRecord->ServiceName);

    //
    // If we created the deferred list, queue a workitem (start a
    // thread) to process it.
    //
    if (NumElements == 1)
    {
        NTSTATUS ntStatus;

        ntStatus = RtlQueueWorkItem(ScDeferredListWorkItem, // callback function
                                    NULL,                   // context
                                    WT_EXECUTEONLYONCE);  // flags

        if (!NT_SUCCESS(ntStatus))
        {
            SC_LOG(ERROR,"Couldn't add DeferredListWorkItem, 0x%x\n",
                    ntStatus);
        }
        else
        {
            SC_LOG0(LOCKS,"Work item will process deferred list\n");
        }
    }
}

/****************************************************************************/
VOID
DEFER_LIST::Process(
    VOID
    )

/*++

Routine Description:

    This function loops through each service record pointer in the
    ScDeferredList, and decrements the UseCount for that ServiceRecord.
    If that count becomes zero, and if the ServiceRecord is marked
    for deletion, This routine will delete the service record and
    the registry entry for that service.

    This function frees the memory pointed to by ScDeferredList, when
    it is done processing the list.

    This routine acquires all 3 database locks.
    The following functions call this routine:
        CGroupListLock::Release

Arguments:

    none.

Return Value:

    none.

--*/
{
    //
    // Wait until we have acquired all 3 locks in the proper order
    //
    SC_LOG0(LOCKS, "In ScProcessDeferredList, waiting for locks\n");
    CGroupListExclusiveLock GLock;
    CServiceListExclusiveLock LLock;
    CServiceRecordExclusiveLock RLock;

    //
    // For each element in the list, delete the service information, and
    // free up its associated resources.
    //
    for (DWORD i=0; i<NumElements; i++)
    {
        LPSERVICE_RECORD ServiceRecord = ServiceRecordPtr[i];

        if (ServiceRecord->UseCount == 0)
        {
            SC_LOG1(ERROR,"ScProcessDeferredList: Attempt to decrement UseCount beyond zero.\n"
            "\t"FORMAT_LPWSTR" \n", ServiceRecord->ServiceName);
            SC_ASSERT(FALSE);
        }
        else
        {
            //
            // The use count is not zero, so we want to decrement it.
            // NOTE that even though the count was 1 when we put it in
            // the deferred list, it may have been incremented in the
            // mean-time.
            // CODEWORK: Why doesn't ScDecrementUseCountAndDelete just
            // decrement the UseCount to zero itself?  If it did, we
            // wouldn't need RLock at all here, just LLock.
            //
            ServiceRecord->UseCount--;
            SC_LOG2(USECOUNT, "ScProcessDeferredList: " FORMAT_LPWSTR
                " decrement USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);
        }

        if ((ServiceRecord->UseCount == 0)      &&
            (DELETE_FLAG_IS_SET(ServiceRecord)))
        {
            SC_LOG1(USECOUNT,"ScProcessDeferredList:DELETING THE ("FORMAT_LPWSTR") SERVICE\n",
            ServiceRecord->ServiceName);

            //
            // Check to see if there is an LSA secret object to delete
            //
            if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32_OWN_PROCESS)
            {
                HKEY ServiceNameKey;
                LPWSTR AccountName;

                //
                // Open the service name key.
                //
                if (ScOpenServiceConfigKey(
                        ServiceRecord->ServiceName,
                        KEY_READ,
                        FALSE,               // Create if missing
                        &ServiceNameKey
                        ) == NO_ERROR)
                {
                    //
                    // Read the account name from the registry.
                    //
                    if (ScReadStartName(
                            ServiceNameKey,
                            &AccountName
                            ) == NO_ERROR)
                    {
                        if (AccountName != NULL
                             &&
                            _wcsicmp(AccountName, SC_LOCAL_SYSTEM_USER_NAME) != 0)
                        {
                            ScRemoveAccount(ServiceRecord->ServiceName);
                        }

                        LocalFree(AccountName);

                    } // Got the StartName

                    ScRegCloseKey(ServiceNameKey);
                }
            } // endif SERVICE_WIN32_OWN_PROCESS

            LocalFree(ServiceRecord->Dependencies);

            //
            // Free up the DisplayName space.
            //
            if (ServiceRecord->DisplayName != ServiceRecord->ServiceName)
            {
                LocalFree(ServiceRecord->DisplayName);
            }

            ScDeleteGroupMembership(ServiceRecord);
            ScDeleteRegistryGroupPointer(ServiceRecord);

            ScDeleteStartDependencies(ServiceRecord);
            ScDeleteStopDependencies(ServiceRecord);

            if (ServiceRecord->ServiceSd != NULL)
            {
                RtlDeleteSecurityObject(&ServiceRecord->ServiceSd);
            }

            delete ServiceRecord->CrashRecord;

            //*******************************
            //  Delete the registry node for
            //  This service.
            //*******************************
            DeleteServicePlugPlayRegKeys(ServiceRecord->ServiceName);
            ScDeleteRegServiceEntry(ServiceRecord->ServiceName);

            REMOVE_FROM_LIST(ServiceRecord);

            ScFreeServiceRecord(ServiceRecord);

        } // End If service can be deleted.

    } // End for each element in the list.

    //
    // The deferred list is no longer needed free it.
    //
    LocalFree(ServiceRecordPtr);
    ServiceRecordPtr = NULL;
    TotalElements = 0;
    NumElements = 0;

    SC_LOG0(LOCKS, "Returning from ScProcessDeferredList\n");
}

/****************************************************************************/
BOOL
ScFindEnumStart(
    IN  DWORD               ResumeIndex,
    OUT LPSERVICE_RECORD    *ServiceRecordPtr
    )

/*++

Routine Description:

    This function finds the first service record to begin the enumeration
    search with by finding the next service record folloing the resumeIndex.

    Service records are indexed by a ResumeNum value that is stored in
    each service record.  The numbers increment as the linked list is
    walked.

Arguments:

    ResumeIndex - This index is compared against the ResumeNum in the
        services records.  The pointer to the next service record beyond
        the ResumeIndex is returned.

    ServiceRecordPtr - This is a pointer to a location where the pointer
        to the returned service record is to be placed.

Return Value:

    TRUE - Indicates that there are service records beyond the resume index.

    FALSE - Indicates that there are no service records beyond the resume
        index.

Note:


--*/
{
    FOR_SERVICES_THAT(serviceRecord, serviceRecord->ResumeNum > ResumeIndex)
    {
        *ServiceRecordPtr = serviceRecord;
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************/
BOOL
ScGetNamedImageRecord (
    IN      LPWSTR              ImageName,
    OUT     LPIMAGE_RECORD      *ImageRecordPtr
    )

/*++

Routine Description:

    This function searches for an Image Record that has a name matching
    that which is passed in.

    NOTE:  If this function is called, it is to find a shareable Image Record
    of the given name.

Arguments:

    ImageName - This is a pointer to a NUL terminated image name string.
        This may be in mixed case.

    ImageRecordPtr - This is a pointer to a location where the pointer to
        the Image Record is to be placed.

Note:
    The Database Lock must be held with at least shared access prior to
    calling this routine.

Return Value:

    TRUE - if the record was found.

    FALSE - if the record was not found.

--*/
{
    if (ImageName == NULL)
    {
        SC_LOG(TRACE,"GetNamedImageRecord: Name was NULL\n",0);
        return (FALSE);
    }

    SC_ASSERT(ScServiceRecordLock.Have());

    //
    // Check the database of running images
    //
    for (PIMAGE_RECORD imageRecord = ImageDatabase.Next;
         imageRecord != NULL;
         imageRecord = imageRecord->Next)
    {
        //
        // We need a shareable Image Record, so check the ImageFlags
        //
        if (ScImagePathsMatch(imageRecord->ImageName, ImageName) &&
                (imageRecord->ImageFlags & CANSHARE_FLAG))
        {
            *ImageRecordPtr = imageRecord;
            return TRUE;
        }
    }

    return FALSE;
}

/****************************************************************************/
DWORD
ScGetNamedServiceRecord (
    IN      LPWSTR              ServiceName,
    OUT     LPSERVICE_RECORD    *ServiceRecordPtr
    )

/*++

Routine Description:

    Uses the service name to look through the service and device linked
    lists until it finds a match.  Inactive services can be identified by
    finding CurrentState = SERVICE_STOPPED.

Arguments:

    ServiceName - This is a pointer to a NUL terminated service name string.

    ServiceRecordPtr - This is a pointer to a location where the pointer to
        the Service Record is to be placed.

Return Value:

    NO_ERROR - if the record was found.

    ERROR_SERVICE_DOES_NOT_EXIST - if the service record was not found in
        the linked list.

    ERROR_INVALID_NAME - if the service name was NULL.

Note:
    The caller is expected to grab the lock before calling this routine.

--*/
{
    if (ServiceName == NULL)
    {
        SC_LOG0(TRACE,"GetNamedServiceRecord: Name was NULL\n");
        return ERROR_INVALID_NAME;
    }

    //
    // Check the database of running services
    //
    FOR_SERVICES_THAT(serviceRecord,
                      _wcsicmp(serviceRecord->ServiceName, ServiceName)== 0)
    {
        *ServiceRecordPtr = serviceRecord;
        return NO_ERROR;
    }

    return ERROR_SERVICE_DOES_NOT_EXIST;
}

/****************************************************************************/
DWORD
ScGetDisplayNamedServiceRecord (
    IN      LPWSTR              ServiceDisplayName,
    OUT     LPSERVICE_RECORD    *ServiceRecordPtr
    )

/*++

Routine Description:

    Uses the service display name to look through the service and device
    linked lists until it finds a match.

Arguments:

    ServiceDisplayName - This is a pointer to a NUL terminated service
        display name string.

    ServiceRecordPtr - This is a pointer to a location where the pointer to
        the Service Record is to be placed.

Return Value:

    NO_ERROR - if the record was found.

    ERROR_SERVICE_DOES_NOT_EXIST - if the service record was not found in
        the linked list.

    ERROR_INVALID_NAME - if the service display name was NULL.

Note:
    The caller is expected to grab the lock before calling this routine.

--*/
{
    if (ServiceDisplayName == NULL)
    {
        SC_LOG0(TRACE,"GetDisplayNamedServiceRecord: Name was NULL\n");
        return ERROR_INVALID_NAME;
    }

    //
    // Check the database of running services
    //
    SC_ASSERT(ScServiceRecordLock.Have());
    FOR_SERVICES_THAT(serviceRecord,
                      _wcsicmp(serviceRecord->DisplayName, ServiceDisplayName)== 0)
    {
        *ServiceRecordPtr = serviceRecord;
        return NO_ERROR;
    }

    return ERROR_SERVICE_DOES_NOT_EXIST;
}

/****************************************************************************/
DWORD
ScGetTotalNumberOfRecords (VOID)

/*++

Routine Description:

    Finds the total number of installed Service Records in the database.
    This is used in the Enum case where only the installed services are
    enumerated.

Arguments:

    none

Return Value:

    TotalNumberOfRecords

--*/
{
    return(ScTotalNumServiceRecs);
}

/****************************************************************************/
BOOL
ScInitDatabase (VOID)

/*++

Routine Description:

    This function initializes the Service Controllers database.

Arguments:

    none

Return Value:

    TRUE - Initialization was successful

    FALSE - Initialization failed

--*/
{
    ScTotalNumServiceRecs = 0;

    ImageDatabase.Next = NULL;
    ImageDatabase.Prev = NULL;

    ServiceDatabase.Next = NULL;
    ServiceDatabase.Prev = NULL;

    ScInitGroupDatabase();

    ResumeNumber = 1;

    //
    // Create the database lock.
    // NOTE:  This is never deleted.  It is assumed it will be deleted
    // when the process goes away.
    //

    ScServiceRecordLock.Initialize("  R", "ServiceRecord");
    ScServiceListLock.Initialize(" L ", "ServiceList");


    //
    // Initialize the group list lock used for protecting the
    // OrderGroupList and StandaloneGroupList
    //
    ScGroupListLock.Initialize("G  ", "GroupList");

    //
    // This routine does the following:
    //   - Read the load order group information from the registry.
    //   - Generate the database of service records from the information
    //         stored in the registry.
    //

    if (!ScGenerateServiceDB())
    {
        return(FALSE);
    }

    return(TRUE);
}


/****************************************************************************/
VOID
ScProcessCleanup(
    HANDLE  ProcessHandle
    )

/*++

Routine Description:

    This function is called when a process has died, and the service
    record in the database needs cleaning up.  This function will
    use the ProcessHandle as a key when scanning the ServiceRecord
    database.  All of the service records referencing that handle
    are cleaned up, and then the image record that they reference
    is deleted.

    In cleaning up a service record, CurrentState is set to
    SERVICE_STOPPED, and the ExitCode is set to a unique value that
    indicates that the service died unexpectedly and without warning.

Arguments:

    ProcessHandle - This is the handle of the process that died
        unexpectedly.

Return Value:

    none.

--*/
{
    PIMAGE_RECORD imageRecord;

    {
        //
        // Get exclusive use of database so that it can be modified.
        //
        // If the service record's update flag is set, we may have to
        // modify the group list (within ScDeactivateServiceRecord),
        // so lock the group list too.
        //

        CGroupListExclusiveLock GLock;
        CServiceListSharedLock LLock;
        CServiceRecordExclusiveLock RLock;

        //
        // Find the image record that has this ProcessHandle.
        //

        for (imageRecord = ImageDatabase.Next;
             imageRecord != NULL;
             imageRecord = imageRecord->Next)
        {
            if (ProcessHandle == imageRecord->ProcessHandle)
            {
                break;
            }
        }

        if (imageRecord == NULL)
        {
            SC_LOG(ERROR, "ScProcessCleanup: No image record has handle %#lx!\n",
                           ProcessHandle);
            return;
        }

        SC_LOG2(ERROR, "Service process %ld (%ws) died\n", imageRecord->Pid,
                        imageRecord->ImageName);

        //
        // Deregister the wait.  Note that this must be done
        // even if the WT_EXECUTEONLYONCE flag was specified)
        //

        if (imageRecord->ObjectWaitHandle != NULL)
        {
            NTSTATUS  ntStatus = RtlDeregisterWait(imageRecord->ObjectWaitHandle);

            if (!NT_SUCCESS(ntStatus))
            {
                SC_LOG1(ERROR,
                        "ScProcessCleanup: RtlDeregisterWait FAILED %#x\n",
                        ntStatus);
            }
        }

        DWORD serviceCount = imageRecord->ServiceCount;

        //
        // The image record's service count must include at least this service
        //

        if (serviceCount == 0)
        {
            SC_ASSERT(0);
            // Do something sensible if this ever does happen
            serviceCount = imageRecord->ServiceCount = 1;
        }

        //
        // The Image may have several services running in it.
        // Find the service records for all running services in this
        // image.
        //
        // NOTE:  If the service is typed as a SERVICE_WIN32_OWN_PROCESS, this
        //        means that only one service can exist in the process that
        //        went down.  However, the serviceCount should correctly
        //        indicate as such in that case.
        //

        FOR_SERVICES_THAT(serviceRecord,
            (serviceRecord->ImageRecord == imageRecord)
                &&
            (serviceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED))
        {
            SC_LOG2(ERROR, "Dead process contained %ws service in state %#lx\n",
                            serviceRecord->ServiceName,
                            serviceRecord->ServiceStatus.dwCurrentState);

            //
            // Don't bother notifying PnP if the system is shutting down.  This
            // prevents a deadlock where we can get stuck calling PnP, which is
            // stuck calling into the Eventlog, which is stuck calling into us.
            // 

            if (!ScShutdownInProgress)
            {
                if (serviceRecord->ServiceStatus.dwControlsAccepted
                     &
                    (SERVICE_ACCEPT_POWEREVENT | SERVICE_ACCEPT_HARDWAREPROFILECHANGE))
                {
                    //
                    // Tell PnP not to send controls to this service any more
                    //
                    RegisterServiceNotification((SERVICE_STATUS_HANDLE)serviceRecord,
                                                serviceRecord->ServiceName,
                                                0,
                                                TRUE);
                }

                //
                // Increment the service's crash count and perform the configured
                // recovery action.  Don't bother if the system is shutting down.
                //

                ScQueueRecoveryAction(serviceRecord);
            }

            serviceRecord->StartError = ERROR_PROCESS_ABORTED;
            serviceRecord->StartState = SC_START_FAIL;
            serviceRecord->ServiceStatus.dwWin32ExitCode = ERROR_PROCESS_ABORTED;

            //
            // Clear the server announcement bits in the global location
            // for this service.
            //

            ScRemoveServiceBits(serviceRecord);

            serviceCount = ScDeactivateServiceRecord(serviceRecord);
            if (serviceCount == 0)
            {
                // No need to continue
                break;
            }
        }

        // (If we hit this assert it means that the service database was corrupt:
        // the number of service records pointing to this image record was less
        // than the service count in the image record.  Not much we can do now.)
        SC_ASSERT(serviceCount == 0);

        //
        // Remove the ImageRecord from the list and delete it
        //
        REMOVE_FROM_LIST(imageRecord);
    }

    ScDeleteImageRecord(imageRecord);

    return;
}

VOID
ScDeleteMarkedServices(
    VOID
    )

/*++

Routine Description:

    This function looks through the service record database for any entries
    marked for deletion.  If one is found, it is removed from the registry
    and its entry is deleted from the service record database.

    WARNING:
    This function is to be called during initialization only.  It
    is assumed that no services are running when this function is called.
    Therefore, no locks are held during this operation.

Arguments:

    none

Return Value:

    none

--*/
{
    HKEY                ServiceNameKey;
    LPWSTR              AccountName;

    FOR_SERVICES_THAT(serviceRecord, DELETE_FLAG_IS_SET(serviceRecord))
    {
        SC_LOG(TRACE,"ScDeleteMarkedServices: %ws is being deleted\n",
            serviceRecord->ServiceName);
        //
        // Open the service name key.
        //
        if (ScOpenServiceConfigKey(
                serviceRecord->ServiceName,
                KEY_READ,
                FALSE,               // Create if missing
                &ServiceNameKey) == NO_ERROR)
        {
            //
            // Read the account name from the registry.
            // If this fails, we still want to delete the registry entry.
            //
            if (ScReadStartName(ServiceNameKey, &AccountName) == NO_ERROR
                 &&
                AccountName != NULL)
            {
                if (_wcsicmp(AccountName, SC_LOCAL_SYSTEM_USER_NAME) != 0)
                {
                    ScRemoveAccount(serviceRecord->ServiceName);
                }

                LocalFree(AccountName);

            } // Got the StartName

            ScRegCloseKey(ServiceNameKey);

            //
            // Delete the entry from the registry
            //
            ScDeleteRegServiceEntry(serviceRecord->ServiceName);

            //
            // Free memory for the DisplayName.
            //
            if (serviceRecord->DisplayName != serviceRecord->ServiceName)
            {
                LocalFree(serviceRecord->DisplayName);
            }

            //
            // Remove the service record from the database
            //
            LPSERVICE_RECORD saveRecord = serviceRecord->Prev;
            REMOVE_FROM_LIST(serviceRecord);

            ScFreeServiceRecord(serviceRecord);

            serviceRecord = saveRecord;
        }
    }
}


/****************************************************************************/
DWORD
ScRemoveService (
    IN      LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

        This should be used to deactivate a service record and shut down
        the process only if it is the last service in the process.  It
        will be used for polite shut-down when a service terminates as
        normal.  It will always be called by the status routine.  If the
        service controller believes that no other services are running in
        the process, it can force termination of the process if it does
        not respond to the process shutdown request.

    This function deactivates the service record (ScDeactivateServiceRecord)
    and checks to see if the ServiceCount in the image record has gone to
    zero.  If it has, then it terminates the service process.  When that
    is complete, it calls ScDeleteImageRecord to remove the remaining
    evidence.

    Even if an error occurs, and we are unable to terminate the process,
    we delete the image record any - just as we would in the case
    where it goes away.

Arguments:

    ServiceRecord - This is a pointer to the service record that is to
        be removed.

Return Value:

    NO_ERROR - The operation was successful.

    NERR_ServiceKillProc - The service process had to be killed because
        it wouldn't terminate when requested.  If the process did not
        go away - even after being killed (TerminateProcess), this error
        message is still returned.

Note:

    Uses Exclusive Locks.

--*/
{
    DWORD           serviceCount = 0;
    LPIMAGE_RECORD  ImageRecord;

    {
        //
        // Get exclusive use of database so that it can be modified.
        // If the service record's update flag is set, we may have to
        // modify the group list, so lock the group list too.
        //
        CGroupListExclusiveLock GLock;
        CServiceListSharedLock LLock; // (needed if update flag set and service has dependencies)
        CServiceRecordExclusiveLock RLock;

        ImageRecord = ServiceRecord->ImageRecord;

        //
        // ImageRecord may be NULL if it had been cleaned up earlier
        //
        if (ImageRecord != NULL)
        {
            //
            // Deactivate the service record.
            //
            serviceCount = ScDeactivateServiceRecord(ServiceRecord);

            //
            // Do as little as possible while holding the locks.
            // Otherwise, we can cause a deadlock or a bottleneck
            // on system shutdown due to contention for the
            // exclusive locks
            //

            if (serviceCount == 0)
            {
                //
                //  Remove the Image record from linked list.
                //
                REMOVE_FROM_LIST(ImageRecord);
            }
        }
    }

    //
    // Done with modifications - now allow other threads database access.
    //

    if (ImageRecord != NULL && serviceCount == 0)
    {
        //
        // Now we must terminate the Service Process.  The return status
        // from this call is not very interesting.  The calling application
        // probably doesn't care how the process died.  (whether it died
        // cleanly, or had to be killed).
        //
        ScTerminateServiceProcess(ImageRecord);

        ScDeleteImageRecord (ImageRecord);
    }

    return(NO_ERROR);
}

/****************************************************************************/
VOID
ScDeleteImageRecord (
    IN LPIMAGE_RECORD       ImageRecord
    )

/*++

Routine Description:

    This function deletes an ImageRecord from the database by removing it
    from the linked list, and freeing its associated memory.  Prior to
    doing this however, it closes the PipeHandle and the ProcessHandle
    in the record.

Arguments:

    ImageRecord - This is a pointer to the ImageRecord that is being deleted.

Return Value:

    nothing

Notes:

    This routine assumes that the image record has already been removed
    from the list before it is called via the REMOVE_FROM_LIST macro.  This
    is to allow us to call ScDeleteImageRecord without holding any exclusive
    locks

--*/
{
    HANDLE  status;         // return status from LocalFree

    SC_ASSERT( ImageRecord != NULL );

    //
    // What else can we do except note the errors in debug mode?
    //
    if (CloseHandle(ImageRecord->PipeHandle) == FALSE)
    {
        SC_LOG(TRACE,"DeleteImageRecord: ClosePipeHandle Failed %lu\n",
               GetLastError());
    }

    if (CloseHandle(ImageRecord->ProcessHandle) == FALSE)
    {
        SC_LOG(TRACE,"DeleteImageRecord: CloseProcessHandle Failed %lu\n",
               GetLastError());
    }

    if (ImageRecord->ProfileHandle != (HANDLE) NULL)
    {
        if (UnloadUserProfile(ImageRecord->TokenHandle,
                              ImageRecord->ProfileHandle) == FALSE)
        {
            SC_LOG1(ERROR,"DeleteImageRecord: UnloadUserProfile Failed %lu\n",
                    GetLastError());
        }
    }

    if (ImageRecord->TokenHandle != (HANDLE) NULL)
    {
        if (CloseHandle(ImageRecord->TokenHandle) == FALSE)
        {
            SC_LOG1(TRACE,"DeleteImageRecord: CloseTokenHandle Failed %lu\n",
                    GetLastError());
        }
    }

    status = LocalFree(ImageRecord);

    if (status != NULL)
    {
        SC_LOG(TRACE,"DeleteImageRecord: LocalFree Failed, rc = %d\n",
               GetLastError());
    }

    return;
}

/****************************************************************************/
DWORD
ScDeactivateServiceRecord (
    IN LPSERVICE_RECORD     ServiceRecord
    )

/*++

Routine Description:

    This function deactivates a service record by updating the proper
    GlobalCount data structure.

    NOTE:  Although the ServiceRecord does not go away, the pointer to
           the ImageRecord is destroyed.

Arguments:

    ServiceRecord - This is a pointer to the ServiceRecord that is to be
        deleted (moved to uninstalled database).

Notes:

    This routine assumes that the Exclusive database lock has already
    been obtained.  (ScRemoveService & ScProcessCleanup call this function).
    If the service's update flag is set (its configuration was changed
    while it was running), the exclusive group list lock must also have
    been obtained.

Return Value:

    ServiceCount - This indicates how many services in this service process
        are actually installed.

--*/
{
    DWORD       serviceCount = 0;
    DWORD       status;
    DWORD       dwServiceType;
    DWORD       dwStartType;
    DWORD       dwErrorControl;
    DWORD       dwTagId;
    LPWSTR      lpDependencies = NULL;
    LPWSTR      lpLoadOrderGroup = NULL;
    LPWSTR      lpDisplayName = NULL;

    SC_LOG(TRACE,"In DeactivateServiceRecord\n",0);
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());
    //
    // Decrement the service count in the image record.
    //
    if (ServiceRecord->ImageRecord != NULL)
    {
        serviceCount = --(ServiceRecord->ImageRecord->ServiceCount);
    }
    ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ServiceRecord->ServiceStatus.dwControlsAccepted = 0;
    ServiceRecord->ServiceStatus.dwCheckPoint = 0;
    ServiceRecord->ServiceStatus.dwWaitHint = 0;
    ServiceRecord->ImageRecord = NULL;

    //
    // If the Update bit is set in the services status flag, we need
    // to read the latest registry configuration information into the
    // service record.  If this fails, all we can do is log the error
    // and press on with the existing data in the service record.
    //

    if (UPDATE_FLAG_IS_SET(ServiceRecord))
    {
        SC_ASSERT(ScGroupListLock.HaveExclusive());
        status = ScReadConfigFromReg(
                    ServiceRecord,
                    &dwServiceType,
                    &dwStartType,
                    &dwErrorControl,
                    &dwTagId,
                    NULL,              // Don't need dependencies -- they're updated dynamically
                    &lpLoadOrderGroup,
                    NULL);             // Don't need display name -- it's updated dynamically

        if (status == NO_ERROR)
        {

            //
            // Dependencies are NULL since they're updated dynamically
            //
            status = ScUpdateServiceRecordConfig(
                        ServiceRecord,
                        dwServiceType,
                        dwStartType,
                        dwErrorControl,
                        lpLoadOrderGroup,
                        NULL);
        }
        if (status != NO_ERROR)
        {
            SC_LOG1(ERROR,"ScDeactivateServiceRecord:Attempt to update "
            "configuration for stopped service failed\n",status);
            //
            // ERROR_LOG ErrorLog
            //
        }

        LocalFree(lpLoadOrderGroup);
        LocalFree(lpDependencies);
        LocalFree(lpDisplayName);

        CLEAR_UPDATE_FLAG(ServiceRecord);
    }
    //
    // Since the service is no longer running, and no longer has a handle
    // to the service, we need to decrement the use count.  If the
    // count is decremented to zero, and the service is marked for
    // deletion, it will get deleted.
    //

    ScDecrementUseCountAndDelete(ServiceRecord);

    return(serviceCount);
}




/****************************************************************************/
DWORD
ScTerminateServiceProcess (
    IN  PIMAGE_RECORD   ImageRecord
    )

/*++

Routine Description:

    This function sends an SERVICE_STOP control message to the target
    ControlDispatcher.  Then it uses the process handle to wait for the
    service process to terminate.

    If the service process fails to terminate with the polite request, it
    will be abruptly killed.  After killing the process, this routine will
    wait on the process handle to make sure it enters the signaled state.
    If it doesn't, and the wait times out, we return anyway having given
    it our best shot.

Arguments:

    ImageRecord - This is a pointer to the Image Record that stores
        information about the service that is to be terminated.

Return Value:

    NO_ERROR - The operation was successful.

    NERR_ServiceKillProc - The service process had to be killed because
        it wouldn't terminate when requested.  If the process did not
        go away - even after being killed (TerminateProcess), this error
        message is still returned.

Note:
    LOCKS:
    This function always operates within an exclusive database lock.
    It DOES NOT give up this lock when sending the control to the service
    process.  We would like all these operations to be atomic.

    It must give this up temporarily when it does the pipe transact.

--*/

{
    DWORD  returnStatus;
    DWORD  status;
    DWORD  waitStatus;

    returnStatus = NO_ERROR;

    //
    // Check vs. NULL in case the register failed or the work item
    // was already deregistered in RSetServiceStatus
    //
    if (ImageRecord->ObjectWaitHandle != NULL) {

        status = RtlDeregisterWait(ImageRecord->ObjectWaitHandle);

        if (NT_SUCCESS(status)) {
            ImageRecord->ObjectWaitHandle = NULL;
        }
        else {

            SC_LOG1(ERROR,
                    "ScTerminateServiceProcess: RtlDeregisterWait failed 0x%x\n",
                    status);
        }
    }

    //
    // Send Uninstall message to the Service Process
    // Note that the ServiceName is NULL when addressing
    // the Service Process.
    //

    SC_LOG(TRACE,"TerminateServiceProcess, sending Control...\n",0);

    //
    // Stop the service's control dispatcher
    //

    status = ScSendControl(
            L"",                        // no service name.
            L"",                        // no display name.
            ImageRecord->PipeHandle,    // PipeHandle
            SERVICE_STOP,               // Opcode
            NULL,                       // CmdArgs (pointer to vectors).
            0L,                         // NumArgs
            NULL);                      // Ignore handler return value


    if (status == NO_ERROR)
    {
        //
        //  Control Dispatcher accepted the request - now
        //  wait for it to shut down.
        //
        SC_LOG(TRACE,
            "TerminateServiceProcess, waiting for process to terminate...\n",0);

        waitStatus = WaitForSingleObject (
                        ImageRecord->ProcessHandle,
                        TERMINATE_TIMEOUT);

        if (waitStatus == WAIT_TIMEOUT)
        {
            SC_LOG3(ERROR,"TerminateServiceProcess: Process %#lx (%ws) did not exit because of timeout: %#ld\n",
                    ImageRecord->Pid, ImageRecord->ImageName, WAIT_TIMEOUT);

            //
            // Process didn't terminate. So Now I have to kill it.
            //
            TerminateProcess(ImageRecord->ProcessHandle, 0);

            waitStatus = WaitForSingleObject (
                            ImageRecord->ProcessHandle,
                            TERMINATE_TIMEOUT);

            if (waitStatus == WAIT_TIMEOUT)
            {
                SC_LOG2(ERROR,"TerminateServiceProcess: Couldn't kill process %#lx because of timeout: %#ld\n",
                        ImageRecord->Pid, WAIT_TIMEOUT);
            }
            returnStatus = NO_ERROR;
        }
    }
    else
    {
        //
        // ScSendControl failed -- this can occur if the service calls ExitProcess
        // while handling SERVICE_CONTROL_STOP or SERVICE_CONTROL_SHUTDOWN since
        // the pipe for the image record is now broken (ERROR_BROKEN_PIPE).
        //
        SC_LOG3(ERROR,
            "TerminateServiceProcess:SendControl to stop process %#lx (%ws) failed, %ld\n",
            ImageRecord->Pid, ImageRecord->ImageName, status);

        TerminateProcess(ImageRecord->ProcessHandle, 0);

        waitStatus = WaitForSingleObject (
                        ImageRecord->ProcessHandle,
                        TERMINATE_TIMEOUT);

        if (waitStatus == WAIT_TIMEOUT)
        {
            SC_LOG2(ERROR,"TerminateServiceProcess: Couldn't kill process because of timeout: %ld\n",
                    0, WAIT_TIMEOUT);
        }
        returnStatus = NO_ERROR;

    }
    SC_LOG(TRACE,"TerminateServiceProcess, Done terminating Process!\n",0);
    return(returnStatus);
}


VOID
ScDeferredListWorkItem(
    IN PVOID    pContext
    )
/*++

Routine Description:

    This function acquires all the database locks, and allows
    the group list lock routine to process the deferred list.

--*/
{
    ScDeferredList.Process();
}


DWORD
ScUpdateServiceRecordConfig(
    IN  LPSERVICE_RECORD    ServiceRecord,
    IN  DWORD               dwServiceType,
    IN  DWORD               dwStartType,
    IN  DWORD               dwErrorControl,
    IN  LPWSTR              lpLoadOrderGroup,
    IN  LPBYTE              lpDependencies
    )

/*++

Routine Description:

    This function updates the service record with the latest config
    information (passed in).

    It assumed that exclusive locks are held before calling this function.

Arguments:


Return Value:


Note:


--*/
#define SERVICE_TYPE_CHANGED            0x00000001
#define START_TYPE_CHANGED              0x00000002
#define ERROR_CONTROL_CHANGED           0x00000004
#define BINARY_PATH_CHANGED             0x00000008
#define LOAD_ORDER_CHANGED              0x00000010
#define TAG_ID_CHANGED                  0x00000020
#define DEPENDENCIES_CHANGED            0x00000040
#define START_NAME_CHANGED              0x00000080

{
    DWORD               status;
    DWORD               backoutStatus;
    LPWSTR              OldLoadOrderGroup = NULL;
    LPWSTR              OldDependencies = NULL;

    DWORD               OldServiceType;
    DWORD               OldStartType;
    DWORD               OldErrorControl;
    DWORD               Progress = 0;
    DWORD               bufSize;
    DWORD               MaxDependSize = 0;

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    OldServiceType = ServiceRecord->ServiceStatus.dwServiceType;
    OldStartType   = ServiceRecord->StartType;
    OldErrorControl= ServiceRecord->ErrorControl;


    //==============================
    // UPDATE DWORDs
    //==============================
    if (dwServiceType != SERVICE_NO_CHANGE)
    {
        ServiceRecord->ServiceStatus.dwServiceType = dwServiceType;
    }
    if (dwStartType != SERVICE_NO_CHANGE)
    {
        ServiceRecord->StartType = dwStartType;
    }
    if (dwErrorControl != SERVICE_NO_CHANGE)
    {
        ServiceRecord->ErrorControl = dwErrorControl;
    }

    Progress |= (SERVICE_TYPE_CHANGED   |
                 START_TYPE_CHANGED     |
                 ERROR_CONTROL_CHANGED  );


    //==============================
    // UPDATE Dependencies
    //==============================

    if (lpDependencies != NULL)
    {
        //
        // Generate the current (old) list of dependency strings.
        //
        ScGetDependencySize(ServiceRecord,&bufSize, &MaxDependSize);
        if (bufSize > 0)
        {
            OldDependencies = (LPWSTR)LocalAlloc(LMEM_FIXED, bufSize);
            if (OldDependencies == NULL)
            {
                status = GetLastError();
                goto Cleanup;
            }
            status = ScGetDependencyString(
                            ServiceRecord,
                            MaxDependSize,
                            bufSize,
                            OldDependencies);
            if (status != NO_ERROR)
            {
                goto Cleanup;
            }
        }

        ScDeleteStartDependencies(ServiceRecord);

        status = ScCreateDependencies(ServiceRecord, (LPWSTR) lpDependencies);
        if (status != NO_ERROR)
        {
            goto Cleanup;
        }
        Progress |= DEPENDENCIES_CHANGED;
    }
    //==============================
    // UPDATE LoadOrderGroup
    //==============================

    if (lpLoadOrderGroup != NULL)
    {
        if (*lpLoadOrderGroup != 0)
        {
            //
            // The string in lpLoadOrderGroup should match that in
            // the RegistryGroup in the service record.
            //
            if (_wcsicmp(lpLoadOrderGroup, ServiceRecord->RegistryGroup->GroupName) != 0)
            {
                SC_LOG2(ERROR,"ScUpdateServiceRecordConfig:  New Group [%ws] Doesn't "
                "match that stored in the service database [%ws]\n",
                lpLoadOrderGroup,
                ServiceRecord->RegistryGroup->GroupName);

                status = ERROR_GEN_FAILURE;
                goto Cleanup;
            }
        }
        //
        // Save Old MemberOfGroup name for error recovery
        //
        if (ServiceRecord->MemberOfGroup != NULL)
        {
            OldLoadOrderGroup = (LPWSTR)LocalAlloc(
                    LMEM_FIXED,
                    WCSSIZE(ServiceRecord->MemberOfGroup->GroupName));
            //
            // If this allocation fails, just pretend that it doesn't exist.
            //
            if (OldLoadOrderGroup != NULL)
            {
                wcscpy(OldLoadOrderGroup, ServiceRecord->MemberOfGroup->GroupName);
            }
        }
        //
        // Delete MemberOfGroup & Add RegistryGroup to MemberOfGroup so that
        // they are the same.
        // REMEMBER that RegistryGroup and lpLoadOrderGroup are the same!
        //
        ScDeleteGroupMembership(ServiceRecord);
        status = ScCreateGroupMembership(ServiceRecord, lpLoadOrderGroup);

        if (status != NO_ERROR)
        {
            ScDeleteGroupMembership(ServiceRecord);

            if ((OldLoadOrderGroup != NULL) && (*OldLoadOrderGroup))
            {
                backoutStatus = ScCreateGroupMembership(
                                ServiceRecord,
                                OldLoadOrderGroup);
                if (backoutStatus != NO_ERROR)
                {
                    // Do what? - we may want to write to ERROR LOG?
                }

            }
            goto Cleanup;
        }
    }
    status = NO_ERROR;

Cleanup:

    if (status != NO_ERROR)
    {
        ServiceRecord->ServiceStatus.dwServiceType = OldServiceType;
        ServiceRecord->StartType = OldStartType;
        ServiceRecord->ErrorControl = OldErrorControl;

        if (Progress & DEPENDENCIES_CHANGED)
        {
            ScDeleteStartDependencies(ServiceRecord);

            if ((OldDependencies != NULL) && (*OldDependencies != 0))
            {
                backoutStatus = ScCreateDependencies(
                                    ServiceRecord,
                                    OldDependencies);
                if (backoutStatus != NO_ERROR)
                {
                    // Do what? - we may want to write to ERROR LOG?
                }
            }
        }

    }

    LocalFree(OldDependencies);
    LocalFree(OldLoadOrderGroup);

    return(status);
}

BOOL
ScAllocateSRHeap(
    DWORD   HeapSize
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    ServiceRecordHeap = HeapCreate(0,HeapSize,0);
    if (ServiceRecordHeap == NULL)
    {
        SC_LOG0(ERROR,"Could not allocate Heap for Service Database\n");
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\dataman.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dataman.h

Abstract:

    Contains data structures and function prototypes for the Service
    Controller Database Manager and the Group List Database Manager.
    (Dataman.c & Groupman.c)


Author:

    Dan Lafferty (danl)     22-Oct-1993

Environment:

    User Mode -Win32

Revision History:

    04-Dec-1996     AnirudhS
        Added CCrashRecord.

    17-Aug-1995     AnirudhS
        Removed State field from LOAD_ORDER_GROUP, since it is recomputed
        every time it is read.

    26-Jun-1995     AnirudhS
        Added ScNotifyServiceObject.

    12-Apr-1995     AnirudhS
        Added AccountName field to image record.

    06-Oct-1993     danl
        Re-arranged comments so that structures are easier to read.

    19-Jan-1992     danl
        Modified for use with the "real" service controller

    20-Mar-1991     danl
        created
--*/

#ifndef SCDATAMAN_INCLUDED
#define SCDATAMAN_INCLUDED

#define USE_GROUPS

//
// ImageFlag definitions
//
#define CANSHARE_FLAG        0x00000001 // service can run in a shared process
#define IS_SYSTEM_SERVICE    0x00000002 // service runs in this exe or the security process

//
// StatusFlag definitions
//
#define DELETE_FLAG          0x00000001 // service is marked for delete
#define UPDATE_FLAG          0x00000002 //
#define CURRENTSTART_FLAG    0x00000004 //

//
// StatusFlag Macros.  SR = ServiceRecord
//

#define SET_DELETE_FLAG(SR)     (((SR)->StatusFlag) |= DELETE_FLAG)
#define CLEAR_DELETE_FLAG(SR)   (((SR)->StatusFlag) &= (~DELETE_FLAG))
#define DELETE_FLAG_IS_SET(SR)  (((SR)->StatusFlag) &  DELETE_FLAG)

#define SET_UPDATE_FLAG(SR)     (((SR)->StatusFlag) |= UPDATE_FLAG)
#define CLEAR_UPDATE_FLAG(SR)   (((SR)->StatusFlag) &= (~UPDATE_FLAG))
#define UPDATE_FLAG_IS_SET(SR)  (((SR)->StatusFlag) &  UPDATE_FLAG)

//
// To get a demand start service to be started correctly in group
// order specified by the ServiceGroupOrder list, we need an additional
// flag to indicate that this service must be included in the same start
// request.
//
#define SET_CURRENTSTART_FLAG(SR)     (((SR)->StatusFlag) |= CURRENTSTART_FLAG)
#define CLEAR_CURRENTSTART_FLAG(SR)   (((SR)->StatusFlag) &= (~CURRENTSTART_FLAG))
#define CURRENTSTART_FLAG_IS_SET(SR)  (((SR)->StatusFlag) &  CURRENTSTART_FLAG)


//
// Data Structures
//

//
//==================
// LOAD_ORDER_GROUP
//==================
// NOTE:  This is an ordered linked list.  The Next group is loaded after
//  this group.
//
// Reference count which indicates the number of members in this
// group plus any dependency pointer that points to this group.
// This field is only used for standalone groups so that we know
// when to delete the group entry.  This value is always set to
// 0xffffffff if this entry represents an order group.
//
typedef struct _LOAD_ORDER_GROUP {
    struct _LOAD_ORDER_GROUP    *Next;
    struct _LOAD_ORDER_GROUP    *Prev;
    LPWSTR                      GroupName;
    DWORD                       RefCount;

} LOAD_ORDER_GROUP, *PLOAD_ORDER_GROUP, *LPLOAD_ORDER_GROUP;



//================
// IMAGE_RECORD
//================
typedef struct _IMAGE_RECORD {
    struct _IMAGE_RECORD    *Prev;              // linked list
    struct _IMAGE_RECORD    *Next;              // linked list
    LPWSTR                  ImageName;          // fully qualified .exe name
    DWORD                   Pid;                // Process ID
    DWORD                   ServiceCount;       // Num services running in process
    HANDLE                  PipeHandle;         // Handle to Service
    HANDLE                  ProcessHandle;      // Handle for process
    HANDLE                  ObjectWaitHandle;   // Handle for waiting on the process
    HANDLE                  TokenHandle;        // Logon token handle
    LUID                    AccountLuid;        // Unique LUID for this logon session
    HANDLE                  ProfileHandle;      // User profile handle
    LPWSTR                  AccountName;        // Account process was started under
    DWORD                   ImageFlags;         // Flags for the IMAGE_RECORD
}IMAGE_RECORD, *PIMAGE_RECORD, *LPIMAGE_RECORD;

typedef enum _DEPEND_TYPE {
    TypeNone = 0,
    TypeDependOnService = 128,
    TypeDependOnGroup,
    TypeDependOnUnresolved  // only for service
} DEPEND_TYPE, *PDEPEND_TYPE, *LPDEPEND_TYPE;

//================
// DEPEND_RECORD
//================
// A service record has a pointer to this structure if the service
// must be started after some services, or must be stopped after some
// services.
// NOTE:  This is an ordered linked list.  This service depends on the
//  "Next" service.  Question:  Does this service depend on all the services
//  in the Next chain?
//
// Depend union:
// Based on the DependType field, this pointer may point to a
// service or a group which the service depends on, or an
// unresolved dependency structure.
//
typedef struct _DEPEND_RECORD {
    struct _DEPEND_RECORD   *Next;
    DEPEND_TYPE             DependType;
    union {
        struct _SERVICE_RECORD *    DependService;
        struct _LOAD_ORDER_GROUP *  DependGroup;
        struct _UNRESOLVED_DEPEND * DependUnresolved;
        LPVOID                      Depend; // used when type doesn't matter
    };
} DEPEND_RECORD, *PDEPEND_RECORD, *LPDEPEND_RECORD;


//================
// CCrashRecord
//================
// This structure counts a service's crashes and remembers the time of the
// last crash.  It is allocated only for services that crash.
//
class CCrashRecord
{
public:
            CCrashRecord() :
                _LastCrashTime(0),
                _Count(0)
                    { }

    DWORD   IncrementCount(DWORD ResetSeconds);

private:

    __int64     _LastCrashTime; // FILETIME = __int64
    DWORD       _Count;
};



//================
// SERVICE_RECORD
//================
// Dependency information:
//    StartDepend is a linked list of services and groups that must be
//        started first before this service can start.
//    StopDepend is a linked list of services and groups that must be
//        stopped first before this service can stop.
//    Dependencies is a string read in from the registry.  Deleted when
//      the info has been converted to a StartDepend list.
//
// StartError:
// Error encountered by service controller when starting a service.
// This is distinguished from error posted by the service itself in
// the exitcode field.
//
// StartState:
// SC managed service state which is distinguished from the service
// current state to enable correct handling of start dependencies.
//
// Load order group information:
//
//     MemberOfGroup is a pointer to a load order group which this service
//         is currently a member of.  This value is set to NULL if this
//         service does not belong to a group.  A non-NULL pointer could
//         point to a group entry in either the order group or standalone
//         group list.
//
//     RegistryGroup is a pointer to a group which we have recorded in the
//         registry as the group this service belongs to.  This is not the
//         same as MemberOfGroup whenever the service is running and the
//         load order group of the service has been changed
//
typedef struct _SERVICE_RECORD {
    struct _SERVICE_RECORD  *Prev;          // linked list
    struct _SERVICE_RECORD  *Next;          // linked list
    LPWSTR                  ServiceName;    // points to service name
    LPWSTR                  DisplayName;    // points to display name
    DWORD                   ResumeNum;      // Ordered number for this rec
    DWORD                   ServerAnnounce; // Server announcement bit flags
    DWORD                   Signature;      // Identifies this as a service record.
    DWORD                   UseCount;       // How many open handles to service
    DWORD                   StatusFlag;     // status(delete,update...)
    union {
        LPIMAGE_RECORD      ImageRecord;    // Points to image record
        LPWSTR              ObjectName;     // Points to driver object name
    };
    SERVICE_STATUS          ServiceStatus;  // see winsvc.h
    DWORD                   StartType;      // AUTO, DEMAND, etc.
    DWORD                   ErrorControl;   // NORMAL, SEVERE, etc.
    DWORD                   Tag;            // DWORD Id for the service,0=none.
    LPDEPEND_RECORD         StartDepend;
    LPDEPEND_RECORD         StopDepend;
    LPWSTR                  Dependencies;
    PSECURITY_DESCRIPTOR    ServiceSd;
    DWORD                   StartError;
    DWORD                   StartState;
    LPLOAD_ORDER_GROUP      MemberOfGroup;
    LPLOAD_ORDER_GROUP      RegistryGroup;
    CCrashRecord *          CrashRecord;
}
SERVICE_RECORD, *PSERVICE_RECORD, *LPSERVICE_RECORD;


//===================
// UNRESOLVED_DEPEND
//===================
// Unresolved dependency record structure
//
// Unresolved dependency entries are linked together so that when a
// new service or group is created (installed) we can look it up in this
// list to see if the service or group is already depended on by some
// other service.
//
typedef struct _UNRESOLVED_DEPEND {
    struct _UNRESOLVED_DEPEND *Next;
    struct _UNRESOLVED_DEPEND *Prev;
    LPWSTR                    Name;     // Service or group name
    DWORD                     RefCount;
} UNRESOLVED_DEPEND, *PUNRESOLVED_DEPEND, *LPUNRESOLVED_DEPEND;


//
// Macros & Constants
//

//
// for every service record in the database...
//
#define FOR_ALL_SERVICES(SR)                                            \
                     SC_ASSERT(ScServiceListLock.Have());               \
                     for (LPSERVICE_RECORD SR = ScGetServiceDatabase(); \
                          SR != NULL;                                   \
                          SR = SR->Next)

//
// for every service record in the database that meets this condition...
//
#define FOR_SERVICES_THAT(SR, condition)                                \
                                    FOR_ALL_SERVICES(SR)                \
                                        if (!(condition))               \
                                            continue;                   \
                                        else

#define FIND_END_OF_LIST(record)    while((record)->Next != NULL) {     \
                                        (record)=(record)->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    (record)->Prev->Next = (record)->Next;      \
                                    if ((record)->Next != NULL) {               \
                                        (record)->Next->Prev = (record)->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST((record))      \
                                    (record)->Next = (newRec);      \
                                    (newRec)->Prev = (record);      \
                                    (newRec)->Next = NULL;


//
// Service controller maintains the state of a service when
// starting up a service and its dependencies in the StartState
// field of the service record.
//
#define SC_NEVER_STARTED         0x00000000
#define SC_START_NOW             0x00000001
#define SC_START_PENDING         0x00000002
#define SC_START_SUCCESS         0x00000003
#define SC_START_FAIL            0x00000004


#define TERMINATE_TIMEOUT       20000       // wait response to terminate req.


//
// External Globals
//

extern  LPLOAD_ORDER_GROUP  ScGlobalTDIGroup;
extern  LPLOAD_ORDER_GROUP  ScGlobalPNP_TDIGroup;


//
// Function Prototypes
//

LPLOAD_ORDER_GROUP
ScGetOrderGroupList(
    VOID
    );

LPLOAD_ORDER_GROUP
ScGetStandaloneGroupList(
    VOID
    );

LPSERVICE_RECORD
ScGetServiceDatabase(
    VOID
    );

LPUNRESOLVED_DEPEND
ScGetUnresolvedDependList(
    VOID
    );

BOOL
ScInitDatabase(
    VOID
    );

VOID
ScInitGroupDatabase(VOID);

VOID
ScEndGroupDatabase(VOID);

DWORD
ScCreateDependRecord(
    IN  BOOL IsStartList,
    IN  OUT PSERVICE_RECORD ServiceRecord,
    OUT PDEPEND_RECORD *DependRecord
    );

DWORD
ScCreateImageRecord (
    OUT     LPIMAGE_RECORD      *ImageRecordPtr,
    IN      LPWSTR              ImageName,
    IN      LPWSTR              AccountName,
    IN      DWORD               Pid,
    IN      HANDLE              PipeHandle,
    IN      HANDLE              ProcessHandle,
    IN      HANDLE              TokenHandle,
    IN      HANDLE              ProfileHandle,
    IN      DWORD               ImageFlags
    );

DWORD
ScCreateServiceRecord(
    IN  LPWSTR              ServiceName,
    OUT LPSERVICE_RECORD   *ServiceRecord
    );

VOID
ScFreeServiceRecord(
    IN  LPSERVICE_RECORD   ServiceRecord
    );

VOID
ScDecrementUseCountAndDelete(
    LPSERVICE_RECORD    ServiceRecord
    );

BOOL
ScFindEnumStart(
    IN  DWORD               ResumeIndex,
    OUT LPSERVICE_RECORD    *ServiceRecordPtr
    );

BOOL
ScGetNamedImageRecord (
    IN      LPWSTR              ImageName,
    OUT     LPIMAGE_RECORD      *ImageRecordPtr
    );

DWORD
ScGetNamedServiceRecord (
    IN      LPWSTR              ServiceName,
    OUT     LPSERVICE_RECORD    *ServiceRecordPtr
    );

LPLOAD_ORDER_GROUP
ScGetNamedGroupRecord(
    IN      LPCWSTR             GroupName
    );

DWORD
ScGetDisplayNamedServiceRecord (
    IN      LPWSTR              ServiceDisplayName,
    OUT     LPSERVICE_RECORD    *ServiceRecordPtr
    );

DWORD
ScGetTotalNumberOfRecords(
    VOID
    );

VOID
ScProcessCleanup(
    HANDLE  ProcessHandle
    );

VOID
ScQueueRecoveryAction(
    IN LPSERVICE_RECORD     ServiceRecord
    );

VOID
ScDeleteMarkedServices(
    VOID
    );

DWORD
ScUpdateServiceRecord (
    IN      LPSERVICE_STATUS    ServiceStatus,
    IN      LPSERVICE_RECORD    ServiceRecord
    );

DWORD
ScRemoveService (
    IN      LPSERVICE_RECORD    ServiceRecord
    );

DWORD
ScTerminateServiceProcess (
    IN  PIMAGE_RECORD   ImageRecord
    );

VOID
ScDeleteImageRecord (
    IN LPIMAGE_RECORD   ImageRecord
    );

VOID
ScActivateServiceRecord (
    IN LPSERVICE_RECORD     ServiceRecord,
    IN LPIMAGE_RECORD       ImageRecord
    );

DWORD
ScDeactivateServiceRecord (
    IN LPSERVICE_RECORD     ServiceRecord
    );

DWORD
ScCreateOrderGroupEntry(
    IN  LPWSTR GroupName
    );

DWORD
ScAddConfigInfoServiceRecord(
    IN  LPSERVICE_RECORD     ServiceRecord,
    IN  DWORD                ServiceType,
    IN  DWORD                StartType,
    IN  DWORD                ErrorControl,
    IN  LPWSTR               Group OPTIONAL,
    IN  DWORD                Tag,
    IN  LPWSTR               Dependencies OPTIONAL,
    IN  LPWSTR               DisplayName OPTIONAL,
    IN  PSECURITY_DESCRIPTOR Sd OPTIONAL
    );


VOID
ScGenerateDependencies(
    VOID
    );

DWORD
ScSetDependencyPointers(
    LPSERVICE_RECORD Service
    );

DWORD
ScResolveDependencyToService(
    LPSERVICE_RECORD Service
    );

VOID
ScUnresolveDependencyToService(
    LPSERVICE_RECORD Service
    );

DWORD
ScCreateDependencies(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Dependencies OPTIONAL
    );

VOID
ScDeleteStartDependencies(
    IN PSERVICE_RECORD ServiceRecord
    );

VOID
ScDeleteStopDependencies(
    IN PSERVICE_RECORD ServiceToBeDeleted
    );

DWORD
ScCreateGroupMembership(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Group OPTIONAL
    );

VOID
ScDeleteGroupMembership(
    IN OUT PSERVICE_RECORD ServiceRecord
    );

DWORD
ScCreateRegistryGroupPointer(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Group OPTIONAL
    );

VOID
ScDeleteRegistryGroupPointer(
    IN OUT PSERVICE_RECORD ServiceRecord
    );

VOID
ScGetUniqueTag(
    IN  LPWSTR GroupName,
    OUT LPDWORD Tag
    );

DWORD
ScUpdateServiceRecordConfig(
    LPSERVICE_RECORD    ServiceRecord,
    DWORD               dwServiceType,
    DWORD               dwStartType,
    DWORD               dwErrorControl,
    LPWSTR              lpLoadOrderGroup,
    LPBYTE              lpDependencies
    );

VOID
ScGetDependencySize(
    LPSERVICE_RECORD    ServiceRecord,
    LPDWORD             DependSize,
    LPDWORD             MaxDependSize
    );

DWORD
ScGetDependencyString(
    LPSERVICE_RECORD    ServiceRecord,
    DWORD               MaxDependSize,
    DWORD               DependSize,
    LPWSTR              lpDependencies
    );

BOOL
ScAllocateSRHeap(
    DWORD   HeapSize
    );

#if DBG
VOID
ScDumpGroups(
    VOID
    );

VOID
ScDumpServiceDependencies(
    VOID
    );
#endif  // if DBG

#endif // ifndef SCDATAMAN_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\groupman.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    groupman.cxx

Abstract:

    Contains code for the Group List Database manager.  This includes
    all the linked list routines.  This file contains the following
    functions:
        ScGetOrderGroupList
        ScGetStandaloneGroupList
        ScGetUnresolvedDependList
        ScGetNamedGroupRecord

        ScCreateOrderGroupEntry
        ScAllocateGroupEntry
        ScCreateGroupMembership
        ScDeleteGroupMembership
        ScCreateRegistryGroupPointer
        ScDeleteRegistryGroupPointer
        ScCreateStandaloneGroup
        ScDeleteStandaloneGroup

        ScGenerateDependencies
        ScSetDependencyPointers
        ScResolveDependencyToService
        ScCreateDependencies
        ScCreateUnresolvedDepend
        ScDeleteUnresolvedDepend
        ScCreateDependRecord
        ScDeleteStartDependencies
        ScDeleteStopDependencies
        ScSetServiceDependList
        ScGetUniqueTag
        ScCompareVector

        ScGetDependencySize
        ScGetDependencyString

        ScDumpGroups
        ScDumpServiceDependencies

Author:

    Dan Lafferty (danl)     04-Feb-1992

Environment:

    User Mode -Win32

Revision History:

    22-Oct-1993     danl
        Created by splitting these functions out of dataman.c because it was
        getting too large.

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <stdlib.h>      // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <ntrpcp.h>     // MIDL_user_allocate
#include <control.h>    // SendControl
#include "scconfig.h"   // ScGenerateServiceDB,ScInitSecurityProcess
#include "scsec.h"      // ScCreateScServiceObject
#include "account.h"    // ScRemoveAccount
#include <sclib.h>      // ScImagePathsMatch().
#include "bootcfg.h"    // ScDeleteRegTree().
#include <strarray.h>   // ScWStrArraySize

//
// Defines
//

// Names of specially treated groups
#define SC_GROUPNAME_TDI        L"TDI"
#define SC_GROUPNAME_PNP_TDI    L"PNP_TDI"

// A value that will not match any real pointer to a load order group
#define SC_INVALID_GROUP    ((LPLOAD_ORDER_GROUP)(DWORD_PTR) 0xFFFFFFFF)


//
// External Globals
//

    //
    // TDI GROUP SPECIAL:  The groups named TDI and PNP_TDI are treated
    // specially during dependency handling.  This is done by remembering a
    // pointer to each of those groups, if it occurs in the group order list,
    // and checking against the remembered pointers during dependency
    // handling.
    //

    LPLOAD_ORDER_GROUP  ScGlobalTDIGroup     = SC_INVALID_GROUP;
    LPLOAD_ORDER_GROUP  ScGlobalPNP_TDIGroup = SC_INVALID_GROUP;

//
//  Static Globals
//

    //
    // These are the linked list heads for each of the databases
    // that are maintained.
    //

    LOAD_ORDER_GROUP  OrderGroupList;       // empty header for doubly linked
    LOAD_ORDER_GROUP  StandaloneGroupList;  // empty header for doubly linked

    UNRESOLVED_DEPEND UnresolvedDependList; // empty header for doubly linked

//
// Local Function Prototypes
//

DWORD
ScAllocateOrderGroupEntry(
    OUT LPLOAD_ORDER_GROUP *NewGroup,
    IN  LPWSTR GroupName
    );

DWORD
ScCreateStandaloneGroup(
    IN  LPWSTR GroupName,
    OUT LPLOAD_ORDER_GROUP *GroupPointer
    );

VOID
ScDeleteStandaloneGroup(
    IN LPLOAD_ORDER_GROUP Group
    );

VOID
ScRememberSpecialGroup(
    IN  LPLOAD_ORDER_GROUP Group
    );

VOID
ScForgetSpecialGroup(
    IN  LPLOAD_ORDER_GROUP Group
    );

DWORD
ScCreateUnresolvedDepend(
   IN  LPWSTR Name,
   OUT LPUNRESOLVED_DEPEND *Unresolved
   );

VOID
ScDeleteUnresolvedDepend(
    IN OUT LPUNRESOLVED_DEPEND *Unresolved
    );

DWORD
ScSetServiceDependList(
    LPDEPEND_RECORD Start,
    LPSERVICE_RECORD ServiceRecord,
    PVOID DependOnRecord,
    DEPEND_TYPE DependOnType
    );

VOID
ScCompareVector(
    IN     LPDWORD TagArray,
    IN     DWORD TagArrayLength,
    IN OUT LPDWORD ReturnTagPtr
    );



//****************************************************************************/
// Miscellaneous Short Functions
//****************************************************************************/
LPLOAD_ORDER_GROUP
ScGetOrderGroupList(
    VOID
    )
{
    SC_ASSERT(ScGroupListLock.Have());
    return OrderGroupList.Next;
}

LPLOAD_ORDER_GROUP
ScGetStandaloneGroupList(
    VOID
    )
{
    SC_ASSERT(ScGroupListLock.Have());
    return StandaloneGroupList.Next;
}

LPUNRESOLVED_DEPEND
ScGetUnresolvedDependList(
    VOID
    )
{
    SC_ASSERT(ScGroupListLock.Have());
    return UnresolvedDependList.Next;
}

VOID
ScInitGroupDatabase(VOID)

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    OrderGroupList.Next = NULL;
    OrderGroupList.Prev = NULL;

    StandaloneGroupList.Next = NULL;
    StandaloneGroupList.Prev = NULL;

    UnresolvedDependList.Next = NULL;
    UnresolvedDependList.Prev = NULL;

}

VOID
ScEndGroupDatabase(VOID)

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    LPLOAD_ORDER_GROUP Group;
    LPLOAD_ORDER_GROUP Grp;

    SC_ASSERT(ScGroupListLock.HaveExclusive());

    Group = OrderGroupList.Next;

    while (Group != NULL) {

        Grp = Group;
        Group = Group->Next;

        REMOVE_FROM_LIST(Grp);
        LocalFree(Grp);
    }


}


DWORD
ScCreateOrderGroupEntry(
    IN  LPWSTR GroupName
    )
/*++

Routine Description:

    This function adds a group entry into the end of the load order group
    list.

Arguments:

    GroupName - Supplies the name of the load group.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a new
        group entry failed.

Note:

    The GroupListLock must be held exclusively prior to calling this function.

--*/
{
    DWORD status;
    LPLOAD_ORDER_GROUP NewGroup;
    LPLOAD_ORDER_GROUP GroupListPointer;

    SC_ASSERT(ScGroupListLock.HaveExclusive());

    if ((status = ScAllocateOrderGroupEntry(
                      &NewGroup,
                      GroupName
                      )) != NO_ERROR) {
        return status;
    }

    GroupListPointer = &OrderGroupList;

    //
    // Add the group entry to the group list at the end.
    //
    ADD_TO_LIST(GroupListPointer, NewGroup);

    SC_LOG(CONFIG, "ScCreateOrderGroupEntry: Added %ws to GroupList\n", GroupName);

    return NO_ERROR;
}


DWORD
ScAllocateOrderGroupEntry(
    OUT LPLOAD_ORDER_GROUP *NewGroup,
    IN  LPWSTR GroupName
    )
{

    //
    // Allocate memory for the new group.
    //
    *NewGroup = (LPLOAD_ORDER_GROUP)LocalAlloc(
                    LMEM_ZEROINIT,
                    WCSSIZE(GroupName) + sizeof(LOAD_ORDER_GROUP)
                    );

    if (*NewGroup == NULL) {
        SC_LOG(ERROR,"ScAllocateOrderGroupEntry: LocalAlloc failure %ld\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Save away the GroupName
    //
    (*NewGroup)->GroupName = (LPWSTR) ((LPBYTE) (*NewGroup) + sizeof(LOAD_ORDER_GROUP));
    wcscpy((*NewGroup)->GroupName, GroupName);

    ScRememberSpecialGroup(*NewGroup);

    //
    // Set the RefCount field to 0xffffffff so that we can differentiate an
    // order group from a standalone group.  This field actually indicates
    // the number of members in a group and dependency references to it if
    // the group is standalone so that we can delete the standalone group
    // when it goes to 0.
    //
    (*NewGroup)->RefCount = MAXULONG;

    return NO_ERROR;
}


DWORD
ScCreateGroupMembership(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Group OPTIONAL
    )
/*++

Routine Description:

    This function assigns the load order group membership information
    of the service to its specified service record.  If the service
    belongs to a group in OrderGroupList, a pointer to the group in the load
    order group list is saved.  If the service belongs to a group which
    is not in the load order group list, the name of the group is saved
    in the service record in case the group gets added to the load order
    group list later.  If Group is not specified, no group membership
    information is saved.

Arguments:

    ServiceRecord - Receives the group membership information in this service
        record.

    Group - Supplies the string which contains the name of the group.  This
        is the raw string read from the registry which may contain blank,
        tab or newline characters which we should ignore.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a group name
        failed.

Note:

    This routine assumes that the database lock is already held.  It is
    called by ScAddConfigInfoServiceRecord.

    It also assumes that the caller has exclusive access to the group
    list lock.

--*/
{
    DWORD status;
    LPWSTR GroupPtr = Group;
    LPWSTR GroupName;
    PLOAD_ORDER_GROUP GroupEntry = ScGetOrderGroupList();

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    // Extract the group name from the string read in from the registry.
    //
    if ((! ARGUMENT_PRESENT(GroupPtr)) || (! ScGetToken(&GroupPtr, &GroupName))) {
        ServiceRecord->MemberOfGroup = (PLOAD_ORDER_GROUP) NULL;
        return NO_ERROR;
    }

    //
    // Search for matching group name in load order list
    //
    while (GroupEntry != NULL) {
        if (_wcsicmp(GroupEntry->GroupName, GroupName) == 0) {
            ServiceRecord->MemberOfGroup = GroupEntry;
            return NO_ERROR;
        }
        GroupEntry = GroupEntry->Next;
    }

    //
    // Group name not NULL, and not found in load order group list.
    // Group is a standalone group.
    //
    status = ScCreateStandaloneGroup(
                 GroupName,
                 &(ServiceRecord->MemberOfGroup)
                 );

    if (status != NO_ERROR) {
        return status;
    }

    return NO_ERROR;
}


VOID
ScDeleteGroupMembership(
    IN OUT PSERVICE_RECORD ServiceRecord
    )
/*++

Routine Description:

    This function deletes any memory allocated for group membership
    association.

Arguments:

    ServiceRecord - Supplies the group membership information in this
        service record.

Return Value:

    None.

Note:

    This routine assumes that the database lock is already held.  It is
    called by ScAddConfigInfoServiceRecord and ScDecrementUseCountAndDelete.

    It also assumes that the group list lock is held exclusively.

--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ServiceRecord->MemberOfGroup != NULL &&
        ServiceRecord->MemberOfGroup->RefCount != MAXULONG) {
        ScDeleteStandaloneGroup(ServiceRecord->MemberOfGroup);
    }

    ServiceRecord->MemberOfGroup = NULL;
}


DWORD
ScCreateRegistryGroupPointer(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Group OPTIONAL
    )
/*++

Routine Description:

    This function assigns the load order group RegistryGroup
    information in the service record to match the load order group
    stored in the registry, which is not the same as MemberOfGroup
    information if the load order group of the service is changed
    while the service is running.  However, we need to know what the
    resultant load order group of the service is when it stops so
    that when we can guarantee uniqueness of a tag based on all
    members the group.

    This function does exactly the same thing as the
    ScCreateGroupMembership function but alters the RegistryGroup
    pointer instead of the MemberOfGroup pointer in the service
    record.

Arguments:

    ServiceRecord - Receives the group membership information in this service
        record.

    Group - Supplies the string which contains the name of the group.  This
        is the raw string read from the registry which may contain blank,
        tab or newline characters which we should ignore.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a group name
        failed.

Note:

    This routine assumes that the database lock is already held.  It is
    called by ScAddConfigInfoServiceRecord.

    It also assumes that the caller has exclusive access to the group
    list lock.

--*/
{
    DWORD status;
    LPWSTR GroupPtr = Group;
    LPWSTR GroupName;
    PLOAD_ORDER_GROUP GroupEntry = ScGetOrderGroupList();

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());


    //
    // Extract the group name from the string read in from the registry.
    //
    if ((! ARGUMENT_PRESENT(GroupPtr)) || (! ScGetToken(&GroupPtr, &GroupName))) {
        ServiceRecord->RegistryGroup = (PLOAD_ORDER_GROUP) NULL;
        return NO_ERROR;
    }

    //
    // Search for matching group name in load order list
    //
    while (GroupEntry != NULL) {
        if (_wcsicmp(GroupEntry->GroupName, GroupName) == 0) {
            ServiceRecord->RegistryGroup = GroupEntry;
            return NO_ERROR;
        }
        GroupEntry = GroupEntry->Next;
    }

    //
    // Group name not NULL, and not found in load order group list.
    // Group is a standalone group.
    //
    status = ScCreateStandaloneGroup(
                 GroupName,
                 &(ServiceRecord->RegistryGroup)
                 );

    if (status != NO_ERROR) {
        return status;
    }

    return NO_ERROR;
}


VOID
ScDeleteRegistryGroupPointer(
    IN OUT PSERVICE_RECORD ServiceRecord
    )
/*++

Routine Description:

    This function deletes any memory allocated for registry group
    association.

Arguments:

    ServiceRecord - Supplies the registry group information in this
        service record.

Return Value:

    None.

Note:

    This routine assumes that the database lock is already held.  It is
    called by ScAddConfigInfoServiceRecord and ScDecrementUseCountAndDelete.

    It also assumes that the group list lock is held exclusively.

--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ServiceRecord->RegistryGroup != NULL &&
        ServiceRecord->RegistryGroup->RefCount != MAXULONG) {
        ScDeleteStandaloneGroup(ServiceRecord->RegistryGroup);
    }

    ServiceRecord->RegistryGroup = NULL;
}


DWORD
ScCreateStandaloneGroup(
    IN LPWSTR GroupName,
    OUT LPLOAD_ORDER_GROUP *GroupPointer
    )
/*++

Routine Description:

    This function looks for a matching standalone group entry in the
    standalone group list.  If a match is found, the reference count is
    incremented and the pointer to the matching entry is returned.

    If no matching entry is found, this function creates a new standalone
    group entry, insert it into the end of the standalone group list, and
    return a pointer to the new entry.


Arguments:

    Name - Supplies the name of the group which is not in the
        ServiceOrderList.

    GroupPointer - Receives a pointer to the unresolved entry.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Allocation of memory failed.

Note:

    This routine assumes that the caller has exclusively acquired the
    group list lock.  It is called by ScCreateGroupMembership.

--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    LPLOAD_ORDER_GROUP Group = ScGetStandaloneGroupList();

    BOOL Found = FALSE;


    //
    // Search the existing standalone group list for the matching
    // standalone group entry.
    //
    while (Group != NULL) {

        if (_wcsicmp(Group->GroupName, GroupName) == 0) {
            Found = TRUE;
            break;
        }

        Group = Group->Next;
    }

    if (Found) {

        Group->RefCount++;

        SC_LOG2(DEPEND_DUMP,
            "Found existing group entry for " FORMAT_LPWSTR
            ", just increment refcount to %lu\n", Group->GroupName,
            Group->RefCount);

        *GroupPointer = Group;

        return NO_ERROR;
    }

    //
    // Not found.  Allocate a new group entry.
    //
    if ((*GroupPointer = (LPLOAD_ORDER_GROUP)LocalAlloc(
                             LMEM_ZEROINIT,
                             sizeof(LOAD_ORDER_GROUP) + WCSSIZE(GroupName)
                             )) == NULL) {
        SC_LOG(ERROR,"ScCreateStandaloneGroup: LocalAlloc failure %lu\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    (*GroupPointer)->GroupName = (LPWSTR) ((DWORD_PTR) *GroupPointer +
                                    sizeof(LOAD_ORDER_GROUP));
    wcscpy((*GroupPointer)->GroupName, GroupName);

    (*GroupPointer)->RefCount = 1;

    SC_LOG1(DEPEND_DUMP, "Created new standalone group entry "
            FORMAT_LPWSTR "\n", (*GroupPointer)->GroupName);

    ScRememberSpecialGroup(*GroupPointer);

    Group = &StandaloneGroupList;

    //
    // Add the new group entry to the standalone group list at the end.
    //
    ADD_TO_LIST(Group, *GroupPointer);

    return NO_ERROR;
}


VOID
ScDeleteStandaloneGroup(
    IN LPLOAD_ORDER_GROUP Group
    )
{
    if (Group->RefCount) {
        Group->RefCount--;

        SC_LOG1(DEPEND, "DeleteStandaloneGroup: Subtracted RefCount is "
                FORMAT_DWORD "\n", Group->RefCount);
    }
    else {
        SC_LOG0(ERROR, "ScDeleteStandaloneGroup: Before delete, refcount is 0!\n");
        SC_ASSERT(FALSE);
    }

    if (Group->RefCount == 0) {

        SC_LOG1(DEPEND, "Deleting standalone group " FORMAT_LPWSTR "\n",
                Group->GroupName);

        REMOVE_FROM_LIST(Group);

        ScForgetSpecialGroup(Group);

        LocalFree(Group);
    }
}



VOID
ScRememberSpecialGroup(
    IN  LPLOAD_ORDER_GROUP Group
    )

/*++

Routine Description:

    Compares the group name against a set of known group names to see if it
    is a group that requires special handling, and if so, saves the pointer
    to the group in a global variable.


Arguments:


Return Value:


--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    // CODEWORK:  If the number of special groups keeps growing, do this
    // in a table-driven way!

    if (_wcsicmp(Group->GroupName, SC_GROUPNAME_TDI) == 0)
    {
        if (ScGlobalTDIGroup != SC_INVALID_GROUP)
        {
            SC_LOG0(ERROR, "Warning: TDI group occurs more than once in load order group list\n");
        }
        ScGlobalTDIGroup = Group;
    }
    else if (_wcsicmp(Group->GroupName, SC_GROUPNAME_PNP_TDI) == 0)
    {
        if (ScGlobalPNP_TDIGroup != SC_INVALID_GROUP)
        {
            SC_LOG0(ERROR, "Warning: PNP_TDI group occurs more than once in load order group list\n");
        }
        ScGlobalPNP_TDIGroup = Group;
    }
}


VOID
ScForgetSpecialGroup(
    IN  LPLOAD_ORDER_GROUP Group
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    if (Group == ScGlobalTDIGroup)
    {
        ScGlobalTDIGroup = SC_INVALID_GROUP;
    }
    else if (Group == ScGlobalPNP_TDIGroup)
    {
        ScGlobalPNP_TDIGroup = SC_INVALID_GROUP;
    }
}



VOID
ScGenerateDependencies(
    VOID
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

    The GroupListLock must be held exclusively prior to calling this routine.


--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    FOR_ALL_SERVICES(Service)
    {
        (void) ScSetDependencyPointers(Service);
    }
}


DWORD
ScSetDependencyPointers(
    IN LPSERVICE_RECORD Service
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

    The GroupListLock must be held exclusively prior to calling this routine.


--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    DWORD status;

    if (Service->Dependencies != NULL) {

        status = ScCreateDependencies(
                     Service,
                     Service->Dependencies
                     );

        if (status == NO_ERROR) {
            LocalFree(Service->Dependencies);
            Service->Dependencies = NULL;
        }

        return status;
    }

    return NO_ERROR;
}


DWORD
ScResolveDependencyToService(
    LPSERVICE_RECORD DependOnService
    )
/*++

Routine Description:

    This function resolves all dependencies to the service we are
    currently installing via CreateService.  The start depend entry
    of these services will point to the service record of the service
    we are installing instead of the unresolved depend record.  A
    stop depend entry is created for the service we are installing to
    point back to every service that depends on it.

Arguments:

    DependOnService - Supplies a pointer to the service we are installing
        via CreateService which other services may depend on.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Fail to allocate memory for required data
        structures.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by RCreateServiceW.

--*/
{
    SC_ASSERT(ScGroupListLock.Have());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    DWORD status;
    LPUNRESOLVED_DEPEND UnresolvedEntry = ScGetUnresolvedDependList();


    //
    // Search the unresolved depend list for a matching entry
    //
    while (UnresolvedEntry != NULL) {

        if (_wcsicmp(UnresolvedEntry->Name, DependOnService->ServiceName) == 0) {
            SC_LOG1(DEPEND, "Found unresolved entry for " FORMAT_LPWSTR "\n",
                    DependOnService->ServiceName);
            break;
        }

        UnresolvedEntry = UnresolvedEntry->Next;
    }

    if (UnresolvedEntry == NULL) {
        //
        // There are no service which depends on the service we are
        // installing; hence, no unresolved dependency to resolve.
        //
        SC_LOG1(DEPEND, "No service depends on " FORMAT_LPWSTR "\n",
                DependOnService->ServiceName);
        return NO_ERROR;
    }


    //
    // Loop through all services to see if any of them has a start depend
    // entry that points to UnresolvedEntry.
    //
    FOR_ALL_SERVICES(Service)
    {
        if (UnresolvedEntry == NULL)
        {
            break;
        }

        for (LPDEPEND_RECORD Start = Service->StartDepend;
             Start != NULL;
             Start = Start->Next)
        {
            if (Start->DependUnresolved == UnresolvedEntry)
            {
                status = ScSetServiceDependList(
                             Start,
                             Service,
                             (PVOID)DependOnService,
                             TypeDependOnService
                             );

                if (status != NO_ERROR)
                {
                    //
                    // Error with creating the stop depend entry for
                    // DependOnService.  Back out changes set for the
                    // current start depend entry.
                    //
                    Start->DependType = TypeDependOnUnresolved;
                    Start->DependUnresolved = UnresolvedEntry;

                    //
                    // Back out of all other resolved dependencies to
                    // DependOnService will be done in ScDecrementUseCountAndDelete.
                    //
                    SC_LOG2(ERROR, "ScResolvedDependencyToService " FORMAT_LPWSTR
                            " failed " FORMAT_DWORD "\n",
                            DependOnService->ServiceName, status);
                    return status;
                }

                SC_LOG2(DEPEND, FORMAT_LPWSTR " depends on " FORMAT_LPWSTR
                        ".  Dependency resolved!\n", Service->ServiceName,
                        UnresolvedEntry->Name);

                ScDeleteUnresolvedDepend(&UnresolvedEntry);
            }
        }
    }

    return NO_ERROR;
}


DWORD
ScCreateDependencies(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Dependencies OPTIONAL
    )
/*++

Routine Description:

    This function creates the start dependencies list of a service.
    If the service specified by ServiceRecord depends on a service that
    has not been inserted into the service list yet, that service entry
    will be created and inserted into the service list so that the depend
    record can point to it.  The service this one points to in its start
    dependency list will get a new entry in its stop dependency list because
    this one must be stopped before it can stop.

    The dependencies list is not ordered.

    NOTE: This function is for call from RChangeServiceConfig.

Arguments:

    ServiceRecord - Receives the start dependencies information in this
        service record.

    Dependencies - Supplies the string which contains the names this service
        depend on to be started first.  This is a multi-sz string of
        service or group names.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Fail to allocate memory for required data
        structures.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScSetDependencyPointers.

    It also assumes that the caller has exclusively acquired the group
    list lock.

--*/
{
    DWORD status;

    LPWSTR DependPtr = Dependencies;
    LPWSTR DependOnName;
    PVOID DependOnRecord = NULL;
    DEPEND_TYPE Type;

    PDEPEND_RECORD Start;

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (! ARGUMENT_PRESENT(DependPtr)) {
        return NO_ERROR;
    }

    while (*DependPtr != 0) {

        if (ScGetToken(&DependPtr, &DependOnName)) {

            //
            // Initialize flag for noting that a new service record is
            // created for resolving the dependency chain.
            //
            Type = TypeNone;

            if (*DependOnName != SC_GROUP_IDENTIFIERW) {

                //
                // Depend on a service
                //

                //
                // Look for the service we depend on in the service record list
                //
                status = ScGetNamedServiceRecord(
                             DependOnName,
                             (LPSERVICE_RECORD *) &DependOnRecord
                             );

                if (status == ERROR_SERVICE_DOES_NOT_EXIST) {

                    //
                    // Could not find the service we depend on.  Create an
                    // unresolved dependency entry.
                    //
                    status = ScCreateUnresolvedDepend(
                                DependOnName,
                                (PUNRESOLVED_DEPEND *) &DependOnRecord
                                );

                    if (status != NO_ERROR) {
                        goto ErrorExit;
                    }

                    //
                    // New unresolved depend entry created.  We have to remove
                    // it if any error occurs later.
                    //
                    Type = TypeDependOnUnresolved;

                }
                else {

                    Type = TypeDependOnService;
                }

                if (status != NO_ERROR) {
                    goto ErrorExit;
                }
            }
            else {

                //
                // Depend on a group
                //

                PLOAD_ORDER_GROUP GroupEntry = ScGetOrderGroupList();

                DependOnName++;

                //
                // Search for matching group name in load order list
                //
                while (GroupEntry != NULL) {
                    if (_wcsicmp(GroupEntry->GroupName, DependOnName) == 0) {
                        DependOnRecord = (PVOID) GroupEntry;
                        Type = TypeDependOnGroup;
                        break;
                    }
                    GroupEntry = GroupEntry->Next;
                }

                if (GroupEntry == NULL) {
                    //
                    // Could not find group in the OrderGroup list.  Must
                    // depend on a standalone group.
                    //
                    status = ScCreateStandaloneGroup(
                                 DependOnName,
                                 (LPLOAD_ORDER_GROUP *) &DependOnRecord
                                 );

                    if (status != NO_ERROR) {
                        goto ErrorExit;
                    }

                    Type = TypeDependOnGroup;
                }
            }

            //
            // Allocate memory for start depend record and insert it in the
            // front of the start depend list of the service we are processing.
            //
            if ((status = ScCreateDependRecord(
                              TRUE,              // For start list
                              ServiceRecord,
                              &Start
                              )) != NO_ERROR) {

                goto ErrorExit;
            }

            //
            // Start depend record created OK, set fields.  Set stop
            // depend if appropriate (Type == TypeDependOnService).
            //
            status = ScSetServiceDependList(
                         Start,
                         ServiceRecord,
                         DependOnRecord,
                         Type
                         );

            if (status != NO_ERROR) {

                //
                // Remove the start depend record just created in the front of
                // the start depend list and delete it.
                //
                ServiceRecord->StartDepend = Start->Next;
                LocalFree(Start);

                goto ErrorExit;
            }

        } // if got token

    }  // while there is a dependency

    return NO_ERROR;

ErrorExit:

    //
    // Remove newly created service record because of errors and we cannot
    // proceed.
    //
    if (Type == TypeDependOnUnresolved) {

        ScDeleteUnresolvedDepend((PUNRESOLVED_DEPEND *) &DependOnRecord);
    }

    //
    // Clean up dependencies created up to the point of failure
    //
    ScDeleteStartDependencies(ServiceRecord);

    return status;
}


DWORD
ScCreateUnresolvedDepend(
   IN LPWSTR Name,
   OUT LPUNRESOLVED_DEPEND *Unresolved
   )
/*++

Routine Description:

    This function looks for a matching unresolved entry in the unresolved
    depend list.  If a match is found, the reference count is incremented
    and the pointer to the matching entry is returned.

    If no matching entry is found, this function creates a new unresolved
    entry, insert it into the end of the unresolved depend list, and
    return a pointer to the new entry.


Arguments:

    Name - Supplies the name of the service or group which has not been
        installed yet, and thus needing this unresolved depend entry.

    Unresolved - Receives a pointer to the unresolved entry.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Allocation of memory failed.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScCreateDependencies.

--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    LPUNRESOLVED_DEPEND UnresolvedList = ScGetUnresolvedDependList();

    BOOL Found = FALSE;


    //
    // Search the existing unresolved depend list for the matching
    // unresolved depend entry.
    //
    while (UnresolvedList != NULL) {

        if (_wcsicmp(UnresolvedList->Name, Name) == 0) {
            Found = TRUE;
            break;
        }

        UnresolvedList = UnresolvedList->Next;
    }

    if (Found) {

        UnresolvedList->RefCount++;

        SC_LOG2(DEPEND,
            "Found existing unresolved entry for " FORMAT_LPWSTR
            ", just increment refcount to %lu\n", UnresolvedList->Name,
            UnresolvedList->RefCount);

        *Unresolved = UnresolvedList;

        return NO_ERROR;
    }

    //
    // Not found.  Allocate a new unresolved entry.
    //
    if ((*Unresolved = (LPUNRESOLVED_DEPEND)LocalAlloc(
                             LMEM_ZEROINIT,
                             sizeof(UNRESOLVED_DEPEND) + WCSSIZE(Name)
                             )) == NULL) {
        SC_LOG1(ERROR,"ScCreateUnresolvedDepend: LocalAlloc failure %lu\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    (*Unresolved)->Name = (LPWSTR) ((DWORD_PTR) *Unresolved +
                                    sizeof(UNRESOLVED_DEPEND));
    wcscpy((*Unresolved)->Name, Name);

    (*Unresolved)->RefCount = 1;

    SC_LOG1(DEPEND, "Created new unresolved depend entry "
            FORMAT_LPWSTR "\n", (*Unresolved)->Name);

    UnresolvedList = &UnresolvedDependList;

    //
    // Add the new unresolved entry to the unresolved list at the end.
    //
    ADD_TO_LIST(UnresolvedList, *Unresolved);

    return NO_ERROR;
}


VOID
ScDeleteUnresolvedDepend(
    IN OUT LPUNRESOLVED_DEPEND *Unresolved
    )
{

    if ((*Unresolved)->RefCount) {
        (*Unresolved)->RefCount--;
        SC_LOG1(DEPEND, "ScDeleteUnresolvedDepend: Subtracted RefCount is "
                FORMAT_DWORD "\n", (*Unresolved)->RefCount);
    }
    else {
        //
        // The reference count better not be 0.
        //
        SC_LOG0(ERROR, "ScDeleteUnresolvedDepend: Before delete, refcount is 0!\n");
        SC_ASSERT(FALSE);
    }

    if ((*Unresolved)->RefCount == 0) {
        REMOVE_FROM_LIST(*Unresolved);
        LocalFree(*Unresolved);
        *Unresolved = NULL;
    }
}


DWORD
ScCreateDependRecord(
    IN  BOOL IsStartList,
    IN  OUT PSERVICE_RECORD ServiceRecord,
    OUT PDEPEND_RECORD *DependRecord
    )
/*++

Routine Description:

    This function allocates the memory for a depend record, and insert
    it into the front of the specific depend list.  If IsStartList is
    TRUE, the depend record goes into the start depend list of
    ServiceRecord, otherwise the depend record goes into the stop
    depend list of the ServiceRecord.

Arguments:

    IsStartList - TRUE indicates to insert into start list, FALSE indicates
        to insert into stop list.

    ServiceRecord - Receives the start/stop depend record in its dependency
        list.

    DependRecord - Receives a pointer to the new depend record created.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a depend
        record failed.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScCreateDependencies.

--*/
{
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if ((*DependRecord = (PDEPEND_RECORD)LocalAlloc(
                             LMEM_ZEROINIT,
                             sizeof(DEPEND_RECORD)
                             )) == NULL) {
        SC_LOG(ERROR,"ScCreateDependRecord: LocalAlloc failure %ld\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Insert the depend record into the front of the list
    //
    if (IsStartList) {
        //
        // Start depend
        //
        (*DependRecord)->Next = ServiceRecord->StartDepend;
        ServiceRecord->StartDepend = *DependRecord;
    }
    else {
        //
        // Stop depend
        //
        (*DependRecord)->Next = ServiceRecord->StopDepend;
        ServiceRecord->StopDepend = *DependRecord;
    }

    return NO_ERROR;
}


VOID
ScDeleteStartDependencies(
    IN PSERVICE_RECORD ServiceRecord
    )
/*++

Routine Description:

    This function deletes the start dependencies list of a service.  It also
    deletes the the stop dependencies of other services which need this
    service to be stopped first.

    NOTE: This function is for call from RChangeServiceConfig.

Arguments:

    ServiceRecord - Supplies the start dependencies information in this
        service record.

Return Value:

    None.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScAddConfigInfoServiceRecord and
    ScDecrementUseCountAndDelete.

    It also assumes that the caller has exclusively acquired the group
    list lock.

--*/
{
    PDEPEND_RECORD StartEntry;
    PDEPEND_RECORD StopEntry;
    PDEPEND_RECORD StopBackPointer;

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    StartEntry = ServiceRecord->StartDepend;

    while (StartEntry != NULL) {

        if (StartEntry->DependType == TypeDependOnService) {

            LPSERVICE_RECORD DependencyService = StartEntry->DependService;


            //
            // Find the stop depend record for the service which depends on this
            // service to be stopped first, and delete it.
            //
            StopEntry = DependencyService->StopDepend;
            StopBackPointer = StopEntry;

            while ((StopEntry != NULL) &&
                   (StopEntry->DependService != ServiceRecord)) {

                StopBackPointer = StopEntry;
                StopEntry = StopEntry->Next;
            }

            if (StopEntry == NULL) {
#ifndef _CAIRO_
                //
                // We allow Netlogon to appear in the start dependency list, but
                // not in the stop dependency list.  This is for the case where
                // we add a "soft" dependency on netlogon because the service runs
                // in a remove account.
                //
                if (_wcsicmp(DependencyService->ServiceName,L"Netlogon") != 0) {
#endif // _CAIRO_
                    SC_LOG1(ERROR,
                            "ScDeleteStartDependencies: Failed to find matching stop depend node for "
                            FORMAT_LPWSTR "\n",
                            DependencyService->ServiceName);
                    SC_ASSERT(FALSE);
                    return;
#ifndef _CAIRO_
                }
#endif // _CAIRO_
            }
            else {

                if (StopEntry->DependService == ServiceRecord) {

                    if ((PVOID) StopBackPointer == StopEntry) {
                        //
                        // Unchaining from the front of the list
                        //
                        DependencyService->StopDepend = StopEntry->Next;
                    }
                    else {
                        //
                        // Unchaining from the middle or end of the list
                        //
                        StopBackPointer->Next = StopEntry->Next;
                    }

                    LocalFree(StopEntry);
                }
            }
        }
        else if (StartEntry->DependType == TypeDependOnGroup) {

            //
            // Decrement the reference count on the standalone group
            // entry and deletes it if 0.
            //
            if (StartEntry->DependGroup->RefCount != MAXULONG) {
                ScDeleteStandaloneGroup(StartEntry->DependGroup);
            }

        }
        else {

            //
            // Dependency type is unresolved.
            //
            ScDeleteUnresolvedDepend(&StartEntry->DependUnresolved);
        }

        //
        // Now delete the start depend record.
        //
        ServiceRecord->StartDepend = StartEntry->Next;
        LocalFree(StartEntry);
        StartEntry = ServiceRecord->StartDepend;
    }
}


VOID
ScDeleteStopDependencies(
    IN PSERVICE_RECORD ServiceToBeDeleted
    )
/*++

Routine Description:

    This function deletes the stop dependencies list of a service.  For
    every stop depend service, it makes the start depend pointer of that
    service to point to an unresolved depend entry.

    This function is called when the service is to be deleted.

Arguments:

    ServiceToBeDeleted - Supplies the pointer to the service that will
        be deleted.

Return Value:

    None.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScDecrementUseCountAndDelete.

--*/
{

    DWORD status;
    PDEPEND_RECORD StartEntry;
    PDEPEND_RECORD StopEntry;
    LPUNRESOLVED_DEPEND Unresolved;

    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    StopEntry = ServiceToBeDeleted->StopDepend;

    while (StopEntry != NULL) {

        LPSERVICE_RECORD DependencyService = StopEntry->DependService;

        //
        // Loop through the start depend entries of the service which
        // depends on ServiceToBeDeleted.
        //
        StartEntry = DependencyService->StartDepend;

        while (StartEntry != NULL) {

            if (StartEntry->DependService == ServiceToBeDeleted) {
                break;
            }

            StartEntry = StartEntry->Next;
        }

        if (StartEntry != NULL) {

            //
            // Found a start depend entry that points to the service to be.
            // deleted.  Make it point to an unresolved depend entry that
            // represents that service.
            //
            status = ScCreateUnresolvedDepend(
                         ServiceToBeDeleted->ServiceName,
                         &Unresolved
                         );

            if (status == NO_ERROR) {
                StartEntry->DependType = TypeDependOnUnresolved;
                StartEntry->DependUnresolved = Unresolved;
            }
        }

        //
        // Now delete the start depend record.
        //
        ServiceToBeDeleted->StopDepend = StopEntry->Next;
        LocalFree(StopEntry);
        StopEntry = ServiceToBeDeleted->StopDepend;
    }
}


DWORD
ScSetServiceDependList(
    LPDEPEND_RECORD Start,
    LPSERVICE_RECORD ServiceRecord,
    PVOID DependOnRecord,
    DEPEND_TYPE DependOnType
    )
/*++

Routine Description:

    This function

Arguments:

Return Value:

    None.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScResolveDependencyToService and
    ScCreateDependencies.

--*/
{
    DWORD status;
    LPDEPEND_RECORD Stop;

    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    // Set fields for start depend entry.
    //
    Start->DependType = DependOnType;
    Start->Depend = DependOnRecord;

    if (DependOnType == TypeDependOnService) {

        //
        // Allocate memory for stop depend record and insert it in the
        // front of the stop depend list of the service we depend on.
        //
        if ((status = ScCreateDependRecord(
                          FALSE,             // For stop list
                          (LPSERVICE_RECORD) DependOnRecord,
                          &Stop
                          )) != NO_ERROR) {

            return status;
        }

        Stop->DependType = TypeDependOnService;
        Stop->DependService = ServiceRecord;
    }

    return NO_ERROR;
}


LPLOAD_ORDER_GROUP
ScGetNamedGroupRecord(
    IN LPCWSTR GroupName
    )
/*++

Routine Description:

    This function searches for a named group, first in the order group
    list and next in the standalone group list.

Arguments:

    GroupName - Supplies the name of the group to look for.

Return Value:

    Returns the pointer to group found.  If not found, this value is
        NULL.

Note:

    This routine assumes that the caller has exclusively acquired the
    group list lock.

--*/
{
    LPLOAD_ORDER_GROUP Group;

    for (Group = ScGetOrderGroupList();
         Group != NULL;
         Group = Group->Next)
    {
        if (_wcsicmp(Group->GroupName, GroupName) == 0)
        {
            break;
        }
    }

    if (Group == NULL)
    {
        for (Group = ScGetStandaloneGroupList();
             Group != NULL;
             Group = Group->Next)
        {
            if (_wcsicmp(Group->GroupName, GroupName) == 0)
            {
                break;
            }
        }
    }

    return Group;
}


VOID
ScGetUniqueTag(
    IN  LPWSTR GroupName,
    OUT LPDWORD Tag
    )
/*++

Routine Description:

    This function looks for a unique tag value within the specified
    group.

Arguments:

    GroupName - Specifies the group name within which the value tag
        returned must be unique.

    Tag - Receives the unique tag value.

Return Value:

    None.

Note:

    This function acquires share access to the group list lock.

    It assumes that the exclusive service database lock is already
    acquired so that no other caller can execute this code until
    the returned tag is fully assigned to the service, and that the
    service entries in the database list don't change.

    The GroupListLock must be held exclusively prior to calling this
    function.

--*/
{
    LPDWORD TagArray;
    DWORD TagArrayLength;

    DWORD ReturnTag = 1;

    LPLOAD_ORDER_GROUP Group;

    SC_ASSERT(ScGroupListLock.Have());
    SC_ASSERT(ScServiceRecordLock.Have());

    if (ScGetGroupVector(
            GroupName,
            (LPBYTE *) &TagArray,
            &TagArrayLength
            ) == NO_ERROR) {

        if (TagArray != NULL) {
            //
            // The returned values is actually the number of bytes.  Divide it
            // by size of DWORD to make it the number of array entries.
            //
            TagArrayLength = TagArrayLength / sizeof(DWORD);

            SC_ASSERT((TagArrayLength - 1) == TagArray[0]);

            ScCompareVector(
                TagArray,
                TagArrayLength,
                &ReturnTag
                );
        }
    }
    else {

        TagArray = NULL;
    }

    Group = ScGetNamedGroupRecord(GroupName);

    if (Group != NULL) {

GroupAgain:
        FOR_ALL_SERVICES(Service) {

            if ((Service->RegistryGroup == Group) &&
                (Service->Tag == ReturnTag)) {

                ReturnTag++;

                if (TagArray != NULL) {

                    ScCompareVector(
                        TagArray,
                        TagArrayLength,
                        &ReturnTag
                        );
                }

                goto GroupAgain;
            }
        } // while all services
    }


    *Tag = ReturnTag;

    SC_LOG(DEPEND, "ScGetUniqueTag: Tag=" FORMAT_DWORD "\n", *Tag);

}


VOID
ScCompareVector(
    IN     LPDWORD TagArray,
    IN     DWORD TagArrayLength,
    IN OUT LPDWORD ReturnTagPtr
    )
{
    DWORD i;

VectorAgain:
    for (i = 1; i < TagArrayLength; i++) {

        if (TagArray[i] == (*ReturnTagPtr)) {

            SC_LOG(DEPEND_DUMP, "Tag " FORMAT_DWORD " is not unique\n",
                   *ReturnTagPtr);

            (*ReturnTagPtr)++;
            goto VectorAgain;
        }
    }
}

VOID
ScGetDependencySize(
    LPSERVICE_RECORD    ServiceRecord,
    LPDWORD             DependSize,
    LPDWORD             MaxDependSize
    )

/*++

Routine Description:



Arguments:

    ServiceRecord -

    DependSize - This points to a location that will contain the number
        of bytes required for the list of dependency strings.

    MaxDependSize - This points to a location that will contain the
        number of bytes in the longest dependency string in the set.

Return Value:



--*/
{
    LPDEPEND_RECORD     dependRecord;
    DWORD               bytesNeeded = 0;
    DWORD               StrSize=0;

    dependRecord = ServiceRecord->StartDepend;

    //
    // NOTE: Dependencies are expected to be a double NULL terminated
    //       terminated set of strings.
    //
    bytesNeeded += sizeof(WCHAR);

    if (dependRecord == NULL) {
        bytesNeeded += sizeof(WCHAR);
    }
    while (dependRecord != NULL) {

        SC_ASSERT( dependRecord->Depend != NULL );

        // Add room.  WCSSIZE adds 1 char.  For final entry,  we'll
        // use null char.  In between, we'll put some separator.

        if (dependRecord->DependType == TypeDependOnService) {
            StrSize =
                (DWORD) WCSSIZE(dependRecord->DependService->ServiceName); // sizes...

        }
        else if (dependRecord->DependType == TypeDependOnGroup) {
            StrSize =
               (DWORD) WCSSIZE(dependRecord->DependGroup->GroupName) +
               sizeof(WCHAR); // name size plus SC_GROUP_IDENTIFIERW
        }
        else {
            //
            // Unresolved service dependency
            //
            StrSize = (DWORD) WCSSIZE(dependRecord->DependUnresolved->Name);
        }

        bytesNeeded += StrSize;

        if (StrSize > *MaxDependSize) {
            *MaxDependSize = StrSize;
        }

        dependRecord = dependRecord->Next;
    }
    *DependSize = bytesNeeded;
}

DWORD
ScGetDependencyString(
    LPSERVICE_RECORD    ServiceRecord,
    DWORD               MaxDependSize,
    DWORD               DependSize,
    LPWSTR              lpDependencies
    )

/*++

Routine Description:



Arguments:

    ServiceRecord -

    MaxDependSize - This is the size of the largest string in the
        dependency list.

    lpDependencies - This is a pointer to the location where the
        list of dependency strings is to be stored.

Return Value:



--*/
{
    LPWSTR          endOfVariableData;
    LPWSTR          fixedDataEnd;
    LPDEPEND_RECORD dependRecord;
    DWORD           bufSize;
    DWORD           ApiStatus = NO_ERROR;

    //
    // Put dependencies in the return buffer.  Since it is a NULL-NULL
    // string, put an extra NULL at the end to begin with.
    //
    endOfVariableData = (LPWSTR) (((LPBYTE)lpDependencies) + DependSize);

    endOfVariableData = endOfVariableData - 1;
    * endOfVariableData = L'\0';

    fixedDataEnd = lpDependencies;

    dependRecord = ServiceRecord->StartDepend;

    if (dependRecord == NULL) {
        //
        // If there are no dependencies, then we need to add a separator
        // that will be followed by the NULL (immediately above).
        // This separator is used to get us across the RPC interface.
        // Then on the client side, it is changed to a NULL.  So we end
        // up with an empty-double-NULL-terminated-string.
        //
        endOfVariableData = endOfVariableData - 1;
        * endOfVariableData = L'/';
        lpDependencies = endOfVariableData;
    }
    else {

        LPWSTR DependName;


        DependName = (LPWSTR)LocalAlloc(0, (UINT) MaxDependSize);

        if (DependName == NULL) {
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        lpDependencies = endOfVariableData;
        while (dependRecord != NULL) {

            SC_ASSERT( dependRecord->Depend != NULL );


            if (dependRecord->DependType == TypeDependOnService) {

                wcscpy(DependName, dependRecord->DependService->ServiceName);

            }
            else if (dependRecord->DependType == TypeDependOnGroup) {

                *DependName = SC_GROUP_IDENTIFIERW;

                wcscpy(DependName + 1, dependRecord->DependGroup->GroupName);
            }
            else {
                //
                // Unresolved service dependency
                //
                wcscpy(DependName, dependRecord->DependUnresolved->Name);
            }

            bufSize = (DWORD) wcslen(DependName);

            if ( !ScCopyStringToBufferW (
                    DependName,
                    bufSize,
                    fixedDataEnd,
                    &endOfVariableData,
                    &lpDependencies,
                    NULL
                    ) ) {

                SC_LOG0(ERROR,
                    "RQueryServiceConfigW:ScCopyStringtoBufferW (Dependencies)Failed\n");

                SC_ASSERT( FALSE );
                ApiStatus = ERROR_INSUFFICIENT_BUFFER;
                LocalFree(DependName);
                goto Cleanup;
            }
            else {
                //
                // Add separator character.
                //

                lpDependencies[bufSize] = L'/';
            }

            dependRecord = dependRecord->Next;
        }

        LocalFree(DependName);
    }
Cleanup:
    return(ApiStatus);
}


#if DBG
VOID
ScDumpGroups(
    VOID
    )
/*++

Routine Description:

    This function walks group list prints out each entry.

Arguments:

    None.

Return Value:

    None.

Note:

    Calls to this routine must be enclosed within #if DBG.

--*/
{
    PLOAD_ORDER_GROUP GroupEntry = ScGetOrderGroupList();


    while (GroupEntry != NULL) {
        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "\nOrdered Groups:\n"));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "Group: Handle=%08lx Name=%ws RefCount=x%lx\n",
                   GroupEntry,
                   GroupEntry->GroupName,
                   GroupEntry->RefCount));

        GroupEntry = GroupEntry->Next;
    }

    GroupEntry = ScGetStandaloneGroupList();

    while (GroupEntry != NULL) {
        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "Standalone Groups:\n"));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "Group: Handle=%08lx Name=%ws RefCount=x%lx\n",
                   GroupEntry,
                   GroupEntry->GroupName,
                   GroupEntry->RefCount));

        GroupEntry = GroupEntry->Next;
    }

    KdPrintEx((DPFLTR_SCSERVER_ID,
               DEBUG_DEPEND_DUMP,
               "\nTDI     group is at %08lx" "\nPNP_TDI group is at %08lx\n",
               ScGlobalTDIGroup,
               ScGlobalPNP_TDIGroup));
}

VOID
ScDumpServiceDependencies(
    VOID
    )
/*++

Routine Description:

    This function walks the start and stop dependencies lists of every
    service in the service record list.

Arguments:

    None.

Return Value:

    None.

Note:

    Calls to this routine must be enclosed within #if DBG.

--*/
{
    PDEPEND_RECORD DependList;

    FOR_ALL_SERVICES(ServiceRecord)
    {
        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "Service: %-20ws UseCount=%lu",
                   ServiceRecord->ServiceName,
                   ServiceRecord->UseCount));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   " MemberOfGroup=%08lx ",
                   ServiceRecord->MemberOfGroup));

        if (ServiceRecord->MemberOfGroup != NULL) {
            if (ServiceRecord->MemberOfGroup->RefCount != MAXULONG) {
                KdPrintEx((DPFLTR_SCSERVER_ID,
                           DEBUG_DEPEND_DUMP,
                           "SG=%ws\n",
                           ServiceRecord->MemberOfGroup->GroupName));
            }
            else if (ServiceRecord->MemberOfGroup->RefCount == MAXULONG) {
                KdPrintEx((DPFLTR_SCSERVER_ID,
                           DEBUG_DEPEND_DUMP,
                           "OG=%ws\n",
                           ServiceRecord->MemberOfGroup->GroupName));
            }
        }
        else {
            KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_DEPEND_DUMP, "\n"));
        }

        if (ServiceRecord->RegistryGroup != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_DEPEND_DUMP,
                       "                    RG=%ws\n",
                       ServiceRecord->RegistryGroup->GroupName));
        }

        //
        // Dump start depend
        //
        DependList = ServiceRecord->StartDepend;

        if (DependList != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_DEPEND_DUMP, "    StartDepend:\n"));
        }

        while (DependList != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_DEPEND_DUMP,
                       "        %ws\n",
                       DependList->DependService->ServiceName));

            DependList = DependList->Next;
        }

        //
        // Dump stop depend
        //
        DependList = ServiceRecord->StopDepend;
        if (DependList != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_DEPEND_DUMP, "    StopDepend:\n"));
        }

        while (DependList != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_DEPEND_DUMP,
                       "        %ws\n",
                       DependList->DependService->ServiceName));

            DependList = DependList->Next;
        }
    }
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\depend.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    depend.h

Abstract:

    Service dependencies related function prototypes.

Author:

    Rita Wong (ritaw)     03-Apr-1992

Revision History:

--*/

#ifndef SCDEPEND_INCLUDED
#define SCDEPEND_INCLUDED

#include <scwow.h>

//
// Function Prototypes
//

BOOL
ScInitAutoStart(
    VOID
    );

DWORD
ScAutoStartServices(
    IN OUT   LPSC_RPC_LOCK lpLock
    );

DWORD
ScStartServiceAndDependencies(
    IN LPSERVICE_RECORD ServiceToStart OPTIONAL,
    IN DWORD NumArgs,
    IN LPSTRING_PTRSW CmdArgs,
    IN BOOL fIsOOBE
    );

BOOL
ScDependentsStopped(
    IN LPSERVICE_RECORD ServiceToStop
    );

VOID
ScNotifyChangeState(
    VOID
    );

VOID
ScEnumDependents(
    IN     LPSERVICE_RECORD ServiceRecord,
    IN     LPENUM_SERVICE_STATUS_WOW64 EnumBuffer,
    IN     DWORD RequestedState,
    IN OUT LPDWORD EntriesRead,
    IN OUT LPDWORD BytesNeeded,
    IN OUT LPENUM_SERVICE_STATUS_WOW64 *EnumRecord,
    IN OUT LPWSTR *EndOfVariableData,
    IN OUT LPDWORD Status
    );

BOOL
ScInHardwareProfile(
    IN  LPCWSTR ServiceName,
    IN  ULONG   GetDeviceListFlags
    );

#endif // #ifndef SCDEPEND_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\driver.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    DRIVER.CXX

Abstract:

    Functions for Loading, Maintaining, and Unloading Device Drivers.
        ScLoadDeviceDriver
        ScControlDriver
        ScGetDriverStatus
        ScGetObjectName
        ScUnloadDriver
        ScIsPnPDriver

Author:

    Dan Lafferty (danl)     27-Apr-1991

Environment:

    User Mode -Win32

Notes:

Revision History:

    22-Feb-1999 jschwart
        Prevent stopping of PnP drivers via ControlService (since it bluescreens
        the machine and is easier to fix here than the REAL fix in NtUnloadDriver)
    02-Oct-1997 AnirudhS
        Removed IOCTL to NDIS for NDIS driver arrivals.
    08-Jan-1997 AnirudhS
        ScGetDriverStatus, ScGetObjectName, etc: Instead of expecting a
        shared lock on the service database and upgrading it to exclusive,
        which is broken, just expect an exclusive lock.
    03-Jan-1997 AnirudhS
        Temporary fix for QFE bug 66887: When a driver stops, don't free its
        object name.  Free it only when the driver is reconfigured or deleted.
        The changes are marked by "QFE 66887" comments.
    19-Jan-1996 AnirudhS
        Add IOCTLs to NDIS for TDI and NDIS driver arrivals.
    30-Oct-1995 AnirudhS
        ScLoadDeviceDriver: Turn STATUS_IMAGE_ALREADY_LOADED into
        ERROR_SERVICE_ALREADY_RUNNING.
    05-Aug-1993 Danl
        ScGetObjectName:  It is possible to read an empty-string object
        name from the registry.  If we do, we need to treat this the same
        as if the ObjectName value were not in the registry.
    01-Jun-1993 Danl
        GetDriverStatus: When state moves from STOPPED to RUNNING,
        then the service record is updated so that STOP is accepted as
        a control.
    10-Jul-1992 Danl
        Changed RegCloseKey to ScRegCloseKey
    27-Apr-1991     danl
        created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <ntddndis.h>   // NDIS IOCTL codes
#include <stdlib.h>     // wide character c runtimes.
#include <cfgmgr32.h>   // PNP manager functions
#include <pnp.h>        // PNP manager functions, server side
#include "scconfig.h"   // ScReadStartName
#include "driver.h"     // ScGetDriverStatus()
#include "depend.h"     // ScGetDependentsStopped()
#include "scsec.h"      // ScGetPrivilege, ScReleasePrivilege
#include <debugfmt.h>   // FORMAT_LPWSTR

//
// DEFINES
//

#define OBJ_DIR_INFO_SIZE       4096L

#define SERVICE_PATH            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

#define FILE_SYSTEM_OBJ_NAME    L"\\FileSystem\\"

#define DRIVER_OBJ_NAME         L"\\Driver\\"

//
// This is a string version of GUID_DEVCLASS_LEGACYDRIVER in devguid.h
//
#define LEGACYDRIVER_STRING     L"{8ECC055D-047F-11D1-A537-0000F8753ED1}"

//
// LOCAL FUNCTION PROTOTYPES
//

DWORD
ScGetObjectName(
    LPSERVICE_RECORD    ServiceRecord
    );


BOOL
ScIsPnPDriver(
    IN  LPSERVICE_RECORD Service
    );


DWORD
ScLoadDeviceDriver(
    LPSERVICE_RECORD    ServiceRecord
    )
/*++

Routine Description:

    This function attempts to load a device driver.  If the NtLoadDriver
    call is successful, we know that the driver is running (since this
    is a synchronous operation).  If the call fails, the appropriate
    windows error code is returned.

    NOTE:  It is expected that the Database Lock will be held with
    exclusive access upon entry to this routine.

    WARNING:  This routine releases and acquires the Database Lock.

Arguments:

    ServiceRecord - This is pointer to a service record for the Device
        Driver that is being started.

Return Value:



--*/

{
    DWORD               status = NO_ERROR;
    NTSTATUS            ntStatus;
    LPWSTR              regKeyPath;
    UNICODE_STRING      regKeyPathString;
    ULONG               privileges[1];

#if DBG
    DWORD               dwLoadTime;
#endif

    SC_LOG1(TRACE,"In ScLoadDeviceDriver for "FORMAT_LPWSTR" Driver\n",
        ServiceRecord->ServiceName);

    SC_ASSERT(ScServiceListLock.Have());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    // If the ObjectName does not exist yet, create one.
    //
    if (ServiceRecord->ObjectName == NULL) {
        status = ScGetObjectName(ServiceRecord);
        if (status != NO_ERROR) {
            goto CleanExit;
        }
    }

    //
    // Create the Registry Key Path for this driver name.
    //
    regKeyPath = (LPWSTR)LocalAlloc(
                    LMEM_FIXED,
                    sizeof(SERVICE_PATH) +
                    WCSSIZE(ServiceRecord->ServiceName));

    if (regKeyPath == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }
    wcscpy(regKeyPath, SERVICE_PATH);
    wcscat(regKeyPath, ServiceRecord->ServiceName);

    //
    // Load the Driver
    // (but first get SeLoadDriverPrivilege)
    //
    RtlInitUnicodeString(&regKeyPathString, regKeyPath);

    privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;
    status = ScGetPrivilege(1,privileges);
    if (status != NO_ERROR) {
        goto CleanExit;
    }

    SC_ASSERT(ServiceRecord->ServiceStatus.dwCurrentState == SERVICE_STOPPED);

    //
    // Release and reacquire the lock around the NtLoadDriver call so that
    // a driver can generate a PnP event during its load routine (in NT5,
    // the ClusDisk driver can synchronously generate a dismount event while
    // it's loading)
    //
    ScServiceRecordLock.Release();

#if DBG
    dwLoadTime = GetTickCount();
#endif

    ntStatus = NtLoadDriver(&regKeyPathString);

#if DBG
    dwLoadTime = GetTickCount() - dwLoadTime;
    if (dwLoadTime > 5000)
    {
        SC_LOG2(ERROR,
                " **** NtLoadDriver(%ws) took %lu ms!\n",
                ServiceRecord->ServiceName,
                dwLoadTime);
    }
#endif

    ScServiceRecordLock.GetExclusive();

    ScReleasePrivilege();

    LocalFree(regKeyPath);

    if (NT_SUCCESS(ntStatus)) {
        SC_LOG1(TRACE,"ScLoadDeviceDriver: NtLoadDriver Success for "
            FORMAT_LPWSTR " \n",ServiceRecord->ServiceName);
    }
    else if (ntStatus == STATUS_IMAGE_ALREADY_LOADED) {
        SC_LOG1(TRACE,"ScLoadDeviceDriver: Driver " FORMAT_LPWSTR
            " is already running\n",ServiceRecord->ServiceName);

        status = ERROR_SERVICE_ALREADY_RUNNING;
    }
    else {
        SC_LOG2(WARNING,"ScLoadDeviceDriver: NtLoadDriver(%ws) Failed 0x%lx\n",
            ServiceRecord->ServiceName,
            ntStatus);

        if (ntStatus == STATUS_NO_SUCH_DEVICE) {
            status = ERROR_BAD_UNIT;
        }
        else {
            status = RtlNtStatusToDosError(ntStatus);
        }
        goto CleanExit;
    }

    //
    // Update the Service Record with this driver's start information.
    //

    ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    ServiceRecord->ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
    ServiceRecord->ServiceStatus.dwServiceSpecificExitCode = 0;
    ServiceRecord->ServiceStatus.dwCheckPoint = 0;
    ServiceRecord->ServiceStatus.dwWaitHint = 0;
    ServiceRecord->UseCount++;
    SC_LOG2(USECOUNT, "ScLoadDeviceDriver: " FORMAT_LPWSTR
         " increment USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);


    //
    // Tell NDIS to issue the PNP notifications about this driver's arrival,
    // if necessary
    //
    ScNotifyNdis(ServiceRecord);

CleanExit:
    return(status);
}


VOID
ScNotifyNdis(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function issues Plug-and-Play notifications to NDIS about the
    arrival of certain types of drivers and services.

Arguments:

    ServiceRecord - Service or driver that just started successfully.

Return Value:

    None.  Errors are written to the event log.

--*/

{
    HANDLE hDevice;
    BOOL fResult;
    DWORD cb;
    DWORD IoControlCode;


    //
    // TDI GROUP SPECIAL:  Drivers in group TDI are assumed to be PNP-unaware
    // network transport drivers.  Win32 services in group TDI are assumed to
    // be in that group because they start PNP-unaware transport drivers.
    // (PNP-aware transports are in group PNP_TDI.)
    // Such a transport doesn't notify the higher-level network components
    // (TDI clients) that it has arrived.  So we issue an IOCTL to NDIS to ask
    // it to read the transport's bindings from the registry and notify the
    // clients on this transport's behalf.
    //
    if (ServiceRecord->MemberOfGroup == ScGlobalTDIGroup)
    {
        IoControlCode = IOCTL_NDIS_ADD_TDI_DEVICE;
    }
    else
    {
        return;
    }

    hDevice = CreateFile(
                    L"\\\\.\\NDIS",
                    GENERIC_READ | GENERIC_WRITE,
                    0,                      // sharing mode - not significant
                    NULL,                   // security attributes
                    OPEN_EXISTING,
                    0,                      // file attributes and flags
                    NULL                    // handle to template file
                    );

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        SC_LOG(WARNING, "Couldn't open handle to NDIS for IOCTL, error %lu\n",
                    GetLastError());
        return;
    }

    fResult = DeviceIoControl(
                    hDevice,
                    IoControlCode,
                    ServiceRecord->ServiceName,                     // input buffer
                    (DWORD) WCSSIZE(ServiceRecord->ServiceName),    // input buffer size
                    NULL,                                           // output buffer
                    0,                                              // output buffer size
                    &cb,                                            // bytes returned
                    NULL);                                          // OVERLAPPED structure

    CloseHandle(hDevice);

    if (!fResult)
    {
        SC_LOG3(WARNING, "IOCTL %#lx to NDIS for %ws failed, error %lu\n",
                IoControlCode, ServiceRecord->ServiceName, GetLastError());
    }
}


DWORD
ScControlDriver(
    DWORD               ControlCode,
    LPSERVICE_RECORD    ServiceRecord,
    LPSERVICE_STATUS    lpServiceStatus
    )

/*++

Routine Description:

    This function checks controls that are passed to device drivers.  Only
    two controls are accepted.
        stop -  This function attemps to unload the driver.  The driver
                state is set to STOP_PENDING since unload is an
                asynchronous operation.  We have to wait until another
                call is made that will return the status of this driver
                before we can query the driver object to see if it is
                still there.

        interrogate - This function attempts to query the driver object
                to see if it is still there.

    WARNING:  This function should only be called with a pointer to
        a ServiceRecord that belongs to a DRIVER.

Arguments:

    ControlCode - This is the control request that is being sent to
        control the driver.

    ServiceRecord - This is a pointer to the service record for the
        driver that is to be controlled.

    lpServiceStatus - This is a pointer to a buffer that upon exit will
        contain the latest service status.

Return Value:



--*/

{
    DWORD status;

    SC_LOG1(TRACE,"In ScControlDriver for "FORMAT_LPWSTR" Driver\n",
        ServiceRecord->ServiceName);

    CServiceRecordExclusiveLock Lock;

    switch(ControlCode) {
    case SERVICE_CONTROL_INTERROGATE:

        //
        // On interrogate, we need to see if the service is still there.
        // Then we update the status accordingly.
        //
        status = ScGetDriverStatus(ServiceRecord, lpServiceStatus);

        if (status == NO_ERROR) {

            //
            // Based on the state, return the appropriate error code
            // so driver return codes match with those of services
            //
            switch(lpServiceStatus->dwCurrentState) {

                case SERVICE_STOPPED:
                    status = ERROR_SERVICE_NOT_ACTIVE;
                    break;

                case SERVICE_STOP_PENDING:
                    status = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
                    break;
            }
        }

        break;

    case SERVICE_CONTROL_STOP:

        //
        // This operation is invalid on PnP drivers
        //
        if (ScIsPnPDriver(ServiceRecord)) {
            status = ERROR_INVALID_SERVICE_CONTROL;
            break;
        }

        //
        // Find out if the driver is still running.
        //
        status = ScGetDriverStatus(ServiceRecord, lpServiceStatus);

        if (status != NO_ERROR) {
            break;
        }

        if (ServiceRecord->ServiceStatus.dwCurrentState != SERVICE_RUNNING) {

            //
            // If the driver is not running, then it cannot accept the
            // STOP control request.  Drivers do not accept STOP requests
            // when in the START_PENDING state.  Make these return codes
            // match with those of services based on the driver's state
            //

            switch(lpServiceStatus->dwCurrentState) {

                case SERVICE_STOPPED:
                    status = ERROR_SERVICE_NOT_ACTIVE;
                    break;

                case SERVICE_STOP_PENDING:
                    status = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
                    break;

                default:
                    status = ERROR_INVALID_SERVICE_CONTROL;
                    break;
            }

            goto CleanExit;
        }

        //
        // Check for dependent services still running
        //

        if (! ScDependentsStopped(ServiceRecord)) {
            status = ERROR_DEPENDENT_SERVICES_RUNNING;
            goto CleanExit;
        }

        status = ScUnloadDriver(ServiceRecord);

        if (status == ERROR_INVALID_SERVICE_CONTROL) {

            //
            // If the driver fails to unload with this error,
            // then it must be one that cannot be stopped.
            // We want to mark it as such, and return an error.
            //
            SC_LOG0(TRACE,"ScControlDriver: Marking driver as non-stoppable\n");

            ServiceRecord->ServiceStatus.dwControlsAccepted = 0L;

            goto CleanExit;
        }

        //
        // Set the Current State to STOP_PENDING, and get the
        // current status (again);
        //
        ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        status = ScGetDriverStatus(ServiceRecord, lpServiceStatus);

        break;

    default:
        status = ERROR_INVALID_SERVICE_CONTROL;
    }

CleanExit:
    return(status);
}


DWORD
ScGetDriverStatus(
    IN OUT LPSERVICE_RECORD    ServiceRecord,
    OUT    LPSERVICE_STATUS    lpServiceStatus OPTIONAL
    )

/*++

Routine Description:

    This function determines the correct current status for a device driver.
    The updated status is only returned if NO_ERROR is returned.

    WARNING:  This function expects the EXCLUSIVE database lock to be held.
    CODEWORK: For greater parallelism while enumerating driver status, get
        the exclusive lock only if the driver status has changed.

    NOTE:  The ServiceRecord passed in MUST be for a DeviceDriver.



Arguments:

    ServiceRecord - This is a pointer to the Service Record for the
        Device Driver for which the status is desired.

    lpServiceStatus - This is a pointer to a buffer that upon exit will
        contain the latest service status.

Return Value:

    NO_ERROR - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - If the local alloc failed.

    Or any unexpected errors from the NtOpenDirectoryObject or
    NtQueryDirectoryObject.

--*/
{

    NTSTATUS                        ntStatus;
    DWORD                           status;
    HANDLE                          DirectoryHandle;
    OBJECT_ATTRIBUTES               Obja;
    ULONG                           Context;
    ULONG                           ReturnLength;
    BOOLEAN                         restartScan;
    UNICODE_STRING                  ObjectPathString;
    UNICODE_STRING                  ObjectNameString;

    LPWSTR      pObjectPath;
    LPWSTR      pDeviceName;
    BOOL        found = FALSE;


    SC_LOG1(TRACE,"In ScGetDriverStatus for "FORMAT_LPWSTR" Driver\n",
        ServiceRecord->ServiceName);

    SC_ASSERT(ScServiceRecordLock.HaveExclusive());
    SC_ASSERT(ServiceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER);

    //
    // If the ObjectName does not exist yet, create one.
    //
    if (ServiceRecord->ObjectName == NULL) {
        status = ScGetObjectName(ServiceRecord);
        if (status != NO_ERROR) {
            return(status);
        }
    }


    //
    // Take the ObjectPathName apart such that the path is in one
    // string, and the device name is in another string.

    //
    // First copy the Object Path string into a new buffer.
    //
    pObjectPath = (LPWSTR)LocalAlloc(
                    LMEM_FIXED,
                    WCSSIZE(ServiceRecord->ObjectName));

    if(pObjectPath == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wcscpy(pObjectPath, ServiceRecord->ObjectName);

    //
    // Find the last occurrence of '\'.  The Device name follows that.
    // replace the '\' with a NULL terminator.  Now we have two strings.
    //
    pDeviceName = wcsrchr(pObjectPath, L'\\');
    if (pDeviceName == NULL) {
        SC_LOG0(ERROR,"ScGetDriverStatus: DeviceName not in object path name\n");
        LocalFree(pObjectPath);
        return(ERROR_PATH_NOT_FOUND);
    }

    *pDeviceName = L'\0';
    pDeviceName++;


    //
    // Open the directory object by name
    //

    RtlInitUnicodeString(&ObjectPathString,pObjectPath);

    InitializeObjectAttributes(&Obja,&ObjectPathString,0,NULL,NULL);

    ntStatus = NtOpenDirectoryObject (
                &DirectoryHandle,
                DIRECTORY_TRAVERSE | DIRECTORY_QUERY,
                &Obja);

    if (!NT_SUCCESS(ntStatus)) {
        LocalFree(pObjectPath);
        if (ntStatus == STATUS_OBJECT_PATH_NOT_FOUND) {
            //
            // If a driver uses a non-standard object path, the path may
            // not exist if the driver is not running.  We want to treat
            // this as if the driver is not running.
            //
            goto CleanExit;
        }
        SC_LOG1(ERROR,"ScGetDriverStatus: NtOpenDirectoryObject failed 0x%lx\n",
            ntStatus);
        return(RtlNtStatusToDosError(ntStatus));
    }

    RtlInitUnicodeString(&ObjectNameString,pDeviceName);

    restartScan = TRUE;
    do  {
        BYTE                            Buffer[OBJ_DIR_INFO_SIZE];
        POBJECT_DIRECTORY_INFORMATION   pObjInfo;

        //
        // Query the Directory Object to enumerate all object names
        // in that object directory.
        //
        ntStatus = NtQueryDirectoryObject (
                    DirectoryHandle,
                    Buffer,
                    OBJ_DIR_INFO_SIZE,
                    FALSE,
                    restartScan,
                    &Context,
                    &ReturnLength);

        if (!NT_SUCCESS(ntStatus)) {
            SC_LOG1(ERROR,"ScGetDriverStatus:NtQueryDirectoryObject Failed 0x%lx\n",
                ntStatus);

            LocalFree(pObjectPath);
            NtClose(DirectoryHandle);
            return(RtlNtStatusToDosError(ntStatus));
        }

        //
        // Now check to see if the device name that we are interested in is
        // in the enumerated data.
        //

        for (pObjInfo = (POBJECT_DIRECTORY_INFORMATION) Buffer;
             pObjInfo->Name.Length != 0;
             pObjInfo++) {

            if (RtlCompareUnicodeString( &(pObjInfo->Name), &ObjectNameString, TRUE) == 0) {
                found = TRUE;
                break;
            }
        }
        restartScan = FALSE;
    } while ((ntStatus == STATUS_MORE_ENTRIES) && (found == FALSE));

    NtClose(DirectoryHandle);
    LocalFree(pObjectPath);

CleanExit:

    if (found) {

        DWORD PreviousState;


        PreviousState = ServiceRecord->ServiceStatus.dwCurrentState;

        if (PreviousState != SERVICE_STOP_PENDING) {

            //
            // The driver IS running.
            //

            ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_RUNNING;

            if (PreviousState == SERVICE_STOPPED) {
                //
                // It used to be stopped but now it is running.
                //
                ServiceRecord->ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
                ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
                ServiceRecord->ServiceStatus.dwServiceSpecificExitCode = 0;
                ServiceRecord->ServiceStatus.dwCheckPoint = 0;
                ServiceRecord->ServiceStatus.dwWaitHint = 0;
                ServiceRecord->UseCount++;
                SC_LOG2(USECOUNT, "ScGetDriverStatus: " FORMAT_LPWSTR
                    " increment USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);
            }

            if (ServiceRecord->ServiceStatus.dwWin32ExitCode ==
                ERROR_SERVICE_NEVER_STARTED) {
                ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
            }

            SC_LOG1(TRACE,"ScGetDriverStatus: "FORMAT_LPWSTR" Driver is "
                "RUNNING\n", ServiceRecord->ServiceName);
        }
    }
    else {

        //
        // The driver is NOT running.
        //

        SC_LOG1(TRACE,"ScGetDriverStatus: "FORMAT_LPWSTR" Driver is "
            "NOT RUNNING\n", ServiceRecord->ServiceName);

        switch(ServiceRecord->ServiceStatus.dwCurrentState) {
        case SERVICE_STOP_PENDING:
            //
            // If the old state was STOP_PENDING, then we can consider
            // it stopped.
            //
            LocalFree(ServiceRecord->ObjectName);

            ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
            ServiceRecord->ServiceStatus.dwControlsAccepted = 0;
            ServiceRecord->ServiceStatus.dwCheckPoint = 0;
            ServiceRecord->ServiceStatus.dwWaitHint = 0;
            ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
            ServiceRecord->ObjectName = NULL;

            //
            // Since the service is no longer running, we need to decrement
            // the use count.  If the count is decremented to zero, and
            // the service is marked for deletion, it will get deleted.
            //
            ScDecrementUseCountAndDelete(ServiceRecord);

            break;

        case SERVICE_STOPPED:
            //
            // We are not likely to query this driver's status again soon,
            // so free its object name.
            //
            LocalFree(ServiceRecord->ObjectName);
            ServiceRecord->ObjectName = NULL;
            break;

        default:
            //
            // The driver stopped without being requested to do so.
            //
            LocalFree(ServiceRecord->ObjectName);

            ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
            ServiceRecord->ServiceStatus.dwControlsAccepted = 0;
            ServiceRecord->ServiceStatus.dwCheckPoint = 0;
            ServiceRecord->ServiceStatus.dwWaitHint = 0;
            ServiceRecord->ServiceStatus.dwWin32ExitCode = ERROR_GEN_FAILURE;
            ServiceRecord->ObjectName = NULL;

            //
            // Since the service is no longer running, we need to decrement
            // the use count.  If the count is decremented to zero, and
            // the service is marked for deletion, it will get deleted.
            //
            ScDecrementUseCountAndDelete(ServiceRecord);

            break;
        }

    }

    if (ARGUMENT_PRESENT(lpServiceStatus)) {
        RtlCopyMemory(
            lpServiceStatus,
            &(ServiceRecord->ServiceStatus),
            sizeof(SERVICE_STATUS));
    }

    return(NO_ERROR);

}

DWORD
ScGetObjectName(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function gets a directory object path name for a driver by looking
    it up in the registry, or, if it isn't specified in the registry, by
    computing it from the driver name and type.  It allocates storage
    for this name, and passes back the pointer to it.  The Pointer to
    the object name string is stored in the ServiceRecord->ObjectName
    location.

    WARNING:  This function expects the EXCLUSIVE database lock to be held.


Arguments:

    ServiceRecord - This is a pointer to the ServiceRecord for the Driver.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - If there wasn't enough memory available for
        the ObjectName.

    or any error from ScOpenServiceConfigKey.

--*/
{
    DWORD   status;
    DWORD   bufferSize;
    LPWSTR  objectNamePath;
    HKEY    serviceKey;
    LPWSTR  pObjectName;

    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ServiceRecord->ObjectName != NULL) {
        //
        // Some other thread beat us to it
        //
        return(NO_ERROR);
    }

    //
    // Open the Registry Key for this driver name.
    //
    status = ScOpenServiceConfigKey(
                ServiceRecord->ServiceName,
                KEY_READ,
                FALSE,
                &serviceKey);

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetObjectName: ScOpenServiceConfigKey Failed %d\n",
            status);
        return(status);
    }

    //
    // Get the NT Object Name from the registry.
    //
    status = ScReadStartName(
                serviceKey,
                &pObjectName);


    ScRegCloseKey(serviceKey);

    //
    // Make sure we read a value with length greater than 0
    //
    if (status == NO_ERROR && pObjectName != NULL)
    {
        if (*pObjectName != '\0') {
            ServiceRecord->ObjectName = pObjectName;
            return(NO_ERROR);
        }
        else {
            LocalFree(pObjectName);
        }
    }

    //
    // There must not be a name in the ObjectName value field.
    // In this case, we must build the name from the type info and
    // the ServiceName.  Names will take the following form:
    //    "\\FileSystem\\Rdr"   example of a file system driver
    //    "\\Driver\\Parallel"   example of a kernel driver
    //
    //
    SC_LOG1(TRACE,"ScGetObjectName: ScReadStartName Failed(%d). Build the"
        "name instead\n",status);

    if (ServiceRecord->ServiceStatus.dwServiceType == SERVICE_FILE_SYSTEM_DRIVER) {

        bufferSize = sizeof(FILE_SYSTEM_OBJ_NAME);
        objectNamePath = FILE_SYSTEM_OBJ_NAME;
    }
    else {

        bufferSize = sizeof(DRIVER_OBJ_NAME);
        objectNamePath = DRIVER_OBJ_NAME;

    }

    bufferSize += (DWORD) WCSSIZE(ServiceRecord->ServiceName);

    pObjectName = (LPWSTR)LocalAlloc(LMEM_FIXED, (UINT) bufferSize);
    if (pObjectName == NULL) {
        SC_LOG0(ERROR,"ScGetObjectName: LocalAlloc Failed\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wcscpy(pObjectName, objectNamePath);
    wcscat(pObjectName, ServiceRecord->ServiceName);

    ServiceRecord->ObjectName = pObjectName;

    return(NO_ERROR);

}

DWORD
ScUnloadDriver(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function attempts to unload the driver whose service record
    is passed in.

    NOTE:  Make sure the ServiceRecord is for a driver and not a service
    before calling this routine.


Arguments:

    ServiceRecord - This is a pointer to the service record for a driver.
        This routine assumes that the service record is for a driver and
        not a service.

Return Value:

    NO_ERROR - if successful.

    ERROR_INVALID_SERVICE_CONTROL - This is returned if the driver is
        not unloadable.

    otherwise, an error code is returned.

Note:


--*/
{
    NTSTATUS        ntStatus = STATUS_SUCCESS;
    DWORD           status;
    LPWSTR          regKeyPath;
    UNICODE_STRING  regKeyPathString;
    ULONG           privileges[1];

    //
    // Create the Registry Key Path for this driver name.
    //
    regKeyPath = (LPWSTR)LocalAlloc(
                    LMEM_FIXED,
                    sizeof(SERVICE_PATH) +
                    WCSSIZE(ServiceRecord->ServiceName));

    if (regKeyPath == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        return(status);
    }
    wcscpy(regKeyPath, SERVICE_PATH);
    wcscat(regKeyPath, ServiceRecord->ServiceName);


    //
    // Unload the Driver
    // (but first get SeLoadDriverPrivilege)
    //

    RtlInitUnicodeString(&regKeyPathString, regKeyPath);

    privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;
    status = ScGetPrivilege(1,privileges);
    if (status != NO_ERROR) {
        LocalFree(regKeyPath);
        return(status);
    }

    ntStatus = NtUnloadDriver (&regKeyPathString);

    (VOID)ScReleasePrivilege();

    LocalFree(regKeyPath);

    if (!NT_SUCCESS(ntStatus)) {

        if (ntStatus == STATUS_INVALID_DEVICE_REQUEST) {

            status = ERROR_INVALID_SERVICE_CONTROL;
            return(status);
        }

        SC_LOG1(ERROR,"ScControlDriver: NtUnloadDriver Failed 0x%lx\n",ntStatus);

        status = RtlNtStatusToDosError(ntStatus);
        return(status);
    }

    SC_LOG1(TRACE,"ScLoadDeviceDriver: NtUnloadDriver Success for "
        ""FORMAT_LPWSTR "\n",ServiceRecord->ServiceName);

    return(NO_ERROR);

}


BOOL
ScIsPnPDriver(
    IN  LPSERVICE_RECORD Service
    )
/*++

Routine Description:

    This function checks whether a specified driver is a PnP driver

Arguments:

    Service - Specifies the driver of interest.

Return Value:

    TRUE - if the driver is a PnP driver or if this cannot be determined.

    FALSE - if the service is not a PnP driver.

--*/
{
    CONFIGRET   Status;
    BOOL        fRetStatus = TRUE;
    WCHAR *     pBuffer;
    ULONG       cchLen, cchTransferLen, ulRegDataType;
    WCHAR       szClassGuid[MAX_GUID_STRING_LEN];

    //
    // Allocate a buffer for the list of device instances associated with
    // this service
    //
    Status = PNP_GetDeviceListSize(
                    NULL,                           // hBinding
                    Service->ServiceName,           // pszFilter
                    &cchLen,                        // list length in wchars
                    CM_GETIDLIST_FILTER_SERVICE);   // filter is a service name

    if (Status != CR_SUCCESS)
    {
        SC_LOG2(WARNING, "PNP_GetDeviceListSize failed %#lx for service %ws\n",
                       Status, Service->ServiceName);
        return TRUE;
    }

    pBuffer = (WCHAR *) LocalAlloc(0, cchLen * sizeof(WCHAR));
    if (pBuffer == NULL)
    {
        SC_LOG(ERROR, "Couldn't allocate buffer for device list, error %lu\n",
                      GetLastError());
        return TRUE;
    }

    //
    // Initialize parameters for PNP_GetDeviceList, the same way as is
    // normally done in the client side of the API
    //
    pBuffer[0] = L'\0';

    //
    // Get the list of device instances that are associated with this service
    //
    // (For legacy and PNP-aware services, we could get an empty device list.)
    //
    Status = PNP_GetDeviceList(
                    NULL,                           // binding handle
                    Service->ServiceName,           // pszFilter
                    pBuffer,                        // buffer for device list
                    &cchLen,                        // buffer length in wchars
                    CM_GETIDLIST_FILTER_SERVICE |   // filter is a service name
                    CM_GETIDLIST_DONOTGENERATE      // do not generate an instance if none exists
                    );

    if (Status != CR_SUCCESS)
    {
        SC_LOG2(ERROR, "PNP_GetDeviceList failed %#lx for service %ws\n",
                       Status, Service->ServiceName);
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // If there are no devnodes, this is not a PnP driver
    //
    if (pBuffer[0] == L'\0' || cchLen == 0)
    {
        SC_LOG1(TRACE, "ScIsPnPDriver: %ws is not a PnP driver (no devnodes)\n",
                       Service->ServiceName);
        LocalFree(pBuffer);
        return FALSE;
    }

    //
    // If there's more than one devnode, this is a PnP driver
    //
    if (*(pBuffer + wcslen(pBuffer) + 1) != L'\0')
    {
        SC_LOG1(TRACE, "ScIsPnPDriver: %ws is a PnP driver (more than 1 devnode)\n",
                       Service->ServiceName);
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // Get the class GUID of this driver
    //
    cchLen = cchTransferLen = sizeof(szClassGuid);

    Status = PNP_GetDeviceRegProp(
                    NULL,                           // binding handle
                    pBuffer,                        // device instance
                    CM_DRP_CLASSGUID,               // property to get
                    &ulRegDataType,                 // pointer to REG_* type
                    (LPBYTE) szClassGuid,           // buffer for property
                    &cchTransferLen,                // transfer length
                    &cchLen,                        // buffer length in bytes
                    0                               // flags
                    );

    if (Status != CR_SUCCESS)
    {
        SC_ASSERT(Status != CR_BUFFER_SMALL);

        SC_LOG2(ERROR, "PNP_GetDeviceRegProp failed %#lx for service %ws\n",
                       Status, Service->ServiceName);
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // If the single devnode's class is LegacyDriver,
    // this is not a PnP driver
    //
    fRetStatus = (_wcsicmp(szClassGuid, LEGACYDRIVER_STRING) != 0);

    SC_LOG2(TRACE, "ScIsPnPDriver: %ws %ws a PnP driver\n",
                   Service->ServiceName, fRetStatus ? L"is" : L"is not");

    LocalFree(pBuffer);
    return fRetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\lock.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lock.cxx

Abstract:

    Contains code for the Service Control Database manager.  This includes
    all the database lock routines.  This file contains the following
    classes:
        CCountingResource
        CServiceListLock
        CGroupListLock

Author:

    Anirudh Sahni (anirudhs)    09-Jan-1997

Environment:

    User Mode -Win32

Revision History:

    09-Jan-1997     AnirudhS
        Created, replacing the old locking functions in dataman.cxx.

--*/

//
// INCLUDES
//

#include "precomp.hxx"

//
// Macros
//
#define LOCK_LOG(string)    SC_LOG3(LOCKS, " %s" string " level = %ld\n", \
                                       _ShortName, _Name, CurrentLevel())

//
// Globals
//
CServiceRecordLock  ScServiceRecordLock;
CServiceListLock    ScServiceListLock;
CGroupListLock      ScGroupListLock;


/*************************************************************************/
/* CCountingResource methods                                             */
/*************************************************************************/

#if DBG
void
CCountingResource::GetShared()
{
    LOCK_LOG(" Asking for %s lock shared...");
    SC_ASSERT(!HaveExclusive());
    RtlAcquireResourceShared(&_Lock, TRUE);
    SetCurrentLevel(CurrentLevel() + 1);
    LOCK_LOG("+Acquired %s lock shared,");
}

void
CCountingResource::GetExclusive()
{
    LOCK_LOG(" Asking for %s lock exclusive...");
    SC_ASSERT(!Have() || HaveExclusive());
    RtlAcquireResourceExclusive(&_Lock, TRUE);
    SetCurrentLevel(CurrentLevel() - 1);
    LOCK_LOG("+Acquired %s lock exclusive,");
}

void
CCountingResource::MakeShared()
{
    LOCK_LOG("vConverting %s lock to shared...");
    SC_ASSERT(CurrentLevel() == -1);
    RtlConvertExclusiveToShared(&_Lock);
    SetCurrentLevel(1);
    LOCK_LOG(" Converted %s lock to shared,");
}

void
CCountingResource::MakeExclusive()
{
    // WARNING: This option is easily misused.
    LOCK_LOG(" Converting %s lock to exclusive...");
    SC_ASSERT(CurrentLevel() == 1);
    RtlConvertSharedToExclusive(&_Lock);
    SetCurrentLevel(-1);
    LOCK_LOG("^Converted %s lock to exclusive,");
}

void
CCountingResource::Release()
{
    LOCK_LOG("-Releasing %s lock...");
    SC_ASSERT(Have());
    RtlReleaseResource( &_Lock );
    if (CurrentLevel() > 0)
    {
        SetCurrentLevel(CurrentLevel() - 1);
    }
    else
    {
        SetCurrentLevel(CurrentLevel() + 1);
    }
    LOCK_LOG(" Released %s lock,");
}
#endif // DBG


/*************************************************************************/
/* CServiceListLock methods                                              */
/*************************************************************************/

#if DBG
void
CServiceListLock::GetShared()
{
    // The record lock mustn't be acquired before the list lock
    if (!Have())
    {
        SC_ASSERT(! ScServiceRecordLock.Have());
    }

    CCountingResource::GetShared();
}

void
CServiceListLock::GetExclusive()
{
    // The record lock mustn't be acquired before the list lock
    if (!Have())
    {
        SC_ASSERT(! ScServiceRecordLock.Have());
    }

    CCountingResource::GetExclusive();
}

void
CServiceListLock::Release()
{
    // We mustn't release this if we still have the record lock
    if (CurrentLevel() == 1 || CurrentLevel() == -1)
    {
        SC_ASSERT(! ScServiceRecordLock.Have());
    }

    CCountingResource::Release();
}
#endif // DBG


/*************************************************************************/
/* CGroupListLock methods                                                */
/*************************************************************************/

#if DBG
void
CGroupListLock::GetShared()
{
    // The service list lock mustn't be acquired before the group list lock
    if (!Have())
    {
        SC_ASSERT(! ScServiceListLock.Have());
    }

    CCountingResource::GetShared();
}

void
CGroupListLock::GetExclusive()
{
    // The service list lock mustn't be acquired before the group list lock
    if (!Have())
    {
        SC_ASSERT(! ScServiceListLock.Have());
    }

    CCountingResource::GetExclusive();
}

void
CGroupListLock::Release()
{
    // We mustn't release this if we still have the service list lock or
    // service record lock
    if (CurrentLevel() == 1 || CurrentLevel() == -1)
    {
        SC_ASSERT(! ScServiceRecordLock.Have());
        SC_ASSERT(! ScServiceListLock.Have());
    }

    CCountingResource::Release();
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\info.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    info.h

Abstract:

    Service query and enum info related function prototypes.

Author:

    Rita Wong (ritaw)     06-Apr-1992

Revision History:

--*/

#ifndef SCINFO_INCLUDED
#define SCINFO_INCLUDED

//
// Service status structures union
//
typedef union
{
    LPSERVICE_STATUS           Regular;
    LPSERVICE_STATUS_PROCESS   Ex;
}
STATUS_UNION, *LPSTATUS_UNION;


//
// Function Prototypes
//

DWORD
ScQueryServiceStatus(
    IN  LPSERVICE_RECORD ServiceRecord,
    OUT STATUS_UNION     ServiceStatus,
    IN  BOOL             fExtendedStatus
    );

VOID
ScGetBootAndSystemDriverState(
    VOID
    );

#endif // #ifndef SCINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\info.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    info.cxx

Abstract:

    Contains entry points for REnumServicesStatusW and RQueryServiceStatus as
    well as support routines.  This file contains the following external
    functions:
        REnumServicesStatusW
        REnumServicesStatusExW
        REnumServiceGroupW
        RQueryServiceStatus
        RQueryServiceStatusEx
        REnumDependentServicesW

Author:

    Dan Lafferty (danl)     25-Jan-1992

Environment:

    User Mode -Win32

Revision History:
    25-Apr-1996     AnirudhS
        Don't popup messages or log events for boot start and system start
        drivers that are disabled in the current hardware profile.
    14-Feb-1996     AnirudhS
        Add REnumServiceGroupW.
    10-Feb-1993     Danl
        Use ROUND_DOWN_COUNT to properly align the enumeration buffer.
    10-Apr-1992     JohnRo
        Use ScImagePathsMatch() to allow mixed-case image names.
        Changed names of some <valid.h> macros.
    25-Jan-1992     danl
        Created.

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <stdlib.h>     // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <align.h>      // ROUND_DOWN_COUNT
#include <sclib.h>      // ScCopyStringToBufferW(), etc.
#include <valid.h>      // ENUM_STATE_INVALID
#include "info.h"       // ScQueryServiceStatus
#include "depend.h"     // ScEnumDependents, ScInHardwareProfile
#include "driver.h"     // ScGetDriverStatus
#include <cfgmgr32.h>   // PNP manager functions
#include <scwow.h>      // 32/64-bit interop structures


//
// DEFINITIONS
//

#define  IS_NOGROUP_STRING(string)      (string[0] == L'\0')


//
// Local function declarations
//

DWORD
REnumServiceGroupHelp (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCWSTR         lpLoadOrderGroup OPTIONAL,
    IN      BOOL            fExtended
    );


//
// Function implementations
//

DWORD
REnumServicesStatusW (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL
    )

/*++

Routine Description:

    This function lists the services installed in the Service Controller's
    database.  The status of each service is returned with the name of
    the service.

Arguments:

    hSCManager - This is a handle to the service controller.  It must
        have been opened with SC_MANAGER_ENUMERATE_SERVICE access.

    dwServiceType - Value to select the type of services to enumerate.
        It must be one of the bitwise OR of the following values:
        SERVICE_WIN32 - enumerate Win32 services only.
        SERVICE_DRIVER - enumerate Driver services only.

    dwServiceState - Value so select the services to enumerate based on the
        running state.  It must be one or the bitwise OR of the following
        values:
        SERVICE_ACTIVE - enumerate services that have started.
        SERVICE_INACTIVE - enumerate services that are stopped.

    lpBuffer - A pointer to a buffer to receive an array of enum status
        (or service) entries.

    cbBufSize - Size of the buffer in bytes pointed to by lpBuffer.

    pcbBytesNeeded - A pointer to a location where the number of bytes
        left (to be enumerated) is to be placed.  This indicates to the
        caller how large the buffer must be in order to complete the
        enumeration with the next call.

    lpServicesReturned - A pointer to a variable to receive the number of
        of service entries returned.

    lpResumeIndex - A pointer to a variable which on input specifies the
        index of a service entry to begin enumeration.  An index of 0
        indicates to start at the beginning.  On output, if this function
        returns ERROR_MORE_DATA, the index returned is the next service
        entry to resume the enumeration.  The returned index is 0 if this
        function returns a NO_ERROR.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in.
        (such as dwServiceType).

    ERROR_INVALID_HANDLE - The specified handle was invalid.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpBuffer, pcbReturned, pcbBytesNeeded,
        lpBuffer, ReturnedServerName, and lpResumeIndex.


--*/
{
    return REnumServiceGroupHelp(hSCManager,
                                 dwServiceType,
                                 dwServiceState,
                                 lpBuffer,
                                 cbBufSize,
                                 pcbBytesNeeded,
                                 lpServicesReturned,
                                 lpResumeIndex,
                                 NULL,          // Enumerate everything
                                 FALSE);        // Regular (non-Ex) enumeration
}


DWORD
REnumServicesStatusExW (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      SC_ENUM_TYPE    InfoLevel,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCWSTR         lpLoadOrderGroup
    )
/*++

Routine Description:

    This function is analogous to REnumServicesStatusW, with the data
    being enumerated being dependent upon the InfoLevel parameter

Arguments:

    InfoLevel - An enumerated type that determines what service attributes
        are enumerated:

            SC_ENUM_PROCESS_INFO - Enumerates all the service information from
                REnumServicesStatusW plus the service's PID and flags

    lpLoadOrderGroup - Only enumerate services belonging to the given group.
        If this parameter is the empty string, services not belonging to
        a group are enumerated.  If this parameter is NULL, no attention
        is paid to group.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in.
        (such as dwServiceType).

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_INVALID_LEVEL - The specified InfoLevel is invalid

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpBuffer, pcbReturned, pcbBytesNeeded,
        lpBuffer, ReturnedServerName, and lpResumeIndex.


--*/
{
    switch (InfoLevel) {

        case SC_ENUM_PROCESS_INFO:

            return REnumServiceGroupHelp(hSCManager,
                                         dwServiceType,
                                         dwServiceState,
                                         lpBuffer,
                                         cbBufSize,
                                         pcbBytesNeeded,
                                         lpServicesReturned,
                                         lpResumeIndex,
                                         lpLoadOrderGroup,
                                         TRUE);     // Extended enumeration

        default:
            
            return ERROR_INVALID_LEVEL;
    }
}


DWORD
REnumServiceGroupW (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCWSTR         lpLoadOrderGroup OPTIONAL
    )
/*++

Routine Description:

    This function lists the services installed in the Service Controllers
    database that belong to a specified group.  The status of each service
    is returned with the name of the service.

Arguments:

    Same as REnumServicesStatusW and one additional argument:

    lpLoadOrderGroup - Only services belonging to this group are included in
        the enumeration.  If this is NULL services are enumerated
        regardless of their group membership.

Return Value:

    Same as REnumServicesStatusW plus one more:

    ERROR_SERVICE_DOES_NOT_EXIST - the group specified by lpLoadOrderGroup
        does not exist.

--*/
{
    return REnumServiceGroupHelp(hSCManager,
                                 dwServiceType,
                                 dwServiceState,
                                 lpBuffer,
                                 cbBufSize,
                                 pcbBytesNeeded,
                                 lpServicesReturned,
                                 lpResumeIndex,
                                 lpLoadOrderGroup,
                                 FALSE);    // Regular (non-Ex) enumeration
}


DWORD
REnumServiceGroupHelp (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCWSTR         lpLoadOrderGroup OPTIONAL,
    IN      BOOL            fExtended
    )
/*++

Routine Description:

    Helper function that does the work for REnumServiceGroup,
    REnumServicesStatusW, and REnumServicesStatusExW

Arguments:

    Same as REnumServiceGroup and one additional argument

    fExtended -- TRUE if this function was called from the extended version
                 of REnumServicesStatus, FALSE if not

Return Value:

    Same as REnumServiceGroupW

--*/
{
    DWORD                         status = NO_ERROR;
    BOOL                          copyStatus;
    LPSERVICE_RECORD              serviceRecord;
    LPLOAD_ORDER_GROUP            Group = NULL;      // group being enumerated, if any
    DWORD                         resumeIndex = 0;   // resume handle value
    LPENUM_SERVICE_STATUS_WOW64   pNextEnumRec;      // next enum record
    LPENUM_SERVICE_STATUS_WOW64   pEnumRec;          // current regular enum record
    LPWSTR                        pStringBuf;        // works backwards in enum buf
    DWORD                         serviceState;      // temp state holder
    BOOL                          exitEarly = FALSE; // buffer is full - enum not done.
    BOOL                          fNoGroup  = FALSE; // enumerate services not in a group

#ifdef TIMING_TEST
    DWORD       TickCount1;
    DWORD       TickCount2;

    TickCount1 = GetTickCount();
#endif // TIMING_TEST

    SC_LOG(TRACE," Inside REnumServicesStatusW\n",0);

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //

    if (!ScIsValidScManagerHandle(hSCManager))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Check for invalid parameters. The ServiceType and Service State are
    // invalid if neither of the bit masks are set, or if any bit outside
    // of the bitmask range is set.
    //
    if (SERVICE_TYPE_MASK_INVALID(dwServiceType)) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (ENUM_STATE_MASK_INVALID(dwServiceState)) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Was the handle opened with SC_MANAGER_ENUMERATE_SERVICE access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hSCManager)->AccessGranted,
              SC_MANAGER_ENUMERATE_SERVICE
              )) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // Initialize some of the return parameters.
    //
    *lpServicesReturned = 0;
    *pcbBytesNeeded     = 0;

    if (ARGUMENT_PRESENT(lpResumeIndex)) {
        resumeIndex = *lpResumeIndex;
    }


    //
    // If a group name was specified, find the group record.
    //

    if (ARGUMENT_PRESENT(lpLoadOrderGroup)) {

        if (!IS_NOGROUP_STRING(lpLoadOrderGroup)) {

            ScGroupListLock.GetShared();
            Group = ScGetNamedGroupRecord(lpLoadOrderGroup);
            if (Group == NULL) {
                ScGroupListLock.Release();
                return(ERROR_SERVICE_DOES_NOT_EXIST);
            }
        }
        else {

            //
            // Enumerate services not in a group
            //
            fNoGroup = TRUE;
        }
    }

    //
    // Get a shared (read) lock on the database so that it cannot be changed
    // while we're gathering up data.
    //
    {
        CServiceListSharedLock LLock;
        CServiceRecordSharedLock RLock;

        //
        // Point to the start of the database.
        //

        if (!ScFindEnumStart(resumeIndex, &serviceRecord))
        {
            //
            // There are no service records beyond the resume index.
            //
            goto CleanExit;
        }

        //
        // Set up a pointer for EnumStatus Structures at the top of the
        // buffer, and Strings at the bottom of the buffer.
        //
        cbBufSize  = ROUND_DOWN_COUNT(cbBufSize, ALIGN_WCHAR);
        pEnumRec   = (LPENUM_SERVICE_STATUS_WOW64) lpBuffer;
        pStringBuf = (LPWSTR)((LPBYTE)lpBuffer + cbBufSize);

        //
        // Loop through, gathering Enum Status into the return buffer.
        //

        do
        {
            //
            // Examine the data in the service record to see if it meets the
            // criteria of the passed in keys.
            //

            //
            // Since driver state can be modified through other means than the
            // SCM, make sure we've got the most recent state information if we're
            // enumerating drivers.
            //

            if (serviceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER)
            {
                //
                // It's OK to use CServiceRecordTEMPORARYEXCLUSIVELOCK
                // because the only field of the service record that we
                // are relying on here is the SERVICE_DRIVER bits, and
                // those are never changed.
                //

                CServiceRecordTEMPORARYEXCLUSIVELOCK Lock;

                //
                // Ignore the error and don't ask for the updated info since we'll
                // use the fields in the serviceRecord below anyhow for comparisons
                // and copying.  If the call succeeded, they'll be updated already.
                // If not, we'll end up using the most recent state info we have.
                //

                ScGetDriverStatus(serviceRecord, NULL);
            }


            serviceState = SERVICE_INACTIVE;
            if (serviceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED)
            {
                serviceState = SERVICE_ACTIVE;
            }

            //
            // If the service record meets the criteria of the passed in key,
            // put its information into the return buffer.  The three checks
            // below are:
            //
            //  1.  Enumerate everything
            //  2.  Enumerate members of a certain group only, so check to see
            //      if the current service is a member of that group
            //  3.  Enumerate only services that aren't in a group, so check to
            //      see if the current service qualifies (NULL MemberOfGroup
            //      field)
            //
            if ((Group == NULL && !fNoGroup
                    || Group && Group == serviceRecord->MemberOfGroup
                    || fNoGroup && !serviceRecord->MemberOfGroup)
                &&
                ((dwServiceType & serviceRecord->ServiceStatus.dwServiceType) != 0)
                &&
                ((dwServiceState & serviceState) != 0))
            {
                //
                // Determine if there is room for any string data in the buffer.
                //

                if (fExtended)
                {
                    pNextEnumRec =
                        (LPENUM_SERVICE_STATUS_WOW64)
                            ((LPENUM_SERVICE_STATUS_PROCESS_WOW64) pEnumRec + 1);
                }
                else
                {
                    pNextEnumRec = pEnumRec + 1;
                }

                if ((LPWSTR) pNextEnumRec >= pStringBuf)
                {
                    exitEarly = TRUE;
                    break;
                }

                //
                // Copy the ServiceName string data.
                //
                copyStatus = ScCopyStringToBufferW(
                                serviceRecord->ServiceName,
                                (DWORD) wcslen(serviceRecord->ServiceName),
                                (LPWSTR) pNextEnumRec,
                                &pStringBuf,
                                (LPWSTR *) &(pEnumRec->dwServiceNameOffset),
                                lpBuffer);

                if (copyStatus == FALSE)
                {
                    SC_LOG(TRACE,
                        "REnumServicesStatusW:NetpCopyStringToBuf not enough room\n",0);
                    exitEarly = TRUE;
                    break;
                }

                //
                // Copy the DisplayName string data.
                //
                copyStatus = ScCopyStringToBufferW(
                                serviceRecord->DisplayName,
                                (DWORD) wcslen(serviceRecord->DisplayName),
                                (LPWSTR) pNextEnumRec,
                                &pStringBuf,
                                (LPWSTR *) &(pEnumRec->dwDisplayNameOffset),
                                lpBuffer);

                if (copyStatus == FALSE)
                {
                    SC_LOG(TRACE,
                        "REnumServicesStatusW:NetpCopyStringToBuf not enough room\n",0);
                    exitEarly = TRUE;
                    break;
                }
                else
                {
                    //
                    // Copy the rest of the status information.
                    //

                    LPSERVICE_STATUS_PROCESS   lpStatusEx = NULL;

                    //
                    // If we're enumerating the extended status, assign the
                    // "helper variable" and initialize the extra fields
                    //

                    if (fExtended)
                    {
                        lpStatusEx = 
                            &((LPENUM_SERVICE_STATUS_PROCESS_WOW64)pEnumRec)->ServiceStatusProcess;

                        lpStatusEx->dwProcessId    = 0;
                        lpStatusEx->dwServiceFlags = 0;
                    }

                    if (serviceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER)
                    {
                        RtlCopyMemory(&(pEnumRec->ServiceStatus),
                                      &(serviceRecord->ServiceStatus),
                                      sizeof(SERVICE_STATUS));
                    }
                    else
                    {
                        //
                        // Otherwise, just copy what is already in the service
                        // record.
                        //

                        RtlCopyMemory(
                            &(pEnumRec->ServiceStatus),
                            &(serviceRecord->ServiceStatus),
                            sizeof(SERVICE_STATUS));

                        if (fExtended)
                        {
                            //
                            // Only assign the PID and flags if there's an
                            // image record for the service.  If there's no
                            // image record, the service isn't running.
                            //
                            if (serviceRecord->ImageRecord)
                            {
                                lpStatusEx->dwProcessId = serviceRecord->ImageRecord->Pid;

                                if (serviceRecord->ImageRecord->ImageFlags 
                                    &
                                    IS_SYSTEM_SERVICE)
                                {
                                    lpStatusEx->dwServiceFlags |=
                                        SERVICE_RUNS_IN_SYSTEM_PROCESS;
                                }
                            }
                        }
                    }

                    (*lpServicesReturned)++;
                    resumeIndex = serviceRecord->ResumeNum;

                    //
                    // Get Location for next Enum Record in the return buffer.
                    // Note that since we dealt with the pointer addition on
                    // pNextEnumRec above, it doesn't matter that this is
                    // being cast to an LPENUM_SERVICE_STATUS_WOW64, even if
                    // we're returning the extended status.
                    //
                    pEnumRec = (LPENUM_SERVICE_STATUS_WOW64) pNextEnumRec;

                    //
                    // TODO:  Determine how many bytes are being marshalled.
                    //        This is only worthwhile if RPC will pack the
                    //        buffer tighter than this code does.
                    //        Since packstr loads strings from the end of
                    //        the buffer,  we end up using the whole width of
                    //        it - even if the middle is basically empty.
                    //
                }

            }

            //
            // Go to the next service record.
            //
            serviceRecord = serviceRecord->Next;
        }
        while (serviceRecord != NULL);

        //
        // If we did not enum the whole database, then
        // determine how large a buffer is needed to complete the database on
        // the next call.
        //
        if (exitEarly) {

            do {
                //
                // Examine the data in the service record to see if it meets the
                // criteria of the passed in keys.
                //

                serviceState = SERVICE_INACTIVE;
                if (serviceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                    serviceState = SERVICE_ACTIVE;
                }

                //
                // If the service record meets the criteria of the passed in key,
                // add the number of bytes to the running sum.  Note that this
                // check (and the associated rules) are the same as the one above.
                //
                if ((Group == NULL && !fNoGroup
                        || Group && Group == serviceRecord->MemberOfGroup
                        || fNoGroup && !serviceRecord->MemberOfGroup)
                    &&
                    ((dwServiceType & serviceRecord->ServiceStatus.dwServiceType) != 0)
                    &&
                    ((dwServiceState & serviceState) != 0))
                {
                    *pcbBytesNeeded += (DWORD)((fExtended ? sizeof(ENUM_SERVICE_STATUS_PROCESS_WOW64) :
                                                     sizeof(ENUM_SERVICE_STATUS_WOW64)) +
                                        WCSSIZE(serviceRecord->ServiceName) +
                                        WCSSIZE(serviceRecord->DisplayName));

                }

                //
                // Go to the next service record.
                //
                serviceRecord = serviceRecord->Next;
            }
            while (serviceRecord != NULL);

        } // exitEarly

        else {

            //
            // exitEarly == FALSE (we went through the whole database)
            //
            // If no records were read, return a successful status.
            //
            if (*lpServicesReturned == 0) {
                goto CleanExit;
            }
        }
    } // Release RLock and LLock


    //
    // Determine the proper return status.  Indicate if there is more data
    // to enumerate than would fit in the buffer.
    //
    if(*pcbBytesNeeded != 0) {
        status = ERROR_MORE_DATA;
    }

    //
    // update the ResumeHandle
    //
    if (ARGUMENT_PRESENT(lpResumeIndex)) {
        if (status == NO_ERROR) {
            *lpResumeIndex = 0;
        }
        else {
            *lpResumeIndex = resumeIndex;
        }
    }

CleanExit:

    if (ARGUMENT_PRESENT(lpLoadOrderGroup) && !IS_NOGROUP_STRING(lpLoadOrderGroup)) {
        ScGroupListLock.Release();
    }

#ifdef TIMING_TEST
    TickCount2 = GetTickCount();
    DbgPrint("\n[SC_TIMING] Time for Enum = %d\n",TickCount2-TickCount1);
#endif // TIMING_TEST

    return (status);
}


DWORD
RQueryServiceStatus(
    IN  SC_RPC_HANDLE     hService,
    OUT LPSERVICE_STATUS  lpServiceStatus
    )

/*++

Routine Description:

    This function returns the service status information maintained by
    the Service Controller.  The status information will be the last status
    information that the service reported to the Service Controller.
    The service may have just changed its status and may not have updated
    the Service Controller yet.

Arguments:

    hService - Handle obtained from a previous CreateService or OpenService
        call.

    lpServiceStatus - A pointer to a buffer to receive a SERVICE_STATUS
        information structure.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_QUERY_STATUS access.

    ERROR_INSUFFICIENT_BUFFER - The supplied output buffer is too small
        for the SERVICE_STATUS information structure.  Nothing is written
        to the supplied output buffer.

--*/
{
    LPSERVICE_RECORD    serviceRecord;
    STATUS_UNION        ServiceStatus;

    if (ScShutdownInProgress)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Was the handle opened with SERVICE_QUERY_STATUS access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              SERVICE_QUERY_STATUS
              )) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Get the Service Status from the database.
    //
    serviceRecord = ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    ServiceStatus.Regular = lpServiceStatus;

    return ScQueryServiceStatus(serviceRecord, ServiceStatus, FALSE);
}


DWORD
RQueryServiceStatusEx(
    IN      SC_RPC_HANDLE        hService,
    IN      SC_STATUS_TYPE       InfoLevel,
    OUT     LPBYTE               lpBuffer,
    IN      DWORD                cbBufSize,
    OUT     LPDWORD              pcbBytesNeeded
    )

/*++

Routine Description:

    This function is analogous to RQueryServiceStatus, but may return
    different status information about the service based on the InfoLevel
    
Arguments:

    hService       - Handle obtained from a previous CreateService or OpenService
                     call.

    InfoLevel      - An enumerated type that determines what service attributes
                     are returned:

                         SC_STATUS_PROCESS_INFO - Returns all the service information
                             from RQueryServiceStatus plus the service's PID and flags

    lpBuffer       - Buffer in which to put the status information.

    cbBufSize      - Size of the buffer, in bytes

    pcbBytesNeeded - Number of bytes needed to hold all the status information.
                     Filled in on both success and failure.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_QUERY_STATUS access.

    ERROR_INSUFFICIENT_BUFFER - The supplied output buffer is too small
        for the SERVICE_STATUS information structure.  Nothing is written
        to the supplied output buffer.

    ERROR_INVALID_PARAMETER - The cbSize field in the lpServiceStatusEx
        structure is not valid

    ERROR_INVALID_LEVEL - InfoLevel contains an unsupported value.  Note that
        this can only happen if there is a bug in RPC

--*/
{
    LPSERVICE_RECORD    serviceRecord;

    if (ScShutdownInProgress)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Was the handle opened with SERVICE_QUERY_STATUS access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              SERVICE_QUERY_STATUS
              )) {

        return ERROR_ACCESS_DENIED;
    }

    //
    // Get the Service Status from the database.
    //
    serviceRecord = ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    switch (InfoLevel) {

        case SC_STATUS_PROCESS_INFO:
        {
            STATUS_UNION    ServiceStatus;

            *pcbBytesNeeded = sizeof(SERVICE_STATUS_PROCESS);

            if (cbBufSize < sizeof(SERVICE_STATUS_PROCESS)) {
                return ERROR_INSUFFICIENT_BUFFER;
            }

            ServiceStatus.Ex = (LPSERVICE_STATUS_PROCESS) lpBuffer;

            return ScQueryServiceStatus(serviceRecord, ServiceStatus, TRUE);
        }

        default:
            return ERROR_INVALID_LEVEL;
    }
}


DWORD
ScQueryServiceStatus(
    IN  LPSERVICE_RECORD ServiceRecord,
    OUT STATUS_UNION     ServiceStatus,
    IN  BOOL             fExtendedStatus
    )
/*++

Routine Description:

    This function copies the service status structure to the output
    pointer after having acquired a shared lock.

Arguments:

    ServiceRecord - Supplies a pointer to the service record.

    ServiceStatus - Receives the service status structure.

    fExtendedStatus - TRUE if the function was called from
        RQueryServiceStatusEx, FALSE otherwise

Return Value:

    None.

--*/
{
    SC_ASSERT(! ScServiceRecordLock.Have());

    //
    // Sanity check that the contents of the union are stored
    // in the same set of 4 bytes since they're both pointers
    //
    SC_ASSERT((LPBYTE)ServiceStatus.Ex == (LPBYTE)ServiceStatus.Regular);

    if (fExtendedStatus) {

        ServiceStatus.Ex->dwProcessId    = 0;
        ServiceStatus.Ex->dwServiceFlags = 0;
    }

    //
    // If this request is for a driver, call ScGetDriverStatus and return.
    //
    if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER) {

        CServiceRecordExclusiveLock RLock;

        return ScGetDriverStatus(ServiceRecord,
                                 ServiceStatus.Regular);
    }
    else {

        CServiceRecordSharedLock RLock;

        //
        // Copy the latest status into the return buffer.
        //
        RtlCopyMemory(
            ServiceStatus.Regular,
            &(ServiceRecord->ServiceStatus),
            sizeof(SERVICE_STATUS));

        if (fExtendedStatus) {

            //
            // Copy the PID and flags into the structure -- if the service
            // hasn't started yet (i.e., there's no ImageRecord), the the PID
            // and the flags will be 0
            //
            if (ServiceRecord->ImageRecord) {

                ServiceStatus.Ex->dwProcessId = ServiceRecord->ImageRecord->Pid;

                if (ServiceRecord->ImageRecord->ImageFlags & IS_SYSTEM_SERVICE) {

                    ServiceStatus.Ex->dwServiceFlags |= SERVICE_RUNS_IN_SYSTEM_PROCESS;
                }
            }
        }
    }

    return NO_ERROR;
}


DWORD
REnumDependentServicesW(
    IN      SC_RPC_HANDLE   hService,
    IN      DWORD           dwServiceState,
    OUT     LPBYTE          lpServices,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned
    )
/*++

Routine Description:

    This function enumerates the services which are dependent on the
    specified service.  The list returned is an ordered list of services
    to be stopped before the specified service can be stopped.  This
    list has to be ordered because there may be dependencies between
    the services that depend on the specified service.

Arguments:

    dwServiceState - Value so select the services to enumerate based on the
        running state.  It must be one or the bitwise OR of the following
        values:
        SERVICE_ACTIVE - enumerate services that have started.
        SERVICE_INACTIVE - enumerate services that are stopped.

    lpServices - A pointer to a buffer to receive an array of enum status
        (or service) entries.

    cbBufSize - Size of the buffer in bytes pointed to by lpBuffer.

    pcbBytesNeeded - A pointer to a location where the number of bytes
        left (to be enumerated) is to be placed.  This indicates to the
        caller how large the buffer must be in order to complete the
        enumeration with the next call.

    lpServicesReturned - A pointer to a variable to receive the number of
        of service entries returned.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in
        for the service state.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpServices, pcbServicesReturned, and
        pcbBytesNeeded.

--*/
{
    DWORD            status;
    LPSERVICE_RECORD Service;

    LPENUM_SERVICE_STATUS_WOW64 EnumRecord = (LPENUM_SERVICE_STATUS_WOW64) lpServices;
    LPWSTR                      EndOfVariableData;

    cbBufSize         = ROUND_DOWN_COUNT(cbBufSize, ALIGN_WCHAR);
    EndOfVariableData = (LPWSTR) ((DWORD_PTR) EnumRecord + cbBufSize);

    SC_LOG(TRACE," Inside REnumDependentServicesW\n",0);

    if (ScShutdownInProgress)
    {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    Service = ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    //
    // Service State is invalid if neither of the bit masks is set, or if any bit
    // outside of the bitmask range is set.
    //
    if (ENUM_STATE_MASK_INVALID(dwServiceState)) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Was the handle opened with SERVICE_ENUMERATE_DEPENDENTS access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              SERVICE_ENUMERATE_DEPENDENTS
              )) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Initialize returned values
    //
    *lpServicesReturned = 0;
    *pcbBytesNeeded = 0;

    status = NO_ERROR;

    //
    // Get a shared (read) lock on the database so that it cannot be changed
    // while we're gathering up data.
    //
    {
        CServiceRecordSharedLock RLock;

        ScEnumDependents(
            Service,
            EnumRecord,
            dwServiceState,
            lpServicesReturned,
            pcbBytesNeeded,
            &EnumRecord,
            &EndOfVariableData,
            &status
            );
    }

    if (status == NO_ERROR)
    {
        *pcbBytesNeeded = 0;
    }

    return status;
}

VOID
ScGetBootAndSystemDriverState(
    VOID
    )
/*++

Routine Description:

    This function is called once at service controller init time to get
    the latest state of boot and system drivers.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status;
    CServiceListSharedLock LLock;   // to avoid assertions

    //
    // ScGetDriverStatus assumes that the exclusive database lock is claimed.
    //
    CServiceRecordExclusiveLock RLock;

    FOR_ALL_SERVICES(Service)
    {
        if ((Service->StartType == SERVICE_BOOT_START ||
             Service->StartType == SERVICE_SYSTEM_START)

             &&

            (Service->ServiceStatus.dwServiceType == SERVICE_KERNEL_DRIVER ||
             Service->ServiceStatus.dwServiceType == SERVICE_FILE_SYSTEM_DRIVER))
        {
            status = ScGetDriverStatus(
                         Service,
                         NULL
                         );

            if (status == NO_ERROR)
            {
                if (Service->ServiceStatus.dwCurrentState == SERVICE_STOPPED
                     &&
                    ScInHardwareProfile(Service->ServiceName, CM_GETIDLIST_DONOTGENERATE))
                {
                    Service->ServiceStatus.dwControlsAccepted = 0;
                    Service->ServiceStatus.dwWin32ExitCode = ERROR_GEN_FAILURE;

                    //
                    // For popup after user has logged on to indicate that some
                    // service started at boot has failed.
                    //
                    if (Service->ErrorControl == SERVICE_ERROR_NORMAL ||
                        Service->ErrorControl == SERVICE_ERROR_SEVERE ||
                        Service->ErrorControl == SERVICE_ERROR_CRITICAL)
                    {
                        (void) ScAddFailedDriver(Service->ServiceName);
                        ScPopupStartFail = TRUE;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\lockapi.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    lockapi.h

Abstract:

    SC Manager database lock worker routines.

Author:

    Rita Wong (ritaw)     06-Aug-1992

Revision History:

--*/

#ifndef SCLOCKAPI_INCLUDED
#define SCLOCKAPI_INCLUDED

//
// Function Prototypes
//

DWORD
ScLockDatabase(
    IN  BOOL LockedByScManager,
    IN  LPWSTR DatabaseName,
    OUT LPSC_RPC_LOCK lpLock
    );

VOID
ScUnlockDatabase(
    IN OUT LPSC_RPC_LOCK lpLock
    );

DWORD
ScGetLockOwner(
    IN  PSID UserSid OPTIONAL,
    OUT LPWSTR *LockOwnerName
    );

#endif // #ifndef SCLOCKAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\lockapi.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    LockAPI.cxx

Abstract:

    This file contains the Service Controller's lock APIs:

        RLockServiceDatabase
        RQueryServiceLockStatusW
        RUnlockServiceDatabase
        SC_RPC_LOCK_rundown

Author:

    John Rogers (JohnRo) 14-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    26-Mar-1992 danl
        Created the stubbed out version for RPC.
    17-Apr-1992 JohnRo
        Split lock APIs out from config API stubs in CfgAPI.c.
        Did initial coding of all lock APIs.
    22-Apr-1992 JohnRo
        Made changes suggested by PC-LINT.
        Use SC_LOG0(), etc.
    06-Aug-1992 ritaw
        Completed the code.

--*/


//
// INCLUDES
//

#include "precomp.hxx"
extern "C" {
#include <ntlsa.h>      // LsaLookupSids
}
#include <stdlib.h>     // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <sclib.h>      // ScCopyStringToBufferW().
#include <time.h>       // time().
#include "account.h"    // SCDOMAIN_USERNAME_SEPARATOR
#include "lockapi.h"    // ScLockDatabase
#include "scsec.h"      // ScGetClientSid

#define SC_MANAGER_USERNAME    L".\\NT Service Control Manager"


#define ScDatabaseNamesMatch(a,b)  (_wcsicmp( (a), (b) ) == 0)


// Macros to lock and unlock the lock list:


#define LOCK_API_LOCK_LIST_SHARED( comment ) \
    { \
        ScServiceRecordLock.GetShared(); \
    }

#define LOCK_API_LOCK_LIST_EXCLUSIVE( comment ) \
    { \
        ScServiceRecordLock.GetExclusive(); \
    }

#define UNLOCK_API_LOCK_LIST( comment ) \
    { \
        ScServiceRecordLock.Release(); \
    }


typedef struct _API_LOCK {
    struct _API_LOCK    *Prev;
    struct _API_LOCK    *Next;
    DWORD               Signature;         // Must be API_LOCK_SIGNATURE.
    LPWSTR              DatabaseName;
    time_t              TimeWhenLocked;    // seconds since 1970.
    PSID                LockOwnerSid;      // SID.  It is NULL if SC
                                           //     Manager grabbed the lock
} API_LOCK, *PAPI_LOCK, *LPAPI_LOCK;

#define API_LOCK_SIGNATURE      0x4C697041 // "ApiL" in ASCII.

//
// List of API_LOCK structures.  This list is locked by the macros above.
//
LPAPI_LOCK ScGlobalApiLockList = NULL;


DWORD
ScCreateLock(
    IN  BOOL IsServiceController,
    IN  LPWSTR DatabaseName,
    IN  PSID UserSid OPTIONAL,
    OUT LPSC_RPC_LOCK lpLock
    );


#if DBG
VOID
ScDumpLockList(
    VOID
    );
#endif


LPAPI_LOCK
ScFindApiLockForDatabase(
    IN      LPWSTR          DatabaseName
    )
/*++

Routine Description:


Arguments:


Return Value:

    Pointer to entry in the list (or NULL if not found).

Note:

    The caller must have a lock (shared or exclusive) for the api lock list.

--*/
{
    LPAPI_LOCK          apiLockEntry;

    apiLockEntry = ScGlobalApiLockList;
    while (apiLockEntry != NULL) {
        SC_ASSERT( apiLockEntry->Signature == API_LOCK_SIGNATURE );
        if (ScDatabaseNamesMatch( DatabaseName, apiLockEntry->DatabaseName) ) {
            return (apiLockEntry);
        }
        apiLockEntry = apiLockEntry->Next;
    }

    return (NULL);
}


DWORD
RLockServiceDatabase(
    IN      SC_RPC_HANDLE   hSCManager,
    OUT     LPSC_RPC_LOCK   lpLock
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD               status;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hSCManager;


    SC_ASSERT( lpLock != NULL );

    *lpLock = NULL;
    if ( !ScIsValidScManagerHandle( hSCManager ) ) {
        return (ERROR_INVALID_HANDLE);
    }

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              SC_MANAGER_LOCK
              )) {
        return (ERROR_ACCESS_DENIED);
    }

    status = ScLockDatabase(
                 FALSE,
                 serviceHandleStruct->Type.ScManagerObject.DatabaseName,
                 lpLock
                 );

    SC_LOG0( LOCK_API, "Database Lock is ON (from API)\n");

    return status;
}


DWORD
RQueryServiceLockStatusW(
    IN  SC_RPC_HANDLE                   hSCManager,
    OUT LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    IN  DWORD                           cbBufSize,
    OUT LPDWORD                         pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD status;

    LPAPI_LOCK          apiLockEntry;
    DWORD               allocSize;
    LPWSTR              databaseName;

    LPWSTR              endOfVariableData;
    LPWSTR              fixedDataEnd;

    LPWSTR              lockOwner;
    DWORD               lockOwnerSize;

    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hSCManager;


    if ( !ScIsValidScManagerHandle( hSCManager ) ) {
        return (ERROR_INVALID_HANDLE);
    } else if (lpLockStatus == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (pcbBytesNeeded == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              SC_MANAGER_QUERY_LOCK_STATUS
              )) {
        return (ERROR_ACCESS_DENIED);
    }

    LOCK_API_LOCK_LIST_SHARED( "RQueryServiceLockStatusW start" );

    databaseName = serviceHandleStruct->Type.ScManagerObject.DatabaseName;
    SC_ASSERT( databaseName != NULL );


    apiLockEntry = ScFindApiLockForDatabase( databaseName );


    if (apiLockEntry == NULL) {

        allocSize = sizeof(QUERY_SERVICE_LOCK_STATUSW) + sizeof(WCHAR);

        *pcbBytesNeeded = allocSize;

        if (cbBufSize < allocSize) {
            UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW too small" );
            return (ERROR_INSUFFICIENT_BUFFER);
        }

        lpLockStatus->fIsLocked = FALSE;

        fixedDataEnd = (LPWSTR) (lpLockStatus + 1);

        endOfVariableData = (LPWSTR) ((LPBYTE)lpLockStatus + allocSize);

        if (! ScCopyStringToBufferW (
                NULL,
                0,
                fixedDataEnd,
                &endOfVariableData,
                &lpLockStatus->lpLockOwner,
                NULL
                )) {

            SC_ASSERT( FALSE );
        }

        lpLockStatus->dwLockDuration = 0;

        UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW not found" );
        return (NO_ERROR);
    }


    SC_ASSERT( apiLockEntry->Signature == API_LOCK_SIGNATURE );

    status = ScGetLockOwner(
                 apiLockEntry->LockOwnerSid,
                 &lockOwner
                 );

    if (status != NO_ERROR) {
        UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW failed get owner" );
        return status;
    }

    lockOwnerSize = (DWORD) WCSSIZE(lockOwner);

    SC_ASSERT( lockOwnerSize > 2 );        //  min is ".\x" (domain\user).

    allocSize = sizeof(QUERY_SERVICE_LOCK_STATUSW) + lockOwnerSize;

    *pcbBytesNeeded = allocSize;

    if (allocSize > cbBufSize) {

        LocalFree(lockOwner);
        UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW too small" );
        return (ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // Build the QUERY_SERVICE_LOCK_STATUS structure.
    //
    lpLockStatus->fIsLocked = TRUE;

    lpLockStatus->dwLockDuration =
            (DWORD)(time(NULL) - apiLockEntry->TimeWhenLocked);

    fixedDataEnd = (LPWSTR) (lpLockStatus + 1);

    endOfVariableData = (LPWSTR) ((LPBYTE)lpLockStatus + allocSize);

    if (! ScCopyStringToBufferW (
             lockOwner,
             (DWORD) wcslen(lockOwner),
             fixedDataEnd,
             &endOfVariableData,
             &lpLockStatus->lpLockOwner,
             NULL
             )) {

        SC_ASSERT( FALSE );
    }

    LocalFree(lockOwner);

    UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW done" );

    return (NO_ERROR);
}


DWORD
RUnlockServiceDatabase(
    IN OUT  LPSC_RPC_LOCK   lpLock
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    LPAPI_LOCK apiLockEntry;

    if (lpLock == NULL) {
        return (ERROR_INVALID_SERVICE_LOCK);
    }
    apiLockEntry = * (LPAPI_LOCK *) (LPVOID) lpLock;
    if (apiLockEntry->Signature != API_LOCK_SIGNATURE) {
        SC_LOG1( ERROR, "RUnlockServiceDatabase: lock w/o signature at "
                FORMAT_LPVOID "\n", (LPVOID) lpLock );
        return (ERROR_INVALID_SERVICE_LOCK);
    }

    //
    // We're going to update the linked list, so keep other threads out.
    //
    LOCK_API_LOCK_LIST_EXCLUSIVE( "RUnlockServiceDatabase start" );

    //
    // Remove the entry from the lock list.  This has the effect of
    // unlocking this database.
    //
    if (apiLockEntry->Prev != NULL) {
        apiLockEntry->Prev->Next = apiLockEntry->Next;
    }
    if (apiLockEntry->Next != NULL) {
        apiLockEntry->Next->Prev = apiLockEntry->Prev;
    }
    if ( (apiLockEntry->Next == NULL) && (apiLockEntry->Prev == NULL) ) {
        ScGlobalApiLockList = NULL;
    }

    //
    // Free the storage we allocated for this entry.
    //
    LocalFree( apiLockEntry );
    *lpLock = NULL;

#if DBG
    ScDumpLockList();
#endif

    //
    // OK, it's safe for other threads to muck with the lock list.
    //
    UNLOCK_API_LOCK_LIST( "RUnlockServiceDatabase done" );

    SC_LOG0( LOCK_API,"Database Lock is OFF (from API)\n");

    return(NO_ERROR);
}


VOID
SC_RPC_LOCK_rundown(
    SC_RPC_LOCK     lock
    )

/*++

Routine Description:

    This function is called by RPC when a connection is broken that had
    an outstanding context handle.  The value of the context handle is
    passed in here so that we have an opportunity to clean up.

Arguments:

    lock - This is the handle value of the context handle that is broken.

Return Value:

    none.

--*/
{
    RUnlockServiceDatabase(&lock);
}


VOID
ScUnlockDatabase(
    IN OUT LPSC_RPC_LOCK lpLock
    )
/*++

Routine Description:

    This function is called by internally by ScStartServiceAndDependencies
    to unlock the SC Manager database lock when it is done starting
    services.

Arguments:

    lpLock - Supplies the address of the pointer to the lock structure.
        On output, the pointer is set to NULL.

Return Value:

    None.

--*/
{
    RUnlockServiceDatabase(lpLock);
}


DWORD
ScLockDatabase(
    IN  BOOL IsServiceController,
    IN  LPWSTR DatabaseName,
    OUT LPSC_RPC_LOCK lpLock
    )
/*++

Routine Description:

    This function grabs the external database lock which is used
    by setup programs to ensure serialization to the services'
    configuration.

    It is also called by the service controller itself from
    ScStartServiceAndDependencies.  We need to grab the database lock
    internally when starting services so that setup programs know
    that when is an unsafe time to modify service configuration.

    When called by the service controller itself, the SID is not
    looked up.

Arguments:

    IsServiceController - Supplies a flag which is TRUE if this routine
        is called by the service controller; FALSE all other times.

    DatabaseName - Supplies the name of the database which the lock
        is to be acquired.

    lpLock - Receives a pointer to the lock entry created.


Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD               status;
    LPAPI_LOCK          apiLockEntry;
    PTOKEN_USER         UserInfo = NULL;


    SC_ASSERT(DatabaseName != NULL);

    LOCK_API_LOCK_LIST_EXCLUSIVE( "ScLockDatabase start" );

    //
    // Check for another lock.
    //
    apiLockEntry = ScFindApiLockForDatabase(DatabaseName);

    if (apiLockEntry != NULL) {
        UNLOCK_API_LOCK_LIST( "ScLockDatabase already locked" );
        SC_LOG0(LOCK_API, "ScLockDatabase: Database is already locked\n");
        return ERROR_SERVICE_DATABASE_LOCKED;
    }

    if (! IsServiceController) {
        //
        // Get the caller's SID
        //
        if ((status = ScGetClientSid(
                          &UserInfo
                          )) != NO_ERROR) {
            UNLOCK_API_LOCK_LIST( "ScLockDatabase ScGetClientSid failed" );
            return status;
        }

        status = ScCreateLock(
                     FALSE,                // Non-ScManager caller to grab lock
                     DatabaseName,
                     UserInfo->User.Sid,
                     lpLock
                     );

        LocalFree(UserInfo);
    }
    else {
        status = ScCreateLock(
                     TRUE,                 // ScManager caller to grab lock
                     DatabaseName,
                     NULL,
                     lpLock
                     );
    }

#if DBG
    ScDumpLockList();
#endif

    UNLOCK_API_LOCK_LIST("ScLockDatabase done");

    return status;
}


DWORD
ScCreateLock(
    IN  BOOL IsServiceController,
    IN  LPWSTR DatabaseName,
    IN  PSID UserSid OPTIONAL,
    OUT LPSC_RPC_LOCK lpLock
    )
/*++

Routine Description:

    This function is creates a lock entry, fills in the information about
    the nature of the lock and insert it into the lock list.

Arguments:

    IsServiceController - Supplies a flag which is TRUE if this routine
        is called by the service controller; FALSE all other times.

    DatabaseName - Supplies the name of the database which the lock
        is to be acquired.

    UserSid - Supplies the SID of the caller to claim the lock.  This
        is NULL if IsServiceController is TRUE.

    lpLock - Receives a pointer to the lock entry created.


Return Value:

    NO_ERROR or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    DWORD allocSize;
    LPAPI_LOCK newLockEntry;
    LPAPI_LOCK apiLockEntry;


    //
    // Build a structure to describe this lock.
    //
    if (IsServiceController) {
        allocSize = sizeof(API_LOCK) + (DWORD) WCSSIZE(DatabaseName);
    }
    else {
        if (! ARGUMENT_PRESENT(UserSid)) {
            SC_LOG0(ERROR, "ScCreateLock: UserSid is NULL!\n");
            SC_ASSERT(FALSE);
            return ERROR_GEN_FAILURE;
        }

        allocSize = sizeof(API_LOCK) + (DWORD) WCSSIZE(DatabaseName)
                    + RtlLengthSid(UserSid);
    }

    newLockEntry = (LPAPI_LOCK) LocalAlloc( LMEM_ZEROINIT, (UINT) allocSize );

    if (newLockEntry == NULL) {
        SC_LOG1(ERROR,"ScCreateLock: Local Alloc FAILED "
                FORMAT_DWORD "\n", GetLastError());
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    SC_LOG3(LOCK_API,"ScCreateLock: alloc'ed " FORMAT_DWORD
            " bytes at " FORMAT_LPVOID "  Sid-size " FORMAT_DWORD ".\n",
            allocSize, (LPVOID) newLockEntry,
            (UserSid) ? RtlLengthSid(UserSid) : 0);


    //
    // Fill in fields of new lock entry
    //
    newLockEntry->Signature = API_LOCK_SIGNATURE;

    newLockEntry->DatabaseName = (LPWSTR) (newLockEntry + 1);
    wcscpy(newLockEntry->DatabaseName, DatabaseName);


    if (ARGUMENT_PRESENT(UserSid)) {
        newLockEntry->LockOwnerSid = (PSID) ((DWORD_PTR) newLockEntry->DatabaseName +
                                             WCSSIZE(DatabaseName));


        SC_LOG1(LOCK_API, "ScCreateLock: Before RtlCopySid, bytes left "
                FORMAT_DWORD "\n", ((DWORD_PTR) newLockEntry + allocSize) -
                (DWORD_PTR) newLockEntry->LockOwnerSid);

        ntstatus = RtlCopySid(
                       (ULONG)(((DWORD_PTR) newLockEntry + allocSize) - (DWORD_PTR) newLockEntry->LockOwnerSid),
                       newLockEntry->LockOwnerSid,
                       UserSid
                       );

        if (! NT_SUCCESS(ntstatus)) {
            SC_LOG1(ERROR, "ScCreateLock: RtlCopySid failed " FORMAT_NTSTATUS
                    "\n", ntstatus);

            LocalFree(newLockEntry);
            return RtlNtStatusToDosError(ntstatus);
        }
    }
    else {
        newLockEntry->LockOwnerSid = (PSID) NULL;
    }

    newLockEntry->TimeWhenLocked = (DWORD) time( NULL );

    //
    // Record this lock.
    //
    if (ScGlobalApiLockList != NULL) {

        //
        // List is not empty, so just add to end.
        //
        apiLockEntry = ScGlobalApiLockList;
        ADD_TO_LIST( apiLockEntry, newLockEntry );

    } else {

        //
        // List is empty, so start with this (new) entry.
        //
        ScGlobalApiLockList = newLockEntry;
        newLockEntry->Next = NULL;
        newLockEntry->Prev = NULL;
    }

    *lpLock = newLockEntry;

    return NO_ERROR;
}




DWORD
ScGetLockOwner(
    IN  PSID UserSid OPTIONAL,
    OUT LPWSTR *LockOwnerName
    )
{

    DWORD status = NO_ERROR;
    NTSTATUS ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;
    LSA_HANDLE PolicyHandle;

    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomain = NULL;
    PLSA_TRANSLATED_NAME Name = NULL;

    NT_PRODUCT_TYPE ProductType;


    if (! ARGUMENT_PRESENT(UserSid)) {

        *LockOwnerName = (LPWSTR)LocalAlloc(
                             LMEM_ZEROINIT,
                             WCSSIZE(SC_MANAGER_USERNAME)
                             );

        if (*LockOwnerName == NULL) {
            SC_LOG1(ERROR, "ScGetLockOwner: LocalAlloc failed " FORMAT_DWORD
                    "\n", GetLastError());

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*LockOwnerName, SC_MANAGER_USERNAME);

        return NO_ERROR;
    }

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    ntstatus = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   POLICY_LOOKUP_NAMES,
                   &PolicyHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG(ERROR, "ScGetLockOwner: LsaOpenPolicy returned " FORMAT_NTSTATUS
                     "\n", ntstatus);
        return RtlNtStatusToDosError(ntstatus);
    }

    //
    // Get the name of the specified SID
    //
    ntstatus = LsaLookupSids(
                   PolicyHandle,
                   1,
                   &UserSid,
                   &ReferencedDomain,
                   &Name
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG(ERROR, "ScGetLockOwner: LsaLookupNames returned " FORMAT_NTSTATUS
                     "\n", ntstatus);
        return RtlNtStatusToDosError(ntstatus);
    }

    if (ReferencedDomain == NULL || Name == NULL) {
        SC_LOG2(ERROR, "ScGetLockOwner: ReferencedDomain=%08lx, Name=%08lx\n",
                ReferencedDomain, Name);

        status = ERROR_GEN_FAILURE;
        goto CleanExit;

    }
    else {

        LPWSTR Ptr;


        if (Name->Use == SidTypeUnknown || Name->Use == SidTypeInvalid) {
            SC_LOG0(ERROR, "ScGetLockOwner: Sid is unknown or invalid\n");
            status = ERROR_GEN_FAILURE;
            goto CleanExit;
        }

        if (Name->DomainIndex < 0) {
            SC_LOG1(ERROR, "ScGetLockOwner: DomainIndex is negative %ld\n",
                    Name->DomainIndex);
            status = ERROR_GEN_FAILURE;
            goto CleanExit;
        }

        if (ReferencedDomain->Entries == 0) {
            SC_LOG0(ERROR, "ScGetLockOwner: No ReferencedDomain entry\n");
            status = ERROR_GEN_FAILURE;
            goto CleanExit;
        }

        *LockOwnerName = (LPWSTR)LocalAlloc(
                             LMEM_ZEROINIT,
                             Name->Name.Length +
                             ReferencedDomain->Domains[Name->DomainIndex].Name.Length +
                             2 * sizeof(WCHAR)
                             );

        if (*LockOwnerName == NULL) {
            SC_LOG1(ERROR, "ScGetLockOwner: LocalAlloc failed " FORMAT_DWORD
                    "\n", GetLastError());

            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }

        if (! RtlGetNtProductType(&ProductType)) {
            status = GetLastError();
            SC_LOG1(ERROR, "ScGetLockOwner: RtlGetNtProductType failed "
                    FORMAT_DWORD "\n", status);
            LocalFree(*LockOwnerName);
            goto CleanExit;
        }

        if (ProductType != NtProductLanManNt) {

            status = ScGetAccountDomainInfo();

            if (status != NO_ERROR) {
                LocalFree(*LockOwnerName);
                goto CleanExit;
            }

            if (RtlEqualUnicodeString(
                    &(ReferencedDomain->Domains[Name->DomainIndex].Name),
                    &ScAccountDomain,
                    TRUE
                    )
                ||

                RtlEqualUnicodeString(
                    &(ReferencedDomain->Domains[Name->DomainIndex].Name),
                    &ScComputerName,
                    TRUE
                    )

                ) {

               //
               // We are WinNT and the user who has the lock is logged on to
               // a local account.  Convert the local domain name to "."
               //
               wcscpy(*LockOwnerName, SC_LOCAL_DOMAIN_NAME);
            }
            else {
                goto ReturnRefDomain;
            }

        }
        else {

ReturnRefDomain:
            memcpy(
                *LockOwnerName,
                ReferencedDomain->Domains[Name->DomainIndex].Name.Buffer,
                ReferencedDomain->Domains[Name->DomainIndex].Name.Length
                );

        }

        Ptr = *LockOwnerName + wcslen(*LockOwnerName);

        *Ptr = SCDOMAIN_USERNAME_SEPARATOR;

        Ptr++;

        memcpy(
            Ptr,
            Name->Name.Buffer,
            Name->Name.Length
            );

    }

CleanExit:

    if (ReferencedDomain != NULL) {
        LsaFreeMemory(ReferencedDomain);
    }

    if (Name != NULL) {
        LsaFreeMemory(Name);
    }

    LsaClose(PolicyHandle);

    return status;
}

#if DBG
VOID
ScDumpLockList(
    VOID
    )
{

    LPAPI_LOCK LockEntry = ScGlobalApiLockList;
    LPWSTR LockOwner;


    if (LockEntry == NULL) {
        KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_LOCK_API, "\nLock list is NULL\n"));

        return;
    }

    KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_LOCK_API, "\nScDumpLockList:\n"));

    while (LockEntry != NULL) {

        if (ScGetLockOwner(LockEntry->LockOwnerSid, &LockOwner) == NO_ERROR) {

            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_LOCK_API,
                       "LockOwner:    " FORMAT_LPWSTR "\n",
                       LockOwner));

            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_LOCK_API,
                       "LockDuration: " FORMAT_DWORD "\n",
                       ((DWORD)time(NULL)) - LockEntry->TimeWhenLocked));

            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_LOCK_API,
                       "LockDatabase: " FORMAT_LPWSTR "\n",
                       LockEntry->DatabaseName));

            LocalFree(LockOwner);
        }

        LockEntry = LockEntry->Next;
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\lock.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lock.h

Abstract:

    Contains data structures and function prototypes for the Service
    Controller's database locking functions (lock.cxx).
    This file defines the following classes:
        CCountingResource
        CServiceRecordLock
        CServiceListLock
        CGroupListLock

        CServiceRecordExclusiveLock
        CServiceRecordSharedLock
        CServiceRecordTEMPORARYEXCLUSIVELOCK
        CServiceListExclusiveLock
        CServiceListSharedLock
        CGroupListExclusiveLock
        CGroupListSharedLock

Author:

    Anirudh Sahni (anirudhs)    09-Jan-1997

Environment:

    User Mode -Win32

Revision History:

    09-Jan-1997     AnirudhS
        Created, replacing the old locking functions in dataman.h.

--*/

#ifndef _LOCK_INCLUDED_
#define _LOCK_INCLUDED_

//+-------------------------------------------------------------------------
//
//  Class:      CCountingResource
//
//  Purpose:    This is an RTL_RESOURCE that, in the checked build, knows
//              its locking level for the current thread.  The locking
//              level is stored in a TLS (thread local storage) slot.  A
//              positive value indicates a shared lock on the resource and
//              a negative value indicates an exclusive lock, with the
//              absolute value indicating the number of recursive
//              acquisitions of the lock.
//
//  History:    09-Jan-97 AnirudhS  Created.
//
//--------------------------------------------------------------------------

class CCountingResource
{
public:

    void Initialize(LPCSTR ShortName, LPCSTR Name)
                        {
                            RtlInitializeResource(&_Lock);
                            #if DBG
                                _TlsIndex = TlsAlloc();
                                SC_ASSERT(_TlsIndex != 0xFFFFFFFF);
                                _ShortName = ShortName;
                                _Name = Name;
                            #endif
                        }
    void Delete()       { RtlDeleteResource(&_Lock); }

#if DBG
    void GetShared();
    void GetExclusive();
    void MakeShared();
    void Release();

    BOOL Have() const   { return (CurrentLevel() != 0); }
    BOOL HaveExclusive() const
                        { return (CurrentLevel() < 0); }
#else
    void GetShared()    { RtlAcquireResourceShared(&_Lock, TRUE); }
    void GetExclusive() { RtlAcquireResourceExclusive(&_Lock, TRUE); }
    void MakeShared()   { RtlConvertExclusiveToShared(&_Lock); }
    void Release()      { RtlReleaseResource(&_Lock); }
#endif

protected:

#if DBG
    void MakeExclusive();

    LONG CurrentLevel() const
                        { return (LONG)(LONG_PTR)(TlsGetValue(_TlsIndex)); }
    void SetCurrentLevel(LONG Level)
                        { SC_ASSERT(TlsSetValue(_TlsIndex, (PVOID)(LONG_PTR) Level) != 0); }
#else
    void MakeExclusive()
                        { RtlConvertSharedToExclusive(&_Lock); }
#endif

private:

#if DBG
    DWORD        _TlsIndex;
    LPCSTR       _ShortName;
    LPCSTR       _Name;
#endif

    RTL_RESOURCE _Lock;
};


//+-------------------------------------------------------------------------
//
//  Class:      CServiceRecordLock, CServiceListLock, CGroupListLock
//
//  Purpose:    These three locks are used to synchronize multithreaded
//              access to the service controller's database.  Each lock
//              allows single-writer/multiple-reader access to a particular
//              aspect of the database.
//
//              These are implemented as three separate classes with one
//              instance each, rather than three instances of one class,
//              because their implementations in the debug build differ
//              substantially from one another.
//
//              The Service List lock is used to synchronize access to the
//              linked list pointers (Prev and Next fields) of the
//              SERVICE_RECORDs in the database.  While a thread holds this
//              lock, no other thread can add or delete SERVICE_RECORDs.
//
//              The Service Record lock is used to synchronize access to
//              the "contents" (other fields) of the SERVICE_RECORDs.
//
//              In order to delete a service record, both the service list
//              lock and the service record lock must be held exclusively.
//              Consequently if a thread is only working with a particular
//              service record (not walking the list of service records),
//              it is sufficient for that thread to hold the service record
//              lock in order to be assured that no other thread will
//              delete that service record.
//
//              The Group List lock is used to synchronize access to the
//              LOAD_ORDER_GROUPs in the database (both contents and
//              pointers).
//
//              To avoid deadlocks, the locks are always acquired in the
//              following order, if more than one is needed:
//              1. Group List lock (if needed)
//              2. Service List lock (if needed)
//              3. Service Record lock (if needed)
//
//  History:    09-Jan-97 AnirudhS  Created.
//
//--------------------------------------------------------------------------

class CServiceRecordLock : public CCountingResource
{
public:

    //
    // This method's name is capitalized to draw attention to its use,
    // because it is easily misunderstood and misused.  It does not hold
    // on to the shared lock while converting it to exclusive.  Instead,
    // it first releases the shared lock and then acquires the exclusive
    // lock.
    //
    void MAKEEXCLUSIVE() { CCountingResource::MakeExclusive(); }
};


class CServiceListLock : public CCountingResource
{
public:

#if DBG
    void GetShared();
    void GetExclusive();
    void Release();
#endif
};


class CGroupListLock : public CCountingResource
{
public:

#if DBG
    void GetShared();
    void GetExclusive();
    void Release();
#endif
};


//
// Globals
//
extern CServiceRecordLock   ScServiceRecordLock;
extern CServiceListLock     ScServiceListLock;
extern CGroupListLock       ScGroupListLock;


//+-------------------------------------------------------------------------
//
// Safe wrapper classes that ensure that the Release method is called
//
// Use of these classes ensures proper, disciplined access to the locks.
// In general, the locks should be acquired and released through these
// safe classes only.  Any direct access to the locks should be viewed
// with suspicion.
//
//--------------------------------------------------------------------------

class CServiceRecordExclusiveLock
{
public:
    CServiceRecordExclusiveLock()   { ScServiceRecordLock.GetExclusive(); }
   ~CServiceRecordExclusiveLock()   { ScServiceRecordLock.Release(); }
};

class CServiceRecordSharedLock
{
public:
    CServiceRecordSharedLock()      { ScServiceRecordLock.GetShared(); }
   ~CServiceRecordSharedLock()      { ScServiceRecordLock.Release(); }
};


//
// Use this one with caution -- see the note above about MAKEEXCLUSIVE.
//
class CServiceRecordTEMPORARYEXCLUSIVELOCK
{
public:
    CServiceRecordTEMPORARYEXCLUSIVELOCK()
                                    { ScServiceRecordLock.MAKEEXCLUSIVE(); }
   ~CServiceRecordTEMPORARYEXCLUSIVELOCK()
                                    { ScServiceRecordLock.MakeShared(); }
};


class CServiceListExclusiveLock
{
public:
    CServiceListExclusiveLock()     { ScServiceListLock.GetExclusive(); }
   ~CServiceListExclusiveLock()     { ScServiceListLock.Release(); }
};

class CServiceListSharedLock
{
public:
    CServiceListSharedLock()        { ScServiceListLock.GetShared(); }
   ~CServiceListSharedLock()        { ScServiceListLock.Release(); }
};


class CGroupListExclusiveLock
{
public:
    CGroupListExclusiveLock()       { ScGroupListLock.GetExclusive(); }
   ~CGroupListExclusiveLock()       { ScGroupListLock.Release(); }
};

class CGroupListSharedLock
{
public:
    CGroupListSharedLock()          { ScGroupListLock.GetShared(); }
   ~CGroupListSharedLock()          { ScGroupListLock.Release(); }
};


#endif // ifndef _LOCK_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\resource.h ===
//
// Resource IDs for services.exe
//

//
// String IDs for the string representations of the SC_ACTION enumeration
// start at this number.
//
#define IDS_SC_ACTION_BASE      0

//
// ID of the string the Service Controller will display on a reboot
// due to a service crash.
//
#define IDS_SC_REBOOT_MESSAGE   10

//
// String IDs for the string representations of service
// controls and states.
//
#define IDS_SC_CONTROL_BASE     20
#define IDS_SC_STATUS_BASE      50


//
// String IDs for the string representations of service config fields
//
#define IDS_SC_CONFIG_SERVICE_TYPE      80
#define IDS_SC_CONFIG_START_TYPE        81
#define IDS_SC_CONFIG_ERROR_CONTROL     82
#define IDS_SC_CONFIG_DISPLAY_NAME      83
#define IDS_SC_CONFIG_BINARY_PATH       84
#define IDS_SC_CONFIG_DEPENDENCIES      85
#define IDS_SC_CONFIG_GROUP             86
#define IDS_SC_CONFIG_TAG               87
#define IDS_SC_CONFIG_ACCOUNT           88
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\ncevents.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
// NCEvents.h
//
// This file is the interface to using non-COM events within ESS.
//

#pragma once

/*
#ifdef __cplusplus
extern "C" {
#endif
*/

BOOL InitNCEvents();
void DeinitNCEvents();
BOOL WINAPI NCFireEvent(DWORD dwIndex, ...);
BOOL WINAPI NCIsEventActive(DWORD dwIndex);


/*
#ifdef __cplusplus
}
#endif
*/

// Use this index with g_hNCEvents
enum NCE_INDEX
{
    NEVENT_BAD_ACCOUNT_NAME,
    NEVENT_CALL_TO_FUNCTION_FAILED,
    NEVENT_CALL_TO_FUNCTION_FAILED_II,
    NEVENT_FIRST_LOGON_FAILED,
    NEVENT_REVERTED_TO_LASTKNOWNGOOD,
    NEVENT_CONNECTION_TIMEOUT,
    NEVENT_READFILE_TIMEOUT,
    NEVENT_TRANSACT_TIMEOUT,
    NEVENT_TRANSACT_INVALID,
    NEVENT_SERVICE_CRASH,
    NEVENT_SERVICE_CRASH_NO_ACTION,
    NEVENT_SERVICE_NOT_INTERACTIVE,
    NEVENT_SERVICE_RECOVERY_FAILED,
    NEVENT_INVALID_DRIVER_DEPENDENCY,
    NEVENT_SERVICE_START_FAILED,
    NEVENT_CIRCULAR_DEPENDENCY_DEMAND,
    NEVENT_CIRCULAR_DEPENDENCY_AUTO,
    NEVENT_SERVICE_START_FAILED_NONE,
    NEVENT_SERVICE_START_FAILED_II,
    NEVENT_DEPEND_ON_LATER_SERVICE,
    NEVENT_SERVICE_START_FAILED_GROUP,
    NEVENT_DEPEND_ON_LATER_GROUP,
    NEVENT_SERVICE_START_HUNG,
    NEVENT_SEVERE_SERVICE_FAILED,
    NEVENT_TAKE_OWNERSHIP,
    NEVENT_BAD_SERVICE_STATE,
    NEVENT_SERVICE_EXIT_FAILED,
    NEVENT_SERVICE_EXIT_FAILED_SPECIFIC,
    NEVENT_BOOT_SYSTEM_DRIVERS_FAILED,
    NEVENT_SERVICE_CONTROL_SUCCESS,
    NEVENT_SERVICE_STATUS_SUCCESS,
    NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
    NEVENT_FIRST_LOGON_FAILED_II,

    NCE_InvalidIndex // This should always be the last one.
};


#ifndef NO_NCEVENTS
#define FIRE_NCEVENT                NCFireEvent
#define IS_NCEVENT_ACTIVE(index)    NCIsEventActive(index)
#else
#define FIRE_NCEVENT                (1 ? (void)0 : NCFireEvent)
#define IS_NCEVENT_ACTIVE(index)    FALSE
#endif

#define ScLogEvent  FIRE_NCEVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\ncevents.cxx ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
// NCEvents.h
//
// This file is the interface to using non-COM events.
//

#include "precomp.hxx"
#include "NCObjAPI.h"
#include "NCEvents.h"

#define NUM_NC_EVENTS       NCE_InvalidIndex
#define MAX_BUFFER_SIZE     32000
#define SEND_LATENCY        100

#ifndef NO_NCEVENTS

static HANDLE g_hConnection;
HANDLE g_hNCEvents[NUM_NC_EVENTS];

LPCWSTR szEventSetup[NUM_NC_EVENTS * 2] =
{
    L"MSFT_NetBadAccount",
    L"",

    L"MSFT_NetCallToFunctionFailed",
    L"FunctionName!s! Error!u!",

    L"MSFT_NetCallToFunctionFailedII",
    L"FunctionName!s! Argument!s! Error!u!",

    L"MSFT_NetFirstLogonFailed",
    L"Error!u!",

    L"MSFT_NetRevertedToLastKnownGood",
    L"",

    L"MSFT_NetConnectionTimeout",
    L"Milliseconds!u! Service!s!",

    L"MSFT_NetReadfileTimeout",
    L"Milliseconds!u!",

    L"MSFT_NetTransactTimeout",
    L"Milliseconds!u! Service!s!",

    L"MSFT_NetTransactInvalid",
    L"",

    L"MSFT_NetServiceCrash",
    L"Service!s! TimesFailed!u! ActionDelay!u! ActionType!u! Action!s!",

    L"MSFT_NetServiceCrashNoAction",
    L"Service!s! TimesFailed!u!",

    L"MSFT_NetServiceNotInteractive",
    L"Service!s!",

    L"MSFT_NetServiceRecoveryFailed",
    L"ActionType!u! Action!s! Service!s! Error!u!",

    L"MSFT_NetInvalidDriverDependency",
    L"Driver!s!",

    L"MSFT_NetServiceStartFailed",
    L"Service!s! Error!u!",

    L"MSFT_NetCircularDependencyDemand",
    L"Service!s!",

    L"MSFT_NetCircularDependencyAuto",
    L"",

    L"MSFT_NetServiceStartFailedNone",
    L"Service!s! NonExistingService!s!",

    L"MSFT_NetServiceStartFailedII",
    L"Service!s! DependedOnService!s! Error!u!",

    L"MSFT_NetDependOnLaterService",
    L"Service!s!",

    L"MSFT_NetServiceStartFailedGroup",
    L"Service!s! Group!s!",

    L"MSFT_NetDependOnLaterGroup",
    L"Service!s!",

    L"MSFT_NetServiceStartHung",
    L"Service!s!",

    L"MSFT_NetSevereServiceFailed",
    L"Service!s!",

    L"MSFT_NetTakeOwnership",
    L"RegistryKey!s!",

    L"MSFT_NetBadServiceState",
    L"Service!s! State!u!",

    L"MSFT_NetServiceExitFailed",
    L"Service!s! Error!u!",

    L"MSFT_NetServiceExitFailedSpecific",
    L"Service!s! Error!u!",

    L"MSFT_NetBootSystemDriversFailed",
    L"DriverList!s!",

    L"MSFT_NetServiceControlSuccess",
    L"Service!s! Control!s! sid!s!",

    L"MSFT_NetServiceStatusSuccess",
    L"Service!s! Control!s!",

    L"MSFT_NetServiceConfigBackoutFailed",
    L"Service!s! ConfigField!s!",

    L"MSFT_NetFirstLogonFailedII",
    L"Service!s! Account!s! Error!u!"
};
#endif // #ifndef NO_NCEVENTS

#define SCM_PROV_NAME   L"SCM Event Provider"


BOOL InitNCEvents()
{

#ifndef NO_NCEVENTS

    BOOL bRet;

    g_hConnection =
        WmiEventSourceConnect(
            L"root\\cimv2",
            SCM_PROV_NAME,
            TRUE,
            MAX_BUFFER_SIZE,
            SEND_LATENCY,
            NULL,
            NULL);

    if (g_hConnection)
    {
        for (int i = 0; i < NUM_NC_EVENTS; i++)
        {
            g_hNCEvents[i] = 
                WmiCreateObjectWithFormat(
                    g_hConnection,
                    szEventSetup[i * 2],
                    WMI_CREATEOBJ_LOCKABLE,
                    szEventSetup[i * 2 + 1]);

            if (!g_hNCEvents[i])
                break;
        }

        bRet = i == NUM_NC_EVENTS;
    }
    else
        bRet = FALSE;

    return bRet;

#else

    return TRUE;

#endif

}


void DeinitNCEvents()
{

#ifndef NO_NCEVENTS

    for (int i = 0; i < NUM_NC_EVENTS; i++)
    {
        if (g_hNCEvents[i])
            WmiDestroyObject(g_hNCEvents[i]);
    }

    if (g_hConnection)
        WmiEventSourceDisconnect(g_hConnection);

#endif

}


BOOL WINAPI NCFireEvent(DWORD dwIndex, ...)
{
    va_list list;
    BOOL    bRet;

    va_start(list, dwIndex);

    bRet =
        WmiSetAndCommitObject(
            g_hNCEvents[dwIndex], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED | WMI_USE_VA_LIST,
            &list);

    return bRet;
}


BOOL WINAPI NCIsEventActive(DWORD dwIndex)
{
    return WmiIsObjectActive(g_hNCEvents[dwIndex]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scansi.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    SCANSI.CXX

Abstract:

    This file contains ansi wrappers for the Service Controller API
    functions.

Author:

    Dan Lafferty (danl) 04-Feb-1992

Environment:

    User Mode - Win32

Revision History:

    05-Nov-1992 Danl
        Added DisplayName Changes & new API.
    28-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.
    14-Apr-1992 JohnRo
        We should not return password from any of our APIs.
    04-Feb-1992 danl
        Created

--*/

#include "precomp.hxx"
#include <sclib.h>      // ScConvertToUnicode, ScConvertToAnsi
#include <scwow.h>      // 32/64-bit interop structures


DWORD
ROpenSCManagerA(
    IN  LPSTR           lpMachineName,
    IN  LPSTR           lpDatabaseName OPTIONAL,
    IN  DWORD           dwDesiredAccess,
    OUT LPSC_RPC_HANDLE lpScHandle
    )
/*++

Routine Description:


Arguments:

    lpMachineName -

    lpDatabaseName -

    dwDesiredAccess -

    lpScHandle -

Return Value:


Note:


--*/
{
    DWORD       status;
    LPWSTR      lpDatabaseNameW = NULL;

    //
    // This parameter got us to the server side and is uninteresting
    // once we get here.
    //
    UNREFERENCED_PARAMETER(lpMachineName);

    //
    // Create a unicode version of lpDatabaseName
    //
    if (ARGUMENT_PRESENT(lpDatabaseName)) {

        if(!ScConvertToUnicode(&lpDatabaseNameW, lpDatabaseName)) {
            SC_LOG(ERROR,"ROpenSCManagerA:ScConvertToUnicode failed\n",0);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    status = ROpenSCManagerW (
                NULL,
                lpDatabaseNameW,
                dwDesiredAccess,
                lpScHandle);


    if (ARGUMENT_PRESENT(lpDatabaseName)) {
        LocalFree(lpDatabaseNameW);
    }
    return(status);
}


DWORD
ROpenServiceA(
    IN  SC_RPC_HANDLE   hSCManager,
    IN  LPSTR           lpServiceName,
    IN  DWORD           dwDesiredAccess,
    OUT LPSC_RPC_HANDLE phService
    )

/*++

Routine Description:

    Returns a handle to the service.  This handle is actually a pointer
    to a data structure that contains a pointer to the service record.

Arguments:

    hSCManager - This is a handle to this service controller.  It is an
        RPC context handle, and has allowed the request to get this far.

    lpServiceName - This is a pointer to a string containing the name of
        the service

    dwDesiredAccess - This is an access mask that contains a description
        of the access that is desired for this service.

    phService - This is a pointer to the location where the handle to the
        service is to be placed.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle is invalid.

    ERROR_SERVICE_DOES_NOT_EXIST - The specified service does not exist
        in the database.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation for the handle structure
        failed.

Note:


--*/
{
    DWORD       status;
    LPWSTR      lpServiceNameW;

    //
    // Create a unicode version of lpServiceName
    //
    if(!ScConvertToUnicode(&lpServiceNameW, lpServiceName)) {
        SC_LOG(ERROR,"ROpenServiceA:ScConvertToUnicode failed\n",0);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    status = ROpenServiceW (
                hSCManager,
                lpServiceNameW,
                dwDesiredAccess,
                phService);

    LocalFree(lpServiceNameW);

    return(status);
}

DWORD
RStartServiceA(
    IN  SC_RPC_HANDLE       hService,
    IN  DWORD               NumArgs,
    IN  LPSTRING_PTRSA      CmdArgs
    )

/*++

Routine Description:

    This function begins the execution of a service.

Arguments:

    hService - A handle which is a pointer to a service handle structure.

    dwNumServiceArgs - This indicates the number of argument vectors.

    lpServiceArgVectors - This is a pointer to an array of string pointers.

Return Value:

    NO_ERROR - The operation was completely successful.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_START access.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_SERVICE_WAS_STARTED - An instance of the service is already running.

    ERROR_SERVICE_REQUEST_TIMEOUT - The service did not respond to the start
        request in a timely fashion.

    ERROR_SERVICE_NO_THREAD - A thread could not be created for the Win32
        service.

    ERROR_PATH_NOT_FOUND - The image file name could not be found in
        the configuration database (registry), or the image file name
        failed in a unicode/ansi conversion.



--*/
{
    DWORD       status = NO_ERROR;
    LPWSTR      *CmdArgsW = NULL;
    DWORD       bufferSize=0;
    DWORD       i;
    LPSTR       *cmdArgs;

    if (NumArgs > 0) {
        //
        // If there are command args, create a unicode version of them.
        //

        //
        // Allocate a buffer for the unicode command arg pointers.
        //
        bufferSize = NumArgs * sizeof(LPWSTR);

        CmdArgsW = (LPWSTR *)LocalAlloc(LMEM_ZEROINIT, (UINT) bufferSize);
        if (CmdArgsW == NULL) {
            SC_LOG(ERROR,"RStartServicesA: LocalAlloc Failed\n",0);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        __try {

            //
            // For each command Arg, allocate a string and convert the
            // unicode version of the string into it.
            //
            cmdArgs = (LPSTR *)CmdArgs;

            for (i=0; i<NumArgs; i++) {
                if(!ScConvertToUnicode(&(CmdArgsW[i]), cmdArgs[i])) {
                    SC_LOG(ERROR,
                        "RStartServicesA: LocalAlloc (convert) Failed\n",0);
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
            if (status != EXCEPTION_ACCESS_VIOLATION) {
                SC_LOG(ERROR,
                    "RStartServicesA: Unexpected Exception 0x%lx\n",status);
            }
        }

        //
        // If any errors occured in the conversion process.  Abort and
        // return the error to the caller.
        //
        if (status != NO_ERROR) {
            goto CleanExit;
        }
    }

    status = RStartServiceW(
                hService,
                NumArgs,
                (LPSTRING_PTRSW)CmdArgsW);

CleanExit:
    if (NumArgs > 0) {
        //
        // If there were unicode versions of the arguments created for
        // this function, release the memory that was allocated.
        //
        for(i = 0; i < NumArgs; i++) {
            if (CmdArgsW[i] != NULL) {
                LocalFree(CmdArgsW[i]);
            }
        }
        LocalFree(CmdArgsW);
    }

    return(status);
}

DWORD
REnumServicesStatusA (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL
    )

/*++

Routine Description:

    This function lists the services installed in the Service Controllers
    database.  The status of each service is returned with the name of
    the service.

Arguments:

    hSCManager - This is a handle to the service controller.

    dwServiceType - Value to select the type of services to enumerate.
        It must be one of the bitwise OR of the following values:
        SERVICE_WIN32 - enumerate Win32 services only.
        SERVICE_DRIVER - enumerate Driver services only.

    dwServiceState - Value so select the services to enumerate based on the
        running state.  It must be one or the bitwise OR of the following
        values:
        SERVICE_ACTIVE - enumerate services that have started.
        SERVICE_INACTIVE - enumerate services that are stopped.

    lpBuffer - A pointer to a buffer to receive an array of enum status
        (or service) entries.

    cbBufSize - Size of the buffer in bytes pointed to by lpBuffer.

    pcbBytesNeeded - A pointer to a location where the number of bytes
        left (to be enumerated) is to be placed.  This indicates to the
        caller how large the buffer must be in order to complete the
        enumeration with the next call.

    lpServicesReturned - A pointer to a variable to receive the number of
        of service entries returned.

    lpResumeIndex - A pointer to a variable which on input specifies the
        index of a service entry to begin enumeration.  An index of 0
        indicates to start at the beginning.  On output, if this function
        returns ERROR_MORE_DATA, the index returned is the next service
        entry to resume the enumeration.  The returned index is 0 if this
        function returns a NO_ERROR.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in.
        (such as dwServiceType).

    ERROR_INVALID_HANDLE - The specified handle was invalid.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpBuffer, pcbReturned, pcbBytesNeeded,
        lpBuffer, ReturnedServerName, and lpResumeIndex.

--*/
{
    DWORD                        status;
    LPENUM_SERVICE_STATUS_WOW64  pEnumRec;
    LPWSTR                       pServiceName;
    LPWSTR                       pDisplayName;
    DWORD                        i;


    //
    // Initialize entries returned because we convert the buffer on
    // output based on the number of returned entries.
    //
    *lpServicesReturned = 0;

    status = REnumServicesStatusW (
                hSCManager,
                dwServiceType,
                dwServiceState,
                lpBuffer,
                cbBufSize,
                pcbBytesNeeded,
                lpServicesReturned,
                lpResumeIndex);

    if (*lpServicesReturned > 0)
    {
        //
        // Convert the returned unicode structures to Ansi.
        //
        pEnumRec = (LPENUM_SERVICE_STATUS_WOW64) lpBuffer;

        for (i = 0; i < *lpServicesReturned; i++)
        {
            //
            // Note: in these conversions, the pointers to the names are
            // stored as offsets at this point.
            //
            pServiceName = (LPWSTR) (lpBuffer + pEnumRec[i].dwServiceNameOffset);
            pDisplayName = (LPWSTR) (lpBuffer + pEnumRec[i].dwDisplayNameOffset);

            if (!ScConvertToAnsi((LPSTR) pServiceName, pServiceName))
            {
                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }

            //
            // Convert the Display Name.
            //
            if (!ScConvertToAnsi((LPSTR)pDisplayName, pDisplayName)) {

                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }
        }
    }

    return(status);
}


DWORD
REnumServicesStatusExA (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      SC_ENUM_TYPE    InfoLevel,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCSTR          pszGroupNameAnsi
    )

/*++

Routine Description:

    This function is analogous to REnumServicesStatusA, with the data
    being enumerated being dependent upon the InfoLevel parameter

Arguments:

    InfoLevel - An enumerated type that determines what service attributes
        are enumerated:

            SC_ENUM_ALL_INFO - Enumerates all the service information from
                REnumServicesStatusW plus the service's PID and flags

    pszGroupName - Only enumerate services belonging to the given group.
        If this parameter is the empty string, services not belonging to
        a group are enumerated.  If this parameter is NULL, no attention
        is paid to group.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in.
        (such as dwServiceType).

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_INVALID_LEVEL - The specified InfoLevel is invalid

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpBuffer, pcbReturned, pcbBytesNeeded,
        lpBuffer, ReturnedServerName, and lpResumeIndex.


--*/
{
    DWORD                                status;
    LPENUM_SERVICE_STATUS_PROCESS_WOW64  pEnumRec;
    LPWSTR                               pServiceName;
    LPWSTR                               pDisplayName;
    LPWSTR                               pszGroupName = NULL;
    DWORD                                i;


    //
    // Initialize entries returned because we convert the buffer on
    // output based on the number of returned entries.
    //
    *lpServicesReturned = 0;

    if (ARGUMENT_PRESENT(pszGroupNameAnsi)) {

        if (!ScConvertToUnicode(&pszGroupName, pszGroupNameAnsi)) {
            SC_LOG(ERROR,"EnumServicesStatusExA: ScConvertToUnicode failed\n",0);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    status = REnumServicesStatusExW (
                hSCManager,
                InfoLevel,
                dwServiceType,
                dwServiceState,
                lpBuffer,
                cbBufSize,
                pcbBytesNeeded,
                lpServicesReturned,
                lpResumeIndex,
                (LPCWSTR)pszGroupName);

    if (*lpServicesReturned > 0)
    {
        //
        // Convert the returned unicode structures to Ansi.
        //
        pEnumRec = (LPENUM_SERVICE_STATUS_PROCESS_WOW64) lpBuffer;

        for (i = 0; i < *lpServicesReturned; i++) {

            //
            // Note: in these conversions, the pointers to the names are
            // stored as offsets at this point.
            //
            pServiceName = (LPWSTR) (lpBuffer + pEnumRec[i].dwServiceNameOffset);
            pDisplayName = (LPWSTR) (lpBuffer + pEnumRec[i].dwDisplayNameOffset);

            if (!ScConvertToAnsi((LPSTR)pServiceName, pServiceName)) {

                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }

            //
            // Convert the Display Name.
            //
            if (!ScConvertToAnsi((LPSTR)pDisplayName, pDisplayName)) {

                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }
        }
    }

    LocalFree(pszGroupName);

    return(status);
}


DWORD
RChangeServiceConfigA(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwServiceType,
    IN  DWORD           dwStartType,
    IN  DWORD           dwErrorControl,
    IN  LPSTR           lpBinaryPathName,
    IN  LPSTR           lpLoadOrderGroup,
    OUT LPDWORD         lpdwTagId,
    IN  LPBYTE          lpDependencies,
    IN  DWORD           dwDependSize,
    IN  LPSTR           lpServiceStartName,
    IN  LPBYTE          EncryptedPassword,
    IN  DWORD           PasswordSize,
    IN  LPSTR           lpDisplayName
    )

/*++

Routine Description:


Arguments:

    lpDependencies - A buffer of size dwDependSize which already contains
        Unicode strings.

Return Value:


Note:


--*/
{
    DWORD       status;
    LPWSTR      lpDisplayNameW      = NULL;
    LPWSTR      lpBinaryPathNameW   = NULL;
    LPWSTR      lpLoadOrderGroupW   = NULL;
    LPWSTR      lpServiceStartNameW = NULL;

    //
    // Create a unicode version of lpBinaryPathName
    //
    if (ARGUMENT_PRESENT(lpBinaryPathName)) {

        if(!ScConvertToUnicode(&lpBinaryPathNameW, lpBinaryPathName)) {
            SC_LOG(ERROR,"ChangeServiceConfigA:ScConvertToUnicode failed\n",0);

            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpLoadOrderGroup
    //
    if (ARGUMENT_PRESENT(lpLoadOrderGroup)) {

        if(!ScConvertToUnicode(&lpLoadOrderGroupW, lpLoadOrderGroup)) {
            SC_LOG(ERROR,"ChangeServiceConfigA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpServiceStartName
    //
    if (ARGUMENT_PRESENT(lpServiceStartName)) {

        if(!ScConvertToUnicode(&lpServiceStartNameW, lpServiceStartName)) {
            SC_LOG(ERROR,"ChangeServiceConfigA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpDisplayName
    //
    if (ARGUMENT_PRESENT(lpDisplayName)) {

        if(!ScConvertToUnicode(&lpDisplayNameW, lpDisplayName)) {
            SC_LOG(ERROR,"ChangeServiceConfigA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Make the Unicode API Call
    //

    status = RChangeServiceConfigW(
                (SC_RPC_HANDLE)hService,
                dwServiceType,
                dwStartType,
                dwErrorControl,
                lpBinaryPathNameW,
                lpLoadOrderGroupW,
                lpdwTagId,
                lpDependencies,
                dwDependSize,
                lpServiceStartNameW,
                EncryptedPassword,
                PasswordSize,
                lpDisplayNameW);

CleanExit:

    LocalFree(lpBinaryPathNameW);
    LocalFree(lpLoadOrderGroupW);
    LocalFree(lpServiceStartNameW);
    LocalFree(lpDisplayNameW);

    return(status);
}


DWORD
RChangeServiceConfig2A(
    IN  SC_RPC_HANDLE       hService,
    IN  SC_RPC_CONFIG_INFOA Info
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   status = NO_ERROR;

    //
    // Make a Unicode version of the arguments to pass to the Unicode function
    //
    union
    {
        SERVICE_DESCRIPTIONW        sd;
        SERVICE_FAILURE_ACTIONSW    sfa;
    }                       Buffer;

    SC_RPC_CONFIG_INFOW     InfoW = { Info.dwInfoLevel, &Buffer.sd };

    switch (Info.dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        Buffer.sd.lpDescription = NULL;

        if (Info.psd == NULL)
        {
            InfoW.psd = NULL;
            break;
        }

        if (Info.psd->lpDescription != NULL)
        {
            if (!ScConvertToUnicode(&Buffer.sd.lpDescription,
                                    Info.psd->lpDescription))
            {
                SC_LOG0(ERROR, "RChangeServiceConfig2A: ScConvertToUnicode failed\n");
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        }
        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        RtlCopyMemory(&Buffer.sfa, Info.psfa, sizeof(SERVICE_FAILURE_ACTIONS));
        Buffer.sfa.lpRebootMsg = NULL;
        Buffer.sfa.lpCommand = NULL;

        if (Info.psfa == NULL)
        {
            InfoW.psfa = NULL;
            break;
        }

        if (Info.psfa->lpRebootMsg != NULL)
        {
            if (!ScConvertToUnicode(&Buffer.sfa.lpRebootMsg,
                                    Info.psfa->lpRebootMsg))
            {
                SC_LOG0(ERROR, "RChangeServiceConfig2A: ScConvertToUnicode failed\n");
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        }

        if (Info.psfa->lpCommand != NULL)
        {
            if (!ScConvertToUnicode(&Buffer.sfa.lpCommand,
                                    Info.psfa->lpCommand))
            {
                SC_LOG0(ERROR, "RChangeServiceConfig2A: ScConvertToUnicode failed\n");
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        }
        break;
    }

    //
    // Call the Unicode function
    //
    status = RChangeServiceConfig2W(hService, InfoW);

CleanExit:

    //
    // Free the temporary Unicode strings
    //
    switch (Info.dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        LocalFree(Buffer.sd.lpDescription);
        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        LocalFree(Buffer.sfa.lpRebootMsg);
        LocalFree(Buffer.sfa.lpCommand);
        break;
    }

    return status;
}


DWORD
RCreateServiceA(
    IN      SC_RPC_HANDLE   hSCManager,
    IN      LPSTR           lpServiceName,
    IN      LPSTR           lpDisplayName,
    IN      DWORD           dwDesiredAccess,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwStartType,
    IN      DWORD           dwErrorControl,
    IN      LPSTR           lpBinaryPathName,
    IN      LPSTR           lpLoadOrderGroup,
    OUT     LPDWORD         lpdwTagId,
    IN      LPBYTE          lpDependencies,
    IN      DWORD           dwDependSize,
    IN      LPSTR           lpServiceStartName,
    IN      LPBYTE          EncryptedPassword,
    IN      DWORD           PasswordSize,
    IN OUT  LPSC_RPC_HANDLE lpServiceHandle
    )

/*++

Routine Description:


Arguments:

    lpDependencies - A buffer of size dwDependSize which already contains
        Unicode strings.

Return Value:


Note:


--*/
{
    DWORD       status;
    LPWSTR      lpServiceNameW      = NULL;
    LPWSTR      lpDisplayNameW      = NULL;
    LPWSTR      lpBinaryPathNameW   = NULL;
    LPWSTR      lpLoadOrderGroupW   = NULL;
    LPWSTR      lpServiceStartNameW = NULL;

    //
    // Create a unicode version of lpServiceName
    //
    if (ARGUMENT_PRESENT(lpServiceName)) {

        if(!ScConvertToUnicode(&lpServiceNameW, lpServiceName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }
    //
    // Create a unicode version of lpDisplayName
    //
    if (ARGUMENT_PRESENT(lpDisplayName)) {

        if(!ScConvertToUnicode(&lpDisplayNameW, lpDisplayName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }
    //
    // Create a unicode version of lpBinaryPathName
    //
    if (ARGUMENT_PRESENT(lpBinaryPathName)) {

        if(!ScConvertToUnicode(&lpBinaryPathNameW, lpBinaryPathName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpLoadOrderGroup
    //
    if (ARGUMENT_PRESENT(lpLoadOrderGroup)) {

        if(!ScConvertToUnicode(&lpLoadOrderGroupW, lpLoadOrderGroup)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpServiceStartName
    //
    if (ARGUMENT_PRESENT(lpServiceStartName)) {

        if(!ScConvertToUnicode(&lpServiceStartNameW, lpServiceStartName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Make the Unicode API Call
    //

    status = RCreateServiceW (
                (SC_RPC_HANDLE)hSCManager,
                lpServiceNameW,
                lpDisplayNameW,
                dwDesiredAccess,
                dwServiceType,
                dwStartType,
                dwErrorControl,
                lpBinaryPathNameW,
                lpLoadOrderGroupW,
                lpdwTagId,
                lpDependencies,
                dwDependSize,
                lpServiceStartNameW,
                EncryptedPassword,
                PasswordSize,
                lpServiceHandle);
CleanExit:

    LocalFree(lpServiceNameW);
    LocalFree(lpDisplayNameW);
    LocalFree(lpBinaryPathNameW);
    LocalFree(lpLoadOrderGroupW);
    LocalFree(lpServiceStartNameW);

    return(status);
}


DWORD
REnumDependentServicesA(
    IN      SC_RPC_HANDLE   hService,
    IN      DWORD           dwServiceState,
    OUT     LPBYTE          lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                        status;
    LPENUM_SERVICE_STATUS_WOW64  pEnumRec;
    LPWSTR                  pServiceName;
    LPWSTR                  pDisplayName;
    DWORD                   i;

    //
    // Initialize entries returned because we convert the buffer on
    // output based on the number of returned entries.
    //
    *lpServicesReturned = 0;

    status = REnumDependentServicesW(
                hService,
                dwServiceState,
                lpBuffer,
                cbBufSize,
                pcbBytesNeeded,
                lpServicesReturned);

    if (*lpServicesReturned > 0) {
        //
        // Convert the returned unicode structures to Ansi.
        //
        pEnumRec = (LPENUM_SERVICE_STATUS_WOW64) lpBuffer;

        for (i=0; i<*lpServicesReturned; i++) {
            //
            // Note: in these conversions, the pointers to the names are
            // stored as offsets at this point.
            //
            pServiceName = (LPWSTR) (lpBuffer + (DWORD_PTR)(pEnumRec[i].dwServiceNameOffset));
            pDisplayName = (LPWSTR) (lpBuffer + (DWORD_PTR)(pEnumRec[i].dwDisplayNameOffset));

            if (!ScConvertToAnsi((LPSTR)pServiceName, pServiceName)) {

                SC_LOG(ERROR,"REnumDependendServicesA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }
            //
            // Convert the Display Name.
            //

            if (!ScConvertToAnsi((LPSTR)pDisplayName, pDisplayName)) {

                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }
        }
    }

    return(status);
}


DWORD
RQueryServiceConfigA(
    IN  SC_RPC_HANDLE           hService,
    OUT LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    IN  DWORD                   cbBufSize,
    OUT LPDWORD                 pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                   status;

    //
    // Call the Unicode version of the API.
    //

    status = RQueryServiceConfigW(
                (SC_RPC_HANDLE)hService,
                (LPQUERY_SERVICE_CONFIGW)lpServiceConfig,
                cbBufSize,
                pcbBytesNeeded);

    //
    // If successful, convert the QUERY_SERVICE_CONFIG structure to
    // ansi.
    //
    if (status == NO_ERROR) {

        //
        // Convert lpBinaryPathName to Ansi
        //
        if (lpServiceConfig->lpBinaryPathName != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpBinaryPathName,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpBinaryPathName)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        //
        // Convert lpDisplayName to Ansi
        //
        if (lpServiceConfig->lpDisplayName != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpDisplayName,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpDisplayName)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        //
        // Convert lpLoadOrderGroup to Ansi
        //
        if (lpServiceConfig->lpLoadOrderGroup != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpLoadOrderGroup,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpLoadOrderGroup)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        //
        // Convert lpDependencies to Ansi
        //
        if (lpServiceConfig->lpDependencies != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpDependencies,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpDependencies)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        //
        // Convert lpServiceStartName to Ansi
        //
        if (lpServiceConfig->lpServiceStartName != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpServiceStartName,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpServiceStartName)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    return(status);
}

DWORD
RQueryServiceConfig2A(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwInfoLevel,
    OUT LPBYTE          lpBuffer,
    IN  DWORD           cbBufSize,
    OUT LPDWORD         pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   status;
    DWORD   StringOffset;

    //
    // Call the Unicode version of the API, using the same buffer.
    // Then convert the strings in the buffer to Ansi.
    //
    status = RQueryServiceConfig2W(
                hService,
                dwInfoLevel,
                lpBuffer,
                cbBufSize,
                pcbBytesNeeded
                );

    if (status == NO_ERROR)
    {
        switch (dwInfoLevel)
        {
        case SERVICE_CONFIG_DESCRIPTION:
            {
                StringOffset = ((LPSERVICE_DESCRIPTION_WOW64) lpBuffer)->dwDescriptionOffset;

                if (StringOffset != 0)
                {
                    if(!ScConvertToAnsi(
                            (LPSTR)  (lpBuffer + StringOffset),
                            (LPWSTR) (lpBuffer + StringOffset)
                            ))
                    {
                        SC_LOG0(ERROR,"RQueryServiceConfig2A:ScConvertToAnsi failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
            break;

        case SERVICE_CONFIG_FAILURE_ACTIONS:
            {
                StringOffset = ((LPSERVICE_FAILURE_ACTIONS_WOW64) lpBuffer)->dwRebootMsgOffset;

                if (StringOffset != 0)
                {
                    if(!ScConvertToAnsi(
                            (LPSTR)  lpBuffer + StringOffset,
                            (LPWSTR) lpBuffer + StringOffset
                            ))
                    {
                        SC_LOG0(ERROR,"RQueryServiceConfig2A:ScConvertToAnsi failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                }

                StringOffset = ((LPSERVICE_FAILURE_ACTIONS_WOW64) lpBuffer)->dwCommandOffset;

                if (StringOffset != 0)
                {
                    if(!ScConvertToAnsi(
                            (LPSTR)  lpBuffer + StringOffset,
                            (LPWSTR) lpBuffer + StringOffset
                            ))
                    {
                        SC_LOG0(ERROR,"RQueryServiceConfig2A:ScConvertToAnsi failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
            break;

        default:
            SC_ASSERT(0);
            break;
        }
    }

    return status;
}

DWORD
RQueryServiceLockStatusA(
    IN  SC_RPC_HANDLE                   hSCManager,
    OUT LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    IN  DWORD                           cbBufSize,
    OUT LPDWORD                         pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   status;

    //
    // Call the Unicode version of the API
    //

    status = RQueryServiceLockStatusW(
                (SC_RPC_HANDLE)hSCManager,
                (LPQUERY_SERVICE_LOCK_STATUSW)lpLockStatus,
                cbBufSize,
                pcbBytesNeeded
                );

    //
    // If successful, convert the QUERY_SERVICE_LOCK_STATUS structure to
    // ansi.
    //
    if (status == NO_ERROR) {

        //
        // Convert lpLockOwner to Ansi
        //
        if (lpLockStatus->lpLockOwner != NULL) {
            if(!ScConvertToAnsi(
                lpLockStatus->lpLockOwner,
                ((LPQUERY_SERVICE_LOCK_STATUSW)lpLockStatus)->lpLockOwner)) {

                SC_LOG(ERROR,"RQueryServiceLockStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return(status);
}

DWORD
RGetServiceDisplayNameA(
    SC_RPC_HANDLE   hSCManager,
    LPSTR           lpServiceName,
    LPSTR           lpDisplayName,
    LPDWORD         lpcchBuffer
    )

/*++

Routine Description:

    This function returns the display name for a service that is identified
    by its key name (ServiceName).

Arguments:

    hSCManager - This is the handle to the Service Controller Manager that
        is expected to return the display name.

    lpServiceName -  This is the ServiceName (which is actually a key
        name) that identifies the service.

    lpDisplayName - This is a pointer to a buffer that is to receive the
        DisplayName string.

    lpcchBuffer - This is a pointer to the size (in characters) of the
        buffer that is to receive the DisplayName string.  If the buffer
        is not large enough to receive the entire string, then the required
        buffer size is returned in this location.  (NOTE:  Ansi Characters,
        including DBCS, are assumed to be 8 bits).

Return Value:



--*/
{
    DWORD       status;
    LPWSTR      lpServiceNameW = NULL;
    DWORD       numChars = 0;
    DWORD       numBytes = 0;
    LPSTR       tempBuffer=NULL;

    //
    // Create a unicode version of lpServiceName
    //
    if (ARGUMENT_PRESENT(lpServiceName)) {

        if(!ScConvertToUnicode(&lpServiceNameW, lpServiceName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Because of DBCS, we can't predict what the proper buffer size should
    // be.  So we allocate a temporary buffer that will hold as many
    // unicode characters as the original buffer would hold single byte
    // characters.
    //
    numChars = *lpcchBuffer;

    numBytes = (*lpcchBuffer) * sizeof(WCHAR);

    tempBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, numBytes);

    if (tempBuffer == NULL)
    {
        status = GetLastError();
        goto CleanExit;
    }

    //
    // Make the Unicode API Call
    //

    status = RGetServiceDisplayNameW (
                hSCManager,
                lpServiceNameW,
                (LPWSTR) tempBuffer,
                &numChars);

    if (status == NO_ERROR)
    {
        //
        // Convert the returned Unicode string and string size back to
        // ansi.
        //

        if (!ScConvertToAnsi(tempBuffer, (LPWSTR) tempBuffer)) {
            SC_LOG0(ERROR, "RGetServiceDisplayNameA: ConvertToAnsi Failed\n");
        }

        numBytes = (DWORD) strlen(tempBuffer);

        if ((numBytes+1) > *lpcchBuffer)
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            *lpcchBuffer = numBytes;
        }
        else
        {
            strcpy (lpDisplayName, tempBuffer);
        }
    }
    else if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        //
        // Adjust the required buffer size for ansi.
        //
        *lpcchBuffer = numChars * sizeof(WCHAR);
    }

CleanExit:
    //
    // Free up any resources that were allocated by this function.
    //

    LocalFree(tempBuffer);
    LocalFree(lpServiceNameW);

    return(status);
}

DWORD
RGetServiceKeyNameA(
    SC_RPC_HANDLE   hSCManager,
    LPSTR           lpDisplayName,
    LPSTR           lpServiceName,
    LPDWORD         lpcchBuffer
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD       status;
    LPWSTR      lpDisplayNameW      = NULL;
    DWORD       numChars = 0;
    DWORD       numBytes = 0;
    LPSTR       tempBuffer=NULL;

    //
    // Create a unicode version of lpDisplayName
    //
    if (ARGUMENT_PRESENT(lpDisplayName))
    {
        if(!ScConvertToUnicode(&lpDisplayNameW, lpDisplayName))
        {
            SC_LOG(ERROR,"RGetServiceKeyNameA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Because of DBCS, we can't predict what the proper buffer size should
    // be.  So we allocate a temporary buffer that will hold as many
    // unicode characters as the original buffer would hold single byte
    // characters.
    //
    numChars = *lpcchBuffer;

    numBytes = (*lpcchBuffer) * sizeof(WCHAR);

    tempBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, numBytes);

    if (tempBuffer == NULL)
    {
        status = GetLastError();
        goto CleanExit;
    }

    //
    // Make the Unicode API Call
    //

    status = RGetServiceKeyNameW (
                hSCManager,
                lpDisplayNameW,
                (LPWSTR)tempBuffer,
                &numChars);

    if (status == NO_ERROR)
    {
        //
        // Convert the returned Unicode string and string size back to
        // ansi.
        //

        if (!ScConvertToAnsi(tempBuffer, (LPWSTR)tempBuffer))
        {
            SC_LOG0(ERROR, "RGetServiceKeyNameA: ConvertToAnsi Failed\n");
        }

        numBytes = (DWORD) strlen(tempBuffer);

        if ((numBytes+1) > *lpcchBuffer)
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            *lpcchBuffer = numBytes;
        }
        else
        {
            strcpy (lpServiceName, tempBuffer);
        }
    }
    else if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        //
        // Adjust the required buffer size for ansi.
        //
        *lpcchBuffer = numChars * sizeof(WCHAR);
    }

CleanExit:
    //
    // Free up any resources that were allocated by this function.
    //

    LocalFree(tempBuffer);
    LocalFree(lpDisplayNameW);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scbsm.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    scbsm.cxx

Abstract:

    This module implements a simplistic scheme to have a trusted system
    component issue a BroadcastSystemMessage when a network drive is added
    or deleted through the WNet APIs.  This scheme guarantees that a spurious
    message is never sent; however, there are some situations in which a
    bona fide message can get lost or delayed.  The real solution requires
    Plug and Play support from network providers.

    The following functions are in this file:
        ScInitBSM
        ScHandleBSMRequest
        ScGetNetworkDrives
        ScCreateBSMEventSD

Author:

    Anirudh Sahni (anirudhs)    05-Jun-1996

Environment:

    User Mode - Win32

Notes:

    There is no architectural reason for this to be in the service controller.
    A more appropriate place would be the Plug and Play service.

Revision History:

    22-Oct-1998     jschwart
        Converted SCM to use NT thread pool APIs

    05-Jun-1996     AnirudhS
        Created.

--*/

#include "precomp.hxx"
#include <dbt.h>        // BroadcastSystemMessage structures
#include <winsvcp.h>    // SC_BSM_EVENT_NAME
#include <scseclib.h>   // well-known SIDs
#include "scbsm.h"

//-------------------------------------------------------------------//
//                                                                   //
// Constants and Macros                                              //
//                                                                   //
//-------------------------------------------------------------------//


//-------------------------------------------------------------------//
//                                                                   //
// Static global variables                                           //
//                                                                   //
//-------------------------------------------------------------------//

//
// Event that will be pulsed by the WNet APIs when they want a message
// broadcast
//
HANDLE hBSMEvent;

//
// What the net drive bitmask was when we last broadcast (initially 0)
//
DWORD LastNetDrives;

//
// Work item handle
//
HANDLE g_hWorkitem;

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

BOOL
ScCreateBSMEventSD(
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    );

VOID
ScHandleBSMRequest(
    PVOID   pContext,
    BOOLEAN dwWaitStatus
    );

DWORD
ScGetNetworkDrives(
    );


//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//


VOID
ScInitBSM(
    )
/*++

Routine Description:

    This function performs initialization related to network drive arrival
    broadcasts.

    CODEWORK  Should we fail service controller initialization if this fails?
    Event log the cause?

Arguments:

    None

Return Value:

    None

--*/
{
    NTSTATUS ntStatus;
    SECURITY_ATTRIBUTES EventAttrs = { sizeof(SECURITY_ATTRIBUTES), NULL, FALSE };

    //
    // Create the security descriptor for the event.
    // No-one else can wait for the event, but anyone can set it.
    //
    if (! ScCreateBSMEventSD(&EventAttrs.lpSecurityDescriptor))
    {
        SC_LOG(ERROR, "Couldn't create BSM event security descriptor, %lu\n",
                      GetLastError());
        return;
    }

    //
    // Create the event that will be pulsed by the WNet APIs when they
    // want a message broadcast.
    //
    hBSMEvent = CreateEvent(
                    &EventAttrs,        // security attrs
                    FALSE,              // make this an auto-reset event
                    FALSE,              // initial state is nonsignaled
                    SC_BSM_EVENT_NAME   // name
                    );

    if (hBSMEvent == NULL)
    {
        SC_LOG(ERROR, "Couldn't create BSM event, %lu\n", GetLastError());
    }

    LocalFree(EventAttrs.lpSecurityDescriptor);

    if (hBSMEvent == NULL)
    {
        return;
    }

    //
    // Add the work item that will be executed when this event is signaled.
    //
    ntStatus = RtlRegisterWait(&g_hWorkitem,          // work item handle
                               hBSMEvent,             // waitable object handle
                               ScHandleBSMRequest,    // callback function
                               0,                     // parameter for callback function
                               INFINITE,              // infinite wait
                               WT_EXECUTEONLYONCE); // one-time work item

    if (!NT_SUCCESS(ntStatus))
    {
        SC_LOG1(ERROR, "ScInitBSM: RtlRegisterWait failed 0x%x\n", ntStatus);
        CloseHandle(hBSMEvent);
        hBSMEvent = NULL;
    }
}



VOID
ScHandleBSMRequest(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    )
/*++

Routine Description:

    This is the callback function executed when some process sets the BSM
    Request event.

Arguments:

Return Value:

--*/
{
    DWORD    NetDrives;
    NTSTATUS ntStatus;

    DEV_BROADCAST_VOLUME dbv;
    LONG status;

    //
    // If fWaitStatus if TRUE, we're being signalled because of a timeout.
    // Since we registered with an infinite wait, this should NEVER happen
    //
    ASSERT(fWaitStatus == FALSE);

    SC_LOG0(BSM, "Handling a BSM request\n");

    //
    // Deregister the work item (we have to do this even if the
    // WT_EXECUTEONLYONCE flag is specified)
    //
    ntStatus = RtlDeregisterWait(g_hWorkitem);

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG1(ERROR,
                "ScHandleBSMRequest: RtlDeregisterWait FAILED %#x\n",
                ntStatus);
    }

    //
    // Keep broadcasting until the set of net drives stops changing
    //
    for (;;)
    {
        //
        // If we're shutting down, do nothing
        //
        if (ScShutdownInProgress)
        {
            return;
        }

        //
        // Get the current net drive bitmask and compare against the net
        // drive bitmask when we last broadcast
        //
        NetDrives = ScGetNetworkDrives();

        SC_LOG2(BSM, "Previous net drives: %#lx   Now: %#lx\n",
                LastNetDrives, NetDrives);

        if (NetDrives == LastNetDrives)
        {
            break;
        }

        //
        // Broadcast about deleted volumes
        //
        dbv.dbcv_size       = sizeof(dbv);
        dbv.dbcv_devicetype = DBT_DEVTYP_VOLUME;
        dbv.dbcv_reserved   = 0;
        dbv.dbcv_unitmask   = LastNetDrives & ~NetDrives;
        dbv.dbcv_flags      = DBTF_NET;
        if (dbv.dbcv_unitmask != 0)
        {
            DWORD dwRec = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
            SC_LOG0(BSM, "Calling BroadcastSystemMessage...\n");
            status = BroadcastSystemMessage(
                        BSF_FORCEIFHUNG | BSF_NOHANG | BSF_NOTIMEOUTIFNOTHUNG,
                        &dwRec,
                        WM_DEVICECHANGE,
                        (WPARAM) DBT_DEVICEREMOVECOMPLETE,
                        (LPARAM)(DEV_BROADCAST_HDR*)(&dbv)
                        );
            SC_LOG0(BSM, "... returned\n");

            if (status <= 0)
            {
                SC_LOG2(ERROR, "BSM for deleted volumes %#lx FAILED, returned %ld\n",
                        dbv.dbcv_unitmask, status);
            }
        }

        //
        // Broadcast about added volumes
        //
        dbv.dbcv_unitmask   = NetDrives & ~LastNetDrives;
        if (dbv.dbcv_unitmask != 0)
        {
            DWORD dwRec = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
            SC_LOG0(BSM, "Calling BroadcastSystemMessage...\n");

            status = BroadcastSystemMessage(
                        BSF_FORCEIFHUNG | BSF_NOHANG | BSF_NOTIMEOUTIFNOTHUNG,
                        &dwRec,
                        WM_DEVICECHANGE,
                        (WPARAM) DBT_DEVICEARRIVAL,
                        (LPARAM)(DEV_BROADCAST_HDR*)(&dbv)
                        );

            SC_LOG0(BSM, "... returned\n");

            if (status <= 0)
            {
                SC_LOG2(ERROR, "BSM for added volumes %#lx FAILED, returned %ld\n",
                        dbv.dbcv_unitmask, status);
            }
        }

        //
        // Remember the drive set that we last broadcast about
        //
        LastNetDrives = NetDrives;

        //
        // Go around the loop again to detect changes that may have occurred
        // while we were broadcasting
        //
    }

    //
    // Add this work item back to the queue
    //
    SC_LOG0(BSM, "Re-waiting on BSM event\n");

    ntStatus = RtlRegisterWait(&g_hWorkitem,          // work item handle
                               hBSMEvent,             // waitable object handle
                               ScHandleBSMRequest,    // callback function
                               0,                     // parameter for callback function
                               INFINITE,              // infinite wait
                               WT_EXECUTEONLYONCE); // one-time work item

    if (!NT_SUCCESS(ntStatus))
    {
        SC_LOG1(ERROR, "ScInitBSM: RtlRegisterWait failed 0x%x\n", ntStatus);
        // CloseHandle(hBSMRequest);
        // hBSMRequest = NULL;
        // BUGBUG  No more events will be processed.  Event log this?
    }

    return;
}



DWORD
ScGetNetworkDrives(
    )
/*++

Routine Description:

    Returns a drive bitmask similar to GetLogicalDrives, but including
    only the network drives.

Arguments:

Return Value:


--*/
{

    WCHAR wszDrive[] = L" :\\";
    DWORD dwMask = 0;
    DWORD dwCurrDrive = 1;

    // For all the drives
    for (wszDrive[0] = L'A'; wszDrive[0] <= L'Z'; wszDrive[0]++, dwCurrDrive <<= 1)
    {
        if (GetDriveType(wszDrive) == DRIVE_REMOTE)
        {
            dwMask |= dwCurrDrive;
        }
    }

    return dwMask;
}



BOOL
ScCreateBSMEventSD(
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    )
/*++

Routine Description:

    This function creates a security descriptor for the BSM request event.
    It grants EVENT_ALL_ACCESS to local system and EVENT_MODIFY_STATE access
    to the rest of the world.  This prevents principals other than local
    system from waiting for the event.

Arguments:

    SecurityDescriptor - Receives a pointer to the new security descriptor.
        Should be freed with LocalFree.

Return Value:

    TRUE - success

    FALSE - failure, use GetLastError

History:

    AnirudhS  06-Jun-1996   Adapted from LsapAuCreatePortSD in auloop.c

--*/
{
    NTSTATUS    Status;
    ULONG       AclLength;
    PACL        EventDacl;


    //
    // Allocate a buffer to contain the SD followed by the DACL
    // Note, the well-known SIDs are expected to have been created
    // by this time
    //

    AclLength = (ULONG)sizeof(ACL) +
                   (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   RtlLengthSid( LocalSystemSid ) +
                   RtlLengthSid( WorldSid ) +
                   8;       // 8 is for good measure

    *SecurityDescriptor = (PSECURITY_DESCRIPTOR)
        LocalAlloc( 0, SECURITY_DESCRIPTOR_MIN_LENGTH + AclLength );

    if (*SecurityDescriptor == NULL) {
        return FALSE;
    }

    EventDacl = (PACL) ((BYTE*)(*SecurityDescriptor) + SECURITY_DESCRIPTOR_MIN_LENGTH);


    //
    // Set up a default ACL
    //
    //    Public: WORLD:EVENT_MODIFY_STATE, SYSTEM:all

    Status = RtlCreateAcl( EventDacl, AclLength, ACL_REVISION2);

    //
    // WORLD access
    //

    Status = RtlAddAccessAllowedAce (
                 EventDacl,
                 ACL_REVISION2,
                 EVENT_MODIFY_STATE,
                 WorldSid
                 );
    SC_ASSERT( NT_SUCCESS(Status) );


    //
    // SYSTEM access
    //

    Status = RtlAddAccessAllowedAce (
                 EventDacl,
                 ACL_REVISION2,
                 EVENT_ALL_ACCESS,
                 LocalSystemSid
                 );
    SC_ASSERT( NT_SUCCESS(Status) );



    //
    // Now initialize security descriptors
    // that export this protection
    //

    Status = RtlCreateSecurityDescriptor(
                 *SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    SC_ASSERT( NT_SUCCESS(Status) );
    Status = RtlSetDaclSecurityDescriptor(
                 *SecurityDescriptor,
                 TRUE,                       // DaclPresent
                 EventDacl,
                 FALSE                       // DaclDefaulted
                 );
    SC_ASSERT( NT_SUCCESS(Status) );


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scbsm.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scbsm.h

Abstract:

    Network drive BroadcastSystemMessage related function prototypes.

Author:

    Anirudh Sahni (anirudhs)    05-Jun-1996

Revision History:

    05-Jun-1996 AnirudhS
        Created.

--*/

#ifndef SCBSM_INCLUDED
#define SCBSM_INCLUDED


//
// Function Prototypes
//

VOID
ScInitBSM(
    );

#endif // #ifndef SCBSM_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scconfig.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    scconfig.cxx

Abstract:

    This module contains routines for manipulating configuration
    information.

    Configuration information is kept in the registry.
    This file contains the following functions:


        ScGetImageFileName
        ScInitSecurityProcess
        ScCreateLoadOrderGroupList
        ScGenerateServiceDB
        ScOpenServiceConfigKey
        ScReadServiceType
        ScReadStartName
        ScReadFailureActions
        ScWriteDependencies
        ScWriteErrorControl
        ScWriteGroupForThisService
        ScWriteImageFileName
        ScWriteServiceType
        ScWriteStartType
        ScWriteStartName
        ScWriteFailureActions
        ScWriteCurrentServiceValue
        ScReadServiceType
        ScReadStartType
        ScReadErrorControl
        ScReadServiceConfig
        ScAllocateAndReadConfigValue
        ScReadNoInteractiveFlag
        ScReadOptionalString
        ScWriteOptionalString

        ScGetToken
        ScOpenServicesKey
        ScRegCreateKeyExW
        ScRegOpenKeyExW
        ScRegQueryValueExW
        ScRegSetValueExW
        ScRegEnumKeyW

        ScRegDeleteKeyW
        ScRegQueryInfoKeyW
        ScRegGetKeySecurity
        ScRegSetKeySecurity
        ScRegEnumValueW
        ScHandleProviderChange
        ScMarkForDelete
        ScTakeOwnership

Author:

    Dan Lafferty (danl)     01-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    04-Apr-1991     danl
        created
    21-Apr-1992     JohnRo
        Export ScAllocateAndReadConfigValue().  Added ScOpenServiceConfigKey().
        Added ScWriteServiceType() and other ScWrite routines.
        Use SC_LOG0(), etc.  Use FORMAT_ equates.
    24-Apr-1992     JohnRo
        Make ScWriteStartType() write a DWORD, not a string, for consistency.
        Call ScWriteStartType() from ScTransferServiceToRegistry().
        Must call RegSetValueExW (not RegSetValueW) for non-strings.
    29-Apr-1992     JohnRo
        Move registry stuff from System\Services to
        System\Services\CurrentControlSet.
        Undo all group operations (ifdef USE_GROUPS).
        Undo reading from nt.cfg (we've got real registry) (ifdef
        USE_OLDCONFIG).
        They changed winreg APIs so REG_SZ is now UNICODE, so avoid REG_USZ.
    08-Aug-1992     Danl
        Added ScMarkForDelete & ScDeleteFlagIsSet.  ScReadServiceConfig is
        called for each service when generating the service database.  At the
        end of this routine, we check to see if the delete flag is set in
        the registry entry.  If it is, the delete flag is set in the service
        record so it can be deleted later.  After the list of service records
        is complete - and before the dependencies are generated, we call
        ScDeleteMarkedServices which walks through the list and deletes any
        service (in both the registry and linked list) that is marked for
        deletion.
    03-Nov-1992     Danl
        ScReadServiceConfig: If the ScAddCOnfigInfoServiceRecord call fails,
        we just want to skip the database entry - rather than fail the
        ScReadServiceConfig fuction.  Failing ScReadServiceConfig is a fatal
        error for the service controller.
    05-Nov-1992     Danl
        Added ScWriteDisplayName and ScReadDisplayName.  Modified
        ReadServiceConfig to read in the display name.
    29-Mar-1993     Danl
        Added SERVICE_RECOGNIZER_DRIVER as a type that is ignored when reading
        in the Service Database.
    01-Apr-1993 Danl
        Added ScTakeOwnership.  It is called when opening a key that
        complains about access denied.
    30-Apr-1993 Danl
        Put security descriptor in a separate key that only allows read
        access to LocalSystem and Administrators.  Also, we now delete the
        dependencies values from the registry when asked to write an empty
        string of dependencies.
    05-Aug-1993 Danl
        ScRegQueryValueExW: It there is no pointer to a buffer for the data
        to be returned in, then we always want to return
        STATUS_BUFFER_OVERFLOW, even if we successfully read the data into
        the functions internal buffer.
    20-Oct-1993 Danl
        InitSecurityProcess:  Use a global NetLogon service name, and set
        the ScConnectedToSecProc flag when we succeed in connecting to the
        SecurityProcess.
    16-Mar-1994 Danl
        ScRegOpenKeyExW:  Fixed Memory Leak. KeyPath was not being free'd.
        ScRegEnumKeyW:  Fixed Memory Leak. KeyInformation was not being free'd.
    12-Apr-1995 AnirudhS
        Added AccountName field to image record.
    04-Aug-1995 AnirudhS
        Close Lsa Event handle after use.
    05-Feb-1996 AnirudhS
        ScWriteSd: Don't close registry handle twice.  Don't close it at all
        if it's invalid.
    18-Nov-1998 jschwart
        Added ScValidateMultiSZ, since the SCM was assuming all MULTI_SZ
        values were properly double-NUL terminated and AVing when this
        was not the case.

--*/

#include "precomp.hxx"
#include <stdlib.h>     // wide character c runtimes.
#include <string.h>     // ansi character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <sclib.h>      // ScConvertToAnsi
#include <control.h>    // ScWaitForConnect
#include "scconfig.h"   // ScGetToken
#include <valid.h>      // SERVICE_TYPE_INVALID().
#include <strarray.h>   // ScDisplayWStrArray
#include <scseclib.h>   // ScCreateAndSetSD
#include <regrpc.h>     // RPC_SECURITY_DESCRIPTOR
#include "depend.h"     // ScInHardwareProfile

#define ScWinRegErrorToApiStatus( regError ) \
    ( (DWORD) RegError )


//
// Constants
//

#define SECURITY_SERVICES_STARTED   TEXT("SECURITY_SERVICES_STARTED")
#define LSA_RPC_SERVER_ACTIVE       L"LSA_RPC_SERVER_ACTIVE"

#define REG_DELETE_FLAG             L"DeleteFlag"

//
// Registry keys/values
//
#define SERVICES_TREE               L"System\\CurrentControlSet\\Services"
#define CONTROL_TREE                L"System\\CurrentControlSet\\Control"
#define CURRENT_KEY                 L"ServiceCurrent"

#define DEFAULT_SERVICE_TYPE        SERVICE_DRIVER

//
// Used for the Nt Registry API.
//
#define SC_HKEY_LOCAL_MACHINE   L"\\REGISTRY\\MACHINE\\"


//
// Average Number of Bytes in a service record (including name).
//
#define AVE_SR_SIZE         260

//
// Static Global Variables
//

STATIC HKEY ScSGOKey = NULL;
STATIC DWORD Buffer;


//
// Local Function Prototypes
//


DWORD
ScReadServiceConfig(
    IN HKEY ServiceNameKey,
    IN LPWSTR ServiceName
    );

BOOL
ScDeleteFlagIsSet(
    HKEY    ServiceKeyHandle
    );

DWORD
ScTakeOwnership(
    POBJECT_ATTRIBUTES  pObja
    );

DWORD
ScOpenSecurityKey(
    IN HKEY     ServiceNameKey,
    IN DWORD    DesiredAccess,
    IN BOOL     CreateIfMissing,
    OUT PHKEY   pSecurityKey
    );

VOID
ScWaitForLsa(
    );



DWORD
ScGetEnvironment (
    IN  LPWSTR  ServiceName,
    OUT LPVOID  *Environment
    )

/*++


Routine Description:

    Retrieves the environment block for the service. This is stored
    in the registry under the Environment value. The cluster service
    uses this to pass an environment block to services under control
    of the cluster software.

    This routine allocates storage for the environment block and the
    caller is responsible for freeing this with LocalFree.

Arguments:

    ServiceName - This is a pointer to a service name.  This identifies
        the service for which we desire an environment

    Environment - Returns a pointer to a location where the environment
        is to be placed.  This memory should be freed with LocalFree.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_PATH_NOT_FOUND - The environment could not be found
        or there was a registry error.

--*/
{
    DWORD ApiStatus;
    HKEY ServiceKey;
    DWORD EnvironmentSize;

    SC_ASSERT( ServiceName != NULL );

    //
    // Open the service key.
    //
    ApiStatus = ScOpenServiceConfigKey(
                   ServiceName,
                   KEY_READ,                    // desired access
                   FALSE,                       // don't create if missing.
                   &ServiceKey
                   );

    if (ApiStatus != NO_ERROR) {
        return ERROR_PATH_NOT_FOUND;
    }

    //
    // Read the binary path name
    //
    ApiStatus = ScAllocateAndReadConfigValue(ServiceKey,
                                             ENVIRONMENT_VALUENAME_W,
                                             (LPWSTR *)Environment,
                                             &EnvironmentSize);
    ScRegCloseKey(ServiceKey);
    if (ApiStatus != NO_ERROR) {
        return ERROR_PATH_NOT_FOUND;
    }

    ApiStatus = ScValidateMultiSZ((LPWSTR) *Environment,
                                  EnvironmentSize);

    if (ApiStatus != NO_ERROR) {

        LocalFree(*Environment);
        *Environment = NULL;
    }

    return ApiStatus;
}


DWORD
ScGetImageFileName (
    IN  LPWSTR  ServiceName,
    OUT LPWSTR  *ImageNamePtr
    )

/*++


Routine Description:

    Retreives the Name of the Image File in which the specified service
    can be found.  This routine allocates storage for the name so that
    a pointer to that name can be returned.

Arguments:

    ServiceName - This is a pointer to a service name.  This identifies
        the service for which we desire an image file name.

    ImageNamePtr - Returns a pointer to a location where the Image Name
        pointer is to be placed.  This memory should be freed with
        LocalFree.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_PATH_NOT_FOUND - The configuration component could not be found
        or there was a registry error.

--*/
{
    DWORD ApiStatus;
    HKEY ServiceKey;

    SC_ASSERT( ServiceName != NULL );

    //
    // Open the service key.
    //
    ApiStatus = ScOpenServiceConfigKey(
                   ServiceName,
                   KEY_READ,                    // desired access
                   FALSE,                       // don't create if missing.
                   &ServiceKey
                   );

    if (ApiStatus != NO_ERROR) {
        return ERROR_PATH_NOT_FOUND;
    }

    //
    // Read the binary path name
    //
    if (ScAllocateAndReadConfigValue(
              ServiceKey,
              IMAGE_VALUENAME_W,
              ImageNamePtr,
              NULL
              ) != NO_ERROR) {
        (void) ScRegCloseKey(ServiceKey);
        return ERROR_PATH_NOT_FOUND;
    }

    (void) ScRegCloseKey(ServiceKey);

    SC_LOG1(CONFIG, "ScGetImageFileName got " FORMAT_LPWSTR " from registry\n",
            *ImageNamePtr);

    return NO_ERROR;
}

#ifndef _CAIRO_

BOOL
ScInitSecurityProcess(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function determines the name of the security process, and then
    initializes a control pipe for it.  A global named event is then
    set.  This causes the security process to start its control dispatcher.
    The control dispatcher should then open the other end of the pipe and
    send its process id.  The processId and the name of the image file
    are stored in an image record for the security process.  The service
    instance count is incremented in this image record so that the
    record will never be deleted and the security process is never
    terminated.


    QUESTION:
        What is the proper behavior if this fails?

Arguments:

    ServiceRecord -- The service record of the service being started.
                     Note that as per the check in ScStartService, this
                     service runs in the security process (and is the
                     first service in that process being started)

Return Value:

    TRUE - The initialization was successful.

    FALSE - The initialization failed.  This indicates means that the
        service controller shouldn't continue with its initialization.
        If FALSE is returned, the service's service record has been
        marked (in the START_TYPE field) as disabled.

--*/
{
    DWORD               status;
    HANDLE              pipeHandle;
    LPIMAGE_RECORD      imageRecord;
    HANDLE              eventHandle;
    DWORD               processId;

    //
    // Create an instance of the control pipe.  Use an ID of 0 for lsass.exe
    // since it's possible for it to create its end of the pipe before we
    // ever get to this function.
    //

    status = ScCreateControlInstance (&pipeHandle, 0, LocalSystemSid);

    if (status != NO_ERROR) {

        SC_LOG1(ERROR,
                "ScInitSecurityProcess: ScCreateControlInstance Failure "
                    FORMAT_DWORD "\n",
                status);

        ServiceRecord->StartType = SERVICE_DISABLED;
        return FALSE;
    }

    //
    // Set the event that will cause the Control dispatcher in the
    // Security Process to be started.
    //

    eventHandle = CreateEvent( NULL,    // No special security
                               TRUE,    // Must be manually reset
                               FALSE,   // The event is initially not signalled
                               SECURITY_SERVICES_STARTED );


    if (eventHandle == NULL){
        status = GetLastError();

        //
        // If the event already exists, the security process beat us to
        // creating it.  Just open it.
        //

        if ( status == ERROR_ALREADY_EXISTS ) {

            eventHandle = OpenEvent( GENERIC_WRITE,
                                     FALSE,
                                     SECURITY_SERVICES_STARTED );

        }

        if (eventHandle == NULL ) {

            SC_LOG1(ERROR,"ScInitSecurityProcess: OpenEvent Failed "
                    FORMAT_DWORD "\n", status);

            CloseHandle(pipeHandle);
            ServiceRecord->StartType = SERVICE_DISABLED;
            return FALSE;
        }
    }

    if (!SetEvent(eventHandle)) {

        SC_LOG1(ERROR,"ScInitSecurityProcess: SetEvent Failed " FORMAT_DWORD
                "\n", GetLastError());
        CloseHandle(pipeHandle);
        CloseHandle(eventHandle);
        ServiceRecord->StartType = SERVICE_DISABLED;
        return FALSE;
    }

    //
    // Wait for the Security Process to attach to the pipe and get its PID
    //

    status = ScWaitForConnect(pipeHandle,
                              NULL,
                              ServiceRecord->DisplayName,
                              &processId);

    if (status != NO_ERROR) {

        SC_LOG1(ERROR,"ScInitSecurityProcess:"
                "SecurityProcess did not attach to pipe " FORMAT_DWORD "\n",
                status);
        CloseHandle(pipeHandle);
        CloseHandle(eventHandle);
        ServiceRecord->StartType = SERVICE_DISABLED;
        return FALSE;
    }

    //
    // Don't close the event handle until we know the security process has
    // seen the event.
    //

    CloseHandle(eventHandle);

    //
    //  NOTE:  The image record does not have a valid processHandle.
    //  Therefore, we will never be able to terminate it.  This is desired
    //  behavior though.  We should never terminate the security process.
    //

    status = ScCreateImageRecord (
                &imageRecord,
                ScGlobalSecurityExePath,
                NULL,           // Account name is LocalSystem
                processId,
                pipeHandle,
                NULL,           // The process handle is NULL.
                NULL,           // Token handle is also NULL -- LocalSystem
                NULL,           // No user profile loaded -- LocalSystem
                CANSHARE_FLAG |
                    IS_SYSTEM_SERVICE);

    if (status != NO_ERROR) {

        SC_LOG0(ERROR,"Failed to create ImageRecord for Security Process\n");
        ServiceRecord->StartType = SERVICE_DISABLED;
        return FALSE;
    }

    imageRecord->ServiceCount = 1;

    ScConnectedToSecProc = TRUE;

    return TRUE;
}
#endif // _CAIRO_


BOOL
ScCreateLoadOrderGroupList(
    VOID
    )
/*++

Routine Description:

    This function creates the load order group list from the group
    order information found in HKEY_LOCAL_SYSTEM\Service_Group_Order

Arguments:

    None

Return Value:

    TRUE - The operation was completely successful.

    FALSE - An error occurred.

Note:

    The GroupListLock must be held exclusively prior to calling this routine.

--*/
{
    DWORD status;
    DWORD dwGroupBytes;

    LONG RegError;
    LPWSTR Groups;
    LPWSTR GroupPtr;
    LPWSTR GroupName;

    SC_ASSERT(ScGroupListLock.HaveExclusive());

    //
    // Open the HKEY_LOCAL_MACHINE
    // System\CurrentControlSet\Control\ServiceGroupOrder key.
    //
    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   LOAD_ORDER_GROUP_LIST_KEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ,                  // desired access
                   &ScSGOKey
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG1(ERROR,
               "ScCreateLoadOrderGroupList: "
               "ScRegOpenKeyExW of HKEY_LOCAL_MACHINE\\System failed "
               FORMAT_LONG "\n", RegError);
        return FALSE;
    }

    //
    // Read the List value
    //
    if (ScAllocateAndReadConfigValue(
              ScSGOKey,
              GROUPLIST_VALUENAME_W,
              &Groups,
              &dwGroupBytes
              ) != NO_ERROR) {

        ScRegCloseKey(ScSGOKey);
        ScSGOKey = NULL;
        return FALSE;
    }

    if (ScValidateMultiSZ(
              Groups,
              dwGroupBytes
              ) != NO_ERROR) {

        LocalFree(Groups);
        ScRegCloseKey(ScSGOKey);
        ScSGOKey = NULL;
        return FALSE;
    }

    //
    // Leave the ServiceGroupOrder key open for change notify later
    //

    SC_LOG0(DEPEND_DUMP, "ScCreateLoadOrderGroupList: ServiceGroupOrder:\n");
    ScDisplayWStrArray(Groups);

    GroupPtr = Groups;
    while (*GroupPtr != 0) {

        if (ScGetToken(&GroupPtr, &GroupName)) {

            //
            // Add the group to the end of the load order group list
            //
            status = ScCreateOrderGroupEntry(
                         GroupName
                         );

            if (status != NO_ERROR) {
                //
                // Fatal error
                //
                LocalFree(Groups);
                return FALSE;
            }
        }
    }

    LocalFree(Groups);
    return TRUE;
}


BOOL
ScGenerateServiceDB(
    VOID
    )
/*++

Routine Description:

    This function creates the service record list from the information
    which resides in the registry.

Arguments:

    None

Return Value:

    TRUE - The operation was completely successful.

    FALSE - An error occurred.

NOTE:
    This function holds the GroupListLock.

--*/
{
#define MAX_SERVICE_NAME_LENGTH   256

    WCHAR ServiceName[MAX_SERVICE_NAME_LENGTH];
    DWORD Index = 0;

    LONG RegError;
    LONG lTempError;    // Used for debug messages only
    HKEY ServicesKey;
    HKEY ServiceNameKey;

    WCHAR       ClassName[ MAX_PATH ];
    DWORD       ClassNameLength = MAX_PATH;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;
    DWORD       HeapSize;


    //
    // Since there is only one thread at the time this function is called,
    // these locks are not really needed, but they are included to quell
    // assertions in the routines called herein.
    //
    CGroupListExclusiveLock GLock;
    CServiceListExclusiveLock LLock;
    CServiceRecordExclusiveLock RLock;

    //
    // Read in the group order list from the registry
    //
    if (! ScCreateLoadOrderGroupList()) {
        return FALSE;
    }

    //
    // Read in all the services entries from the registry
    //

    //
    // Open the key to the Services tree.
    //
    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   SERVICES_TREE,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ,                  // desired access
                   &ServicesKey
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG1(ERROR,
                "ScGenerateServiceDB: ScRegOpenKeyExW of Services tree failed "
                FORMAT_LONG "\n", RegError);
        return FALSE;
    }


    //
    // Find out how many service keys there are, and allocate a heap
    // that is twice as large.
    //
    RegError = ScRegQueryInfoKeyW(
                ServicesKey,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime);

    if (RegError != NO_ERROR) {
        SC_LOG1(ERROR,"ScGenerateServiceDatabase: RegQueryInfoKey failed %d\n",
        RegError);
        HeapSize = 0x8000;
    }
    else {
        SC_LOG1(INFO,"ScGenerateServiceDatabase: %d SubKeys\n",NumberOfSubKeys);
        HeapSize = NumberOfSubKeys*2*AVE_SR_SIZE;
    }

    if (!ScAllocateSRHeap(HeapSize)) {
        return(FALSE);
    }

    //
    // Enumerate all the service name keys
    //
    do {

        RegError = ScRegEnumKeyW(
                       ServicesKey,
                       Index,
                       ServiceName,
                       MAX_SERVICE_NAME_LENGTH * sizeof(WCHAR)
                       );

        if (RegError != ERROR_SUCCESS) {

            if (RegError == ERROR_NO_MORE_ITEMS) {
                //
                // No more entries
                //
                SC_LOG1(CONFIG,
                       "ScGenerateServiceDB: ScRegEnumKeyW returns ERROR_NO_MORE_ITEMS"
                       "(no more entries) for index " FORMAT_DWORD "\n",
                       Index);
            }
            else {
                //
                // Error trying to enumerate next service name key
                //
                SC_LOG1(ERROR,
                        "ScGenerateServiceDB: ScRegEnumKeyW of services tree failed "
                        FORMAT_LONG "\n", RegError );
                ScRegCloseKey(ServicesKey);
                return FALSE;
            }
        }
        else {
            //
            // Got the name of a new service key.  Open a handle to it.
            //
            SC_LOG1(CONFIG, "Service name key " FORMAT_LPWSTR "\n",
                    ServiceName);

            lTempError = ScRegOpenKeyExW(
                           ServicesKey,
                           ServiceName,
                           REG_OPTION_NON_VOLATILE,   // options
                           KEY_READ,                  // desired access
                           &ServiceNameKey);

            if (lTempError == ERROR_SUCCESS)
            {
                //
                // Read service config info from the registry and build the
                // service record.
                //
                lTempError = ScReadServiceConfig(
                               ServiceNameKey,
                               ServiceName);

                ScRegCloseKey(ServiceNameKey);

                if (lTempError != NO_ERROR)
                {
                    //
                    // Skip this key
                    //
                    SC_LOG2(ERROR,
                            "ScGenerateServiceDB: ScReadServiceConfig of "
                                   FORMAT_LPWSTR " failed " FORMAT_LONG "\n",
                           ServiceName,
                           lTempError);
                }
            }
            else
            {
                //
                // Skip this key
                //
                SC_LOG2(ERROR,
                        "ScGenerateServiceDB: ScRegOpenKeyExW of "
                               FORMAT_LPWSTR " failed " FORMAT_LONG "\n",
                       ServiceName,
                       lTempError);
            }
        }

        Index++;

    } while (RegError == ERROR_SUCCESS);

    ScRegCloseKey(ServicesKey);

    //
    // Wait for LSA to start since we are about to make our first call to
    // LSA and it typically is not already started yet.
    //
    ScWaitForLsa();

    //
    // Go through entire service record list and remove any services marked
    // for deletion.
    //
    ScDeleteMarkedServices();

    //
    // Go through entire service record list and resolve dependencies chain
    //
    ScGenerateDependencies();

#if DBG
    ScDumpGroups();
    ScDumpServiceDependencies();
#endif // DBG


    return TRUE;
}

VOID
ScWaitForLsa(
    )
/*++

Routine Description:

    This routine either creates or opens the event called LSA_RPC_SERVER_ACTIVE
    event and waits on it indefinitely until LSA signals it.  We need
    to know when LSA is available so that we can call LSA APIs.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD Status;
    HANDLE EventHandle;


    //
    // Create the named event LSA will set.
    //
    EventHandle = CreateEventW(
                      NULL,   // No special security
                      TRUE,   // Must be manually reset
                      FALSE,  // The event is initially not signalled
                      LSA_RPC_SERVER_ACTIVE
                      );

    if ( EventHandle == NULL ) {

        Status = GetLastError();

        //
        // If the event already exists, LSA has already created it.
        // Just open.
        //

        if ( Status == ERROR_ALREADY_EXISTS ) {

            EventHandle = OpenEventW(
                              SYNCHRONIZE,
                              FALSE,
                              LSA_RPC_SERVER_ACTIVE
                              );
        }

        if ( EventHandle == NULL ) {

            SC_LOG1(ERROR, "ScWaitForLsa: OpenEvent of LSA_RPC_SERVER_ACTIVE failed %d\n",
                    GetLastError());

            return;
        }
    }

    //
    // Wait for LSA to come up.
    //
    (VOID) WaitForSingleObject( EventHandle, INFINITE );

    CloseHandle( EventHandle );
}


DWORD
ScOpenServiceConfigKey(
    IN LPWSTR ServiceName,
    IN DWORD DesiredAccess,
    IN BOOL CreateIfMissing,
    OUT PHKEY ServiceKey
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    HKEY ServicesKey;
    HKEY ServiceNameKey;
    DWORD   ServicesAccess = KEY_READ;

    LONG RegError;

    SC_ASSERT( ServiceName != NULL );
    if (CreateIfMissing) {
        ServicesAccess |= KEY_CREATE_SUB_KEY;
    }

    //
    // Open the key to the Services tree.
    //
    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   SERVICES_TREE,
                   REG_OPTION_NON_VOLATILE, // options
                   ServicesAccess,          // desired access (this level)
                   &ServicesKey
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG1(ERROR, "ScOpenServiceConfigKey: "
                "ScRegOpenKeyExW of Services tree failed, reg error "
                FORMAT_LONG "\n", RegError);

        return ((DWORD) RegError);
    }

    if ( !CreateIfMissing ) {
        //
        // Open the existing service key.
        //
        RegError = ScRegOpenKeyExW(
               ServicesKey,
               ServiceName,
               REG_OPTION_NON_VOLATILE,   // options
               DesiredAccess,             // desired access
               & ServiceNameKey );

        if (RegError != ERROR_SUCCESS) {
            SC_LOG2(ERROR, "ScOpenServiceConfigKey: "
                    "ScRegOpenKeyExW of " FORMAT_LPWSTR " failed "
                    FORMAT_LONG "\n", ServiceName, RegError);
            (void) ScRegCloseKey(ServicesKey);
            return ((DWORD) RegError);
        }

    } else {

        DWORD Disposition;

        //
        // Create a new service key (or open existing one).
        //
        RegError = ScRegCreateKeyExW(
                ServicesKey,
                ServiceName,
                0,
                0,
                REG_OPTION_NON_VOLATILE, // options
                DesiredAccess,           // desired access
                NULL,
                &ServiceNameKey,
                &Disposition);

         if (RegError != ERROR_SUCCESS) {
             SC_LOG2(ERROR, "ScOpenServiceConfigKey: "
                     "ScRegCreateKeyExW of " FORMAT_LPWSTR " failed "
                     FORMAT_LONG "\n", ServiceName, RegError);
             ScRegCloseKey(ServicesKey);
             return ((DWORD) RegError);
         }

    }

    (void) ScRegCloseKey(ServicesKey);

    //
    // Give the service key back to caller.
    //
    *ServiceKey = ServiceNameKey;

    return NO_ERROR;

} // ScOpenServiceConfigKey


DWORD
ScWriteCurrentServiceValue(
    OUT LPDWORD  lpdwID
    )

/*++

Routine Description:

    Writes the value to be used in the next service's pipe name to the registry

Arguments:


Return Value:


--*/
{
    LONG                 RegError;
    NTSTATUS             ntstatus;
    SECURITY_ATTRIBUTES  SecurityAttr;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    DWORD                Disposition;

    //
    // Unique ID for the service to be started.  Start
    // at 1 since ID 0 is reserved for lsass.exe
    //
    static DWORD         s_dwCurrentService = 1;
    static HKEY          s_hCurrentKey      = NULL;


    SC_ASSERT(lpdwID != NULL);

    if (s_hCurrentKey == NULL)
    {
        HKEY  hKey;

        //
        // Open the key to the Services tree.
        //
        RegError = ScRegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       CONTROL_TREE,
                       0,                       // options (ignored)
                       KEY_WRITE,               // KEY_SET_VALUE | KEY_CREATE_SUB_KEY
                       &hKey
                       );

        if (RegError != ERROR_SUCCESS)
        {
            SC_LOG1(ERROR,
                    "ScWriteCurrentServiceValue: ScRegOpenKeyExW of Control tree failed, reg error "
                        FORMAT_LONG "\n",
                    RegError);

            return ((DWORD) RegError);
        }


#define SC_KEY_ACE_COUNT 2

        SC_ACE_DATA AceData[SC_KEY_ACE_COUNT] = {

            {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
                   GENERIC_ALL,                &LocalSystemSid},
            {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
                   GENERIC_READ,               &WorldSid}

            };


        //
        // Create a security descriptor for the registry key we are about
        // to create.  This gives everyone read access, and all access to
        // ourselves only.
        //
        ntstatus = ScCreateAndSetSD(
                       AceData,
                       SC_KEY_ACE_COUNT,
                       LocalSystemSid,
                       LocalSystemSid,
                       &SecurityDescriptor
                       );

#undef SC_KEY_ACE_COUNT

        if (! NT_SUCCESS(ntstatus)) {
            SC_LOG1(ERROR, "ScCreateAndSetSD failed " FORMAT_NTSTATUS
                    "\n", ntstatus);

            ScRegCloseKey(hKey);
            return(RtlNtStatusToDosError(ntstatus));
        }

        SecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttr.lpSecurityDescriptor = SecurityDescriptor;
        SecurityAttr.bInheritHandle = FALSE;

        //
        // Create a new  key (or open existing one).
        //
        RegError = ScRegCreateKeyExW(
                        hKey,
                        CURRENT_KEY,
                        0,
                        0,
                        REG_OPTION_VOLATILE, // options
                        KEY_SET_VALUE,       // desired access
                        &SecurityAttr,
                        &s_hCurrentKey,
                        &Disposition);

        RtlDeleteSecurityObject(&SecurityDescriptor);
        ScRegCloseKey(hKey);

        if (RegError != ERROR_SUCCESS)
        {
            SC_LOG1(ERROR,
                    "ScWriteCurrentServiceValue: ScRegCreateKeyExW of "
                        "CURRENT_KEY failed " FORMAT_LONG "\n",
                    RegError);

            return ((DWORD) RegError);
        }
    }

    //
    // Write the value in the key
    //

    RegError = ScRegSetValueExW(
                   s_hCurrentKey,
                   NULL,           // Use key's unnamed value
                   0,
                   REG_DWORD,
                   (LPBYTE) &s_dwCurrentService,
                   sizeof(DWORD));

    if (RegError != ERROR_SUCCESS)
    {
        SC_LOG1(ERROR,
                "ScWriteCurrentServiceValue: ScRegCreateKeyExW of "
                    "CURRENT_KEY failed " FORMAT_LONG "\n",
                RegError);

        return ((DWORD) RegError);
    }

    *lpdwID = s_dwCurrentService;
    s_dwCurrentService++;

    return NO_ERROR;

} // ScWriteCurrentServiceValue


DWORD
ScReadServiceType(
    IN HKEY ServiceNameKey,
    OUT LPDWORD ServiceTypePtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( ServiceTypePtr != NULL );

    *ServiceTypePtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   SERVICETYPE_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) ServiceTypePtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(TRACE, "ScReadServiceType: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                SERVICETYPE_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScReadServiceType

DWORD
ScReadNoInteractiveFlag(
    IN HKEY ServiceNameKey,
    OUT LPDWORD NoInteractivePtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( NoInteractivePtr != NULL );

    *NoInteractivePtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   NOINTERACTIVE_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) NoInteractivePtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(ERROR, "ScReadNoInteractiveFlag: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                NOINTERACTIVE_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScReadServiceType


DWORD
ScReadStartType(
    IN HKEY ServiceNameKey,
    OUT LPDWORD StartTypePtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( StartTypePtr != NULL );

    *StartTypePtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   START_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) StartTypePtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(ERROR, "ScReadStartType: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                START_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ));

} // ScReadStartType


DWORD
ScReadTag(
    IN HKEY ServiceNameKey,
    OUT LPDWORD TagPtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( TagPtr != NULL );

    *TagPtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   TAG_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) TagPtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(CONFIG, "ScReadTag: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                START_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ));

} // ScReadTag


DWORD
ScReadErrorControl(
    IN HKEY ServiceNameKey,
    OUT LPDWORD ErrorControlPtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( ErrorControlPtr != NULL );

    *ErrorControlPtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   ERRORCONTROL_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) ErrorControlPtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(ERROR, "ScReadErrorControl: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                ERRORCONTROL_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ));


} // ScReadErrorControl



DWORD
ScReadFailureActions(
    IN HKEY ServiceNameKey,
    OUT LPSERVICE_FAILURE_ACTIONS_WOW64 * FailActPtr,
    IN OUT LPDWORD TotalBytes OPTIONAL
    )
/*++

Routine Description:

    This function attempts to read the value for the non-string portion
    of the service's failure actions configuration from the registry.
    If the value does not exist, or is invalid, this function sets the
    pointer to the value to NULL and returns NO_ERROR.  If any other error
    occurs, the error is returned.

    NOTE:  On return from this function, a buffer with the value will be
        allocated, or the pointer will be NULL.  If a buffer is allocated,
        it contains both the fixed-size structure and the array of actions.

Arguments:

    ServiceNameKey - This is the Service's Key handle.

    FailActPtr - This is a pointer to a location where the pointer to
        the failure actions information is to be placed.

    TotalBytes - If present, this DWORD is INCREMENTED by the number of bytes
        needed to store the string.

Return Value:


--*/
{
    DWORD BytesReturned;
    LONG RegError = ScAllocateAndReadConfigValue(
                ServiceNameKey,
                FAILUREACTIONS_VALUENAME_W,
                (LPWSTR *) FailActPtr,
                &BytesReturned
                );

    if (RegError != ERROR_SUCCESS)
    {
        if (RegError == ERROR_FILE_NOT_FOUND)
        {
            RegError = NO_ERROR;
        }

        *FailActPtr = NULL;

        return RegError;
    }

    //
    // Validate the value read.  Treat a bogus value as no value.
    //
    if ((BytesReturned < sizeof(SERVICE_FAILURE_ACTIONS_WOW64)) ||
        (BytesReturned != sizeof(SERVICE_FAILURE_ACTIONS_WOW64) +
                          (*FailActPtr)->cActions * sizeof(SC_ACTION)))
    {
        LocalFree(*FailActPtr);
        *FailActPtr = NULL;
        return NO_ERROR;
    }

    //
    // Fix up the pointer to the array.
    //
    (*FailActPtr)->dwsaActionsOffset = sizeof(SERVICE_FAILURE_ACTIONS_WOW64);

    //
    // Increment the total number of bytes used.
    //
    if (ARGUMENT_PRESENT(TotalBytes))
    {
        *TotalBytes += BytesReturned;
    }

    return NO_ERROR;

} // ScReadFailureActions


DWORD
ScReadOptionalString(
    IN  HKEY    ServiceNameKey,
    IN  LPCWSTR ValueName,
    OUT LPWSTR  *Value,
    IN OUT LPDWORD TotalBytes OPTIONAL
    )
/*++

Routine Description:

    This function attempts to read the value for the optional string
    configuration parameter from the registry.  If this read fails because
    the value does no exist, then this function sets the pointer to the
    value string to NULL, and returns NO_ERROR.  If any other error occurs,
    the error is returned.

    NOTE:  On successful return from this function, a buffer with the
        string value will be allocated, or the pointer will be NULL.
        If a string is returned, it is guaranteed to be non-empty and
        null-terminated (if the registry value was not null-terminated,
        its last character will be overwritten).

Arguments:

    ServiceNameKey - This is the Service's Key handle.

    ValueName - Name of the registry value from which to read.

    Value - This is a pointer to a location where the pointer to the
        string is to be placed.

    TotalBytes - If present, this DWORD is INCREMENTED by the number of bytes
        needed to store the string.

Return Value:



--*/
{
    DWORD BytesReturned;
    LONG RegError = ScAllocateAndReadConfigValue(
                ServiceNameKey,
                ValueName,
                Value,
                &BytesReturned
                );

    if (RegError != ERROR_SUCCESS)
    {
        // Nothing read from the registry.
        if (RegError == ERROR_FILE_NOT_FOUND)
        {
            RegError = NO_ERROR;
        }

        *Value = NULL;
        BytesReturned = 0;
    }
    else
    {
        // We read something from the registry.  Make sure it's
        // null-terminated.
        if (BytesReturned < sizeof(L" "))
        {
            LocalFree(*Value);
            *Value = NULL;
            BytesReturned = 0;
        }
        else
        {
            (*Value)[BytesReturned/sizeof(WCHAR) - 1] = L'\0';
        }
    }

    //
    // Increment the total number of bytes used.
    //
    if (ARGUMENT_PRESENT(TotalBytes))
    {
        *TotalBytes += (BytesReturned/sizeof(WCHAR)) * sizeof(WCHAR);
    }

    return RegError;

} // ScReadOptionalString


DWORD
ScReadStartName(
    IN HKEY ServiceNameKey,
    OUT LPWSTR *AccountName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    return ScAllocateAndReadConfigValue(
               ServiceNameKey,
               STARTNAME_VALUENAME_W,
               AccountName,
               NULL
               );

} // ScReadStartName


DWORD
ScReadSd(
    IN HKEY ServiceNameKey,
    OUT PSECURITY_DESCRIPTOR *Sd
    )
/*++

Routine Description:

    This function reads the security descriptor for the service

Arguments:



Return Value:



--*/
{
    LONG    RegError;
    HKEY    SecurityKey;
    DWORD   status;


    //
    // Open the Security Sub-key (under the services key).
    // NOTE:  This key may not exist, and that is ok.
    //
    RegError = ScOpenSecurityKey(
                ServiceNameKey,
                KEY_READ,
                FALSE,              // Do not create if missing.
                &SecurityKey);

    if (RegError != NO_ERROR) {
        SC_LOG1(TRACE,"ScReadSd:ScOpenSecurityKey Failed %d\n",RegError);
        return(ScWinRegErrorToApiStatus(RegError));
    }

    //
    // Read the Security Descriptor value stored under the security key.
    //
    status = ScAllocateAndReadConfigValue(
                 SecurityKey,
                 SD_VALUENAME_W,
                 (LPWSTR *) Sd,
                 NULL);

    if (status == NO_ERROR)
    {
        if (RtlValidSecurityDescriptor(*Sd))
        {
            status = NO_ERROR;
        }
        else
        {
            LocalFree(*Sd);
            *Sd = NULL;
            status = ERROR_FILE_NOT_FOUND;
        }
    }

    RegCloseKey(SecurityKey);
    return status;

} // ScReadSd



DWORD
ScWriteDependencies(
    IN HKEY ServiceNameKey,
    IN LPWSTR Dependencies,
    IN DWORD DependSize
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;
    LPWSTR DependOnService;
    LPWSTR DependOnGroup;
    LPWSTR DestService;
    LPWSTR DestGroup;
    DWORD DependencyLength;


    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( Dependencies != NULL );

    //
    // If the dependencies string is empty, then delete the dependency
    // values from the registry and return.  If errors occur during the
    // delete, we ignore them.  It could be that there aren't any existing
    // dependencies, so that the depend values don't exist to begin with.
    // Also, it the delete fails, we can't do anything about it anyway.
    //
    if (*Dependencies == L'\0') {

        RegError = ScRegDeleteValue(ServiceNameKey,DEPENDONSERVICE_VALUENAME_W);
        if ((RegError != ERROR_SUCCESS) && (RegError != ERROR_FILE_NOT_FOUND)) {
            SC_LOG1(ERROR, "Failed to delete DependOnService Value "
                "" FORMAT_LONG "\n",RegError);
        }
        RegError = ScRegDeleteValue(ServiceNameKey,DEPENDONGROUP_VALUENAME_W);
        if ((RegError != ERROR_SUCCESS) && (RegError != ERROR_FILE_NOT_FOUND)) {
            SC_LOG1(ERROR, "Failed to delete DependOnGroup Value "
                "" FORMAT_LONG "\n",RegError);
        }
        return(NO_ERROR);
    }

    //
    // Allocate a buffer which is twice the size of DependSize so that
    // we can split the Dependencies array string into a DependOnService,
    // and a DependOnGroup array strings.
    //
    if ((DependOnService = (LPWSTR)LocalAlloc(
                               LMEM_ZEROINIT,
                               (UINT) (2 * DependSize)
                               )) == NULL) {
        SC_LOG1(ERROR, "ScWriteDependencies: LocalAlloc failed " FORMAT_DWORD "\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DependOnGroup = (LPWSTR) ((DWORD_PTR) DependOnService + DependSize);

    DestService = DependOnService;
    DestGroup = DependOnGroup;

    while ((*Dependencies) != 0) {

        if (*Dependencies == SC_GROUP_IDENTIFIERW) {

            Dependencies++;
            DependencyLength = (DWORD) wcslen(Dependencies) + 1;

            wcscpy(DestGroup, Dependencies);
            DestGroup += DependencyLength;
        }
        else {

            DependencyLength = (DWORD) wcslen(Dependencies) + 1;

            wcscpy(DestService, Dependencies);
            DestService += DependencyLength;
        }

        Dependencies += DependencyLength;
    }

    //
    // Write the DependOnService array string
    //
    RegError = ScRegSetValueExW(
                   ServiceNameKey,                  // open handle (to section)
                   DEPENDONSERVICE_VALUENAME_W,
                   0,
                   REG_MULTI_SZ,                    // type (NULL-NULL UNICODE string)
                   (LPBYTE) DependOnService,        // data
                   ScWStrArraySize(DependOnService) // byte count for data
                   );

    if (RegError != ERROR_SUCCESS) {
#if DBG
        SC_LOG1(ERROR, "ScWriteDependOnService: ScRegSetValueExW returned "
                FORMAT_LONG "\n", RegError);
        ScDisplayWStrArray(DependOnService);
#endif
        goto CleanExit;
    }

    //
    // Write the DependOnGroup array string
    //
    RegError = ScRegSetValueExW(
                   ServiceNameKey,                  // open handle (to section)
                   DEPENDONGROUP_VALUENAME_W,
                   0,
                   REG_MULTI_SZ,                    // type (NULL-NULL UNICODE string)
                   (LPBYTE) DependOnGroup,          // data
                   ScWStrArraySize(DependOnGroup)   // byte count for data
                   );

    if (RegError != ERROR_SUCCESS) {
#if DBG
        SC_LOG1(ERROR, "ScWriteDependOnGroup: ScRegSetValueExW returned "
                FORMAT_LONG "\n", RegError);
        ScDisplayWStrArray(DependOnGroup);
#endif
        goto CleanExit;
    }

CleanExit:
    LocalFree(DependOnService);
    if (RegError != NO_ERROR) {
        SC_LOG2(ERROR, "ScWriteDependencies (%ws) Error %d \n",
        Dependencies,RegError);
    }

    return (ScWinRegErrorToApiStatus( RegError ));

} // ScWriteDependencies


DWORD
ScWriteOptionalString(
    IN HKEY ServiceNameKey,
    IN LPCWSTR ValueName,
    IN LPCWSTR Value
    )
/*++

Routine Description:

    This function writes the specified string value to the registry for the
    particular key.  If the value is a NULL pointer, we don't do anything.  If
    the value is an empty string, we delete the registry value.

Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( ValueName != NULL && ValueName[0] != L'\0' );

    //
    // A NULL value means no change.
    //
    if (Value == NULL)
    {
        return NO_ERROR;
    }

    if (Value[0] != L'\0')
    {
        //
        // Write the Value
        //
        RegError = ScRegSetValueExW(
                       ServiceNameKey,           // open key handle
                       ValueName,                // value name
                       0,
                       REG_SZ,                   // type (zero-terminated UNICODE)
                       (LPBYTE) Value,           // data
                       (DWORD) WCSSIZE(Value));  // byte count for data

        if (RegError != ERROR_SUCCESS)
        {
            SC_LOG3(ERROR, "ScWriteStringParm: ScRegSetValueExW of \"%ws\" "
                    "to reg value %ws failed %ld\n",
                    Value, ValueName, RegError);
        }

        return RegError;
    }
    else
    {
        //
        // The value is specifically being cleared.  So we
        // want to delete the registry value.
        //
        RegError = ScRegDeleteValue(ServiceNameKey, ValueName);
        if (RegError != ERROR_SUCCESS)
        {
            if (RegError == ERROR_FILE_NOT_FOUND)
            {
                RegError = ERROR_SUCCESS;
            }
            else
            {
                SC_LOG2(ERROR, "ScWriteStringParm: ScRegDeleteValue of "
                        "reg value %ws failed %ld\n", ValueName, RegError);
            }
        }

        return RegError;
    }

} // ScWriteOptionalString



DWORD
ScWriteFailureActions(
    IN HKEY ServiceNameKey,
    IN LPSERVICE_FAILURE_ACTIONSW psfa
    )
/*++

Routine Description:

    This function writes ONLY the non-string fields of the
    SERVICE_FAILURE_ACTIONS structure to the registry for the specified
    key.  If the structure is a NULL pointer, we don't do anything.  If
    the structure contains no failure actions, we delete the registry value.

Arguments:


Return Value:


--*/
{
    SC_ASSERT( ServiceNameKey != NULL );

    //
    // A NULL structure or NULL array means no change.
    //
    if (psfa == NULL || psfa->lpsaActions == NULL)
    {
        return NO_ERROR;
    }

    if (psfa->cActions != 0)
    {
        //
        // Write the Value
        //

        //
        // Combine the SERVICE_FAILURE_ACTIONSW structure and the
        // array of SC_ACTION into a contiguous block.
        // The structure includes the string pointers, though we don't
        // actually use them when reading the structure back.
        //
        // Always write this structure out with 32-bit "pointers" since
        // that's the format we expect when we read it in (required for
        // backwards compatibility).
        //

        DWORD cbValueLen = sizeof(SERVICE_FAILURE_ACTIONS_WOW64) +
                           psfa->cActions * sizeof(SC_ACTION);

        LPSERVICE_FAILURE_ACTIONS_WOW64 psfaValue =
            (LPSERVICE_FAILURE_ACTIONS_WOW64) LocalAlloc(0, cbValueLen);

        if (psfaValue == NULL)
        {
            return (GetLastError());
        }

        psfaValue->dwResetPeriod     = psfa->dwResetPeriod;
        psfaValue->dwRebootMsgOffset = psfa->lpRebootMsg ? 1 : 0;
        psfaValue->dwCommandOffset   = psfa->lpCommand ? 1 : 0;
        psfaValue->cActions          = psfa->cActions;

        RtlCopyMemory(psfaValue + 1,
                      psfa->lpsaActions,
                      psfa->cActions * sizeof(SC_ACTION));

        //
        // Write the block to the registry
        //
        LONG RegError = ScRegSetValueExW(
                            ServiceNameKey,
                            FAILUREACTIONS_VALUENAME_W,
                            0,
                            REG_BINARY,
                            psfaValue,
                            cbValueLen
                            );

        if (RegError != ERROR_SUCCESS)
        {
            SC_LOG(ERROR, "ScWriteFailureActions: ScRegSetValueExW failed %ld\n",
                   RegError);
        }

        LocalFree(psfaValue);

        return RegError;
    }
    else
    {
        //
        // There are no failure actions to store.  So we
        // want to delete the registry value.
        //
        LONG RegError = ScRegDeleteValue(
                            ServiceNameKey,
                            FAILUREACTIONS_VALUENAME_W
                            );
        if (RegError != ERROR_SUCCESS)
        {
            if (RegError == ERROR_FILE_NOT_FOUND)
            {
                RegError = ERROR_SUCCESS;
            }
            else
            {
                SC_LOG(ERROR, "ScWriteFailureActions: ScRegDeleteValue failed %ld\n",
                        RegError);
            }
        }

        return RegError;
    }

} // ScWriteFailureActions


DWORD
ScWriteErrorControl(
    IN HKEY ServiceNameKey,
    IN DWORD ErrorControl
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( !ERROR_CONTROL_INVALID( ErrorControl ) );

    RegError = ScRegSetValueExW(
            ServiceNameKey,                     // key
            ERRORCONTROL_VALUENAME_W,           // value name
            0,
            REG_DWORD,                          // data type
            (LPBYTE) & ErrorControl,            // data
            sizeof(DWORD) );                    // byte count

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteErrorControl


DWORD
ScWriteSd(
    IN HKEY ServiceNameKey,
    IN PSECURITY_DESCRIPTOR Security
    )
/*++

Routine Description:

    This routine write the specified security descriptor to the registry.

Arguments:



Return Value:



--*/
{
    LONG    RegError;
    HKEY    SecurityKey;
    ULONG   SdLength;

    SC_ASSERT( ServiceNameKey != NULL );

    if (Security == NULL) {
        return NO_ERROR;
    }
    SdLength = RtlLengthSecurityDescriptor(Security);
    if (SdLength == 0) {
        return(NO_ERROR);
    }

    SC_LOG1(SECURITY, "ScWriteSd: Size of security descriptor %lu\n", SdLength);

    //
    // Open the Security Sub-key (under the service key).
    //
    RegError = ScOpenSecurityKey(
                ServiceNameKey,
                KEY_READ | KEY_WRITE,
                TRUE,                   // CreateIfMissing
                &SecurityKey);

    if (RegError != NO_ERROR) {
        SC_LOG1(ERROR,"ScWriteSd:ScOpenSecurityKey Failed %d\n",RegError);
    }
    else
    {
        //
        // Write the Security Descriptor to the Security Value in the Security
        // Key.
        //
        RegError = ScRegSetValueExW(
                SecurityKey,                        // key
                SD_VALUENAME_W,                     // value name
                0,                                  // reserved
                REG_BINARY,                         // data type
                (LPBYTE) Security,                  // data
                SdLength                            // byte count
                );

        if (RegError != NO_ERROR) {
            SC_LOG1(ERROR,"ScWriteSd:ScRegSetValueExW Failed %d\n",RegError);
        }

        RegCloseKey(SecurityKey);
    }

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteSd


#ifdef USE_GROUPS
DWORD
ScWriteGroupForThisService(
    IN HKEY ServiceNameKey,
    IN LPWSTR Group
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( Group != NULL );

    //
    // Write the group
    //
    RegError = ScRegSetValueExW(
                   ServiceNameKey,           // open handle (to section)
                   GROUP_VALUENAME_W,        // value name
                   0,
                   REG_SZ,                   // type (zero-terminated UNICODE)
                   (LPBYTE) Group,           // data
                   (DWORD) WCSSIZE(Group));  // byte count for data

    if (RegError != ERROR_SUCCESS) {
        SC_LOG2(ERROR, "ScWriteGroupForThisService: ScRegSetValueExW of "
                FORMAT_LPWSTR " failed " FORMAT_LONG "\n",
                Group, RegError);
    }

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteGroupForThisService
#endif // USE_GROUPS


DWORD
ScWriteImageFileName(
    IN HKEY hServiceKey,
    IN LPWSTR ImageFileName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );
    SC_ASSERT( ImageFileName != NULL );

    //
    // Write the binary path name
    //
    RegError = ScRegSetValueExW(
            hServiceKey,                      // open handle (to section)
            IMAGE_VALUENAME_W,                // value name
            0,
            REG_EXPAND_SZ,                    // type (zero-terminated UNICODE)
            (LPBYTE) ImageFileName,           // data
            (DWORD) WCSSIZE(ImageFileName));  // byte count for data

    if (RegError != ERROR_SUCCESS) {
        SC_LOG2(ERROR, "ScWriteImageFileName: ScRegSetValueExW of "
                FORMAT_LPWSTR " failed " FORMAT_LONG "\n",
                ImageFileName, RegError);
    }

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return ( (DWORD) RegError );

} // ScWriteImageFileName


DWORD
ScWriteServiceType(
    IN HKEY hServiceKey,
    IN DWORD dwServiceType
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );
    SC_ASSERT( !SERVICE_TYPE_INVALID( dwServiceType ) );
    SC_ASSERT( dwServiceType != SERVICE_WIN32 );  // Don't write ambig info.

    RegError = ScRegSetValueExW(
            hServiceKey,                        // key
            SERVICETYPE_VALUENAME_W,            // value name
            0,
            REG_DWORD,                          // data type
            (LPBYTE) & dwServiceType,           // data
            sizeof(DWORD) );                    // byte count

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteServiceType


DWORD
ScWriteStartType(
    IN HKEY hServiceKey,
    IN DWORD dwStartType
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );
    SC_ASSERT( !START_TYPE_INVALID( dwStartType ) );

    RegError = ScRegSetValueExW(
            hServiceKey,                        // key
            START_VALUENAME_W,                  // value name
            0,
            REG_DWORD,                          // data type
            (LPBYTE) &dwStartType,              // data
            sizeof( DWORD ) );                  // byte count

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteStartType


DWORD
ScWriteTag(
    IN HKEY hServiceKey,
    IN DWORD dwTag
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );

    RegError = ScRegSetValueExW(
            hServiceKey,                        // key
            TAG_VALUENAME_W,                    // value name
            0,
            REG_DWORD,                          // data type
            (LPBYTE) &dwTag,                    // data
            sizeof( DWORD ) );                  // byte count

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteTag


VOID
ScDeleteTag(
    IN HKEY hServiceKey
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );

    RegError = ScRegDeleteValue(
            hServiceKey,                        // key
            TAG_VALUENAME_W);                   // value name

    SC_LOG1(DEPEND, "ScRegDeleteValue of Tag returns %ld\n", RegError);

} // ScDeleteTag


DWORD
ScWriteStartName(
    IN HKEY ServiceNameKey,
    IN LPWSTR StartName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( StartName != NULL );

    //
    // Write the StartName
    //
    RegError = ScRegSetValueExW(
                   ServiceNameKey,               // open handle (to section)
                   STARTNAME_VALUENAME_W,        // value name
                   0,
                   REG_SZ,                       // type (zero-terminated UNICODE)
                   (LPBYTE) StartName,           // data
                   (DWORD) WCSSIZE(StartName));  // byte count for data

    if (RegError != ERROR_SUCCESS) {
        SC_LOG2(ERROR, "ScWriteStartName: ScRegSetValueExW of " FORMAT_LPWSTR
                " failed " FORMAT_LONG "\n",
                StartName, RegError);
    }

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteStartName



DWORD
ScReadServiceConfig(
    IN HKEY ServiceNameKey,
    IN LPWSTR ServiceName
    )
/*++

Routine Description:

    This function reads the service configuration information and
    creates a service record in memory with the information.

Arguments:

    ServiceNameKey - Supplies opened handle to the service key to read
        from.

    ServiceName - Supplies name of the service.

Return Value:

    TRUE - Service record is created successfully.

    FALSE - Error in creating the service record.  If an error occurs here,
        it is generally considered a fatal error which will cause the
        service controller to fail to start.

Note:

    The GroupListLock must be held exclusively prior to calling this routine.

--*/
{
    DWORD status;

    DWORD StartType;
    DWORD ServiceType;
    DWORD ErrorControl;
    DWORD Tag;
    LPWSTR Group = NULL;
    LPWSTR Dependencies = NULL;
    LPWSTR DisplayName=NULL;
    PSECURITY_DESCRIPTOR Sd = NULL;

    LPSERVICE_RECORD ServiceRecord;

    SC_ASSERT(ScGroupListLock.HaveExclusive());

    //
    // Get the Service Type information from the registry
    //
    status = ScReadServiceType(ServiceNameKey, &ServiceType);
    if (status != NO_ERROR) {
        SC_LOG1(TRACE, "Ignored " FORMAT_LPWSTR ".  No ServiceType\n",
                ServiceName);
        return NO_ERROR;  // Skip service entry and ignore error.
    }

    //
    // If service type is not one of type SERVICE_WIN32 or SERVICE_DRIVER,
    // do not bother saving it in a service record because it's data
    // for services.
    //
    if (SERVICE_TYPE_INVALID(ServiceType)) {
        if ((ServiceType != SERVICE_ADAPTER) &&
            (ServiceType != SERVICE_RECOGNIZER_DRIVER)) {
            SC_LOG2(ERROR, "Ignored " FORMAT_LPWSTR ".  Invalid ServiceType "
                    FORMAT_HEX_DWORD "\n", ServiceName, ServiceType);
        }
        return NO_ERROR;
    }
    SC_LOG1(CONFIG, "    ServiceType " FORMAT_HEX_DWORD "\n", ServiceType);


    //
    // Read the StartType value
    //
    status = ScReadStartType(ServiceNameKey, &StartType);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "Ignored " FORMAT_LPWSTR ".  No StartType\n",
                ServiceName);
        return NO_ERROR;  // Skip service entry and ignore error.
    }
    SC_LOG1(CONFIG, "    StartType " FORMAT_HEX_DWORD "\n", StartType);

    //
    // Read the ErrorControl value
    //
    status = ScReadErrorControl(ServiceNameKey, &ErrorControl);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "Ignored " FORMAT_LPWSTR ".  No ErrorControl\n",
                ServiceName);
        return NO_ERROR;  // Skip service entry and ignore error.
    }
    SC_LOG1(CONFIG, "    ErrorControl " FORMAT_HEX_DWORD "\n", ErrorControl);


    //
    // Read the optional Tag value.  0 means no tag.
    //
    status = ScReadTag(ServiceNameKey, &Tag);
    if (status != NO_ERROR) {
        Tag = 0;
    }

    //
    // Read the Group value
    //
    if (ScAllocateAndReadConfigValue(
            ServiceNameKey,
            GROUP_VALUENAME_W,
            &Group,
            NULL
            ) != NO_ERROR) {

        Group = NULL;
    }
    else {
        SC_LOG1(CONFIG, "    Belongs to group " FORMAT_LPWSTR "\n", Group);
    }

    //
    // Read the Dependencies
    //

    status = ScReadDependencies(ServiceNameKey, &Dependencies, ServiceName);
    if (status != NO_ERROR) {
        Dependencies = NULL;
    }


    //
    // Read the security descriptor
    //
    if (ScReadSd(
            ServiceNameKey,
            &Sd
            ) != NO_ERROR) {

        Sd = NULL;
    }

    //
    // Read the Display Name
    // NOTE: If an error occurs, or the name doesn't exist, then a NULL
    // pointer is returned from this call.
    //
    ScReadDisplayName(ServiceNameKey, &DisplayName);

    //
    // Get an exclusive lock on the database so we can read and
    // make modifications.
    //
    SC_ASSERT(ScServiceListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    // See if the service record already exists
    //
    status = ScGetNamedServiceRecord(
                 ServiceName,
                 &ServiceRecord
                 );

    if (status == ERROR_SERVICE_DOES_NOT_EXIST) {

        //
        // Create a service record for this service
        //
        status = ScCreateServiceRecord(
                    ServiceName,
                    &ServiceRecord
                    );
    }

    if (status != NO_ERROR) {
        goto CleanExit;
    }

    //
    // Insert the config information into the service record
    //
    status = ScAddConfigInfoServiceRecord(
                ServiceRecord,
                ServiceType,
                StartType,
                ErrorControl,
                Group,
                Tag,
                Dependencies,
                DisplayName,
                Sd
                );

    if (status != NO_ERROR) {
        //
        // Fail to set meaningful data into service record.  Remove the service
        // record from the service record list and delete it.  This is not
        // a fatal error.  Instead, we just leave this entry out of the
        // database.
        //
        REMOVE_FROM_LIST(ServiceRecord);

        ScFreeServiceRecord(ServiceRecord);

        status = NO_ERROR;
    }
    else {

        //
        // Should the service be deleted?
        // The service entry in the registry cannot be deleted while we
        // are enumerating services, therefore we must mark it and delete it
        // later.
        //
        if (ScDeleteFlagIsSet(ServiceNameKey)) {
            SC_LOG(TRACE,"ScReadServiceConfig: %ws service marked for delete\n",
                ServiceRecord->ServiceName);
            SET_DELETE_FLAG(ServiceRecord);
        }
    }
CleanExit:

    LocalFree(Group);
    LocalFree(Dependencies);
    LocalFree(DisplayName);

    return status;
}


DWORD
ScAllocateAndReadConfigValue(
    IN  HKEY    Key,
    IN  LPCWSTR  ValueName,
    OUT LPWSTR  *Value,
    OUT LPDWORD BytesReturned OPTIONAL
    )
/*++

Routine Description:

    This function allocates the output buffer and reads the requested
    value from the registry into it.  It is useful for reading string
    data of undeterministic length.


Arguments:

    Key - Supplies opened handle to the key to read from.

    ValueName - Supplies name of the value to retrieve data.

    Value - Returns a pointer to the output buffer which points to
        the memory allocated and contains the data read in from the
        registry.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - Failed to create buffer to read value into.

    Error from registry call.

--*/
{
    LONG    RegError;
    DWORD   NumRequired = 0;
    WCHAR   Temp[1];
    LPWSTR  TempValue = NULL;
    DWORD   ValueType;
    DWORD   CharsReturned;


    //
    // Set returned buffer pointer to NULL.
    //
    *Value = NULL;

    RegError = ScRegQueryValueExW(
                   Key,
                   ValueName,
                   NULL,
                   &ValueType,
                   (LPBYTE) NULL,
                   &NumRequired
                   );

    if (RegError != ERROR_SUCCESS && NumRequired > 0) {

        SC_LOG3(CONFIG, "ScAllocateAndReadConfig: ScRegQueryKeyExW of "
                FORMAT_LPWSTR " failed " FORMAT_LONG ", NumRequired "
                FORMAT_DWORD "\n",
                ValueName, RegError, NumRequired);

        if ((TempValue = (LPWSTR)LocalAlloc(
                          LMEM_ZEROINIT,
                          (UINT) NumRequired
                          )) == NULL) {
            SC_LOG2(ERROR, "ScAllocateAndReadConfig: LocalAlloc of size "
                    FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                    NumRequired, GetLastError());
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RegError = ScRegQueryValueExW(
                       Key,
                       ValueName,
                       NULL,
                       &ValueType,
                       (LPBYTE) TempValue,
                       &NumRequired
                       );
    }

    if (RegError != ERROR_SUCCESS) {

        if (RegError != ERROR_FILE_NOT_FOUND) {
            SC_LOG3(ERROR, "ScAllocateAndReadConfig: ScRegQueryKeyExW of "
                    FORMAT_LPWSTR " failed " FORMAT_LONG ", NumRequired "
                    FORMAT_DWORD "\n",
                    ValueName, RegError, NumRequired);
        }

        LocalFree(TempValue);

        return (DWORD) RegError;
    }

    if (ValueType != REG_EXPAND_SZ || TempValue == NULL) {
        *Value = TempValue;
        if (BytesReturned != NULL) {
            *BytesReturned = NumRequired;
        }
        return(NO_ERROR);
    }

    //
    // If the ValueType is REG_EXPAND_SZ, then we must call the
    // function to expand environment variables.
    //
    SC_LOG1(CONFIG,"ScAllocateAndReadConfig: Must expand the string for "
        FORMAT_LPWSTR "\n", ValueName);

    //
    // Make the first call just to get the number of characters that
    // will be returned.
    //
    NumRequired = ExpandEnvironmentStringsW (TempValue,Temp, 1);

    if (NumRequired > 1) {

        *Value = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (UINT) (NumRequired * sizeof(WCHAR)));

        if (*Value == NULL) {

            SC_LOG2(ERROR, "ScAllocateAndReadConfig: LocalAlloc of numChar= "
                FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                NumRequired, GetLastError());

            LocalFree(TempValue);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        CharsReturned = ExpandEnvironmentStringsW (
                            TempValue,
                            *Value,
                            NumRequired);

        if (CharsReturned > NumRequired) {
            SC_LOG1(ERROR, "ScAllocAndReadConfig: ExpandEnvironmentStrings "
                " failed for " FORMAT_LPWSTR " \n", ValueName);

            LocalFree(*Value);
            *Value = NULL;
            LocalFree(TempValue);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        LocalFree(TempValue);

        if (BytesReturned != NULL) {
            *BytesReturned = CharsReturned * sizeof(WCHAR);
        }
        return(NO_ERROR);

    }
    else {
        //
        // This call should have failed because of our ridiculously small
        // buffer size.
        //

        SC_LOG0(ERROR, "ScAllocAndReadConfig: ExpandEnvironmentStrings "
            " Should have failed because we gave it a BufferSize=1\n");

        //
        // This could happen if the string was a single byte long and
        // didn't really have any environment values to expand.  In this
        // case, we return the TempValue buffer pointer.
        //
        *Value = TempValue;

        if (BytesReturned != NULL) {
            *BytesReturned = sizeof(WCHAR);
        }
        return(NO_ERROR);
    }
}



DWORD
ScGetGroupVector(
    IN  LPWSTR Group,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    )

{
    DWORD status;
    LONG RegError;
    HKEY VectorsKey;


    //
    // Open the HKEY_LOCAL_MACHINE
    // System\CurrentControlSet\Control\GroupOrderList key.
    //
    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   GROUP_VECTORS_KEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ,                  // desired access
                   &VectorsKey
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG(ERROR, "ScGetGroupVector: Open of GroupOrderList key failed "
               FORMAT_LONG "\n", RegError);

        return (DWORD) RegError;
    }

    //
    // Read the value with the valuename of the specified group
    //
    status = ScAllocateAndReadConfigValue(
                 VectorsKey,
                 Group,
                 (LPWSTR *)Buffer,
                 BufferSize
                 );

    (void) ScRegCloseKey(VectorsKey);

    return status;
}


BOOL
ScGetToken(
    IN OUT LPWSTR *CurrentPtr,
    OUT    LPWSTR *TokenPtr
    )
/*++

Routine Description:

    This function takes a pointer into a given NULL-NULL-terminated buffer
    and isolates the next string token in it.  The CurrentPtr is incremented
    past the NULL byte of the token found if it is not the end of the buffer.
    The TokenPtr returned points to the token in the buffer and is NULL-
    terminated.

Arguments:

    CurrentPtr - Supplies a pointer to the buffer to extract the next token.
        On output, this pointer is set past the token found.

    TokenPtr - Supplies the pointer to the token found.

Return Value:

    TRUE - If a token is found.

    FALSE - No token is found.

--*/
{

    if (*(*CurrentPtr) == 0) {
        return FALSE;
    }

    *TokenPtr = *CurrentPtr;

    *CurrentPtr = ScNextWStrArrayEntry((*CurrentPtr));

    return TRUE;

}

DWORD
ScOpenServicesKey(
    OUT PHKEY ServicesKey
    )
{
    LONG RegError;

    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   SERVICES_TREE,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ | DELETE,         // desired access
                   ServicesKey
                   );

    return (ScWinRegErrorToApiStatus( RegError ));
}

DWORD
ScRegCreateKeyExW(
    IN  HKEY                    hKey,
    IN  LPWSTR                  lpSubKey,
    IN  DWORD                   dwReserved,
    IN  LPWSTR                  lpClass,
    IN  DWORD                   dwOptions,
    IN  REGSAM                  samDesired,
    IN  LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    OUT PHKEY                   phKeyResult,
    OUT LPDWORD                 lpdwDisposition
    )

/*++

Routine Description:

    NOTE:  This routine only creates one key at a time.  If the lpSubKey
        parameter includes keys that don't exist, an error will result.
        For instance, if "\\new\\key\\here" is passed in, "new" and "key"
        are expected to exist.  They will not be created by this call.

Arguments:


Return Value:


Note:


--*/
{
    NTSTATUS            ntStatus;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      KeyName;
    UNICODE_STRING      ClassString;

    UNREFERENCED_PARAMETER(dwReserved);

    RtlInitUnicodeString(&KeyName,lpSubKey);
    RtlInitUnicodeString(&ClassString,lpClass);

    InitializeObjectAttributes(
        &Obja,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        hKey,
        ARGUMENT_PRESENT(lpSecurityAttributes) ?
            lpSecurityAttributes->lpSecurityDescriptor :
            NULL);


    ntStatus = NtCreateKey(
                (PHANDLE)phKeyResult,
                (ACCESS_MASK)samDesired,
                &Obja,
                0,
                &ClassString,
                (ULONG)dwOptions,
                (PULONG)lpdwDisposition);


    return(RtlNtStatusToDosError(ntStatus));
}


DWORD
ScRegOpenKeyExW(
    IN  HKEY    hKey,
    IN  LPWSTR  lpSubKey,
    IN  DWORD   dwOptions,
    IN  REGSAM  samDesired,
    OUT PHKEY   phKeyResult
    )
/*++

Routine Description:

    NOTE:  This function will only accept one of the WinReg Pre-defined
        handles - HKEY_LOCAL_MACHINE.  Passing any other type of Pre-defined
        handle will cause an error.

Arguments:


Return Value:


Note:


--*/
{
    NTSTATUS            ntStatus;
    DWORD               status;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      KeyNameString;
    LPWSTR              KeyPath;
    DWORD               stringSize;
    LPWSTR              HKeyLocalMachine = SC_HKEY_LOCAL_MACHINE;
    HKEY                tempHKey;
    BOOL                KeyPathIsAllocated=FALSE;


    UNREFERENCED_PARAMETER(dwOptions);

    //
    // If we are opening the Pre-Defined Key (HKEY_LOCAL_MACHINE), then
    // pre-pend "\\REGISTRY\\MACHINE\\" to the subKey string.
    //
    if (hKey == HKEY_LOCAL_MACHINE) {
        stringSize = (DWORD) WCSSIZE(HKeyLocalMachine) + (DWORD) WCSSIZE(lpSubKey);
        KeyPath = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (UINT) stringSize);
        if (KeyPath == NULL) {
            SC_LOG0(ERROR,"ScRegOpenKeyExW: Local Alloc Failed\n");
            return(GetLastError());
        }
        KeyPathIsAllocated=TRUE;
        wcscpy(KeyPath,HKeyLocalMachine);
        wcscat(KeyPath,lpSubKey);
        tempHKey = NULL;
    }
    else {
        KeyPath = lpSubKey;
        tempHKey = hKey;
    }

    RtlInitUnicodeString(&KeyNameString,KeyPath);

    InitializeObjectAttributes(
        &Obja,
        &KeyNameString,
        OBJ_CASE_INSENSITIVE,
        tempHKey,
        NULL);

    ntStatus = NtOpenKey(
                (PHANDLE)phKeyResult,
                (ACCESS_MASK)samDesired,
                &Obja);

    if (ntStatus == STATUS_ACCESS_DENIED) {

        SC_LOG0(ERROR,"ScOpenKeyExW: NtOpenKey ACCESS_DENIED try to Take Ownership\n");

        status = ScTakeOwnership(&Obja);
        if (status != NO_ERROR) {
            if (KeyPathIsAllocated) {
                LocalFree(KeyPath);
            }
            return(status);
        }

        //
        // Now try to open the key with the desired access.
        //
        ntStatus = NtOpenKey(
                    (PHANDLE)phKeyResult,
                    (ACCESS_MASK)samDesired,
                    &Obja);
        if (!NT_SUCCESS(ntStatus)) {
            SC_LOG(ERROR, "ScRegOpenKeyExW: NtOpenKey(final try) failed %x\n",
            ntStatus);
        }
    }

    if (KeyPathIsAllocated) {
        LocalFree(KeyPath);
    }
    return(RtlNtStatusToDosError(ntStatus));
}

DWORD
ScRegQueryValueExW(
    IN      HKEY    hKey,
    IN      LPCWSTR lpValueName,
    OUT     LPDWORD lpReserved,
    OUT     LPDWORD lpType,
    OUT     LPBYTE  lpData,
    IN OUT  LPDWORD lpcbData
    )
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/

{

    NTSTATUS                    ntStatus;
    UNICODE_STRING              ValueName;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    DWORD                       bufSize;

    UNREFERENCED_PARAMETER(lpReserved);

    //
    // Make sure we have a buffer size if the buffer is present.
    //

    if ((ARGUMENT_PRESENT(lpData)) && (!ARGUMENT_PRESENT(lpcbData))) {
        return(ERROR_INVALID_PARAMETER);
    }

    RtlInitUnicodeString(&ValueName, lpValueName);

    //
    // Compute size of value information and allocate buffer.
    //

    bufSize = 0;
    if (ARGUMENT_PRESENT(lpcbData)) {
        bufSize = *lpcbData;
    }

    bufSize += FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
    KeyValueInfo =
            (PKEY_VALUE_PARTIAL_INFORMATION)LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (KeyValueInfo == NULL) {
        SC_LOG0(ERROR,"ScRegQueryValueExW: LocalAlloc Failed");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ntStatus = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInfo,
                bufSize,
                &bufSize);

    if (NT_SUCCESS(ntStatus) || (ntStatus == STATUS_BUFFER_OVERFLOW)) {
        if (ARGUMENT_PRESENT(lpcbData)) {
            *lpcbData = KeyValueInfo->DataLength;
        }

        if (ARGUMENT_PRESENT(lpType)) {
            *lpType = KeyValueInfo->Type;
        }
    }

    if (NT_SUCCESS(ntStatus) && ARGUMENT_PRESENT(lpData)) {
        RtlCopyMemory(lpData, &KeyValueInfo->Data[0], KeyValueInfo->DataLength);
    }

    LocalFree(KeyValueInfo);
    return RtlNtStatusToDosError(ntStatus);
}


DWORD
ScRegSetValueExW(
    IN  HKEY    hKey,
    IN  LPCWSTR lpValueName,
    IN  DWORD   lpReserved,
    IN  DWORD   dwType,
    IN  LPVOID  lpData,
    IN  DWORD   cbData
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    UNICODE_STRING              ValueName;


    UNREFERENCED_PARAMETER(lpReserved);

    RtlInitUnicodeString(&ValueName,lpValueName);

    ntStatus = NtSetValueKey(
                hKey,
                &ValueName,
                0,
                (ULONG)dwType,
                (PVOID)lpData,
                (ULONG)cbData);

    status = RtlNtStatusToDosError(ntStatus);

    if (status != NO_ERROR)
    {
        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED_II,
            L"ScRegSetValueExW",
            lpValueName,
            status
            );
    }

    return(status);

}

DWORD
ScRegDeleteValue(
    IN  HKEY    hKey,
    IN  LPCWSTR lpValueName
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    NTSTATUS                    ntStatus;
    UNICODE_STRING              ValueName;


    RtlInitUnicodeString(&ValueName,lpValueName);

    ntStatus = NtDeleteValueKey(
                hKey,
                &ValueName);

    return(RtlNtStatusToDosError(ntStatus));

}


DWORD
ScRegEnumKeyW(
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpName,
    DWORD   cbName
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    NTSTATUS                    ntStatus;
    PKEY_BASIC_INFORMATION      KeyInformation;
    ULONG                       resultLength;
    DWORD                       bufSize;

    //
    // Allocate a buffer for the Key Information.
    //
    bufSize = sizeof(KEY_BASIC_INFORMATION) + cbName;
    KeyInformation = (PKEY_BASIC_INFORMATION)LocalAlloc(LMEM_ZEROINIT, (UINT) bufSize);
    if (KeyInformation == NULL){
        SC_LOG0(ERROR,"ScRegEnumKey: LocalAlloc Failed\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ntStatus = NtEnumerateKey(
                (HANDLE)hKey,
                (ULONG)dwIndex,
                KeyBasicInformation,
                (PVOID)KeyInformation,
                (ULONG)bufSize,
                (PULONG)&resultLength);

    if (!NT_SUCCESS(ntStatus)) {
        LocalFree(KeyInformation);
        return(RtlNtStatusToDosError(ntStatus));
    }

    if (cbName < (KeyInformation->NameLength + sizeof(WCHAR))) {
        LocalFree(KeyInformation);
        return(ERROR_MORE_DATA);
    }

    RtlCopyMemory(lpName, KeyInformation->Name, KeyInformation->NameLength);
    *(lpName + (KeyInformation->NameLength/sizeof(WCHAR))) = L'\0';

    LocalFree(KeyInformation);
    return(NO_ERROR);
}


DWORD
ScRegDeleteKeyW (
    HKEY    hKey,
    LPWSTR  lpSubKey
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD       status;
    NTSTATUS    ntStatus;
    HKEY        keyToDelete;

    status = ScRegOpenKeyExW(
                hKey,
                lpSubKey,
                0,
                KEY_READ | READ_CONTROL | DELETE,
                &keyToDelete);

    if (status != NO_ERROR) {
        SC_LOG2(ERROR, "ScRegDeleteKeyW: ScRegOpenKeyExW (%ws) Failed %d\n",
            lpSubKey,
            status);
        return(status);
    }

    ntStatus = NtDeleteKey(keyToDelete);

    NtClose(keyToDelete);

    return(RtlNtStatusToDosError(ntStatus));
}

DWORD
ScRegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD                   status;
    NTSTATUS                ntStatus;
    NTSTATUS                ntStatus2;
    PSECURITY_DESCRIPTOR    SecurityDescriptor=NULL;
    ULONG                   SecurityDescriptorLength;
    PKEY_FULL_INFORMATION   KeyInfo;
    DWORD                   bufSize;
    DWORD                   bytesReturned;
    DWORD                   classBufSize;


    UNREFERENCED_PARAMETER(lpReserved);

    classBufSize = *lpcbClass;
    bufSize = sizeof(KEY_FULL_INFORMATION) + *lpcbClass;

    KeyInfo = (PKEY_FULL_INFORMATION)LocalAlloc(LMEM_ZEROINIT, bufSize);
    if (KeyInfo == NULL) {
        SC_LOG0(ERROR,"RegQueryInfoKeyW: LocalAlloc failed\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ntStatus = NtQueryKey(
                hKey,
                KeyFullInformation,
                (PVOID)KeyInfo,
                bufSize,
                &bytesReturned);

    status = RtlNtStatusToDosError(ntStatus);

    if (ntStatus == STATUS_SUCCESS) {
        ntStatus2 = NtQuerySecurityObject(
                        hKey,
                        OWNER_SECURITY_INFORMATION
                        | GROUP_SECURITY_INFORMATION
                        | DACL_SECURITY_INFORMATION,
                        SecurityDescriptor,
                        0,
                        lpcbSecurityDescriptor
                        );
        //
        // If getting the size of the SECURITY_DESCRIPTOR failed (probably
        // due to the lack of READ_CONTROL access) return zero.
        //

        if( ntStatus2 != STATUS_BUFFER_TOO_SMALL ) {

            *lpcbSecurityDescriptor = 0;

        } else {

            //
            // Try again to get the size of the key's SECURITY_DESCRIPTOR,
            // this time asking for SACL as well. This should normally
            // fail but may succeed if the caller has SACL access.
            //

            ntStatus2 = NtQuerySecurityObject(
                            hKey,
                            OWNER_SECURITY_INFORMATION
                            | GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION
                            | SACL_SECURITY_INFORMATION,
                            SecurityDescriptor,
                            0,
                            &SecurityDescriptorLength
                            );


            if( ntStatus2 == STATUS_BUFFER_TOO_SMALL ) {

                //
                // The caller had SACL access so update the returned
                // length.
                //

                *lpcbSecurityDescriptor = SecurityDescriptorLength;
            }

        }

        *lpcbClass              = KeyInfo->ClassLength;
        *lpcSubKeys             = KeyInfo->SubKeys;
        *lpcbMaxSubKeyLen       = KeyInfo->MaxNameLen;
        *lpcbMaxClassLen        = KeyInfo->MaxClassLen;
        *lpcValues              = KeyInfo->Values;
        *lpcbMaxValueNameLen    = KeyInfo->MaxValueNameLen;
        *lpcbMaxValueLen        = KeyInfo->MaxValueDataLen;
        *lpftLastWriteTime      = *(PFILETIME) &KeyInfo->LastWriteTime;

        if (KeyInfo->ClassLength > classBufSize) {
            LocalFree(KeyInfo);
            return(RtlNtStatusToDosError(STATUS_BUFFER_TOO_SMALL));
        }
        RtlCopyMemory(
            lpClass,
            (LPBYTE)KeyInfo->Class,
            KeyInfo->ClassLength);

        //
        // NUL terminate the class name.
        //
        *(lpClass + (KeyInfo->ClassLength/sizeof(WCHAR))) = UNICODE_NULL;

    }
    else
    {
        //
        // NtQueryKey failed
        //

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            L"ScRegQueryInfoKeyW",
            status
            );
    }

    LocalFree(KeyInfo);

    return(status);
}

DWORD
ScRegGetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    DWORD                       status;

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor    = (PBYTE) pSecurityDescriptor;
    RpcSD.cbInSecurityDescriptor  = *lpcbSecurityDescriptor;
    RpcSD.cbOutSecurityDescriptor = 0;

    status = (DWORD)BaseRegGetKeySecurity(
                            hKey,
                            SecurityInformation,
                            &RpcSD
                            );
    //
    // Extract the size of the SECURITY_DESCRIPTOR from the RPCable version.
    //
    *lpcbSecurityDescriptor = RpcSD.cbInSecurityDescriptor;

    return(status);
}


DWORD
ScRegSetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    DWORD                       status;

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor = NULL;

    status = MapSDToRpcSD(
        pSecurityDescriptor,
        &RpcSD
        );

    if( status != ERROR_SUCCESS )
    {
        SC_LOG1(ERROR,"ScRegSetKeySecurity: MapSDToRpcSD failed %lu\n",
                status);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            L"MapSDToRpcSD",
            status
            );

        return (status);
    }

    status = (DWORD)BaseRegSetKeySecurity (
                        hKey,
                        SecurityInformation,
                        &RpcSD
                        );

    //
    // Free the buffer allocated by MapSDToRpcSD.
    //

    RtlFreeHeap(
        RtlProcessHeap( ), 0,
        RpcSD.lpSecurityDescriptor
        );

    return (status);
}

DWORD
ScRegEnumValueW (
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    NTSTATUS                    ntStatus;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    DWORD                       bufSize;
    DWORD                       resultSize;
    DWORD                       totalSize;    // size of string including NUL
    BOOL                        stringData = FALSE;

    UNREFERENCED_PARAMETER(lpReserved);
    //
    // Make sure we have a buffer size if the buffer is present.
    //
    if ((ARGUMENT_PRESENT(lpData)) && (!ARGUMENT_PRESENT(lpcbData))) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Compute size of KeyValueInfo, round to pointer size, and allocate
    // buffer.
    //

    bufSize = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name) + (MAX_PATH * sizeof(WCHAR));
    bufSize = (bufSize + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1);
    bufSize += *lpcbData;

    KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION)LocalAlloc(
                    LMEM_ZEROINIT,
                    (UINT) bufSize);
    if (KeyValueInfo == NULL) {
        SC_LOG0(ERROR,"ScRegEnumValueW: LocalAlloc Failed\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ntStatus = NtEnumerateValueKey(
                (HANDLE)hKey,
                (ULONG)dwIndex,
                KeyValueFullInformation,
                (PVOID)KeyValueInfo,
                (ULONG)bufSize,
                (PULONG)&resultSize);

    if (ntStatus == STATUS_BUFFER_OVERFLOW) {

        LocalFree(KeyValueInfo);

        KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION)LocalAlloc(
                        LMEM_ZEROINIT,
                        (UINT) resultSize);
        if (KeyValueInfo == NULL) {
            SC_LOG0(ERROR,"ScRegEnumValueW: LocalAlloc (2nd try) Failed\n");
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        ntStatus = NtEnumerateValueKey(
                    hKey,
                    (ULONG)dwIndex,
                    KeyValueFullInformation,
                    (PVOID)KeyValueInfo,
                    (ULONG)bufSize,
                    (PULONG)&resultSize);

        if (ntStatus != STATUS_SUCCESS) {
            LocalFree(KeyValueInfo);
            return(RtlNtStatusToDosError(ntStatus));
        }
    }
    else if (ntStatus != STATUS_SUCCESS) {
        LocalFree(KeyValueInfo);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // The API was successful (from our point of view.  Now see if the
    // callers buffers were large enough.
    //
    totalSize = KeyValueInfo->NameLength+sizeof(WCHAR);  // add 1 for the NUL terminator.

    if (*lpcbValueName < totalSize) {
        *lpcbValueName = totalSize;
        *lpcbData = KeyValueInfo->DataLength;
        LocalFree(KeyValueInfo);
        return(ERROR_INSUFFICIENT_BUFFER);
    }
    else {
        RtlCopyMemory(
            lpValueName,
            (LPBYTE)KeyValueInfo->Name,
            KeyValueInfo->NameLength);

        *lpcbValueName = totalSize;

        //
        // NUL terminate the Value name.
        //
        *(lpValueName + (KeyValueInfo->NameLength/sizeof(WCHAR))) = UNICODE_NULL;

    }

    if (ARGUMENT_PRESENT(lpData)) {

        totalSize = KeyValueInfo->DataLength;

#ifdef REMOVE
        //
        // I believe I can remove this because data strings will be
        // stored with NULL terminators.
        //

        if((KeyValueInfo->Type == REG_SZ)        ||
           (KeyValueInfo->Type == REG_EXPAND_SZ) ||
           (KeyValueInfo->Type == REG_MULTI_SZ))  {

            totalSize += sizeof(WCHAR);
            stringData = TRUE;
        }

#endif // REMOVE

        if (*lpcbData < totalSize) {
            *lpcbData = totalSize;
            LocalFree(KeyValueInfo);
            return(ERROR_INSUFFICIENT_BUFFER);
        }
        else {
            RtlCopyMemory(
                lpData,
                (LPBYTE)KeyValueInfo + KeyValueInfo->DataOffset,
                KeyValueInfo->DataLength);

            *lpcbData = KeyValueInfo->DataLength;
            if (stringData) {
                *lpcbData += sizeof(WCHAR);
                //
                // NUL terminate the string Data.
                //
                *((LPWSTR)lpData + (KeyValueInfo->DataLength/sizeof(WCHAR))) = UNICODE_NULL;
            }
        }
    }

    if (ARGUMENT_PRESENT(lpType)) {
        *lpType = KeyValueInfo->Type;
    }

    LocalFree(KeyValueInfo);
    return(NO_ERROR);

}


VOID
ScHandleProviderChange(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    )

/*++

Routine Description:

    Processes changes to the list of network providers in the registry
    and publishes a list of those that are currently active in the HW
    profile for mpr.dll to use.

Arguments:


Return Value:


--*/
{
    DWORD   dwStatus;
    LPWSTR  lpProviderList = NULL;

    DWORD   dwLength;
    DWORD   dwTempLength;
    UINT    i;
    DWORD   dwCurrentChar;
    DWORD   dwNameStart;

    BOOL    fWriteList = TRUE;
    LPWSTR  lpList = NULL;

    HKEY                 hProviderHwKey;
    HKEY                 hProviderKey;
    DWORD                dwDisposition;
    SECURITY_ATTRIBUTES  SecurityAttr;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    static  HANDLE  s_hWorkItem;

#define SC_KEY_ACE_COUNT 2

    SC_ACE_DATA AceData[SC_KEY_ACE_COUNT] = {

        {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
               GENERIC_ALL,                &LocalSystemSid},
        {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
               GENERIC_READ,               &WorldSid}

        };


    SC_ASSERT(fWaitStatus == FALSE);
    SC_ASSERT(g_hProviderKey != NULL);

    if (ScShutdownInProgress)
    {
        return;
    }

    if (s_hWorkItem != NULL)
    {
        dwStatus = RtlDeregisterWait(s_hWorkItem);

        if (!NT_SUCCESS(dwStatus))
        {
            SC_LOG(ERROR,
                   "ScHandleProviderChange: RtlDeregisterWait FAILED %#x\n",
                   dwStatus);
        }
    }

    //
    // Reset the event
    //
    ResetEvent((HANDLE)pContext);

    SC_LOG0(TRACE, "ScHandleProviderChange: ProviderOrder key changed\n");

    //
    // Reregister for registry change notifications in case the key
    // changes while we're in this routine.  Note that there's no
    // race condition since the work item is a one-shot -- only one
    // thread can be in this routine at a time.
    //
    dwStatus = RegNotifyChangeKeyValue(
                   g_hProviderKey,
                   FALSE,                      // Don't watch subkeys
                   REG_NOTIFY_CHANGE_LAST_SET, // Watch for value changes
                   (HANDLE)pContext,           // Event to signal
                   TRUE);                      // Asynchronous

    if (dwStatus != NO_ERROR)
    {
        //
        // We won't pick up any further changes to the provider list.
        // Keep going so we at least pick up this one.
        //
        SC_LOG(ERROR,
               "ScHandleProviderChange: RegNotifyChangeKeyValue FAILED %d\n",
               dwStatus);
    }

    dwStatus = ScAllocateAndReadConfigValue(g_hProviderKey,
                                            PROVIDER_VALUE,
                                            &lpProviderList,
                                            &dwLength);

    if (dwStatus != NO_ERROR)
    {
        SC_LOG(ERROR,
               "ScHandleProviderChange: Unable to read ProviderOrder %d\n",
               dwStatus);

        goto Reregister;
    }

    //
    // This should be a REG_SZ -- check the basics
    //
    if ((dwLength % 2 != 0)
          ||
        (dwLength < sizeof(UNICODE_NULL))
          ||
        (lpProviderList[dwLength / sizeof(WCHAR) - 1] != UNICODE_NULL))
    {
        SC_LOG0(ERROR,
                "ScHandleProviderChange: Invalid REG_SZ for ProviderOrder\n");

        goto Reregister;
    }

    dwTempLength  = dwLength;
    dwCurrentChar = 0;
    dwNameStart   = 0;

    //
    // For each character in the original string
    //
    for (i = 0; i < dwTempLength; i += sizeof(WCHAR))
    {
        WCHAR  wcTemp = lpProviderList[dwCurrentChar];

        //
        // The provider list is comma-delimited
        //
        if (wcTemp == L',' || wcTemp == UNICODE_NULL)
        {
            lpProviderList[dwCurrentChar] = UNICODE_NULL;

            if (!ScInHardwareProfile(&lpProviderList[dwNameStart], 0))
            {
                //
                // The string plus the trailing UNICODE_NULL
                //
                DWORD dwBytes = (dwCurrentChar - dwNameStart + 1) * sizeof(WCHAR);

                //
                // Service is disabled in the HW profile
                //
                SC_LOG(TRACE,
                       "ScHandleProviderChange: Service %ws is disabled\n",
                       &lpProviderList[dwNameStart]);

                //
                // Shift over the remaining characters in the buffer.
                //
                RtlMoveMemory(&lpProviderList[dwNameStart],
                              &lpProviderList[dwCurrentChar + 1],
                              dwLength - (dwCurrentChar + 1) * sizeof(WCHAR));

                //
                // This may cause dwCurrentChar to underflow to
                // 0xffffffff (if the first provider was deleted).
                // This is OK -- it'll be incremented (to 0) below.
                //
                dwLength     -= dwBytes;
                dwCurrentChar = dwNameStart - 1;
            }
            else
            {
                //
                // Restore the temp character and move
                // to the start of the next provider name.
                //
                lpProviderList[dwCurrentChar] = wcTemp;
                dwNameStart = dwCurrentChar + 1;
            }
        }

        dwCurrentChar++;
    }

    //
    // If the last provider name was deleted, the string will
    // end with a ',' instead of a '\0'.  Note that if all the
    // provider names were deleted, dwCurrentChar will be 0 --
    // we increment it to empty out the provider list.
    //
    if (dwCurrentChar == 0)
    {
        dwCurrentChar++;
    }

    lpProviderList[dwCurrentChar - 1] = UNICODE_NULL;

    SC_LOG(TRACE,
           "ScHandleProviderChange: Provider list is now %ws\n",
           lpProviderList);

    dwStatus = ScRegOpenKeyExW(HKEY_LOCAL_MACHINE,
                               PROVIDER_KEY_BASE,
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE | KEY_READ,
                               &hProviderKey);

    if (dwStatus != NO_ERROR)
    {
        SC_LOG(ERROR,
               "ScHandleProviderChange: Unable to open provider key %d\n",
               dwStatus);

        goto Reregister;
    }

    //
    // Create a security descriptor for the registry key we are about
    // to create.  This gives everyone read access, and all access to
    // ourselves only.
    //
    dwStatus = ScCreateAndSetSD(AceData,
                                SC_KEY_ACE_COUNT,
                                LocalSystemSid,
                                LocalSystemSid,
                                &SecurityDescriptor);

#undef SC_KEY_ACE_COUNT

    if (!NT_SUCCESS(dwStatus))
    {
       SC_LOG1(ERROR,
               "ScHandleProviderChange: ScCreateAndSetSD failed %#x\n",
               dwStatus);

       ScRegCloseKey(hProviderKey);
       goto Reregister;
    }

    SecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttr.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttr.bInheritHandle = FALSE;

    //
    // Create a new HW provider subkey (or open existing one).
    //
    dwStatus = ScRegCreateKeyExW(hProviderKey,
                                 PROVIDER_KEY_HW,
                                 0,
                                 0,
                                 REG_OPTION_VOLATILE,
                                 KEY_SET_VALUE | KEY_QUERY_VALUE,
                                 &SecurityAttr,
                                 &hProviderHwKey,
                                 &dwDisposition);

    RtlDeleteSecurityObject(&SecurityDescriptor);
    ScRegCloseKey(hProviderKey);

    if (dwStatus != NO_ERROR)
    {
        SC_LOG(ERROR,
               "ScHandleProviderChange: Unable to open HW subkey %d\n",
               dwStatus);

        goto Reregister;
    }

    //
    // Write the modified list to the registry, but only if it is
    // different from the list already there.  This will prevent
    // mpr.dll from getting hyperactive on spurious (or repeated)
    // registry change notifications.
    //
    dwStatus = ScAllocateAndReadConfigValue(hProviderHwKey,
                                            PROVIDER_VALUE,
                                            &lpList,
                                            &dwTempLength);

    if (dwStatus == NO_ERROR)
    {
        //
        // If the string lengths are different, there's
        // definitely been a provider change.
        //
        if (dwTempLength == dwLength)
        {
            fWriteList = (_wcsnicmp(lpList,
                                    lpProviderList,
                                    dwTempLength / sizeof(WCHAR)) != 0);
        }

        LocalFree(lpList);
    }

    if (fWriteList)
    {
        SC_LOG0(TRACE,
                "Active provider list is different -- writing new list\n");

        dwStatus = ScRegSetValueExW(hProviderHwKey,
                                    PROVIDER_VALUE,
                                    0,
                                    REG_SZ,
                                    (LPBYTE) lpProviderList,
                                    dwLength);

        if (dwStatus != NO_ERROR)
        {
            SC_LOG(ERROR,
                   "ScHandleProviderChange: Unable to write HW-aware list %d\n",
                   dwStatus);
        }
    }
    else
    {
        SC_LOG0(TRACE,
                "Active provider list is the same -- not writing\n");
    }

    ScRegCloseKey(hProviderHwKey);

Reregister:

    LocalFree(lpProviderList);

    dwStatus = RtlRegisterWait(&s_hWorkItem,           // work item handle
                               (HANDLE) pContext,      // watiable handle
                               ScHandleProviderChange, // callback
                               (HANDLE) pContext,      // callback arg
                               INFINITE,
                               WT_EXECUTEINPERSISTENTIOTHREAD |
                                   WT_EXECUTEONLYONCE);

    if (!NT_SUCCESS(dwStatus))
    {
        SC_LOG(ERROR,
               "ScHandleProviderChange: RtlRegisterWait FAILED %#x\n",
               dwStatus);
    }
}


VOID
ScMarkForDelete(
    LPSERVICE_RECORD  ServiceRecord
    )

/*++

Routine Description:

    This function adds a DeleteFlag value to a service key in the registry.

Arguments:

    ServiceName - This is a pointer to the service name string.

Return Value:

    none.

--*/
{
    DWORD   status;
    HKEY    hServiceKey;
    DWORD   deleteFlag=1;

    status = ScOpenServiceConfigKey(
                ServiceRecord->ServiceName,
                KEY_WRITE,              // desired access
                FALSE,                  // don't create if missing
                &hServiceKey);

    if (status != NO_ERROR) {
        SC_LOG1(TRACE,"ScMarkForDelete:ScOpenServiceConfigKey failed %d\n",status);
        return;
    }

    status = ScRegSetValueExW(
                hServiceKey,
                REG_DELETE_FLAG,
                0,
                REG_DWORD,
                (LPBYTE)&deleteFlag,
                sizeof(DWORD));

    if (status != NO_ERROR) {
        SC_LOG1(TRACE,"ScMarkForDelete:ScRegSetValueExW failed %d\n",status);
        (void) ScRegCloseKey(hServiceKey);
        return;
    }

    //
    // Make sure we're disabling the service in case it's a driver started by the
    // kernel before we get a chance to delete the key on the next boot
    //
    ASSERT(ServiceRecord->StartType == SERVICE_DISABLED);

    status = ScWriteStartType(hServiceKey, ServiceRecord->StartType);

    if (status != NO_ERROR) {
        SC_LOG1(TRACE,"ScMarkForDelete:ScRegSetValueExW failed %d\n",status);
    }

    (void) ScRegCloseKey(hServiceKey);

    return;
}

BOOL
ScDeleteFlagIsSet(
    HKEY    ServiceKeyHandle
    )

/*++

Routine Description:

    This function looks for a delete flag value stored in the registry for
    this service.

Arguments:

    ServiceKeyHandle - This is a handle to the service key.

Return Value:

    TRUE - if the delete flag exists.
    FALSE - otherwise.

--*/
{
    DWORD   status;
    DWORD   value;
    DWORD   valueSize = sizeof(DWORD);
    DWORD   type;

    status = ScRegQueryValueExW(
                ServiceKeyHandle,
                REG_DELETE_FLAG,
                NULL,
                &type,
                (LPBYTE)&value,
                &valueSize);

    if (status == NO_ERROR) {
        return(TRUE);
    }
    return(FALSE);
}


DWORD
ScReadDependencies(
    HKEY    ServiceNameKey,
    LPWSTR  *Dependencies,
    LPWSTR  ServiceName
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    LPWSTR  DependOnService      = NULL;
    LPWSTR  DependOnGroup        = NULL;
    DWORD   DependOnServiceSize  = 0;
    DWORD   DependOnGroupSize    = 0;
    DWORD   status               = NO_ERROR;

    //
    // Read the DependOnService value
    //
    if (ScAllocateAndReadConfigValue(
              ServiceNameKey,
              DEPENDONSERVICE_VALUENAME_W,
              &DependOnService,
              &DependOnServiceSize
              ) != NO_ERROR)
    {
        DependOnService     = NULL;
        DependOnServiceSize = 0;
    }

    //
    // We write a length of 2 bytes into the
    // registry for an empty REG_MULTI_SZ.
    //
    else if ((DependOnServiceSize >= sizeof(WCHAR)) && (*DependOnService != L'\0'))
    {
        //
        // Make sure we got a valid MULTI_SZ
        //
        status = ScValidateMultiSZ(DependOnService,
                                   DependOnServiceSize);

        if (status != NO_ERROR) {

            SC_LOG2(CONFIG,
                    "ScReadDependencies: ScValidateMultiSZ failed %d for service %ws\n",
                    status,
                    ServiceName);

            //
            // Set this to NULL since we'll LocalFree it in CleanExit below
            //
            LocalFree(DependOnService);
            DependOnService     = NULL;
            DependOnServiceSize = 0;
        }

#if DBG
        SC_LOG1(CONFIG, "    " FORMAT_LPWSTR " DependOnService\n", ServiceName);
        ScDisplayWStrArray(DependOnService);
#endif

    }

    //
    // Read the DependOnGroup value
    //
    if (ScAllocateAndReadConfigValue(
              ServiceNameKey,
              DEPENDONGROUP_VALUENAME_W,
              &DependOnGroup,
              &DependOnGroupSize
              ) != NO_ERROR)
    {
        DependOnGroup     = NULL;
        DependOnGroupSize = 0;
    }

    //
    // We write a length of 2 bytes into the
    // registry for an empty REG_MULTI_SZ.
    //
    else if ((DependOnGroupSize >= sizeof(WCHAR)) && (*DependOnGroup != L'\0'))
    {
        //
        // Make sure we got a valid MULTI_SZ
        //
        status = ScValidateMultiSZ(DependOnGroup,
                                   DependOnGroupSize);

        if (status != NO_ERROR) {

            SC_LOG2(CONFIG,
                    "ScReadDependencies: ScValidateMultiSZ failed %d for service %ws\n",
                    status,
                    ServiceName);

            //
            // Set this to NULL since we'll LocalFree it in CleanExit below
            //
            LocalFree(DependOnGroup);
            DependOnGroup     = NULL;
            DependOnGroupSize = 0;
        }

#if DBG
        SC_LOG1(CONFIG, "    " FORMAT_LPWSTR " DependOnGroup\n", ServiceName);
        ScDisplayWStrArray(DependOnGroup);
#endif

    }

    //
    // Concatenate the DependOnService and DependOnGroup string arrays
    // to make the Dependencies array string.
    //
    if (DependOnService == NULL && DependOnGroup == NULL) {
        *Dependencies = NULL;
    }
    else {

        LPWSTR Entry;
        LPWSTR DestPtr;

        if (DependOnService != NULL) {
            DependOnServiceSize -= sizeof(WCHAR);  // subtract the NULL terminator
        }

        if (DependOnGroup != NULL) {

            Entry = DependOnGroup;

            while (*Entry != 0) {

                //
                // Add extra space for the group name to be prefixed
                // by SC_GROUP_IDENTIFIERW.
                //
                DependOnGroupSize += sizeof(WCHAR);

                Entry = (LPWSTR) ((DWORD_PTR) Entry + WCSSIZE(Entry));
            }
        }

        //
        // Allocate the total amount of memory needed for DependOnService
        // and DependOnGroup strings.
        //
        *Dependencies = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
                                            DependOnServiceSize +
                                                DependOnGroupSize +
                                                sizeof(WCHAR));     // NULL terminator

        if (*Dependencies == NULL) {

            SC_LOG1(ERROR,
                    "ScReadDependencies: LocalAlloc failed " FORMAT_DWORD "\n",
                    GetLastError());

            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }

        if (DependOnService != NULL) {

            RtlCopyMemory(*Dependencies, DependOnService, DependOnServiceSize);
        }

        if (DependOnGroup != NULL) {

            DWORD  EntrySize;

            DestPtr = (LPWSTR) ((DWORD_PTR) *Dependencies + DependOnServiceSize);
            Entry = DependOnGroup;

            while (*Entry != 0) {

                EntrySize = (DWORD) wcslen(Entry) + 1;

                *DestPtr = SC_GROUP_IDENTIFIERW;
                DestPtr++;

                wcscpy(DestPtr, Entry);

                DestPtr += EntrySize;
                Entry   += EntrySize;
            }
        }

#if DBG
        SC_LOG0(CONFIG, "    Dependencies\n");
        ScDisplayWStrArray(*Dependencies);
#endif

    }

CleanExit:

    LocalFree(DependOnService);
    LocalFree(DependOnGroup);
    return(status);
}


DWORD
ScReadConfigFromReg(
    LPSERVICE_RECORD    ServiceRecord,
    LPDWORD             lpdwServiceType,
    LPDWORD             lpdwStartType,
    LPDWORD             lpdwErrorControl,
    LPDWORD             lpdwTagId,
    LPWSTR              *Dependencies,
    LPWSTR              *LoadOrderGroup,
    LPWSTR              *DisplayName
    )

/*++

Routine Description:

    This function obtains some basic information about a service from
    the registry.

    If dependencies or load order group information are not present for
    the service in question, then NULL pointers will be returned for
    these parameters.

Arguments:



Return Value:



--*/
{
    DWORD   ApiStatus = NO_ERROR;
    HKEY    ServiceNameKey;

    ApiStatus = ScOpenServiceConfigKey(
            ServiceRecord->ServiceName,
            KEY_READ,
            FALSE,              // don't create if missing
            & ServiceNameKey );
    if (ApiStatus != NO_ERROR) {
        return(ApiStatus);
    }

    //---------------------
    // Service Type
    //---------------------
    ApiStatus = ScReadServiceType( ServiceNameKey, lpdwServiceType);
    if (ApiStatus != NO_ERROR) {
        ScRegCloseKey(ServiceNameKey);
        return(ApiStatus);
    }

    //---------------------
    // Start Type
    //---------------------
    ApiStatus = ScReadStartType( ServiceNameKey, lpdwStartType);
    if (ApiStatus != NO_ERROR) {
        ScRegCloseKey(ServiceNameKey);
        return(ApiStatus);
    }

    //---------------------
    // ErrorControl
    //---------------------
    ApiStatus = ScReadErrorControl( ServiceNameKey, lpdwErrorControl);
    if (ApiStatus != NO_ERROR) {
        ScRegCloseKey(ServiceNameKey);
        return(ApiStatus);
    }

    //---------------------
    // TagId
    //---------------------
    if (ScReadTag( ServiceNameKey, lpdwTagId) != NO_ERROR) {
        *lpdwTagId = 0;
    }

    //---------------------
    // Dependencies
    //---------------------

    if (Dependencies != NULL) {
        if (ScReadDependencies(
                        ServiceNameKey,
                        Dependencies,
                        ServiceRecord->ServiceName) != NO_ERROR) {

            *Dependencies = NULL;
        }
    }


    //---------------------
    // LoadGroupOrder
    //---------------------
    if (ScAllocateAndReadConfigValue(
            ServiceNameKey,
            GROUP_VALUENAME_W,
            LoadOrderGroup,
            NULL
            ) != NO_ERROR) {

        *LoadOrderGroup = NULL;
    }

    //---------------------
    // DisplayName
    //---------------------

    if (DisplayName != NULL) {

        ApiStatus = ScReadDisplayName(
                        ServiceNameKey,
                        DisplayName);
    }

    ScRegCloseKey(ServiceNameKey);

    return(ApiStatus);
}


DWORD
ScTakeOwnership(
    POBJECT_ATTRIBUTES  pObja
    )

/*++

Routine Description:

    This function attempts to take ownership of the key described by the
    Object Attributes.  If successful, it will modify the security descriptor
    to give LocalSystem full control over the key in question.

Arguments:

    pObja - Pointer to object attributes that describe the key.

Return Value:


--*/
{
    DWORD               status = NO_ERROR;
    NTSTATUS            ntStatus;
    HKEY                hKey;
    DWORD               SdBufSize=0;
    SECURITY_DESCRIPTOR tempSD;
    BOOL                DaclFlag;
    PACL                pDacl;
    BOOL                DaclDefaulted;
    PACL                pNewDacl=NULL;
    PACCESS_ALLOWED_ACE pMyAce=NULL;
    DWORD               bufSize;
    PISECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;

    //
    // An event should be logged whenever we must resort to using this
    // routine.
    //

    ScLogEvent(
        NEVENT_TAKE_OWNERSHIP,
        pObja->ObjectName->Buffer
        );

    //
    // If we were denied access, then assume we have the privilege
    // to get WRITE_OWNER access, so that we can modify the Security
    // Descriptor.
    //
    ntStatus = NtOpenKey(
                (PHANDLE)&hKey,
                (ACCESS_MASK)WRITE_OWNER,
                pObja);

    if (!NT_SUCCESS(ntStatus)) {
        // MAKE THIS A TRACE
        SC_LOG(ERROR, "ScTakeOwnership: NtOpenKey(WRITE_OWNER) failed %x\n",ntStatus);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Set the owner to be local system
    //
    if (!InitializeSecurityDescriptor(&tempSD,SECURITY_DESCRIPTOR_REVISION)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: InitializeSD(1) failed %d\n",status);
        NtClose(hKey);
        return(status);
    }
    if (!SetSecurityDescriptorOwner(&tempSD, LocalSystemSid,0)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: SetSDOwner failed %d\n",status);
        NtClose(hKey);
        return(status);
    }

    status = ScRegSetKeySecurity(
                hKey,
                OWNER_SECURITY_INFORMATION,
                &tempSD);

    if (status != NO_ERROR) {
        SC_LOG(ERROR, "ScRegOpenKeyExW: ScRegSetKeySecurity (take ownership)"
        " failed %d\n",status);
    }
    NtClose(hKey);

    //
    // Now open the handle again so that the DACL can be modified to
    // allow LocalSystem Full Access.
    //

    ntStatus = NtOpenKey(
                (PHANDLE)&hKey,
                (ACCESS_MASK)READ_CONTROL | WRITE_DAC,
                pObja);

    if (!NT_SUCCESS(ntStatus)) {
        // MAKE THIS A TRACE
        SC_LOG(ERROR, "ScTakeOwnership: NtOpenKey(WRITE_DAC) failed %x\n",ntStatus);
        return(RtlNtStatusToDosError(ntStatus));
    }
    status = ScRegGetKeySecurity(
                hKey,
                DACL_SECURITY_INFORMATION,
                pSecurityDescriptor,
                &SdBufSize);

    if (status != ERROR_INSUFFICIENT_BUFFER) {
        SC_LOG(ERROR, "ScTakeOwnership: ScRegGetKeySecurity(1) failed %d\n",
        status);
        NtClose(hKey);
        return(status);
    }
    pSecurityDescriptor = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_FIXED,SdBufSize);
    if (pSecurityDescriptor == NULL) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: LocalAlloc failed %d\n",status);
        NtClose(hKey);
        return(status);
    }
    status = ScRegGetKeySecurity(
                hKey,
                DACL_SECURITY_INFORMATION,
                pSecurityDescriptor,
                &SdBufSize);

    if (status != NO_ERROR) {
        SC_LOG(ERROR, "ScTakeOwnership: ScRegGetKeySecurity(2) failed %d\n",
        status);
        goto CleanExit;
    }

    //
    // Modify the DACL to allow LocalSystem to have all access.
    //
    // Get size of DACL

    if (!GetSecurityDescriptorDacl (
            pSecurityDescriptor,
            &DaclFlag,
            &pDacl,
            &DaclDefaulted)) {

        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: GetSecurityDescriptorDacl "
            " failed %d\n",status);
        goto CleanExit;
    }

    //
    // Create new ACE.
    //
    bufSize = sizeof(ACE_HEADER) +
              sizeof(ACCESS_MASK) +
              GetLengthSid(LocalSystemSid);

    pMyAce = (PACCESS_ALLOWED_ACE) LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (pMyAce == NULL) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: LocalAlloc(Ace) failed %d\n",status);
        goto CleanExit;
    }
    pMyAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pMyAce->Header.AceFlags = CONTAINER_INHERIT_ACE;
    pMyAce->Header.AceSize = (WORD)bufSize;
    pMyAce->Mask = GENERIC_ALL;
    if (!CopySid(
            GetLengthSid(LocalSystemSid),
            &(pMyAce->SidStart),
            LocalSystemSid)) {

        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: CopySid failed %d\n",status);
        goto CleanExit;
    }

    //
    // Allocate buffer for DACL and new ACE.
    //
    bufSize += pDacl->AclSize;

    pNewDacl = (PACL) LocalAlloc(LMEM_ZEROINIT, bufSize);
    if (pNewDacl == NULL) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: LocalAlloc (DACL) "
            " failed %d\n",status);
        goto CleanExit;
    }
    if (!InitializeAcl(pNewDacl, bufSize, ACL_REVISION)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: InitializeAcl failed %d\n",status);
        goto CleanExit;
    }

    //
    // Add the ACE to the DACL
    //
    if (!AddAce(
        pNewDacl,                           // pACL
        pDacl->AclRevision,                 // dwACLRevision
        0,                                  // dwStartingAceIndex
        pMyAce,                             // pAceList
        (DWORD)pMyAce->Header.AceSize)) {   // cbAceList

        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: AddAce failed %d\n",status);
        goto CleanExit;
    }

    //
    // Initialize a new SD.
    //
    if (!InitializeSecurityDescriptor(&tempSD,SECURITY_DESCRIPTOR_REVISION)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: InitializeSD failed %d\n",status);
        goto CleanExit;
    }

    //
    // Add the new DACL to the SD
    //
    if (!SetSecurityDescriptorDacl(&tempSD,TRUE,pNewDacl,FALSE)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: SetSecurityDescriptorDacl failed %d\n",status);
        goto CleanExit;
    }

    //
    // Set DACL on the key's security descriptor.
    //
    status = ScRegSetKeySecurity(
                hKey,
                DACL_SECURITY_INFORMATION,
                &tempSD);

    if (status != NO_ERROR) {
        SC_LOG(ERROR, "ScTakeOwnership: ScRegSetKeySecurity(new DACL) failed %d\n",
        status);
    }

    SC_LOG0(CONFIG, "ScTakeOwnership: Changed SD, now try to open with "
    "Desired Access\n");

CleanExit:

    LocalFree(pNewDacl);
    LocalFree(pMyAce);
    LocalFree (pSecurityDescriptor);

    NtClose(hKey);
    return(status);

} // ScTakeOwnership


DWORD
ScOpenSecurityKey(
    IN HKEY     ServiceNameKey,
    IN DWORD    DesiredAccess,
    IN BOOL     CreateIfMissing,
    OUT PHKEY   pSecurityKey
    )

/*++

Routine Description:

    This function opens, or creates (if it doesn't exist), the Security Key
    that is a sub-key of the service's key.  This key is created such that
    only LocalSystem and Administrators have access.

Arguments:

    ServiceNameKey - This is a key to the service key that will contain
        the security key.

    DesiredAccess - This is the access that is desired with the SecurityKey
        that will be returned on a successful call.

    pSecurityKey - A pointer to a location where the security key is to
        be placed.

Return Value:

    NO_ERROR - if the operation is successful.

    otherwise, a registry error code is returned.


--*/
{
    LONG    RegError;

    LPWSTR  SecurityKeyName = SD_VALUENAME_W;



    DWORD                   Disposition;
    NTSTATUS                ntstatus;
    SECURITY_ATTRIBUTES     SecurityAttr;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;

#define SEC_KEY_ACE_COUNT 2
    SC_ACE_DATA AceData[SEC_KEY_ACE_COUNT] = {
        {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
               GENERIC_ALL,                &LocalSystemSid},
        {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
               GENERIC_ALL,                &AliasAdminsSid}
        };


    if (!CreateIfMissing) {
        //
        // Open the existing security key.
        //
        RegError = ScRegOpenKeyExW(
                    ServiceNameKey,
                    SecurityKeyName,
                    REG_OPTION_NON_VOLATILE,
                    DesiredAccess,
                    pSecurityKey);
        if (RegError != ERROR_SUCCESS) {
            SC_LOG2(TRACE, "ScOpenSecurityKey: "
                    "ScRegOpenKeyExW of " FORMAT_LPWSTR " failed "
                    FORMAT_LONG "\n", SecurityKeyName, RegError);

        }
        return((DWORD)RegError);
    }

    //
    // Create a security descriptor for the registry key we are about
    // to create.  This gives everyone read access, and all access to
    // ourselves and the admins.
    //
    ntstatus = ScCreateAndSetSD(
                   AceData,
                   SEC_KEY_ACE_COUNT,
                   LocalSystemSid,
                   LocalSystemSid,
                   &SecurityDescriptor
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR, "ScCreateAndSetSD failed " FORMAT_NTSTATUS
                "\n", ntstatus);
        return(RtlNtStatusToDosError(ntstatus));
    }

    //
    // Protect the DACL on the SD so it can't be overridden by DACL inheritance
    // from parent keys.  Since this key can contain a SACL, we want to make
    // sure access to it is always what we expect.
    //

    ntstatus = RtlSetControlSecurityDescriptor(SecurityDescriptor,
                                               SE_DACL_PROTECTED,
                                               SE_DACL_PROTECTED);

    if (!NT_SUCCESS(ntstatus))
    {
        SC_LOG1(ERROR,
                "ScOpenSecurityKey:  RtlSetControlSecurityDescriptor failed %x\n",
                ntstatus);

        RtlDeleteSecurityObject(&SecurityDescriptor);
        return RtlNtStatusToDosError(ntstatus);
    }

    SecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttr.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttr.bInheritHandle = FALSE;

    //
    // Create a new service key (or open existing one).
    //
    RegError = ScRegCreateKeyExW(
           ServiceNameKey,
           SecurityKeyName,
           0,
           0,
           REG_OPTION_NON_VOLATILE, // options
           DesiredAccess,           // desired access
           &SecurityAttr,
           pSecurityKey,
           &Disposition);


    RtlDeleteSecurityObject(&SecurityDescriptor);

    if (RegError != ERROR_SUCCESS) {
        SC_LOG2(ERROR, "ScOpenSecurityKey: "
                "ScRegCreateKeyExW of " FORMAT_LPWSTR " failed "
                FORMAT_LONG "\n", SecurityKeyName, RegError);
        return ((DWORD) RegError);
    }

    return NO_ERROR;

} // ScOpenSecurityKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\sclastgood.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ScLastGood.cxx

Abstract:

    This module implements various functions required to clean-up last known
    good information.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#include "precomp.hxx"
#include "ScpLastGood.h"

//
// DeleteFile is a member of a structure we use below. Here we keep Windows.h
// from redefining the structure member to DeleteFileW.
//
#ifdef DeleteFile
#undef DeleteFile
#endif

DWORD
ScLastGoodFileCleanup(
    VOID
    )
/*++

Routine Description:

    This routine does the neccessary processing to mark a boot "good".
    Specifically, the last known good directory is emptied of any files or
    directories.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING lastKnownGoodTmpSubTree;
    UNICODE_STRING lastKnownGoodTmpRegKey;
    HANDLE regKeyHandle;
    NTSTATUS status;

    RtlInitUnicodeString(
        &lastKnownGoodTmpSubTree,
        L"\\SystemRoot\\LastGood.Tmp"
        );

    RtlInitUnicodeString(
        &lastKnownGoodTmpRegKey,
        L"\\Registry\\Machine\\System\\LastKnownGoodRecovery\\LastGood.Tmp"
        );

    //
    // Delete the temp tree.
    //
    ScLastGoodWalkDirectoryTreeBottomUp(
        &lastKnownGoodTmpSubTree,
        ( DIRWALK_INCLUDE_FILES | DIRWALK_INCLUDE_DIRECTORIES |
          DIRWALK_CULL_DOTPATHS | DIRWALK_TRAVERSE ),
        ScpLastGoodDeleteFiles,
        NULL
        );

    InitializeObjectAttributes(
        &objectAttributes,
        &lastKnownGoodTmpSubTree,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    NtDeleteFile(&objectAttributes);

    //
    // Now delete the corresponding registry key info.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        &lastKnownGoodTmpRegKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(
        &regKeyHandle,
        KEY_ALL_ACCESS,
        &objectAttributes
        );

    if (NT_SUCCESS(status)) {

        NtDeleteKey(regKeyHandle);
        NtClose(regKeyHandle);
    }

    return NO_ERROR;
}


//
// This function works, but it is not needed today.
//
DWORD
ScLastGoodWalkDirectoryTreeTopDown(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    )
/*++

Routine Description:

    This funcion walks a directory tree *top down*, passing each entry to the
    callback with the below restrictions. Note that the root directory itself
    is not included in the callback!

Arguments:

    Directory - Supplies the NT Path to the directory to walk.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                          dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

Return Value:

    DWORD - status of the operation, NO_ERROR on success.

--*/
{
    PDIRWALK_ENTRY pDirEntry;
    PLIST_ENTRY pListEntry;
    NTSTATUS status;
    UCHAR buffer[1024];
    LIST_ENTRY dirListHead;

    InitializeListHead(&dirListHead);

    //
    // Walk the first directory.
    //
    status = ScpLastGoodWalkDirectoryTreeHelper(
        Directory,
        Flags,
        CallbackFunction,
        Context,
        buffer,
        sizeof(buffer),
        &dirListHead
        );

    //
    // Each directory that WalkDirectory finds gets added to the list.
    // process the list until we have no more directories.
    //
    while((!IsListEmpty(&dirListHead)) && NT_SUCCESS(status)) {

        pListEntry = RemoveHeadList(&dirListHead);

        pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

        status = ScpLastGoodWalkDirectoryTreeHelper(
            &pDirEntry->Directory,
            Flags,
            CallbackFunction,
            Context,
            buffer,
            sizeof(buffer),
            &dirListHead
            );

        LocalFree(pDirEntry);
    }

    //
    // If we failed we need to empty out our directory list.
    //
    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&dirListHead)) {

            pListEntry = RemoveHeadList(&dirListHead);

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            LocalFree(pDirEntry);
        }
    }

    return RtlNtStatusToDosError(status);
}


DWORD
ScLastGoodWalkDirectoryTreeBottomUp(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    )
/*++

Routine Description:

    This funcion walks a directory tree *bottom up*, passing each entry to the
    callback with the below restrictions. Note that the root directory itself
    is not included in the callback!

Arguments:

    Directory - Supplies the NT Path to the directory to walk.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

Return Value:

    DWORD - status of the operation, NO_ERROR on success.

--*/
{
    PDIRWALK_ENTRY pDirEntry;
    PLIST_ENTRY pListEntry;
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR buffer[1024];
    LIST_ENTRY dirListHead, dirNothingHead;

    InitializeListHead(&dirListHead);
    InitializeListHead(&dirNothingHead);

    //
    // Create an entry for the root directory.
    //
    pDirEntry = (PDIRWALK_ENTRY) LocalAlloc(
        LPTR,
        sizeof(DIRWALK_ENTRY) + Directory->Length - sizeof(WCHAR)
        );

    if (pDirEntry == NULL) {

        return RtlNtStatusToDosError(STATUS_INSUFFICIENT_RESOURCES);
    }

    pDirEntry->Directory.Length = 0;
    pDirEntry->Directory.MaximumLength = Directory->Length;
    pDirEntry->Directory.Buffer = &pDirEntry->Name[0];
    RtlCopyUnicodeString(&pDirEntry->Directory, Directory);

    InsertHeadList(&dirListHead, &pDirEntry->Link);

    //
    // Collect the directory trees. When we are done we will walk the list in
    // reverse.
    //
    status = STATUS_SUCCESS;
    if (Flags & DIRWALK_TRAVERSE) {

        for(pListEntry = dirListHead.Flink;
            pListEntry != &dirListHead;
            pListEntry = pListEntry->Flink) {

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            status = ScpLastGoodWalkDirectoryTreeHelper(
                &pDirEntry->Directory,
                DIRWALK_TRAVERSE,
                NULL,
                NULL,
                buffer,
                sizeof(buffer),
                &dirListHead
                );

            if (!NT_SUCCESS(status)) {

                break;
            }
        }
    }

    //
    // Each directory that WalkDirectory finds gets added to the list.
    // process the list until we have no more directories.
    //
    while((!IsListEmpty(&dirListHead)) && NT_SUCCESS(status)) {

        pListEntry = RemoveTailList(&dirListHead);

        pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

        status = ScpLastGoodWalkDirectoryTreeHelper(
            &pDirEntry->Directory,
            Flags & ~DIRWALK_TRAVERSE,
            CallbackFunction,
            Context,
            buffer,
            sizeof(buffer),
            &dirNothingHead
            );

        LocalFree(pDirEntry);

        ASSERT(IsListEmpty(&dirNothingHead));
    }

    //
    // Now do any final cleanup.
    //
    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&dirListHead)) {

            pListEntry = RemoveHeadList(&dirListHead);

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            LocalFree(pDirEntry);
        }
    }

    return RtlNtStatusToDosError(status);
}


NTSTATUS
ScpLastGoodWalkDirectoryTreeHelper(
    IN      PUNICODE_STRING  Directory,
    IN      ULONG            Flags,
    IN      DIRWALK_CALLBACK CallbackFunction   OPTIONAL,
    IN      PVOID            Context,
    IN      PUCHAR           Buffer,
    IN      ULONG            BufferSize,
    IN OUT  PLIST_ENTRY      DirList
    )
/*++

Routine Description:

    This is a helper function for the ScLastGoodWalkDirectory*Tree functions.
    Each directory is added to the list for later processing.

Arguments:

    Directory - Supplies the NT Path to the directory to walk.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

    Buffer - A scratch buffer to use.

    BufferSize - The length of Buffer. Must be greater than sizeof(WCHAR).

    DirList - Recieves list of new directories to scan after completion of this
              directory. Each entry is a member of the DIRECTORY_ENTRY
              structure.

Return Value:

    NTSTATUS - status of the operation.

--*/
{
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    BOOLEAN bRestartScan, bIsDotPath;
    WCHAR savedChar;
    PFILE_BOTH_DIR_INFORMATION pFileInfo;
    UNICODE_STRING entryName;
    USHORT newNameLength;
    PDIRWALK_ENTRY pDirEntry;
    ULONG OpenFlags;

    //
    // Setup initial values
    //
    bRestartScan = TRUE;

    //
    //  Open the file for list directory access
    //
    if (Flags & DIRWALK_TRAVERSE_MOUNTPOINTS) {

        OpenFlags = FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT;

    } else {

        OpenFlags = FILE_OPEN_REPARSE_POINT |
                    FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        Directory,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile(
        &fileHandle,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ,
        OpenFlags
        );

    if (!NT_SUCCESS(status)) {

        goto cleanup;
    }

    //
    //  Do the directory loop
    //
    while(1) {

        //
        // We subtract off a WCHAR so that we can append a terminating null as
        // needed.
        //
        ASSERT(BufferSize > sizeof(WCHAR));

        status = NtQueryDirectoryFile(
            fileHandle,
            (HANDLE)NULL,
            (PIO_APC_ROUTINE)NULL,
            (PVOID)NULL,
            &ioStatus,
            Buffer,
            BufferSize - sizeof(WCHAR),
            FileBothDirectoryInformation,
            FALSE,
            (PUNICODE_STRING)NULL,
            bRestartScan
            );

        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // We may come back here. Make sure the file scan doesn't start back
        // over.
        //
        bRestartScan = FALSE;

        //
        // Wait for the event to complete if neccessary.
        //
        if (status == STATUS_PENDING) {

            NtWaitForSingleObject(fileHandle, TRUE, NULL);
            status = ioStatus.Status;

            //
            //  Check the Irp for success
            //
            if (!NT_SUCCESS(status)) {

                break;
            }
        }

        //
        // Walk each returned record. Note that we won't be here if there are
        // no records, as ioStatus will have contains STATUS_NO_MORE_FILES.
        //
        pFileInfo = (PFILE_BOTH_DIR_INFORMATION) Buffer;

        while(1) {

            //
            // Temporarily terminate the file. We allocated an extra WCHAR to
            // make sure we could safely do this.
            //
            savedChar = pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)];
            pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)] = 0;

            //
            // Build a full unicode path for the file along with a directory
            // entry at the same time.
            //
            RtlInitUnicodeString(&entryName, pFileInfo->FileName);

            newNameLength =
                (Directory->Length + entryName.Length + sizeof(WCHAR));

            pDirEntry = (PDIRWALK_ENTRY) LocalAlloc(
                LPTR,
                sizeof(DIRWALK_ENTRY) + newNameLength
                );

            if (pDirEntry == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            pDirEntry->Directory.Length = 0;
            pDirEntry->Directory.MaximumLength = newNameLength;
            pDirEntry->Directory.Buffer = &pDirEntry->Name[0];
            RtlCopyUnicodeString(&pDirEntry->Directory, Directory);
            RtlAppendUnicodeToString(&pDirEntry->Directory, L"\\");
            RtlAppendUnicodeStringToString(&pDirEntry->Directory, &entryName);

            if (pFileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // Check for . and ..
                //
                bIsDotPath = ((!_wcsicmp(pFileInfo->FileName, L".")) ||
                              (!_wcsicmp(pFileInfo->FileName, L"..")));

                if ((Flags & DIRWALK_INCLUDE_DIRECTORIES) &&
                    ((!(Flags & DIRWALK_CULL_DOTPATHS)) || (!bIsDotPath))) {

                    status = CallbackFunction(
                        &pDirEntry->Directory,
                        &entryName,
                        pFileInfo->FileAttributes,
                        Context
                        );
                }

                if ((!bIsDotPath) && (Flags & DIRWALK_TRAVERSE)) {

                    InsertTailList(DirList, &pDirEntry->Link);

                } else {

                    LocalFree(pDirEntry);
                }

            } else {

                if (Flags & DIRWALK_INCLUDE_FILES) {

                    status = CallbackFunction(
                        &pDirEntry->Directory,
                        &entryName,
                        pFileInfo->FileAttributes,
                        Context
                        );
                }

                LocalFree(pDirEntry);
            }

            if (!NT_SUCCESS(status)) {

                break;
            }

            //
            // Put back the character we wrote down. It might have been part of
            // the next entry.
            //
            pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)] = savedChar;

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //
            if (pFileInfo->NextEntryOffset == 0) {

                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //
            pFileInfo = (PFILE_BOTH_DIR_INFORMATION)
                (((PUCHAR) pFileInfo) + pFileInfo->NextEntryOffset);
        }

        if (!NT_SUCCESS(status)) {

            break;
        }
    }

    NtClose( fileHandle );

    if (status == STATUS_NO_MORE_FILES) {

        status = STATUS_SUCCESS;
    }

cleanup:
    return status;
}


NTSTATUS
ScpLastGoodDeleteFiles(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    )
/*++

Routine Description:

    This callback routine is called for each file under the LastGood directory.
    It's job is to delete each such file.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    FILE_DISPOSITION_INFORMATION Disposition;
    ULONG OpenFlags;

    //
    // Remove any attributes that might stop us from deleting this file.
    //
    ScLastGoodClearAttributes(
        FullPathName,
        ( FILE_ATTRIBUTE_READONLY |
          FILE_ATTRIBUTE_HIDDEN |
          FILE_ATTRIBUTE_SYSTEM )
        );

    //
    // Now delete the file.
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        FullPathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );


    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        OpenFlags = FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT |
                    FILE_OPEN_REPARSE_POINT;
    } else {

        OpenFlags = FILE_NON_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT |
                    FILE_OPEN_REPARSE_POINT;
    }

    Status = NtOpenFile(
        &FileHandle,
        DELETE | FILE_READ_ATTRIBUTES,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
        OpenFlags
        );

    if (!NT_SUCCESS(Status)) {

        KdPrintEx((
            DPFLTR_SCSERVER_ID,
            DEBUG_CONFIG_API,
            "SERVICES: Cannot open last known good file: %Zw %x\n",
            FullPathName,
            Status
            ));

        return Status;
    }

    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
        FileHandle,
        &IoStatusBlock,
        &Disposition,
        sizeof(Disposition),
        FileDispositionInformation
        );

    if (!NT_SUCCESS(Status)) {

        KdPrintEx((
            DPFLTR_SCSERVER_ID,
            DEBUG_CONFIG_API,
            "SERVICES: Cannot delete last known good file: %Zw %x\n",
            FullPathName,
            Status
            ));
    }

    NtClose(FileHandle);

    //
    // If we can't delete one file, keep trying to delete the rest.
    //
    return STATUS_SUCCESS;
}


NTSTATUS
ScLastGoodClearAttributes(
    IN PUNICODE_STRING  FullPathName,
    IN ULONG            FileAttributes
    )
/*++

Routine Description:

    This function clears the passed in attributes off the specified file.

Arguments:

    FullPathName - Full path name of the identified file.

    FileAttributes - Attributes to clear.

Return Value:

    NTSTATUS.

--*/
{
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    FILE_BASIC_INFORMATION fileBasicInformation;
    ULONG newAttributes;
    NTSTATUS status;

    //
    // First we open the file.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        FullPathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile(
        &fileHandle,
        FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_FOR_BACKUP_INTENT | FILE_WRITE_THROUGH
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Then we get the file attributes.
    //
    status = NtQueryInformationFile(
        fileHandle,
        &ioStatus,
        &fileBasicInformation,
        sizeof(fileBasicInformation),
        FileBasicInformation
        );

    if (!NT_SUCCESS(status)) {

        NtClose(fileHandle);
        return status;
    }

    //
    // Anything to do?
    //
    if (fileBasicInformation.FileAttributes & FileAttributes) {

        //
        // Clear the specified bits.
        //
        newAttributes = fileBasicInformation.FileAttributes;
        newAttributes &= ~FileAttributes;
        if (newAttributes == 0) {

            newAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        //
        // Zero fields that shouldn't be touched.
        //
        RtlZeroMemory(
            &fileBasicInformation,
            sizeof(FILE_BASIC_INFORMATION)
            );

        fileBasicInformation.FileAttributes = newAttributes;

        //
        // Commit the changes.
        //
        status = NtSetInformationFile(
            fileHandle,
            &ioStatus,
            &fileBasicInformation,
            sizeof(fileBasicInformation),
            FileBasicInformation
            );
    }

    NtClose(fileHandle);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scconfig.h ===
/*++

Copyright (c) 1991, 1992 Microsoft Corporation

Module Name:

    scconfig.h

Abstract:

    Service configuration related function prototypes.

Author:

    Dan Lafferty (danl)     03-Apr-1991

Revision History:

    22-Apr-1992 JohnRo
        Added ScAllocateAndReadConfigValue(), ScOpenServiceConfigKey(),
        and ScWriteServiceType().  Added CreateIfMissing flag to
        ScOpenServiceConfigKey().  Added ScWriteImageFileName(),
        ScWriteDependencies(), ScWriteGroupForThisService().

    24-Apr-1992 RitaW
        ScAllocateAndReadConfigValue() returns DWORD.

--*/

#ifndef SCCONFIG_INCLUDED
#define SCCONFIG_INCLUDED


#include <winreg.h>     // HKEY, PHKEY.
#include <scwow.h>      // 32/64-bit interop structures

//
// Macros
//

#define ScRegCloseKey(handle)   RtlNtStatusToDosError(NtClose((HANDLE)handle))
#define ScRegFlushKey(handle)   RtlNtStatusToDosError(NtFlushKey((HANDLE)handle))


//
// Value names in registry
//
#define START_VALUENAME_W           L"Start"
#define GROUP_VALUENAME_W           L"Group"
#define TAG_VALUENAME_W             L"Tag"
#define DEPENDONSERVICE_VALUENAME_W L"DependOnService"
#define DEPENDONGROUP_VALUENAME_W   L"DependOnGroup"
#define ERRORCONTROL_VALUENAME_W    L"ErrorControl"
#define IMAGE_VALUENAME_W           L"ImagePath"
#define SERVICETYPE_VALUENAME_W     L"Type"
#define STARTNAME_VALUENAME_W       L"ObjectName"
#define DISPLAYNAME_VALUENAME_W     L"DisplayName"
#define DESCRIPTION_VALUENAME_W     L"Description"
#define REBOOTMESSAGE_VALUENAME_W   L"RebootMessage"
#define FAILURECOMMAND_VALUENAME_W  L"FailureCommand"
#define FAILUREACTIONS_VALUENAME_W  L"FailureActions"
#define SD_VALUENAME_W              L"Security"
#define LOAD_ORDER_GROUP_LIST_KEY   L"System\\CurrentControlSet\\Control\\ServiceGroupOrder"
#define GROUP_VECTORS_KEY           L"System\\CurrentControlSet\\Control\\GroupOrderList"
#define GROUPLIST_VALUENAME_W       L"List"
#define CONTROL_WINDOWS_KEY_W       L"System\\CurrentControlSet\\Control\\Windows"
#define NOINTERACTIVE_VALUENAME_W   L"NoInteractiveServices"
#define NOBOOTPOPUPS_VALUENAME_W    L"NoPopupsOnBoot"
#define ENVIRONMENT_VALUENAME_W     L"Environment"
#define PROVIDER_KEY_BASE           L"System\\CurrentControlSet\\Control\\NetworkProvider"
#define PROVIDER_KEY_ORDER          L"Order"
#define PROVIDER_KEY_HW             L"HwOrder"
#define PROVIDER_VALUE              L"ProviderOrder"

//
// Function Prototypes
//

DWORD
ScGetEnvironment (
    IN  LPWSTR  ServiceName,
    OUT LPVOID  *Environment
    );

DWORD
ScGetImageFileName (
    LPWSTR   ServiceName,
    LPWSTR   *ImageNamePtr
    );

BOOL
ScGenerateServiceDB(
    VOID
    );

#ifndef _CAIRO_
BOOL
ScInitSecurityProcess(
    LPSERVICE_RECORD    ServiceRecord
    );
#endif // _CAIRO_

DWORD
ScAllocateAndReadConfigValue(
    IN HKEY Key,
    IN LPCWSTR ValueName,
    OUT LPWSTR *Value,
    OUT LPDWORD BytesReturned OPTIONAL
    );

DWORD
ScReadOptionalString(
    IN  HKEY    ServiceNameKey,
    IN  LPCWSTR ValueName,
    OUT LPWSTR  *Value,
    IN OUT LPDWORD TotalBytes = NULL
    );

BOOL
ScCreateLoadOrderGroupList(
    VOID
    );

DWORD
ScGetGroupVector(
    IN  LPWSTR Group,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    );

BOOL
ScGetToken(
    IN OUT LPWSTR *CurrentPtr,
    OUT    LPWSTR *TokenPtr
    );

DWORD
ScOpenServiceConfigKey(
    IN LPWSTR ServiceName,
    IN DWORD DesiredAccess,
    IN BOOL CreateIfMissing,
    OUT PHKEY ServiceKey
    );

DWORD
ScReadServiceType(
    IN HKEY ServiceNameKey,
    OUT LPDWORD ServiceTypePtr
    );

DWORD
ScReadStartType(
    IN HKEY ServiceNameKey,
    OUT LPDWORD StartTypePtr
    );

DWORD
ScReadTag(
    IN HKEY ServiceNameKey,
    OUT LPDWORD TagPtr
    );

DWORD
ScReadFailureActions(
    IN HKEY ServiceNameKey,
    OUT LPSERVICE_FAILURE_ACTIONS_WOW64 * FailActPtr,
    IN OUT LPDWORD TotalBytes = NULL
    );

DWORD
ScReadErrorControl(
    IN HKEY ServiceNameKey,
    OUT LPDWORD ErrorControlPtr
    );

DWORD
ScReadStartName(
    IN HKEY ServiceNameKey,
    OUT LPWSTR *AccountName
    );

DWORD
ScWriteOptionalString(
    IN HKEY ServiceNameKey,
    IN LPCWSTR ValueName,
    IN LPCWSTR Value
    );

DWORD
ScWriteDependencies(
    IN HKEY ServiceNameKey,
    IN LPWSTR Dependencies,
    IN DWORD DependSize
    );

DWORD
ScWriteDisplayName(
    IN HKEY ServiceNameKey,
    IN LPWSTR DisplayName
    );

DWORD
ScWriteErrorControl(
    IN HKEY hServiceKey,
    IN DWORD dwErrorControl
    );

DWORD
ScWriteSd(
    IN HKEY ServiceNameKey,
    IN PSECURITY_DESCRIPTOR Security
    );

DWORD
ScWriteGroupForThisService(
    IN HKEY ServiceNameKey,
    IN LPWSTR Group
    );

DWORD
ScWriteImageFileName(
    IN HKEY hServiceKey,
    IN LPWSTR ImageFileName
    );

DWORD
ScWriteServiceType(
    IN HKEY hServiceKey,
    IN DWORD dwServiceType
    );

DWORD
ScWriteStartType(
    IN HKEY hServiceKey,
    IN DWORD lpStartType
    );

DWORD
ScWriteTag(
    IN HKEY hServiceKey,
    IN DWORD dwTag
    );

DWORD
ScWriteFailureActions(
    IN HKEY ServiceNameKey,
    IN LPSERVICE_FAILURE_ACTIONSW psfa
    );

DWORD
ScWriteCurrentServiceValue(
    OUT LPDWORD lpdwID
    );

VOID
ScDeleteTag(
    IN HKEY hServiceKey
    );

DWORD
ScWriteStartName(
    IN HKEY ServiceNameKey,
    IN LPWSTR StartName
    );

DWORD
ScOpenServicesKey(
    OUT PHKEY ServicesKey
    );

DWORD
ScRegCreateKeyExW(
    IN  HKEY                    hKey,
    IN  LPWSTR                  lpSubKey,
    IN  DWORD                   dwReserved,
    IN  LPWSTR                  lpClass,
    IN  DWORD                   dwOptions,
    IN  REGSAM                  samDesired,
    IN  LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    OUT PHKEY                   phkResult,
    OUT LPDWORD                 lpdwDisposition
    );

DWORD
ScRegOpenKeyExW(
    IN  HKEY    hKey,
    IN  LPWSTR  lpSubKey,
    IN  DWORD   dwOptions,
    IN  REGSAM  samDesired,
    OUT PHKEY   phkResult
    );

DWORD
ScRegQueryValueExW(
    IN      HKEY    hKey,
    IN      LPCWSTR lpValueName,
    OUT     LPDWORD lpReserved,
    OUT     LPDWORD lpType,
    OUT     LPBYTE  lpData,
    IN OUT  LPDWORD lpcbData
    );

DWORD
ScRegSetValueExW(
    IN  HKEY    hKey,
    IN  LPCWSTR lpValueName,
    IN  DWORD   lpReserved,
    IN  DWORD   dwType,
    IN  LPVOID  lpData,
    IN  DWORD   cbData
    );

DWORD
ScRegDeleteValue(
    IN  HKEY    hKey,
    IN  LPCWSTR lpValueName
    );

DWORD
ScRegEnumKeyW(
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpName,
    DWORD   cbName
    );

DWORD
ScRegDeleteKeyW (
    HKEY    hKey,
    LPWSTR  lpSubKey
    );

DWORD
ScRegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

DWORD
ScRegGetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    );

DWORD
ScRegSetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

DWORD
ScRegEnumValueW (
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    );

VOID
ScHandleProviderChange(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    );

VOID
ScMarkForDelete(
    LPSERVICE_RECORD  ServiceRecord
    );

DWORD
ScReadDependencies(
    HKEY    ServiceNameKey,
    LPWSTR  *Dependencies,
    LPWSTR  ServiceName
    );

DWORD
ScReadConfigFromReg(
    LPSERVICE_RECORD    ServiceRecord,
    LPDWORD             lpdwServiceType,
    LPDWORD             lpdwStartType,
    LPDWORD             lpdwErrorControl,
    LPDWORD             lpdwTagId,
    LPWSTR              *Dependencies,
    LPWSTR              *LoadOrderGroup,
    LPWSTR              *DisplayName
    );

inline DWORD
ScReadDisplayName(
    IN  HKEY    ServiceNameKey,
    OUT LPWSTR  *DisplayName
    )
{
    return (ScReadOptionalString(
                ServiceNameKey,
                DISPLAYNAME_VALUENAME_W,
                DisplayName
                ));
}

inline DWORD
ScWriteDisplayName(
    IN HKEY ServiceNameKey,
    IN LPWSTR DisplayName
    )
{
    return (ScWriteOptionalString(
                    ServiceNameKey,
                    DISPLAYNAME_VALUENAME_W,
                    DisplayName
                    ));
}

DWORD
ScReadNoInteractiveFlag(
    IN HKEY ServiceNameKey,
    OUT LPDWORD NoInteractivePtr
    );

inline DWORD
ScReadDescription(
    IN  HKEY    ServiceNameKey,
    OUT LPWSTR  *Description,
    IN OUT LPDWORD TotalBytes = NULL
    )
{
    return (ScReadOptionalString(
                ServiceNameKey,
                DESCRIPTION_VALUENAME_W,
                Description,
                TotalBytes
                ));
}

inline DWORD
ScWriteDescription(
    IN HKEY ServiceNameKey,
    IN LPWSTR Description
    )
{
    return (ScWriteOptionalString(
                    ServiceNameKey,
                    DESCRIPTION_VALUENAME_W,
                    Description
                    ));
}

inline DWORD
ScReadRebootMessage(
    IN  HKEY    ServiceNameKey,
    OUT LPWSTR  *RebootMessage,
    IN OUT LPDWORD TotalBytes = NULL
    )
{
    return (ScReadOptionalString(
                ServiceNameKey,
                REBOOTMESSAGE_VALUENAME_W,
                RebootMessage,
                TotalBytes
                ));
}

inline DWORD
ScReadFailureCommand(
    IN  HKEY    ServiceNameKey,
    OUT LPWSTR  *FailureCommand,
    IN OUT LPDWORD TotalBytes = NULL
    )
{
    return (ScReadOptionalString(
                ServiceNameKey,
                FAILURECOMMAND_VALUENAME_W,
                FailureCommand,
                TotalBytes
                ));
}


#endif // #ifndef SCCONFIG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scplastgood.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ScpLastGood.h

Abstract:

    This header contains private information to implement last known good boot
    cleanup. This file is mean to be included only by ScLastGood.cxx

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

typedef struct {

    LIST_ENTRY      Link;
    UNICODE_STRING  Directory;
    WCHAR           Name[1];

} DIRWALK_ENTRY, *PDIRWALK_ENTRY;

NTSTATUS
ScpLastGoodWalkDirectoryTreeHelper(
    IN      PUNICODE_STRING  Directory,
    IN      ULONG            Flags,
    IN      DIRWALK_CALLBACK CallbackFunction   OPTIONAL,
    IN      PVOID            Context            OPTIONAL,
    IN      PUCHAR           Buffer,
    IN      ULONG            BufferSize,
    IN OUT  PLIST_ENTRY      DirList
    );

NTSTATUS
ScpLastGoodDeleteFiles(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\sclastgood.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ScLastGood.h

Abstract:

    This header exposes routines neccessary for cleaning up last known good
    information.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#define DIRWALK_INCLUDE_FILES           0x00000001
#define DIRWALK_INCLUDE_DIRECTORIES     0x00000002
#define DIRWALK_CULL_DOTPATHS           0x00000004
#define DIRWALK_TRAVERSE                0x00000008
#define DIRWALK_TRAVERSE_MOUNTPOINTS    0x00000010

typedef NTSTATUS (*DIRWALK_CALLBACK)(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    );

DWORD
ScLastGoodWalkDirectoryTreeTopDown(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    );

DWORD
ScLastGoodWalkDirectoryTreeBottomUp(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    );

NTSTATUS
ScLastGoodClearAttributes(
    IN PUNICODE_STRING  FullPathName,
    IN ULONG            FileAttributes
    );

DWORD
ScLastGoodFileCleanup(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scopen.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ScOpen.h

Abstract:

    Contains data structures used for Service Controller Handles.
    Also some closely-related prototypes.

Author:

    Dan Lafferty (danl)     20-Jan-1992

Environment:

    User Mode -Win32

Revision History:

    20-Jan-1992     danl
        created
    11-Mar-1992     ritaw
        changed context handle structure
    10-Apr-1992 JohnRo
        Added ScIsValidServiceHandle() and ScCreateServiceHandle().
    15-Apr-1992 JohnRo
        Added ScIsValidScManagerHandle().

--*/


#ifndef SCOPEN_H
#define SCOPEN_H


#include <svcctl.h>     // MIDL generated header file. (SC_RPC_HANDLE)


//
// Signature value in handle
//
#define SC_SIGNATURE               0x6E4F6373  // "scOn" in ASCII.
#define SERVICE_SIGNATURE          0x76724573  // "sErv" in ASCII.

//
// The following are definitions for the Flags field in the handle.
//
// SC_HANDLE_GENERATE_ON_CLOSE indicates that NtCloseAuditAlarm must
//                        be called when this handle is closed.  This flag
//                        is set when an audit is generated on open.
//

#define     SC_HANDLE_GENERATE_ON_CLOSE         0x0001

//
// Data associated with each opened context handle
//
typedef struct  _SC_HANDLE_STRUCT{

    DWORD Signature;     // For block identification to detect some app errors
    DWORD Flags;         // See definitions above
    DWORD AccessGranted; // Access granted to client.
    union {              // Object specific data

        struct {
            LPWSTR DatabaseName;            // Name of database opened
        } ScManagerObject;

        struct {
            LPSERVICE_RECORD ServiceRecord; // Pointer to service record
        } ScServiceObject;

    } Type;

} SC_HANDLE_STRUCT, *LPSC_HANDLE_STRUCT;


//
// FUNCTION PROTOTYPES
//

DWORD
ScCreateServiceHandle(
    IN  LPSERVICE_RECORD ServiceRecord,
    OUT LPSC_HANDLE_STRUCT *ContextHandle
    );

BOOL
ScIsValidScManagerHandle(
    IN  SC_RPC_HANDLE   hScManager
    );

BOOL
ScIsValidServiceHandle(
    IN  SC_RPC_HANDLE   hService
    );


typedef enum
{
    SC_HANDLE_TYPE_MANAGER = 0,
    SC_HANDLE_TYPE_SERVICE
}
SC_HANDLE_TYPE, *PSC_HANDLE_TYPE;

BOOL
ScIsValidScManagerOrServiceHandle(
    IN  SC_RPC_HANDLE    ContextHandle,
    OUT PSC_HANDLE_TYPE  phType
    );

#endif // SCOPEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scsec.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    scsec.h

Abstract:

    Security related function prototypes.

Author:

    Rita Wong (ritaw)     10-Mar-1992

Revision History:

--*/

#ifndef _SCSEC_INCLUDED_
#define _SCSEC_INCLUDED_

#include <scseclib.h>

DWORD
ScCreateScManagerObject(
    VOID
    );

DWORD
ScCreateScServiceObject(
    OUT PSECURITY_DESCRIPTOR *ServiceSd
    );

DWORD
ScGrantAccess(
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     ACCESS_MASK DesiredAccess
    );

NTSTATUS
ScPrivilegeCheckAndAudit(
    IN ULONG PrivilegeId,
    IN PVOID ObjectHandle,
    IN ACCESS_MASK DesiredAccess
    );

DWORD
ScAccessValidate(
    IN OUT LPSC_HANDLE_STRUCT ScObject,
    IN     ACCESS_MASK DesiredAccess
    );

DWORD
ScAccessCheckAndAudit(
    IN     LPWSTR SubsystemName,
    IN     LPWSTR ObjectTypeName,
    IN     LPWSTR ObjectName,
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN     ACCESS_MASK DesiredAccess,
    IN     PGENERIC_MAPPING GenericMapping
    );

DWORD
ScStatusAccessCheck(
    IN     LPSERVICE_RECORD   lpService
    );

DWORD
ScGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );

DWORD
ScReleasePrivilege(
    VOID
    );

DWORD
ScGetClientSid(
    OUT PTOKEN_USER *UserInfo
    );

#define SC_MANAGER_SUBSYSTEM_NAME       L"SERVICE CONTROL MANAGER"
#define SC_MANAGER_AUDIT_NAME           L"SC Manager"

#define SC_MANAGER_OBJECT_TYPE_NAME     L"SC_MANAGER OBJECT"
#define SC_SERVICE_OBJECT_TYPE_NAME     L"SERVICE OBJECT"


#endif // _SCSEC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scopen.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    scopen.cxx

Abstract:

    Functions for handling opening and closing of Service and
    ServiceController handles.

        ROpenSCManagerW
        ROpenServiceW
        RCloseServiceHandle
        SC_RPC_HANDLE_rundown
        ScCreateScManagerHandle
        ScCreateServiceHandle
        ScIsValidScManagerHandle
        ScIsValidServiceHandle
        ScIsValidScManagerOrServiceHandle

Author:

    Dan Lafferty (danl) 20-Jan-1992

Environment:

    User Mode - Win32

Revision History:

    20-Jan-1992 danl
        Created
    10-Apr-1992 JohnRo
        Added ScIsValidServiceHandle().
        Export ScCreateServiceHandle() for RCreateService() too.
    14-Apr-1992 JohnRo
        Added ScIsValidScManagerHandle().
    22-Feb-1995 AnirudhS
        RCloseServiceHandle: Pass the handle, rather than the address of the
        handle, to the auditing routine.

--*/

#include "precomp.hxx"
#include <stdlib.h>      // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include "scsec.h"      // ScAccessValidate
#include "sclib.h"      // ScIsValidServiceName


//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
ScCreateScManagerHandle(
    IN  LPWSTR DatabaseName,
    OUT LPSC_HANDLE_STRUCT *ContextHandle
    );

//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
ROpenSCManagerW(
    IN  LPWSTR          lpMachineName,
    IN  LPWSTR          lpDatabaseName,
    IN  DWORD           dwDesiredAccess OPTIONAL,
    OUT LPSC_RPC_HANDLE lpScHandle
    )
/*++

Routine Description:


Arguments:

    lpMachineName -

    lpDatabaseName -

    dwDesiredAccess -

    lpScHandle -

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_NAME - lpDatabaseName is invalid

    ERROR_DATABASE_DOES_NOT_EXIST - Valid database name but database
        does not exist.

    ERROR_ACCESS_DENIED - dwDesiredAccess specifies accesses that are
        not granted to the client, or contains invalid bits.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocated memory for context
        handle.

--*/
{
    LPSC_HANDLE_STRUCT scManagerHandle;
    DWORD error;
    LPWSTR RequestedDatabase = SERVICES_ACTIVE_DATABASEW;


    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // This parameter got us to the server side and is uninteresting
    // once we get here.
    //
    UNREFERENCED_PARAMETER(lpMachineName);

    //
    // Validate specified database name
    //
    if (ARGUMENT_PRESENT(lpDatabaseName)) {
        if ((_wcsicmp(lpDatabaseName, SERVICES_ACTIVE_DATABASEW) != 0) &&
            (_wcsicmp(lpDatabaseName, SERVICES_FAILED_DATABASEW) != 0)) {

            return ERROR_INVALID_NAME;

        }
        else if ((_wcsicmp(lpDatabaseName, SERVICES_FAILED_DATABASEW) == 0)
                   &&
                 (TRUE))
        {
            //
            // CODEWORK:  Actually implement a ServicesFailed database
            //            at some point in the future and check for it
            //            in place of the (TRUE) above.
            //

            //
            // ServicesFailed database does not exist
            //
            return ERROR_DATABASE_DOES_NOT_EXIST;

        }
        else {
            RequestedDatabase = lpDatabaseName;
        }
    }

    //
    // Allocate context handle structure and save the database name in it
    //
    if ((error = ScCreateScManagerHandle(
                     RequestedDatabase,
                     &scManagerHandle
                     )) != NO_ERROR) {
        return error;
    }

    //
    // Make sure the desired access specified is valid and allowed to
    // the client.  Save away the desired access in the handle structure.
    //
    if ((error = ScAccessValidate(
                     scManagerHandle,
                     (dwDesiredAccess | SC_MANAGER_CONNECT)
                     )) != NO_ERROR) {

        SC_LOG(ERROR,"ROpenSCManagerW:ScAccessValidate Failed %u\n",
               error);
        (void) LocalFree(scManagerHandle);
        return error;
    }

    //
    // return the pointer to the handle struct as the context handle for
    // this open.
    //
    *lpScHandle = (SC_RPC_HANDLE)scManagerHandle;

    SC_LOG(HANDLE,"SC Manager Handle Opened 0x%08lx\n",*lpScHandle);

    return(NO_ERROR);
}


DWORD
ROpenServiceW(
    IN  SC_RPC_HANDLE   hSCManager,
    IN  LPWSTR          lpServiceName,
    IN  DWORD           dwDesiredAccess,
    OUT LPSC_RPC_HANDLE phService
    )

/*++

Routine Description:

    Returns a handle to the service.  This handle is actually a pointer
    to a data structure that contains a pointer to the service record.

Arguments:

    hSCManager - This is a handle to this service controller.  It is an
        RPC context handle, and has allowed the request to get this far.

    lpServiceName - This is a pointer to a string containing the name of
        the service

    dwDesiredAccess - This is an access mask that contains a description
        of the access that is desired for this service.

    phService - This is a pointer to the location where the handle to the
        service is to be placed.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified ScManager handle is invalid.

    ERROR_SERVICE_DOES_NOT_EXIST - The specified service does not exist
        in the database.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation for the handle structure
        failed.

    ERROR_INVALID_NAME - Service name contains invalid character or
        name is too long.
Note:


--*/
{

    LPSC_HANDLE_STRUCT serviceHandle;
    DWORD              status;
    LPSERVICE_RECORD   serviceRecord;


    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //

    if (!ScIsValidScManagerHandle(hSCManager))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Validate the format of the service name.
    //
    if (! ScIsValidServiceName(lpServiceName)) {
        return(ERROR_INVALID_NAME);
    }

    //
    // Find the service record in the database.
    //

    CServiceListSharedLock LLock;
    CServiceRecordExclusiveLock RLock;

    status = ScGetNamedServiceRecord(
                lpServiceName,
                &serviceRecord);

    if (status != NO_ERROR) {
        return(status);
    }

    //
    // Allocate context handle structure and save the service record
    // pointer in it.
    //
    if ((status = ScCreateServiceHandle(
                      serviceRecord,
                      &serviceHandle
                      )) != NO_ERROR) {

        return(status);
    }

    //
    // Make sure the desired access specified is valid and allowed to
    // the client.  Save away the desired access in the handle structure.
    //
    if ((status = ScAccessValidate(
                      serviceHandle,
                      dwDesiredAccess
                      )) != NO_ERROR) {

        SC_LOG(ERROR,"ROpenServiceW:ScAccessValidate Failed %u\n",
               status);
        (void) LocalFree(serviceHandle);
        return(status);
    }

    //
    // Additional check is required if the SCManager points to a database
    // other than the active one.  Execute accesses are not allowed.
    //
    if (_wcsicmp(
            ((LPSC_HANDLE_STRUCT)hSCManager)->Type.ScManagerObject.DatabaseName,
            SERVICES_ACTIVE_DATABASEW
            ) != 0) {

        if (dwDesiredAccess & MAXIMUM_ALLOWED) {

            //
            // MAXIMUM_ALLOWED is requested.  Remove bits for execute accesses.
            //
            serviceHandle->AccessGranted &= ~(SERVICE_STOP           |
                                              SERVICE_START          |
                                              SERVICE_PAUSE_CONTINUE |
                                              SERVICE_INTERROGATE    |
                                              SERVICE_USER_DEFINED_CONTROL);

        }
        else if ((serviceHandle->AccessGranted &
                  (SERVICE_STOP           |
                   SERVICE_START          |
                   SERVICE_PAUSE_CONTINUE |
                   SERVICE_INTERROGATE    |
                   SERVICE_USER_DEFINED_CONTROL)) != 0) {

            //
            // Deny access if any execute access is requested.
            //
            SC_LOG(
                SECURITY,
                "ROpenServiceW:Non-active database, execute accesses not allowed\n",
                0
                );
            (void) LocalFree(serviceHandle);
            return(ERROR_ACCESS_DENIED);
        }
    }

    //
    // Increment the UseCount.  The service record cannot be deleted
    // as long as the UseCount is greater than zero.
    //
    serviceRecord->UseCount++;

    SC_LOG2(USECOUNT, "ROpenServiceW: " FORMAT_LPWSTR
        " increment USECOUNT=%lu\n", serviceRecord->ServiceName, serviceRecord->UseCount);

    //
    // return the pointer to the handle struct as the handle for this
    // open.
    //
    *phService = (SC_RPC_HANDLE)serviceHandle;

    SC_LOG(HANDLE,"Service Handle Opened 0x%lx\n",*phService);

    return (NO_ERROR);
}


DWORD
RCloseServiceHandle(
    IN OUT SC_RPC_HANDLE    *phSCObject
    )

/*++

Routine Description:

    This function closes a handle to a service or to the service controller
    by freeing the data structure that the handle points to.

Arguments:

    phSCObject - This is a pointer to a pointer to the context handle
        structure.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The handle is invalid.  It does not point to
        a recognizable structure.

Note:


--*/
{
    NTSTATUS            status;
    HLOCAL              FreeStatus;
    UNICODE_STRING      Subsystem;
    ULONG               privileges[1];
    SC_HANDLE_TYPE      HandleType;

    //
    // Check the handle
    //

    if (!ScIsValidScManagerOrServiceHandle(*phSCObject, &HandleType))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // If it is a service handle being closed, decrement the use count.
    // If the count goes to zero, and the service is marked for deletion,
    // it will get deleted.
    //
    if (HandleType == SC_HANDLE_TYPE_SERVICE)
    {
        {
            CServiceRecordExclusiveLock RLock;

            ScDecrementUseCountAndDelete(
                ((LPSC_HANDLE_STRUCT)*phSCObject)->Type.ScServiceObject.ServiceRecord);
        }

        //
        // Get Audit Privilege
        //
        privileges[0] = SE_AUDIT_PRIVILEGE;
        status = ScGetPrivilege( 1, privileges);

        if (!NT_SUCCESS(status)) {
            SC_LOG1(ERROR, "RCloseServiceHandle: ScGetPrivilege (Enable) "
                           "failed: %#lx\n", status);
        }

        //
        // Generate the Audit.
        //
        RtlInitUnicodeString(&Subsystem, SC_MANAGER_AUDIT_NAME);
        status = NtCloseObjectAuditAlarm(
                    &Subsystem,
                    *phSCObject,
                    (BOOLEAN)((((LPSC_HANDLE_STRUCT)*phSCObject)->Flags
                        & SC_HANDLE_GENERATE_ON_CLOSE) != 0));
        if (!NT_SUCCESS(status)) {
            SC_LOG1(ERROR, "RCloseServiceHandle: NtCloseObjectAuditAlarm "
                           "failed: %#lx\n",status);
        }

        ScReleasePrivilege();
    }

    //
    // Attempt to free the memory that the handle points to.
    //

    FreeStatus = LocalFree(*phSCObject);

    if (FreeStatus != NULL)
    {
        //
        // For some reason, the handle couldn't be freed.  Therefore, the
        // best we can do to disable it is to remove the signature.
        //

        SC_LOG(ERROR,"RCloseServiceHandle:LocalFree Failed %d\n",GetLastError());
        ((LPSC_HANDLE_STRUCT)*phSCObject)->Signature = 0;
    }

    //
    // Tell RPC we are done with the context handle.
    //

    SC_LOG(HANDLE,"Handle Closed 0x%08lx\n",*phSCObject);

    *phSCObject = NULL;

    return(NO_ERROR);
}


VOID
SC_RPC_HANDLE_rundown(
    SC_RPC_HANDLE     scHandle
    )

/*++

Routine Description:

    This function is called by RPC when a connection is broken that had
    an outstanding context handle.  The value of the context handle is
    passed in here so that we have an opportunity to clean up.

Arguments:

    scHandle - This is the handle value of the context handle that is broken.

Return Value:

    none.

--*/
{
    //
    // Close the handle.
    //

    RCloseServiceHandle(&scHandle);

}


DWORD
ScCreateScManagerHandle(
    IN  LPWSTR DatabaseName,
    OUT LPSC_HANDLE_STRUCT *ContextHandle
    )
/*++

Routine Description:

    This function allocates the memory for an SC Manager context handle
    structure, and initializes it.

Arguments:

    DatabaseName - Supplies the name of the SC Manager database which the
        returned structure is a context of.

    ContextHandle - Returns a pointer to the context handle structure
        created.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Memory allocation for the context handle
        structure failed.

Note:
    The memory allocated by this routine should be freed with LocalFree.

--*/
{
    //
    // Allocate memory for the context handle structure, and database name.
    //
    *ContextHandle = (LPSC_HANDLE_STRUCT)LocalAlloc(
                         LMEM_ZEROINIT,
                         sizeof(SC_HANDLE_STRUCT) + WCSSIZE(DatabaseName));

    if (*ContextHandle == NULL) {
        SC_LOG(ERROR,"ScCreateScManagerHandle:LocalAlloc Failed %d\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure, except for the
    // granted access which is figured out when the desired access is validated
    // later.
    //
    (*ContextHandle)->Signature = SC_SIGNATURE;
    (*ContextHandle)->Flags = 0;

    (*ContextHandle)->Type.ScManagerObject.DatabaseName =
        (LPWSTR) ((DWORD_PTR) *ContextHandle + sizeof(SC_HANDLE_STRUCT));
    wcscpy((*ContextHandle)->Type.ScManagerObject.DatabaseName, DatabaseName);

    return NO_ERROR;
}


BOOL
ScIsValidScManagerHandle(
    IN  SC_RPC_HANDLE   hScManager
    )
{
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hScManager;

    if (serviceHandleStruct == NULL) {
        return (FALSE);   // Not valid.
    }

    if (serviceHandleStruct->Signature != SC_SIGNATURE) {
        return (FALSE);   // Not valid.
    }

    return (TRUE);

} // ScIsValidScManagerHandle


DWORD
ScCreateServiceHandle(
    IN  LPSERVICE_RECORD ServiceRecord,
    OUT LPSC_HANDLE_STRUCT *ContextHandle
    )
/*++

Routine Description:

    This function allocates the memory for a service context handle
    structure, and initializes it.

Arguments:

    ServiceRecord - Supplies a pointer to the service record which the
        returned structure is a context of.

    ContextHandle - Returns a pointer to the context handle structure
        created.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Memory allocation for the context handle
        structure failed.

Note:
    The memory allocated by this routine should be freed with LocalFree.

--*/
{
    //
    // Allocate memory for the context handle structure.
    //
    *ContextHandle = (LPSC_HANDLE_STRUCT)LocalAlloc(
                         LMEM_ZEROINIT,
                         sizeof(SC_HANDLE_STRUCT)
                         );

    if (*ContextHandle == NULL) {
        SC_LOG(ERROR,"ScCreateServiceHandle:LocalAlloc Failed %d\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure, except for the
    // granted access which is figured out when the desired access is validated
    // later.
    //
    (*ContextHandle)->Signature = SERVICE_SIGNATURE;
    (*ContextHandle)->Flags = 0;
    (*ContextHandle)->Type.ScServiceObject.ServiceRecord = ServiceRecord;

    SC_ASSERT( ScIsValidServiceHandle( *ContextHandle ) );

    return NO_ERROR;
}


BOOL
ScIsValidServiceHandle(
    IN  SC_RPC_HANDLE   hService
    )
{
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hService;

    if (serviceHandleStruct == NULL) {
        return (FALSE);   // Not valid.
    }

    if (serviceHandleStruct->Signature != SERVICE_SIGNATURE) {
        return (FALSE);   // Not valid.
    }

    return (TRUE);

} // ScIsValidServiceHandle


BOOL
ScIsValidScManagerOrServiceHandle(
    IN  SC_RPC_HANDLE   ContextHandle,
    OUT PSC_HANDLE_TYPE phType
    )
/*++

Routine Description:

    Function to check a handle that may be either a service handle or
    an SC Manager handle without having to check vs. NULL twice by
    calling both ScIsValidScManagerHandle and ScIsValidServiceHandle

Arguments:

    ContextHandle -- The handle to check
    phType        -- The type of the handle (SCManager vs. Service) if valid

Return Value:

    TRUE  -- The handle is valid
    FALSE -- The handle is not valid

--*/
{
    LPSC_HANDLE_STRUCT  pHandle = (LPSC_HANDLE_STRUCT) ContextHandle;

    SC_ASSERT(phType != NULL);

    if (pHandle == NULL)
    {
        return FALSE;   // Not valid.
    }

    if (pHandle->Signature == SERVICE_SIGNATURE)
    {
        *phType = SC_HANDLE_TYPE_SERVICE;
        return TRUE;
    }
    else if (pHandle->Signature == SC_SIGNATURE)
    {
        *phType = SC_HANDLE_TYPE_MANAGER;
        return TRUE;
    }

    return FALSE;

} // ScIsValidScManagerOrServiceHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\scsec.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    scsec.cxx

Abstract:

    This module contains security related routines:
        RQueryServiceObjectSecurity
        RSetServiceObjectSecurity
        ScCreateScManagerObject
        ScCreateScServiceObject
        ScGrantAccess
        ScPrivilegeCheckAndAudit
        ScAccessValidate
        ScAccessCheckAndAudit
        ScGetPrivilege
        ScReleasePrivilege

Author:

    Rita Wong (ritaw)     10-Mar-1992

Environment:

    Calls NT native APIs.

Revision History:

    10-Mar-1992     ritaw
        created
    16-Apr-1992     JohnRo
        Process services which are marked for delete accordingly.
    06-Aug-1992     Danl
        Fixed a debug print statement.  It indicated it was from the
        ScLoadDeviceDriver function - rather than in ScGetPrivilege.
    21-Jan-1995     AnirudhS
        Added ScGrantAccess and ScPrivilegeCheckAndAudit.
--*/

#include "precomp.hxx"
#include "scconfig.h"   // ScOpenServiceConfigKey
#include "scsec.h"      // Object names and security functions
#include "control.h"    // SERVICE_SET_STATUS
#include "account.h"    // ScLookupServiceAccount
#include "align.h"      // ROUND_UP_COUNT


#define PRIVILEGE_BUF_SIZE  512


//-------------------------------------------------------------------//
//                                                                   //
// Static global variables                                           //
//                                                                   //
//-------------------------------------------------------------------//

//
// Security descriptor of the SCManager objects to control user accesses
// to the Service Control Manager and its database.
//
PSECURITY_DESCRIPTOR ScManagerSd;

//
// Structure that describes the mapping of Generic access rights to
// object specific access rights for the ScManager object.
//
GENERIC_MAPPING ScManagerObjectMapping = {

    STANDARD_RIGHTS_READ             |     // Generic read
        SC_MANAGER_ENUMERATE_SERVICE |
        SC_MANAGER_QUERY_LOCK_STATUS,

    STANDARD_RIGHTS_WRITE         |        // Generic write
        SC_MANAGER_CREATE_SERVICE |
        SC_MANAGER_MODIFY_BOOT_CONFIG,

    STANDARD_RIGHTS_EXECUTE |              // Generic execute
        SC_MANAGER_CONNECT  |
        SC_MANAGER_LOCK,

    SC_MANAGER_ALL_ACCESS                  // Generic all
    };

//
// Structure that describes the mapping of generic access rights to
// object specific access rights for the Service object.
//
GENERIC_MAPPING ScServiceObjectMapping = {

    STANDARD_RIGHTS_READ             |     // Generic read
        SERVICE_QUERY_CONFIG         |
        SERVICE_QUERY_STATUS         |
        SERVICE_ENUMERATE_DEPENDENTS |
        SERVICE_INTERROGATE,

    STANDARD_RIGHTS_WRITE     |            // Generic write
        SERVICE_CHANGE_CONFIG,

    STANDARD_RIGHTS_EXECUTE    |           // Generic execute
        SERVICE_START          |
        SERVICE_STOP           |
        SERVICE_PAUSE_CONTINUE |
        SERVICE_USER_DEFINED_CONTROL,

    SERVICE_ALL_ACCESS                     // Generic all
    };


//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
RQueryServiceObjectSecurity(
    IN  SC_RPC_HANDLE hService,
    IN  SECURITY_INFORMATION dwSecurityInformation,
    OUT LPBYTE lpSecurityDescriptor,
    IN  DWORD cbBufSize,
    OUT LPDWORD pcbBytesNeeded
    )
/*++

Routine Description:

    This is the worker function for QueryServiceObjectSecurity API.
    It returns the security descriptor information of a service
    object.

Arguments:

    hService - Supplies the context handle to an existing service object.

    dwSecurityInformation - Supplies the bitwise flags describing the
        security information being queried.

    lpSecurityInformation - Supplies the output buffer from the user
        which security descriptor information will be written to on
        return.

    cbBufSize - Supplies the size of lpSecurityInformation buffer.

    pcbBytesNeeded - Returns the number of bytes needed of the
        lpSecurityInformation buffer to get all the requested
        information.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened for
        either READ_CONTROL or ACCESS_SYSTEM_SECURITY
        access.

    ERROR_INVALID_PARAMETER - The dwSecurityInformation parameter is
        invalid.

    ERROR_INSUFFICIENT_BUFFER - The specified output buffer is smaller
        than the required size returned in pcbBytesNeeded.  None of
        the security descriptor is returned.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpSecurityDescriptor, and pcbBytesNeeded.

--*/
{
    NTSTATUS ntstatus;
    ACCESS_MASK DesiredAccess = 0;
    PSECURITY_DESCRIPTOR ServiceSd;
    DWORD ServiceSdSize = 0;


    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Check the validity of dwSecurityInformation
    //
    if ((dwSecurityInformation == 0) ||
        ((dwSecurityInformation &
          (OWNER_SECURITY_INFORMATION |
           GROUP_SECURITY_INFORMATION |
           DACL_SECURITY_INFORMATION  |
           SACL_SECURITY_INFORMATION)) != dwSecurityInformation))
    {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set the desired access based on the requested SecurityInformation
    //
    if (dwSecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    if (dwSecurityInformation & (DACL_SECURITY_INFORMATION  |
                                 OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION)) {
        DesiredAccess |= READ_CONTROL;
    }

    //
    // Was the handle opened for the requested access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              DesiredAccess
              )) {
        return ERROR_ACCESS_DENIED;
    }

    //
    //
    RtlZeroMemory(lpSecurityDescriptor, cbBufSize);

    //
    // Get the database lock for reading
    //
    CServiceRecordSharedLock RLock;

    //
    // The most up-to-date service security descriptor is always kept in
    // the service record.
    //
    ServiceSd =
        ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord->ServiceSd;


    //
    // Retrieve the appropriate security information from ServiceSd
    // and place it in the user supplied buffer.
    //
    ntstatus = RtlQuerySecurityObject(
                   ServiceSd,
                   dwSecurityInformation,
                   (PSECURITY_DESCRIPTOR) lpSecurityDescriptor,
                   cbBufSize,
                   &ServiceSdSize
                   );

    if (! NT_SUCCESS(ntstatus)) {

        if (ntstatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

            //
            // Internal error: our security descriptor is bad!
            //
            SC_LOG0(ERROR,
                "RQueryServiceObjectSecurity: Our security descriptor is bad!\n");
            ASSERT(FALSE);
            return ERROR_GEN_FAILURE;

        }
        else if (ntstatus == STATUS_BUFFER_TOO_SMALL) {

            //
            // Return the required size to the user
            //
            *pcbBytesNeeded = ServiceSdSize;
            return ERROR_INSUFFICIENT_BUFFER;

        }
        else {
            return RtlNtStatusToDosError(ntstatus);
        }
    }

    //
    // Return the required size to the user
    //
    *pcbBytesNeeded = ServiceSdSize;

    return NO_ERROR;
}


DWORD
RSetServiceObjectSecurity(
    IN  SC_RPC_HANDLE hService,
    IN  SECURITY_INFORMATION dwSecurityInformation,
    IN  LPBYTE lpSecurityDescriptor,
    IN  DWORD cbBufSize
    )
/*++

Routine Description:

    This is the worker function for SetServiceObjectSecurity API.
    It modifies the security descriptor information of a service
    object.

Arguments:

    hService - Supplies the context handle to the service.

    dwSecurityInformation - Supplies the bitwise flags of security
        information being queried.

    lpSecurityInformation - Supplies a buffer which contains a
        well-formed self-relative security descriptor.

    cbBufSize - Supplies the size of lpSecurityInformation buffer.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened for
        either WRITE_OWNER, WRITE_DAC, or ACCESS_SYSTEM_SECURITY
        access.

    ERROR_INVALID_PARAMETER - The lpSecurityDescriptor or dwSecurityInformation
        parameter is invalid.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpSecurityDescriptor.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    RPC_STATUS rpcstatus;
    ACCESS_MASK DesiredAccess = 0;
    LPSERVICE_RECORD serviceRecord;
    HANDLE ClientTokenHandle = NULL;
    LPBYTE lpTempSD = lpSecurityDescriptor;


    UNREFERENCED_PARAMETER(cbBufSize);  // for RPC marshalling code

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Silently ignore flags we don't understand that may come
    // from higher-level object managers.
    //
    dwSecurityInformation &= (OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION  |
                                SACL_SECURITY_INFORMATION);

    if (dwSecurityInformation == 0)
    {
        return NO_ERROR;
    }


#ifdef _WIN64

    if (PtrToUlong(lpSecurityDescriptor) & (sizeof(PVOID) - 1))
    {
        //
        // SD isn't properly aligned.  Alloc an aligned heap buffer
        // and copy it in to fix things up.
        //

        lpTempSD = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBufSize);

        if (lpTempSD == NULL)
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }

        RtlCopyMemory(lpTempSD, lpSecurityDescriptor, cbBufSize);
    }

#endif // _WIN64
    

    //
    // Check the validity of lpSecurityInformation
    //
    if (! RtlValidRelativeSecurityDescriptor(
              (PSECURITY_DESCRIPTOR) lpTempSD,
              cbBufSize,
              dwSecurityInformation
              ))
    {
        status = ERROR_INVALID_PARAMETER;
        goto CleanExit;
    }

    //
    // Set the desired access based on the specified SecurityInformation
    //
    if (dwSecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    if (dwSecurityInformation & (OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION)) {
        DesiredAccess |= WRITE_OWNER;
    }

    if (dwSecurityInformation & DACL_SECURITY_INFORMATION) {
        DesiredAccess |= WRITE_DAC;
    }

    //
    // Make sure the specified fields are present in the provided
    // security descriptor.
    // Security descriptors must have owner and group fields.
    //
    if (dwSecurityInformation & OWNER_SECURITY_INFORMATION)
    {
        if (((PISECURITY_DESCRIPTOR_RELATIVE) lpTempSD)->Owner == 0)
        {
            status = ERROR_INVALID_PARAMETER;
            goto CleanExit;
        }
    }

    if (dwSecurityInformation & GROUP_SECURITY_INFORMATION)
    {
        if (((PISECURITY_DESCRIPTOR_RELATIVE) lpTempSD)->Group == 0)
        {
            status = ERROR_INVALID_PARAMETER;
            goto CleanExit;
        }
    }

    //
    // Was the handle opened for the requested access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              DesiredAccess
              ))
    {
        status = ERROR_ACCESS_DENIED;
        goto CleanExit;
    }

    //
    // Is this service marked for delete?
    //
    serviceRecord =
        ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    SC_ASSERT( serviceRecord != NULL );

    if (DELETE_FLAG_IS_SET(serviceRecord))
    {
        status = ERROR_SERVICE_MARKED_FOR_DELETE;
        goto CleanExit;
    }

    //
    // If caller wants to replace the owner, get a handle to the impersonation
    // token.
    //
    if (dwSecurityInformation & OWNER_SECURITY_INFORMATION)
    {
        if ((rpcstatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
        {
            SC_LOG1(
                ERROR,
                "RSetServiceObjectSecurity: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
                rpcstatus
                );

            ScLogEvent(
                NEVENT_CALL_TO_FUNCTION_FAILED,
                SC_RPC_IMPERSONATE,
                rpcstatus
                );

            status = rpcstatus;
            goto CleanExit;
        }

        ntstatus = NtOpenThreadToken(
                       NtCurrentThread(),
                       TOKEN_QUERY,
                       TRUE,              // OpenAsSelf
                       &ClientTokenHandle
                       );

        //
        // Stop impersonating the client
        //
        if ((rpcstatus = RpcRevertToSelf()) != RPC_S_OK) {
            SC_LOG1(
               ERROR,
               "RSetServiceObjectSecurity: Failed to revert to self " FORMAT_RPC_STATUS "\n",
               rpcstatus
               );

            ScLogEvent(
                NEVENT_CALL_TO_FUNCTION_FAILED,
                SC_RPC_REVERT,
                rpcstatus
                );

            ASSERT(FALSE);
            status = rpcstatus;
            goto CleanExit;
        }

        if (! NT_SUCCESS(ntstatus))
        {
            SC_LOG(ERROR,
                   "RSetServiceObjectSecurity: NtOpenThreadToken failed %08lx\n",
                   ntstatus);

            status = RtlNtStatusToDosError(ntstatus);
            goto CleanExit;
        }
    }

    {
        CServiceRecordExclusiveLock RLock;

        //
        // Replace the service security descriptor with the appropriate
        // security information specified in the caller supplied security
        // descriptor.  This routine may reallocate the memory needed to
        // contain the new service security descriptor.
        //
        ntstatus = RtlSetSecurityObject(
                       dwSecurityInformation,
                       (PSECURITY_DESCRIPTOR) lpTempSD,
                       &serviceRecord->ServiceSd,
                       &ScServiceObjectMapping,
                       ClientTokenHandle
                       );

        status = RtlNtStatusToDosError(ntstatus);

        if (! NT_SUCCESS(ntstatus))
        {
            SC_LOG1(ERROR,
                    "RSetServiceObjectSecurity: RtlSetSecurityObject failed %08lx\n",
                    ntstatus);
        }
        else
        {
            HKEY ServiceKey;

            //
            // Write new security descriptor to the registry
            //
            status = ScOpenServiceConfigKey(
                         serviceRecord->ServiceName,
                         KEY_WRITE,
                         FALSE,
                         &ServiceKey
                         );

            if (status == NO_ERROR)
            {
                status = ScWriteSd(
                             ServiceKey,
                             serviceRecord->ServiceSd
                             );

                if (status != NO_ERROR)
                {
                    SC_LOG1(ERROR,
                            "RSetServiceObjectSecurity: ScWriteSd failed %lu\n",
                            status);
                }

                ScRegFlushKey(ServiceKey);
                ScRegCloseKey(ServiceKey);
            }
        }
    }

CleanExit:

#ifdef _WIN64

    if (lpTempSD != lpSecurityDescriptor)
    {
        LocalFree(lpTempSD);
    }

#endif // _WIN64

    if (ClientTokenHandle != NULL)
    {
        NtClose(ClientTokenHandle);
    }

    return status;
}


DWORD
ScCreateScManagerObject(
    VOID
    )
/*++

Routine Description:

    This function creates the security descriptor which represents
    the ScManager object for both the "ServiceActive" and
    "ServicesFailed" databases.

Arguments:

    None.

Return Value:

    Returns values from calls to:
        ScCreateUserSecurityObject

--*/
{
    NTSTATUS ntstatus;
    ULONG Privilege = SE_SECURITY_PRIVILEGE;

    //
    // World has SC_MANAGER_CONNECT access and GENERIC_READ access.
    // Local admins are allowed GENERIC_ALL access.
    //
#define SC_MANAGER_OBJECT_ACES  5             // Number of ACEs in this DACL

    SC_ACE_DATA AceData[SC_MANAGER_OBJECT_ACES] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SC_MANAGER_CONNECT |
               GENERIC_READ,                  &AuthenticatedUserSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SC_MANAGER_CONNECT |
               GENERIC_READ |
               SC_MANAGER_MODIFY_BOOT_CONFIG, &LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,                   &AliasAdminsSid},

        {SYSTEM_AUDIT_ACE_TYPE, 0, FAILED_ACCESS_ACE_FLAG,
               GENERIC_ALL,                  &WorldSid},

        {SYSTEM_AUDIT_ACE_TYPE, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,
               FAILED_ACCESS_ACE_FLAG,
               GENERIC_ALL,                  &WorldSid}
        };


    //
    // You need to have SE_SECURITY_PRIVILEGE privilege to create the SD with a
    // SACL
    //

    ntstatus = ScGetPrivilege(1, &Privilege);
    if (ntstatus != NO_ERROR) {
        SC_LOG1(ERROR, "ScCreateScManagerObject: ScGetPrivilege Failed %d\n",
            ntstatus);
        RevertToSelf();
        return(ntstatus);
    }

    ntstatus = ScCreateUserSecurityObject(
                   NULL,                        // Parent SD
                   AceData,
                   SC_MANAGER_OBJECT_ACES,
                   LocalSystemSid,
                   LocalSystemSid,
                   TRUE,                        // IsDirectoryObject
                   TRUE,                        // UseImpersonationToken
                   &ScManagerObjectMapping,
                   &ScManagerSd
                   );

#undef SC_MANAGER_OBJECT_ACES

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG(
            ERROR,
            "ScCreateScManagerObject: ScCreateUserSecurityObject failed " FORMAT_NTSTATUS "\n",
            ntstatus
            );
    }

    ScReleasePrivilege();

    return RtlNtStatusToDosError(ntstatus);
}


DWORD
ScCreateScServiceObject(
    OUT PSECURITY_DESCRIPTOR *ServiceSd
    )
/*++

Routine Description:

    This function creates the security descriptor which represents
    the Service object.

Arguments:

    ServiceSd - Returns service object security descriptor.

Return Value:

    Returns values from calls to:
        ScCreateUserSecurityObject

--*/
{
    NTSTATUS ntstatus;

    //
    // Authenticated users have read access.
    // Local system has service start/stop and all read access.
    // Power user has service start and all read access (Workstation and Server).
    // Admin and SystemOp (DC) are allowed all access.
    //

#define SC_SERVICE_OBJECT_ACES    4             // Number of ACEs in this DACL

    SC_ACE_DATA AceData[SC_SERVICE_OBJECT_ACES] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_READ | GENERIC_EXECUTE,
               &LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,
               &AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_READ | SERVICE_USER_DEFINED_CONTROL,
               &AuthenticatedUserSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               0,
               0}
        };

    switch(USER_SHARED_DATA->NtProductType)
    {
        case NtProductWinNt:
        case NtProductServer:

            //
            // Power users are only on Workstation and Server
            //
            AceData[SC_SERVICE_OBJECT_ACES - 1].Mask = GENERIC_READ | GENERIC_EXECUTE;
            AceData[SC_SERVICE_OBJECT_ACES - 1].Sid  = &AliasPowerUsersSid;
            break;

        case NtProductLanManNt:

            //
            // System Ops (Server Operators) are only on a DC
            //
            AceData[SC_SERVICE_OBJECT_ACES - 1].Mask = GENERIC_ALL;
            AceData[SC_SERVICE_OBJECT_ACES - 1].Sid  = &AliasSystemOpsSid;
            break;

        default:

            //
            // A new product type has been added -- add code to cover it
            //
            SC_ASSERT(FALSE);
            break;
    }

    ntstatus = ScCreateUserSecurityObject(
                   ScManagerSd,                // ParentSD
                   AceData,
                   SC_SERVICE_OBJECT_ACES,
                   LocalSystemSid,
                   LocalSystemSid,
                   FALSE,                       // IsDirectoryObject
                   FALSE,                       // UseImpersonationToken
                   &ScServiceObjectMapping,
                   ServiceSd
                   );

#undef SC_SERVICE_OBJECT_ACES

    return RtlNtStatusToDosError(ntstatus);
}


DWORD
ScGrantAccess(
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This function is called when a new service is created.  It validates
    the access desired by the caller for the new service handle and
    computes the granted access to be stored in the context handle
    structure.  Since this is object creation, all requested accesses,
    except for ACCESS_SYSTEM_SECURITY, are granted automatically.

Arguments:

    DesiredAccess - Supplies the client requested desired access.

    ContextHandle - On return, the granted access is written back to this
        location if this call succeeds.

Return Value:

    Returns values from calls to the following, mapped to Win32 error codes:
        ScPrivilegeCheckAndAudit

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ACCESS_MASK AccessToGrant = DesiredAccess;

    //
    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
    //

    if (AccessToGrant & MAXIMUM_ALLOWED) {

        AccessToGrant &= ~MAXIMUM_ALLOWED;
        AccessToGrant |= GENERIC_ALL;
    }

    //
    // If ACCESS_SYSTEM_SECURITY is requested, check that we have
    // SE_SECURITY_PRIVILEGE.
    //

    if (AccessToGrant & ACCESS_SYSTEM_SECURITY) {

        Status = ScPrivilegeCheckAndAudit(
                    SE_SECURITY_PRIVILEGE,  // check for this privilege
                    ContextHandle,          // client's handle to the object
                                            //  (used for auditing only)
                    DesiredAccess           // (used for auditing only)
                    );
    }

    if (NT_SUCCESS(Status)) {

        //
        // Map the generic bits to specific and standard bits.
        //

        RtlMapGenericMask(
            &AccessToGrant,
            &ScServiceObjectMapping
            );

        //
        // Return the computed access mask.
        //

        ContextHandle->AccessGranted = AccessToGrant;
    }

    return(RtlNtStatusToDosError(Status));
}


NTSTATUS
ScPrivilegeCheckAndAudit(
    IN ULONG PrivilegeId,
    IN PVOID ObjectHandle,
    IN ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This function is only called from ScGrantAccess.  It checks if the given
    well known privilege is enabled for an impersonated client.  It also
    generates an audit for the attempt to use the privilege.

Arguments:

    PrivilegeId -  Specifies the well known Privilege Id

    ObjectHandle - Client's handle to the object (used for auditing)

    DesiredAccess - Access that the client requested to the object (used
                    for auditing)

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and the client
            is either trusted or has the necessary privilege enabled.

        STATUS_PRIVILEGE_NOT_HELD - The client does not have the necessary
            privilege.
--*/
{
    NTSTATUS Status, SecondaryStatus;
    HANDLE ClientToken = NULL;

    //
    // Impersonate the client.
    //

    Status = I_RpcMapWin32Status(RpcImpersonateClient( NULL ));

    if (NT_SUCCESS(Status)) {

        //
        // Open the current thread's impersonation token (if any).
        //

        Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &ClientToken
                     );

        if (NT_SUCCESS(Status)) {

            PRIVILEGE_SET Privilege;
            BOOLEAN PrivilegeHeld = FALSE;
            UNICODE_STRING Subsystem;

            //
            // OK, we have a token open.  Now check for the specified privilege.
            // On return, PrivilegeHeld indicates whether the client has the
            // privilege, and whether we will allow the operation to succeed.
            //

            Privilege.PrivilegeCount = 1;
            Privilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
            Privilege.Privilege[0].Luid = RtlConvertLongToLuid(PrivilegeId);
            Privilege.Privilege[0].Attributes = 0;

            Status = NtPrivilegeCheck(
                         ClientToken,
                         &Privilege,
                         &PrivilegeHeld
                         );

            SC_ASSERT(NT_SUCCESS(Status));

            //
            // Audit the attempt to use the privilege.
            //

            RtlInitUnicodeString(&Subsystem, SC_MANAGER_AUDIT_NAME);

            Status = NtPrivilegeObjectAuditAlarm(
                            &Subsystem,     // Subsystem name
                            PrivilegeHeld ? ObjectHandle : NULL,
                                            // Object handle, to display in
                                            //  the audit log
                            ClientToken,    // Client's token
                            DesiredAccess,  // Access desired by client
                            &Privilege,     // Privileges attempted to use
                            PrivilegeHeld   // Whether access was granted
                            );

            SC_ASSERT(NT_SUCCESS(Status));

            if ( !PrivilegeHeld ) {

                Status = STATUS_PRIVILEGE_NOT_HELD;
            }


            //
            // Close the client token.
            //

            SecondaryStatus = NtClose( ClientToken );
            ASSERT(NT_SUCCESS(SecondaryStatus));
        }

        //
        // Stop impersonating the client.
        //

        SecondaryStatus = I_RpcMapWin32Status(RpcRevertToSelf());
    }

    return Status;
}


DWORD
ScAccessValidate(
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This function is called due to an open request.  It validates the
    desired access based on the object type specified in the context
    handle structure.  If the requested access is granted, it is
    written into the context handle structure.

Arguments:

    ContextHandle - Supplies a pointer to the context handle structure
        which contains information about the object.  On return, the
        granted access is written back to this structure if this
        call succeeds.

    DesiredAccess - Supplies the client requested desired access.


Return Value:

    ERROR_GEN_FAILURE - Object type is unrecognizable.  An internal
        error has occured.

    Returns values from calls to:
        ScAccessCheckAndAudit

Notes:

    The supplied ContextHandle must be verified to be valid (i.e., non-NULL)
    BEFORE calling this routine.

--*/
{

    ACCESS_MASK RequestedAccess = DesiredAccess;


    if (ContextHandle->Signature == SC_SIGNATURE) {

        //
        // Map the generic bits to specific and standard bits.
        //
        RtlMapGenericMask(&RequestedAccess, &ScManagerObjectMapping);

        //
        // Check to see if requested access is granted to client
        //
        return ScAccessCheckAndAudit(
                   (LPWSTR) SC_MANAGER_AUDIT_NAME,
                   (LPWSTR) SC_MANAGER_OBJECT_TYPE_NAME,
                   ContextHandle->Type.ScManagerObject.DatabaseName,
                   ContextHandle,
                   ScManagerSd,
                   RequestedAccess,
                   &ScManagerObjectMapping
                   );
    }
    else if (ContextHandle->Signature == SERVICE_SIGNATURE) {

        //
        // Special-case the status access check instead of adding the right
        // for the service to set its own status to the service's default SD
        // because of the following reasons:
        //
        //     1.  This check is tighter -- since an SC_HANDLE can be used
        //         remotely, this prevents SetServiceStatus from now being
        //         called remotely because the LUIDs won't match.
        //
        //     2.  Modifying the SD would require lots of extra work for SDs
        //         that are stored in the registry -- the SCM would have to
        //         detect that there's no SERVICE_SET_STATUS access ACL on
        //         the SD and add it (also in calls to SetServiceObjectSecurity).
        //
        // Note that if the user specifies extraneous access bits (i.e.,
        // SERVICE_SET_STATUS & <other bits>), it will be rejected by the
        // ScAccessCheckAndAudit call below.
        //
        if (DesiredAccess == SERVICE_SET_STATUS) {

            DWORD  dwError = ScStatusAccessCheck(ContextHandle->Type.ScServiceObject.ServiceRecord);

            if (dwError == NO_ERROR) {
                ContextHandle->AccessGranted = SERVICE_SET_STATUS;
            }

            return dwError;
        }

        //
        // Map the generic bits to specific and standard bits.
        //
        RtlMapGenericMask(&RequestedAccess, &ScServiceObjectMapping);

        //
        // Check to see if requested access is granted to client
        //
        return ScAccessCheckAndAudit(
                   (LPWSTR) SC_MANAGER_AUDIT_NAME,
                   (LPWSTR) SC_SERVICE_OBJECT_TYPE_NAME,
                   ContextHandle->Type.ScServiceObject.ServiceRecord->ServiceName,
                   ContextHandle,
                   ContextHandle->Type.ScServiceObject.ServiceRecord->ServiceSd,
                   RequestedAccess,
                   &ScServiceObjectMapping
                   );
    }
    else {

        //
        // Unknown object type.  This should not happen!
        //
        SC_LOG(ERROR, "ScAccessValidate: Unknown object type, signature=0x%08lx\n",
               ContextHandle->Signature);
        ASSERT(FALSE);
        return ERROR_GEN_FAILURE;
    }
}


DWORD
ScAccessCheckAndAudit(
    IN     LPWSTR SubsystemName,
    IN     LPWSTR ObjectTypeName,
    IN     LPWSTR ObjectName,
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN     ACCESS_MASK DesiredAccess,
    IN     PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    ObjectName - Supplies the name of the object being accessed.

    ContextHandle - Supplies the context handle to the object.  On return, if
        this call succeeds, the granted access is written to the AccessGranted
        field of this structure, and the SC_HANDLE_GENERATE_ON_CLOSE bit of the
        Flags field indicates whether NtCloseAuditAlarm must be called when
        this handle is closed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NT status mapped to Win32 errors.

--*/
{

    NTSTATUS NtStatus;
    RPC_STATUS RpcStatus;

    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;

    BOOLEAN GenerateOnClose;
    NTSTATUS AccessStatus;



    RtlInitUnicodeString(&Subsystem, SubsystemName);
    RtlInitUnicodeString(&ObjectType, ObjectTypeName);
    RtlInitUnicodeString(&Object, ObjectName);

    if ((RpcStatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SC_LOG1(ERROR, "ScAccessCheckAndAudit: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
                RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_IMPERSONATE,
            RpcStatus
            );

        return RpcStatus;
    }

    NtStatus = NtAccessCheckAndAuditAlarm(
                   &Subsystem,
                   (PVOID) ContextHandle,
                   &ObjectType,
                   &Object,
                   SecurityDescriptor,
                   DesiredAccess,
                   GenericMapping,
                   FALSE,
                   &ContextHandle->AccessGranted,   // return access granted
                   &AccessStatus,
                   &GenerateOnClose
                   );

    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        SC_LOG(ERROR, "ScAccessCheckAndAudit: Fail to revert to self %08lx\n",
               RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_REVERT,
            RpcStatus
            );

        ASSERT(FALSE);
        return RpcStatus;
    }

    if (! NT_SUCCESS(NtStatus)) {
        if (NtStatus != STATUS_ACCESS_DENIED) {
            SC_LOG1(
                ERROR,
                "ScAccessCheckAndAudit: Error calling NtAccessCheckAndAuditAlarm " FORMAT_NTSTATUS "\n",
                NtStatus
                );
        }
        return ERROR_ACCESS_DENIED;
    }

    if (GenerateOnClose)
    {
        ContextHandle->Flags |= SC_HANDLE_GENERATE_ON_CLOSE;
    }

    if (AccessStatus != STATUS_SUCCESS) {
        SC_LOG(SECURITY, "ScAccessCheckAndAudit: Access status is %08lx\n",
               AccessStatus);
        return ERROR_ACCESS_DENIED;
    }

    SC_LOG(SECURITY, "ScAccessCheckAndAudit: Object name %ws\n", ObjectName);
    SC_LOG(SECURITY, "                       Granted access %08lx\n",
           ContextHandle->AccessGranted);

    return NO_ERROR;
}


DWORD
ScStatusAccessCheck(
    IN     LPSERVICE_RECORD   lpServiceRecord    OPTIONAL
    )
{
    RPC_STATUS          RpcStatus;
    DWORD               dwStatus;

    HANDLE              hThreadToken   = NULL;

    SC_ASSERT(lpServiceRecord == NULL || ScServiceRecordLock.Have());

    //
    // If OpenService is called for SERVICE_SET_STATUS access on a
    // service that's not running, the ImageRecord will be NULL
    //
    if (lpServiceRecord != NULL && lpServiceRecord->ImageRecord == NULL)
    {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        SC_LOG1(ERROR,
                "ScStatusAccessCheck: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
                RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_IMPERSONATE,
            RpcStatus
            );

        return RpcStatus;
    }

    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,
                         TRUE,               // Open as self
                         &hThreadToken))
    {
        dwStatus = GetLastError();

        SC_LOG1(ERROR,
                "ScStatusAccessCheck: OpenThreadToken FAILED %d\n",
                dwStatus);
    }
    else
    {
        TOKEN_STATISTICS  TokenStats;

        if (!GetTokenInformation(hThreadToken,
                                 TokenStatistics,        // Information wanted
                                 &TokenStats,
                                 sizeof(TokenStats),     // Buffer size
                                 &dwStatus))             // Size required
        {
            dwStatus = GetLastError();

            SC_LOG1(ERROR,
                    "ScCreateImageRecord: GetTokenInformation FAILED %d\n",
                    dwStatus);
        }
        else
        {
            LUID  SystemLuid = SYSTEM_LUID;

            if (RtlEqualLuid(&TokenStats.AuthenticationId,
                             lpServiceRecord ? &lpServiceRecord->ImageRecord->AccountLuid :
                                               &SystemLuid))
            {
                dwStatus = NO_ERROR;
            }
            else
            {
                dwStatus = ERROR_ACCESS_DENIED;
            }
        }

        CloseHandle(hThreadToken);
    }

    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        SC_LOG(ERROR,
               "ScStatusAccessCheck: Fail to revert to self %08lx\n",
               RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_REVERT,
            RpcStatus
            );

        ASSERT(FALSE);
        return RpcStatus;
    }

    return dwStatus;
}    


DWORD
ScGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    )
/*++

Routine Description:

    This function alters the privilege level for the current thread.

    It does this by duplicating the token for the current thread, and then
    applying the new privileges to that new token, then the current thread
    impersonates with that new token.

    Privileges can be relinquished by calling ScReleasePrivilege().

Arguments:

    numPrivileges - This is a count of the number of privileges in the
        array of privileges.

    pulPrivileges - This is a pointer to the array of privileges that are
        desired.  This is an array of ULONGs.

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.

--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    HANDLE                      ourToken;
    HANDLE                      newToken;
    OBJECT_ATTRIBUTES           Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    ULONG                       returnLen;
    PTOKEN_PRIVILEGES           pTokenPrivilege = NULL;
    DWORD                       i;

    //
    // Initialize the Privileges Structure
    //
    pTokenPrivilege = (PTOKEN_PRIVILEGES) LocalAlloc(
                                              LMEM_FIXED,
                                              sizeof(TOKEN_PRIVILEGES) +
                                                  (sizeof(LUID_AND_ATTRIBUTES) *
                                                   numPrivileges)
                                              );

    if (pTokenPrivilege == NULL) {
        status = GetLastError();
        SC_LOG(ERROR,"ScGetPrivilege:LocalAlloc Failed %d\n", status);
        return(status);
    }

    pTokenPrivilege->PrivilegeCount  = numPrivileges;

    for (i = 0; i < numPrivileges; i++) {
        pTokenPrivilege->Privileges[i].Luid = RtlConvertLongToLuid(
                                                pulPrivileges[i]);
        pTokenPrivilege->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;

    }

    //
    // Initialize Object Attribute Structure.
    //
    InitializeObjectAttributes(&Obja,NULL,0L,NULL,NULL);

    //
    // Initialize Security Quality Of Service Structure
    //
    SecurityQofS.Length              = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQofS.ImpersonationLevel  = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly       = FALSE;

    Obja.SecurityQualityOfService = &SecurityQofS;

    //
    // Open our own Token
    //
    ntStatus = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_DUPLICATE,
                &ourToken);

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG(ERROR, "ScGetPrivilege: NtOpenThreadToken Failed "
            "FORMAT_NTSTATUS" "\n", ntStatus);

        LocalFree(pTokenPrivilege);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Duplicate that Token
    //
    ntStatus = NtDuplicateToken(
                ourToken,
                TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &Obja,
                FALSE,                  // Duplicate the entire token
                TokenImpersonation,     // TokenType
                &newToken);             // Duplicate token

    if (!NT_SUCCESS(ntStatus)) {
        SC_LOG(ERROR, "ScGetPrivilege: NtDuplicateToken Failed "
            "FORMAT_NTSTATUS" "\n", ntStatus);

        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Add new privileges
    //

    ntStatus = NtAdjustPrivilegesToken(
                newToken,                   // TokenHandle
                FALSE,                      // DisableAllPrivileges
                pTokenPrivilege,            // NewState
                0,                          // Size of previous state buffer
                NULL,                       // No info on previous state
                &returnLen);                // numBytes required for buffer.

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG(ERROR, "ScGetPrivilege: NtAdjustPrivilegesToken Failed "
            "FORMAT_NTSTATUS" "\n", ntStatus);

        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Begin impersonating with the new token
    //
    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&newToken,
                (ULONG)sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG(ERROR, "ScGetPrivilege: NtAdjustPrivilegesToken Failed "
            "FORMAT_NTSTATUS" "\n", ntStatus);

        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    LocalFree(pTokenPrivilege);
    NtClose(ourToken);
    NtClose(newToken);

    return(NO_ERROR);
}


DWORD
ScReleasePrivilege(
    VOID
    )
/*++

Routine Description:

    This function relinquishes privileges obtained by calling ScGetPrivilege().

Arguments:

    none

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.


--*/
{
    NTSTATUS    ntStatus;
    HANDLE      NewToken;


    //
    // Revert To Self.
    //
    NewToken = NULL;

    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&NewToken,
                (ULONG)sizeof(HANDLE));

    if ( !NT_SUCCESS(ntStatus) ) {
        return(RtlNtStatusToDosError(ntStatus));
    }

    return(NO_ERROR);
}


DWORD
ScGetClientSid(
    OUT PTOKEN_USER *UserInfo
    )

/*++

Routine Description:

    This function looks up the SID of the API caller by impersonating
    the caller.

Arguments:

    UserInfo - Receives a pointer to a buffer allocated by this routine
        which contains the TOKEN_USER information of the caller.

Return Value:

    Returns the NT error mapped to Win32

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    RPC_STATUS rpcstatus;
    HANDLE CurrentThreadToken = NULL;
    DWORD UserInfoSize;


    *UserInfo = NULL;

    if ((rpcstatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SC_LOG1(
            ERROR,
            "ScGetUserSid: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
            rpcstatus
            );

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_IMPERSONATE,
            rpcstatus
            );

        return ((DWORD) rpcstatus);
    }

    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,              // Use service controller's security
                                      // context to open thread token
                   &CurrentThreadToken
                   );

    status = RtlNtStatusToDosError(ntstatus);

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR, "ScGetUserSid: NtOpenThreadToken failed "
                FORMAT_NTSTATUS "\n", ntstatus);
        goto Cleanup;
    }

    //
    // Call NtQueryInformationToken the first time with 0 input size to
    // get size of returned information.
    //
    ntstatus = NtQueryInformationToken(
                   CurrentThreadToken,
                   TokenUser,         // User information class
                   (PVOID) *UserInfo, // Output
                   0,
                   &UserInfoSize
                   );

    if (ntstatus != STATUS_BUFFER_TOO_SMALL) {
        SC_LOG1(ERROR, "ScGetUserSid: NtQueryInformationToken failed "
                FORMAT_NTSTATUS ".  Expected BUFFER_TOO_SMALL.\n", ntstatus);
        status = RtlNtStatusToDosError(ntstatus);
        goto Cleanup;
    }

    //
    // Allocate buffer of returned size
    //
    *UserInfo = (PTOKEN_USER)LocalAlloc(
                    LMEM_ZEROINIT,
                    (UINT) UserInfoSize
                    );

    if (*UserInfo == NULL) {
        SC_LOG1(ERROR, "ScGetUserSid: LocalAlloc failed " FORMAT_DWORD
                "\n", GetLastError());
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Call NtQueryInformationToken again with the correct buffer size.
    //
    ntstatus = NtQueryInformationToken(
                   CurrentThreadToken,
                   TokenUser,         // User information class
                   (PVOID) *UserInfo, // Output
                   UserInfoSize,
                   &UserInfoSize
                   );

    status = RtlNtStatusToDosError(ntstatus);

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR, "ScGetUserSid: NtQueryInformationToken failed "
                FORMAT_NTSTATUS "\n", ntstatus);

        LocalFree(*UserInfo);
        *UserInfo = NULL;
    }

Cleanup:

    if (CurrentThreadToken != NULL)
    {
        NtClose(CurrentThreadToken);
    }

    if ((rpcstatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        SC_LOG1(
           ERROR,
           "ScGetUserSid: Failed to revert to self " FORMAT_RPC_STATUS "\n",
           rpcstatus
           );

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_REVERT,
            rpcstatus
            );

        SC_ASSERT(FALSE);
        return ((DWORD) rpcstatus);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\services.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    SERVICES.CXX

Abstract:

    This is the main routine for the Win32 Service Controller and
    Registry (Screg) RPC server process.

Author:

    Dan Lafferty (danl) 25-Oct-1993

Modification History:

--*/

#include "precomp.hxx"
#include <ntrpcp.h>


extern "C"
int __cdecl
main (
    int     argc,
    PCHAR   argv[]
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    //
    //  Initialize the RPC server
    //
    RpcpInitRpcServer();

    SvcctrlMain(argc, argv);


    //
    //  We should never get here!
    //
    ASSERT( FALSE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\smartp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smartp.h

Abstract:

    Safe pointer classes

Author:

    Anirudh Sahni (anirudhs)    21-Oct-1996

Environment:

    User Mode -Win32

Revision History:

    21-Oct-1996     AnirudhS
        Created.


--*/

#ifndef SMARTP_H
#define SMARTP_H

//
// Template pointer class that automatically calls LocalFree when it goes
// out of scope
// T is a pointer type, like LPWSTR or LPVOID, that can be initialized to NULL
//

template <class T>
class CHeapPtr
{
public:
    CHeapPtr() : _p(NULL) { }
   ~CHeapPtr() { LocalFree(_p); }

    operator T()        { return _p; }
    T operator*()       { return *_p; }
    T * operator& ()    { return &_p; }

private:
    T   _p;
};


#endif // def SMARTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\start.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    start.h

Abstract:

    Service start function prototypes.

Author:

    Rita Wong (ritaw)     06-Apr-1992

Revision History:

--*/

#ifndef SCSTART_INCLUDED
#define SCSTART_INCLUDED

//
// Function Prototypes
//

DWORD
ScStartService(
    IN LPSERVICE_RECORD ServiceRecord,
    IN  DWORD               NumArgs,
    IN  LPSTRING_PTRSW      CmdArgs
    );

BOOL
ScAllowInteractiveServices(
    VOID
    );

VOID
ScInitStartupInfo(
    OUT LPSTARTUPINFOW  StartupInfo,
    IN  BOOL            bInteractive
    );

#endif // #ifndef SCSTART_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\start.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    start.cxx

Abstract:

    Contains functions that are required for starting a service.
        RStartServiceW
        StartImage
        InitStartImage
        ScInitStartupInfo
        EndStartImage
        ScAllowInteractiveServices

Author:

    Dan Lafferty (danl)     20-Jan-1992

Environment:

    User Mode - Calls Win32 and NT native APIs.


Revision History:

    13-Mar-199  jschwart
        Use CreateProcessAsUserW for non-LocalSystem services

    06-Apr-1998 jschwart
        Change check for Security Process connection -- check to see if
        the service being started runs in the process, not if it's NetLogon.
        Also clean up WesW from 12-Dec-1997

    10-Mar-1998 jschwart
        Allow services to receive control messages for Plug-and-Play events

    12-Dec-1997 WesW
        Added support for safe boot

    22-Oct-1997 jschwart
        Enable 12-Apr-1995 change for non-_CAIRO_.

    08-Jan-1997 AnirudhS
        Fixed miscellaneous synchronization bugs found by new locking
        scheme.

    09-Dec-1996 AnirudhS
        Added ScInitStartupInfo and ScAllowInteractiveServices, also used
        by crash.cxx

    01-Mar-1996 AnirudhS
        ScStartImage: Notify the PNP manager when a service is started.

    12-Apr-1995 AnirudhS
        Allow services that run under accounts other than LocalSystem to
        share processes too.
        (_CAIRO_ only)

    21-Feb-1995 AnirudhS
        Since CreateProcess now handles quoted exe pathnames, removed the
        (buggy) code that had been added to parse them, including
        ScParseImagePath.

    08-Sep-1994 Danl
        ScLogonAndStartImage:  Close the Duplicate token when we are done
        with it.  This allows logoff notification when the service process
        exits.

    30-Aug-1994 Danl
        ScParseImagePath:  Added this function to look for quotes around the
        pathname.  The Quotes may be necessary if the path contains a space
        character.

    18-Mar-1994 Danl
        ScLogonAndStartImage:  When starting a service in an account, we now
        Impersonate using a duplicate of the token for the service, prior
        to calling CreateProcess.  This allows us to load executables
        whose binaries reside on a remote server.

    20-Oct-1993 Danl
        ScStartService:  If the NetLogon Service isn't in our database yet,
        then we want to check to see if the service to be started is
        NetLogon.  If it is then we need to init our connection with the
        Security Process.

    17-Feb-1993     danl
        Must release the database lock around the CreateProcess call so
        that dll init routines can call OpenService.

    12-Feb-1993     danl
        Move the incrementing of the Service UseCount to
        ScActivateServiceRecord.  This is because if we fail beyond this
        point, we call ScRemoveService to cleanup - but that assumes the
        UseCount has already been incremented one for the service itself.

    25-Apr-1992     ritaw
        Changed ScStartImage to ScLogonAndStartImage

    20-Jan-1992     danl
        created


--*/

//
// Includes
//

#include "precomp.hxx"
extern "C" {
#include <winuserp.h>   // STARTF_DESKTOPINHERIT
#include <cfgmgr32.h>   // PNP manager functions
#include <pnp.h>        // PNP manager functions, server side
#include <cfgmgrp.h>    // PNP manager functions, server side, internal
#include <userenv.h>    // UnloadUserProfile
}
#include <stdlib.h>      // wide character c runtimes.

#include <tstr.h>       // Unicode string macros

#include <scconfig.h>   // ScGetImageFileName
#include <control.h>
#include <scseclib.h>   // ScCreateAndSetSD
#include <svcslib.h>    // SvcStartLocalDispatcher
#include "depend.h"     // ScStartMarkedServices
#include "driver.h"     // ScLoadDeviceDriver
#include "account.h"    // ScLogonService

#include "start.h"      // ScStartService


//
// STATIC DATA
//

    CRITICAL_SECTION     ScStartImageCriticalSection;
    const LPWSTR         pszInteractiveDesktop=L"WinSta0\\Default";

//
// LOCAL FUNCTIONS
//
DWORD
ScLogonAndStartImage(
    IN  LPSERVICE_RECORD ServiceRecord,
    IN  LPWSTR           ImageName,
    OUT LPIMAGE_RECORD   *ImageRecordPtr,
    IN  OPTIONAL LPVOID  Environment
    );

VOID
ScProcessHandleIsSignaled(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    );

BOOL
ScEqualAccountName(
    IN LPWSTR Account1,
    IN LPWSTR Account2
    );


DWORD
RStartServiceW(
    IN  SC_RPC_HANDLE       hService,
    IN  DWORD               NumArgs,
    IN  LPSTRING_PTRSW      CmdArgs
    )

/*++

Routine Description:

    This function begins the execution of a service.

Arguments:

    hService - A handle which is a pointer to a service handle structure.

    dwNumServiceArgs - This indicates the number of argument vectors.

    lpServiceArgVectors - This is a pointer to an array of string pointers.

Return Value:

    NO_ERROR - The operation was completely successful.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_START access.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_SERVICE_WAS_STARTED - An instance of the service is already running.

    ERROR_SERVICE_REQUEST_TIMEOUT - The service did not respond to the start
        request in a timely fashion.

    ERROR_SERVICE_NO_THREAD - A thread could not be created for the Win32
        service.

    ERROR_PATH_NOT_FOUND - The image file name could not be found in
        the configuration database (registry), or the image file name
        failed in a unicode/ansi conversion.



--*/
{
    DWORD status;
    LPSERVICE_RECORD serviceRecord;

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Was the handle opened with SERVICE_START access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              SERVICE_START
              )) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // A word about Locks....
    // We don't bother to get locks here because (1) We know the service
    // record cannot go away because we have an open handle to it,
    // (2) For these checks, we don't care if state changes after we
    // check them.
    //
    // (ScStartServiceAndDependencies also performs these checks; they are
    // repeated here so we can fail quickly in these 2 cases.)
    //
    serviceRecord =
        ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    //
    // We can never start a disabled service
    //
    if (serviceRecord->StartType == SERVICE_DISABLED) {
        return ERROR_SERVICE_DISABLED;
    }

    //
    // Cannot start a deleted service.
    //
    if (DELETE_FLAG_IS_SET(serviceRecord)) {
        return ERROR_SERVICE_MARKED_FOR_DELETE;
    }

    status = ScStartServiceAndDependencies(serviceRecord, NumArgs, CmdArgs, FALSE);

    if (status == NO_ERROR)
    {
        if (serviceRecord->StartError == NO_ERROR)
        {
            //
            // Log successful service start.  0 is for a start "control"
            // since there's actually no such SERVICE_CONTROL_* constant.
            //

            ScLogControlEvent(NEVENT_SERVICE_CONTROL_SUCCESS,
                              serviceRecord->DisplayName,
                              0);
        }

        return serviceRecord->StartError;
    }
    else
    {
        //
        // Start failure was logged by ScStartServiceAndDependencies
        //

        return status;
    }
}


DWORD
ScStartService(
    IN  LPSERVICE_RECORD    ServiceRecord,
    IN  DWORD               NumArgs,
    IN  LPSTRING_PTRSW      CmdArgs
    )
/*++

Routine Description:

    This function starts a service.  This code is split from the RStartServiceW
    so that the service controller internal code can bypass RPC and security
    checking when auto-starting services and their dependencies.

Arguments:

    ServiceRecord - This is a pointer to the service record.

    NumArgs - This indicates the number of argument vectors.

    CmdArgs - This is a pointer to an array of string pointers.

Return Value:

    NO_ERROR - The operation was completely successful.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_START access.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_SERVICE_WAS_STARTED - An instance of the service is already running.

    ERROR_SERVICE_REQUEST_TIMEOUT - The service did not respond to the start
        request in a timely fashion.

    ERROR_SERVICE_NO_THREAD - A thread could not be created for the Win32
        service.

    ERROR_PATH_NOT_FOUND - The image file name could not be found in
        the configuration database (registry), or the image file name
        failed in a Unicode/Ansi conversion.

    ERROR_NOT_SAFEBOOT_SERVICE - This service isn't startable during Safeboot.

--*/
{
    DWORD               status;
    LPWSTR              ImageName   = NULL;
    LPIMAGE_RECORD      ImageRecord = NULL;
    LPWSTR              serviceName;
    LPWSTR              displayName;
    HANDLE              pipeHandle;
    DWORD               startControl;

    //
    // Check for Safeboot
    //
    if (g_dwSafebootLen != 0 && g_SafeBootEnabled != SAFEBOOT_DSREPAIR) {

        HKEY  hKeySafeBoot;

        //
        // If this ever fails, SAFEBOOT_BUFFER_LENGTH must be made larger
        //
        SC_ASSERT(g_dwSafebootLen + wcslen(ServiceRecord->ServiceName)
                      < SAFEBOOT_BUFFER_LENGTH);

        wcscpy(g_szSafebootKey + g_dwSafebootLen, ServiceRecord->ServiceName);

        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              g_szSafebootKey,
                              0,
                              KEY_READ,
                              &hKeySafeBoot);

        if (status != NO_ERROR) {
            SC_LOG1(ERROR, "SAFEBOOT: service skipped = %ws\n",
                    ServiceRecord->ServiceName);

            return ERROR_NOT_SAFEBOOT_SERVICE;
        }

        RegCloseKey(hKeySafeBoot);
    }

    //  NOTE:  Only one thread at a time should be in this part of the code.
    //  This prevents two images from getting started as could happen if
    //  two threads get the Image Record at virtually the same time.  In
    //  this case, they might both decide to start the same image.
    //
    //  We need to do this before the check for the CurrentState.  Otherwise,
    //  two threads could race down to start the same service, and they
    //  would both attempt to start it.  We would end up with either
    //  two service images running, or two threads of the same service
    //  running in a single image.
    //

    EnterCriticalSection(&ScStartImageCriticalSection);

    SC_LOG(LOCKS,"RStartServiceW: Entering StartImage Critical Section.....\n",0);

    //
    // We need to gain exclusive access to the database so that we may
    // Read the database and make decisions based on its content.
    //
    {
        CServiceRecordExclusiveLock RLock;

#ifdef TIMING_TEST
        DbgPrint("[SC_TIMING] Start Next Service TickCount for\t%ws\t%d\n",
            ServiceRecord->ServiceName, GetTickCount());
#endif // TIMING_TEST

        //
        // Check to see if the service is already running.
        //
        if (ServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED){
            SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section....\n",0);
            LeaveCriticalSection(&ScStartImageCriticalSection);
            return(ERROR_SERVICE_ALREADY_RUNNING);
        }

        //
        // If we are loading a driver, load it and return.
        // WARNING: ScLoadDeviceDriver releases and reacquires the RecordLock.
        //
        if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER) {
            status = ScLoadDeviceDriver(ServiceRecord);
            LeaveCriticalSection(&ScStartImageCriticalSection);
            return(status);
        }

        //
        // Get the image record information out of the configuration database.
        //
        status = ScGetImageFileName(ServiceRecord->ServiceName, &ImageName);

        if (status != NO_ERROR) {
            SC_LOG(ERROR,"GetImageFileName failed rc = %d\n",status);
            SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section....\n",0);
            LeaveCriticalSection(&ScStartImageCriticalSection);
            return status;
        }

        if (ImageName == NULL) {
            SC_LOG0(ERROR,"GetImageFileName returned a NULL pointer\n");
            SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section....\n",0);
            LeaveCriticalSection(&ScStartImageCriticalSection);
            return ERROR_PATH_NOT_FOUND;
        }

#ifndef _CAIRO_
        //
        // If the security process hasn't been started yet, see if this
        // service runs in the security process and if so, initialize it.
        // Even if ScInitSecurityProcess fails, we will set the global
        // flag since we will not attempt to connect again.
        //
        if (!ScConnectedToSecProc) {
            if (_wcsicmp(ScGlobalSecurityExePath, ImageName) == 0) {
                if (!ScInitSecurityProcess(ServiceRecord)) {
                    SC_LOG0(ERROR, "ScInitSecurityProcess Failed\n");
                }
                ScConnectedToSecProc = TRUE;
            }
        }
#endif // _CAIRO_

        //
        // Make the service record active.
        // Because the service effectively has a handle to itself, the
        // UseCount gets incremented inside ScActivateServiceRecord() when
        // called with a NULL ImageRecord pointer.
        //
        // We need to do this here because when we get to ScLogonAndStartImage,
        // we have to release the database lock around the CreateProcess call.
        // Since we open ourselves up to DeleteService and Control Service calls,
        // We need to increment the use count, and set the START_PENDING status
        // here.
        //
        ScActivateServiceRecord(ServiceRecord, NULL);

        //
        // Is the image file for that service already running?
        // If not, call StartImage.
        //
        // If the Image Record was NOT found in the database OR if the service
        // wants to share a process and there is no shareable version of the
        // Image Record, then start the image file.
        //
        if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32_SHARE_PROCESS) {
            ScGetNamedImageRecord(ImageName,&ImageRecord);
        }

        // CODEWORK - may not need to release the lock here in all cases.
    } // Release RLock

    if (ImageRecord != NULL) {


        //
        // The service is configured to share its process with other services,
        // and the image for the service is already running.  So we don't need
        // to start a new instance of the image.
        //
        // We do need to check that the account for the service is the same
        // as the one that the image was started under, and that the password
        // is valid.
        //

        LPWSTR AccountName = NULL;

        status = ScLookupServiceAccount(
                    ServiceRecord->ServiceName,
                    &AccountName
                    );

        if (status == NO_ERROR) {
            if (!ScEqualAccountName(AccountName, ImageRecord->AccountName)) {
                status = ERROR_DIFFERENT_SERVICE_ACCOUNT;
                SC_LOG3(ERROR,
                        "Can't start %ws service in account %ws because "
                            "image is already running under account %ws\n",
                        ServiceRecord->ServiceName,
                        AccountName,
                        ImageRecord->AccountName
                        );
            }
        }

        //
        // If the account is not LocalSystem, validate the password by
        // logging on the service
        //
        if (status == NO_ERROR && AccountName != NULL) {

            HANDLE          ServiceToken = NULL;
            PSID            ServiceSid = NULL;

            status = ScLogonService(
                         ServiceRecord->ServiceName,
                         AccountName,
                         &ServiceToken,
                         NULL,      // Don't need to load the user profile again
                         &ServiceSid
                         );

            if (status == NO_ERROR) {
                CloseHandle(ServiceToken);
                LocalFree(ServiceSid);
            }
        }

        LocalFree(AccountName);
    }
    else {


        //
        // Start a new instance of the image
        //
        // See if the service has a supplied environment.
        //
        LPVOID  Environment;
        status = ScGetEnvironment(ServiceRecord->ServiceName, &Environment);
        if (status != NO_ERROR) {
            Environment = NULL;
        }

        SC_LOG(TRACE,"Start: calling StartImage\n",0);

        status = ScLogonAndStartImage(
                    ServiceRecord,
                    ImageName,
                    &ImageRecord,
                    Environment
                    );

        if (status != NO_ERROR) {
            SC_LOG(TRACE,"Start: StartImage failed!\n",0);
        }

        LocalFree(Environment);
    }

    LocalFree( ImageName );

    if (status != NO_ERROR) {

        //
        // Deactivate the service record.
        //
        CServiceRecordExclusiveLock RLock;
        (void)ScDeactivateServiceRecord(ServiceRecord);

        SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section........\n",0);
        LeaveCriticalSection(&ScStartImageCriticalSection);

        return(status);
    }

    //
    // Before leaving the StartImage critical section, we need to gain
    // exclusive access to the database so that we may add the image record
    // pointer to the service record. (ActivateServiceRecord).
    //
    {
        CServiceRecordExclusiveLock RLock;

        //
        // By the time we get here, the Service Process will already be
        // running and ready to accept its first control request.
        //

        //
        // Add the ImageRecord Information to the active service record.
        //
        // Note that, as soon as we activate the service record and release
        // the lock, we open ourselves up to receiving control requests.
        // However, ScActivateServiceRecord sets the ControlsAccepted field
        // to 0, so that the service cannot accept any controls.  Thus, until
        // the service actually sends its own status, the service controller
        // will reject any controls other than INTERROGATE.
        //
        // Because the service effectively has a handle to itself, the
        // UseCount gets incremented inside ScActivateServiceRecord().
        //
        ScActivateServiceRecord(ServiceRecord,ImageRecord);

        pipeHandle  = ServiceRecord->ImageRecord->PipeHandle;
        serviceName = ServiceRecord->ServiceName;
        displayName = ServiceRecord->DisplayName;
    }

    SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section........\n",0);
    LeaveCriticalSection(&ScStartImageCriticalSection);

    //
    // Start the Service
    //

    if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32_OWN_PROCESS) {
        startControl = SERVICE_CONTROL_START_OWN;
    }
    else {
        startControl = SERVICE_CONTROL_START_SHARE;
    }


    CONTROL_ARGS        ControlArgs;

    ControlArgs.CmdArgs = (LPWSTR *)CmdArgs;

    status = ScSendControl (
                serviceName,                               // ServiceName
                displayName,                               // DisplayName
                pipeHandle,                                // pipeHandle
                startControl,                              // Opcode
                &ControlArgs,                              // Union holding command-line args
                NumArgs,                                   // NumArgs
                NULL);                                     // Ignore handler return value

    if (status != NO_ERROR) {
        //
        // If an error occured, remove the service by de-activating the
        // service record and terminating the service process if it is
        // the only one running in the process.
        //
        SC_LOG2(ERROR,"Start: SendControl to %ws service failed! status=%ld\n",
                serviceName, status);

        //
        // NOTE: Because ScRemoveService will expect the use count
        //  to already be incremented (for the service's own handle),
        //  it is necessary to increment that use count prior to
        //  removing it.
        //

        ScRemoveService(ServiceRecord);
    }
    else
    {
        //
        // Notify the PNP manager that the service was started.
        // The PNP manager uses this information to resolve ambiguities in
        // reconfiguration scenarios where there could temporarily be more
        // than one controlling service for a device.  It remembers the last
        // service started for each device, and marks it as the "active"
        // service for the device in the registry.
        // We don't need to do this for drivers, because NtLoadDriver itself
        // notifies the PNP manager.
        //
        CONFIGRET PnpStatus = PNP_SetActiveService(
                                    NULL,               // hBinding
                                    serviceName,        // pszService
                                    PNP_SERVICE_STARTED // ulFlags
                                    );
        if (PnpStatus != CR_SUCCESS)
        {
            SC_LOG2(ERROR, "PNP_SetActiveService failed %#lx for service %ws\n",
                           PnpStatus, serviceName);
        }
    }
    return(status);
}

/****************************************************************************/
DWORD
ScLogonAndStartImage(
    IN  LPSERVICE_RECORD ServiceRecord,
    IN  LPWSTR          ImageName,
    OUT LPIMAGE_RECORD  *ImageRecordPtr,
    IN  OPTIONAL LPVOID Environment
    )

/*++

Routine Description:

    This function is called when the first service in an instance of an
    image needs to be started.

    This function creates a pipe instance for control messages and invokes
    the executable image.  It then waits for the new process to connect
    to the control data pipe.  An image Record is created with the
    above information by calling CreateImageRecord.

Arguments:

    ImageName - This is the name of the image file that is to be started.
        This is expected to be a fully qualified path name.

    ImageRecordPtr - This is a location where the pointer to the new
        Image Record is returned.

    Environment - If present, supplies the environment block to be passed
        to CreateProcess

Return Value:

    NO_ERROR - The operation was successful.  It any other return value
        is returned, a pipe instance will not be created, a process will
        not be started, and an image record will not be created.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate buffer for the image record.

    other - Any error returned by the following could be returned:
                CreateNamedPipe
                ConnectNamedPipe
                CreateProcess
                ScCreateControlInstance
                ScLogonService

Note:
    LOCKS:
        The Database Lock is not held when this function is called.

    CODEWORK: This function badly needs to use C++ destructors for safe
    cleanup in error conditions.

--*/

{
    PROCESS_INFORMATION     processInfo          = { 0, 0, 0, 0 };
    DWORD                   servicePID;
    DWORD                   dwServiceID;
    HANDLE                  pipeHandle           = NULL;
    DWORD                   status;
    BOOL                    runningInThisProcess = FALSE;
    HANDLE                  ServiceToken         = NULL;
    HANDLE                  ProfileHandle        = NULL;
    LPWSTR                  AccountName          = NULL;
    DWORD                   ImageFlags           = 0;
    PSID                    ServiceSid           = LocalSystemSid;

    SC_ASSERT(! ScServiceRecordLock.Have());

    //
    // IMPORTANT:
    // Only one thread at a time should be allowed to execute this
    // code.
    //

    //
    // Lookup the account that the service is to be started under.
    // An AccountName of NULL means the LocalSystem account.
    //
    status = ScLookupServiceAccount(
                ServiceRecord->ServiceName,
                &AccountName
                );

    if (status != NO_ERROR) {
        return status;
    }

    if (AccountName != NULL) {

        //*******************************************************************
        // Start Service in an Account
        //*******************************************************************

        //
        // A token can be created via service logon, if the service
        // account name is not LocalSystem.  Assign this token into
        // the service process.
        //

        NTSTATUS                ntstatus;
        SECURITY_ATTRIBUTES     SaProcess;
        BOOL                    fLoadedEnv      = FALSE;

        PSECURITY_DESCRIPTOR    SecurityDescriptor;

#define SC_PROCESSSD_ACECOUNT 2

        SC_ACE_DATA AceData[SC_PROCESSSD_ACECOUNT] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   PROCESS_ALL_ACCESS,
                   0},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   PROCESS_SET_INFORMATION |
                       PROCESS_TERMINATE |
                       SYNCHRONIZE,
                   &LocalSystemSid}
            };

        //
        // Get service token, to be assigned into the service process,
        // by logging on the service
        //

        status = ScLogonService(
                     ServiceRecord->ServiceName,
                     AccountName,
                     &ServiceToken,
                     &ProfileHandle,
                     &ServiceSid
                     );

        if (status != NO_ERROR) {
            LocalFree(AccountName);
            return status;
        }

        //
        // If there was no environment specified in the registry for
        // this service and successfully read by ScGetEnvironment,
        // give it this user account's environment block
        //
        if (Environment == NULL) {

            fLoadedEnv = CreateEnvironmentBlock(
                             &Environment,
                             ServiceToken,
                             FALSE);

            if (!fLoadedEnv) {

                SC_LOG(ERROR,
                       "ScLogonAndStartImage: CreateEnvironmentBlock FAILED %d\n",
                       GetLastError());
                Environment = NULL;
            }
        }

        //
        // Fill pointer in AceData structure with ServiceSid we just
        // got back.
        //
        AceData[0].Sid = &ServiceSid;

        //
        // Create a security descriptor for the process we are about
        // to create
        //
        ntstatus = ScCreateAndSetSD(
                       AceData,                 // AceData
                       SC_PROCESSSD_ACECOUNT,   // AceCount
                       NULL,                    // OwnerSid (optional)
                       NULL,                    // GroupSid (optional)
                       &SecurityDescriptor      // pNewDescriptor
                       );

#undef SC_PROCESSSD_ACECOUNT

        if (! NT_SUCCESS(ntstatus)) {

            SC_LOG1(ERROR, "ScCreateAndSetSD failed " FORMAT_NTSTATUS
                    "\n", ntstatus);

            if (fLoadedEnv) {
                DestroyEnvironmentBlock(Environment);
            }

            status = RtlNtStatusToDosError(ntstatus);
            goto ExitAccountError;
        }

        //
        // Initialize process security info
        //
        SaProcess.nLength = sizeof(SECURITY_ATTRIBUTES);
        SaProcess.lpSecurityDescriptor = SecurityDescriptor;
        SaProcess.bInheritHandle = FALSE;

        //
        // Set the flags that prevent the service from interacting
        // with the desktop
        //
        STARTUPINFOW StartupInfo;
        ScInitStartupInfo(&StartupInfo, FALSE);

        //
        // Impersonate the user so we don't give access to
        // EXEs that have been locked down for the account.
        //
        if (!ImpersonateLoggedOnUser(ServiceToken))
        {
            status = GetLastError();

            SC_LOG1(ERROR,
                    "ScLogonAndStartImage:  ImpersonateLoggedOnUser failed %d\n",
                    status);

            if (fLoadedEnv) {
                DestroyEnvironmentBlock(Environment);
            }

            RtlDeleteSecurityObject(&SecurityDescriptor);

            goto ExitAccountError;
        }

        //
        // Create the process in suspended mode to set the token
        // into the process.
        //
        // Note: If someone tries to start a service in a user account
        // with an image name of services.exe, a second instance of
        // services.exe will start, but will exit because it won't be
        // able to open the start event with write access (see
        // ScGetStartEvent).
        //
        if (!CreateProcessAsUserW (
                ServiceToken,   // Token representing logged-on user
                NULL,           // Fully qualified image name
                ImageName,      // Command Line
                &SaProcess,     // Process Attributes
                NULL,           // Thread Attributes
                FALSE,          // Inherit Handles
                DETACHED_PROCESS |
                    CREATE_UNICODE_ENVIRONMENT |
                    CREATE_SUSPENDED, // Creation Flags
                Environment,    // Pointer to Environment block
                NULL,           // Pointer to Current Directory
                &StartupInfo,   // Startup Info
                &processInfo))  // ProcessInformation
        {
            status = GetLastError();
        }

        //
        // Stop impersonating
        //
        RevertToSelf();

        if (fLoadedEnv) {
            DestroyEnvironmentBlock(Environment);
        }

        RtlDeleteSecurityObject(&SecurityDescriptor);

        if (status != NO_ERROR) {

            SC_LOG2(ERROR,
                "LogonAndStartImage: CreateProcessAsUser %ws failed " FORMAT_DWORD "\n",
                 ImageName, status);

            goto ExitAccountError;
        }

        SC_LOG1(ACCOUNT, "LogonAndStartImage: Service " FORMAT_LPWSTR
            " was spawned to run in an account\n", ServiceRecord->ServiceName);

        //*******************************************************************
        // End of Service In Account Stuff.
        //*******************************************************************
    }
    else
    {
        //-----------------------------------------------
        // Service to run with the LocalSystem account.
        //-----------------------------------------------

        BOOL bInteractive = FALSE;

        if (_wcsicmp(ImageName,ScGlobalThisExePath) == 0)
        {
            processInfo.hProcess = NULL;
            processInfo.dwProcessId = GetCurrentProcessId();
            runningInThisProcess = TRUE;
        }
        else
        {
            //
            // The service is to run in some other image.
            //
            // If the service is to run interactively, check the flag in the
            // registry to see if this system is to allow interactive services.
            //
            if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_INTERACTIVE_PROCESS) {

                bInteractive = ScAllowInteractiveServices();

                if (!bInteractive)
                {
                    //
                    // Write an event to indicate that an interactive service
                    // was started, but the system is configured to not allow
                    // services to be interactive.
                    //

                    ScLogEvent(NEVENT_SERVICE_NOT_INTERACTIVE,
                               ServiceRecord->DisplayName);
                }
            }

            //
            // If the process is to be interactive, set the appropriate flags.
            //
            STARTUPINFOW StartupInfo;
            ScInitStartupInfo(&StartupInfo, bInteractive);

            //
            // Spawn the Image Process
            //

            SC_LOG0(TRACE,"LogonAndStartImage: about to spawn a Service Process\n");

            if (!CreateProcessW (
                    NULL,           // Fully qualified image name
                    ImageName,      // Command Line
                    NULL,           // Process Attributes
                    NULL,           // Thread Attributes
                    FALSE,          // Inherit Handles
                    DETACHED_PROCESS |  
                        CREATE_UNICODE_ENVIRONMENT |
                        CREATE_SUSPENDED, // Creation Flags
                    Environment,    // Pointer to Environment block
                    NULL,           // Pointer to Current Directory
                    &StartupInfo,   // Startup Info
                    &processInfo)   // ProcessInformation
                ) {

                status = GetLastError();
                SC_LOG2(ERROR,
                    "LogonAndStartImage: CreateProcess %ws failed %d \n",
                        ImageName,
                        status);

                goto ExitAccountError;
            }

            SC_LOG1(ACCOUNT, "LogonAndStartImage: Service " FORMAT_LPWSTR
                    " was spawned to run as LocalSystem\n", ServiceRecord->ServiceName);
        }
        //-----------------------------------------------
        // End of LocalSystem account stuff
        //-----------------------------------------------
    }

    //
    // Create an instance of the control pipe.  If a malicious process
    // has already created a pipe by this name, the CreateNamedPipe
    // call in ScCreateControlInstance will return ERROR_ACCESS_DENIED.
    // Since that error should never come back otherwise, keep trying
    // new pipe names until we stop getting that error.
    //

    do
    {
        //
        // Write the service's ID to the registry
        //
        status = ScWriteCurrentServiceValue(&dwServiceID);

        if (status != NO_ERROR)
        {
            goto ExitAccountError;
        }

        status = ScCreateControlInstance(&pipeHandle,
                                         dwServiceID,
                                         ServiceSid);
    }
    while (status == ERROR_ACCESS_DENIED);

    if (status != NO_ERROR)
    {
        SC_LOG(ERROR,"LogonAndStartImage: CreateControlInstance Failure\n",0);
        goto ExitAccountError;
    }

    if (runningInThisProcess) {

        //
        // The service is to run in this image (services.exe).
        // Since this is the first service to be started in this image,
        // we need to start the local dispatcher.
        //
        status = SvcStartLocalDispatcher();

        if (status != NO_ERROR) {

            SC_LOG1(ERROR,"LogonAndStartImage: SvcStartLocalDispatcher "
                " failed %d",status);
            goto ExitAccountError;
        }
    }
    else {

        //
        // Let the suspended process run.
        //
        ResumeThread(processInfo.hThread);
    }

    status = ScWaitForConnect(pipeHandle,
                              processInfo.hProcess,
                              ServiceRecord->DisplayName,
                              &servicePID);

    if (status != NO_ERROR) {

        SC_LOG0(ERROR,
            "LogonAndStartImage: Failed to connect to pipe - Terminating the Process...\n");
        goto ExitAccountError;
    }

    //
    // The client managed to connect on the correct PID-named pipe, so
    // the PID it's reporting should be the same as what we think it is.
    // Note that a mismatch is OK if the service is being run under the debugger.
    //
    if (processInfo.dwProcessId != servicePID) {

        SC_LOG2(ERROR,
                "LogonAndStartImage: PID mismatch - started process %d, process %d connected\n",
                processInfo.dwProcessId, 
                servicePID);
    }

    //
    // If it's a shared-process service, put this information into the Image Record
    //
    if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32_SHARE_PROCESS) {
        ImageFlags |= CANSHARE_FLAG;
    }

    status = ScCreateImageRecord (
                ImageRecordPtr,
                ImageName,
                AccountName,
                processInfo.dwProcessId,
                pipeHandle,
                processInfo.hProcess,
                ServiceToken,
                ProfileHandle,
                ImageFlags);

    if (status != NO_ERROR) {
        SC_LOG0(ERROR,
            "LogonAndStartImage: Failed to create imageRecord - Terminating the Process...\n",);
        goto ExitAccountError;
    }

    //
    // If the dispatcher is running in this process, then we want to
    // increment the service count an extra time so that the dispatcher
    // never goes away.  Also, we don't really have a process handle for
    // the watcher to wait on.
    // It could wait on the ThreadHandle, but handling that when it becomes
    // signaled becomes a special case.  So we won't try that.
    //
    if (runningInThisProcess) {
        (*ImageRecordPtr)->ServiceCount = 1;
        (*ImageRecordPtr)->ImageFlags  |= IS_SYSTEM_SERVICE;
    }
    else {
        HANDLE   hWaitObject = NULL;
        NTSTATUS ntStatus;

        CloseHandle(processInfo.hThread);
        //
        // Add the process handle to the ObjectWatcher list of waitable
        // objects.
        //

        //
        // Add the process handle as a handle to wait on.
        // Retain the WaitObject handle for when we need shutdown the
        // process because all the services stopped.
        //
        ntStatus = RtlRegisterWait(&hWaitObject,
                                   processInfo.hProcess,
                                   ScProcessHandleIsSignaled,
                                   processInfo.hProcess,
                                   INFINITE,                   // Infinite
                                   WT_EXECUTEONLYONCE);

        if (!NT_SUCCESS(ntStatus)) {

            //
            // Work item registration failed
            //
            SC_LOG1(ERROR,
                    "ScLogonAndStartImage: RtlRegisterWait failed 0x%x\n",
                    ntStatus);
        }

        (*ImageRecordPtr)->ObjectWaitHandle = hWaitObject;
    }

    if (ServiceSid != LocalSystemSid) {
        LocalFree(ServiceSid);
    }

    LocalFree(AccountName);
    return(NO_ERROR);

ExitAccountError:

    if (pipeHandle != NULL) {
        CloseHandle(pipeHandle);
    }

    if (ServiceSid != LocalSystemSid) {
        LocalFree(ServiceSid);
    }

    UnloadUserProfile(ServiceToken, ProfileHandle);
    
    if (ServiceToken != NULL) {
        CloseHandle(ServiceToken);
    }

    if (processInfo.hProcess) {

        TerminateProcess(processInfo.hProcess,0);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
    }

    LocalFree(AccountName);

    return status;
}


BOOL
ScEqualAccountName(
    IN LPWSTR Account1,
    IN LPWSTR Account2
    )

/*++

Routine Description:

    This function compares two account names, either of which may be NULL,
    for equality.

Arguments:

    Account1, Account2 - account names to be compared

Return Value:

    TRUE - names are equal

    FALSE - names are not equal

--*/
{
    if (Account1 == NULL && Account2 == NULL)
    {
        return TRUE;
    }

    if (Account1 == NULL || Account2 == NULL)
    {
        return FALSE;
    }

    return (_wcsicmp(Account1, Account2) == 0);
}


VOID
ScInitStartImage(
    VOID
    )

/*++

Routine Description:

    This function initializes the Critical Section that protects
    entry into the ScStartImage Routine.

Arguments:

    none

Return Value:

    none

--*/
{
    InitializeCriticalSection(&ScStartImageCriticalSection);
}


VOID
ScInitStartupInfo(
    OUT LPSTARTUPINFOW  StartupInfo,
    IN  BOOL            bInteractive
    )

/*++

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    static const STARTUPINFOW ScStartupInfo =
        {
            sizeof(STARTUPINFOW), // size
            NULL,                 // lpReserved
            NULL,                 // DeskTop
            NULL,                 // Title
            0,                    // X (position)
            0,                    // Y (position)
            0,                    // XSize (dimension)
            0,                    // YSize (dimension)
            0,                    // XCountChars
            0,                    // YCountChars
            0,                    // FillAttributes
            STARTF_FORCEOFFFEEDBACK,
                                  // Flags - should be STARTF_TASKNOTCLOSABLE
            SW_HIDE,              // ShowWindow
            0L,                   // cbReserved
            NULL,                 // lpReserved
            NULL,                 // hStdInput
            NULL,                 // hStdOutput
            NULL                  // hStdError
        };

    RtlCopyMemory(StartupInfo, &ScStartupInfo, sizeof(ScStartupInfo));

    if (bInteractive)
    {
        StartupInfo->dwFlags |= STARTF_DESKTOPINHERIT;
        StartupInfo->lpDesktop = pszInteractiveDesktop;
    }
}


VOID
ScProcessHandleIsSignaled(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    )

/*++

Routine Description:


Arguments:

    pContext - This is the process handle.
    fWaitStatus - This is the status from the wait on the process handle.
                  TRUE means the wait timed out, FALSE means it was signaled

Return Value:


--*/
{
    if (fWaitStatus == TRUE) {

        //
        // This should never happen -- it indicates a bug in the thread pool code
        // since we registered an infinite wait and are getting called on a timeout
        //
        SC_LOG0(ERROR,
                "ScProcessCleanup received bad WaitStatus\n");

        SC_ASSERT(FALSE);
        return;
    }

    SC_ASSERT(fWaitStatus == FALSE);

    SC_LOG1(THREADS, "Process Handle is signaled 0x%lx\n", pContext);

    ScNotifyChangeState();
    ScProcessCleanup((HANDLE)pContext);
}


BOOL
ScAllowInteractiveServices(
    VOID
    )

/*++

Routine Description:

    Check the flag in the registry to see if this system is to allow
    interactive services.
    REG KEY = HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\-
                 Windows\NoInteractiveServices.

Arguments:


Return Value:


--*/
{
    HKEY    WindowsKey=NULL;
    DWORD   NoInteractiveFlag=0;

    BOOL    bServicesInteractive = TRUE;

    DWORD   status = ScRegOpenKeyExW(
                           HKEY_LOCAL_MACHINE,
                           CONTROL_WINDOWS_KEY_W,
                           REG_OPTION_NON_VOLATILE,   // options
                           KEY_READ,                  // desired access
                           &WindowsKey
                           );

    if (status != ERROR_SUCCESS) {
        SC_LOG1(TRACE,
            "ScAllowInteractiveServices: ScRegOpenKeyExW of Control\\Windows failed "
            FORMAT_LONG "\n", status);
    }
    else {
        status = ScReadNoInteractiveFlag(WindowsKey,&NoInteractiveFlag);
        if ((status == ERROR_SUCCESS) && (NoInteractiveFlag != 0)) {

            bServicesInteractive = FALSE;
        }

        ScRegCloseKey(WindowsKey);
    }

    return bServicesInteractive;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\svcctrl.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    svcctrl.cxx

Abstract:

    This is the main routine for the NT LAN Manager Service Controller.

    To use this as a template for another service, simply replace the string
    "svcctl" with the name of the new interface.

Author:

    Dan Lafferty    (danl)  20-Mar-1991

Environment:

    User Mode - Win32

Revision History:

    04-Aug-1999     jschwart
        Added code to watch the list of network providers and write the list
        of providers enabled in this HW profile to the registry for mpr.dll
    22-Oct-1998     jschwart
        Added an unhandled exception filter and converted SCM to use
        the NT thread pool APIs
    22-Jun-1998     jschwart
        Added SetErrorMode call to prevent services from halting the process
        with a hard error popup
    10-Mar-1998     jschwart
        Added RegisterScmCallback call to provide SCM support for passing
        PnP messages to services
    12-Dec-1997     WesW
        Added support for safe boot
    11-Jun-1996     AnirudhS
        Don't popup messages during setup.  The most common cause of popups
        during upgrade is that a service runs in a domain account, and hence
        has a dependency on netlogon, which is disabled during upgrade.
    26-Jun-1995     AnirudhS
        Added callouts to service object class code (ScNotifyServiceObject).
    20-Oct-1993     Danl
        Added Globals for ScConnectedToSecProc and ScGlobalNetLogonName.
    28-Oct-1992     Danl
        Removed ParseArgs and the NT event.  Added Windows event for
        synchronizing service controller with the OpenSCManager client side.
        OpenScManager will now wait until the service controller event is
        set.
    20-Mar-1991     danl
        created

--*/
//
// INCLUDES
//
#include "precomp.hxx"
#include <stdio.h>      // printf

#include <winuserp.h>   // RegisterServicesProcess

#include <lmcons.h>     // needed by lmalert.h
#include <lmalert.h>    // NetAlertRaiseEx definitions
#include <alertmsg.h>   // ALERT_SC_IsLastKnownGood

#ifdef _CAIRO_
#include <wtypes.h>     // HRESULT
#include <scmso.h>      // ScmCallSvcObject
#endif

#include <tstr.h>       // Unicode string macros

#include <ntrpcp.h>     // Rpcp... function prototypes


#include <sclib.h>      // SC_INTERNAL_START_EVENT
#include <svcslib.h>    // CWorkItemContext
#include "scsec.h"      // Security object functions
#include "scconfig.h"   // ScInitSecurityProcess
#include "depend.h"     // ScAutoStartServices
#include "bootcfg.h"    // ScCheckLastKnownGood()
#include "account.h"    // ScInitServiceAccount
#include "info.h"       // ScGetBootAndSystemDriverState
#include "control.h"    // ScShutdownAllServices
#include "lockapi.h"    // ScLockDatabase
#include "scbsm.h"      // ScInitBSM
#include <svcsp.h>      // SVCS_RPC_PIPE, SVCS_LRPC_PROTOCOl, SVCS_LRPC_PORT
#include <winsvcp.h>    // SC_AUTOSTART_EVENT_NAME
#include <sddl.h>       // ConvertSidToStringSid
#include "resource.h"

extern "C" {

#include <cfgmgr32.h>
#include "cfgmgrp.h"
}

#include <scesrv.h>
#include <crypstub.h>   // StartCryptServiceStubs, StopCryptServiceStubs
#include <trkstub.h>    // StartTrkWksServiceStubs, StopTrkWksServiceStubs

//
// Macros:
//
//    IsServer         -- We're running on an NT server or DC
//    IsTerminalServer -- We're running Hydra
//
// Note that IsServer is not guaranteed to be accurate during GUI-mode setup since
// the product type may be changing during an upgrade.
//
#define IsServer()         (USER_SHARED_DATA->NtProductType != NtProductWinNt)
#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))

#define LENGTH(array)           (sizeof(array)/sizeof((array)[0]))

//
// The following turns on code that captures time info & displays it.
// To be used for performance analysis.
//
//#define TIMING_TEST 1

//
// Defines
//

#define SVCCTRL_SHUTDOWN_LEVEL  480
#define SCREG_BASE_PRIORITY     9

#define SERVICES_EXPANDPATH     L"%SystemRoot%\\system32\\services.exe"
#define SECURITY_EXPANDPATH     L"%SystemRoot%\\system32\\lsass.exe"


extern "C" typedef
NET_API_STATUS (NET_API_FUNCTION * PF_NetAlertRaiseEx) (
    IN LPCWSTR AlertEventName,
    IN LPVOID  VariableInfo,
    IN DWORD   VariableInfoSize,
    IN LPCWSTR ServiceName
    );



//===========================
// Globals
//===========================

    DWORD   ScShutdownInProgress  = FALSE;

    //
    // For determining if the service controller is still in its
    // initialization code.
    //
    BOOL    ScStillInitializing = TRUE;

    //
    // For the service controller to put up a popup to notify the first
    // logged on user if any boot, system, or auto start services failed
    // to start.
    //
    BOOL    ScPopupStartFail = FALSE;

#ifndef _CAIRO_
    //
    // Flag indicating whether or not NetLogon has been created, and we
    // have successfully connected to the Security Process .
    // If it hasn't then we need to look for it when it is created so that
    // we can synchronize with lsass appropriately.
    //
    BOOL    ScConnectedToSecProc = FALSE;
#endif // _CAIRO_

    //
    // Linked list of names of boot or system start drivers which failed
    // to load.  This list is logged to the eventlog.
    //
    LPFAILED_DRIVER ScFailedDrivers = NULL;
    DWORD ScTotalSizeFailedDrivers = 0;

    //
    // ScGlobalThisExePath gets initialized to the full path of where this
    // executable image is to be.  This is later used to create an image
    // record for services that run in the context of this process.
    //
    LPWSTR  ScGlobalThisExePath = NULL;

    //
    // ScGlobalSecurityExePath gets initialized to the full path of the
    // security process's executable image.  This is later used to
    // determine if we need to initialize the security proc when starting
    // services (i.e., initialize if we start the first SecProc service)
    //
    LPWSTR  ScGlobalSecurityExePath = NULL;

    //
    // ScGlobalProductType contains the product type for this machine.
    // Possiblilties are NtProductWinNt, NtProductLanManNt, NtProductServer.
    //
    NT_PRODUCT_TYPE ScGlobalProductType;

    //
    // Global variables used for safeboot support.  g_szSafebootKey contains
    // the name of the safeboot key (minus the service name, which is filled
    // in by ScStartService for each service in start.cxx).  g_dwSafebootLen
    // holds the length of the safeboot key name, minus the service name
    //
    WCHAR   g_szSafebootKey[SAFEBOOT_BUFFER_LENGTH] = SAFEBOOT_KEY;
    DWORD   g_dwSafebootLen;
    DWORD   g_SafeBootEnabled;

    //
    // Key handle for MPR provider change notification.  Do this in
    // the SCM so we can avoid loading 3 DLLs (needed for calling the
    // client side of the PNP HW profile APIs) into every process that
    // uses mpr.dll.
    //
    HKEY    g_hProviderKey;


//=================================
// prototypes
//=================================
BOOL
ScGetStartEvent(
    LPHANDLE    pScStartEvent
    );

VOID
ScPopupThread(
    DWORD StartFailFlag
    );

VOID
ScDestroyFailedDriverList(
    VOID
    );

DWORD
ScMakeFailedDriversOneString(
    LPWSTR *DriverList
    );

LONG
WINAPI
ScUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

NTSTATUS
SvcStartRPCProxys(
    VOID
    );

NTSTATUS
SvcStopRPCProxys(
    VOID
    );

NTSTATUS
ScCreateRpcEndpointSD(
    PSECURITY_DESCRIPTOR  *ppSD
    );


VOID
SvcctrlMain (
    int     argc,
    PCHAR   argv[]
    )

/*++

Routine Description:

    This is the main routine for the Service Controller.  It sets up
    the RPC interface.

Arguments:


Return Value:


Note:


--*/
{
    RPC_STATUS  status;
    NTSTATUS    ntStatus;
    DWORD       dwStatus;
    HANDLE      ScStartEvent;
    HANDLE      ThreadHandle;
    DWORD       ThreadId;
    SC_RPC_LOCK Lock=NULL;
    KPRIORITY   NewBasePriority   = SCREG_BASE_PRIORITY;
    HANDLE      AutoStartHandle   = NULL;
    HKEY        hKeySafeBoot;
    HANDLE      hProviderEvent    = NULL;


    //
    // Save bitwise flags to indicate the amount of initialization
    // work done so that if we hit an error along the way, the
    // appropriate amount of shutdown can occur.
    //
    DWORD ScInitState = 0;

    SetUnhandledExceptionFilter(&ScUnhandledExceptionFilter);


    //
    // Prevent critical errors from raising hard error popups and
    // halting services.exe.  The flag below will have the system
    // send the errors to the process instead.
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

#ifdef TIMING_TEST
    DWORD       TickCount1;
    DWORD       TickCount2;
    DWORD       TickCount3;

    TickCount1 = GetTickCount();
#endif // TIMING_TEST

    //
    // Create event that Service Controller will set when done starting all
    // Auto-Start services (including async devices).  If this call fails,
    // it typically means somebody tried to start up a second instance of
    // services.exe (which is running in the user's context, not LocalSystem).
    //
    AutoStartHandle = CreateEvent(
                        NULL,                       // Event Attributes
                        TRUE,                       // ManualReset
                        FALSE,                      // Initial State (not-signaled)
                        SC_AUTOSTART_EVENT_NAME);   // Name

    if (AutoStartHandle == NULL)
    {
        SC_LOG2(ERROR,
                "SvcctrlMain: CreateEvent( \"%ws\" ) failed %ld\n",
                SC_AUTOSTART_EVENT_NAME,
                GetLastError());

        goto CleanExit;
    }

    //
    // Create a string containing the pathname for this executable image
    // and one containing the pathname for the security proc image
    //
    {
        DWORD   NumChars = 0;
        DWORD   CharsReturned = 0;
        WCHAR   Temp[1];

        //
        // Create the string for this Exe
        //
        NumChars = ExpandEnvironmentStringsW(SERVICES_EXPANDPATH,Temp,1);

        if (NumChars > 1) {
            ScGlobalThisExePath = (LPWSTR)LocalAlloc(
                                    LPTR,
                                    NumChars * sizeof(WCHAR));
            if (ScGlobalThisExePath == NULL) {
                SC_LOG0(ERROR,"Couldn't allocate for ThisExePath\n");
                goto CleanExit;
            }

            CharsReturned = ExpandEnvironmentStringsW(
                                SERVICES_EXPANDPATH,
                                ScGlobalThisExePath,
                                NumChars);

            if (CharsReturned > NumChars) {
                SC_LOG0(ERROR,"Couldn't expand ThisExePath\n");
                goto CleanExit;
            }
        }

        //
        // Create the string for the security image
        //
        NumChars = ExpandEnvironmentStringsW(SECURITY_EXPANDPATH, Temp, 1);

        if (NumChars > 1) {

            ScGlobalSecurityExePath = (LPWSTR)LocalAlloc(LPTR,
                                                         NumChars * sizeof(WCHAR));

            if (ScGlobalSecurityExePath == NULL) {
                SC_LOG0(ERROR,"Couldn't allocate for SecurityExePath\n");
                goto CleanExit;
            }

            CharsReturned = ExpandEnvironmentStringsW(
                                SECURITY_EXPANDPATH,
                                ScGlobalSecurityExePath,
                                NumChars);

            if (CharsReturned > NumChars) {
                SC_LOG0(ERROR,"Couldn't expand SecurityExePath\n");
                goto CleanExit;
            }
        }
    }

    //
    // Create well-known SIDs
    //
    if (! NT_SUCCESS(ntStatus = ScCreateWellKnownSids())) {
        SC_LOG1(ERROR, "ScCreateWellKnownSids failed: %08lx\n", ntStatus);
        goto CleanExit;
    }
    ScInitState |= WELL_KNOWN_SIDS_CREATED;

    //
    // Set up the provider information for mpr.dll
    //
    dwStatus = ScRegOpenKeyExW(HKEY_LOCAL_MACHINE,
                               PROVIDER_KEY_BASE L"\\" PROVIDER_KEY_ORDER,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               &g_hProviderKey);

    if (dwStatus == NO_ERROR)
    {
        hProviderEvent = CreateEvent(NULL,
                                     TRUE,    // Manual-reset
                                     FALSE,   // Nonsignaled
                                     NULL);

        if (hProviderEvent != NULL)
        {
            ScHandleProviderChange(hProviderEvent, FALSE);
        }
        else
        {
            SC_LOG1(ERROR,
                    "SvcctrlMain: CreateEvent for provider event FAILED %d\n",
                    GetLastError());

            ScRegCloseKey(g_hProviderKey);
            g_hProviderKey = NULL;
        }
    }
    else
    {
        SC_LOG1(ERROR,
                "SvcctrlMain: Unable to open provider key %d\n",
                dwStatus);
    }

    //
    // Create the event that the OpenSCManager will use to wait on the
    // service controller with.
    //
    if (!ScGetStartEvent(&ScStartEvent)) {
        SC_LOG0(ERROR,"SvcctrlMain: ScGetStartEvent Failed\n");
        goto CleanExit;
    }

    ScInitState |= SC_NAMED_EVENT_CREATED;

    //
    // Create security descriptor for SC Manager object to protect
    // the SC Manager databases
    //
    if (ScCreateScManagerObject() != NO_ERROR) {
        SC_LOG0(ERROR, "ScCreateScManagerObject failed\n");
        goto CleanExit;
    }
    ScInitState |= SC_MANAGER_OBJECT_CREATED;

    //
    // Get the ProductType.
    //
    if (!RtlGetNtProductType(&ScGlobalProductType)) {
        SC_LOG0(ERROR, "GetNtProductType failed\n");
        goto CleanExit;
    }

    //
    // Check the Boot Configuration and assure that the LastKnownGood
    // ControlSet is safe, and pointers are correct.
    // This function initializes the ScGlobalLastKnownGood flag.
    //

    if (!ScCheckLastKnownGood()) {
        SC_LOG0(ERROR, "ScCheckLastKnownGood failed\n");
        goto CleanExit;
    }

    //
    // Initialize data structures required to remove a service account.
    // They will be cleaned up by ScEndServiceAccount.
    //
    // NOTE: ScGetComputerNameAndMutex must be called before call to
    // ScInitDatabase because ScInitDatabase may delete a service
    // entry that was marked for delete from a previous boot.
    //
    if (! ScGetComputerNameAndMutex()) {
        SC_LOG0(ERROR, "ScGetComputerName failed\n");
        goto CleanExit;
    }

    //
    // Read installed services into memory
    //
    if (! ScInitDatabase()) {
        SC_LOG0(ERROR, "ScInitDatabase failed\n");
        goto CleanExit;
    }
    ScInitState |= SC_DATABASE_INITIALIZED;

    //
    // Initialize accounts functionality.
    //

    if (! ScInitServiceAccount()) {
        SC_LOG0(ERROR, "ScInitServiceAccount failed\n");
        goto CleanExit;
    }

    //
    // Create critical sections
    //
    ScInitStartImage();
    ScInitTransactNamedPipe();
    ScInitState |= CRITICAL_SECTIONS_CREATED;

    if (!CWorkItemContext::Init()) {
        SC_LOG0(ERROR, "CWorkItemContext::Init failed\n");
        goto CleanExit;
    }


    //
    // look to see if we booted in safeboot mode
    //

    dwStatus = RegOpenKey(HKEY_LOCAL_MACHINE,
                          L"system\\currentcontrolset\\control\\safeboot\\option",
                          &hKeySafeBoot);

    if (dwStatus == ERROR_SUCCESS) {

        //
        // we did in fact boot under safeboot control
        //
        ThreadId = sizeof(DWORD);

        dwStatus = RegQueryValueEx(hKeySafeBoot,
                                   L"OptionValue",
                                   NULL,
                                   NULL,
                                   (LPBYTE)&g_SafeBootEnabled,
                                   &ThreadId);

        if (dwStatus != ERROR_SUCCESS) {
            g_SafeBootEnabled = 0;
        }

        RegCloseKey(hKeySafeBoot);

        if (g_SafeBootEnabled) {

            g_dwSafebootLen = (sizeof(SAFEBOOT_KEY) / sizeof(WCHAR)) - 1;

            switch (g_SafeBootEnabled) {
                case SAFEBOOT_MINIMAL:
                    wcscpy(g_szSafebootKey + g_dwSafebootLen, SAFEBOOT_MINIMAL_STR_W);
                    g_dwSafebootLen += (sizeof(SAFEBOOT_MINIMAL_STR_W) / sizeof(WCHAR)) - 1;
                    break;

                case SAFEBOOT_NETWORK:
                    wcscpy(g_szSafebootKey + g_dwSafebootLen, SAFEBOOT_NETWORK_STR_W);
                    g_dwSafebootLen += (sizeof(SAFEBOOT_NETWORK_STR_W) / sizeof(WCHAR)) - 1;
                    break;

                case SAFEBOOT_DSREPAIR:
                    wcscpy(g_szSafebootKey + g_dwSafebootLen, SAFEBOOT_DSREPAIR_STR_W);
                    g_dwSafebootLen += (sizeof(SAFEBOOT_DSREPAIR_STR_W) / sizeof(WCHAR)) - 1;
                    break;

                default:
                    SC_ASSERT(FALSE);
                    break;
            }

            wcscpy(g_szSafebootKey + g_dwSafebootLen, L"\\");
            g_dwSafebootLen += 1;
        }
    }

    //
    // Perform initialization related to network drive arrival broadcasts.
    // (This addes another work item to the object watcher work list.)
    //
    ScInitBSM();

    //
    // Get the latest state of drivers started up by boot and system
    // init.
    //
    ScGetBootAndSystemDriverState();

    //
    // Create semaphores needed for handling start dependencies
    //
    if (! ScInitAutoStart()) {
        SC_LOG0(ERROR, "ScInitAutoStart failed\n");
        goto CleanExit;
    }
    ScInitState |= AUTO_START_INITIALIZED;

    //
    // Register this process with User32.  This tells User32 to use the
    // value from HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control
    //  \WaitToKillServiceTimeout (if it exists), rather than
    // HKEY_CURRENT_USER\Control Panel\Desktop\WaitToKillAppTimeout,
    // to decide how long to wait before killing us on shutdown.
    //
    if (! RegisterServicesProcess(GetCurrentProcessId())) {
        SC_LOG0(ERROR, "RegisterServicesProcess failed\n");
    }

    //
    //  Lock the database until autostart is complete
    //
    status = ScLockDatabase(TRUE, SERVICES_ACTIVE_DATABASEW, &Lock);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScLockDatabase failed during init %d\n",status);
        goto CleanExit;
    }

    //
    // Start the RPC server
    //
    SC_LOG0(TRACE, "Getting ready to start RPC server\n");

    //
    // Listen to common LRPC port.
    //

    PSECURITY_DESCRIPTOR pSD;

    status = ScCreateRpcEndpointSD(&pSD);

    if (!NT_SUCCESS(status))
    {
        status = RtlNtStatusToDosError(status);

        SC_LOG1(ERROR,
                "SvcctrlMain:  ScCreateRpcEndpointSD failed %d\n",
                status);

        goto CleanExit;
    }

    status = RpcServerUseProtseqEp((unsigned short *)SVCS_LRPC_PROTOCOL,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   (unsigned short *)SVCS_LRPC_PORT,
                                   pSD);

    RtlDeleteSecurityObject(&pSD);
    pSD = NULL;

    if (status != RPC_S_OK)
    {
        SC_LOG1(ERROR, "RpcServerUseProtseqEp on LRPC failed: %d\n", status);
        goto CleanExit;
    }

    // Listen to named pipe endpoint and register interface.

    status = RpcpStartRpcServer(
                SVCS_RPC_PIPE,
                svcctl_ServerIfHandle);

    if (!NT_SUCCESS(status))
    {
        SC_LOG1(ERROR, "RpcpStartRpcServer: %lx\n",status);
        goto CleanExit;
    }

    ScInitState |= RPC_SERVER_STARTED;

    //
    // Signal the event that indicates that we are completely started.
    //
    if (!SetEvent(ScStartEvent))
    {
        SC_LOG1(ERROR, "Unable to set StartEvent: %d\n", GetLastError());
    }

    SC_LOG0(INFO,"Service Controller successfully initialized\n");

    //
    // Set up for proper shutdown.
    //

    if (!SetConsoleCtrlHandler(ScShutdownNotificationRoutine, TRUE))
    {
        SC_LOG1(ERROR, "SetConsoleCtrlHandler call failed %d\n",GetLastError());
    }

    if (!SetProcessShutdownParameters(SVCCTRL_SHUTDOWN_LEVEL, SHUTDOWN_NORETRY))
    {
        SC_LOG1(ERROR, "SetProcessShutdownParameters call failed %d\n",
        GetLastError());
    }

    SC_LOG0(TRACE,"** ** Service Controller can now accept shutdown system request\n");

    //
    // init SCE server. if it fails to intialize, the process will terminate
    //

    dwStatus = ScesrvInitializeServer(RpcpStartRpcServer);

    if (ERROR_SUCCESS != dwStatus)
    {
        //
        // event log is not up running yet.
        // just log a message to debugger
        // no need to shutdown services
        //
        SC_LOG(ERROR,"ScesrvInitializeServer failed to initialize! %lu\n", dwStatus);

        goto CleanExit;
    }

    //
    // Initialization is done, so give PnP a callback routine for them to call
    // when a service needs to receive a PnP event (callback in control.cxx) and
    // to validate a service calling RegisterDeviceNotification.
    //
    RegisterScmCallback(&ScSendPnPMessage, &ScValidatePnPService);

    SvcStartRPCProxys();

    //
    // Init the WMI events.
    //
    InitNCEvents();

    //
    // Auto-start services
    //
    dwStatus = ScAutoStartServices(&Lock);

    if (dwStatus != NO_ERROR)
    {
        SC_LOG1(ERROR,
                "SvcctrlMain:  ScAutoStartServices failed %d\n",
                dwStatus);

        goto CleanExit;
    }

    //
    // Log event if any boot/system start drivers failed.
    //
    if (ScFailedDrivers != NULL)
    {
        LPWSTR DriverList;

        ScMakeFailedDriversOneString(&DriverList);

        ScLogEvent(
            NEVENT_BOOT_SYSTEM_DRIVERS_FAILED,
            DriverList
            );

        LocalFree(DriverList);

        ScDestroyFailedDriverList();
    }

    //
    // Spin a thread to put up popup if a service specified to start
    // automatically at boot has failed to start, or we are running the
    // last-known-good configuration.
    //
    // Only popup a message if we're running on a server -- Workstation
    // users get confused by the message and don't know where to look
    // to figure out what went wrong.  Note that IsServer is not valid
    // during GUI-mode setup (the product type may be changing), but
    // the later call to SetupInProgress handles this.
    //
    // Don't popup any messages if we're booting into safe mode, since
    // several boot and system drivers are explicitly not started and
    // will result in a "false error" when the SCM notices they "failed"
    // to start.
    //
    // Don't popup any messages during setup/upgrade.  (The most common
    // cause of messages during upgrade is dependence on netlogon, which
    // is disabled.)
    //
    if ((ScPopupStartFail || (ScGlobalLastKnownGood & REVERTED_TO_LKG))
        &&
        IsServer()
        &&
        !g_SafeBootEnabled
        &&
        (! SetupInProgress(NULL, NULL))) {

        //
        // Suppress the popups if NoPopupsOnBoot is indicated in the registry.
        //
        DWORD   PopupStatus;
        BOOLEAN bPopups = TRUE;     // FALSE means suppress popups on boot
        HKEY    WindowsKey=NULL;

        PopupStatus = ScRegOpenKeyExW(
           HKEY_LOCAL_MACHINE,
           CONTROL_WINDOWS_KEY_W,
           REG_OPTION_NON_VOLATILE,   // options
           KEY_READ,                  // desired access
           &WindowsKey
           );

        if (PopupStatus == ERROR_SUCCESS) {

            DWORD Type;
            DWORD Data;
            DWORD cbData = sizeof(Data);

            PopupStatus = ScRegQueryValueExW(
                           WindowsKey,
                           NOBOOTPOPUPS_VALUENAME_W,
                           NULL,
                           &Type,
                           (LPBYTE) &Data,
                           &cbData
                           );

            //
            // Popups are suppressed if the NOBOOTPOPUPS_VALUENAME_W value is
            // present, is a REG_DWORD and is non-zero.
            //
            if (PopupStatus == ERROR_SUCCESS &&
                Type == REG_DWORD &&
                Data != 0) {

                bPopups = FALSE;
            }

            ScRegCloseKey(WindowsKey);
        }


        if (bPopups) {

            ThreadHandle = CreateThread(
                               NULL,
                               0L,
                               (LPTHREAD_START_ROUTINE) ScPopupThread,
                               (LPVOID)(DWORD_PTR) ScPopupStartFail,
                               0L,
                               &ThreadId
                               );

            if (ThreadHandle == (HANDLE) NULL) {
                SC_LOG(TRACE,"CreateThread ScPopupThread failed %lu\n",
                    GetLastError());

            }
            else {
                (void) CloseHandle(ThreadHandle);
            }
        }
    }

    //
    // Now we can allow database modifications from RPC callers.
    //
    ScUnlockDatabase(&Lock);

#ifdef TIMING_TEST
    TickCount2 = GetTickCount();
#endif

    //
    // Now switch to high priority class
    //
    (void) NtSetInformationProcess(
                NtCurrentProcess(),
                ProcessBasePriority,
                &NewBasePriority,
                sizeof(NewBasePriority));

    //
    // If we get this far, then from our point of view, the boot is
    // acceptable.  We will now call the Accept Boot Program.  This program
    // will decide whether or not the boot was good (from the administrators)
    // point of view.
    // Our default program simply says the boot was good - thus causing
    // LastKnownGood to be updated to the current boot.
    //
    ScRunAcceptBootPgm();

    //
    // Now that the Auto-start services have been started, notify
    // Terminal Server so that additional Sessions can be started.
    //
    if ( AutoStartHandle )
        NtSetEvent( AutoStartHandle, NULL );

    //
    // Setup complete -
    // This thread will become the service process watcher.  Service
    // process handles are stored in an array of waitble objects that
    // the watcher thread waits on.  When any ProcessHandle becomes
    // signaled while in this array, this indicates that the process has
    // terminated unexpectedly.  The watcher thread then cleans up the
    // service controller database.
    //
    ScStillInitializing = FALSE;

#ifdef TIMING_TEST
    TickCount3 = GetTickCount();
    DbgPrint("[SC_TIMING] Tick Count for autostart complete \t %d\n",TickCount2);
    DbgPrint("[SC-TIMING] MSec for Autostart:   \t%d\n",TickCount2-TickCount1);
    DbgPrint("[SC-TIMING] MSec for LKG work:    \t%d\n",TickCount3-TickCount2);
    DbgPrint("[SC-TIMING] MSec to complete init:\t%d\n",TickCount3-TickCount1);
#endif

    ExitThread(NO_ERROR);

CleanExit:

    //
    // Do minimal cleanup and let process cleanup take care of the rest.
    // Note that the full-blown cleanup was removed in January, 2000 as
    // it was for the most part unnecessary.  If some of it ends up being
    // needed, it should be available via the checkin history.
    //
    ScStillInitializing  = FALSE;

    ScEndServiceAccount();

    SvcStopRPCProxys();

    //
    // Shut down the RPC server.
    //
    SC_LOG0(TRACE,"Shutting down the RPC interface for the Service Controller\n");

    if (ScInitState & RPC_SERVER_STARTED)
    {
        status = RpcpStopRpcServer(svcctl_ServerIfHandle);
    }

    if (Lock != NULL)
    {
        ScUnlockDatabase(&Lock);
    }

    //
    // terminate SCE server
    //
    ScesrvTerminateServer( (PSVCS_STOP_RPC_SERVER) RpcpStopRpcServer );

    SC_LOG0(ERROR,"The Service Controller is Terminating.\n");

    ExitThread(0);

    return;
}

BOOL
ScShutdownNotificationRoutine(
    DWORD   dwCtrlType
    )

/*++

Routine Description:

    This routine is called by the system when system shutdown is occuring.

Arguments:



Return Value:



--*/
{
    if (dwCtrlType == CTRL_SHUTDOWN_EVENT) {

        SC_LOG0(TRACE,"  ! SHUTDOWN !  -  -  In ScShutdownNotificationRoutine\n");


#ifndef SC_DEBUG
        //
        // First quiet all RPC interfaces
        //


        ScShutdownInProgress = TRUE;
#endif

        //
        // Then shut down all services
        //
        SC_LOG0(TRACE,"[Shutdown] Begin Service Shutdown\n");
        ScShutdownAllServices();

    }
    return(TRUE);
}


VOID
ScLogControlEvent(
    DWORD   dwEvent,
    LPCWSTR lpServiceName,
    DWORD   dwControl
    )
/*++

Routine Description:

    Wrapper for logging service control events

Arguments:


Return Value:


--*/
{
    WCHAR  wszControlString[50];
    DWORD  dwStringBase;

    //
    // Load the string that corresponts to this control
    //

    switch (dwEvent)
    {
        case NEVENT_SERVICE_CONTROL_SUCCESS:
            dwStringBase = IDS_SC_CONTROL_BASE;
            break;

        case NEVENT_SERVICE_STATUS_SUCCESS:
            dwStringBase = IDS_SC_STATUS_BASE;
            break;

        case NEVENT_SERVICE_CONFIG_BACKOUT_FAILED:
            dwStringBase = 0;    // dwControl is the resource ID
            break;

        default:
            ASSERT(FALSE);
            return;
    }

    if (!LoadString(GetModuleHandle(NULL),
                    dwStringBase + dwControl,
                    wszControlString,
                    LENGTH(wszControlString)))
    {
        //
        // The control has no string associated with it
        // (i.e., not a control we log).
        //

        return;
    }

    if (dwEvent == NEVENT_SERVICE_CONTROL_SUCCESS)
    {
        //
        // Include the user that sent the control.  Use the empty
        // string on failure (better that than dropping the event).
        //

        PTOKEN_USER  pToken      = NULL;
        LPWSTR       lpStringSid = NULL;

        if (ScGetClientSid(&pToken) == NO_ERROR)
        {
            if (!ConvertSidToStringSid(pToken->User.Sid, &lpStringSid))
            {
                lpStringSid = NULL;
            }
        }
        else
        {
            pToken = NULL;
        }

        ScLogEvent(dwEvent,
                   lpServiceName,
                   wszControlString,
                   lpStringSid);

        LocalFree(lpStringSid);
        LocalFree(pToken);
    }
    else
    {
        ScLogEvent(dwEvent,
                   lpServiceName,
                   wszControlString);
    }
}


BOOL
ScGetStartEvent(
    LPHANDLE    pScStartEvent
    )

/*++

Routine Description:

    This function gets a handle to the SC_INTERNAL_START_EVENT that is
    used to wait on the service controller when calling OpenSCManager.

Arguments:

    pScStartEvent - This is a pointer to the location where the handle
        to the event is to be placed.

Return Value:

    TRUE    - If a handle was obtained.
    FALSE   - If a handle was not obtained.


--*/
{
    DWORD                   status;
    HANDLE                  ScStartEvent = NULL;
    SECURITY_ATTRIBUTES     SecurityAttributes;
    PSECURITY_DESCRIPTOR    SecurityDescriptor=NULL;

    //
    // Initialize the status so that if we fail to create the security
    // descriptor, we will still try to open the event.
    //
    status = ERROR_ALREADY_EXISTS;

    //
    // Create the event that the OpenSCManager will use to wait on the
    // service controller with.
    //

    status = ScCreateStartEventSD(&SecurityDescriptor);

    if (status == NO_ERROR) {

        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.bInheritHandle = FALSE;
        SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;

        ScStartEvent = CreateEventW(
                    &SecurityAttributes,
                    TRUE,                   // Must be manually reset
                    FALSE,                  // The event is initially not signalled
                    SC_INTERNAL_START_EVENT );

        if (ScStartEvent == NULL) {
            status = GetLastError();
        }
        LocalFree(SecurityDescriptor);
    }
    else {
        SC_LOG0(ERROR,"ScGetStartEvent: Couldn't allocate for SecurityDesc\n");
    }

    if (ScStartEvent == NULL){

        //
        // If the event already exists, some other process beat us to
        // creating it.  Just open it.
        //
        if ( status == ERROR_ALREADY_EXISTS ) {
            ScStartEvent = OpenEvent(
                            GENERIC_WRITE,
                            FALSE,
                            SC_INTERNAL_START_EVENT );
        }

        if (ScStartEvent == NULL ) {
            SC_LOG1(ERROR,"GetStartEvent: OpenEvent (StartEvent) Failed "
                    FORMAT_DWORD "\n", status);
            return(FALSE);
        }
    }
    *pScStartEvent = ScStartEvent;
    return(TRUE);
}

VOID
ScPopupThread(
    DWORD StartFailFlag
    )
/*++

Routine Description:

    This function reports the state of the system that has just booted.
    If we are running last-known-good:
        1) Raise an admin alert
        2) Put up a message box popup

    If a service has failed to start (StartFailFlag is TRUE):
        1) Put up a message box popup

    The reason the StartFailFlag is a parameter is because its value
    may change while we are in this thread.  We only care about
    its value at the time this thread is created.

Arguments:

    StartFailFlag - Supplies a flag which indicates whether to put
        up a popup due to services which failed to start.

Return Value:

    None.

--*/
{

#define POPUP_BUFFER_CHARS   256

    DWORD   MessageSize;
    HMODULE NetEventDll;
    WCHAR   Buffer[POPUP_BUFFER_CHARS];
    WCHAR   Title[POPUP_BUFFER_CHARS];
    LPWSTR  pTitle=NULL;

    HMODULE     NetApi32Dll = NULL;
    PF_NetAlertRaiseEx  ScNetAlertRaiseEx = NULL;
    KPRIORITY   NewBasePriority = SCREG_BASE_PRIORITY;


    if (ScGlobalLastKnownGood & REVERTED_TO_LKG) {
        //
        // Get address to API NetAlertRaiseEx to raise an Admin alert
        //
        NetApi32Dll = LoadLibraryW(L"netapi32.dll");

        if (NetApi32Dll != NULL) {
            ScNetAlertRaiseEx = (PF_NetAlertRaiseEx) GetProcAddress(
                                                 NetApi32Dll,
                                                 "NetAlertRaiseEx"
                                                 );

            if (ScNetAlertRaiseEx != NULL) {

                PADMIN_OTHER_INFO Admin;


                //
                // Raise an admin alert
                //
                Admin = (PADMIN_OTHER_INFO) Buffer;
                Admin->alrtad_errcode = ALERT_SC_IsLastKnownGood;
                Admin->alrtad_numstrings = 0;

                (void) ScNetAlertRaiseEx(
                           ALERT_ADMIN_EVENT,
                           Buffer,
                           sizeof(ADMIN_OTHER_INFO),
                           SCM_NAMEW
                           );

            }

            FreeLibrary(NetApi32Dll);
        }
    }

    NetEventDll = LoadLibraryW(L"netevent.dll");

    if (NetEventDll == NULL) {
        return;
    }

    MessageSize = FormatMessageW(
                      FORMAT_MESSAGE_FROM_HMODULE,
                      (LPVOID) NetEventDll,
                      TITLE_SC_MESSAGE_BOX,
                      0,
                      Title,
                      POPUP_BUFFER_CHARS,
                      NULL
                      );

    if (MessageSize == 0 ) {
        pTitle = SCM_NAMEW;
    }
    else {
        pTitle = Title;
    }

    if (ScGlobalLastKnownGood & REVERTED_TO_LKG) {

        MessageSize = FormatMessageW(
                          FORMAT_MESSAGE_FROM_HMODULE,
                          (LPVOID) NetEventDll,
                          EVENT_RUNNING_LASTKNOWNGOOD,
                          0,
                          Buffer,
                          POPUP_BUFFER_CHARS,
                          NULL
                          );

        if (MessageSize != 0) {

            (void) MessageBoxW(
                       NULL,
                       Buffer,
                       pTitle,
                       MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION |
                            MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION
                       );
            //
            // Now switch back to proper priority
            //
            NtSetInformationProcess(NtCurrentProcess(),
                                    ProcessBasePriority,
                                    &NewBasePriority,
                                    sizeof(NewBasePriority));
        }
        else {
            SC_LOG1(TRACE, "FormatMessage failed %lu\n", GetLastError());
        }

    }

    //
    // Popup a message if a service failed to start
    //
    if (StartFailFlag) {

        MessageSize = FormatMessageW(
                          FORMAT_MESSAGE_FROM_HMODULE,
                          (LPVOID) NetEventDll,
                          EVENT_SERVICE_START_AT_BOOT_FAILED,
                          0,
                          Buffer,
                          POPUP_BUFFER_CHARS,
                          NULL
                          );

        if (MessageSize != 0) {

            MessageBoxW(NULL,
                        Buffer,
                        pTitle,
                        MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION |
                             MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION);

            //
            // Now switch back to proper priority
            //

            NtSetInformationProcess(NtCurrentProcess(),
                                    ProcessBasePriority,
                                    &NewBasePriority,
                                    sizeof(NewBasePriority));
        }
        else {
            SC_LOG1(TRACE, "FormatMessage failed %lu\n", GetLastError());
        }
    }

    FreeLibrary(NetEventDll);

    //
    // Now switch to high priority class
    //

    ExitThread(0);
}


DWORD
ScAddFailedDriver(
    LPWSTR Driver
    )
{
    DWORD StrSize = (DWORD) WCSSIZE(Driver);
    LPFAILED_DRIVER NewEntry;
    LPFAILED_DRIVER Entry;


    NewEntry = (LPFAILED_DRIVER) LocalAlloc(
                           LMEM_ZEROINIT,
                           (UINT) sizeof(FAILED_DRIVER) + StrSize
                           );

    if (NewEntry == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Each string will be separated from the previous one a CR and
    // LF character.  We already included one for NULL terminator of each
    // driver so add one more.
    //
    ScTotalSizeFailedDrivers += StrSize + sizeof(WCHAR);

    wcscpy((LPWSTR) NewEntry->DriverName, Driver);

    //
    // Insert new entry into ScFailedDrivers global list
    //

    //
    // Special case empty list
    //
    if (ScFailedDrivers == NULL) {
        ScFailedDrivers = NewEntry;
        return NO_ERROR;
    }

    //
    // Otherwise look for end of the list and insert new entry
    //
    Entry = ScFailedDrivers;

    while (Entry->Next != NULL) {
        Entry = Entry->Next;
    }

    Entry->Next = NewEntry;

    return NO_ERROR;
}


VOID
ScDestroyFailedDriverList(
    VOID
    )
{
    LPFAILED_DRIVER DeleteEntry;


    while (ScFailedDrivers != NULL) {
        DeleteEntry = ScFailedDrivers;
        ScFailedDrivers = ScFailedDrivers->Next;
        LocalFree(DeleteEntry);
    }
}


DWORD
ScMakeFailedDriversOneString(
    LPWSTR *DriverList
    )
{
    LPFAILED_DRIVER Entry = ScFailedDrivers;


    //
    // Allocate space for concatenated string of all the drivers that
    // failed plus the terminator character.
    //
    *DriverList = (LPWSTR) LocalAlloc(
                              LMEM_ZEROINIT,
                              (UINT) ScTotalSizeFailedDrivers + sizeof(WCHAR)
                              );

    if (*DriverList == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    while (Entry != NULL) {
        wcscat(*DriverList, L"\r\n");
        wcscat(*DriverList, (LPWSTR) Entry->DriverName);
        Entry = Entry->Next;
    }

    return NO_ERROR;
}


LONG
WINAPI
ScUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    return RtlUnhandledExceptionFilter(ExceptionInfo);
}


NTSTATUS
SvcStartRPCProxys(
    VOID
    )

/*++

Routine Description:

    This function calls the RPC Proxy startup routines for the
    services that were moved out of services.exe, but have existing
    clients that rely on the services.exe named pipe

Arguments:


Return Value:

    STATUS_SUCCESS - If proxys were started


--*/
{
    NTSTATUS dwStatus = STATUS_SUCCESS;

    dwStatus = StartCryptServiceStubs(RpcpStartRpcServer,
                                      SVCS_RPC_PIPE);

    // Start the RPC stubs for the distributed link tracking client service.
    dwStatus = StartTrkWksServiceStubs( RpcpStartRpcServer,
                                        SVCS_RPC_PIPE );

    return dwStatus;
}


NTSTATUS
SvcStopRPCProxys(
    VOID
    )

/*++

Routine Description:

    This function calls the RPC Proxy startup routines for the
    services that were moved out of services.exe, but have existing
    clients that rely on the services.exe named pipe

Arguments:


Return Value:

    STATUS_SUCCESS - If proxys were started


--*/
{
    NTSTATUS dwStatus = STATUS_SUCCESS;

    dwStatus = StopCryptServiceStubs(RpcpStopRpcServer);

    // Stop the RPC stubs for the distributed link tracking client service.
    dwStatus = StopTrkWksServiceStubs(RpcpStopRpcServer);

    return dwStatus;
}


NTSTATUS
ScCreateRpcEndpointSD(
    PSECURITY_DESCRIPTOR  *ppSD
    )

/*++

Routine Description:

    This function builds a security descriptor for the SCM's
    shared LPC endpoint.  Everybody needs access to call it.

Arguments:

    ppSD -- pointer to an SD that this routine will allocate

Return Value:

    STATUS_SUCCESS - if SD was successfully created


--*/
{

#define SC_ENDPOINT_ACECOUNT    3

    SC_ACE_DATA AceData[SC_ENDPOINT_ACECOUNT] = {
        { ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                GENERIC_ALL,
                &LocalSystemSid },

        { ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                GENERIC_ALL,
                &AliasAdminsSid },

        { ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                GENERIC_READ | GENERIC_WRITE |
                    GENERIC_EXECUTE | SYNCHRONIZE,
                &WorldSid }
        };

    return ScCreateAndSetSD(AceData,
                            SC_ENDPOINT_ACECOUNT,
                            NULL,                  // owner
                            NULL,                  // group
                            ppSD);

#undef SC_ENDPOINT_ACECOUNT

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\simservice\service.cxx ===
#include <nt.h>
#include <ntrtl.h>   // DbgPrint prototype
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <winsvc.h>
#include <winsvcp.h>

#include <winuser.h>
#include <dbt.h>

#include <crtdbg.h>

//
// Definitions
//

#define LOG0(string)                    \
        (VOID) DbgPrint(" [SCM] " string);

#define LOG1(string, var)               \
        (VOID) DbgPrint(" [SCM] " string,var);

#define LOG2(string, var1, var2)        \
        (VOID) DbgPrint(" [SCM] " string,var1,var2);


//
// Test fix for bug #106110
//
// #define     FLOOD_PIPE
//

//
// Test fix for bug #120359
//
static const GUID GUID_NDIS_LAN_CLASS =
    {0xad498944,0x762f,0x11d0,{0x8d,0xcb,0x00,0xc0,0x4f,0xc3,0x35,0x8c}};


//
// Globals
//
SERVICE_STATUS          ssService;
SERVICE_STATUS_HANDLE   hssService;
HANDLE                  g_hEvent;


VOID WINAPI
ServiceStart(
    DWORD argc,
    LPTSTR *argv
    );

VOID WINAPI
ServiceCtrlHandler(
    DWORD   Opcode
    )
{
    switch(Opcode)
    {
        case SERVICE_CONTROL_SESSIONCHANGE:
            break;

        case SERVICE_CONTROL_PAUSE:
            ssService.dwCurrentState = SERVICE_PAUSED;
            LOG0("Service paused\n");
            break;

        case SERVICE_CONTROL_CONTINUE:
            ssService.dwCurrentState = SERVICE_RUNNING;
            LOG0("Service continuing\n");
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            LOG0("Shutdown command received\n");

            //
            // Fall through to STOP case
            //

        case SERVICE_CONTROL_STOP:
            ssService.dwWin32ExitCode = 0;
            ssService.dwCurrentState  = SERVICE_STOP_PENDING;
            ssService.dwCheckPoint    = 0;
            ssService.dwWaitHint      = 0;
            break;

        case SERVICE_CONTROL_INTERROGATE:
            LOG0("Service interrogated\n");
            break;

        case 251:
        {
            DWORD  dwError;
            DWORD  dwTest = 0xabcdefab;

            //
            // Try a bad address
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_SESSIONCHANGE,
                                        0,
                                        0,
                                        NULL);

            LOG1("I_ScSendTSMessage with NULL pointer returned %d\n", dwError);


            //
            // Try a bad control
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_STOP,
                                        0,
                                        sizeof(DWORD),
                                        (LPBYTE) &dwTest);

            LOG1("I_ScSendTSMessage for SERVICE_CONTROL_STOP returned %d\n", dwError);

            //
            // Now try for real
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_SESSIONCHANGE,
                                        0,
                                        sizeof(DWORD),
                                        (LPBYTE) &dwTest);

            LOG1("I_ScSendTSMessage (real call) returned %d\n", dwError);

            break;
        }

        case 252:
        {
            DEV_BROADCAST_DEVICEINTERFACE dbdPnpFilter;

            //
            // Test fix for bug #120359
            //
            ssService.dwCurrentState = SERVICE_STOPPED;

            //
            // Eventlog's SERVICE_STATUS_HANDLE when I checked
            //
            if (!SetServiceStatus((SERVICE_STATUS_HANDLE)0x96df8, &ssService))
            {
                LOG1("Fix works -- SetServiceStatus error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- SetServiceStatus call succeeded!\n");
            }

            //
            // Eventlog's LPSERVICE_RECORD when I checked
            //
            if (!SetServiceStatus((SERVICE_STATUS_HANDLE)0x4844e8, &ssService))
            {
                LOG1("Fix works -- SetServiceStatus error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- SetServiceStatus call succeeded!\n");
            }

            //
            // SERVICE_STATUS_HANDLE again
            //

            ZeroMemory (&dbdPnpFilter, sizeof(dbdPnpFilter));
            dbdPnpFilter.dbcc_size         = sizeof(dbdPnpFilter);
            dbdPnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
            dbdPnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

            if (!RegisterDeviceNotification((SERVICE_STATUS_HANDLE)0x96df8,
                                            &dbdPnpFilter,
                                            DEVICE_NOTIFY_SERVICE_HANDLE))
            {
                LOG1("Fix works -- RegisterDeviceNotification error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- RegisterDeviceNotification call succeeded!\n");
            }

            ssService.dwCurrentState = SERVICE_RUNNING;
            break;
        }

        case 253:
        {
            //
            // Test fix for bug #36395.  Make sure that we inherited the
            // environment block of the user, not the system.  NOTE this
            // assumes the service is running in an account AND the
            // variable we're looking for is in the user's environment.
            //

            CHAR    cTemp[1];
            DWORD   dwCount = GetEnvironmentVariable("User_specific_variable",
                                                     cTemp,
                                                     sizeof(cTemp));

            LOG1("GetEnvironmentVariable on User_specific_variable %ws\n",
                 (dwCount == 0 ? L"FAILED!" : L"succeeded"));

            break;
        }

        case 254:
        {
            //
            // Test client-side API for #120359 fix
            //
            WCHAR                  wszServiceName[256 + 1];
            DWORD                  dwError;
            
            dwError = I_ScPnPGetServiceName(hssService, wszServiceName, 256);

            if (dwError == NO_ERROR)
            {
                LOG0("I_ScPnPGetServiceName succeeded for valid handle\n");
                LOG1("ServiceName is %ws\n", wszServiceName);
            }
            else
            {
                LOG0("I_ScPnPGetServiceName failed for valid handle!\n");
                LOG1("Error was %d\n", dwError);
            }

            dwError = I_ScPnPGetServiceName(NULL, wszServiceName, 256);

            if (dwError == NO_ERROR)
            {
                LOG0("I_ScPnPGetServiceName succeeded for NULL handle!\n");
                LOG1("ServiceName is %ws\n", wszServiceName);
            }
            else
            {
                LOG0("I_ScPnPGetServiceName failed for NULL handle!\n");
                LOG1("Error was %d\n", dwError);
            }

            break;
        }

        case 255:

            //
            // Print controls to the debugger
            //
            LOG0("Controls supported:\n");
            LOG0("\t251:\tTry calling I_ScSendTSMessage\n");
            LOG0("\t252:\tTry calling SetServiceStatus with a bogus status handle\n");
            LOG0("\t253:\tCheck service environment for %%User_specific_variable%%\n");
            LOG0("\t254:\tTest I_ScPnPGetServiceName on valid and invalid handles\n");
            break;

        default:
            LOG1("Unrecognized opcode %ld\n", Opcode);
    }

    if (!SetServiceStatus(hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    if (Opcode == SERVICE_CONTROL_STOP || Opcode == SERVICE_CONTROL_SHUTDOWN)
    {
        SetEvent(g_hEvent);
    }

    return;
}


VOID WINAPI
ServiceStart(
    DWORD argc,
    LPTSTR *argv
    )
{
    g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hEvent == NULL)
    {
        LOG1("CreateEvent error = %d\n", GetLastError());
        return;
    }

    ssService.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    ssService.dwCurrentState            = SERVICE_START_PENDING;
    ssService.dwControlsAccepted        = SERVICE_ACCEPT_STOP |
                                            SERVICE_ACCEPT_SHUTDOWN |
                                            SERVICE_ACCEPT_POWEREVENT |
                                            SERVICE_ACCEPT_HARDWAREPROFILECHANGE |
                                            SERVICE_ACCEPT_SESSIONCHANGE;
    ssService.dwWin32ExitCode           = 0;
    ssService.dwServiceSpecificExitCode = 0;
    ssService.dwCheckPoint              = 0;
    ssService.dwWaitHint                = 0;

    hssService = RegisterServiceCtrlHandler(TEXT("simservice"),
                                            ServiceCtrlHandler);

    if (hssService == (SERVICE_STATUS_HANDLE)0)
    {
        LOG1("RegisterServiceCtrlHandler failed %d\n", GetLastError());
        return;
    }

    //
    // Initialization complete - report running status.
    //
    ssService.dwCurrentState       = SERVICE_RUNNING;
    ssService.dwCheckPoint         = 0;
    ssService.dwWaitHint           = 0;

    LOG0("Initialized and running\n");
    LOG1("PID is %d\n", GetCurrentProcessId());
    LOG1("TID is %d\n", GetCurrentThreadId());

    if (!SetServiceStatus (hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    WaitForSingleObject(g_hEvent, INFINITE);

    ssService.dwCurrentState       = SERVICE_STOPPED;
    ssService.dwCheckPoint         = 0;
    ssService.dwWaitHint           = 0;

    if (!SetServiceStatus (hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    LOG0("Returning the Main Thread\n");

    return;
}


int __cdecl main( )
{
    SERVICE_TABLE_ENTRY   DispatchTable[] =
    {
        { TEXT("simservice"),     ServiceStart    },
        { NULL,                   NULL            }
    };

#ifdef  FLOOD_PIPE

    LOG1("Service PID is %d\n", GetCurrentProcessId());
    LOG0("Sleeping for 20 seconds\n");

    Sleep(20000);

#endif  // FLOOD_PIPE

    if (!StartServiceCtrlDispatcher(DispatchTable))
    {
        LOG1("StartServiceCtrlDispatcher error = %d\n", GetLastError());
    }
 
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\status.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    status.cxx

Abstract:

    This file contains functions that are involved with setting the
    status for a service in the service controller.

        RSetServiceStatus
        RemovalThread
        RI_ScSetServiceBitsA
        RI_ScSetServiceBitsW
        ScRemoveServiceBits
        ScInitServerAnnounceFcn

Author:

    Dan Lafferty (danl)     20-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    10-Mar-1998     jschwart
        Add code to RSetServiceStatus to notify Plug-and-Play when a service
        registers/deregisters for hardware profile change notifications.

    08-Jan-1997     anirudhs
        RSetServiceStatus: Fix obscure locking bugs found by the new locking
        scheme.  When a service stops, we sometimes need more restrictive
        locks than was previously assumed.

    11-Apr-1996     anirudhs
        RSetServiceStatus: Notify NDIS when a service that belongs to a
        group NDIS is interested in starts running.

    21-Nov-1995     anirudhs
        RI_ScSetServiceBitsW: Catch access violations caused if the
        hServiceStatus parameter is invalid.

    23-Mar-1994     danl
        RSetServiceStatus:  Only set the PopupStartFail flag when we have
        actually logged an event.  This means that now an auto-started service
        can quietly stop itself without reporting an exit code, and we will not
        log an event or put up a popup.
        However, we will still put up a popup if a service stops itself during
        auto-start, and it provides an exit code.

    20-Oct-1993     danl
        RSetServiceStatus: Only update the status if the service process is
        still running.  It is possible that the status could have been blocked
        when the process unexpectedly terminated, and updated the status to
        stopped.  In this case, the status that was blocked contains
        out-of-date information.

    10-Dec-1992     danl
        RI_ScSetServiceBitsW & ScRemoveServiceBits no longer hold locks when
        calling ScNetServerSetServiceBits.

    03-Nov-1992     danl
        RSetServiceStatus: Remove code that sets ExitCode to ERROR_GEN_FAILURE
        when a service transitions directly from START_PENDING to STOPPED with
        out an exit code of its own.

    25-Aug-1992     danl
        RSetServiceStatus: Allow dirty checkpoint and exitcode fields.
        Force them clean.

    19-Jun-1991     danl
        Allow ExitCodes to be specified for the SERVICE_STOP_PENDING state.
        Prior to this they were only allowed for the SERVICE_STOP state.

    20-Mar-1991     danl
        created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <tstr.h>       // Unicode string macros

#include "valid.h"      // ScCurrentStateInvalid
#include "depend.h"     // ScNotifyChangeState
#include "driver.h"     // ScNotifyNdis

#include <lmcons.h>     // NET_API_STATUS
#include <lmerr.h>      // NERR_Success
#include <lmsname.h>    // contains service name
#include <lmserver.h>   // SV_TYPE_NT (server announcement bits)
#include <srvann.h>     // I_NetServerSetServiceBits

#include "control.h"    // SERVICE_SET_STATUS

extern "C" {

#include <cfgmgr32.h>
#include "cfgmgrp.h"

}

//
// GLOBALS
//
    //
    // This is a special storage place for the OR'd server announcement
    // bit masks.  NOTE:  This is only read or written to when the
    // service database exclusive lock is held.
    //
    DWORD   GlobalServerAnnounce = SV_TYPE_NT;


    //
    // The following ServerHandle is the handle returned from the
    // LoadLibrary call which loaded netapi.dll.  The entrypoint for
    // I_NetServerSetServiceBits is then found and stored in the
    // global location described below.
    //
    HMODULE ScGlobalServerHandle;

    extern "C" typedef NET_API_STATUS (*SETSBPROC) (
                IN  LPTSTR  servername,
                IN  LPTSTR  transport OPTIONAL,
                IN  DWORD   servicebits,
                IN  DWORD   updateimmediately
                );

    SETSBPROC ScNetServerSetServiceBits = NULL;


//
//  Function Prototypes (local functions)
//

DWORD
RemovalThread(
    IN  LPSERVICE_RECORD    ServiceRecord
    );



DWORD
RSetServiceStatus(
    IN  SC_RPC_HANDLE      hService,
    IN  LPSERVICE_STATUS   lpServiceStatus
    )

/*++

Routine Description:

    This function is called by services when they need to inform the
    service controller of a change in state.

Arguments:

    hService - A service handle that has been given to the service
        with SERVICE_SET_STATUS access granted.

    lpServiceStatus - A pointer to a SERVICE_STATUS structure.  This
        reflects the latest status of the calling service.

Return Value:

    ERROR_INVALID_HANDLE - The specified handle is invalid.

    ERROR_INVALID_SERVICE_STATUS - The specified service status is invalid.

Note:


--*/
{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    serviceRecord;
    LPSERVICE_RECORD    hServiceStatus;
    DWORD               threadId;
    HANDLE              threadHandle;
    DWORD               oldState;
    DWORD               oldType;
    BOOL                groupListLocked = FALSE;


    SC_LOG(TRACE,"In RSetServiceStatus routine\n",0);

    //
    // Check the handle.
    //

    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    if (((LPSC_HANDLE_STRUCT)hService)->AccessGranted != SERVICE_SET_STATUS)
    {
        return(ERROR_INVALID_HANDLE);
    }

    hServiceStatus = ((LPSC_HANDLE_STRUCT) hService)->Type.ScServiceObject.ServiceRecord;

    //
    // Validate the fields in the service status structure.
    //

    if (ScCurrentStateInvalid(lpServiceStatus->dwCurrentState))
    {
        SC_LOG2(ERROR, "RSetServiceStatus: " FORMAT_LPWSTR " set invalid "
                       " dwCurrentState x%08lx\n",
                ((LPSERVICE_RECORD) hServiceStatus)->DisplayName,
                lpServiceStatus->dwCurrentState);

        ScLogEvent(
            NEVENT_BAD_SERVICE_STATE,
            ((LPSERVICE_RECORD) hServiceStatus)->DisplayName,
            lpServiceStatus->dwCurrentState
            );

        return(ERROR_INVALID_DATA);
    }


    if( (SERVICE_STATUS_TYPE_INVALID(lpServiceStatus->dwServiceType))    ||
        (CONTROLS_ACCEPTED_INVALID(lpServiceStatus->dwControlsAccepted)) )
    {
        SC_LOG3(ERROR,
                "RSetServiceStatus: Error in one of the following for service %ws\n"
                     "\tServiceType       %#x\n"
                     "\tControlsAccepted  %#x\n",
                ((LPSERVICE_RECORD) hServiceStatus)->DisplayName,
                lpServiceStatus->dwServiceType,
                lpServiceStatus->dwControlsAccepted);

        return(ERROR_INVALID_DATA);
    }

    //
    // If the service is not in the stopped or stop-pending state, then the
    // exit code fields should be 0.
    //
    if (((lpServiceStatus->dwCurrentState != SERVICE_STOPPED) &&
         (lpServiceStatus->dwCurrentState != SERVICE_STOP_PENDING))

          &&

         ((lpServiceStatus->dwWin32ExitCode != 0) ||
          (lpServiceStatus->dwServiceSpecificExitCode != 0))  )
    {
        SC_LOG(TRACE,"RSetServiceStatus: ExitCode fields not cleaned up "
            "when state indicates SERVICE_STOPPED\n",0);

        lpServiceStatus->dwWin32ExitCode = 0;
        lpServiceStatus->dwServiceSpecificExitCode = 0;
    }

    //
    // If the service is not in a pending state, then the waitHint and
    // checkPoint fields should be 0.
    //
    if ( ( (lpServiceStatus->dwCurrentState == SERVICE_STOPPED) ||
           (lpServiceStatus->dwCurrentState == SERVICE_RUNNING) ||
           (lpServiceStatus->dwCurrentState == SERVICE_PAUSED)  )
         &&
         ( (lpServiceStatus->dwCheckPoint != 0) ||
           (lpServiceStatus->dwWaitHint   != 0) )   )
    {
        SC_LOG(TRACE,"RSetServiceStatus: Dirty Checkpoint and WaitHint fields\n",0);
        lpServiceStatus->dwCheckPoint = 0;
        lpServiceStatus->dwWaitHint   = 0;
    }


    //
    // If the service has stopped, ScRemoveServiceBits needs the service
    // list lock with shared access.
    //
    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED)
    {
        ScServiceListLock.GetShared();
    }

    //
    // Update the service record.  Exclusive locks are required for this.
    //
    // NOTICE that we don't destroy the ServiceType information that was
    // in the service record.
    //
    serviceRecord = (LPSERVICE_RECORD)hServiceStatus;

    SC_LOG(TRACE,"RSetServiceStatus:  Status field accepted, service %ws\n",
           serviceRecord->ServiceName);

    ScServiceRecordLock.GetExclusive();

    //
    // If the service stopped, and its update flag is set (its config was
    // changed while it was running) we may need the group list lock in
    // ScRemoveService.  So release the locks and reacquire them after
    // getting the group list lock.  This is a rare occurrence, hence not
    // optimized.
    //
    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED &&
        UPDATE_FLAG_IS_SET(serviceRecord))
    {
        ScServiceRecordLock.Release();
        ScServiceListLock.Release();

        ScGroupListLock.GetExclusive();
        ScServiceListLock.GetShared();
        ScServiceRecordLock.GetExclusive();
        groupListLocked = TRUE;
    }

    oldState = serviceRecord->ServiceStatus.dwCurrentState;
    oldType  = serviceRecord->ServiceStatus.dwServiceType;


    //
    // It is possible that while we were blocked waiting for the lock,
    // that a running service could have terminated (Due to the process
    // terminating).  So we need to look for "late" status updates, and
    // filter them out.  If the ImageRecord pointer is NULL, then the
    // Service has Terminated.  Otherwise update the status.
    //
    if (serviceRecord->ImageRecord != NULL)
    {
        //
        // Don't bother notifying PnP if the system is shutting down.  This
        // prevents a deadlock where we can get stuck calling PnP, which is
        // stuck calling into the Eventlog, which is stuck calling into us.
        // 
        if (!ScShutdownInProgress)
        {
            DWORD dwControlFlags;
            DWORD dwBitMask;

            dwControlFlags = serviceRecord->ServiceStatus.dwControlsAccepted
                              &
                             (SERVICE_ACCEPT_HARDWAREPROFILECHANGE |
                                 SERVICE_ACCEPT_POWEREVENT);

            dwBitMask = lpServiceStatus->dwControlsAccepted ^ dwControlFlags;

            if (dwBitMask
                 ||
                ((lpServiceStatus->dwCurrentState == SERVICE_STOPPED) && dwControlFlags))
            {
                DWORD   dwRetVal;

                //
                // The service is either changing its registration status for
                // hardware profile change notifications or power OR is stopping,
                // so inform PnP of this.  On service stop, deregister the service
                // if it accepts power or hardware profile change notifications.
                //
                dwRetVal = RegisterServiceNotification(
                               (SERVICE_STATUS_HANDLE)hServiceStatus,
                               serviceRecord->ServiceName,
                               lpServiceStatus->dwCurrentState != SERVICE_STOPPED ?
                                       lpServiceStatus->dwControlsAccepted : 0,
                               (lpServiceStatus->dwCurrentState == SERVICE_STOPPED));

                if (dwRetVal != CR_SUCCESS)
                {
                    SC_LOG3(ERROR,
                           "Hardware profile change and power %sregistration failed "
                               "for service %ws with config manager error %d\n",
                           (lpServiceStatus->dwControlsAccepted &
                               (SERVICE_ACCEPT_HARDWAREPROFILECHANGE |
                                    SERVICE_ACCEPT_POWEREVENT)) ?
                                   "" :
                                   "de",
                           serviceRecord->ServiceName,
                           dwRetVal);
                }
            }
        }

        //
        // Update to the new status
        //
        RtlCopyMemory(&(serviceRecord->ServiceStatus),
                      lpServiceStatus,
                      sizeof(SERVICE_STATUS));

        serviceRecord->ServiceStatus.dwServiceType = oldType;
    }

    //
    // For dependency handling
    //
    if ((serviceRecord->ServiceStatus.dwCurrentState == SERVICE_RUNNING ||
         serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOPPED ||
         serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) &&
        oldState == SERVICE_START_PENDING)
    {
        if (serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOPPED ||
            serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
        {
            serviceRecord->StartState = SC_START_FAIL;
            SC_LOG(DEPEND, "%ws START_PENDING -> FAIL\n", serviceRecord->ServiceName);
        }
        else if (serviceRecord->ServiceStatus.dwCurrentState == SERVICE_RUNNING)
        {
            serviceRecord->StartState = SC_START_SUCCESS;
            SC_LOG(DEPEND, "%ws START_PENDING -> RUNNING\n", serviceRecord->ServiceName);
#ifdef TIMING_TEST
            DbgPrint("[SC_TIMING] TickCount for RUNNING service \t%ws\t%d\n",
            serviceRecord->ServiceName, GetTickCount());
#endif // TIMING_TEST
        }

        //
        // Tell the dependency handling code that a start-pending
        // service is now running or stopped.
        //
        ScNotifyChangeState();
    }

    //
    // Note:  We no longer need an exclusive lock on the service records,
    // but we still need at least a shared lock, since we read the
    // DisplayName and ErrorControl fields below.  (If we didn't have a
    // shared lock, ChangeServiceConfig could change the fields under
    // us.)  Later, we call ScRemoveServiceBits and ScRemoveService,
    // which acquire an exclusive lock, which is problematic if we
    // already have a shared lock.
    // To keep things simple, we just hold onto the exclusive lock.
    //

    //
    // Log an event about the service's new state if appropriate.  Don't
    // do this during auto-start to avoid hurting boot performance and
    // filling the log with a start event for every auto-start service.
    //
    if (!ScAutoStartInProgress
         &&
        lpServiceStatus->dwCurrentState != oldState
         &&
        IS_STATUS_LOGGABLE(lpServiceStatus->dwCurrentState))
    {
        ScLogControlEvent(NEVENT_SERVICE_STATUS_SUCCESS,
                          serviceRecord->DisplayName,
                          lpServiceStatus->dwCurrentState);
    }


    //
    // If the new status indicates that the service has just started,
    // tell NDIS to issue the PNP notifications about this service's arrival,
    // if it belongs to one of the groups NDIS is interested in.
    //
    if ((lpServiceStatus->dwCurrentState == SERVICE_RUNNING) &&
        (oldState != SERVICE_RUNNING))
    {
        ScNotifyNdis(serviceRecord);
    }

    //
    // If the new status indicates that the service has just stopped,
    // we need to check to see if there are any other services running
    // in the service process.  If not, then we can ask the service to
    // terminate.  Another thread is spawned to handle this since we need
    // to return from this call in order to allow the service to complete
    // its shutdown.
    //

    else if ((lpServiceStatus->dwCurrentState == SERVICE_STOPPED) &&
        (oldState != SERVICE_STOPPED))
    {
        if (lpServiceStatus->dwWin32ExitCode != NO_ERROR)
        {
            if (lpServiceStatus->dwWin32ExitCode != ERROR_SERVICE_SPECIFIC_ERROR)
            {
                ScLogEvent(
                    NEVENT_SERVICE_EXIT_FAILED,
                    serviceRecord->DisplayName,
                    lpServiceStatus->dwWin32ExitCode
                    );
            }
            else
            {
                ScLogEvent(
                    NEVENT_SERVICE_EXIT_FAILED_SPECIFIC,
                    serviceRecord->DisplayName,
                    lpServiceStatus->dwServiceSpecificExitCode
                    );
            }

            //
            // For popup after user has logged on to indicate that some service
            // started at boot has failed.
            //
            if (serviceRecord->ErrorControl == SERVICE_ERROR_NORMAL ||
                serviceRecord->ErrorControl == SERVICE_ERROR_SEVERE ||
                serviceRecord->ErrorControl == SERVICE_ERROR_CRITICAL)
            {
                ScPopupStartFail = TRUE;
            }
        }

        //
        // Clear the server announcement bits in the global location
        // for this service.
        //
        ScRemoveServiceBits(serviceRecord);

        //
        // If this is the last service in the process, then delete the
        // process handle from the ProcessWatcher list.
        //
        if ((serviceRecord->ImageRecord != NULL) &&
            (serviceRecord->ImageRecord->ServiceCount == 1))
        {
            NTSTATUS ntStatus;

            //
            // Check vs. NULL in case the work item registration failed.
            // Deregister here so the process cleanup routine doesn't get
            // called if the service process exits between now and when we
            // call ScRemoveService.
            //
            if (serviceRecord->ImageRecord->ObjectWaitHandle != NULL) {

                ntStatus = RtlDeregisterWait(serviceRecord->ImageRecord->ObjectWaitHandle);

                if (NT_SUCCESS(ntStatus)) {
                    serviceRecord->ImageRecord->ObjectWaitHandle = NULL;
                }
                else {

                    SC_LOG1(ERROR,
                            "RSetServiceStatus: RtlDeregisterWait failed 0x%x\n",
                            ntStatus);
                }
            }
        }

        //
        // Even though the service said it stopped, save a status of
        // STOP_PENDING.  ScRemoveService will set it to STOPPED.  This
        // is to prevent anyone else from trying to restart the service
        // between the time that our thread releases the locks here and
        // the time that ScRemoveService (in the thread we are about to
        // create) acquires the locks.  ScRemoveService must get to the
        // service first, because it may need to process an UPDATE_FLAG
        // set on the service before it's OK to restart it.
        //
        serviceRecord->ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;

        SC_LOG(TRACE,
            "RSetServiceStatus:Create a thread to run ScRemoveService\n",0);

        threadHandle = CreateThread (
            NULL,                                   // Thread Attributes.
            0L,                                     // Stack Size
            (LPTHREAD_START_ROUTINE)RemovalThread,  // lpStartAddress
            (LPVOID)serviceRecord,                  // lpParameter
            0L,                                     // Creation Flags
            &threadId);                             // lpThreadId

        if (threadHandle == (HANDLE) NULL)
        {
            SC_LOG(ERROR,"RSetServiceStatus:CreateThread failed %d\n",
                GetLastError());

            //
            // If a thread couldn't be created to remove the service, it is removed
            // in the context of this thread.  The result of this is a somewhat
            // dirty termination.  The service record will be removed from the
            // installed database. If this was the last service in the process,
            // the process will terminate before we return to the thread.  Note that
            // we must release the locks before calling ScRemoveService since the
            // first thing it does is to acquire the list lock -- not releasing here
            // will cause deadlock (bug #103102).  The GroupListLock is not released
            // since ScRemoveService will acquire it in the same thread -- instead
            // of just releasing and then immediately reacquiring, release afterwards.
            //

            ScServiceRecordLock.Release();
            ScServiceListLock.Release();

            SC_LOG0(TRACE,"Attempting an in-thread removal in RSetServiceStatus\n");

            status = ScRemoveService(serviceRecord);

            if (groupListLocked)
            {
                ScGroupListLock.Release();
            }

            return status;
        }
        else
        {
            //
            // The Thread Creation was successful.
            //
            SC_LOG(TRACE,"Thread Creation Success, thread id = %#lx\n",threadId);
            CloseHandle(threadHandle);
        }
    }

    //
    // Release the locks we got earlier
    //
    ScServiceRecordLock.Release();

    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED)
    {
        ScServiceListLock.Release();
        if (groupListLocked)
        {
            ScGroupListLock.Release();
        }
    }

    SC_LOG(TRACE,"Return from RSetServiceStatus\n",0);

    return(status);

}


DWORD
RemovalThread(
    IN  LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This thread is used by RSetServiceStatus to remove a service from the
    Service Controller's database, and also - if necessary - shut down
    the service process.  The later step is only done if this was the last
    service running in that process.

    The use of this thread allows RSetServiceStatus to return to the service
    so that the service can then continue to terminate itself.

    We know that the service record will not go away before this thread
    acquires an exclusive lock on the database, because the service record's
    use count is not zero.

Arguments:

    ServiceRecord - This is a pointer to the service record that is being
        removed.

Return Value:

    Same as return values for RemoveService().

--*/
{
    ScRemoveService (ServiceRecord);

    return(0);
}

DWORD
RI_ScSetServiceBitsA(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwServiceBits,
    IN  DWORD           bSetBitsOn,
    IN  DWORD           bUpdateImmediately,
    IN  LPSTR           pszReserved
    )

/*++

Routine Description:

    This function Or's the Service Bits that are passed in - into a
    global bitmask maintained by the service controller.  Everytime this
    function is called, we check to see if the server service is running.
    If it is, then we call an internal entry point in the server service
    to pass in the complete bitmask.

    This function also Or's the Service Bits into the ServerAnnounce
    element in the service's ServiceRecord.

    NOTE:  The exclusive database lock is obtained and held while the
           service record is being read, and while the GlobalServerAnnounce
           bits are set.

Arguments:


Return Value:

    NO_ERROR - The operation was completely successful.  The information
        may or may not be delivered to the Server depending on if it is
        running or not.

    or any error returned from the server service I_NetServerSetServiceBits
    function.

Note:


--*/
{
    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    if (pszReserved != NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    return RI_ScSetServiceBitsW((SC_RPC_HANDLE)hService,
                                dwServiceBits,
                                bSetBitsOn,
                                bUpdateImmediately,
                                NULL);

}

DWORD
RI_ScSetServiceBitsW(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwServiceBits,
    IN  DWORD           bSetBitsOn,
    IN  DWORD           bUpdateImmediately,
    IN  LPWSTR          pszReserved
    )

/*++

Routine Description:

    This function Or's the Service Bits that are passed in - into a
    global bitmask maintained by the service controller.  Everytime this
    function is called, we check to see if the server service is running.
    If it is, then we call an internal entry point in the server service
    to pass in the complete bitmask.

    This function also Or's the Service Bits into the ServerAnnounce
    element in the service's ServiceRecord.

    NOTE:  The exclusive database lock is obtained and held while the
           service record is being read, and while the GlobalServerAnnounce
           bits are set.

Arguments:


Return Value:

    NO_ERROR - The operation was completely successful.

    ERROR_GEN_FAILURE - The server service is there, but the call to
        update it failed.

Note:


--*/
{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    serviceRecord;
    LPWSTR              serverServiceName;
    DWORD               serviceState;

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    if (pszReserved != NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    if (((LPSC_HANDLE_STRUCT)hService)->AccessGranted != SERVICE_SET_STATUS) {
        return(ERROR_INVALID_HANDLE);
    }

    if (ScNetServerSetServiceBits == (SETSBPROC)NULL) {
        if (! ScInitServerAnnounceFcn()) {
            return(ERROR_NO_NETWORK);
        }
    }

    serverServiceName = SERVICE_SERVER;

    CServiceListSharedLock LLock;
    CServiceRecordExclusiveLock RLock;

    serviceRecord = ((LPSC_HANDLE_STRUCT) hService)->Type.ScServiceObject.ServiceRecord;

    if (bSetBitsOn) {
        //
        // Set the bits in the global location.
        //
        GlobalServerAnnounce |= dwServiceBits;

        //
        // Set the bits in the service record.
        //

        serviceRecord->ServerAnnounce |= dwServiceBits;


    }
    else {
        //
        // Clear the bits in the global location.
        //
        GlobalServerAnnounce &= ~dwServiceBits;

        //
        // Clear the bits in the service record.
        //

        serviceRecord->ServerAnnounce &= ~dwServiceBits;


    }
    //
    // If the server service is running, then send the Global mask to
    // the server service.
    //

    status = ScGetNamedServiceRecord(
                serverServiceName,
                &serviceRecord);

    if (status == NO_ERROR) {

        serviceState = serviceRecord->ServiceStatus.dwCurrentState;

        if (serviceState == SERVICE_RUNNING) {

            status = ScNetServerSetServiceBits(
                        NULL,                   // ServerName
                        NULL,                   // TransportName
                        GlobalServerAnnounce,
                        bUpdateImmediately);

            if (status != NERR_Success) {
                SC_LOG(ERROR,"I_ScSetServiceBits: I_NetServerSetServiceBits failed %lu\n",
                       status);
            }
            else {
                SC_LOG(TRACE,"I_ScSetServiceBits: I_NetServerSetServiceBits success\n",0);
            }
        }
    }
    else {
        status = NO_ERROR;
    }

    SC_LOG(TRACE,"I_ScSetServiceBits: GlobalServerAnnounce = 0x%lx\n",
           GlobalServerAnnounce);

    return(status);
}


DWORD
ScRemoveServiceBits(
    IN  LPSERVICE_RECORD  ServiceRecord
    )

/*++

Routine Description:

    This function is called when a service stops running.  It looks in
    the service record for any server announcement bits that are set
    and turns them off in GlobalServerAnnounce.  The ServerAnnounce
    element in the service record is set to 0.

Arguments:

    ServiceRecord - This is a pointer to the service record that
        has changed to the stopped state.

Return Value:

    The status returned from I_NetServerSetServiceBits.

--*/
{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    serverServiceRecord;
    DWORD               serviceState;


    if (ScNetServerSetServiceBits == (SETSBPROC)NULL) {
        if (! ScInitServerAnnounceFcn()) {
            return(ERROR_NO_NETWORK);
        }
    }

    if (ServiceRecord->ServerAnnounce != 0) {

        CServiceRecordExclusiveLock RLock;

        //
        // Clear the bits in the global location.
        //
        GlobalServerAnnounce &= ~(ServiceRecord->ServerAnnounce);


        //
        // Clear the bits in the service record.
        //

        ServiceRecord->ServerAnnounce = 0;

        SC_LOG1(TRACE,"RemoveServiceBits: New GlobalServerAnnounce = 0x%lx\n",
            GlobalServerAnnounce);

        //
        // If the server service is running, then send the Global mask to
        // the server service.
        //

        status = ScGetNamedServiceRecord(
                    SERVICE_SERVER,
                    &serverServiceRecord);


        if (status == NO_ERROR) {

            serviceState = serverServiceRecord->ServiceStatus.dwCurrentState;

            if ( serviceState == SERVICE_RUNNING) {

                status = ScNetServerSetServiceBits(
                            NULL,                   // ServerName
                            NULL,                   // Transport name
                            GlobalServerAnnounce,
                            TRUE);                  // Update immediately.

                if (status != NERR_Success) {
                    SC_LOG(ERROR,"ScRemoveServiceBits: I_NetServerSetServiceBits failed %d\n",
                    status);
                }
            }
        }
    }
    return(status);
}

BOOL
ScInitServerAnnounceFcn(
    VOID
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    ScGlobalServerHandle = LoadLibraryW(L"netapi32.dll");

    if (ScGlobalServerHandle == NULL) {
        SC_LOG(ERROR,"ScInitServerAnnouncFcn: LoadLibrary failed %d\n",
            GetLastError());
        return(FALSE);
    }

    //
    // Use I_NetServerSetServiceBits rather than the Ex version since
    // it uses a special flag to prevent the RPC failure path from
    // calling back into services.exe and potentially causing a deadlock.
    //

    ScNetServerSetServiceBits = (SETSBPROC)GetProcAddress(
                                    ScGlobalServerHandle,
                                    "I_NetServerSetServiceBits");


    if (ScNetServerSetServiceBits == (SETSBPROC)NULL) {
        SC_LOG(ERROR,"ScInitServerAnnouncFcn: GetProcAddress failed %d\n",
            GetLastError());
        return(FALSE);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\server\svcctrl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcctrl.h

Abstract:

    Included by the main module svcctrl.c.

Author:

    Dan Lafferty (danl)     22-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    20-Oct-1993     Danl
        Added ScConnectedToSecProc and ScGlobalNetLogonName.


--*/

#ifndef SVCCTRL_H
#define SVCCTRL_H

#include <netevent.h>
#include <safeboot.h>

//
// CONSTANTS
//

//
// Flags to indicate the amount of initialization work done
//
#define SC_NAMED_EVENT_CREATED           0x00000001
#define WELL_KNOWN_SIDS_CREATED          0x00000002
#define SC_MANAGER_OBJECT_CREATED        0x00000004
#define CRITICAL_SECTIONS_CREATED        0x00000008
#define AUTO_START_INITIALIZED           0x00000010
#define RPC_SERVER_STARTED               0x00000020
#define SC_DATABASE_INITIALIZED          0x00000040

//
// String constants for event logging
//
#define SCM_NAMEW                        L"Service Control Manager"
#define SCM_NAMEA                        "Service Control Manager"

#define SC_RPC_IMPERSONATE               L"RpcImpersonateClient"
#define SC_RPC_REVERT                    L"RpcRevertToSelf"

#define SC_LSA_STOREPRIVATEDATA          L"LsaStorePrivateData"
#define SC_LSA_RETRIEVEPRIVATEDATA       L"LsaRetrievePrivateData"
#define SC_LSA_OPENPOLICY                L"LsaOpenPolicy"

#define SC_RESET_EVENT                   L"ResetEvent"

#define SC_LOAD_USER_PROFILE             L"LoadUserProfile"


//
// Constants used for Safeboot
//
#define  SAFEBOOT_BUFFER_LENGTH     256
#define  SAFEBOOT_KEY               L"system\\currentcontrolset\\control\\safeboot\\"


typedef struct _FAILED_DRIVER {
    struct _FAILED_DRIVER *Next;
    WCHAR DriverName[1];
} FAILED_DRIVER, *LPFAILED_DRIVER;


//
// EXTERNAL GLOBALS
//
    extern  BOOL    ScAutoStartInProgress;
    extern  DWORD   ScShutdownInProgress;
    extern  BOOL    ScPopupStartFail;
    extern  BOOL    ScStillInitializing;
#ifndef _CAIRO_
    extern  BOOL    ScConnectedToSecProc;

    extern  LPWSTR  ScGlobalNetLogonName;
#endif // _CAIRO_
    extern  LPWSTR  ScGlobalThisExePath;
    extern  LPWSTR  ScGlobalSecurityExePath;

    extern  NT_PRODUCT_TYPE ScGlobalProductType;

    extern  WCHAR   g_szSafebootKey[];
    extern  DWORD   g_dwSafebootLen;
    extern  DWORD   g_SafeBootEnabled;

    extern  HKEY    g_hProviderKey;

//
// FUNCTION PROTOTYPES
//
VOID
SvcctrlMain (
    int     argc,
    PCHAR   argv[]
    );

//
// Functions from start.c
//
VOID
ScInitStartImage(
    VOID
    );

//
// Functions from control.c
//
VOID
ScInitTransactNamedPipe(
    VOID
    );

//
// Functions from status.c
//

BOOL
ScInitServerAnnounceFcn(
    VOID
    );

DWORD
ScRemoveServiceBits(
    IN  LPSERVICE_RECORD  ServiceRecord
    );

BOOL
ScShutdownNotificationRoutine(
    DWORD   dwCtrlType
    );

DWORD
ScAddFailedDriver(
    LPWSTR Driver
    );


#define  IS_CONTROL_LOGGABLE(Control)  (Control == SERVICE_CONTROL_STOP || \
                                          Control == SERVICE_CONTROL_PAUSE || \
                                          Control == SERVICE_CONTROL_CONTINUE)

#define  IS_STATUS_LOGGABLE(Status)    (Status == SERVICE_STOPPED || \
                                          Status == SERVICE_RUNNING || \
                                          Status == SERVICE_PAUSED)

VOID
ScLogControlEvent(
    DWORD   dwEvent,
    LPCWSTR lpServiceName,
    DWORD   dwControl
    );

#endif // def SVCCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\globals.h ===
#pragma once


extern PSVCHOST_GLOBAL_DATA    g_pSvchostSharedGlobals;

VOID
SvchostBuildSharedGlobals(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\globals.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       G L O B A L S . C
//
//  Contents:   Support for shared global data for services in svchost.exe
//              that choose to use it.
//
//  Notes:
//
//  Author:     jschwart   26 Jan 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <svcslib.h>
#include <scseclib.h>
#include <ntrpcp.h>
#include "globals.h"
#include "svcsnb.h"

//
// Defines to gauge progress from past calls
// to SvchostBuildSharedGlobals
//
#define SVCHOST_RPCP_INIT           0x00000001
#define SVCHOST_NETBIOS_INIT        0x00000002
#define SVCHOST_SIDS_BUILT          0x00000004

//
// Global data
//
PSVCHOST_GLOBAL_DATA    g_pSvchostSharedGlobals;

#if DBG

DWORD  SvcctrlDebugLevel;  // Needed to resolve external in sclib.lib

#endif


VOID
SvchostBuildSharedGlobals(
    VOID
    )
{
    static  DWORD  s_dwProgress;

    NTSTATUS       ntStatus;

    //
    // Note that this routine assumes it is being called
    // while the ListLock critsec (in svchost.c) is held
    //
    ASSERT(g_pSvchostSharedGlobals == NULL);

    //
    // Initialize the RPC helper routine global data
    //
    if (!(s_dwProgress & SVCHOST_RPCP_INIT))
    {
        RpcpInitRpcServer();
        s_dwProgress |= SVCHOST_RPCP_INIT;
    }

    //
    // Initialize the NetBios critical section for services
    // that use NetBios.
    //
    if (!(s_dwProgress & SVCHOST_NETBIOS_INIT))
    {
        SvcNetBiosInit();
        s_dwProgress |= SVCHOST_NETBIOS_INIT;
    }

    //
    // Build up the shared global SIDs -- use the Service Controller's
    // routine for this.
    //
    if (!(s_dwProgress & SVCHOST_SIDS_BUILT))
    {
        ntStatus = ScCreateWellKnownSids();

        if (!NT_SUCCESS(ntStatus))
        {
            return;
        }

        s_dwProgress |= SVCHOST_SIDS_BUILT;
    }

    //
    // Create and populate the global data structure.
    //
    g_pSvchostSharedGlobals = MemAlloc(HEAP_ZERO_MEMORY,
                                       sizeof(SVCHOST_GLOBAL_DATA));

    if (g_pSvchostSharedGlobals != NULL)
    {
        g_pSvchostSharedGlobals->NullSid              = NullSid;
        g_pSvchostSharedGlobals->WorldSid             = WorldSid;
        g_pSvchostSharedGlobals->LocalSid             = LocalSid;
        g_pSvchostSharedGlobals->NetworkSid           = NetworkSid;
        g_pSvchostSharedGlobals->LocalSystemSid       = LocalSystemSid;
        g_pSvchostSharedGlobals->LocalServiceSid      = LocalServiceSid;
        g_pSvchostSharedGlobals->NetworkServiceSid    = NetworkServiceSid;
        g_pSvchostSharedGlobals->BuiltinDomainSid     = BuiltinDomainSid;
        g_pSvchostSharedGlobals->AuthenticatedUserSid = AuthenticatedUserSid;
        g_pSvchostSharedGlobals->AnonymousLogonSid    = AnonymousLogonSid;

        g_pSvchostSharedGlobals->AliasAdminsSid       = AliasAdminsSid;
        g_pSvchostSharedGlobals->AliasUsersSid        = AliasUsersSid;
        g_pSvchostSharedGlobals->AliasGuestsSid       = AliasGuestsSid;
        g_pSvchostSharedGlobals->AliasPowerUsersSid   = AliasPowerUsersSid;
        g_pSvchostSharedGlobals->AliasAccountOpsSid   = AliasAccountOpsSid;
        g_pSvchostSharedGlobals->AliasSystemOpsSid    = AliasSystemOpsSid;
        g_pSvchostSharedGlobals->AliasPrintOpsSid     = AliasPrintOpsSid;
        g_pSvchostSharedGlobals->AliasBackupOpsSid    = AliasBackupOpsSid;

        g_pSvchostSharedGlobals->StartRpcServer       = RpcpStartRpcServer;
        g_pSvchostSharedGlobals->StopRpcServer        = RpcpStopRpcServer;
        g_pSvchostSharedGlobals->StopRpcServerEx      = RpcpStopRpcServerEx;
        g_pSvchostSharedGlobals->NetBiosOpen          = SvcNetBiosOpen;
        g_pSvchostSharedGlobals->NetBiosClose         = SvcNetBiosClose;
        g_pSvchostSharedGlobals->NetBiosReset         = SvcNetBiosReset;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\memory.h ===
#pragma once

VOID
MemInit (
    IN HANDLE   hHeap
    );

LPVOID
MemAlloc (
    IN DWORD    dwFlags,
    IN SIZE_T   dwBytes
    );

BOOL
MemFree (
    IN LPVOID   pv
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\pch.h ===
#pragma once

#include <scpragma.h>

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>
#include <svcs.h>

#include <objbase.h>
#include <regstr.h>

#include <stdio.h>

// Local headers which don't change
// and are included by all modules.
//
#include "scdebug.h"
#include "memory.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\memory.c ===
#include "pch.h"
#pragma hdrstop


HANDLE g_hHeap;


VOID
MemInit (
    IN HANDLE   hHeap
    )
{
    g_hHeap = hHeap;
}

LPVOID
MemAlloc (
    IN DWORD    dwFlags,
    IN SIZE_T   dwBytes
    )
{
    return HeapAlloc (g_hHeap, dwFlags, dwBytes);
}

BOOL
MemFree (
    IN LPVOID   pv
    )
{
    return HeapFree (g_hHeap, 0, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\security.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       S E C U R I T Y . C
//
//  Contents:   Support for process-wide security settings such as calls
//              to CoInitializeSecurity.
//
//  Notes:
//
//  Author:     shaunco   15 Jul 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "security.h"


#define SIZE_ALIGNED_FOR_TYPE(_size, _type) \
    (((_size) + sizeof(_type)-1) & ~(sizeof(_type)-1))


DWORD
DwInitializeNullDaclSdFromThreadToken (
    PSECURITY_DESCRIPTOR*   ppSd
    )
{
    PSECURITY_DESCRIPTOR    pSd;
    PTOKEN_USER             pUserInfo;
    PTOKEN_PRIMARY_GROUP    pGroupInfo;
    HANDLE                  hToken;
    DWORD                   dwErr = NOERROR;
    DWORD                   dwUserSize;
    DWORD                   dwGroupSize;
    DWORD                   dwAlignSdSize;
    DWORD                   dwAlignUserSize;
    PVOID                   pvBuffer;

    // Here is the buffer we are building.
    //
    //   |<- a ->|<--- b ---->|<--- c ---->|
    //   +-------+------------+------------+
    //   |      p|           p|            |
    //   | SD   a| User info a| Group info |
    //   |      d|           d|            |
    //   +-------+------------+------------+
    //   ^       ^            ^
    //   |       |            |
    //   |       |            +--pGroupInfo
    //   |       |
    //   |       +--pUserInfo
    //   |
    //   +--pSd (this is returned via *ppSd)
    //
    //   pad is so that pUserInfo and pGroupInfo are aligned properly.
    //
    //   a = dwAlignSdSize
    //   b = dwAlignUserSize
    //   c = dwGroupSize
    //

    // Initialize output parameters.
    //
    *ppSd = NULL;

    // Open the thread token if we can.  If we can't try for the process
    // token.
    //
    if (!OpenThreadToken (GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
    {
        if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &hToken))
        {
            dwErr = GetLastError ();
            goto finish;
        }
    }

    // Get the size of the buffer required for the user information.
    //
    if (!GetTokenInformation (hToken, TokenUser, NULL, 0, &dwUserSize))
    {
        dwErr = GetLastError ();
        if (ERROR_INSUFFICIENT_BUFFER != dwErr)
        {
            goto finish;
        }
    }

    // Get the size of the buffer required for the group information.
    //
    if (!GetTokenInformation (hToken, TokenPrimaryGroup, NULL, 0, &dwGroupSize))
    {
        dwErr = GetLastError ();
        if (ERROR_INSUFFICIENT_BUFFER != dwErr)
        {
            goto finish;
        }
    }

    dwAlignSdSize   = SIZE_ALIGNED_FOR_TYPE(SECURITY_DESCRIPTOR_MIN_LENGTH, PTOKEN_USER);
    dwAlignUserSize = SIZE_ALIGNED_FOR_TYPE(dwUserSize, PTOKEN_PRIMARY_GROUP);

    // Allocate a buffer big enough for both making sure the sub-buffer
    // for the group information is suitably aligned.
    //
    pvBuffer = MemAlloc (0,
                    dwAlignSdSize + dwAlignUserSize + dwGroupSize);

    if (pvBuffer)
    {
        dwErr = NOERROR;

        // Setup the pointers into the buffer.
        //
        pSd        = pvBuffer;
        pUserInfo  = (PTOKEN_USER)((PBYTE)pvBuffer + dwAlignSdSize);
        pGroupInfo = (PTOKEN_PRIMARY_GROUP)((PBYTE)pUserInfo + dwAlignUserSize);

        if (!InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION))
        {
            dwErr = GetLastError ();
        }

        if (!SetSecurityDescriptorDacl (pSd, TRUE, NULL, FALSE))
        {
            dwErr = GetLastError ();
        }

        if (!GetTokenInformation (hToken, TokenUser,
                        pUserInfo, dwUserSize, &dwUserSize))
        {
            dwErr = GetLastError ();
        }

        if (!GetTokenInformation (hToken, TokenPrimaryGroup,
                        pGroupInfo, dwGroupSize, &dwGroupSize))
        {
            dwErr = GetLastError ();
        }

        if (!SetSecurityDescriptorOwner (pSd, pUserInfo->User.Sid, FALSE))
        {
            dwErr = GetLastError ();
        }

        if (!SetSecurityDescriptorGroup (pSd, pGroupInfo->PrimaryGroup, FALSE))
        {
            dwErr = GetLastError ();
        }

        // All is well, so assign the output parameters.
        //
        if (!dwErr)
        {
            *ppSd = pSd;
        }

        // Free our allocated buffer on failure.
        //
        else
        {
            MemFree (pvBuffer);
        }
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
    }

finish:
    return dwErr;
}

VOID
InitializeSecurity (
    DWORD   dwParam,
    DWORD   dwAuthLevel,
    DWORD   dwImpersonationLevel,
    DWORD   dwAuthCapabilities
    )
{
    HRESULT                 hr;
    PSECURITY_DESCRIPTOR    pSd;

    ASSERT (0 != dwParam);

    if (!DwInitializeNullDaclSdFromThreadToken (&pSd))
    {
        hr = CoInitializeEx (NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

        if (SUCCEEDED(hr))
        {
            SVCHOST_LOG1(SECURITY,
                         "Calling CoInitializeSecurity...(dwAuthCapabilities=0x%08x)\n",
                         dwAuthCapabilities);

            hr = CoInitializeSecurity (
                    pSd, -1, NULL, NULL,
                    dwAuthLevel,
                    dwImpersonationLevel,
                    NULL,
                    dwAuthCapabilities,
                    NULL);

            if (FAILED(hr))
            {
                SVCHOST_LOG1(ERROR,
                             "CoInitializeSecurity returned hr=0x%08x\n",
                             hr);
            }
        }

        MemFree (pSd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\registry.h ===
#pragma once

LONG
RegQueryDword (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    OUT LPDWORD pdwValue
    );

LONG
RegQueryString (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*  ppszData
    );

LONG
RegQueryStringA (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PSTR*   ppszData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\security.h ===
#pragma once

VOID
InitializeSecurity (
    DWORD   dwParam,
    DWORD   dwAuthLevel,
    DWORD   dwImpersonationLevel,
    DWORD   dwAuthCapabilities
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\svcsnb.h ===
#pragma once

VOID
SvcNetBiosInit(
    VOID
    );

VOID
SvcNetBiosOpen(
    VOID
    );

VOID
SvcNetBiosClose(
    VOID
    );

DWORD
SvcNetBiosReset (
    UCHAR   LanAdapterNumber
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\registry.c ===
#include "pch.h"
#pragma hdrstop
#include "registry.h"

LONG
RegQueryDword (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    OUT LPDWORD pdwValue
    )
{
    LONG    lr;
    DWORD   dwType;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (pdwValue);

    dwSize = sizeof(DWORD);

    lr = RegQueryValueEx (
            hkey,
            pszValueName,
            NULL,
            &dwType,
            (LPBYTE)pdwValue,
            &dwSize);

    if (!lr && (REG_DWORD != dwType))
    {
        *pdwValue = 0;
        lr = ERROR_INVALID_DATATYPE;
    }

    return lr;
}

LONG
RegQueryValueWithAlloc (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT LPBYTE* ppbData,
    OUT LPDWORD pdwSize
    )
{
    LONG    lr;
    DWORD   dwType;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (ppbData);
    ASSERT (pdwSize);

    // Initialize the output parameters.
    //
    *ppbData = NULL;
    *pdwSize = 0;

    // Get the size of the buffer required.
    //
    dwSize = 0;
    lr = RegQueryValueEx (
            hkey,
            pszValueName,
            NULL,
            &dwType,
            NULL,
            &dwSize);

    if (!lr && (dwType == dwTypeMustBe) && dwSize)
    {
        LPBYTE  pbData;

        // Allocate the buffer.
        //
        lr = ERROR_OUTOFMEMORY;
        pbData = MemAlloc (0, dwSize);
        if (pbData)
        {
            // Get the data.
            //
            lr = RegQueryValueEx (
                    hkey,
                    pszValueName,
                    NULL,
                    &dwType,
                    pbData,
                    &dwSize);

            if (!lr)
            {
                *ppbData = pbData;
                *pdwSize = dwSize;
            }
            else
            {
                MemFree (pbData);
            }
        }
    }
    else if (!lr)
    {
        lr = ERROR_INVALID_DATA;
    }

    return lr;
}

LONG
RegQueryString (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*  ppszData
    )
{
    LONG    lr;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);

    lr = RegQueryValueWithAlloc (
            hkey,
            pszValueName,
            dwTypeMustBe,
            (LPBYTE*)ppszData,
            &dwSize);

    return lr;
}

LONG
RegQueryStringA (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PSTR*   ppszData
    )
{
    LONG    lr;
    PTSTR   pszUnicode;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (ppszData);

    // Initialize the output parameter.
    //
    *ppszData = NULL;

    lr = RegQueryString (
            hkey,
            pszValueName,
            dwTypeMustBe,
            &pszUnicode);

    if (!lr)
    {
        INT cb;
        INT cchUnicode = lstrlen (pszUnicode) + 1;

        // Compute the number of bytes required to hold the ANSI string.
        //
        cb = WideCharToMultiByte (
                CP_ACP,     // CodePage
                0,          // dwFlags
                pszUnicode,
                cchUnicode,
                NULL,       // no buffer to receive translated string
                0,          // return the number of bytes required
                NULL,       // lpDefaultChar
                NULL);      // lpUsedDefaultChar
        if (cb)
        {
            PSTR pszAnsi;

            lr = ERROR_OUTOFMEMORY;
            pszAnsi = MemAlloc (0, cb);
            if (pszAnsi)
            {
                lr = NOERROR;

                // Now translate the UNICODE string to ANSI.
                //
                cb = WideCharToMultiByte (
                        CP_ACP,     // CodePage
                        0,          // dwFlags
                        pszUnicode,
                        cchUnicode,
                        pszAnsi,    // buffer to receive translated string
                        cb,         // return the number of bytes required
                        NULL,       // lpDefaultChar
                        NULL);      // lpUsedDefaultChar

                if (cb)
                {
                    *ppszData = pszAnsi;
                }
                else
                {
                    MemFree (pszAnsi);
                    lr = GetLastError ();
                }
            }
        }

        MemFree (pszUnicode);
    }

    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Generic Host Process for Win32 Services"
#define VER_INTERNALNAME_STR            "svchost.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\svchost.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       svchost.c
//
//  Contents:   Generic Host Process for Win32 Services
//
//  Classes:
//
//  Functions:
//
//  History:    3-30-98   RichardW   Created
//              3-31-98   ShaunCo    Took ownership.
//                                   Finished off basic implementation.
//              1-24-00   JSchwart   Took ownership.
//                                   Adapted to run NT intrinsic services.
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "globals.h"
#include "registry.h"
#include "security.h"


//
//  Generic Service Process:
//
//  This process will grovel the service portion of the registry, looking
//  for instances of itself (details below), and constructing a list of services
//  to submit to the service controller.  As an individual service is started,
//  the DLL is loaded and the entry point called.  Services in these DLLs are
//  expected to play nicely with others, that is, use the common thread pool,
//  not stomp memory, etc.
//
//
//  Loading.
//
//  Each service that will be resident in this process must have svchost.exe as
//  the ImagePath, with the same parameters.  Additionally, the service must
//  have under its Parameters key, these values:
//
//  ServiceDll      = REG_EXPAND_SZ <path to DLL>
//  ServiceMain     = REG_SZ        <pszFunctionName>  OPTIONAL
//
//  If ServiceMain is not present, then it defaults to "ServiceMain".
//
//
//  Multiple Service Groups
//
//  Multiple service groups can be accomplished by supplying parameters to the
//  svchost.exe on the ImagePath.
//
//      svchost.exe -k "Key"
//
//  will grovel the services and only load those with matching ImagePath.
//

#define REGSTR_PATH_SVCHOST     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost")

typedef struct _COMMAND_OPTIONS
{
    PTSTR   CommandLineBuffer;
    PTSTR   ImageName;

    BOOL    fServiceGroup;
    PTSTR   ServiceGroupName;

    //
    // dwCoInitializeSecurityParam is a DWORD read from the registry for the
    // service group we were instantiated for.  If non-zero, we will
    // call CoInitializeSecurity in a way based on the value.
    //

    DWORD   dwCoInitializeSecurityParam;
    DWORD   dwAuthLevel;
    DWORD   dwImpersonationLevel;
    DWORD   dwAuthCapabilities;

    //
    // Default stack size for RPC threads (to prevent stack overflow)
    //

    DWORD   dwDefaultRpcStackSize;
}
COMMAND_OPTIONS, * PCOMMAND_OPTIONS;


typedef struct _SERVICE_DLL
{
    LIST_ENTRY      List;
    HMODULE         hmod;
    PTSTR           pszDllPath;
} SERVICE_DLL, * PSERVICE_DLL;


typedef struct _SERVICE
{
    PTSTR           pszName;
    PSERVICE_DLL    pDll;
    PSTR            pszEntryPoint;
} SERVICE, * PSERVICE;


//+---------------------------------------------------------------------------
//
// Global variables.
//

// ListLock protects access to the Dll list and Service array.
//
CRITICAL_SECTION    ListLock;

// DllList is a list of SERVICE_DLL structures representing the DLL's
// which host entry points for the services hosted by this process.
//
LIST_ENTRY          DllList;

// ServiceArray is an array of SERVICE structures representing the services
// hosted by this process.
//
PSERVICE            ServiceArray;

// ServiceCount is the count of SERVICE entries in ServiceList.
//
UINT                ServiceCount;

// ServiceNames is the multi-sz read from the registry for the
// service group we were instantiated for.
//
PTSTR               ServiceNames;


//+---------------------------------------------------------------------------
//
// Local function prototypes
//

VOID
SvchostCharLowerW(
    LPWSTR  pszString
    );


//+---------------------------------------------------------------------------
//

VOID
DummySvchostCtrlHandler(
    DWORD   Opcode
    )
{
    return;
}


VOID
AbortSvchostService(               // used if cant find Service DLL or entrypoint
    LPWSTR  ServiceName,
    DWORD   Error
    )
{
    SERVICE_STATUS_HANDLE   GenericServiceStatusHandle;
    SERVICE_STATUS          GenericServiceStatus;

    GenericServiceStatus.dwServiceType        = SERVICE_WIN32;
    GenericServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    GenericServiceStatus.dwControlsAccepted   = SERVICE_CONTROL_STOP;
    GenericServiceStatus.dwCheckPoint         = 0;
    GenericServiceStatus.dwWaitHint           = 0;
    GenericServiceStatus.dwWin32ExitCode      = Error;
    GenericServiceStatus.dwServiceSpecificExitCode = 0;

    GenericServiceStatusHandle = RegisterServiceCtrlHandler(ServiceName,
                                                            DummySvchostCtrlHandler);

    if (GenericServiceStatusHandle == NULL)
    {
        SVCHOST_LOG1(ERROR,
                     "AbortSvchostService: RegisterServiceCtrlHandler failed %d\n",
                     GetLastError());
    }
    else if (!SetServiceStatus (GenericServiceStatusHandle,
                                &GenericServiceStatus))
    {
        SVCHOST_LOG1(ERROR,
                     "AbortSvchostService: SetServiceStatus error %ld\n",
                     GetLastError());
    }

    return;
}


FARPROC
GetServiceDllFunction (
    PSERVICE_DLL    pDll,
    PCSTR           pszFunctionName,
    LPDWORD         lpdwError        OPTIONAL
    )
{
    FARPROC pfn;
    HMODULE hmod;

    // Load the module if neccessary.
    //
    hmod = pDll->hmod;
    if (!hmod)
    {
        hmod = LoadLibraryEx (
                    pDll->pszDllPath,
                    NULL,
                    LOAD_WITH_ALTERED_SEARCH_PATH);

        if (hmod)
        {
            pDll->hmod = hmod;
        }
        else
        {
            if (lpdwError)
            {
                *lpdwError = GetLastError();
            }

            SVCHOST_LOG2(ERROR,
                         "LoadLibrary (%ws) failed.  Error %d.\n",
                         pDll->pszDllPath,
                         GetLastError());

            return NULL;
        }
    }

    ASSERT (hmod);

    pfn = GetProcAddress(hmod, pszFunctionName);

    if (!pfn)
    {
        if (lpdwError)
        {
            *lpdwError = GetLastError();
        }

        SVCHOST_LOG3(TRACE,
                     "GetProcAddress (%s) failed on DLL %ws.  Error = %d.\n",
                     pszFunctionName,
                     pDll->pszDllPath,
                     GetLastError());
    }

    return pfn;
}


PSERVICE_DLL
FindDll(
    IN LPCTSTR pszDllPath
    )
{
    PLIST_ENTRY     pNode;
    PSERVICE_DLL    pDll = NULL;

    ASSERT (pszDllPath);

    EnterCriticalSection (&ListLock);

    pNode = DllList.Flink;

    while (pNode != &DllList)
    {
        pDll = CONTAINING_RECORD (pNode, SERVICE_DLL, List);

        if (0 == lstrcmp (pDll->pszDllPath, pszDllPath))
        {
            break;
        }

        pDll = NULL;

        pNode = pNode->Flink;
    }

    LeaveCriticalSection (&ListLock);

    return pDll;
}


PSERVICE_DLL
AddDll(
    IN  LPCTSTR pszDllPath,
    OUT LPDWORD lpdwError
    )
{
    PSERVICE_DLL    pDll;

    ASSERT (pszDllPath);
    ASSERT (*pszDllPath);

    pDll = MemAlloc (HEAP_ZERO_MEMORY,
                sizeof (SERVICE_DLL) +
                (lstrlen (pszDllPath) + 1) * sizeof (TCHAR));

    if (pDll)
    {
        // Set the structure members.
        //
        pDll->pszDllPath = (PTSTR) (pDll + 1);
        lstrcpy (pDll->pszDllPath, pszDllPath);

        // Add the entry to the list.
        //
        EnterCriticalSection (&ListLock);

        InsertTailList (&DllList, &pDll->List);

        LeaveCriticalSection (&ListLock);
    }
    else
    {
        *lpdwError = GetLastError();
    }

    return pDll;
}

LONG
OpenServiceParametersKey (
    LPCTSTR pszServiceName,
    HKEY*   phkey
    )
{
    LONG lr;
    HKEY hkeyServices;

    ASSERT (phkey);

    // Open the Services key.
    //
    lr = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_PATH_SERVICES,
            0,
            KEY_READ,
            &hkeyServices);

    if (!lr)
    {
        HKEY hkeySvc;

        // Open the service key.
        //
        lr = RegOpenKeyEx (
                hkeyServices,
                pszServiceName,
                0,
                KEY_READ,
                &hkeySvc);

        if (!lr)
        {
            // Open the Parameters key.
            //
            lr = RegOpenKeyEx (
                    hkeySvc,
                    TEXT("Parameters"),
                    0,
                    KEY_READ,
                    phkey);

            RegCloseKey (hkeySvc);
        }

        RegCloseKey (hkeyServices);
    }

    return lr;
}


#if DBG
BOOL
FDebugBreakForService (
    LPCWSTR pszwService
    )
{
    BOOL    fAttach = FALSE;
    LONG    lr;
    HKEY    hkeySvchost;

    // Open the Svchost key.
    //
    lr = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_PATH_SVCHOST,
            0,
            KEY_READ,
            &hkeySvchost);

    if (!lr)
    {
        HKEY  hkeyServiceOptions;

        // Look for the key with the same name as the service.
        //
        lr = RegOpenKeyExW (
                hkeySvchost,
                pszwService,
                0,
                KEY_READ,
                &hkeyServiceOptions);

        if (!lr)
        {
            DWORD dwValue;

            lr = RegQueryDword (
                    hkeyServiceOptions,
                    TEXT("DebugBreak"),
                    &dwValue);

            if (!lr)
            {
                fAttach = !!dwValue;
            }

            RegCloseKey (hkeyServiceOptions);
        }

        RegCloseKey (hkeySvchost);
    }

    return fAttach;
}
#endif


VOID
GetServiceMainFunctions (
    PSERVICE                       pService,
    LPSERVICE_MAIN_FUNCTION        *ppfnServiceMain,
    LPSVCHOST_PUSH_GLOBAL_FUNCTION *ppfnPushGlobals,
    LPDWORD                        lpdwError
    )
{
    LPCSTR pszEntryPoint;

    *lpdwError = NO_ERROR;

    // Get the dll and entrypoint for this service if we don't have it yet.
    //
    if (!pService->pDll)
    {
        LONG lr;
        HKEY hkeyParams;

        lr = OpenServiceParametersKey (pService->pszName, &hkeyParams);
        if (!lr)
        {
            DWORD dwType;
            DWORD dwSize;
            WCHAR pszDllName         [MAX_PATH + 1];
            WCHAR pszExpandedDllName [MAX_PATH + 1];

            // Look for the service dll path and expand it.
            //
            dwSize = sizeof(pszDllName);
            lr = RegQueryValueEx (
                    hkeyParams,
                    TEXT("ServiceDll"),
                    NULL,
                    &dwType,
                    (LPBYTE)pszDllName,
                    &dwSize);

            if (!lr && (REG_EXPAND_SZ == dwType) && *pszDllName)
            {
                PSERVICE_DLL pDll;

                // Expand the dll name and lower case it for comparison
                // when we try to find an existing dll record.
                //
                ExpandEnvironmentStrings (
                    pszDllName,
                    pszExpandedDllName,
                    MAX_PATH);

                SvchostCharLowerW (pszExpandedDllName);

                // Try to find an existing dll record that we might have and
                // if we don't, add this as a new record.
                //
                pDll = FindDll (pszExpandedDllName);
                if (!pDll)
                {
                    pDll = AddDll (pszExpandedDllName, lpdwError);
                }

                // Remember this dll for this service for next time.
                //
                ASSERT (!pService->pDll);
                pService->pDll = pDll;

                // Look for an explicit entrypoint name for this service.
                // (Optional)
                //
                RegQueryStringA (
                    hkeyParams,
                    TEXT("ServiceMain"),
                    REG_SZ,
                    &pService->pszEntryPoint);
            }
            else if (NOERROR != lr)
            {
                *lpdwError = lr;

                SVCHOST_LOG2(ERROR,
                             "RegQueryValueEx for the ServiceDll parameter of the "
                             "%ws service returned %u\n",
                             pService->pszName,
                             lr);
            }
            else if (REG_EXPAND_SZ != dwType)
            {
                *lpdwError = ERROR_FILE_NOT_FOUND;

                SVCHOST_LOG1(ERROR,
                             "The ServiceDll parameter for the %ws service is not "
                             "of type REG_EXPAND_SZ\n",
                             pService->pszName);
            }
            else
            {
                *lpdwError = ERROR_FILE_NOT_FOUND;
            }

            RegCloseKey (hkeyParams);
        }
        else
        {
            *lpdwError = lr;
        }


        // If we don't have the service dll record by now, we're through.
        //
        if (!pService->pDll)
        {
            ASSERT(*lpdwError != NO_ERROR);
            return;
        }
    }

    // We should have it the dll by now, so proceed to load the entry point.
    //
    ASSERT (pService->pDll);

    // Default the entry point if we don't have one specified.
    //
    if (pService->pszEntryPoint)
    {
        pszEntryPoint = pService->pszEntryPoint;
    }
    else
    {
        pszEntryPoint = "ServiceMain";
    }

    // Get the address for the service's ServiceMain
    //
    *ppfnServiceMain = (LPSERVICE_MAIN_FUNCTION) GetServiceDllFunction(
                                                     pService->pDll,
                                                     pszEntryPoint,
                                                     lpdwError);

    // Get the address for the "push the globals" function (optional)
    //
    *ppfnPushGlobals = (LPSVCHOST_PUSH_GLOBAL_FUNCTION) GetServiceDllFunction(
                                                            pService->pDll,
                                                            "SvchostPushServiceGlobals",
                                                            NULL);
}


LONG
ReadPerInstanceRegistryParameters(
    IN     HKEY             hkeySvchost,
    IN OUT PCOMMAND_OPTIONS pOptions
    )
{
    HKEY   hkeySvchostGroup;
    LONG   lr;

    // Read the value corresponding to this service group.
    //
    ASSERT (pOptions->ServiceGroupName);

    lr = RegQueryString (
            hkeySvchost,
            pOptions->ServiceGroupName,
            REG_MULTI_SZ,
            &ServiceNames);

    if (!lr && (!ServiceNames || !*ServiceNames))
    {
        lr = ERROR_INVALID_DATA;
    }

    // Read any per-instance parameters from the service group subkey
    // if it exists.
    //
    if (!RegOpenKeyEx (
            hkeySvchost,
            pOptions->ServiceGroupName,
            0, KEY_READ,
            &hkeySvchostGroup))
    {
        DWORD dwValue;

        if (!RegQueryDword (
                hkeySvchostGroup,
                TEXT("CoInitializeSecurityParam"),
                &dwValue))
        {
            pOptions->dwCoInitializeSecurityParam = dwValue;
        }

        if (pOptions->dwCoInitializeSecurityParam)
        {
            if (!RegQueryDword (
                    hkeySvchostGroup,
                    TEXT("AuthenticationLevel"),
                    &dwValue))
            {
                pOptions->dwAuthLevel = dwValue;
            }
            else
            {
                pOptions->dwAuthLevel = RPC_C_AUTHN_LEVEL_PKT;
            }

            if (!RegQueryDword (
                    hkeySvchostGroup,
                    TEXT("ImpersonationLevel"),
                    &dwValue))
            {
                pOptions->dwImpersonationLevel = dwValue;
            }
            else
            {
                pOptions->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            }

            if (!RegQueryDword (
                    hkeySvchostGroup,
                    TEXT("AuthenticationCapabilities"),
                    &dwValue))
            {
                pOptions->dwAuthCapabilities = dwValue;
            }
            else
            {
                pOptions->dwAuthCapabilities = EOAC_NO_CUSTOM_MARSHAL |
                                                 EOAC_DISABLE_AAA;
            }
        }

        if (!RegQueryDword (
                hkeySvchostGroup,
                TEXT("DefaultRpcStackSize"),
                &dwValue))
        {
            pOptions->dwDefaultRpcStackSize = dwValue;
        }

        RegCloseKey (hkeySvchostGroup);
    }

    return lr;
}


VOID
CallPerInstanceInitFunctions(
    IN OUT PCOMMAND_OPTIONS pOptions
    )
{
    if (pOptions->dwCoInitializeSecurityParam)
    {
        InitializeSecurity (
            pOptions->dwCoInitializeSecurityParam,
            pOptions->dwAuthLevel,
            pOptions->dwImpersonationLevel,
            pOptions->dwAuthCapabilities);
    }

    if (pOptions->dwDefaultRpcStackSize)
    {
        RpcMgmtSetServerStackSize(pOptions->dwDefaultRpcStackSize * 1024);
    }
    else
    {
        //
        // Make sure the default RPC stack size will be at least as
        // large as the default thread stack size for the process so
        // a random service calling RpcMgmtSetServerStackSize can't
        // set it to a value that's too low, causing overflows.
        //

        PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

        if (NtHeaders != NULL)
        {
            RpcMgmtSetServerStackSize((ULONG) NtHeaders->OptionalHeader.SizeOfStackCommit);
        }
    }
}


VOID
BuildServiceArray (
    IN OUT PCOMMAND_OPTIONS pOptions
    )
{
    LONG    lr;
    HKEY    hkeySvchost;

    // Open the Svchost key.
    //
    lr = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_PATH_SVCHOST,
            0, KEY_READ,
            &hkeySvchost);

    if (!lr)
    {
        lr = ReadPerInstanceRegistryParameters(hkeySvchost, pOptions);

        RegCloseKey (hkeySvchost);
    }

    if (!lr)
    {
        PTSTR pszServiceName;

        EnterCriticalSection (&ListLock);

        // Count the number of service names read.
        //
        ServiceCount = 0;
        for (pszServiceName = ServiceNames;
             *pszServiceName;
             pszServiceName += lstrlen(pszServiceName) + 1)
        {
            ServiceCount++;
        }
        ASSERT (ServiceCount);

        // Allocate memory for the service array.
        //
        ServiceArray = MemAlloc (HEAP_ZERO_MEMORY,
                            sizeof (SERVICE) * ServiceCount);
        if (ServiceArray)
        {
            PSERVICE pService;

            // Initialize the service array.
            //
            pService = ServiceArray;

            for (pszServiceName = ServiceNames;
                 *pszServiceName;
                 pszServiceName += lstrlen(pszServiceName) + 1)
            {
                pService->pszName = pszServiceName;

                pService++;
            }

            ASSERT (pService == ServiceArray + ServiceCount);
        }

        LeaveCriticalSection (&ListLock);
    }
}


// type of LPSERVICE_MAIN_FUNCTIONW
//
VOID
WINAPI
ServiceStarter(
    DWORD   argc,
    PWSTR   argv[]
    )
{
    LPSERVICE_MAIN_FUNCTION        pfnServiceMain = NULL;
    LPSVCHOST_PUSH_GLOBAL_FUNCTION pfnPushGlobals = NULL;
    LPCWSTR pszwService = argv[0];
    LPWSTR pszwAbort = NULL;
    DWORD  dwError = ERROR_FILE_NOT_FOUND;

    EnterCriticalSection (&ListLock);
    {
        UINT i;

        for (i = 0; i < ServiceCount; i++)
        {
            if (0 == lstrcmpi (pszwService, ServiceArray[i].pszName))
            {
#if DBG
                if (FDebugBreakForService (pszwService))
                {
                    SVCHOST_LOG1(TRACE,
                                "Attaching debugger before getting ServiceMain for %ws...",
                                pszwService);

                    DebugBreak ();
                }
#endif
                GetServiceMainFunctions(&ServiceArray[i],
                                        &pfnServiceMain,
                                        &pfnPushGlobals,
                                        &dwError);

                if (pfnServiceMain && pfnPushGlobals && !g_pSvchostSharedGlobals)
                {
                    SvchostBuildSharedGlobals();
                }

                pszwAbort = argv[0];
                break;
            }
        }
    }
    LeaveCriticalSection (&ListLock);

    if (pfnPushGlobals && g_pSvchostSharedGlobals)
    {
        pfnPushGlobals (g_pSvchostSharedGlobals);

        if (pfnServiceMain)
        {
            SVCHOST_LOG1(TRACE,
                         "Calling ServiceMain for %ws...\n",
                         pszwService);

            pfnServiceMain (argc, argv);
        }
        else if (pszwAbort)
        {
            AbortSvchostService(pszwAbort,
                                dwError);
        }
    }
    else if (pfnServiceMain && !pfnPushGlobals)
    {
        SVCHOST_LOG1(TRACE,
                     "Calling ServiceMain for %ws...\n",
                     pszwService);

        pfnServiceMain (argc, argv);
    }
    else if (pszwAbort)
    {
        AbortSvchostService(pszwAbort,
                            dwError);
    }
}


LPSERVICE_TABLE_ENTRY
BuildServiceTable(
    VOID
    )
{
    LPSERVICE_TABLE_ENTRY   pServiceTable;

    EnterCriticalSection (&ListLock);

    // Allocate one extra entry and zero the entire range.  The extra entry
    // is the table terminator required by StartServiceCtrlDispatcher.
    //
    pServiceTable = MemAlloc (HEAP_ZERO_MEMORY,
                        sizeof (SERVICE_TABLE_ENTRY) * (ServiceCount + 1));

    if (pServiceTable)
    {
        UINT i;

        for (i = 0; i < ServiceCount; i++)
        {
            pServiceTable[i].lpServiceName = ServiceArray[i].pszName;
            pServiceTable[i].lpServiceProc = ServiceStarter;

            SVCHOST_LOG1(TRACE,
                         "Added service table entry for %ws\n",
                         pServiceTable[i].lpServiceName);
        }
    }

    LeaveCriticalSection (&ListLock);

    return pServiceTable;
}


PCOMMAND_OPTIONS
BuildCommandOptions (
    LPCTSTR  pszCommandLine
    )
{
    PCOMMAND_OPTIONS    pOptions;
    ULONG               cbCommandLine;

    if (pszCommandLine == NULL)
    {
        return NULL;
    }

    cbCommandLine = (lstrlen(pszCommandLine) + 1) * sizeof (TCHAR);

    pOptions = MemAlloc (HEAP_ZERO_MEMORY,
                sizeof (COMMAND_OPTIONS) + cbCommandLine);
    if (pOptions)
    {
        TCHAR*  pch;
        TCHAR*  pArgumentStart;
        PTSTR* ppNextArgument = NULL;

        pOptions->CommandLineBuffer = (PTSTR) (pOptions + 1);
        RtlCopyMemory (
            pOptions->CommandLineBuffer,
            pszCommandLine,
            cbCommandLine);

        pch = pOptions->CommandLineBuffer;
        ASSERT (pch);

        // Skip the name of the executable.
        //
        pOptions->ImageName = pch;
        while (*pch && (L' ' != *pch) && (L'\t' != *pch))
        {
            pch++;
        }
        if (*pch)
        {
            *pch++ = 0;
        }

        SvchostCharLowerW (pOptions->ImageName);

        while (1)
        {
            // Skip whitespace.
            //
            while (*pch && ((L' ' == *pch) || (L'\t' == *pch)))
            {
                pch++;
            }

            // End of string?
            //
            if (!*pch)
            {
                break;
            }

            // Is it a '-' or '/' argument?
            //
            if (((L'-' == *pch) || (L'/' == *pch)) && *(++pch))
            {
                if ((L'k' == *pch) || (L'K' == *pch))
                {
                    pOptions->fServiceGroup = TRUE;
                    ppNextArgument = &pOptions->ServiceGroupName;
                }

                pch++;
                continue;
            }

            // This is the start of an argument.
            //
            pArgumentStart = pch;

            // If the argument starts with a quote, skip it and scan to the
            // next quote to terminate it.
            //
            if ((L'\"' == *pch) && *(++pch))
            {
                pArgumentStart = pch;

                while (*pch && (L'\"' != *pch))
                {
                    pch++;
                }
            }

            // otherwise, skip to the next whitespace and this will be
            // our argument.
            //
            else
            {
                while (*pch && (L' ' != *pch) && (L'\t' != *pch))
                {
                    pch++;
                }
            }

            if (*pch)
            {
                // terminate the newly found argument string.
                //
                *pch++ = 0;
            }

            if (ppNextArgument)
            {
                *ppNextArgument = pArgumentStart;
                ppNextArgument = NULL;
            }
        }

        pOptions->fServiceGroup = !!pOptions->ServiceGroupName;

        SVCHOST_LOG1(TRACE,
                     "Command line     : %ws\n",
                     pszCommandLine);

        SVCHOST_LOG1(TRACE,
                     "Service Group    : %ws\n",
                     (pOptions->fServiceGroup) ? pOptions->ServiceGroupName : L"No");

        // Validate the options.
        //
        if (!pOptions->fServiceGroup)
        {
            SVCHOST_LOG2(TRACE,
                         "Generic Service Host\n\n"
                         "%ws [-k <key>] | [-r] | <service>\n\n"
                         "   -k <key>   Host all services whose ImagePath matches\n"
                         "              %ws -k <key>.\n\n",
                         pOptions->CommandLineBuffer,
                         pOptions->CommandLineBuffer);

            MemFree (pOptions);
            pOptions = NULL;
        }
    }

    return pOptions;
}


VOID
SvchostCharLowerW(
    LPWSTR  pszString
    )
{
    //
    // LocalVersion of CharLower to avoid pulling in user32.dll
    //

    int   cwchT;
    DWORD cwch;

    if (pszString == NULL)
    {
        return;
    }

    cwch = (DWORD) wcslen(pszString) + 1;

    cwchT = LCMapStringW(LOCALE_USER_DEFAULT,
                         LCMAP_LOWERCASE,
                         pszString,
                         cwch,
                         pszString,
                         cwch);

    if (cwchT == 0)
    {
        SVCHOST_LOG1(ERROR,
                     "SvchostCharLowerW failed for %ws\n",
                     pszString);
    }

    return;
}


LONG
WINAPI
SvchostUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    return RtlUnhandledExceptionFilter(ExceptionInfo);
}


VOID
wmainCRTStartup (
    VOID
    )
{
    LPSERVICE_TABLE_ENTRY   pServiceTable = NULL;
    PCOMMAND_OPTIONS        pOptions;
    PCWSTR                  pszwCommandLine;

    SetUnhandledExceptionFilter(&SvchostUnhandledExceptionFilter);

    // Prevent critical errors from raising hard error popups and
    // halting svchost.exe.  The flag below will have the system send
    // the errors to the process instead.
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Initialize our HeapAlloc wrapper to use the process heap.
    //
    MemInit (GetProcessHeap());

    // Initialize our global DLL list, Service array, and the critical
    // section that protects them.  InitializeCriticalSection can throw a
    // STATUS_NO_MEMORY exception.  We want the process to exit if that
    // happens, so the default exception handler is fine.
    //
    InitializeListHead (&DllList);
    InitializeCriticalSection (&ListLock);

    // Build a COMMAND_OPTIONS structure and use it to grovel the registry
    // and create the service entry table.
    //
    pszwCommandLine = GetCommandLine ();

    pOptions = BuildCommandOptions (pszwCommandLine);
    if (pOptions)
    {
        BuildServiceArray (pOptions);

        pServiceTable = BuildServiceTable ();

        if (pServiceTable)
        {
            CallPerInstanceInitFunctions(pOptions);
        }

        MemFree (pOptions);
    }

    // If we have a valid service entry table, use it to transfer control
    // to the service controller.  StartServiceCtrlDispatcher won't return
    // until all services are stopped.
    //
    if (pServiceTable)
    {
        StartServiceCtrlDispatcher (pServiceTable);
    }

    SVCHOST_LOG1(TRACE,
                 "Calling ExitProcess for %ws\n",
                 pszwCommandLine);

    ExitProcess (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\client\api.c ===
#include "pch.h"
#pragma hdrstop
#include "internal.h"


DWORD
WINAPI
MyPublicApi1 (
    LPCWSTR pszwInput,
    LPWSTR* ppszwOutput,
    INT n
    )
{
    DWORD dwErr;

    __try
    {
        // validation
        dwErr = MyInternalApi1 (pszwInput, ppszwOutput, n);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    return dwErr;
}


DWORD
WINAPI
MyPublicApi2 (
    INT n
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\makefile.inc ===
#
# These are common to all sources files in this project.
# (Each sources file includes this file.)
#

TARGETPATH=obj

C_DEFINES=-DWIN32 -DUNICODE -D_UNICODE
MSC_WARNING_LEVEL=/W3 /WX
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(PROJDIR)\inc\pch.h
PRECOMPILED_OPTION=/Yu /Fp$(PROJDIR)\lib$(BUILD_ALT_DIR)\*\pch.pch
PRECOMPILED_TARGET=$(PROJDIR)\lib$(BUILD_ALT_DIR)\*\pch.pch
PRECOMPILED_OBJ=$(PROJDIR)\lib$(BUILD_ALT_DIR)\*\pch.obj
RCOPTIONS=-N
UMTYPE=windows
USE_NTDLL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\svcsnb.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    svcsnb.c

Abstract:

    NetBios support for services in svchost.exe.

    Background:
        In order to put the messenger service and the workstation service
        together in the same process, it became necessary to synchronize
        their use of NetBios.  If NetSend did a reset and added the
        computername via netbios, it isn't desirable for the messenger
        to then do a reset, and destroy that computername.

    Purpose:
        These functions help to synchronize the use of netbios.  A service
        that uses NetBios should first call the SvcsOpenNetBios function,
        then call SvcsResetNetBios.  The open causes a use count to be
        incremented.  The SvcsResetNetBios will only actually cause a
        NetBios reset if that Lan Adapter has not been reset yet.
        When the service stops it is necessary for it to call
        SvcsCloseNetBios.  Thus when the last service using NetBios
        terminates, we clear all the state flags, and allow the next
        call to SvcsResetNetBios to actually do a reset.

Author:

    Dan Lafferty (danl)     08-Nov-1993

Environment:

    User Mode -Win32


Revision History:

    08-Nov-1993     danl
        created

--*/
//
// INCLUDES
//

#include "pch.h"
#pragma hdrstop

#include <windows.h>
#include <nb30.h>      // NetBIOS 3.0 definitions
#include <lmerr.h>     // NERR_
#include <svcsnb.h>    // SvcNetBios prototypes

//
// DEFINES & MACROS
//
#define     NUM_DWORD_BITS          (sizeof(DWORD)*8)
#define     LANA_NUM_DWORDS         ((MAX_LANA/NUM_DWORD_BITS)+1)


//
// These values correspond to the constants defined in ntos\netbios\nbconst.h
// MAX_NUM_OF_SESSIONS=MAXIMUM_CONNECTION 
// MAX_NUM_OF_NAMES=MAXIMUM_ADDRESS -2
//
#define     MAX_NUM_OF_SESSIONS     254
#define     MAX_NUM_OF_NAMES        253
//
// GLOBALS
//
    CRITICAL_SECTION        SvcNetBiosCritSec={0};
    DWORD                   LanaFlags[LANA_NUM_DWORDS]={0};
    DWORD                   GlobalNetBiosUseCount=0;

//
// LOCAL FUNCTIONS
//
DWORD
SvcNetBiosStatusToApiStatus(
    UCHAR NetBiosStatus
    );

VOID
SetLanaFlag(
    UCHAR   uCharLanaNum
    );

BOOL
LanaFlagIsSet(
    UCHAR   uCharLanaNum
    );

VOID
SvcNetBiosInit(
    VOID
    )

/*++

Routine Description:

    Initializes a critical section and the global variable that it protects.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD   i;

    InitializeCriticalSection(&SvcNetBiosCritSec);

    for (i=0;i<LANA_NUM_DWORDS ;i++ ) {
        LanaFlags[i] = 0;
    }
    GlobalNetBiosUseCount = 0;
}

VOID
SvcNetBiosOpen(
    VOID
    )

/*++

Routine Description:

    This function is called by a service that will be making NetBios calls
    sometime in the future.  It increments a use count for NetBios usage.

    This allows us to keep track of the services using NetBios.
    When the last service is done using it, then all the Lan Adapters can
    be marked as being re-settable.


Arguments:


Return Value:


--*/
{
    EnterCriticalSection(&SvcNetBiosCritSec);
    GlobalNetBiosUseCount++;
    LeaveCriticalSection(&SvcNetBiosCritSec);

    return;
}

VOID
SvcNetBiosClose(
    VOID
    )

/*++

Routine Description:

    This function is called when the service is terminating and is
    no longer going to make any netbios calls.

    The UseCount for NetBios is decremented.  It it becomes zero (meaning
    that no services are using NetBios any longer), then the array of
    LanaFlags is re-initialized to 0.  Thus indicating that any of the
    Lan Adapters can now be reset.

Arguments:

Return Value:

    none.

--*/
{
    EnterCriticalSection(&SvcNetBiosCritSec);
    if (GlobalNetBiosUseCount > 0) {
        GlobalNetBiosUseCount--;
        if (GlobalNetBiosUseCount == 0) {
            DWORD   i;
            for (i=0;i<LANA_NUM_DWORDS ;i++ ) {
                LanaFlags[i] = 0;
            }
        }
    }
    LeaveCriticalSection(&SvcNetBiosCritSec);

    return;
}


DWORD
SvcNetBiosReset (
    UCHAR   LanAdapterNumber
    )
/*++

Routine Description:

    This function will cause a NetBios Reset to occur on the specified
    LanAdapter if that adapter is marked as having never been reset.
    When the adapter is reset, then the LanaFlag for that adapter is
    set to 1 indicating that it has been reset.  Future calls to reset that
    adapter will not cause a NetBios reset.

Arguments:

    LanAdapterNumber - This indicates which LanAdapter the reset should affect.

Return Value:

    Mapped response from NetBiosReset.  If the NetBios Reset has already
    been accomplished, then NO_ERROR is returned.

--*/
{
    DWORD   status = NO_ERROR;

    EnterCriticalSection(&SvcNetBiosCritSec);

    if (!LanaFlagIsSet(LanAdapterNumber)) {
        NCB Ncb;
        UCHAR NcbStatus;

        RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

        Ncb.ncb_command = NCBRESET;
        Ncb.ncb_lsn = 0;
        Ncb.ncb_callname[0] = MAX_NUM_OF_SESSIONS;
        Ncb.ncb_callname[1] = 0;
        Ncb.ncb_callname[2] = MAX_NUM_OF_NAMES;
        Ncb.ncb_callname[3] = 0;
        Ncb.ncb_lana_num = LanAdapterNumber;

        NcbStatus = Netbios(&Ncb);

        status = SvcNetBiosStatusToApiStatus(NcbStatus);
        if (status == NO_ERROR) {
            SetLanaFlag(LanAdapterNumber);
        }
    }
    LeaveCriticalSection(&SvcNetBiosCritSec);
    return(status);
}

DWORD
SvcNetBiosStatusToApiStatus(
    UCHAR NetBiosStatus
    )
{
    //
    // Slight optimization
    //
    if (NetBiosStatus == NRC_GOODRET) {
        return NERR_Success;
    }

    switch (NetBiosStatus) {
        case NRC_NORES:   return NERR_NoNetworkResource;

        case NRC_DUPNAME: return NERR_AlreadyExists;

        case NRC_NAMTFUL: return NERR_TooManyNames;

        case NRC_ACTSES:  return NERR_DeleteLater;

        case NRC_REMTFUL: return ERROR_REM_NOT_LIST;

        case NRC_NOCALL:  return NERR_NameNotFound;

        case NRC_NOWILD:
        case NRC_NAMERR:
                          return ERROR_INVALID_PARAMETER;

        case NRC_INUSE:
        case NRC_NAMCONF:
                          return NERR_DuplicateName;

        default:          return NERR_NetworkError;
    }

}
VOID
SetLanaFlag(
    UCHAR   uCharLanaNum
    )
{
    DWORD   LanaNum = (DWORD)uCharLanaNum;
    DWORD   BitMask=1;
    DWORD   DwordOffset;
    DWORD   BitShift;

    DwordOffset = LanaNum / NUM_DWORD_BITS;
    if (DwordOffset > LANA_NUM_DWORDS) {
        return;
    }

    BitShift = LanaNum - (DwordOffset * NUM_DWORD_BITS);

    BitMask = BitMask << BitShift;

    LanaFlags[DwordOffset] |= BitMask;
}

BOOL
LanaFlagIsSet(
    UCHAR   uCharLanaNum
    )
{
    DWORD   LanaNum = (DWORD)uCharLanaNum;
    DWORD   BitMask=1;
    DWORD   DwordOffset;
    DWORD   BitShift;

    DwordOffset = LanaNum / NUM_DWORD_BITS;

    if (DwordOffset > LANA_NUM_DWORDS) {
        return(FALSE);
    }
    BitShift = LanaNum - (DwordOffset * NUM_DWORD_BITS);

    BitMask = BitMask << BitShift;

    return ((BOOL) LanaFlags[DwordOffset] & BitMask );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\client\internal.h ===
#pragma once

extern CRITICAL_SECTION g_csLock;
extern HINSTANCE        g_hinst;


DWORD
MyInternalApi1 (
    LPCWSTR pszwInput,
    LPWSTR* ppszwOutput,
    INT n
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\client\internal.c ===
#include "pch.h"
#pragma hdrstop
#include "internal.h"

//+---------------------------------------------------------------------------
//
//  Ensure our service is running.  Call StartService and wait for the
//  to enter the SERVICE_RUNNING state.
//
DWORD
EnsureServiceRunning (
    VOID
    )
{
    // TBD
    return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Internal implementation of an API.
//
DWORD
MyInternalApi1 (
    LPCWSTR pszwInput,
    LPWSTR* ppszwOutput,
    INT n
    )
{
    DWORD dwErr;

    dwErr = EnsureServiceRunning ();

    if (ERROR_TIMEOUT == dwErr)
    {
        // Our service timed out trying to start.  This is bad.
        // Propagate the error out.
        //
    }
    else if (ERROR_SUCCESS == dwErr)
    {
        // Perform an RPC into our service as appropriate to satisfy
        // this call.
        //
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\client\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Sample client DLL"
#define VER_INTERNALNAME_STR            "sampcli.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\client\dllmain.c ===
#include "pch.h"
#pragma hdrstop

CRITICAL_SECTION    g_csLock;
HINSTANCE           g_hinst;


//+---------------------------------------------------------------------------
// DLL Entry Point
//
// DllMain should do as little work as possible.  Here's why:
//   1. Incorrectly assuming that thread attach/detach are 1:1. (explain)
//   2. Performance
//      a) touching pages (#3 below)
//      b) assume you will be loaded by someone who is performance-critical.
//
//   1. For every process that the DLL is attached to, DllMain gets called
//      with DLL_PROCESS_ATTACH.  For any new threads created or destroyed
//      after DLL_PROCESS_ATTACH, DllMain is called with DLL_THREAD_ATTACH
//      and DLL_THREAD_DETACH events.  Since it is rare that a DLL controls
//      or even knows about the clients that use it, it shouldn't assume
//      that DllMain is called only once (or even a small number of times).
//      In fact, you should assume the worst case (that it is called a lot)
//      and code for that case.  This is not unrealistic either.  If your
//      DLL gets attached to services.exe for example, you will be hit
//      with a lot of thread attach/detach events.  If you don't need these
//      events (and you shouldn't) your DllMain code needs to get paged in
//      (assuming it's not paged in) and called.
//
//   2. Over time, people tend to lose sight of why and when DLLs are loaded.
//      Further, as more APIs are added to the DLL the likelihood that the
//      DLL will be loaded increases.  (i.e. It becomes more useful.) It
//      is your responsibility to keep the performance of your DLL at a level
//      compatible with your most demanding (performance wise) client.  For
//      example: Say a very performance-critical client needs to use a small
//      piece of functionality in your DLL.  If you've done things in DllMain
//      (like create heaps, or access the registry, etc.) that don't strictly
//      need to be done to access that small piece of functionality, then
//      it is wasteful to do so and may be the straw that broke the camel's
//      back in terms of your client deciding your DLL is "too heavy" to be
//      used.  For the functionality in your DLL to "scale" from your first
//      very simple client to the Nth performance-critical client, you've got
//      to keep DllMain absolutely lean and mean.
//
//   3. Fewer code in DllMain means fewer pages touched when your DLL is
//      loaded.  If your DLL is loaded at all during boot of the OS or
//      an application, this means faster startup times.  Let's say it again
//      in another way -- "the more code you add to DllMain, the slower the
//      OS or application boots up".  You may think now that your DLL won't
//      be loaded during boot.  I'll bet most of the developers of the DLLs
//      that are now loaded during boot thought the same thing in the
//      beginning. ;-)  As your DLL becomes more useful, it gets used by
//      more and more parts of the system.
//
BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved
    )
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        // Syncrhonization support --
        // Unless you have *measured* lock contention, you should only need
        // one lock for the entire DLL.  (and maybe you don't even need one.)
        //
        InitializeCriticalSection (&g_csLock);

        // Save our instance handle in a global variable to be used
        // when loading resources etc.
        //
        g_hinst = hinst;

        // DisableThreadLibraryCalls tells the loader we don't need to
        // be informed of DLL_THREAD_ATTACH and DLL_THREAD_DETACH events.
        //
        DisableThreadLibraryCalls (hinst);

    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        DeleteCriticalSection (&g_csLock);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\inc\pch.h ===
#pragma once

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\server\internal.h ===
#pragma once

extern CRITICAL_SECTION g_csLock;
extern HINSTANCE        g_hinst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\server\internal.c ===
#include "pch.h"
#pragma hdrstop
#include "internal.h"

// This global variable is our indicator that we have been initialized.
//
volatile BOOL g_fInitializationComplete;

DWORD
EnsureInitialized (
    VOID
    )
{
    DWORD dwErr;

    // Most common case is we're already initialized.  Perform a quick
    // check for this.
    //
    if (g_fInitializationComplete)
    {
        return NOERROR;
    }

    dwErr = NOERROR;

    // Make no assumptions about how many threads may be trying to
    // initialize us at the same time.
    //
    EnterCriticalSection (&g_csLock);

    // Need to re-check after acquiring the lock because another thread
    // may have just finished initializing and released the lock allowing
    // us to get it.
    //
    if (!g_fInitializationComplete)
    {
        // Perorm initialization work here.
        //
        // dwErr = InitializeService ();

        // Initialization is complete.  Indicate so and leave.
        //
        g_fInitializationComplete = TRUE;
    }

    LeaveCriticalSection (&g_csLock);

    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Server-side implementation of an API.
//
DWORD
RpcEntryPointForMyInternalApi1 (
    LPCWSTR pszwInput,
    LPWSTR* ppszwOutput,
    INT n
    )
{
    DWORD dwErr;

    dwErr = EnsureInitialized ();
    if (!dwErr)
    {
        // Proceed with API implementation.
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\server\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Sample server DLL"
#define VER_INTERNALNAME_STR            "sampsrv.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\server\dllmain.c ===
#include "pch.h"
#pragma hdrstop

CRITICAL_SECTION    g_csLock;
HINSTANCE           g_hinst;


//+---------------------------------------------------------------------------
// DLL Entry Point
//
// DllMain should do as little work as possible.  Here's why:
//   1. Incorrectly assuming that thread attach/detach are 1:1. (explain)
//   2. Performance
//      a) touching pages (#3 below)
//      b) assume you will be loaded by someone who is performance-critical.
//
//   1. For every process that the DLL is attached to, DllMain gets called
//      with DLL_PROCESS_ATTACH.  For any new threads created or destroyed
//      after DLL_PROCESS_ATTACH, DllMain is called with DLL_THREAD_ATTACH
//      and DLL_THREAD_DETACH events.  Since it is rare that a DLL controls
//      or even knows about the clients that use it, it shouldn't assume
//      that DllMain is called only once (or even a small number of times).
//      In fact, you should assume the worst case (that it is called a lot)
//      and code for that case.  This is not unrealistic either.  If your
//      DLL gets attached to services.exe for example, you will be hit
//      with a lot of thread attach/detach events.  If you don't need these
//      events (and you shouldn't) your DllMain code needs to get paged in
//      (assuming it's not paged in) and called.
//
//   2. Over time, people tend to lose sight of why and when DLLs are loaded.
//      Further, as more APIs are added to the DLL the likelihood that the
//      DLL will be loaded increases.  (i.e. It becomes more useful.) It
//      is your responsibility to keep the performance of your DLL at a level
//      compatible with your most demanding (performance wise) client.  For
//      example: Say a very performance-critical client needs to use a small
//      piece of functionality in your DLL.  If you've done things in DllMain
//      (like create heaps, or access the registry, etc.) that don't strictly
//      need to be done to access that small piece of functionality, then
//      it is wasteful to do so and may be the straw that broke the camel's
//      back in terms of your client deciding your DLL is "too heavy" to be
//      used.  For the functionality in your DLL to "scale" from your first
//      very simple client to the Nth performance-critical client, you've got
//      to keep DllMain absolutely lean and mean.
//
//   3. Fewer code in DllMain means fewer pages touched when your DLL is
//      loaded.  If your DLL is loaded at all during boot of the OS or
//      an application, this means faster startup times.  Let's say it again
//      in another way -- "the more code you add to DllMain, the slower the
//      OS or application boots up".  You may think now that your DLL won't
//      be loaded during boot.  I'll bet most of the developers of the DLLs
//      that are now loaded during boot thought the same thing in the
//      beginning. ;-)  As your DLL becomes more useful, it gets used by
//      more and more parts of the system.
//
BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved
    )
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        // Syncrhonization support --
        // Unless you have *measured* lock contention, you should only need
        // one lock for the entire DLL.  (and maybe you don't even need one.)
        //
        InitializeCriticalSection (&g_csLock);

        // Save our instance handle in a global variable to be used
        // when loading resources etc.
        //
        g_hinst = hinst;

        // DisableThreadLibraryCalls tells the loader we don't need to
        // be informed of DLL_THREAD_ATTACH and DLL_THREAD_DETACH events.
        //
        DisableThreadLibraryCalls (hinst);

    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        DeleteCriticalSection (&g_csLock);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svchost\sample\server\svcmain.c ===
#include "pch.h"
#pragma hdrstop
#include "internal.h"


SERVICE_STATUS_HANDLE   g_hStatus;
SERVICE_STATUS          g_status;
HANDLE                  g_hShutdownEvent ;

VOID
UpdateServiceStatus (
    DWORD   dwState
    )
{
    ASSERT (g_hStatus);

    g_status.dwCurrentState = dwState;
    SetServiceStatus (g_hStatus, &g_status);
}

//+---------------------------------------------------------------------------
// ServiceHandler - Called by the service controller at various times.
//
// type of LPHANDLER_FUNCTION
//
VOID
WINAPI
ServiceHandler (
    DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        UpdateServiceStatus (SERVICE_STOP_PENDING);

        // set an event or otherwise signal that we are to quit.
        // e.g. RpcMgmtStopServerListening
        //
        SetEvent( g_hShutdownEvent );
        break;

    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
    default:
        // This may not be need, but refresh our status to the service
        // controller.
        //
        ASSERT (g_hStatus);
        SetServiceStatus (g_hStatus, &g_status);
        break;
    }
}

//+---------------------------------------------------------------------------
// ServiceMain - Called by svchost when starting this service.
//
// type of LPSERVICE_MAIN_FUNCTIONW
//
VOID
WINAPI
ServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    // Since we run in svchost.exe, we must have the 'share process' bit set.
    //
    ZeroMemory (&g_status, sizeof(g_status));
    g_status.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS;
    g_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    // Register the service control handler.
    //
    DbgPrint( "Starting MyService\n" );
    g_hStatus = RegisterServiceCtrlHandler (TEXT("myservice"), ServiceHandler);
    if (g_hStatus)
    {
        // Immediately report that we are running.  All non-essential
        // initialization is deferred until we are called by clients to
        // do some work.
        //
        UpdateServiceStatus (SERVICE_RUNNING);

        g_hShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

        // Setup RPC and call RpcServerListen.
        //
        // RpcMgmtWaitServerListen (NULL);

        WaitForSingleObject( g_hShutdownEvent, INFINITE );

        UpdateServiceStatus (SERVICE_STOPPED);
    }
    else 
    {
        DbgPrint( "RegisterServiceCtrlHandler failed!  %d\n", GetLastError() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svcslib\threads.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    THREADS.C

Abstract:

    This file contains thread management routines.  Callers can register
    waitable object handles and the functions to be called when a handle
    becomes signaled.  Also, work items can be queued, and operated on when
    threads become free.

    The implementation of the CWorkItemContext class resides in this file

Author:

    Dan Lafferty (danl) 10-Jan-1994

Environment:

    User Mode - Win32

Revision History:

    21-Jan-1999 jschwart
        Removed -- Service Controller and intrinsic services now use
        NT thread pool APIs.

    27-Jun-1997 anirudhs
        SvcObjectWatcher: Fixed bug that sent WAIT_OBJECT_0 to all timed-
        out work items even when only one was signaled.
        Made global arrays static instead of heap-allocated.

    04-Dec-1996 anirudhs
        Added CWorkItemContext, a higher-level wrapper for SvcAddWorkItem.

    01-Nov-1995 anirudhs
        SvcAddWorkItem: Fixed race condition wherein a DLL could add a
        work item and another thread would execute the work item, decrement
        the DLL ref count and unload the DLL before its ref count was
        incremented.

    18-Jul-1994 danl
        TmWorkerThread:  Fixed Access Violation problem which will occur
        if pWorkItem is NULL and we go on to see if the DLL should be
        free'd.  Now we check to see if pWorkItem is NULL first.

    10-Jan-1994 danl
        Created

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <scdebug.h>
#include <svcslib.h>            // CWorkItemContext


//----------
// GLOBALS
//----------

    HANDLE CWorkItemContext::s_hNeverSignaled;


VOID
CWorkItemContext::CallBack(
    IN PVOID    pContext
    )

/*++

Routine Description:

    Wrapper function for the Perform method that is supplied by derived classes.

--*/
{
    //
    // Timeout value is meaningless in this case, so tell the
    // derived class it was signaled
    //
    (((CWorkItemContext *) pContext)->Perform(FALSE));
}


VOID
CWorkItemContext::DelayCallBack(
    IN PVOID    pContext,
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

    Wrapper function for the Perform method that is supplied by derived classes.

--*/
{
    (((CWorkItemContext *) pContext)->Perform(fWaitStatus));
}


BOOL
CWorkItemContext::Init(
    )
{
    ASSERT(s_hNeverSignaled == NULL);
    s_hNeverSignaled = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (s_hNeverSignaled == NULL)
    {
        SC_LOG(ERROR, "Couldn't create never-signaled event, %lu\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}


void
CWorkItemContext::UnInit(
    )
{
    if (s_hNeverSignaled != NULL)
    {
        CloseHandle(s_hNeverSignaled);
    }
}


NTSTATUS
CWorkItemContext::AddDelayedWorkItem(
    IN  DWORD    dwTimeout,
    IN  DWORD    dwFlags
    )

/*++

Routine Description:

    Queues a work item to take the action after the delay has elapsed.

--*/
{
    //
    // Give RtlRegisterWait a waitable handle that will never get signaled
    // to force it to timeout.  (Hack!)
    //
    // CODEWORK  Use an RtlTimerQueue instead
    //
    if (s_hNeverSignaled == NULL)
    {
        SC_LOG0(ERROR, "Never-signaled event wasn't created\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // The timeout mustn't be infinite
    //
    SC_ASSERT(dwTimeout != INFINITE);

    return (RtlRegisterWait(&m_hWorkItem,         // work item handle
                            s_hNeverSignaled,     // waitable handle
                            DelayCallBack,        // callback
                            this,                 // pContext;
                            dwTimeout,            // timeout
                            dwFlags));            // flags
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Imports.h

Abstract:

    This file allows us to include standard system header files in the
    regrpc.idl file.  The regrpc.idl file imports a file called
    imports.idl.  This allows the regrpc.idl file to use the types defined
    in these header files.  It also causes the following line to be added
    in the MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    David J. Gilman (davegi) 28-Jan-1992

--*/

#ifndef __IMPORTS_H__
#define __IMPORTS_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winreg.h>

typedef struct _RVALENT {       // Remote Value entry for RegQueryMultipleValues
        PUNICODE_STRING rv_valuename;
        DWORD   rv_valuelen;
        DWORD   rv_valueptr;
        DWORD   rv_type;
} RVALENT;

typedef RVALENT *PRVALENT;

//
// NT 3.1, 3.5 and 3.51 have no implementation of BaseRegGetVersion so this
// number is irrelevant to them.
//
// For a Win95 registry REMOTE_REGISTRY_VERSION should be == 4. Unfortunately,
// someone a bit confused by the concept of a pointer mis-implented the
// Win95 BaseRegGetVersion and it does not actually return a version number.
// So we detect Win95 by assuming anything that succeeds but returns
// a dwVersion outside the range 5-10.
//
// For an NT 4.0 registry, REMOTE_REGISTRY_VERSION==5.
//
// Win95 has the following bugs than NT 4.0 works around on the client side:
//  - BaseRegQueryInfoKey does not account for Unicode value names & data correctly
//  - BaseRegEnumValue returns value data length that is one WCHAR more than it
//    really should be for REG_SZ, REG_MULTI_SZ, and REG_EXPAND_SZ types.
//

#define WIN95_REMOTE_REGISTRY_VERSION 4
#define REMOTE_REGISTRY_VERSION 5

#define IsWin95Server(h,v) ((BaseRegGetVersion(h,&v)==ERROR_SUCCESS) &&  \
                            ((v < 5) || (v > 10)))

//
//  BOOL
//  IsPredefinedRegistryHandle(
//      IN RPC_HKEY     Handle
//      );
//

#define IsPredefinedRegistryHandle( h )                                     \
    ((  ( h == HKEY_CLASSES_ROOT        )                                   \
    ||  ( h == HKEY_CURRENT_USER        )                                   \
    ||  ( h == HKEY_LOCAL_MACHINE       )                                   \
    ||  ( h == HKEY_PERFORMANCE_DATA    )                                   \
    ||  ( h == HKEY_PERFORMANCE_TEXT    )                                   \
    ||  ( h == HKEY_PERFORMANCE_NLSTEXT )                                   \
    ||  ( h == HKEY_USERS               )                                   \
    ||  ( h == HKEY_CURRENT_CONFIG      )                                   \
    ||  ( h == HKEY_DYN_DATA            ))                                  \
    ?   TRUE                                                                \
    :   FALSE )

//
// RPC constants.
//

#define INTERFACE_NAME  L"winreg"
#define BIND_SECURITY   L"Security=Impersonation Dynamic False"

//
// External synchronization event.
//

#define PUBLIC_EVENT    "Microsoft.RPC_Registry_Server"

//
// Force the implementation of the API to be explicit (i.e wrt ANSI or
// UNICODE) about what other Registry APIs are called.
//

#undef RegCloseKey
#undef RegConnectRegistry
#undef RegCreateKey
#undef RegCreateKeyEx
#undef RegDeleteKey
#undef RegDeleteValue
#undef RegEnumKey
#undef RegEnumKeyEx
#undef RegEnumValue
#undef RegFlushKey
#undef RegGetKeySecurity
#undef RegNotifyChangeKeyValue
#undef RegOpenKey
#undef RegOpenKeyEx
#undef RegQueryInfoKey
#undef RegQueryValue
#undef RegQueryValueEx
#undef RegRestoreKey
#undef RegSaveKey
#undef RegSaveKeyEx
#undef RegSetKeySecurity
#undef RegSetValue
#undef RegSetValueEx

//
// Additional type for string arrays.
//

typedef CHAR    STR;

//
// Default values for Win 3.1 requested access.
//

#define WIN31_REGSAM                MAXIMUM_ALLOWED

#endif //__IMPORTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\sc\svcslib\svcslib.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SVCSLIB.C

Abstract:

    Contains code for attaching services to the service controller process.
    This file contains the following functions:
        SvcStartLocalDispatcher
        SvcServiceEntry
        SvcLoadDllAndStartSvc
        DummyCtrlHandler
        AbortService

Author:

    Dan Lafferty (danl)     25-Oct-1993

Environment:

    User Mode - Win32

Revision History:

    25-Oct-1993         Danl
        created

--*/

//
// INCLUDES
//

#include <scpragma.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windows.h>
#include <winsvc.h>             // Service control APIs
#include <scdebug.h>
#include <svcsp.h>              // SVCS_ENTRY_POINT, SVCS_GLOBAL_DATA
#include <scseclib.h>           //
#include <lmsname.h>            // Lanman Service Names
#include <ntrpcp.h>             // Rpcp... function prototypes
#include <svcslib.h>            // SetupInProgress


//--------------------------
// Definitions and Typedefs
//--------------------------
#define THREAD_WAIT_TIMEOUT     100    // 100 msec timeout

typedef struct _SVCDLL_TABLE_ENTRY {
    LPCWSTR      lpServiceName;
    LPCWSTR      lpDllName;
    LPCSTR       lpServiceEntrypoint;
}SVCDLL_TABLE_ENTRY, *PSVCDLL_TABLE_ENTRY;

//
// Storage for well-known SIDs.  Passed to each service entry point.
//
    SVCS_GLOBAL_DATA GlobalData;

//--------------------------
// FUNCTION PROTOTYPES
//--------------------------
VOID
SvcServiceEntry (           // Ctrl Dispatcher calls here to start service.
    IN DWORD argc,
    IN LPTSTR *argv
    );

VOID
SvcLoadDllAndStartSvc (     // Loads and invokes service DLL
    IN CONST SVCDLL_TABLE_ENTRY * pDllEntry,
    IN DWORD                      argc,
    IN LPTSTR                     argv[]
    );

VOID
DummyCtrlHandler(           // used if cant find Services Dll or entry pt.
    DWORD   Opcode
    );

VOID
AbortService(               // used if cant find Services Dll or entry pt.
    LPWSTR  ServiceName,
    DWORD   Error
    );

VOID
DispatcherThread(
    VOID
    );

//--------------------------
// GLOBALS
//--------------------------
//
// Dispatch table for all services. Passed to StartServiceCtrlDispatcher.
//
// Add new service entries here and in the DLL name list.
//

const SERVICE_TABLE_ENTRY SvcServiceDispatchTable[] = {
                        { L"EVENTLOG",          SvcServiceEntry },
                        { L"PlugPlay",          SvcServiceEntry },

                        //
                        // Do NOT add new services here.
                        //

                        { NULL,                 NULL            }
                        };

//
// DLL names for all services.
//

const SVCDLL_TABLE_ENTRY SvcDllTable[] = {
                        { L"EVENTLOG",          L"eventlog.dll", "SvcEntry_Eventlog"         },
                        { L"PlugPlay",          L"umpnpmgr.dll", "SvcEntry_PlugPlay"         },
                        
                        //
                        // Do NOT add new services here.
                        //

                        { NULL,                 NULL            }
                        };


DWORD
SvcStartLocalDispatcher(
    VOID
    )

/*++

Routine Description:

    This function initializes global data for the services to use, and
    then starts a thread for the service control dispatcher.

Arguments:


Return Value:

    NO_ERROR - If the dispatcher was started successfully.

    otherwise - Errors due to thread creation, or starting the dispatcher
        can be returned.

--*/
{
    DWORD   status = NO_ERROR;
    DWORD   waitStatus = NO_ERROR;
    DWORD   threadId;
    HANDLE  hThread;

    //
    // Populate the global data structure.
    //

    GlobalData.NullSid              = NullSid;
    GlobalData.WorldSid             = WorldSid;
    GlobalData.LocalSid             = LocalSid;
    GlobalData.NetworkSid           = NetworkSid;
    GlobalData.LocalSystemSid       = LocalSystemSid;
    GlobalData.LocalServiceSid      = LocalServiceSid;
    GlobalData.NetworkServiceSid    = NetworkServiceSid;
    GlobalData.BuiltinDomainSid     = BuiltinDomainSid;
    GlobalData.AuthenticatedUserSid = AuthenticatedUserSid;

    GlobalData.AliasAdminsSid       = AliasAdminsSid;
    GlobalData.AliasUsersSid        = AliasUsersSid;
    GlobalData.AliasGuestsSid       = AliasGuestsSid;
    GlobalData.AliasPowerUsersSid   = AliasPowerUsersSid;
    GlobalData.AliasAccountOpsSid   = AliasAccountOpsSid;
    GlobalData.AliasSystemOpsSid    = AliasSystemOpsSid;
    GlobalData.AliasPrintOpsSid     = AliasPrintOpsSid;
    GlobalData.AliasBackupOpsSid    = AliasBackupOpsSid;

    GlobalData.StartRpcServer       = RpcpStartRpcServer;
    GlobalData.StopRpcServer        = RpcpStopRpcServer;
    GlobalData.SvcsRpcPipeName      = SVCS_RPC_PIPE;

    GlobalData.fSetupInProgress     = SetupInProgress(NULL, NULL);

    //--------------------------------------------------
    // Create the thread for the dispatcher to run in.
    //--------------------------------------------------
    hThread = CreateThread (
        NULL,                                       // Thread Attributes.
        0L,                                         // Stack Size
        (LPTHREAD_START_ROUTINE)DispatcherThread,   // lpStartAddress
        NULL,                                       // lpParameter
        0L,                                         // Creation Flags
        &threadId);                                 // lpThreadId

    if (hThread == (HANDLE) NULL) {
        status = GetLastError();
        SC_LOG1(ERROR,"[SERVICES]CreateThread failed %d\n",status);
        return(status);
    }

    //
    // Wait on Thread handle for a moment to make sure the dispatcher is
    // running.
    //
    waitStatus = WaitForSingleObject(hThread, THREAD_WAIT_TIMEOUT);

    if (waitStatus != WAIT_TIMEOUT) {
        GetExitCodeThread(hThread, &status);
    }

    CloseHandle(hThread);
    return(status);
}


VOID
SvcServiceEntry (
    IN DWORD argc,
    IN LPTSTR *argv
    )

/*++

Routine Description:

    This is the thunk routine for the Alerter service.  It loads the DLL
    that contains the service and calls its main routine.

Arguments:

    argc - Argument Count

    argv - Array of pointers to argument strings.  The first is always
        the name of the service.

Return Value:

    None.

--*/

{
    const SVCDLL_TABLE_ENTRY * pDllEntry = SvcDllTable;

    if (argc == 0) {
        SC_LOG0(ERROR,"[SERVICES]SvcServiceEntry: ServiceName was not passed in\n");
        return;
    }

    while (pDllEntry->lpServiceName != NULL) {
        if (_wcsicmp(pDllEntry->lpServiceName, argv[0]) == 0) {
            SC_LOG3(TRACE, "[SERVICES]SvcServiceEntry: "
                           "Service = %ws, Dll = %ws, argv[0] = %ws\n",
                    pDllEntry->lpServiceName, pDllEntry->lpDllName, argv[0]);
            SvcLoadDllAndStartSvc( pDllEntry, argc, argv );
            return;
        }
        pDllEntry++;
    }
    AbortService(argv[0], ERROR_MOD_NOT_FOUND);
    return;
}


VOID
SvcLoadDllAndStartSvc (
    IN CONST SVCDLL_TABLE_ENTRY * pDllEntry,
    IN DWORD                      argc,
    IN LPTSTR                     argv[]
    )

/*++

Routine Description:

    This routine loads the DLL that contains a service and calls its
    main routine.  Note that if a service is stopped and restarted,
    we simply call LoadLibrary again since it increments a refcount
    for already-loaded DLLs.

Arguments:

    DllName - name of the DLL

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    PSVCS_SERVICE_DLL_ENTRY   serviceEntry;
    HINSTANCE                 dllHandle = NULL;
    DWORD                     Error;

    //
    // Load the DLL that contains the service.
    //

    dllHandle = LoadLibrary( pDllEntry->lpDllName );

    if ( dllHandle == NULL ) {
        Error = GetLastError();
        SC_LOG2(ERROR,
                "SERVICES: Failed to load DLL %ws: %ld\n",
                pDllEntry->lpDllName,
                Error);

        AbortService(argv[0], Error);
        return;
    }

    //
    // Get the address of the service's main entry point.  First try the
    // new, servicename-specific entrypoint naming scheme
    //
    serviceEntry = (PSVCS_SERVICE_DLL_ENTRY)GetProcAddress(
                                                dllHandle,
                                                pDllEntry->lpServiceEntrypoint
                                                );

    if (serviceEntry == NULL) {

        SC_LOG3(TRACE,
                "SERVICES: Can't find entry %s in DLL %ws: %ld\n",
                pDllEntry->lpServiceEntrypoint,
                pDllEntry->lpDllName,
                GetLastError());

        //
        // That didn't work -- let's try the well-known entrypoint
        // 
        serviceEntry = (PSVCS_SERVICE_DLL_ENTRY)GetProcAddress(
                                                    dllHandle,
                                                    SVCS_ENTRY_POINT_STRING
                                                    );
        if ( serviceEntry == NULL ) {

            Error = GetLastError();
            SC_LOG3(ERROR,
                    "SERVICES: Can't find entry %s in DLL %ws: %ld\n",
                    SVCS_ENTRY_POINT_STRING,
                    pDllEntry->lpDllName,
                    Error);

            AbortService(argv[0], Error);
            return;
        }
    }

    //
    // We found the service's main entry point -- call it.
    //
    serviceEntry( argc, argv, &GlobalData, NULL);

    return;

} // SvcLoadDllAndStartSvc


VOID
DummyCtrlHandler(
    DWORD   Opcode
    )
/*++

Routine Description:

    This is a dummy control handler which is only used if we can't load
    a services DLL entry point.  Then we need this so we can send the
    status back to the service controller saying we are stopped, and why.

Arguments:

    OpCode - Ignored

Return Value:

    None.

--*/

{
    return;

} // DummyCtrlHandler


VOID
AbortService(
    LPWSTR  ServiceName,
    DWORD   Error)
/*++

Routine Description:

    This is called if we can't load the entry point for a service.  It
    gets a handle so it can call SetServiceStatus saying we are stopped
    and why.

Arguments:

    ServiceName - the name of the service that couldn't be started
    Error - the reason it couldn't be started

Return Value:

    None.

--*/
{
    SERVICE_STATUS_HANDLE   GenericServiceStatusHandle;
    SERVICE_STATUS          GenericServiceStatus;

    GenericServiceStatus.dwServiceType        = SERVICE_WIN32;
    GenericServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    GenericServiceStatus.dwControlsAccepted   = SERVICE_CONTROL_STOP;
    GenericServiceStatus.dwCheckPoint         = 0;
    GenericServiceStatus.dwWaitHint           = 0;
    GenericServiceStatus.dwWin32ExitCode      = Error;
    GenericServiceStatus.dwServiceSpecificExitCode = 0;

    GenericServiceStatusHandle = RegisterServiceCtrlHandler(
                ServiceName,
                DummyCtrlHandler);

    if (GenericServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        SC_LOG1(ERROR,"[SERVICES] RegisterServiceCtrlHandler failed %d\n",
            GetLastError());
    }
    else if (!SetServiceStatus (GenericServiceStatusHandle,
                &GenericServiceStatus)) {
        SC_LOG1(ERROR,"[SERVICES] SetServiceStatus error %ld\n", GetLastError());
    }

    return;
}

VOID
DispatcherThread(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   status=NO_ERROR;

    //
    // Call StartServiceCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    if (! StartServiceCtrlDispatcher (
                SvcServiceDispatchTable
                )) {

        status = GetLastError();
        SC_LOG1(ERROR, "SERVICES: Failed to start control dispatcher %lu\n",
            status);
    }
    ExitThread(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\client.h ===
/*++


Copyright (c) 1992 Microsoft Corporation

Module Name:

    client.h

Abstract:

    This module is the header file for the client side of the Win32 DLL

Author:

    Ramon J. San Andres (ramonsa) 13-May-1992

--*/

#if DBG
    extern BOOLEAN  BreakPointOnEntry;
#endif

//
// Macros to manage local versus remote handles (HKEYs), as
// well as class registration keys from HKEY_CLASSES_ROOT
//

#define REMOTE_HANDLE_TAG    ( 0x00000001 )

#define REG_CLASSES_MASK     ( 0x00000003 )
#define REG_CLASSES_SPECIAL_TAG ( 0x00000002 )

//
//  BOOL
//  IsLocalHandle(
//      IN HKEY Handle
//      );
//

#define IsLocalHandle( Handle )                                         \
    ( ! ((( DWORD_PTR )( Handle )) & REMOTE_HANDLE_TAG ))

//
//  BOOL
//  IsSpeciaClassesHandle(
//      IN HKEY Handle
//      );
//

#define IsSpecialClassesHandle( Handle )                                 \
    ( ((( DWORD_PTR )( Handle )) & REG_CLASSES_SPECIAL_TAG ))


//
//  VOID
//  TagRemoteHandle(
//      IN PHKEY Handle
//      );
//

#define TagRemoteHandle( Handle )                                       \
    ASSERT( IsLocalHandle( *Handle ));                                  \
    ( *Handle = (( HKEY )((( DWORD_PTR )( *Handle )) | REMOTE_HANDLE_TAG )))

//
//  HKEY
//  DereferenceRemoteHandle(
//      IN HKEY Handle
//      );
//

#define DereferenceRemoteHandle( Handle )                               \
    (( HKEY )((( DWORD_PTR )( Handle )) & ~REMOTE_HANDLE_TAG ))

//
//  HKEY
//  TagSpecialClassesHandle (
//      IN HKEY Handle
//      );
//

#define TagSpecialClassesHandle( Handle )                                       \
    ASSERT( IsLocalHandle( *Handle ));                                  \
    ( *Handle = (( HKEY )((( ULONG_PTR )( *Handle )) | REG_CLASSES_SPECIAL_TAG )))


//
// disable predefined cache not enabled on remote !
//
#define CLOSE_LOCAL_HANDLE(TempHandle)                              \
    if( TempHandle != NULL ) {                                      \
        /* disable cache is not enabled on remote registry */       \
        ASSERT( IsLocalHandle(TempHandle) );                        \
        LocalBaseRegCloseKey(&TempHandle);                          \
    }

#if defined(LEAK_TRACK)


typedef struct _RegLeakTraceInfo {
    DWORD   dwMaxStackDepth;
    LPTSTR  szSymPath;
    BOOL    bEnableLeakTrack;

} RegLeakTraceInfo;


extern RegLeakTraceInfo g_RegLeakTraceInfo;

#endif // LEAK_TRACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\init.c ===
/*++


Copyright (c) 1991 Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module contains the entry point for the Win32 Registry APIs
    client side DLL.

Author:

    David J. Gilman (davegi) 06-Feb-1992

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include "ntconreg.h"

#if DBG
BOOLEAN BreakPointOnEntry = FALSE;
#endif

BOOL LocalInitializeRegCreateKey();
BOOL LocalCleanupRegCreateKey();
BOOL InitializePredefinedHandlesTable();
BOOL CleanupPredefinedHandlesTable();
BOOL InitializeClassesRoot();
BOOL CleanupClassesRoot(BOOL fOnlyThisThread);

#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)

BOOL InitializeInstrumentedRegClassHeap();
BOOL CleanupInstrumentedRegClassHeap();

#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

#if defined(LEAK_TRACK)
BOOL InitializeLeakTrackTable();
BOOL CleanupLeakTrackTable();
#endif // defined (LEAK_TRACK)


enum
{
    ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD = 1,
    ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD = 2
};

HKEY HKEY_ClassesRoot = NULL;

extern BOOL gbDllHasThreadState ;

BOOL
RegInitialize (
    IN HANDLE   Handle,
    IN DWORD    Reason,
    IN PVOID    Reserved
    )

/*++

Routine Description:

    Returns TRUE.

Arguments:

    Handle      - Unused.

    Reason      - Unused.

    Reserved    - Unused.

Return Value:

    BOOL        - Returns TRUE.

--*/

{
    UNREFERENCED_PARAMETER( Handle );

    switch( Reason ) {

    case DLL_PROCESS_ATTACH:

#ifndef REMOTE_NOTIFICATION_DISABLED
        if( !InitializeRegNotifyChangeKeyValue( ) ||
            !LocalInitializeRegCreateKey() ||
            !InitializePredefinedHandlesTable() ) {
            return( FALSE );

        }
#else
#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)
        if ( !InitializeInstrumentedRegClassHeap()) {
            return FALSE;
        }
#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

        if( !LocalInitializeRegCreateKey() ||
            !InitializePredefinedHandlesTable() ||
            !InitializeClassesRoot()) {
            return( FALSE );

        }
#endif
#if defined(LEAK_TRACK)
        InitializeLeakTrackTable();
        // ginore errors
#endif // LEAK_TRACK
        return( TRUE );
        break;

    case DLL_PROCESS_DETACH:

        // Reserved == NULL when this is called via FreeLibrary,
        //    we need to cleanup Performance keys.
        // Reserved != NULL when this is called during process exits,
        //    no need to do anything.

        if( Reserved == NULL &&
            !CleanupPredefinedHandles()) {
            return( FALSE );
        }

        //initialized and used in ..\server\regclass.c
        if (NULL != HKEY_ClassesRoot)
            NtClose(HKEY_ClassesRoot);

#ifndef REMOTE_NOTIFICATION_DISABLED
        if( !CleanupRegNotifyChangeKeyValue( ) ||
            !LocalCleanupRegCreateKey() ||
            !CleanupPredefinedHandlesTable() ||
            !CleanupClassesRoot( FALSE ) {
            return( FALSE );
        }
#else
        if( !LocalCleanupRegCreateKey() ||
            !CleanupPredefinedHandlesTable() ||
            !CleanupClassesRoot( FALSE )) {
            return( FALSE );
        }
#if defined(LEAK_TRACK)
        CleanupLeakTrackTable();
#endif // LEAK_TRACK
#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)
        if ( !CleanupInstrumentedRegClassHeap()) {
            return FALSE;
        }
#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)
#endif
        if ( !PerfRegCleanup() ) {
            return FALSE;
        }

        return( TRUE );
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:

        if ( gbDllHasThreadState ) {

            return CleanupClassesRoot( TRUE );
        }

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regclass.c ===
/*++




Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regclass.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to open the classes root key for a specified user.

        - RegOpenUserClassesRoot

Author:

    Adam Edwards (adamed) 15-Apr-1998

Notes:

    This API is local only.
    See the notes in server\regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <malloc.h>

#define REG_USER_CLASSES_PREFIX L"\\Registry\\User\\"
#define REG_USER_CLASSES_SUFFIX L"_Classes"

BOOL InitializeClassesEnumTable();
BOOL InitializeClassesNameSpace();

BOOL CleanupClassesEnumTable(DWORD dwCriteria);
BOOL CleanupClassesNameSpace();

#if defined(LEAK_TRACK)
NTSTATUS TrackObject(HKEY hKey);
#endif // defined(LEAK_TRACK)

extern BOOL gbCombinedClasses;


LONG
APIENTRY
RegOpenUserClassesRoot(
    HANDLE hToken,
    DWORD  dwOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for opening the classes root key
    for the use specified by the hToken parameter.

Arguments:

    hToken - token for user whose classes root is to be opened. If 
        this parameter is NULL, we return ERROR_INVALID_PARAMETER

    phkResult - Returns an open handle to the newly opened key.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:


--*/

{
    NTSTATUS            Status;
    UNICODE_STRING      UsersHive;
    BYTE achBuffer[100];
    PTOKEN_USER pTokenInfo = (PTOKEN_USER) &achBuffer;
    DWORD dwBytesRequired;
    LONG Error;

    //
    //  Caller must pass pointer to the variable where the opened handle
    //  will be returned
    //

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == hToken) {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwOptions != REG_OPTION_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!gbCombinedClasses) {
        return ERROR_FILE_NOT_FOUND;
    }
    
    //
    // open up the token to get the sid
    //

    if (!GetTokenInformation(
        hToken,                    // Handle
        TokenUser,                 // TokenInformationClass
        pTokenInfo,                // TokenInformation
        sizeof(achBuffer),         // TokenInformationLength
        &dwBytesRequired           // ReturnLength
        )) {

        Error = GetLastError();

        //
        // Try again if the buffer was too small
        //

        if (ERROR_INSUFFICIENT_BUFFER != Error) {
            return Error ;
        }

        //
        // Allocate space for the user info
        //

        pTokenInfo = (PTOKEN_USER) alloca(dwBytesRequired);

        if (!pTokenInfo) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }


        //
        // Read in the UserInfo
        //

        if (!GetTokenInformation(
            hToken,                // Handle
            TokenUser,                 // TokenInformationClass
            pTokenInfo,                // TokenInformation
            dwBytesRequired,           // TokenInformationLength
            &dwBytesRequired           // ReturnLength
            )) {
            return GetLastError();
        }
    }

    //
    //  Change sid to a string
    //

    Status = RtlConvertSidToUnicodeString(
        &UsersHive,
        pTokenInfo->User.Sid,
        TRUE); // allocate the string

    if (NT_SUCCESS(Status)) {
        
        UNICODE_STRING UserClassesString;

        UserClassesString.MaximumLength = UsersHive.Length + 
            sizeof(REG_USER_CLASSES_PREFIX) + 
            sizeof(REG_USER_CLASSES_SUFFIX);

        UserClassesString.Buffer = (WCHAR*) alloca(UserClassesString.MaximumLength);

        if (UserClassesString.Buffer) {

            UNICODE_STRING UserPrefix;

            //
            // construct the name
            //

            RtlInitUnicodeString(&UserPrefix, REG_USER_CLASSES_PREFIX);

            RtlCopyUnicodeString(&UserClassesString, &UserPrefix);

            Status = RtlAppendUnicodeStringToString(&UserClassesString, &UsersHive);

            if (NT_SUCCESS(Status)) {
                Status = RtlAppendUnicodeToString(&UserClassesString, 
                                                  REG_USER_CLASSES_SUFFIX);
            }

            if (NT_SUCCESS(Status)) {

                OBJECT_ATTRIBUTES Obja;

                // open this key
                InitializeObjectAttributes(
                    &Obja,
                    &UserClassesString,
                    OBJ_CASE_INSENSITIVE,
                    NULL, // using absolute path, no hkey
                    NULL);

                Status = NtOpenKey(
                    phkResult,
                    samDesired,
                    &Obja);
            }

        } else {
            Status = STATUS_NO_MEMORY;
        }

        RtlFreeUnicodeString(&UsersHive);

    }

    if (NT_SUCCESS(Status)) {
#if defined(LEAK_TRACK)

        if (g_RegLeakTraceInfo.bEnableLeakTrack) {
            (void) TrackObject(*phkResult);
        }
        
#endif defined(LEAK_TRACK)

        // mark this key as a class key
        TagSpecialClassesHandle(phkResult);
    }

    return RtlNtStatusToDosError(Status);
}

BOOL InitializeClassesRoot() 
{
    if (!InitializeClassesEnumTable()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CleanupClassesRoot(BOOL fOnlyThisThread) 
{
    //
    // Always remove enumeration states for this thread
    //
    return CleanupClassesEnumTable( fOnlyThisThread );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regdkey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regdkey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to delete a key.  That is:

        - RegDeleteKeyA
        - RegDeleteKeyW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regdkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"


LONG
APIENTRY
RegDeleteKeyA (
    HKEY hKey,
    LPCSTR lpKeyName
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for deleting a Key.

    RegDeleteKeyA converts the lpKeyName argument to a counted Unicode string
    and then calls BaseRegDeleteKey.

--*/

{
    UNICODE_STRING      KeyName;
    NTSTATUS            Status;
    HKEY                TempHandle = NULL;
    LONG                Result;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( lpKeyName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle);
    if( hKey == NULL ) {
        Result = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the Key name to a counted Unicode string 
    //

    if( !RtlCreateUnicodeStringFromAsciiz(&KeyName,lpKeyName) ) {
        Status = STATUS_NO_MEMORY;
        Result = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //
    KeyName.Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Result = (LONG)LocalBaseRegDeleteKey (
                    hKey,
                    &KeyName
                    );

    } else {

        Result = (LONG)BaseRegDeleteKey (
                    DereferenceRemoteHandle( hKey ),
                    &KeyName
                    );
    }
    RtlFreeUnicodeString( &KeyName );

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Result;
}

LONG
APIENTRY
RegDeleteKeyW (
    HKEY hKey,
    LPCWSTR lpKeyName
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for deleting a Key.

    RegDeleteKeyW converts the lpKeyName argument to a counted Unicode string
    and then calls BaseRegDeleteKey.

--*/

{
    UNICODE_STRING      KeyName;
    HKEY                TempHandle = NULL;
    LONG                Result;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( lpKeyName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    // ASSERT( hKey != NULL );
    if( hKey == NULL ) {
        Result = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the Key name to a counted Unicode string.
    //

    RtlInitUnicodeString( &KeyName, lpKeyName );

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //

    KeyName.Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Result = (LONG)LocalBaseRegDeleteKey (
                    hKey,
                    &KeyName
                    );
    } else {

        Result = (LONG)BaseRegDeleteKey (
                    DereferenceRemoteHandle( hKey ),
                    &KeyName
                    );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regdval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regdval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to delete values from a key.  That is:

        - RegDeleteValueA
        - RegDeleteValueW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regdval.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#if defined(_WIN64)
#include <wow64reg.h>
#endif

LONG
APIENTRY
RegDeleteValueA (
    HKEY hKey,
    LPCSTR lpValueName
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for deleting a value.

    RegDeleteValueA converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegDeleteValue.

--*/

{
    UNICODE_STRING      ValueName;
    NTSTATUS            Status;
    HKEY                TempHandle = NULL;
    LONG                Result;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Result = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&ValueName,lpValueName) ) {
        Status = STATUS_NO_MEMORY;
        Result = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //

    ValueName.Length += sizeof( UNICODE_NULL );

    if( ValueName.Length == 0 ) {
        //
        // overflow in RtlInitUnicodeString
        //
        Result = ERROR_INVALID_PARAMETER;
        goto ExitCleanup;
    }

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Result = (LONG)LocalBaseRegDeleteValue (
                    hKey,
                    &ValueName
                    );
#if defined(_WIN64)

        if ( Result == 0) //only set dirty if operation succeed
                    Wow64RegSetKeyDirty (hKey);
#endif
    } else {

        Result = (LONG)BaseRegDeleteValue (
                    DereferenceRemoteHandle( hKey ),
                    &ValueName
                    );
    }
    RtlFreeUnicodeString( &ValueName );

ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Result;
}

LONG
APIENTRY
RegDeleteValueW (
    HKEY hKey,
    LPCWSTR lpValueName
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for deleting a value.

    RegDeleteValueW converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegDeleteValue.

--*/

{
    UNICODE_STRING      ValueName;
    HKEY                TempHandle = NULL;
    LONG                Result;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Result = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //

    ValueName.Length += sizeof( UNICODE_NULL );
    if( ValueName.Length == 0 ) {
        //
        // overflow in RtlInitUnicodeString
        //
        Result = ERROR_INVALID_PARAMETER;
        goto ExitCleanup;
    }

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Result = (LONG)LocalBaseRegDeleteValue (
                    hKey,
                    &ValueName
                    );
#if defined(_WIN64)

        if ( Result == 0) //only set dirty if operation succeed
                    Wow64RegSetKeyDirty (hKey);
#endif
    } else {

        Result = (LONG)BaseRegDeleteValue (
                    DereferenceRemoteHandle( hKey ),
                    &ValueName
                    );
    }
ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\predefh.c ===
/*++


Copyright (c) 1992 Microsoft Corporation

Module Name:

    Predefh.c

Abstract:

    This module contains the client side support for managing the Win32
    Registry API's predefined handles. This support is supplied via a
    table, which maps (a) predefined handles to real handles and (b)
    the server side routine which opens the handle.

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    See the notes in server\predefh.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"

#if defined(LEAK_TRACK)
NTSTATUS TrackObject(HKEY hKey);
#endif // LEAK_TRACK

RTL_CRITICAL_SECTION    PredefinedHandleTableCriticalSection;


//
// For each predefined handle an entry is maintained in an array. Each of
// these structures contains a real (context) handle and a pointer to a
// function that knows how to map the predefined handle to the Registry name
// space.
//

//
// Pointer to function to open predefined handles.
//

typedef
error_status_t
( *OPEN_FUNCTION ) (
     PREGISTRY_SERVER_NAME,
     REGSAM,
     PRPC_HKEY
     );


//
// Table entry for a predefined handle.
//

typedef struct _PRDEFINED_HANDLE {

    RPC_HKEY        Handle;
    OPEN_FUNCTION   OpenFunc;
    BOOLEAN         Disabled;   // tells whether the handle should be cached or not.

#if DBG
    ULONG                   Callers;
    PVOID                   CallerAddress[10];
#endif 

} PREDEFINED_HANDLE, *PPREDEFINED_HANDLE;

//
// Initialize predefined handle table.
//
PREDEFINED_HANDLE PredefinedHandleTable[ ] = {

    NULL, LocalOpenClassesRoot,         FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenCurrentUser,         FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenLocalMachine,        FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenUsers,               FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenPerformanceData,     FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenPerformanceText,     FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenPerformanceNlsText,  FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenCurrentConfig,       FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenDynData,             FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif

};

#define MAX_PREDEFINED_HANDLES                                              \
    ( sizeof( PredefinedHandleTable ) / sizeof( PREDEFINED_HANDLE ))

//
// Predefined HKEY values are defined in Winreg.x. They MUST be kept in
// synch with the following constants and macros.
//

//
// Mark Registry handles so that we can recognize predefined handles.
//

#define PREDEFINED_REGISTRY_HANDLE_SIGNATURE    ( 0x80000000 )

NTSTATUS
SetHandleProtection(
    IN      HANDLE                  Handle,
    IN      LONG                    Index,
    IN      BOOLEAN                 Protect
)
/*++

Routine Description:

    Changes the handle ProtectFromClose attribute. To be used for predefined handles, 
    to prevent abnormal closure.

Arguments:

    Handle - Supplies the handle who's protection to be changed.

    Index  - Index in the predefined handle table

Return Value:

    Status of the NtSetInformationObject call

--*/
{
    NTSTATUS                        Status;
    OBJECT_HANDLE_FLAG_INFORMATION  Ohfi = {    FALSE,
                                                FALSE
                                            };
    ULONG                           PredefHandle;

    PredefHandle = ((ULONG)Index) | PREDEFINED_REGISTRY_HANDLE_SIGNATURE;

    switch (PredefHandle) {
        case (ULONG)((ULONG_PTR)HKEY_CLASSES_ROOT):
        case (ULONG)((ULONG_PTR)HKEY_CURRENT_USER):
        case (ULONG)((ULONG_PTR)HKEY_LOCAL_MACHINE):
        case (ULONG)((ULONG_PTR)HKEY_USERS):
            //
            // go change the protection
            //
            break;
        default:
            //
            // The supplied handle might not be a real handle
            //
            return STATUS_INVALID_HANDLE;
    }


    Ohfi.ProtectFromClose = Protect;

    Status = NtSetInformationObject(Handle,
                                    ObjectHandleFlagInformation,
                                    &Ohfi,
                                    sizeof (OBJECT_HANDLE_FLAG_INFORMATION));

#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "WINREG: SetHandleProtection (%u) on %lx failed. Status = %lx \n",Protect, Handle, Status );
    }
#endif

    return Status;
}

LONG
MapPredefinedRegistryHandleToIndex(
    IN ULONG Handle
    )

/*++

Routine Description:

    Maps a predefined handle to an index into the predefined handle table.

Arguments:

    Handle - Supplies the handle to be mapped.

Return Value:

    An index into the predefined handle table
    -1 if the handle is not a predefined handle

--*/
{
    LONG Index;

    switch (Handle) {
        case (ULONG)((ULONG_PTR)HKEY_CLASSES_ROOT):
        case (ULONG)((ULONG_PTR)HKEY_CURRENT_USER):
        case (ULONG)((ULONG_PTR)HKEY_LOCAL_MACHINE):
        case (ULONG)((ULONG_PTR)HKEY_USERS):
        case (ULONG)((ULONG_PTR)HKEY_PERFORMANCE_DATA):
            Index = (Handle & ~PREDEFINED_REGISTRY_HANDLE_SIGNATURE);
            break;
        case (ULONG)((ULONG_PTR)HKEY_PERFORMANCE_TEXT):
            Index = 5;
            break;
        case (ULONG)((ULONG_PTR)HKEY_PERFORMANCE_NLSTEXT):
            Index = 6;
            break;
        case (ULONG)((ULONG_PTR)HKEY_CURRENT_CONFIG):
            Index = 7;
            break;
        case (ULONG)((ULONG_PTR)HKEY_DYN_DATA):
            Index = 8;
            break;
        default:
            //
            // The supplied handle is not predefined, so return it.
            //
            Index = -1;
            break;
    }
    return(Index);
}



NTSTATUS
RemapPredefinedHandle(
    IN RPC_HKEY     Handle,
    IN RPC_HKEY     NewHandle

    )

/*++

Routine Description:

    Override the current predefined handle.  If it is already open, close it,
	then set the new handle

Arguments:

    Handle  - Supplies a handle which must be a predefined handle
	NewHandle	- an already open registry key to override the special key

Return Value:

    ERROR_SUCCESS - no problems

--*/

{
    LONG        Index;
    LONG        Error;
    NTSTATUS    Status;
    HANDLE      hCurrentProcess;
    HKEY        hkTableHandle = NULL;

    //
    // If the high bit is not set, we know it's not a predefined handle
    // so take a quick out.
    //
    if (((ULONG_PTR)Handle & 0x80000000) == 0) {
        return(STATUS_INVALID_HANDLE);
    }

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() on RemapPredefinedHandle() failed. Status = %lx \n", Status );
#endif
        Status = ERROR_INVALID_HANDLE;
	goto cleanup_and_exit;
    }

    Index = MapPredefinedRegistryHandleToIndex((ULONG)(ULONG_PTR)Handle);

    if (Index == -1) {
	Status = STATUS_INVALID_HANDLE;
        goto leave_crit_sect;
    }

    ASSERT(( 0 <= Index ) && ( Index < MAX_PREDEFINED_HANDLES ));

    if( PredefinedHandleTable[ Index ].Disabled == TRUE ) {
        //
        // predefined table is disabled for this key
        //

        // nobody is allowed to write here
        ASSERT( PredefinedHandleTable[ Index ].Handle == NULL );

        // refuse the request
        Status = STATUS_INVALID_HANDLE;
        goto leave_crit_sect;
    }

    hCurrentProcess = NtCurrentProcess();

    //
    // see if we can duplicate this handle so we can place it
    // in the table
    //
    if (NewHandle && !NT_SUCCESS(Status = NtDuplicateObject (hCurrentProcess,
			       NewHandle,
			       hCurrentProcess,
			       &hkTableHandle,
                               0,
			       FALSE,
			       DUPLICATE_SAME_ACCESS))) {
	goto leave_crit_sect;
    }

    if (NewHandle && IsSpecialClassesHandle(NewHandle)) {
        TagSpecialClassesHandle( &hkTableHandle );
    }

    //
    // If the predefined handle has already been opened try
    // and close the key now.
    //
    if( PredefinedHandleTable[ Index ].Handle != NULL ) {

        // make sure the handle CAN be closed.
        SetHandleProtection(PredefinedHandleTable[ Index ].Handle,Index,FALSE);
	    
#if DBG
        PredefinedHandleTable[ Index ].Callers = RtlWalkFrameChain(&(PredefinedHandleTable[ Index ].CallerAddress[0]), 10, 0);      
#endif

        Error = (LONG) RegCloseKey( PredefinedHandleTable[ Index ].Handle );

#if DBG
        if ( Error != ERROR_SUCCESS ) {

            DbgPrint( "Winreg.dll: Cannot close predefined handle\n" );
            DbgPrint( "            Handle: 0x%x  Index: %d  Error: %d\n",
                      Handle, Index, Error );
        }

#endif

    }

    PredefinedHandleTable[ Index ].Handle = hkTableHandle;

    // make sure the handle CANNOT be closed.
    SetHandleProtection(PredefinedHandleTable[ Index ].Handle,Index,TRUE);

leave_crit_sect:

#if DBG
    {
    NTSTATUS Status =
#endif DBG
	RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
        ASSERT( NT_SUCCESS( Status ) );
#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() on RemapPredefinedHandle() failed. Status = %lx \n", Status );
	}
    }
#endif

cleanup_and_exit:

    if (!NT_SUCCESS(Status) && hkTableHandle)
    {
	RegCloseKey(hkTableHandle);
    }

    return( Status );
}


RPC_HKEY
MapPredefinedHandle(
    IN  RPC_HKEY    Handle,
    OUT PRPC_HKEY    HandleToClose
    )

/*++

Routine Description:

    Attempt to map a predefined handle to a RPC context handle. This in
    turn will map to a real Nt Registry handle.

Arguments:

    Handle  - Supplies a handle which may be a predefined handle or a handle
              returned from a previous call to any flavour of RegCreateKey,
              RegOpenKey or RegConnectRegistry.

    HandleToClose - When not NULL, this is the same as the result.
                    Used to implement the DisablePredefinedCache feature.

Return Value:

    RPC_HKEY- Returns the supplied handle argument if it not predefined,
              a RPC context handle if possible (i.e. it was previously
              opened or can be opened now), NULL otherwise.

--*/

{
    LONG        Index;
    LONG        Error;
    NTSTATUS    Status;
    HANDLE      ResultHandle;

    *HandleToClose = NULL;

    // reject outrageous calls
    if( Handle ==  INVALID_HANDLE_VALUE ) {
        return( NULL );
    }

    //
    // If the high bit is not set, we know it's not a predefined handle
    // so take a quick out.
    //
    if (((ULONG_PTR)Handle & 0x80000000) == 0) {
        return(Handle);
    }
    Index = MapPredefinedRegistryHandleToIndex((ULONG)(ULONG_PTR)Handle);
    if (Index == -1) {
        return(Handle);
    }

    ASSERT(( 0 <= Index ) && ( Index < MAX_PREDEFINED_HANDLES ));

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() on MapPredefinedHandle() failed. Status = %lx \n", Status );
#endif
        return( NULL );
    }

    if( PredefinedHandleTable[ Index ].Disabled == TRUE ) {
        //
        // for this handle the predefined feature has been disabled
        //

        // nobody is allowed to write here
        ASSERT( PredefinedHandleTable[ Index ].Handle == NULL );

        //
        // open a new handle for this request and store it in "toClose"
        // argument so the caller knows that should close it
        //
        ( *PredefinedHandleTable[ Index ].OpenFunc )(
                        NULL,
                        MAXIMUM_ALLOWED,
                        HandleToClose
                        );


        // return the new handle to the caller
        ResultHandle = *HandleToClose;
    } else {
        //
        // If the predefined handle has not already been openend try
        // and open the key now.
        //
        if( PredefinedHandleTable[ Index ].Handle == NULL ) {

            Error = (LONG)( *PredefinedHandleTable[ Index ].OpenFunc )(
                            NULL,
                            MAXIMUM_ALLOWED,
                            &PredefinedHandleTable[ Index ].Handle
                            );

            if( Error == ERROR_SUCCESS ) {
                // make sure the handle CANNOT be closed.
                SetHandleProtection(PredefinedHandleTable[ Index ].Handle,Index,TRUE);
            }

#if defined(LEAK_TRACK)

            if (g_RegLeakTraceInfo.bEnableLeakTrack) {
                (void) TrackObject(PredefinedHandleTable[ Index ].Handle);
            }
            
#endif // defined(LEAK_TRACK)

#if DBG
            if ( Error != ERROR_SUCCESS ) {

                DbgPrint( "Winreg.dll: Cannot map predefined handle\n" );
                DbgPrint( "            Handle: 0x%x  Index: %d  Error: %d\n",
                          Handle, Index, Error );
            } else {
                ASSERT( IsLocalHandle( PredefinedHandleTable[ Index ].Handle ));
            }

#endif
        }
        //
        // Map the predefined handle to a real handle (may be NULL
        // if key could not be opened).
        //
        ResultHandle = PredefinedHandleTable[ Index ].Handle;

        ASSERT(*HandleToClose == NULL);

    }


    Status = RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() on MapPredefinedHandle() failed. Status = %lx \n", Status );
    }
#endif
    return( ResultHandle );
}


BOOL
CleanupPredefinedHandles(
    VOID
    )

/*++

Routine Description:

    Runs down the list of predefined handles and closes any that have been opened.

Arguments:

    None.

Return Value:

    TRUE - success

    FALSE - failure

--*/

{
    LONG        i;
    NTSTATUS    Status;

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlEnterCriticalSection() on CleanupPredefinedHandles() failed. Status = %lx \n", Status );
    }
#endif
    for (i=0;i<sizeof(PredefinedHandleTable)/sizeof(PREDEFINED_HANDLE);i++) {
        //
        // consistency check
        //
        if( PredefinedHandleTable[ i ].Disabled == TRUE ) {
            //
            // predefined table is disabled for this key
            //

            // nobody is allowed to write here
            ASSERT( PredefinedHandleTable[ i ].Handle == NULL );
        } else if (PredefinedHandleTable[i].Handle != NULL) {
            // make sure the handle CAN be closed.
            SetHandleProtection(PredefinedHandleTable[ i ].Handle,i,FALSE);
#if DBG
            PredefinedHandleTable[ i ].Callers = RtlWalkFrameChain(&(PredefinedHandleTable[ i ].CallerAddress[0]), 10, 0);      
#endif
            LocalBaseRegCloseKey(&PredefinedHandleTable[i].Handle);
            PredefinedHandleTable[i].Handle = NULL;
        }
    }
    Status = RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() on CleanupPredefinedHandles() failed. Status = %lx \n", Status );
    }
#endif
    return(TRUE);
}


LONG
ClosePredefinedHandle(
    IN RPC_HKEY     Handle
    )

/*++

Routine Description:

    Zero out the predefined handles entry in the predefined handle table
    so that subsequent opens will call the server.

Arguments:

    Handle - Supplies a predefined handle.

Return Value:

    None.

--*/

{
    NTSTATUS    Status;
    HKEY        hKey1;
    LONG        Error;
    LONG        Index;

    ASSERT( IsPredefinedRegistryHandle( Handle ));

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlEnterCriticalSection() on ClosePredefinedHandle() failed. Status = %lx \n", Status );
    }
#endif

    Index = MapPredefinedRegistryHandleToIndex( (ULONG)(ULONG_PTR)Handle );
    ASSERT( Index != -1 );

    hKey1 = PredefinedHandleTable[ Index ].Handle;
    if( hKey1 == NULL ) {
        //
        //  If the handle was already closed, then return ERROR_SUCCESS.
        //  This is because an application may already have called RegCloseKey
        //  on a predefined key, and is now callig RegOpenKey on the same
        //  predefined key. RegOpenKeyEx will try to close the predefined handle
        //  and open a new one, in order to re-impersonate the client. If we don't
        //  return ERROR_SUCCESS, then RegOpenKeyEx will not open a new predefined
        //  handle, and the API will fail.
        //
        Error = ERROR_SUCCESS;
    } else {

        // if there is a handle here, the predefined handle is not disabled.
        ASSERT(PredefinedHandleTable[ Index ].Disabled == FALSE);

        PredefinedHandleTable[ Index ].Handle = NULL;
#if DBG
        PredefinedHandleTable[ Index ].Callers = RtlWalkFrameChain(&(PredefinedHandleTable[ Index ].CallerAddress[0]), 10, 0);      
#endif
    }

    Status = RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() on ClosePredefinedHandle() failed. Status = %lx \n", Status );
    }
#endif

    if( hKey1 != NULL ) {
        //
        // close the key now (after leaving critical region to prevent deadlock
        // with dumb heads calling reg apis from DllInit.
        //

        // make sure the handle CAN be closed.
        SetHandleProtection(hKey1,Index,FALSE);

        Error =  ( LONG ) LocalBaseRegCloseKey( &hKey1 );
    }
    return( Error );
}



LONG
OpenPredefinedKeyForSpecialAccess(
    IN  RPC_HKEY     Handle,
    IN  REGSAM       AccessMask,
    OUT PRPC_HKEY    pKey
    )

/*++

Routine Description:

    Attempt to open a predefined key with SYSTEM_SECURITY_ACCESS.
    Such an access is not included on MAXIMUM_ALLOWED, and is  needed
    by RegGetKeySecurity and RegSetKeySecurity, in order to retrieve
    and save the SACL of a predefined key.

    WHEN USING A HANDLE WITH SPECIAL ACCESS, IT IS IMPORTANT TO FOLLOW
    THE RULES BELOW:

        - HANDLES OPENED FOR SPECIAL ACCESS ARE NEVER SAVED ON THE
          PredefinedHandleTable.

        - SUCH HANDLES SHOULD BE USED ONLY INTERNALY TO THE CLIENT
          SIDE OF WINREG APIs.
          THEY SHOULD NEVER BE RETURNED TO THE OUTSIDE WORLD.

        - IT IS THE RESPONSIBILITY OF THE CALLER OF THIS FUNCTION TO CLOSE
          THE HANDLES OPENED BY THIS FUNCTION.
          RegCloseKey() SHOULD BE USED TO CLOSE SUCH HANDLES.


    This function should be called only by the following APIs:

      RegGetKeySecurity -> So that it can retrieve the SACL of a predefined key
      RegSetKeySecurity -> So that it can save the SACL of a predefined key
      RegOpenKeyEx -> So that it can determine wheteher or not the caller of
                      RegOpenKeyEx is able to save and restore SACL of
                      predefined keys.


Arguments:

    Handle  - Supplies one of the predefined handle of the local machine.

    AccessMask - Suplies an access mask that contains the special access
                 desired (the ones not included in MAXIMUM_ALLOWED).
                 On NT 1.0, ACCESS_SYSTEM_SECURITY is the only one of such
                 access.

    pKey - Pointer to the variable that will contain the handle opened with
           the special access.


Return Value:


    LONG - Returns a DosErrorCode (ERROR_SUCCESS if the operation succeeds).

--*/

{
    LONG    Index;
    LONG    Error;


    ASSERT( pKey );
    ASSERT( AccessMask & ACCESS_SYSTEM_SECURITY );
    ASSERT( IsPredefinedRegistryHandle( Handle ) );

    //
    // Check if the Handle is a predefined handle.
    //

    if( IsPredefinedRegistryHandle( Handle )) {

        if( ( ( AccessMask & ACCESS_SYSTEM_SECURITY ) == 0 ) ||
            ( pKey == NULL ) ) {
            return( ERROR_INVALID_PARAMETER );
        }

        //
        // Convert the handle to an index.
        //

        Index = MapPredefinedRegistryHandleToIndex( (ULONG)(ULONG_PTR)Handle );
        ASSERT(( 0 <= Index ) && ( Index < MAX_PREDEFINED_HANDLES ));

        //
        // If the predefined handle has not already been openend try
        // and open the key now.
        //


        Error = (LONG)( *PredefinedHandleTable[ Index ].OpenFunc )(
                        NULL,
                        AccessMask,
                        pKey
                        );

/*
#if DBG
        if ( Error != ERROR_SUCCESS ) {

            DbgPrint( "Winreg.dll: Cannot map predefined handle\n" );
            DbgPrint( "            Handle: 0x%x  Index: %d  Error: %d\n",
                          Handle, Index, Error );
        } else {
            ASSERT( IsLocalHandle( PredefinedHandleTable[ Index ].Handle ));
        }

#endif
*/

        return Error;
    } else {
        return( ERROR_BADKEY );
    }

}
// #endif


BOOL
InitializePredefinedHandlesTable(
    )

/*++

Routine Description:

    Initialize the critical section used by the functions that access
    PredefinedHandleTable.
    This critical section is needed to avoid that a thread closes a predefined
    key, while other threads are accessing the predefined key

Arguments:

    None.

Return Value:

    Returns TRUE if the initialization succeeds.

--*/

{
    NTSTATUS    NtStatus;


    NtStatus = RtlInitializeCriticalSection(
                    &PredefinedHandleTableCriticalSection
                    );
    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus ) ) {
        return FALSE;
    }
    return( TRUE );

}


BOOL
CleanupPredefinedHandlesTable(
    )

/*++

Routine Description:

    Delete the critical section used by the functions that access the
    PredefinedHandleTable.


Arguments:

    None.

Return Value:

    Returns TRUE if the cleanup succeeds.

--*/

{
    NTSTATUS    NtStatus;


    //
    //  Delete the critical section
    //
    NtStatus = RtlDeleteCriticalSection(
                    &PredefinedHandleTableCriticalSection
                    );

    ASSERT( NT_SUCCESS( NtStatus ) );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return FALSE;
    }
    return( TRUE );
}

NTSTATUS
DisablePredefinedHandleTable(
                   HKEY    Handle
                             )

/*++

Routine Description:

    Disables the predefined handle table for the current user
    key. Eventually closes the handle in predefined handle, if already open

Arguments:

    Handle - predefined handle for which to disable (now only current user)

Return Value:


--*/

{
    NTSTATUS    Status;
    LONG        Index;

    if( Handle != HKEY_CURRENT_USER ) {
        //
        // feature enabled only for current user at this time
        //
        return STATUS_INVALID_HANDLE;
    }

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );

#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlEnterCriticalSection() on DisablePredefinedHandleTable() failed. Status = %lx \n", Status );
    }
#endif

    Index = MapPredefinedRegistryHandleToIndex( (ULONG)(ULONG_PTR)Handle );
    ASSERT( Index != -1 );

    if(PredefinedHandleTable[ Index ].Disabled == TRUE) {
        // already called
        ASSERT( PredefinedHandleTable[ Index ].Handle == NULL );
    } else {
        if( PredefinedHandleTable[ Index ].Handle != NULL ) {

            // make sure the handle CAN be closed.
            SetHandleProtection(PredefinedHandleTable[ Index ].Handle,Index,FALSE);

#if DBG
            PredefinedHandleTable[ Index ].Callers = RtlWalkFrameChain(&(PredefinedHandleTable[ Index ].CallerAddress[0]), 10, 0);      
#endif
            LocalBaseRegCloseKey( &(PredefinedHandleTable[ Index ].Handle) );
        }
        PredefinedHandleTable[ Index ].Handle = NULL;
        PredefinedHandleTable[ Index ].Disabled = TRUE;
    }

    Status = RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );

#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() on ClosePredefinedHandle() failed. Status = %lx \n", Status );
    }
#endif
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regcnreg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regcnreg.c

Abstract:

    This module contains the Win32 Registry APIs to connect to a remote
    Registry.  That is:

       - RegConnectRegistryA
       - RegConnectRegistryW
Author:

    David J. Gilman (davegi) 25-Mar-1992

Notes:

    The semantics of this API make it local only. That is there is no MIDL
    definition for RegConnectRegistry although it does call other client
    stubs, specifically OpenLocalMachine and OpenUsers.

Revision History:

    John Vert (jvert) 16-Jun-1995
       Added connect support for protocols other than named pipes by
       stealing code from Win95. This enabled NT machines to connect
       to registries on Win95 machines

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include "shutinit.h"
#include "..\regconn\regconn.h"

LONG
BaseBindToMachine(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    );


typedef int (* RegConnFunction)(LPCWSTR, handle_t *);

RegConnFunction conn_functions[] = {
        RegConn_np,
        RegConn_spx,
        RegConn_ip_tcp,
        RegConn_nb_nb,
        RegConn_nb_tcp,
        RegConn_nb_ipx,
        NULL
};

LONG
Rpc_OpenPredefHandle(
    IN RPC_BINDING_HANDLE * pbinding OPTIONAL,
    IN HKEY hKey,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Win32 Unicode API for establishing a connection to a predefined
    handle on another machine.

Parameters:

    pbinding - This is a pointer to the binding handle in order
                to allow access to multiple protocols (NT remote registry is only over
                named pipes).

    hKey - Supplies the predefined handle to connect to on the remote
        machine. Currently this parameter must be one of:

        - HKEY_LOCAL_MACHINE
        - HKEY_PERFORMANCE_DATA
        - HKEY_USERS

    phkResult - Returns a handle which represents the supplied predefined
        handle on the supplied machine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.
        On failure, the binding handle is freed.

Notes:

    For administration purposes this API allows programs to access the
    Registry on a remote machine.  In the current system the calling
    application must know the name of the remote machine that it wishes to
    connect to.  However, it is expected that in the future a directory
    service API will return the parameters necessary for this API.

--*/

{
    LONG    Error;
    HKEY    PreviousResult;

    ASSERT( (phkResult != NULL));
    PreviousResult = *phkResult;

    switch ((int)(ULONG_PTR)hKey)
    {
        case (int)(ULONG_PTR)HKEY_LOCAL_MACHINE:

            Error = (LONG)OpenLocalMachine((PREGISTRY_SERVER_NAME) pbinding,
                                           MAXIMUM_ALLOWED,
                                           phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_DATA:

            Error = (LONG)OpenPerformanceData((PREGISTRY_SERVER_NAME) pbinding,
                                              MAXIMUM_ALLOWED,
                                              phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_USERS:

            Error = (LONG)OpenUsers((PREGISTRY_SERVER_NAME) pbinding,
                                    MAXIMUM_ALLOWED,
                                    phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_CLASSES_ROOT:

            Error = (LONG)OpenClassesRoot((PREGISTRY_SERVER_NAME) pbinding,
                                          MAXIMUM_ALLOWED,
                                          phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_CURRENT_USER:

            Error = (LONG)OpenCurrentUser((PREGISTRY_SERVER_NAME) pbinding,
                                          MAXIMUM_ALLOWED,
                                          phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_TEXT:

            Error = (LONG)OpenPerformanceText((PREGISTRY_SERVER_NAME) pbinding,
                                              MAXIMUM_ALLOWED,
                                              phkResult );

            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_NLSTEXT:

            Error = (LONG)OpenPerformanceNlsText((PREGISTRY_SERVER_NAME) pbinding,
                                              MAXIMUM_ALLOWED,
                                              phkResult );

            break;

        default:
            Error = ERROR_INVALID_HANDLE;
    }

    if( Error != ERROR_SUCCESS) {
        ASSERTMSG("WINREG: RPC failed, but modifed phkResult", *phkResult == PreviousResult);
        if (*pbinding != NULL)
            RpcBindingFree(pbinding);
    }

    return Error;
}

LONG
LocalOpenPredefHandle(
    IN HKEY hKey,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Opens a predefined handle locally. The purpose of this is to bypass RPC in the 
    case of connecting to the local machine.

Parameters:

    hKey - Supplies the predefined handle to connect to on the remote
        machine. Currently this parameter must be one of:

        - HKEY_LOCAL_MACHINE
        - HKEY_PERFORMANCE_DATA
        - HKEY_USERS

    phkResult - Returns a handle which represents the supplied predefined
        handle on the supplied machine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    LONG    Error;

    ASSERT( (phkResult != NULL));

    switch ((int)(ULONG_PTR)hKey)
    {
        case (int)(ULONG_PTR)HKEY_LOCAL_MACHINE:

            Error = (LONG)LocalOpenLocalMachine(NULL,
                                           MAXIMUM_ALLOWED,
                                           phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_DATA:

            Error = (LONG)LocalOpenPerformanceData(NULL,
                                              MAXIMUM_ALLOWED,
                                              phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_USERS:

            Error = (LONG)LocalOpenUsers(NULL,
                                    MAXIMUM_ALLOWED,
                                    phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_CLASSES_ROOT:

            Error = (LONG)LocalOpenClassesRoot(NULL,
                                          MAXIMUM_ALLOWED,
                                          phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_CURRENT_USER:

            Error = (LONG)LocalOpenCurrentUser(NULL,
                                          MAXIMUM_ALLOWED,
                                          phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_TEXT:
        case (int)(ULONG_PTR)HKEY_PERFORMANCE_NLSTEXT:
        case (int)(ULONG_PTR)HKEY_CURRENT_CONFIG:
        case (int)(ULONG_PTR)HKEY_DYN_DATA:
            //
            // try not to break whoever used this
            //
            *phkResult = hKey;
            Error = ERROR_SUCCESS;
            break;

        default:
            Error = ERROR_INVALID_HANDLE;
    }

    return Error;
}

LONG
RegConnectRegistryW (
    IN LPCWSTR lpMachineName OPTIONAL,
    IN HKEY hKey,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Win32 Unicode API for establishing a connection to a predefined
    handle on another machine.

Parameters:

    lpMachineName - Supplies a pointer to a null-terminated string that
    names the machine of interest.  If this parameter is NULL, the local
    machine name is used.

    hKey - Supplies the predefined handle to connect to on the remote
    machine. Currently this parameter must be one of:

    - HKEY_LOCAL_MACHINE
    - HKEY_PERFORMANCE_DATA
    - HKEY_USERS

    phkResult - Returns a handle which represents the supplied predefined
    handle on the supplied machine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    For administration purposes this API allows programs to access the
    Registry on a remote machine.  In the current system the calling
    application must know the name of the remote machine that it wishes to
    connect to.  However, it is expected that in the future a directory
    service API will return the parameters necessary for this API.

    Even though HKEY_CLASSES and HKEY_CURRENT_USER are predefined handles,
    they are not supported by this API as they do not make sense in the
    context of a remote Registry.

--*/

{
    LONG    Error;
    WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   bufLen = MAX_COMPUTERNAME_LENGTH + 1;

    ASSERT( ARGUMENT_PRESENT( phkResult ));

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif
    //
    // Check for local connect
    //

    if (lpMachineName == NULL) {
        //
        // always return a valid handle
        //
        Error = LocalOpenPredefHandle(hKey,phkResult);
        return Error;
    } else if (lpMachineName[0] == L'\0') {
        //
        // always return a valid handle
        //
        Error = LocalOpenPredefHandle(hKey,phkResult);
        return Error;
    }

    if (GetComputerNameW(ComputerName,&bufLen)) {

        if ((_wcsicmp(ComputerName,lpMachineName) == 0) ||
                ((lpMachineName[0] == '\\') &&
                 (lpMachineName[1] == '\\') &&
                 (_wcsicmp(ComputerName,&(lpMachineName[2]))==0))) {
            //
            // local connect
            //
            //
            // always return a valid handle
            //
            Error = LocalOpenPredefHandle(hKey,phkResult);
            return Error;
        } 
    } 

    Error = BaseBindToMachine(lpMachineName,
                              Rpc_OpenPredefHandle,
                              (PVOID)hKey,
                              (PVOID)phkResult);

    if( Error == ERROR_SUCCESS) {
        TagRemoteHandle( phkResult );
    }
    return Error;
}

LONG
BaseBindToMachine(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    )

/*++

Routine Description:

    This is a helper routine used to create an RPC binding from
    a given machine name.

Arguments:

    lpMachineName - Supplies a pointer to a machine name. Must not
                    be NULL.

    BindCallback - Supplies the function that should be called once
                   a binding has been created to initiate the connection.

    Context1 - Supplies the first parameter to pass to the callback routine.

    Context2 - Supplies the second parameter to pass to the callback routine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    LONG    Error;
    int         i;
    RegConnFunction conn_fn;
    RPC_BINDING_HANDLE binding;

    conn_fn = conn_functions[0];
    i = 1;

    //
    // Iterate through the protocols until we find one that
    // can connect.
    //
    do {
        Error = conn_fn(lpMachineName,&binding);

        if (Error == ERROR_SUCCESS) {

            //
            // For the named pipes protocol, we use a static endpoint, so the
            // call to RpcEpResolveBinding is not needed.
            // Also, the server checks the user's credentials on opening
            // the named pipe, so RpcBindingSetAuthInfo is not needed.
            //
            if (conn_fn != RegConn_np) {
                Error = (LONG)RpcEpResolveBinding(binding,winreg_ClientIfHandle);

                if (Error == ERROR_SUCCESS) {
                    Error = (LONG)RpcBindingSetAuthInfo(binding,
                                            "",     // ServerPrincName
                                            RPC_C_AUTHN_LEVEL_CONNECT,
                                            RPC_C_AUTHN_WINNT,
                                            NULL,   // AuthIdentity
                                            RPC_C_AUTHZ_NONE);
                }
            }
            if (Error == ERROR_SUCCESS) {
                Error = (BindCallback)(&binding,
                                       Context1,
                                       Context2);
                RpcBindingFree(&binding);
                if (Error != RPC_S_SERVER_UNAVAILABLE) {
                    return Error;
                }
            } else {
                RpcBindingFree(&binding);
            }
        }

        //
        // Try the next protocol's connection function.
        //
        if (Error) {
            conn_fn = conn_functions[i];
            i++;
        }

    } while (!((Error == ERROR_SUCCESS) || (conn_fn == NULL)));

    if (Error != ERROR_SUCCESS) {
        if ((Error == RPC_S_INVALID_ENDPOINT_FORMAT) ||
            (Error == RPC_S_INVALID_NET_ADDR) ) {
            Error = ERROR_INVALID_COMPUTERNAME;
        } else {
            Error = ERROR_BAD_NETPATH;
        }
    }

    return(Error);
}

    
LONG
APIENTRY
RegConnectRegistryA (
    LPCSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win32 ANSI API for establishes a connection to a predefined handle on
    another machine.

    RegConnectRegistryA converts the lpMachineName argument to a Unicode
    string and then calls RegConnectRegistryW.

--*/

{
    UNICODE_STRING     MachineName;
    ANSI_STRING     AnsiString;
    NTSTATUS        Status;
    LONG        Error;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Convert the subkey to a counted Unicode string
    //

    RtlInitAnsiString( &AnsiString, lpMachineName );
    Status = RtlAnsiStringToUnicodeString(&MachineName,
                                          &AnsiString,
                                          TRUE);

    if( ! NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
    }

    Error = (LONG)RegConnectRegistryW(MachineName.Buffer,
                                      hKey,
                                      phkResult);
    RtlFreeUnicodeString(&MachineName);
    return Error;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regekey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regekey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    enumerate key APIs.  That is:

        - RegEnumKeyA
        - RegEnumKeyW
        - RegEnumKeyExA
        - RegEnumKeyExW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regekey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"

LONG
APIENTRY
RegEnumKeyA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    )

/*++

Routine Description:

    Win 3.1 ANSI RPC wrapper for enumerating keys.

--*/

{
#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    return RegEnumKeyExA (
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL
        );
}

LONG
APIENTRY
RegEnumKeyW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for enumerating keys.

--*/

{
#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    return RegEnumKeyExW (
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL
        );
}

LONG
APIENTRY
RegEnumKeyExA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Win32 ANSI API for enumerating keys.

--*/

{
    UNICODE_STRING      Name;
    UNICODE_STRING      Class;
    WCHAR               ClassBuffer[ MAX_PATH ];
    PUNICODE_STRING     ClassPointer;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error = ERROR_SUCCESS;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Validate dependency between lpClass and lpcbClass parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpClass ) && ( ! ARGUMENT_PRESENT( lpcbClass )))) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey,&TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Allocate temporary buffer for the Name
    //
    Name.Length        = 0;
    Name.MaximumLength = (USHORT)((*lpcbName + 1) * sizeof( WCHAR ));
    Name.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, Name.MaximumLength );
    if( Name.Buffer == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitCleanup;
    }

    //
    // If the class string is to be returned, initialize a UNICODE_STRING
    //

    ClassPointer           = &Class;
    ClassPointer->Length   = 0;

    if( ARGUMENT_PRESENT( lpClass )) {

        ClassPointer->MaximumLength = MAX_PATH;
        ClassPointer->Buffer        = ( PVOID ) ClassBuffer;

    } else {

        ClassPointer->MaximumLength = 0;
        ClassPointer->Buffer        = NULL;
    }




    //
    // Call the Base API passing it a pointer to the counted Unicode
    // strings for the name and class.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegEnumKey (
                            hKey,
                            dwIndex,
                            &Name,
                            ClassPointer,
                            lpftLastWriteTime
                            );
    } else {

        Error = (LONG)BaseRegEnumKey (
                            DereferenceRemoteHandle( hKey ),
                            dwIndex,
                            &Name,
                            ClassPointer,
                            lpftLastWriteTime
                            );
    }

    //
    // If the information was not succesfully queried return the error.
    //

    if( Error != ERROR_SUCCESS ) {
        // free allocated buffer
        RtlFreeHeap( RtlProcessHeap(), 0, Name.Buffer );
        goto ExitCleanup;
    }

    //
    //  Subtact the NULL from Length, which was added by the server
    //  so that RPC would transmit it.
    //

    Name.Length -= sizeof( UNICODE_NULL );

    if ( ClassPointer->Length > 0 ) {
        ClassPointer->Length -= sizeof( UNICODE_NULL );
    }

    //
    // Convert the name to ANSI.
    //
    // If somebody passed in a really big buffer, pretend it's
    // not quite so big so that it doesn't get truncated to zero.
    //
    if (*lpcbName > 0xFFFF) {
        AnsiString.MaximumLength    = ( USHORT ) 0xFFFF;
    } else {
        AnsiString.MaximumLength    = ( USHORT ) *lpcbName;
    }

    AnsiString.Buffer           = lpName;

    Status = RtlUnicodeStringToAnsiString(
                &AnsiString,
                &Name,
                FALSE
                );

    // free allocated buffer
    RtlFreeHeap( RtlProcessHeap(), 0, Name.Buffer );

    //
    // If the name conversion failed, map and return the error.
    //

    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    // Update the name length return parameter.
    //

    *lpcbName = AnsiString.Length;

    //
    // If requested, convert the class to ANSI.
    //

    if( ARGUMENT_PRESENT( lpClass )) {

        AnsiString.MaximumLength    = ( USHORT ) *lpcbClass;
        AnsiString.Buffer           = lpClass;

        Status = RtlUnicodeStringToAnsiString(
                    &AnsiString,
                    ClassPointer,
                    FALSE
                    );

        //
        // If the class conversion failed, map and return the error.
        //

        if( ! NT_SUCCESS( Status )) {
            Error = RtlNtStatusToDosError( Status );
            goto ExitCleanup;
        }

        //
        // If requested, return the class length parameter w/o the NUL.
        //

        if( ARGUMENT_PRESENT( lpcbClass )) {
            *lpcbClass = AnsiString.Length;
        }

    //
    // It is possible to ask for the size of the class w/o asking for the
    // class itself.
    //

    } else if( ARGUMENT_PRESENT( lpcbClass )) {
        *lpcbClass = ( ClassPointer->Length >> 1 );
    }


ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for enumerating keys.

--*/


{
    LONG                Error;
    UNICODE_STRING      Name;
    UNICODE_STRING      Class;
    PUNICODE_STRING     ClassPointer;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Validate dependency between lpClass and lpcbClass parameters.
    //
    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpClass ) && ( ! ARGUMENT_PRESENT( lpcbClass )))) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Use the supplied name string buffer as the buffer in a counted
    // Unicode string.
    //

    Name.Length           = 0;
    if ((*lpcbName << 1) > 0xFFFE) {
        Name.MaximumLength    = ( USHORT ) 0xFFFE;
    } else {
        Name.MaximumLength    = ( USHORT )( *lpcbName << 1 );
    }
    Name.Buffer           = lpName;

    //
    // If supplied use the supplied name string buffer as the buffer in a
    // counted Unicode string.
    //
    ClassPointer        = &Class;

    if( ARGUMENT_PRESENT( lpClass )) {

        Class.Length        = 0;
        Class.MaximumLength = ( USHORT )( *lpcbClass << 1 );
        Class.Buffer        = lpClass;

    } else {

        Class.Length        = 0;
        Class.MaximumLength = 0;
        Class.Buffer        = NULL;
    }

    //
    // Call the Base API passing it a pointer to the counted Unicode
    // strings for the name and class and return the results.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegEnumKey (
                            hKey,
                            dwIndex,
                            &Name,
                            ClassPointer,
                            lpftLastWriteTime
                            );
    } else {

        Error = (LONG)BaseRegEnumKey (
                            DereferenceRemoteHandle( hKey ),
                            dwIndex,
                            &Name,
                            ClassPointer,
                            lpftLastWriteTime
                            );
    }

    //
    //  Subtact the NULL from Length, which was added by the server
    //  so that RPC would transmit it.
    //

    if ( Name.Length > 0 ) {
        Name.Length -= sizeof( UNICODE_NULL );
    }

    if ( ClassPointer->Length > 0 ) {
        ClassPointer->Length -= sizeof( UNICODE_NULL );
    }

    //
    // Return the name length parameter w/o the NUL.
    //

    if( Error == ERROR_SUCCESS ) {

        *lpcbName = ( Name.Length >> 1 );
    }

    //
    // If requested, return the class length parameter w/o the NUL.
    //

    if( ARGUMENT_PRESENT( lpcbClass )) {
        *lpcbClass = ( Class.Length >> 1 );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regeval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regeval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    enumerate value APIs.  That is:

        - RegEnumValueExA
        - RegEnumValueExW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regeval.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"



LONG
RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD  lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for enumerating values.

--*/

{
    UNICODE_STRING      Name;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error = ERROR_SUCCESS;
    DWORD               ValueType;
    DWORD               ValueLength;
    DWORD               InputLength;
    PWSTR               UnicodeValueBuffer;
    ULONG               UnicodeValueLength;
    PSTR                AnsiValueBuffer;
    ULONG               AnsiValueLength;
    ULONG               Index;
    BOOLEAN             Win95Server = FALSE;
    ULONG               cbAnsi = 0;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Validate dependency between lpData and lpcbData parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpData ) && ( ! ARGUMENT_PRESENT( lpcbData ))) ||
        (!ARGUMENT_PRESENT(lpcbValueName)) || (!ARGUMENT_PRESENT(lpValueName)) ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error =  ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Allocate temporary buffer for the Name
    //
    Name.Length        = 0;
    Name.MaximumLength = (USHORT)((*lpcbValueName + 1) * sizeof( WCHAR ));
    Name.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, Name.MaximumLength );
    if( Name.Buffer == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitCleanup;
    }

    //
    // Call the Base API passing it a pointer to the counted Unicode
    // strings for the value name. Note that zero bytes are transmitted (i.e.
    // InputLength = 0) for the data.
    //

    if (ARGUMENT_PRESENT( lpcbData )) {
        ValueLength = *lpcbData;
        }
    else {
        ValueLength = 0;
        }

    InputLength = 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegEnumValue (
                            hKey,
                            dwIndex,
                            &Name,
                            &ValueType,
                            lpData,
                            &ValueLength,
                            &InputLength
                            );

        ASSERT( Name.Buffer );

    } else {
        DWORD dwVersion;

        //
        // Check for a downlevel Win95 server, which requires
        // us to work around their BaseRegEnumValue bugs.
        // The returned ValueLength is one WCHAR too large AND
        // they trash two bytes beyond the end of the buffer
        // for REG_SZ, REG_MULTI_SZ, and REG_EXPAND_SZ
        //
        Win95Server = IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion);

        if (Win95Server) {
            LPBYTE lpWin95Data;
            //
            // This is a Win95 server.
            // Allocate a new buffer that is two bytes larger than
            // the old one so they can trash the last two bytes.
            //
            lpWin95Data = RtlAllocateHeap(RtlProcessHeap(),
                                          0,
                                          ValueLength+sizeof(WCHAR));
            if (lpWin95Data == NULL) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                                dwIndex,
                                                &Name,
                                                &ValueType,
                                                lpWin95Data,
                                                &ValueLength,
                                                &InputLength);
                if (Error == ERROR_SUCCESS) {
                    if ((ValueType == REG_SZ) ||
                        (ValueType == REG_MULTI_SZ) ||
                        (ValueType == REG_EXPAND_SZ)) {
                        //
                        // The returned length is one WCHAR too large
                        // and the last two bytes of the buffer are trashed.
                        //
                        ValueLength -= sizeof(WCHAR);
                    }
                    CopyMemory(lpData, lpWin95Data, ValueLength);
                }
                RtlFreeHeap(RtlProcessHeap(),0,lpWin95Data);
            }

        } else {
            Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                            dwIndex,
                                            &Name,
                                            &ValueType,
                                            lpData,
                                            &ValueLength,
                                            &InputLength);
        }

    }


    //
    // If no error or callers buffer too small, and type is one of the null
    // terminated string types, then do the UNICODE to ANSI translation.
    // We handle the buffer too small case, because the callers buffer may
    // be big enough for the ANSI representation, but not the UNICODE one.
    // In this case, we need to allocate a buffer big enough, do the query
    // again and then the translation into the callers buffer.
    //

    if ((Error == ERROR_SUCCESS || Error == ERROR_MORE_DATA) &&
        ARGUMENT_PRESENT( lpcbData ) &&
        (ValueType == REG_SZ ||
         ValueType == REG_EXPAND_SZ ||
         ValueType == REG_MULTI_SZ)
       ) {

        UnicodeValueLength         = ValueLength;

        AnsiValueBuffer        = lpData;
        AnsiValueLength        = ARGUMENT_PRESENT( lpcbData )? *lpcbData : 0;


        //
        // Allocate a buffer for the UNICODE value and reissue the query.
        //
        UnicodeValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                          UnicodeValueLength
                                        );
        if (UnicodeValueBuffer == NULL) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            InputLength = 0;

            if( IsLocalHandle( hKey )) {


                Error = (LONG)LocalBaseRegEnumValue (
                                    hKey,
                                    dwIndex,
                                    &Name,
                                    &ValueType,
                                    (LPBYTE)UnicodeValueBuffer,
                                    &ValueLength,
                                    &InputLength
                                    );
                //
                //  Make sure that the local side didn't destroy the
                //  Buffer in the Name
                //

                ASSERT(Name.Buffer);

            } else {
                if (Win95Server) {
                    LPBYTE lpWin95Data;
                    //
                    // This is a Win95 server.
                    // Allocate a new buffer that is two bytes larger than
                    // the old one so they can trash the last two bytes.
                    //
                    lpWin95Data = RtlAllocateHeap(RtlProcessHeap(),
                                                  0,
                                                  ValueLength+sizeof(WCHAR));
                    if (lpWin95Data == NULL) {
                        Error = ERROR_NOT_ENOUGH_MEMORY;
                    } else {
                        Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                                        dwIndex,
                                                        &Name,
                                                        &ValueType,
                                                        lpWin95Data,
                                                        &ValueLength,
                                                        &InputLength);
                        if (Error == ERROR_SUCCESS) {
                            if ((ValueType == REG_SZ) ||
                                (ValueType == REG_MULTI_SZ) ||
                                (ValueType == REG_EXPAND_SZ)) {
                                //
                                // The returned length is one WCHAR too large
                                // and the last two bytes of the buffer are trashed.
                                //
                                ValueLength -= sizeof(WCHAR);
                            }
                            CopyMemory(UnicodeValueBuffer, lpWin95Data, ValueLength);
                        }
                        RtlFreeHeap(RtlProcessHeap(),0,lpWin95Data);
                    }

                } else {
                    Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                                    dwIndex,
                                                    &Name,
                                                    &ValueType,
                                                    (LPBYTE)UnicodeValueBuffer,
                                                    &ValueLength,
                                                    &InputLength);
                }
            }
            // Compute needed buffer size , cbAnsi will keeps the byte
            // counts to keep MBCS string after following step.

            RtlUnicodeToMultiByteSize( &cbAnsi ,
                                       UnicodeValueBuffer ,
                                       ValueLength );

            // If we could not store all MBCS string to buffer that
            // Apps gives me. We set ERROR_MORE_DATA to Error

            if( ARGUMENT_PRESENT( lpcbData ) ) {
                if( cbAnsi > *lpcbData && lpData != NULL ) {
                    Error = ERROR_MORE_DATA;
                }
            }
        }

        if ((Error == ERROR_SUCCESS) && (AnsiValueBuffer != NULL)) {

            //
            // We have a UNICODE value, so translate it to ANSI in the callers
            // buffer.  In the case where the caller's buffer was big enough
            // for the UNICODE version, we do the conversion in place, which
            // works since the ANSI version is smaller than the UNICODE version.
            //


            Index = 0;
            Status = RtlUnicodeToMultiByteN( AnsiValueBuffer,
                                             AnsiValueLength,
                                             &Index,
                                             UnicodeValueBuffer,
                                             UnicodeValueLength
                                           );

            if (!NT_SUCCESS( Status )) {
                Error = RtlNtStatusToDosError( Status );
            }
            cbAnsi = Index;
        }

        //
        // Free the unicode buffer if it was successfully allocated
        //
        if (UnicodeValueBuffer != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValueBuffer );
        }

        //
        // Return the length of the ANSI version to the caller.
        //

        ValueLength = cbAnsi;

        //
        // Special hack to help out all the peopl who
        // believe the length of a NULL terminated string is
        // strlen(foo) instead of strlen(foo) + 1.
        // If the last character of the buffer is not a NULL
        // and there is enough space left in the caller's buffer,
        // slap a NULL in there to prevent him from going nuts
        // trying to do a strlen().
        //
        if (ARGUMENT_PRESENT( lpData ) &&
            (*lpcbData > ValueLength)  &&
            (ValueLength > 0) &&
            (lpData[ValueLength-1] != '\0')) {

            lpData[ValueLength] = '\0';
        }
    }

    //
    // Return the value type and data length if requested and we have it.
    //

    if (Error == ERROR_SUCCESS || Error == ERROR_MORE_DATA) {

        if (lpcbData != NULL) {
            *lpcbData = ValueLength;
        }

        if (lpType != NULL) {
            *lpType = ValueType;
        }
    }

    //
    // If the information was not succesfully queried return the error.
    //

    if( Error != ERROR_SUCCESS ) {
        // free allocated buffer
        RtlFreeHeap( RtlProcessHeap(), 0, Name.Buffer );
        goto ExitCleanup;
    }


    //
    //  Subtract the NULL from the Length. This was added by the server
    //  so that RPC would transmit it.
    //

    if ( Name.Length > 0 ) {
        Name.Length -= sizeof( UNICODE_NULL );
    }

    //
    // Convert the name to ANSI.
    //

    AnsiString.MaximumLength    = ( USHORT ) *lpcbValueName;
    AnsiString.Buffer           = lpValueName;

    Status = RtlUnicodeStringToAnsiString(
                &AnsiString,
                &Name,
                FALSE
                );


    // free allocated buffer
    RtlFreeHeap( RtlProcessHeap(), 0, Name.Buffer );
    //
    // If the name conversion failed, map and return the error.
    //

    if( ! NT_SUCCESS( Status )) {


        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    // Update the name length return parameter.
    //

    *lpcbValueName = AnsiString.Length;


ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}



LONG
RegEnumValueW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for enumerating values.

--*/

{
    UNICODE_STRING      Name;
    LONG                Error;
    DWORD               InputLength;
    DWORD               ValueLength;
    DWORD               ValueType;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Validate dependency between lpData and lpcbData parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpData ) && ( ! ARGUMENT_PRESENT( lpcbData ))) ||
        (!ARGUMENT_PRESENT(lpcbValueName)) || (!ARGUMENT_PRESENT(lpValueName)) ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    Name.Length           = 0;
    Name.MaximumLength    = ( USHORT )( *lpcbValueName << 1 );
    Name.Buffer           = lpValueName;

    //
    // Call the Base API passing it a pointer to the counted Unicode
    // string for the name and return the results. Note that zero bytes
    // are transmitted (i.e.InputLength = 0) for the data.
    //

    InputLength = 0;
    ValueLength = ( ARGUMENT_PRESENT( lpcbData ) )? *lpcbData : 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegEnumValue (
                            hKey,
                            dwIndex,
                            &Name,
                            &ValueType,
                            lpData,
                            &ValueLength,
                            &InputLength
                            );
    } else {
        DWORD dwVersion;

        if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
            LPBYTE lpWin95Data;
            //
            // This is a Win95 server.
            // Allocate a new buffer that is two bytes larger than
            // the old one so they can trash the last two bytes.
            //
            lpWin95Data = RtlAllocateHeap(RtlProcessHeap(),
                                          0,
                                          ValueLength+sizeof(WCHAR));
            if (lpWin95Data == NULL) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto ExitCleanup;
            } else {
                Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                                dwIndex,
                                                &Name,
                                                &ValueType,
                                                lpWin95Data,
                                                &ValueLength,
                                                &InputLength);
                if (Error == ERROR_SUCCESS) {
                    if ((ValueType == REG_SZ) ||
                        (ValueType == REG_MULTI_SZ) ||
                        (ValueType == REG_EXPAND_SZ)) {
                        //
                        // The returned length is one WCHAR too large
                        // and the last two bytes of the buffer are trashed.
                        //
                        ValueLength -= sizeof(WCHAR);
                    }
                    CopyMemory(lpData, lpWin95Data, ValueLength);
                }
                RtlFreeHeap(RtlProcessHeap(),0,lpWin95Data);
            }

        } else {
            Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                            dwIndex,
                                            &Name,
                                            &ValueType,
                                            lpData,
                                            &ValueLength,
                                            &InputLength);
        }
    }
    //
    // Special hack to help out all the people who
    // believe the length of a NULL terminated string is
    // strlen(foo) instead of strlen(foo) + 1.
    // If the last character of the buffer is not a NULL
    // and there is enough space left in the caller's buffer,
    // slap a NULL in there to prevent him from going nuts
    // trying to do a strlen().
    //
    if ( (Error == ERROR_SUCCESS) &&
         ARGUMENT_PRESENT( lpData ) &&
         ( (ValueType == REG_SZ) ||
           (ValueType == REG_EXPAND_SZ) ||
           (ValueType == REG_MULTI_SZ)) &&
         ( ValueLength > sizeof(WCHAR))) {

        UNALIGNED WCHAR *String = (UNALIGNED WCHAR *)lpData;
        DWORD Length = ValueLength/sizeof(WCHAR);

        if ((String[Length-1] != UNICODE_NULL) &&
            (ValueLength+sizeof(WCHAR) <= *lpcbData)) {
            String[Length] = UNICODE_NULL;
        }
    }

    //
    // Don't count the NUL.
    //
    if( Name.Length != 0 ) {
        *lpcbValueName = ( Name.Length >> 1 ) - 1;
    }

    if( ARGUMENT_PRESENT( lpcbData ) ) {
        *lpcbData = ValueLength;
    }
    if ( ARGUMENT_PRESENT( lpType )) {
        *lpType = ValueType;
    }

ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regkey.c ===
/*++



Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    Regkey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to open, create, flush and close keys.  That is:

        - RegCloseKey
        - RegCreateKeyA
        - RegCreateKeyW
        - RegCreateKeyExA
        - RegCreateKeyExW
        - RegFlushKey
        - RegOpenKeyA
        - RegOpenKeyW
        - RegOpenKeyExA
        - RegOpenKeyExW
        - RegOverridePredefKey
        - RegOpenCurrentUser

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    See the notes in server\regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <wow64reg.h>

#if defined(LEAK_TRACK)
NTSTATUS TrackObject(HKEY hKey);
#endif // defined(LEAK_TRACK)

NTSTATUS DisablePredefinedHandleTable(HKEY Handle);


LONG
APIENTRY
RegCloseKey (
    IN HKEY hKey
    )

/*++

Routine Description:

    Win32 RPC wrapper for closeing a key handle.

--*/

{

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( hKey == NULL ) {
        return ERROR_INVALID_HANDLE;
    }

    if( IsPredefinedRegistryHandle( hKey )) {
        return( ClosePredefinedHandle( hKey ) );
    }

    if( IsLocalHandle( hKey )) {

#if defined(_WIN64)
        Wow64RegCloseKey (hKey);
#endif
        return ( LONG ) LocalBaseRegCloseKey( &hKey );

    } else {

        hKey = DereferenceRemoteHandle( hKey );
        return ( LONG ) BaseRegCloseKey( &hKey );
    }
}

LONG
APIENTRY
RegOverridePredefKey (
    IN HKEY hKey,
	IN HKEY hNewKey
    )

/*++

Routine Description:

    Win32 wrapper to override the normal value for a predefined key.

--*/

{

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( hKey == NULL ) {
        return ERROR_INVALID_HANDLE;
    }

    if( !IsPredefinedRegistryHandle( hKey )) {
        return ERROR_INVALID_HANDLE;
    }

    {
	NTSTATUS Status;

	Status = RemapPredefinedHandle( hKey, hNewKey );

	return RtlNtStatusToDosError( Status );
    }
}

LONG
APIENTRY
RegCreateKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win 3.1 ANSI RPC wrapper for opening an existing key or creating a new one.

--*/

{
    LONG    Error;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Win3.1ism - Win 3.1 allows the predefined handle to be opened by
    // specifying a pointer to an empty or NULL string for the sub-key.
    //

    //
    // If the subkey is NULL or points to a NUL string and the handle is
    // predefined, just return the predefined handle (a virtual open)
    // otherwise it's an error.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        if( IsPredefinedRegistryHandle( hKey )) {

            *phkResult = hKey;
            return ERROR_SUCCESS;

        } else {

            return ERROR_BADKEY;
        }
    }

    Error = (LONG)RegCreateKeyExA(
                            hKey,
                            lpSubKey,
                            0,
                            WIN31_CLASS,
                            REG_OPTION_NON_VOLATILE,
                            WIN31_REGSAM,
                            NULL,
                            phkResult,
                            NULL
                            );

    return Error;

}

LONG
APIENTRY
RegCreateKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for opening an existing key or creating a
    new one.

--*/

{
    LONG    Error;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    Error =  (LONG)RegCreateKeyExW(
                            hKey,
                            lpSubKey,
                            0,
                            WIN31_CLASS,
                            REG_OPTION_NON_VOLATILE,
                            WIN31_REGSAM,
                            NULL,
                            phkResult,
                            NULL
                            );

    return Error;

}

LONG
APIENTRY
RegCreateKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for opening an existing key or creating a new one.

    RegCreateKeyExA converts the LPSECURITY_ATTRIBUTES argument to a
    RPC_SECURITY_ATTRIBUTES argument and calls BaseRegCreateKeyExA.

--*/

{
    UNICODE_STRING              SubKey;
    UNICODE_STRING              ClassUnicode;
    PUNICODE_STRING             Class;
    ANSI_STRING                 AnsiString;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    NTSTATUS                    Status;
    LONG                        Error;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        OutputDebugString( "In RegCreateKeyExA\n" );
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {

        return ERROR_INVALID_HANDLE;
    }

    //
    // Ensure Reserved is zero to avoid future compatability problems.
    //

    if( Reserved != 0 ) {
            return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate that the sub key is not NULL.
    //
    if( ! lpSubKey ) {
        return ERROR_BADKEY;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the subkey to a counted Unicode string 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        Status = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add size of NULL so that RPC transmits the right
    //  stuff.
    //
    SubKey.Length += sizeof( UNICODE_NULL );

    if (ARGUMENT_PRESENT( lpClass )) {

        //
        // Convert the class name to a counted Unicode string using a counted
        // Unicode string dynamically allocated by RtlAnsiStringToUnicodeString.
        //

        RtlInitAnsiString( &AnsiString, lpClass );
        Status = RtlAnsiStringToUnicodeString(
                    &ClassUnicode,
                    &AnsiString,
                    TRUE
                    );

        if( ! NT_SUCCESS( Status )) {
            Error = RtlNtStatusToDosError( Status );
            RtlFreeUnicodeString( &SubKey );
            goto ExitCleanup;
        }

        Class = &ClassUnicode;
        Class->Length += sizeof( UNICODE_NULL );

    } else {

        Class = &ClassUnicode;

        Class->Length        = 0;
        Class->MaximumLength = 0;
        Class->Buffer        = NULL;
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //

    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            RtlFreeUnicodeString( &SubKey );
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //

        pRpcSA = NULL;
    }

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

#if defined(_WIN64)
        DWORD dwTempDisposition = 0;
        if ( lpdwDisposition == NULL )
            lpdwDisposition = &dwTempDisposition;

        //
        //  if wow64 reserve field is set in the access mask, call
        //  wow64 function to handle the scenario.
        //

        if ( samDesired & KEY_WOW64_RES ) {

            Error = (LONG)Wow64RegCreateKeyEx (
                            hKey,
                            SubKey.Buffer,
                            0, //reserved
                            Class->Buffer,
                            dwOptions,
                            samDesired,
                            lpSecurityAttributes,
                            phkResult,
                            lpdwDisposition
                            );

        } else
#endif

        Error = (LONG)LocalBaseRegCreateKey (
                            hKey,
                            &SubKey,
                            Class,
                            dwOptions,
                            samDesired,
                            pRpcSA,
                            phkResult,
                            lpdwDisposition
                            );
#if defined(_WIN64)

        if ( ( Error == 0) && ( REG_CREATED_NEW_KEY & *lpdwDisposition) ) //only set dirty if its a newly created key
                    Wow64RegSetKeyDirty (*phkResult);
#endif
    } else {

        Error = (LONG)BaseRegCreateKey (
                            DereferenceRemoteHandle( hKey ),
                            &SubKey,
                            Class,
                            dwOptions,
                            samDesired,
                            pRpcSA,
                            phkResult,
                            lpdwDisposition
                            );

        if( Error == ERROR_SUCCESS) {

            TagRemoteHandle( phkResult );
        }
    }

    //
    // Free the counted Unicode string allocated by
    // RtlAnsiStringToUnicodeString.
    //

    if (Class != NULL) {
        RtlFreeUnicodeString( Class );
    }

    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer and return the
    // Registry return value.
    //

    if( pRpcSA != NULL ) {

        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }
    
    RtlFreeUnicodeString( &SubKey );

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for opening an existing key or creating a new one.

    RegCreateKeyExW converts the LPSECURITY_ATTRIBUTES argument to a
    RPC_SECURITY_ATTRIBUTES argument and calls BaseRegCreateKeyExW.

--*/

{
    UNICODE_STRING              SubKey;
    UNICODE_STRING              ClassUnicode;
    PUNICODE_STRING             Class;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    PWSTR                       AuxBuffer;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Ensure Reserved is zero to avoid future compatability problems.
    //

    if( Reserved != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate that the sub key is not NULL.
    //

    if( ! lpSubKey ) {
        return ERROR_BADKEY;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    //  Add terminating NULL to Length so that RPC transmits it.
    //
    SubKey.Length += sizeof( UNICODE_NULL );
    if( SubKey.Length == 0 ) {
        //
        // overflow in RtlInitUnicodeString
        //
        Error = ERROR_INVALID_PARAMETER;
        goto ExitCleanup;
    }

    if (ARGUMENT_PRESENT( lpClass )) {

        //
        // Convert the class name to a counted Unicode string.
        //

        RtlInitUnicodeString( &ClassUnicode, lpClass );
        Class = &ClassUnicode;
        Class->Length += sizeof( UNICODE_NULL );

    } else {

        Class = &ClassUnicode;

        Class->Length        = 0;
        Class->MaximumLength = 0;
        Class->Buffer        = NULL;
    }


    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it and call the private version of the create key API.
    //

    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //

        pRpcSA = NULL;
    }

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

#if defined(_WIN64)
        DWORD dwTempDisposition = 0;
        if ( lpdwDisposition == NULL )
            lpdwDisposition = &dwTempDisposition;

        //
        //  if wow64 reserve field is set in the access mask, call
        //  wow64 function to handle the scenario.
        //

        if ( samDesired & KEY_WOW64_RES ) {

            Error = (LONG)Wow64RegCreateKeyEx (
                            hKey,
                            SubKey.Buffer,
                            0, //reserved
                            Class->Buffer,
                            dwOptions,
                            samDesired,
                            lpSecurityAttributes,
                            phkResult,
                            lpdwDisposition
                            );
        } else
#endif
        Error = (LONG)LocalBaseRegCreateKey (
                            hKey,
                            &SubKey,
                            Class,
                            dwOptions,
                            samDesired,
                            pRpcSA,
                            phkResult,
                            lpdwDisposition
                            );
#if defined(_WIN64)

        if ( ( Error == 0) && ( REG_CREATED_NEW_KEY & *lpdwDisposition) ) //only set dirty if its a newly created key
                    Wow64RegSetKeyDirty (*phkResult);
#endif
    } else {

        Error = (LONG)BaseRegCreateKey (
                            DereferenceRemoteHandle( hKey ),
                            &SubKey,
                            Class,
                            dwOptions,
                            samDesired,
                            pRpcSA,
                            phkResult,
                            lpdwDisposition
                            );

        if( Error == ERROR_SUCCESS) {

            TagRemoteHandle( phkResult );
        }
    }

    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer and return the
    // Registry return value.
    //

    if( pRpcSA != NULL ) {

        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegFlushKey (
    IN HKEY hKey
    )

/*++

Routine Description:

    Win32 RPC wrapper for flushing changes to backing store.

--*/

{
    LONG                        Error;
    HKEY                        TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Flush is a NO-OP for HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {
        return ERROR_SUCCESS;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegFlushKey( hKey );

    } else {

        Error = (LONG)BaseRegFlushKey( DereferenceRemoteHandle( hKey ));
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegOpenKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win 3.1 ANSI RPC wrapper for opening an existing key.

--*/

{
    LONG    Error;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Win3.1ism - Win 3.1 allows the predefined handle to be opened by
    // specifying a pointer to an empty or NULL string for the sub-key.
    //

    //
    // If the subkey is NULL or points to a NUL string and the handle is
    // predefined, just return the predefined handle (a virtual open)
    // otherwise return the same handle that was passed in.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {
        if( !IsPredefinedRegistryHandle( hKey )) {
            *phkResult = hKey;
            return ERROR_SUCCESS;
        }

/*
        if( IsPredefinedRegistryHandle( hKey )) {

            *phkResult = hKey;
            return ERROR_SUCCESS;

        } else {

            return ERROR_BADKEY;
        }
*/
    }

    Error = (LONG)RegOpenKeyExA(
                        hKey,
                        lpSubKey,
                        REG_OPTION_RESERVED,
                        WIN31_REGSAM,
                        phkResult
                        );

    return Error;

}

LONG
APIENTRY
RegOpenKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for opening an existing key.

--*/

{

    LONG    Error;

#if DBG
    if ( BreakPointOnEntry ) {
        OutputDebugString( "In RegOpenKeyW\n" );
        DbgBreakPoint();
    }
#endif

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Win3.1ism - Win 3.1 allows the predefined handle to be opened by
    // specifying a pointer to an empty or NULL string for the sub-key.
    //

    //
    // If the subkey is NULL or points to a NUL string and the handle is
    // predefined, just return the predefined handle (a virtual open)
    // otherwise return the handle passed in.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {
        if( !IsPredefinedRegistryHandle( hKey )) {
            *phkResult = hKey;
            return ERROR_SUCCESS;
        }

/*
        if( IsPredefinedRegistryHandle( hKey )) {

            *phkResult = hKey;
            return ERROR_SUCCESS;

        } else {

            return ERROR_BADKEY;
        }
*/
    }

    Error = (LONG)RegOpenKeyExW(
                         hKey,
                         lpSubKey,
                         REG_OPTION_RESERVED,
                         WIN31_REGSAM,
                         phkResult
                         );

    return Error;

}

LONG
APIENTRY
RegOpenKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for opening an existing key.

    RegOpenKeyExA converts the lpSubKey argument to a counted Unicode string
    and then calls BaseRegOpenKey.

--*/

{
    UNICODE_STRING      SubKey;
    NTSTATUS            Status;
    LONG                Error;
    CHAR                NullString;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Caller must pass pointer to the variable where the opened handle
    //  will be returned
    //

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  If lpSubKey is NULL, then assume NUL-string as subkey name
    //

    if( lpSubKey == NULL ) {
        NullString = ( CHAR )'\0';
        lpSubKey = &NullString;
    }

    //
    //  If hKey is a predefined key, and lpSubKey is either a NULL pointer or
    //  a NUL string, close the predefined key and clear the associated entry
    //  in the PredefinedHandleTable  (RegCloseKey will do the job).
    //
    if( IsPredefinedRegistryHandle( hKey ) && (!( samDesired & KEY_WOW64_RES )) &&
        ( ( lpSubKey == NULL ) || ( *lpSubKey == '\0' ) ) ) {

        if ( HKEY_CLASSES_ROOT != hKey ) {
            Error = RegCloseKey( hKey );
            if( Error != ERROR_SUCCESS ) {
                return( Error );
            }
            //
            //  Create a handle and save it in the appropriate entry  in
            //  PredefinedHandleTable.
            //  Notice that the client will be impersonated.
            //  (MapPredefinedHandle will do all this stuff).
            //
            if( MapPredefinedHandle( hKey, &TempHandle ) == NULL ) {
                Error = ERROR_INVALID_HANDLE;
                goto ExitCleanup;
            }
        }

        //
        //  Return to the user the handle passed in
        //
        *phkResult = hKey;
        Error = ERROR_SUCCESS;
        goto ExitCleanup;
    }


    //
    // Validate that the sub key is not NULL.
    //

    ASSERT( lpSubKey != NULL );
    if( ! lpSubKey ) {
        Error = ERROR_BADKEY;
        goto ExitCleanup;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the subkey to a counted Unicode string 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        Status = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it.
    //
    SubKey.Length += sizeof( UNICODE_NULL );


    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {
#if defined(_WIN64)

        //
        //  if wow64 reserve field is set in the access mask, call
        //  wow64 function to handle the scenario.
        //

        if ( samDesired & KEY_WOW64_RES ) {

            Error = (LONG)Wow64RegOpenKeyEx (
                            hKey,
                            SubKey.Buffer,
                            dwOptions,
                            samDesired,
                            phkResult
                            );
        } else
#endif

        Error = (LONG)LocalBaseRegOpenKey (
                            hKey,
                            &SubKey,
                            dwOptions,
                            samDesired,
                            phkResult
                            );
    } else {

        Error = (LONG)BaseRegOpenKey (
                            DereferenceRemoteHandle( hKey ),
                            &SubKey,
                            dwOptions,
                            samDesired,
                            phkResult
                            );

        if( Error == ERROR_SUCCESS) {

            TagRemoteHandle( phkResult );
        }
    }

    // free the allocated unicode string
    RtlFreeUnicodeString( &SubKey );

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for opening an existing key.

    RegOpenKeyExW converts the lpSubKey argument to a counted Unicode string
    and then calls BaseRegOpenKey.

--*/

{
    UNICODE_STRING      SubKey;
    LONG                Error;
    WCHAR               NullString;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Caller must pass pointer to the variable where the opened handle
    //  will be returned
    //

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  If lpSubKey is NULL, then assume NUL-string as subkey name
    //

    if( lpSubKey == NULL ) {
        NullString = UNICODE_NULL;
        lpSubKey = &NullString;
    }

    //
    //  If hKey is a predefined key, and lpSubKey is either a NULL pointer or
    //  a NUL string, close the predefined key and clear the associated entry
    //  in the PredefinedHandleTable  (RegCloseKey will do the job).
    //
    if( IsPredefinedRegistryHandle( hKey ) && (!( samDesired & KEY_WOW64_RES )) &&
        ( ( lpSubKey == NULL ) || ( *lpSubKey == ( WCHAR )'\0' ) ) ) {

        if ( HKEY_CLASSES_ROOT != hKey ) {
            Error = RegCloseKey( hKey );
            if( Error != ERROR_SUCCESS ) {
                return( Error );
            }
            //
            //  Create a handle and save it in the appropriate entry  in
            //  PredefinedHandleTable.
            //  Notice that the client will be impersonated.
            //  (MapPredefinedHandle will do all this stuff).
            //
            if( MapPredefinedHandle( hKey, &TempHandle ) == NULL ) {
                Error = ERROR_INVALID_HANDLE;
                goto ExitCleanup;
            }
        }

        //
        //  Return to the user the handle passed in
        //
        *phkResult = hKey;
        Error = ERROR_SUCCESS;
        goto ExitCleanup;
    }

    //
    // Validate that the sub key is not NULL.
    //

    ASSERT( lpSubKey != NULL );
    if( ! lpSubKey ) {
        Error = ERROR_BADKEY;
        goto ExitCleanup;
    }


    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //
    SubKey.Length += sizeof (UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

#if defined(_WIN64)
        //
        //  if wow64 reserve field is set in the access mask, call
        //  wow64 function to handle the scenario. 
        //

        if ( samDesired & KEY_WOW64_RES ) {

            Error = (LONG)Wow64RegOpenKeyEx (
                            hKey,
                            SubKey.Buffer,
                            dwOptions,
                            samDesired,
                            phkResult
                            );
        } else
#endif
        Error =  (LONG)LocalBaseRegOpenKey (
                            hKey,
                            &SubKey,
                            dwOptions,
                            samDesired,
                            phkResult
                            );
    } else {

        Error =  (LONG)BaseRegOpenKey (
                            DereferenceRemoteHandle( hKey ),
                            &SubKey,
                            dwOptions,
                            samDesired,
                            phkResult
                            );

        if( Error == ERROR_SUCCESS) {

            TagRemoteHandle( phkResult );
        }
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegOpenCurrentUser(
    REGSAM samDesired,
    PHKEY phkResult
    )
/*++

Routine Description:

    Win32 Client-Only function to open the key for HKEY_CURRENT_USER
    for the user that the thread is currently impersonating.  Since
    HKEY_CURRENT_USER is cached for all threads in a process, if the
    process is impersonating multiple users, this allows access to
    the appropriate key.

Arguments:

    samDesired - Supplies the requested security access mask.

    phkResult - Returns an open handle to the key.

Return Value:

    Returns 0 (ERROR_SUCCESS) for success, otherwise a windows error code.

--*/
{
    NTSTATUS Status ;

    Status = RtlOpenCurrentUser( samDesired, phkResult );

#if defined(LEAK_TRACK)

    if (NT_SUCCESS(Status)) {
        if (g_RegLeakTraceInfo.bEnableLeakTrack) {
            (void) TrackObject(*phkResult);
        }
    }

#endif // (LEAK_TRACK)

    return RtlNtStatusToDosError( Status );

}

LONG
APIENTRY
RegDisablePredefinedCache(
    )
/*++

Routine Description:

    Win32 Client-Only function to disable the predefined handle table
    for HKEY_CURRENT_USER for the calling process
    All references to HKEY_CURRENT_USER after this function is called
    will result in a open/close on HKU\<sid>

Arguments:


Return Value:

    Returns 0 (ERROR_SUCCESS) for success, otherwise a windows error code.

--*/
{
    NTSTATUS Status ;

    Status = DisablePredefinedHandleTable( HKEY_CURRENT_USER );

    return RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\reglukey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Reglukey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to load, unload and replace keys. That is:

        - RegLoadKeyA
        - RegLoadKeyW
        - RegUnLoadKeyA
        - RegUnLoadKeyW
        - RegReplaceKeyA
        - RegReplaceKeyW

Author:


    Ramon J. San Andres (ramonsa) 16-Apr-1992



--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"


LONG
APIENTRY
RegLoadKeyA(
    HKEY   hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpFile
    )

/*++

Routine Description:

    Win32 Ansi API for loading a key.

--*/

{

    HKEY                Handle;
    UNICODE_STRING      SubKey;
    UNICODE_STRING      File;
    WCHAR               UnicodeBuffer[ MAX_PATH ];
    ANSI_STRING         AnsiFile;
    NTSTATUS            NtStatus;
    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    // OutputDebugString( "Winreg: Entering RegLoadKeyA\n" );
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the SubKey name to a counted Unicode 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        NtStatus = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }


    //
    // Convert the file name to a counted Unicode string using the
    // Unicode string on the stack.
    //
    File.Buffer        = UnicodeBuffer;
    File.MaximumLength = sizeof( UnicodeBuffer );
    RtlInitAnsiString( &AnsiFile, lpFile );
    NtStatus = RtlAnsiStringToUnicodeString(
                    &File,
                    &AnsiFile,
                    FALSE
                    );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( NtStatus )) {
        // free the allocated unicode string
        RtlFreeUnicodeString( &SubKey );

        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( File.Length > 0 ) {
        File.Length += sizeof( UNICODE_NULL );
    }

    //
    // Call the server
    //

    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegLoadKey(
                            Handle,
                            &SubKey,
                            &File
                            );

    } else {

        Error = (LONG)BaseRegLoadKey(
                            DereferenceRemoteHandle( Handle ),
                            &SubKey,
                            &File
                            );
    }

    // free the allocated unicode string
    RtlFreeUnicodeString( &SubKey );

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}




LONG
APIENTRY
RegLoadKeyW(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpFile
    )

/*++

Routine Description:

    Load the tree in the supplied file into the key referenced by the
    supplied key handle and sub-key.  The loaded tree will overwrite all
    of the contents of the supplied sub-key except for its name.
    Pictorially, if the file contains:

                    A
                   / \
                  /   \
                 B     C

    and the supplied key refers to a key name X, the resultant tree would
    look like:

                    X
                   / \
                  /   \
                 B     C

Arguments:

    hKey - Supplies the predefined handle HKEY_USERS or HKEY_LOCAL_MACHINE.
        lpSubKey is relative to this handle.

    lpSubKey - Supplies a path name to a new (i.e.  non-existant) key
        where the supplied file will be loaded.

    lpFile - Supplies a pointer to an existing file name whose contents was
        created with RegSaveKey. The file name may not have an extension.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    The difference between RegRestoreKey and RegLoadKey is that in the
    latter case the supplied file is used as the actual backing store
    whereas in the former case the information in the file is copied into
    the Registry.

    RegLoadKey requires SeRestorePrivilege.

--*/

{

    HKEY                Handle;
    UNICODE_STRING      SubKey;
    UNICODE_STRING      File;
    LONG                Error;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    RtlInitUnicodeString(
            &SubKey,
            lpSubKey
            );

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }


    RtlInitUnicodeString(
            &File,
            lpFile
            );

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( File.Length > 0 ) {
        File.Length += sizeof( UNICODE_NULL );
    }


    //
    // Call the server
    //

    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegLoadKey(
                            Handle,
                            &SubKey,
                            &File
                            );

    } else {

        Error = (LONG)BaseRegLoadKey(
                            DereferenceRemoteHandle( Handle ),
                            &SubKey,
                            &File
                            );
    }
ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}




LONG
APIENTRY
RegUnLoadKeyA(
    HKEY   hKey,
    LPCSTR  lpSubKey
    )
/*++

Routine Description:

    Win32 Ansi API for unloading a key.

--*/

{

    HKEY                Handle;
    UNICODE_STRING      SubKey;
    NTSTATUS            NtStatus;
    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey,&TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    //
    // Convert the SubKey name to a counted Unicode 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        NtStatus = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }


    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegUnLoadKey(
                                Handle,
                                &SubKey
                                );

    } else {

        Error = (LONG)BaseRegUnLoadKey(
                                DereferenceRemoteHandle( Handle ),
                                &SubKey
                                );
    }

    // free the allocated unicode string
    RtlFreeUnicodeString( &SubKey );
ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}




LONG
APIENTRY
RegUnLoadKeyW(
    HKEY   hKey,
    LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Unload the specified tree (hive) from the Registry.

Arguments:

    hKey - Supplies a handle to an open key. lpSubKey is relative to this
        handle.

    lpSubKey - Supplies a path name to the key that is to be unloaded.
        The combination of hKey and lpSubKey must refer to a hive in the
        Registry created with RegRestoreKey or RegLoadKey.  This parameter may
        be NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    RegUnLoadKey requires SeRestorePrivilege.

--*/

{
    HKEY                Handle;
    UNICODE_STRING      SubKey;
    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    RtlInitUnicodeString(
            &SubKey,
            lpSubKey
            );

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }


    //
    // Call the server
    //
    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegUnLoadKey(
                                Handle,
                                &SubKey
                                );

    } else {

        Error = (LONG)BaseRegUnLoadKey(
                                DereferenceRemoteHandle( Handle ),
                                &SubKey
                                );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}






LONG
APIENTRY
RegReplaceKeyA(
    HKEY   hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpNewFile,
    LPCSTR  lpOldFile
    )
/*++

Routine Description:

    Win32 Ansi API for replacing a key.

--*/
{
    HKEY                Handle;
    UNICODE_STRING      SubKey;
    UNICODE_STRING      NewFile;
    UNICODE_STRING      OldFile;
    WCHAR               NewUnicodeBuffer[ MAX_PATH ];
    WCHAR               OldUnicodeBuffer[ MAX_PATH ];
    ANSI_STRING         AnsiFile;
    NTSTATUS            NtStatus;
    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the SubKey name to a counted Unicode 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        NtStatus = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    // Convert the new file name to a counted Unicode string using the
    // Unicode string on the stack.
    //
    NewFile.Buffer        = NewUnicodeBuffer;
    NewFile.MaximumLength = sizeof( NewUnicodeBuffer );
    RtlInitAnsiString( &AnsiFile, lpNewFile );
    NtStatus = RtlAnsiStringToUnicodeString(
                    &NewFile,
                    &AnsiFile,
                    FALSE
                    );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( NtStatus )) {
        // free the allocated unicode string
        RtlFreeUnicodeString( &SubKey );
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }


    //
    // Convert the old file name to a counted Unicode string using the
    // Unicode string on the stack.
    //
    OldFile.Buffer        = OldUnicodeBuffer;
    OldFile.MaximumLength = sizeof( OldUnicodeBuffer );
    RtlInitAnsiString( &AnsiFile, lpOldFile );
    NtStatus = RtlAnsiStringToUnicodeString(
                    &OldFile,
                    &AnsiFile,
                    FALSE
                    );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( NtStatus )) {
        // free the allocated unicode string
        RtlFreeUnicodeString( &SubKey );
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }

    if ( NewFile.Length > 0 ) {
        NewFile.Length += sizeof( UNICODE_NULL );
    }

    if ( OldFile.Length > 0 ) {
        OldFile.Length += sizeof( UNICODE_NULL );
    }

    //
    //  Call the server
    //

    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegReplaceKey(
                                Handle,
                                &SubKey,
                                &NewFile,
                                &OldFile
                                );

    } else {

        Error = (LONG)BaseRegReplaceKey(
                                DereferenceRemoteHandle( Handle ),
                                &SubKey,
                                &NewFile,
                                &OldFile
                                );
    }

    // free the allocated unicode string
    RtlFreeUnicodeString( &SubKey );
ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}




LONG
APIENTRY
RegReplaceKeyW(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpNewFile,
    LPCWSTR  lpOldFile
    )

/*++

Routine Description:

    Replace an existing tree (hive) in the Registry. The new tree will
    take effect the next time the system is rebooted.

Arguments:

    hKey - Supplies a handle to an open key. lpSubKey is relative to this
        handle.

    lpSubKey - Supplies a path name to the key that is to be replaced.
        The combination of hKey and lpSubKey must refer to a hive in the
        Registry.  This parameter may be NULL.

    lpNewFile - Supplies a file name for the new hive file.

    lpOldFile - Supplies a backup file name for the old (existing) hive file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    lpNewFile will remain open until after the system is rebooted.

    RegUnLoadKey requires SeRestorePrivilege.

--*/

{

    HKEY    Handle;
    UNICODE_STRING      SubKey;
    UNICODE_STRING      NewFile;
    UNICODE_STRING      OldFile;
    LONG                Error;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    RtlInitUnicodeString(
                &SubKey,
                lpSubKey
                );

    RtlInitUnicodeString(
                &NewFile,
                lpNewFile
                );

    RtlInitUnicodeString(
                &OldFile,
                lpOldFile
                );


    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }

    if ( NewFile.Length > 0 ) {
        NewFile.Length += sizeof( UNICODE_NULL );
    }

    if ( OldFile.Length > 0 ) {
        OldFile.Length += sizeof( UNICODE_NULL );
    }


    //
    //  Call the server
    //

    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegReplaceKey(
                                Handle,
                                &SubKey,
                                &NewFile,
                                &OldFile
                                );

    } else {

        Error = (LONG)BaseRegReplaceKey(
                                DereferenceRemoteHandle( Handle ),
                                &SubKey,
                                &NewFile,
                                &OldFile
                                );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regqmval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regqmval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    query multiple values APIs:
        - RegQueryMultipleValuesA
        - RegQueryMultipleValuesW

Author:

    John Vert (jvert) 15-Jun-1995

Revision History:

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"


WINADVAPI
LONG
APIENTRY
RegQueryMultipleValuesA (
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    )
/*++

Routine Description:

    The RegQueryMultipleValues function retrieves a list of
    data type/data pairs for a list of value names associated
    with an open registry key.

Parameters:

        hKey
                Identifies a currently open key or any of the pre-defined reserved handle values:
                HKEY_CLASSES_ROOT
                HEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

        valList
                Points to an array of structures describing one or more value entries.  This
                contains the value names of the values to be queried.  Refer to Appendix A for a
                description of VALUE_ENTRY structure.

        num_vals
                Size of valList in bytes. If valListLength is not a multiple of the sizeof pvalue, the
                fractional extra space pointed to by valList is ignored.

        lpValueBuf
                The output buffer for returning value information (value names and value data). Data
                is DWORD aligned with pads inserted as necessary.

        ldwTotsize
                The total size of the output buffer pointed to by lpvalueBuf. On output ldwTotsize
                contains the number of bytes used including pads.  If lpValueBuf  was too short, then on
                output ldwTotsize will be the size needed, and caller should assume that lpValueBuf  was
                filled up to the size specified by ldwTotsize on input.

Return value:

    If the function succeeds, the return value is ERROR_SUCCESS; otherwise it is one
    of the error value which can be returned by RegQueryValueEx.  In addition, if
    either valList or lpValueBuf is too small then ERROR_INSUFFICIENT_BUFFER is returned
    If the function is unable to instantiate/access the provider of the
    dynamic key, it will return ERROR_CANTREAD.  If the total length of the
    requested data (valListLength + ldwTotSize) is more than the system limit of one
    megabytes, then the function returns ERROR_TRANSFER_TOO_LONG and only the first
    megabyte of data is returned.


--*/

{
    NTSTATUS Status;
    PRVALENT Values;
    PUNICODE_STRING Names;
    LONG Error;
    ULONG i;
    ULONG DataLength;
    ULONG InputLength;
    LPDWORD pTotalSize;
    DWORD TotalSize;
    ANSI_STRING AnsiString;
    LPSTR NewValueBuf = NULL;
    DWORD DataOffset;
    ULONG AnsiLength;
    HKEY    TempHandle = NULL;

    hKey = MapPredefinedHandle(hKey, &TempHandle);
    if (hKey == NULL) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Allocate an array of RVALENTs to describe the input value names
    //
    Values = RtlAllocateHeap(RtlProcessHeap(),0,num_vals * sizeof(RVALENT));
    if (Values == NULL) {
        Error = ERROR_OUTOFMEMORY;
        goto ExitCleanup;
    }
    ZeroMemory(Values, sizeof(RVALENT)*num_vals);

    //
    // Allocate an array of UNICODE_STRINGs to contain the input names
    //
    Names = RtlAllocateHeap(RtlProcessHeap(),0,num_vals * sizeof(UNICODE_STRING));
    if (Names == NULL) {
        Error = ERROR_OUTOFMEMORY;
        goto ExitCleanup;
    }
    ZeroMemory(Names, num_vals*sizeof(UNICODE_STRING));

    //
    // Convert the value names to UNICODE_STRINGs
    //
    for (i=0; i<num_vals; i++) {
        RtlInitAnsiString(&AnsiString, val_list[i].ve_valuename);
        Status = RtlAnsiStringToUnicodeString(&Names[i], &AnsiString, TRUE);
        if (!NT_SUCCESS(Status)) {
            Error =  RtlNtStatusToDosError( Status );
            goto Cleanup;
        }

        //
        //  Add the terminating NULL to the Length so that RPC transmits
        //  it.
        //
        Names[i].Length += sizeof( UNICODE_NULL );
        Values[i].rv_valuename = &Names[i];
    }

    //
    // Allocate a data buffer twice the size of the input buffer
    // so that any Unicode value data will fit before it is converted
    // to Ansi.
    //

    if ((ldwTotsize == NULL) || (*ldwTotsize == 0)) {
        TotalSize = 0;
    } else {
        TotalSize = *ldwTotsize * sizeof(WCHAR);
        NewValueBuf = RtlAllocateHeap(RtlProcessHeap(),0,TotalSize);
        if (NewValueBuf == NULL) {
            Error = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    pTotalSize = &TotalSize;

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if (IsLocalHandle(hKey)) {
        Error = (LONG)LocalBaseRegQueryMultipleValues(hKey,
                                                      Values,
                                                      num_vals,
                                                      NewValueBuf,
                                                      pTotalSize);
    } else {
        DWORD dwVersion;
        Error = (LONG)BaseRegQueryMultipleValues(DereferenceRemoteHandle( hKey ),
                                                 Values,
                                                 num_vals,
                                                 NewValueBuf,
                                                 pTotalSize);
        if ((Error == ERROR_SUCCESS) &&
            (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion))) {
            //
            // Win95's RegQueryMultipleValues doesn't return Unicode
            // value data, so do not try and convert it back to Ansi.
            //
            for (i=0; i<num_vals; i++) {
                val_list[i].ve_valuelen = Values[i].rv_valuelen;
                val_list[i].ve_type = Values[i].rv_type;
                val_list[i].ve_valueptr = (DWORD_PTR)(lpValueBuf + Values[i].rv_valueptr);
            }
            CopyMemory(lpValueBuf,NewValueBuf,TotalSize);
            if (ldwTotsize != NULL) {
                *ldwTotsize = TotalSize;
            }
            goto Cleanup;
        }
    }
    if (Error == ERROR_SUCCESS) {
        //
        // Convert results back.
        //
        DataOffset = 0;
        for (i=0; i < num_vals; i++) {
            val_list[i].ve_valuelen = Values[i].rv_valuelen;
            val_list[i].ve_type = Values[i].rv_type;
            val_list[i].ve_valueptr = (DWORD_PTR)(lpValueBuf + DataOffset);
            if ((val_list[i].ve_type == REG_SZ) ||
                (val_list[i].ve_type == REG_EXPAND_SZ) ||
                (val_list[i].ve_type == REG_MULTI_SZ)) {

                Status = RtlUnicodeToMultiByteN(lpValueBuf + DataOffset,
                                                Values[i].rv_valuelen/sizeof(WCHAR),
                                                &AnsiLength,
                                                (PWCH)(NewValueBuf + Values[i].rv_valueptr),
                                                Values[i].rv_valuelen);
                if (!NT_SUCCESS(Status)) {
                    Error =  RtlNtStatusToDosError( Status );
                }
                val_list[i].ve_valuelen = AnsiLength;
                DataOffset += AnsiLength;
            } else {
                CopyMemory(lpValueBuf + DataOffset,
                           NewValueBuf + Values[i].rv_valueptr,
                           Values[i].rv_valuelen);
                DataOffset += Values[i].rv_valuelen;
            }
            //
            // Round DataOffset up to dword boundary.
            //
            DataOffset = (DataOffset + sizeof(DWORD) - 1) & ~(sizeof(DWORD)-1);
        }
        if (ldwTotsize != NULL) {
            *ldwTotsize = DataOffset;
        }
    } else if (Error == ERROR_MORE_DATA) {
        //
        // We need to thunk the Unicode required bytes back to Ansi. But
        // there is not really any way to do this without having the data
        // available. So just return the required bytes for the Unicode
        // data, as this will always be enough.
        //
        if (ldwTotsize != NULL) {
            *ldwTotsize = *pTotalSize;
        }
    }

Cleanup:
    if (NewValueBuf != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,NewValueBuf);
    }
    for (i=0; i<num_vals; i++) {
        if (Names[i].Buffer != NULL) {
            RtlFreeUnicodeString(&Names[i]);
        }
    }
    RtlFreeHeap(RtlProcessHeap(),0,Values);
    RtlFreeHeap(RtlProcessHeap(),0,Names);

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

WINADVAPI
LONG
APIENTRY
RegQueryMultipleValuesW (
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    )
/*++

Routine Description:

    The RegQueryMultipleValues function retrieves a list of
    data type/data pairs for a list of value names associated
    with an open registry key.

Parameters:

        hKey
                Identifies a currently open key or any of the pre-defined reserved handle values:
                HKEY_CLASSES_ROOT
                HEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

        valList
                Points to an array of structures describing one or more value entries.  This
                contains the value names of the values to be queried.  Refer to Appendix A for a
                description of VALUE_ENTRY structure.

        num_vals
                Size of valList in bytes. If valListLength is not a multiple of the sizeof pvalue, the
                fractional extra space pointed to by valList is ignored.

        lpValueBuf
                The output buffer for returning value information (value names and value data). Data
                is DWORD aligned with pads inserted as necessary.

        ldwTotsize
                The total size of the output buffer pointed to by lpValueBuf. On output ldwTotsize
                contains the number of bytes used including pads.  If lpValueBuf  was too short, then on
                output ldwTotsize will be the size needed, and caller should assume that lpValueBuf  was
                filled up to the size specified by ldwTotsize on input.

Return value:

    If the function succeeds, the return value is ERROR_SUCCESS; otherwise it is one
    of the error value which can be returned by RegQueryValueEx.  In addition, if
    either valList or lpValueBuf is too small then ERROR_INSUFFICIENT_BUFFER is returned
    If the function is unable to instantiate/access the provider of the
    dynamic key, it will return ERROR_CANTREAD.  If the total length of the
    requested data (valListLength + ldwTotSize) is more than the system limit of one
    megabytes, then the function returns ERROR_TRANSFER_TOO_LONG and only the first
    megabyte of data is returned.


--*/

{
    NTSTATUS Status;
    PRVALENT Values;
    PUNICODE_STRING Names;
    LONG Error;
    ULONG i;
    ULONG DataLength;
    ULONG InputLength;
    LPDWORD pTotalSize;
    DWORD TotalSize;
    DWORD StringLength;
    HKEY    TempHandle = NULL;

    hKey = MapPredefinedHandle(hKey, &TempHandle);
    if (hKey == NULL) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Allocate an array of RVALENTs to describe the input value names
    //
    Values = RtlAllocateHeap(RtlProcessHeap(),0,num_vals * sizeof(RVALENT));
    if (Values == NULL) {
        Error = ERROR_OUTOFMEMORY;
        goto ExitCleanup;
    }
    ZeroMemory(Values, sizeof(RVALENT)*num_vals);

    //
    // Allocate an array of UNICODE_STRINGs to contain the input names
    //
    Names = RtlAllocateHeap(RtlProcessHeap(),0,num_vals * sizeof(UNICODE_STRING));
    if (Names == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, Values);
        Error = ERROR_OUTOFMEMORY;
        goto ExitCleanup;
    }
    ZeroMemory(Names, num_vals*sizeof(UNICODE_STRING));

    //
    // Copy and convert the value names to UNICODE_STRINGs
    // Note that we have to copy the value names because RPC tromps
    // on them.
    //
    for (i=0; i<num_vals; i++) {

        StringLength = wcslen(val_list[i].ve_valuename)*sizeof(WCHAR);
        Names[i].Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, StringLength + sizeof(UNICODE_NULL));
        if (Names[i].Buffer == NULL) {
            goto error_exit;
        }
        Names[i].Length = Names[i].MaximumLength = (USHORT)StringLength + sizeof(UNICODE_NULL);
        CopyMemory(Names[i].Buffer, val_list[i].ve_valuename, StringLength + sizeof(UNICODE_NULL));

        Values[i].rv_valuename = &Names[i];
    }

    if (ldwTotsize == NULL) {
        TotalSize = 0;
        pTotalSize = &TotalSize;
    } else {
        pTotalSize = ldwTotsize;
    }

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if (IsLocalHandle(hKey)) {
        Error = (LONG)LocalBaseRegQueryMultipleValues(hKey,
                                                      Values,
                                                      num_vals,
                                                      (LPSTR)lpValueBuf,
                                                      pTotalSize);
    } else {
        DWORD dwVersion;
        if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
            //
            // We cannot support RegQueryMultipleValuesW to Win95 servers
            // since they do not return Unicode value data.
            //
            Error = ERROR_CALL_NOT_IMPLEMENTED;
        } else {
            Error = (LONG)BaseRegQueryMultipleValues(DereferenceRemoteHandle( hKey ),
                                                     Values,
                                                     num_vals,
                                                     (LPSTR)lpValueBuf,
                                                     pTotalSize);
        }
    }
    if (Error == ERROR_SUCCESS) {
        //
        // Convert results back.
        //
        for (i=0; i < num_vals; i++) {
            val_list[i].ve_valuelen = Values[i].rv_valuelen;
            val_list[i].ve_valueptr = (DWORD_PTR)((LPCSTR)lpValueBuf + Values[i].rv_valueptr);
            val_list[i].ve_type = Values[i].rv_type;
        }
    }

error_exit:
    for (i=0; i < num_vals; i++) {
        if (Names[i].Buffer != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, Names[i].Buffer);
        }
    }

    RtlFreeHeap(RtlProcessHeap(),0,Values);
    RtlFreeHeap(RtlProcessHeap(),0,Names);

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regnckey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regnckey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to notify a caller about a changed Key value. That is:

        - RegNotifyChangeKey

Author:

    David J. Gilman (davegi) 10-Feb-1992

Notes:

    The implementation of RegNotifyChangeKeyValue involves >= 4 threads: 2 on
    the client side and >= 2 on the server side.

    Client:

        Thread 1.- The user's thread executing the RegNotifyChangeKeyValue.
                   This threads does:

                   - If thread #2 has not been created yet, it creates a
                     named pipe and thread #2.

                   - Does a synchronous RPC to the server



        Thread 2.- This thread reads events from the named pipe and signals
                   them. The writers to the pipe are the RPC servers which
                   thread 1 has called.





    Server:

        Thread 1.- This thread services the RPC from the client side. It
                   calls the NT notification API and adds the notification
                   handle to a "notification list".

        Thread 2.- This thread waits on part of the "notification list",
                   telling the original client (via named pipe) what events
                   need to be signaled.

        Threads 3... etc. Same as thread 2.





Revision History:

    02-Apr-1992     Ramon J. San Andres (ramonsa)
                    Changed to use RPC.


--*/


#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <stdlib.h>

NTSTATUS BaseRegNotifyClassKey(
    IN  HKEY                     hKey,
    IN  HANDLE                   hEvent,
    IN  PIO_STATUS_BLOCK         pLocalIoStatusBlock,
    IN  DWORD                    dwNotifyFilter,
    IN  BOOLEAN                  fWatchSubtree,
    IN  BOOLEAN                  fAsynchronous);

//
// Used by local call to NtNotifyChangeKey.
//

IO_STATUS_BLOCK     LocalIoStatusBlock;


#ifndef REMOTE_NOTIFICATION_DISABLED
//
//  Named pipe full paths.
//
#define NAMED_PIPE_HERE     L"\\Device\\NamedPipe\\"

//
//  Maximum number of times we will retry to create a pipe if there are
//  name conflicts.
//
#define MAX_PIPE_RETRIES    1000



//
//  Local variables.
//

//
//  Critical section to control access to notification structures
//
RTL_CRITICAL_SECTION        NotificationCriticalSection;

//
//  Our machine name
//
UNICODE_STRING              OurMachineName;
WCHAR                       OurMachineNameBuffer[ MAX_PATH ];

//
//  Named pipe used for notification
//
UNICODE_STRING              NotificationPipeName;
WCHAR                       NotificationPipeNameBuffer[ MAX_PATH ];
HANDLE                      NotificationPipeHandle;
RPC_SECURITY_ATTRIBUTES     NotificationPipeSaRpc;

//
//  Security descriptor used in the named pipe
//
SECURITY_DESCRIPTOR         SecurityDescriptor;
PACL                        Acl;
BOOL                        SecurityDescriptorInitialized;

//
//  Notification thread
//
HANDLE                      NotificationThread;
DWORD                       NotificationClientId;


//
//  Local prototypes
//
LONG
CreateNotificationPipe(
    );

VOID
NotificationHandler(
    );
#endif // REMOTE_NOTIFICATION_DISABLED


#ifndef REMOTE_NOTIFICATION_DISABLED

LONG
InitializeNotificationPipeSecurityDescriptor(
    )
/*++

Routine Description:

    Initialize the security descriptor (global variable) to be attached to
    the named pipe.

Arguments:

    None

Return Value:

    LONG - Returns a win32 error code.

--*/

{
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ULONG                    AclLength;
    PSID                     WorldSid;

    NTSTATUS                 NtStatus;

    //
    // Initialize global variables
    //
    SecurityDescriptorInitialized = FALSE;
    Acl = NULL;

    //
    //  Get World SID
    //
    NtStatus = RtlAllocateAndInitializeSid( &WorldSidAuthority,
                                            1,
                                            SECURITY_WORLD_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &WorldSid
                                          );

    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to allocate and initialize SID, NtStatus = %x \n", NtStatus );
#endif
        return( RtlNtStatusToDosError( NtStatus ) );
    }


    //
    //  Allocate buffer for ACL.
    //  This buffer should be big enough for the ACL header and for each ACE.
    //  Each ACE needs an ACE header.
    //
    AclLength = sizeof( ACL ) +
                sizeof( ACCESS_ALLOWED_ACE ) +
                GetLengthSid( WorldSid ) +
                sizeof( DWORD );

    Acl = RtlAllocateHeap( RtlProcessHeap(), 0, AclLength );
    ASSERT( Acl != NULL );
    if( Acl == NULL ) {
#if DBG
        DbgPrint( "WINREG: Unable to allocate memory, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeSid( WorldSid );
        return( ERROR_OUTOFMEMORY );
    }

    //
    // Build ACL: World has all access
    //

    NtStatus = RtlCreateAcl( (PACL)Acl,
                             AclLength,
                             ACL_REVISION2
                           );

    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to create ACL, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeSid( WorldSid );
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( RtlNtStatusToDosError( NtStatus ) );
    }

    NtStatus = RtlAddAccessAllowedAce( (PACL)Acl,
                                       ACL_REVISION2,
                                       SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                       WorldSid
                                     );

    RtlFreeSid( WorldSid );
    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to add ACE, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( RtlNtStatusToDosError( NtStatus ) );
    }

    //
    //  Build security descriptor
    //
    NtStatus = RtlCreateSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to create security descriptor, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( RtlNtStatusToDosError( NtStatus ) );
    }

#if DBG
    if( !RtlValidAcl( (PACL )Acl ) ) {
        DbgPrint( "WINREG: Acl is invalid \n" );
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( ERROR_INVALID_ACL );
    }
#endif

    NtStatus = RtlSetDaclSecurityDescriptor ( &SecurityDescriptor,
                                              TRUE,
                                              (PACL)Acl,
                                              FALSE
                                            );
    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to set DACL, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( RtlNtStatusToDosError( NtStatus ) );
    }
    SecurityDescriptorInitialized = TRUE;
    return( ERROR_SUCCESS );
}



BOOL
InitializeRegNotifyChangeKeyValue(
    )
/*++

Routine Description:


    Initializes the static data structures used by the
    RegNotifyChangeKeyValue client. Called once at DLL
    initialization.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if successful.


--*/

{

    NTSTATUS    NtStatus;


    NtStatus = RtlInitializeCriticalSection(
                    &NotificationCriticalSection
                    );

    if ( NT_SUCCESS( NtStatus ) ) {



        //
        //  Initialize our machine name. Note that the actual
        //  name is only obtained when the notification API
        //  is first invoked.
        //
        OurMachineName.Length        = 0;
        OurMachineName.MaximumLength = MAX_PATH * sizeof(WCHAR);
        OurMachineName.Buffer        = OurMachineNameBuffer;

        //
        //  Initialize named pipe data
        //
        NotificationPipeName.Length         = 0;
        NotificationPipeName.MaximumLength  = MAX_PATH * sizeof(WCHAR);
        NotificationPipeName.Buffer         = NotificationPipeNameBuffer;

        NotificationThread      = NULL;
        NotificationPipeHandle  = NULL;

        NotificationPipeSaRpc.RpcSecurityDescriptor.lpSecurityDescriptor = NULL;

        return TRUE;
    }

    return FALSE;

}



BOOL
CleanupRegNotifyChangeKeyValue(
    )
/*++

Routine Description:


    Performs any cleanup of the static data structures used
    by the RegNotifyChangeKeyValue client. Called once at
    process termination.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if successful.


--*/

{

    NTSTATUS    NtStatus;


    //
    //  Terminate notification thread if there is one running
    //
    if ( NotificationThread != NULL ) {

        //
        //  Close the named pipe
        //
        if ( NotificationPipeHandle != NULL ) {

            NtStatus = NtClose( NotificationPipeHandle );

            ASSERT( NT_SUCCESS( NtStatus ) );
        }

        TerminateThread( NotificationThread, 0 );
    }

    //
    //  Delete the notification critical section
    //
    NtStatus = RtlDeleteCriticalSection(
                    &NotificationCriticalSection
                    );

    ASSERT( NT_SUCCESS( NtStatus ) );

    if ( NotificationPipeSaRpc.RpcSecurityDescriptor.lpSecurityDescriptor ) {
        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            NotificationPipeSaRpc.RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }

    return  TRUE;

}
#endif  // REMOTE_NOTIFICATION_DISABLED



LONG
RegNotifyChangeKeyValue(
    HKEY    hKey,
    BOOL    fWatchSubtree,
    DWORD   dwNotifyFilter,
    HANDLE  hEvent,
    BOOL    fAsynchronous
    )

/*++

Routine Description:

    This API is used to watch a key or sub-tree for changes. It can be
    called either synchronously or asynchronously. In the latter case the
    caller must supply an event that is signalled when changes occur. In
    either case it is possible to filter the criteria by which the
    notification occurs.


Arguments:

    hKey - Supplies a handle to a key that has been previously opened with
        KEY_NOTIFY access.

    fWatchSubtree - Supplies a boolean value that if TRUE causes the
        system to monitor the key and all of its decsendants.  A value of
        FALSE causes the system to monitor only the specified key.

    dwNotifyFilter - Supplies a set of flags that specify the filter
        conditions the system uses to satisfy a change notification.

        REG_NOTIFY_CHANGE_KEYNAME - Any key name changes that occur
            in a key or subtree being watched will satisfy a
            change notification wait.  This includes creations
            and deletions.

        REG_NOTIFY_CHANGE_ATTRIBUTES - Any attribute changes that occur
            in a key or subtree being watched will satisfy a
            change notification.

        REG_NOTIFY_CHANGE_LAST_WRITE - Any last write time changes that
            occur in a key or subtree being watched will satisfy a
            change notification.

        REG_NOTIFY_CHANGE_SECURITY - Any security descriptor changes
            that occur in a key or subtree being watched will
            satisfy a change notification.


    hEvent - Supplies an optional event handle. This parameter is ignored
        if fAsynchronus is set to FALSE.

    fAsynchronous - Supplies a flag which if FALSE causes the API to not
        return until something has changed. If TRUE, the API returns
        immediately and changes are reported via the supplied event. It
        is an error for this parameter to be TRUE and hEvent to be NULL.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.

Notes:

    If the supplied hKey is closed the event is signalled.
    Therefore it is possible to return from a wait on the event and then
    have subsequent APIs fail.

--*/

{
    HKEY                        Handle;
    HANDLE                      EventHandle;
    LONG                        Error       = ERROR_SUCCESS;
    NTSTATUS                    NtStatus;
    PRPC_SECURITY_ATTRIBUTES    pRpcSa;
    HKEY                        TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Validate the dependency between fAsynchronus and hEvent.
    //
    if (( fAsynchronous ) && ( ! ARGUMENT_PRESENT( hEvent ))) {
        return ERROR_INVALID_PARAMETER;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        CLOSE_LOCAL_HANDLE(TempHandle);
        return ERROR_INVALID_HANDLE;
    }

    //
    // Notification is not supported on remote handles.
    //
    if( !IsLocalHandle( Handle ) ) {
        CLOSE_LOCAL_HANDLE(TempHandle);
        return ERROR_INVALID_HANDLE;

    } else {

        //
        // If its a local handle, make an Nt API call and return.
        //

        if (IsSpecialClassesHandle( Handle )) {

            //
            // We call a special function for class keys
            //
            NtStatus = BaseRegNotifyClassKey(
                Handle,
                hEvent,
                &LocalIoStatusBlock,
                dwNotifyFilter,
                ( BOOLEAN ) fWatchSubtree,
                ( BOOLEAN ) fAsynchronous
                );

        } else {
            NtStatus = NtNotifyChangeKey(
                Handle,
                hEvent,
                NULL,
                NULL,
                &LocalIoStatusBlock,
                dwNotifyFilter,
                ( BOOLEAN ) fWatchSubtree,
                NULL,
                0,
                ( BOOLEAN ) fAsynchronous
                );
        }

        if( NT_SUCCESS( NtStatus ) ||
            ( NtStatus == STATUS_PENDING ) ) {
            Error = (error_status_t)ERROR_SUCCESS;
        } else {
            Error = (error_status_t) RtlNtStatusToDosError( NtStatus );
        }

        CLOSE_LOCAL_HANDLE(TempHandle);
        return Error;
    }

#ifndef REMOTE_NOTIFICATION_DISABLED

    // NOTE: THE FOLLOWING CODE IS DISABLED BY THE CHECK FOR
    // IsLocalHandle AT THE BEGINNING OF THE FUNCTION.
    //

    //
    //  If this is an asynchronous call, we use the user-provided
    //  event and will let the user wait on it him/herself.
    //  Otherwise we have to create our own event and wait on
    //  it ourselves.
    //
    //  This is because the server side of the API is always
    //  asynchronous.
    //
    if ( fAsynchronous ) {

        EventHandle = hEvent;

    } else {

        NtStatus = NtCreateEvent(
                        &EventHandle,
                        EVENT_ALL_ACCESS,
                        NULL,
                        NotificationEvent,
                        FALSE
                        );

        if ( !NT_SUCCESS( NtStatus ) ) {
            return RtlNtStatusToDosError( NtStatus );
        }
    }

    //
    //  See if the notification thread is already running
    //  and create it if not.  We have to protect this
    //  with a critical section because there might be
    //  several instances of this API doing this check
    //  at the same time.
    //
    NtStatus = RtlEnterCriticalSection( &NotificationCriticalSection );

    if ( !NT_SUCCESS( NtStatus ) ) {

        Error = RtlNtStatusToDosError( NtStatus );

    } else {

        //
        //  We are now inside the critical section
        //
        if ( NotificationThread == NULL ) {


            //
            //  Create a named pipe for the notification thread
            //  to use.
            //
            Error = CreateNotificationPipe( );

            if ( Error == ERROR_SUCCESS ) {

                //
                //  Create the notification thread
                //
                NotificationThread = CreateThread(
                                        NULL,
                                        (16 * 1024),
                                        (LPTHREAD_START_ROUTINE)NotificationHandler,
                                        NULL,
                                        0,
                                        &NotificationClientId
                                        );

                if ( NotificationThread == NULL ) {
                    //
                    //  Could not create thread, remove the named pipe.
                    //
                    Error = GetLastError();
                    NtClose( NotificationPipeHandle );
                }
            }
        }

        NtStatus = RtlLeaveCriticalSection( &NotificationCriticalSection );

        ASSERT( NT_SUCCESS( NtStatus ) );
    }

    if ( Error == ERROR_SUCCESS ) {

        //
        //  Let the server side do its work. Remember that this call
        //  is always asynchronous.
        //
        if ( NotificationPipeSaRpc.RpcSecurityDescriptor.lpSecurityDescriptor ) {
            pRpcSa = &NotificationPipeSaRpc;
        } else {
            pRpcSa = NULL;
        }

        //NotificationPipeName.Length += sizeof(UNICODE_NULL);
        //OurMachineName.Length       += sizeof(UNICODE_NULL );

        // DbgPrint(" Waiting for notification, handle %x\n", EventHandle );

        Error = (LONG)BaseRegNotifyChangeKeyValue(
                                DereferenceRemoteHandle( Handle ),
                                (BOOLEAN)fWatchSubtree,
                                dwNotifyFilter,
                                (DWORD)EventHandle,
                                &OurMachineName,
                                &NotificationPipeName,
                                pRpcSa
                                );

        //NotificationPipeName.Length -= sizeof(UNICODE_NULL);
        //OurMachineName.Length       -= sizeof(UNICODE_NULL );

    }


    //
    //  If the call went ok. and we are in synchronous mode, we have
    //  to wait on the event.
    //
    if ( (Error == ERROR_SUCCESS) && !fAsynchronous ) {

        NtStatus = NtWaitForSingleObject(
                        EventHandle,
                        FALSE,
                        NULL
                        );


        if ( !NT_SUCCESS( NtStatus ) ) {
            Error = RtlNtStatusToDosError( NtStatus );
        }
    }


    //
    //  If we created an event, we must close it now.
    //
    if ( !fAsynchronous ) {

        NtStatus = NtClose( EventHandle );
        ASSERT( NT_SUCCESS( NtStatus ));
    }

    return Error;
#endif // REMOTE_NOTIFICATION_DISABLED
}


#ifndef REMOTE_NOTIFICATION_DISABLED


LONG
CreateNotificationPipe(
    )
/*++

Routine Description:


    Creates the notification named pipe and sets the appropriate
    global variables.

    Note that the NotificationPipeName set by this function is
    server-relative, so that no conversion is required on the
    server side.


Arguments:

    None

Return Value:

    Error code.


--*/
{

    UNICODE_STRING      PipeName;
    WCHAR               PipeNameBuffer[ MAX_PATH ];
    USHORT              OrgSize;
    DWORD               Sequence;
    NTSTATUS            NtStatus;
    LARGE_INTEGER       Timeout;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    DWORD               MachineNameLength;
    LONG                WinStatus;

    //
    //  Get our machine name
    //
    MachineNameLength = MAX_PATH;
    if ( !GetComputerNameW( OurMachineNameBuffer, &MachineNameLength ) ) {
        return GetLastError();
    }

    OurMachineName.Buffer        = OurMachineNameBuffer;
    OurMachineName.Length        = (USHORT)(MachineNameLength * sizeof(WCHAR));
    OurMachineName.MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR));

    //
    //  Get the "here" name
    //
    RtlMoveMemory(
            PipeNameBuffer,
            NAMED_PIPE_HERE,
            sizeof( NAMED_PIPE_HERE)
            );


    PipeName.MaximumLength  = MAX_PATH * sizeof(WCHAR);
    PipeName.Buffer         = PipeNameBuffer;

    //
    //  Remember the size of the base portion of the pipe name, so
    //  we can patch it later when we attempt to create the full
    //  name.
    //
    OrgSize = (USHORT)(sizeof(NAMED_PIPE_HERE) - sizeof(UNICODE_NULL));

    //
    //  Create the named pipe, if the name is already being used,
    //  keep trying with different names.
    //
    Sequence = 0;

    Timeout.QuadPart = Int32x32To64( -10 * 1000, 50 );

    //
    //  Initialize the security descriptor that will be set in the named pipe
    //
    WinStatus = InitializeNotificationPipeSecurityDescriptor();
    if( WinStatus != ERROR_SUCCESS ) {
        return( WinStatus );
    }

    do {

        //
        //  Get a semi-unique name
        //
        if ( !MakeSemiUniqueName( &NotificationPipeName, Sequence++ ) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        //  Patch the full pipe name, in case this is not our first
        //  try.
        //
        PipeName.Buffer[OrgSize/sizeof(WCHAR)] = UNICODE_NULL;
        PipeName.Length          = OrgSize;

        //
        //  Now get the full path of the pipe name
        //
        NtStatus = RtlAppendUnicodeStringToString(
                            &PipeName,
                            &NotificationPipeName
                            );


        ASSERT( NT_SUCCESS( NtStatus ) );

        if ( !NT_SUCCESS( NtStatus ) ) {
            break;
        }


        InitializeObjectAttributes(
                    &Obja,
                    &PipeName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );


        if( SecurityDescriptorInitialized ) {
            Obja.SecurityDescriptor = &SecurityDescriptor;
        }

        NtStatus = NtCreateNamedPipeFile (
                        &NotificationPipeHandle,
                        SYNCHRONIZE | GENERIC_READ | FILE_WRITE_ATTRIBUTES,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        FILE_CREATE,
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        FILE_PIPE_MESSAGE_TYPE,
                        FILE_PIPE_MESSAGE_MODE,
                        FILE_PIPE_QUEUE_OPERATION,
                        1,
                        0,
                        0,
                        &Timeout
                        );

    } while ( (NtStatus == STATUS_OBJECT_NAME_EXISTS) &&
              (Sequence <= MAX_PIPE_RETRIES )
            );

    //
    // At this point we don't need the security descriptor anymore.
    // Free the memory allocated for the ACL
    //
    if( SecurityDescriptorInitialized ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, Acl );
        Acl = NULL;
        SecurityDescriptorInitialized = FALSE;
    }

    if ( !NT_SUCCESS( NtStatus ) ) {
        return RtlNtStatusToDosError( NtStatus );
    }

    NotificationPipeName.Length += sizeof(UNICODE_NULL);
    OurMachineName.Length       += sizeof(UNICODE_NULL );

    return ERROR_SUCCESS;
}





VOID
NotificationHandler(
    )

/*++

Routine Description:


    This function is the entry point of the notification thread.
    The notification thread is created the first time that
    the RegNotifyChangeKeyValue API is called by the process,
    and keeps on running until the process terminates.

    This function creates a named pipe whose name is given by
    RegNotifyChangeKeyValue to all its servers.  The servers
    then use the pipe to indicate that a particular event has
    to be signaled.
                                                                        117
    Note that this single thread is in charge of signaling the
    events for all the RegNotifyChangeKeyValue invocations of
    the process.  However no state has to be maintained by this
    thread because all the state information is provided by the
    server through the named pipe.


Arguments:

    None

Return Value:

    None


--*/

{
    NTSTATUS        NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE          EventHandle;


    ASSERT( NotificationPipeHandle != NULL );

    while ( TRUE ) {

        //
        //  Wait for a connection
        //
        NtStatus = NtFsControlFile(
                        NotificationPipeHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FSCTL_PIPE_LISTEN,
                        NULL,
                        0,
                        NULL,
                        0
                        );

        if ( NtStatus == STATUS_PENDING ) {

            NtStatus = NtWaitForSingleObject(
                            NotificationPipeHandle,
                            FALSE,
                            NULL
                            );
        }

        if ( NT_SUCCESS( NtStatus ) ||
             ( NtStatus == STATUS_PIPE_CONNECTED ) ) {

            //
            //  Read an event handle from the pipe
            //
            NtStatus = NtReadFile(
                            NotificationPipeHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            ( PVOID )&EventHandle,
                            sizeof( HANDLE ),
                            NULL,
                            NULL
                            );

            if ( NtStatus == STATUS_PENDING ) {

                NtStatus = NtWaitForSingleObject(
                                NotificationPipeHandle,
                                FALSE,
                                NULL
                                );
            }


            //
            //  Signal the Event.
            //
            if ( NT_SUCCESS( NtStatus ) ) {

                ASSERT( IoStatusBlock.Information == sizeof( HANDLE ) );

                //
                //  Signal the event
                //
                //DbgPrint(" WINREG: Signaling handle %x\n", EventHandle );
                NtStatus = NtSetEvent( EventHandle, NULL );

#if DBG
                if ( !NT_SUCCESS( NtStatus ) ) {
                    DbgPrint( "WINREG: Cannot signal notification event 0x%x, status %x\n",
                                EventHandle, NtStatus );
                }
#endif
                ASSERT( NT_SUCCESS( NtStatus ) );

            } else if ( NtStatus != STATUS_PIPE_BROKEN ) {
#if DBG
                DbgPrint( "WINREG  (Notification handler) error reading pipe\n" );
                DbgPrint( "         status 0x%x\n", NtStatus );
#endif
                ASSERT( NT_SUCCESS( NtStatus ) );
            }

        } else if ( NtStatus != STATUS_PIPE_BROKEN &&
                    NtStatus != STATUS_PIPE_CLOSING) {
#if DBG
            DbgPrint( "WINREG (Notification): FsControlFile (Connect) status 0x%x\n",
                      NtStatus );
#endif
        }

        if ( NT_SUCCESS( NtStatus )             ||
             NtStatus == STATUS_PIPE_BROKEN     ||
             NtStatus == STATUS_PIPE_CLOSING    ||
             NtStatus == STATUS_PIPE_LISTENING  ||
             NtStatus == STATUS_PIPE_BUSY ) {

            //
            //  Disconnect
            //
            NtStatus = NtFsControlFile(
                                NotificationPipeHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_PIPE_DISCONNECT,
                                NULL,
                                0,
                                NULL,
                                0
                                );

            if ( NtStatus == STATUS_PENDING) {

                NtStatus = NtWaitForSingleObject(
                                NotificationPipeHandle,
                                FALSE,
                                NULL
                                );
            }

#if DBG
            if ( !NT_SUCCESS( NtStatus ) ) {
                DbgPrint( "WINREG (Notification): FsControlFile (Disconnect) status 0x%x\n",
                          NtStatus );
            }
#endif
            ASSERT( NT_SUCCESS( NtStatus ) );

        }
    }
}

#endif //  REMOTE_NOTIFICATION_DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regqkey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regqkey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    query key APIs.  That is:

        - RegQueryInfoKeyA
        - RegQueryInfoKeyW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regqkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"

LONG
RegQueryInfoKeyA (
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for querying information about a previously
    opened key.

--*/

{
    PUNICODE_STRING     Class;
    UNICODE_STRING      UnicodeString;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error;
    DWORD               cSubKeys;
    DWORD               cbMaxSubKeyLen;
    DWORD               cValues;
    DWORD               cbMaxValueNameLen;
    DWORD               cbMaxValueLen;
    FILETIME            ftLastWriteTime;
    HKEY                TempHandle = NULL;
    DWORD               cbMaxClassLen;
    DWORD               cbSecurityDescriptor;
    PDWORD              pCbMaxClassLen = NULL;
    PDWORD              pCbSecurityDescriptor = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpClass ) && ( ! ARGUMENT_PRESENT( lpcbClass )))) {
        return ERROR_INVALID_PARAMETER;
    }


    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    //  Make sure that the buffer size for lpClass is zero if lpClass is NULL
    //
    if( !ARGUMENT_PRESENT( lpClass ) && ARGUMENT_PRESENT( lpcbClass ) ) {
        *lpcbClass = 0;
    }

    if( ARGUMENT_PRESENT( lpcbMaxClassLen ) ) {
        pCbMaxClassLen = &cbMaxClassLen;
    }

    if( ARGUMENT_PRESENT( lpcbSecurityDescriptor ) ) {
        pCbSecurityDescriptor = &cbSecurityDescriptor;
    }

    //
    //  If the count of bytes in the class is 0, pass a NULL pointer
    //  instead of what was supplied.  This ensures that RPC won't
    //  attempt to copy data to a bogus pointer.  Note that in this
    //  case we use the unicode string allocated on the stack, because
    //  we must not change the Buffer or MaximumLength fields of the
    //  static unicode string in the TEB.
    //
    if ( !ARGUMENT_PRESENT( lpClass ) || *lpcbClass == 0 ) {

        Class = &UnicodeString;
        Class->Length           = 0;
        Class->MaximumLength    = 0;
        Class->Buffer           = NULL;

    } else {

        //
        // Use the static Unicode string in the TEB as a temporary for the
        // key's class.
        //
        Class = &NtCurrentTeb( )->StaticUnicodeString;
        ASSERT( Class != NULL );
        Class->Length = 0;
    }


    //
    // Call the Base API passing it a pointer to a counted Unicode string
    // for the class string.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegQueryInfoKey(
                                hKey,
                                Class,
                                &cSubKeys,
                                &cbMaxSubKeyLen,
                                pCbMaxClassLen,
                                &cValues,
                                &cbMaxValueNameLen,
                                &cbMaxValueLen,
                                pCbSecurityDescriptor,
                                &ftLastWriteTime
                                );
    } else {
        //
        // on RPC always send valid pointers!!!
        //
        pCbMaxClassLen = &cbMaxClassLen;
        pCbSecurityDescriptor = &cbSecurityDescriptor;

        Error = (LONG)BaseRegQueryInfoKey(
                                DereferenceRemoteHandle( hKey ),
                                Class,
                                &cSubKeys,
                                &cbMaxSubKeyLen,
                                pCbMaxClassLen,
                                &cValues,
                                &cbMaxValueNameLen,
                                &cbMaxValueLen,
                                pCbSecurityDescriptor,
                                &ftLastWriteTime
                                );
        if (Error == ERROR_SUCCESS) {
            DWORD dwVersion;

            //
            // Check for a downlevel Win95 server, which requires
            // us to work around their BaseRegQueryInfoKey bugs.
            // They do not account for Unicode correctly.
            //
            if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
                //
                // This is a Win95 server.
                // Double the maximum value name length and
                // maximum value data length to account for
                // the Unicode translation that Win95 forgot
                // to account for.
                //
                cbMaxValueNameLen *= sizeof(WCHAR);
                cbMaxValueLen *= sizeof(WCHAR);
            }
        }
    }

    //
    //  MaxSubKeyLen, MaxClassLen, and MaxValueNameLen should be in
    //  number of characters, without counting the NULL.
    //  Note that the server side will return the number of bytes,
    //  without counting the NUL
    //

    cbMaxSubKeyLen /= sizeof( WCHAR );
    if( pCbMaxClassLen != NULL ) {
        cbMaxClassLen  /= sizeof( WCHAR );
        ASSERT( *pCbMaxClassLen == cbMaxClassLen ); 
    }
    cbMaxValueNameLen /= sizeof( WCHAR );


    //
    //  Subtract the NULL from the Length. This was added on
    //  the server side so that RPC would transmit it.
    //
    if ( Class->Length > 0 ) {
        Class->Length -= sizeof( UNICODE_NULL );
    }

    //
    // If all the information was succesfully queried from the key
    // convert the class name to ANSI and update the class length value.
    //

    if( ( Error == ERROR_SUCCESS ) &&
        ARGUMENT_PRESENT( lpClass ) && ( *lpcbClass != 0 ) ) {

        if (*lpcbClass > (DWORD)0xFFFF) {
            AnsiString.MaximumLength    = ( USHORT ) 0xFFFF;
        } else {
            AnsiString.MaximumLength    = ( USHORT ) *lpcbClass;
        }

        AnsiString.Buffer           = lpClass;

        Status = RtlUnicodeStringToAnsiString(
                    &AnsiString,
                    Class,
                    FALSE
                    );
        ASSERTMSG( "Unicode->ANSI conversion of Class ",
                    NT_SUCCESS( Status ));

        //
        // Update the class length return parameter.
        //

        *lpcbClass = AnsiString.Length;

        Error = RtlNtStatusToDosError( Status );

    } else {

        //
        // Not all of the information was succesfully queried, or Class
        // doesn't have to be converted from UNICODE to ANSI
        //

        if( ARGUMENT_PRESENT( lpcbClass ) ) {
            if( Class->Length == 0 ) {

                *lpcbClass = 0;

            } else {

                *lpcbClass = ( Class->Length >> 1 );
            }
        }
    }

    if( ARGUMENT_PRESENT( lpcSubKeys ) ) {
        *lpcSubKeys = cSubKeys;
    }
    if( ARGUMENT_PRESENT( lpcbMaxSubKeyLen ) ) {
        *lpcbMaxSubKeyLen = cbMaxSubKeyLen;
    }
    if( ARGUMENT_PRESENT( lpcbMaxClassLen ) ) {
        *lpcbMaxClassLen = cbMaxClassLen;
        ASSERT( *pCbMaxClassLen == cbMaxClassLen );
    }
    if( ARGUMENT_PRESENT( lpcValues ) ) {
        *lpcValues = cValues;
    }
    if( ARGUMENT_PRESENT( lpcbMaxValueNameLen ) ) {
        *lpcbMaxValueNameLen = cbMaxValueNameLen;
    }
    if( ARGUMENT_PRESENT( lpcbMaxValueLen ) ) {
        *lpcbMaxValueLen = cbMaxValueLen;
    }
    if( ARGUMENT_PRESENT( lpcbSecurityDescriptor ) ) {
        *lpcbSecurityDescriptor = cbSecurityDescriptor;
        ASSERT( *pCbSecurityDescriptor == cbSecurityDescriptor );
    }
    if( ARGUMENT_PRESENT( lpftLastWriteTime ) ) {
        *lpftLastWriteTime = ftLastWriteTime;
    }

ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
RegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for querying information about a previously
    opened key.

--*/

{
    UNICODE_STRING  Class;
    LONG            Error;

    DWORD           cbClass;
    DWORD           cSubKeys;
    DWORD           cbMaxSubKeyLen;
    DWORD           cValues;
    DWORD           cbMaxValueNameLen;
    DWORD           cbMaxValueLen;
    FILETIME        ftLastWriteTime;
    HKEY            TempHandle = NULL;
    DWORD           cbMaxClassLen;
    DWORD           cbSecurityDescriptor;
    PDWORD          pCbMaxClassLen = NULL;
    PDWORD          pCbSecurityDescriptor = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpClass ) && ( ! ARGUMENT_PRESENT( lpcbClass )))) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    //  Make sure that the buffer size for lpClass is zero if lpClass is NULL
    //
    if( !ARGUMENT_PRESENT( lpClass ) && ARGUMENT_PRESENT( lpcbClass ) ) {
        *lpcbClass = 0;
    }

    if( ARGUMENT_PRESENT( lpcbMaxClassLen ) ) {
        pCbMaxClassLen = &cbMaxClassLen;
    }

    if( ARGUMENT_PRESENT( lpcbSecurityDescriptor ) ) {
        pCbSecurityDescriptor = &cbSecurityDescriptor;
    }

    //
    // Use the supplied class Class buffer as the buffer in a counted
    // Unicode Class.
    //
    Class.Length = 0;
    if( ARGUMENT_PRESENT( lpcbClass ) && ( *lpcbClass != 0 ) ) {

        Class.MaximumLength = ( USHORT )( *lpcbClass << 1 );
        Class.Buffer        = lpClass;

    } else {

        //
        // If the count of bytes in the class is 0, pass a NULL pointer
        // instead of what was supplied.  This ensures that RPC won't
        // attempt to copy data to a bogus pointer.
        //
        Class.MaximumLength = 0;
        Class.Buffer        = NULL;
    }

    //
    // Call the Base API.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegQueryInfoKey(
                                hKey,
                                &Class,
                                &cSubKeys,
                                &cbMaxSubKeyLen,
                                pCbMaxClassLen,
                                &cValues,
                                &cbMaxValueNameLen,
                                &cbMaxValueLen,
                                pCbSecurityDescriptor,
                                &ftLastWriteTime
                                );
    } else {
        //
        // on RPC always send valid pointers!!!
        //
        pCbMaxClassLen = &cbMaxClassLen;
        pCbSecurityDescriptor = &cbSecurityDescriptor;

        Error = (LONG)BaseRegQueryInfoKey(
                                DereferenceRemoteHandle( hKey ),
                                &Class,
                                &cSubKeys,
                                &cbMaxSubKeyLen,
                                pCbMaxClassLen,
                                &cValues,
                                &cbMaxValueNameLen,
                                &cbMaxValueLen,
                                pCbSecurityDescriptor,
                                &ftLastWriteTime
                                );
        if (Error == ERROR_SUCCESS) {
            DWORD dwVersion;
            //
            // Check for a downlevel Win95 server, which requires
            // us to work around their BaseRegQueryInfoKey bugs.
            // They do not account for Unicode correctly.
            //
            if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
                //
                // This is a Win95 server.
                // Double the maximum value name length and
                // maximum value data length to account for
                // the Unicode translation that Win95 forgot
                // to account for.
                //
                cbMaxValueNameLen *= sizeof(WCHAR);
                cbMaxValueLen *= sizeof(WCHAR);
            }
        }
    }

    //
    //  MaxSubKeyLen, MaxClassLen, and MaxValueNameLen should be in
    //  number of characters, without counting the NULL.
    //  Note that the server side will return the number of bytes,
    //  without counting the NUL
    //

    cbMaxSubKeyLen /= sizeof( WCHAR );
    if( pCbMaxClassLen != NULL ) {
        cbMaxClassLen  /= sizeof( WCHAR );
        ASSERT( *pCbMaxClassLen == cbMaxClassLen ); 
    }
    cbMaxValueNameLen /= sizeof( WCHAR );


    if( ARGUMENT_PRESENT( lpcbClass ) ) {
        if( Class.Length == 0 ) {
            *lpcbClass = 0;
        } else {
            *lpcbClass = ( Class.Length >> 1 ) - 1;
        }
    }

    if( ARGUMENT_PRESENT( lpcSubKeys ) ) {
        *lpcSubKeys = cSubKeys;
    }
    if( ARGUMENT_PRESENT( lpcbMaxSubKeyLen ) ) {
        *lpcbMaxSubKeyLen = cbMaxSubKeyLen;
    }
    if( ARGUMENT_PRESENT( lpcbMaxClassLen ) ) {
        *lpcbMaxClassLen = cbMaxClassLen;
        ASSERT( *pCbMaxClassLen == cbMaxClassLen ); 
    }
    if( ARGUMENT_PRESENT( lpcValues ) ) {
        *lpcValues = cValues;
    }
    if( ARGUMENT_PRESENT( lpcbMaxValueNameLen ) ) {
        *lpcbMaxValueNameLen = cbMaxValueNameLen;
    }
    if( ARGUMENT_PRESENT( lpcbMaxValueLen ) ) {
        *lpcbMaxValueLen = cbMaxValueLen;
    }
    if( ARGUMENT_PRESENT( lpcbSecurityDescriptor ) ) {
        *lpcbSecurityDescriptor = cbSecurityDescriptor;
        ASSERT( *pCbSecurityDescriptor == cbSecurityDescriptor );
    }
    if( ARGUMENT_PRESENT( lpftLastWriteTime ) ) {
        *lpftLastWriteTime = ftLastWriteTime;
    }

ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regsckey.c ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsckey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to set and get the SECURITY_DESCRIPTOR for a key.  That is:

        - RegGetKeySecurity
        - RegSetKeySecurity

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regsckey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <wow64reg.h>

NTSTATUS BaseRegGetUserAndMachineClass(
    PVOID          pKeySemantics,
    HKEY           hKey,
    REGSAM         samDesired,
    PHKEY          phkMachine,
    PHKEY          phkUser);


LONG
APIENTRY
RegGetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    )

/*++

Routine Description:

    Win32 RPC wrapper for getting a key's security descriptor.

--*/

{
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    LONG                        Error;
    REGSAM                      DesiredAccess;
    HKEY                        hkSpecialHandle = NULL;

    HKEY                        hkMachineClass;
    HKEY                        hkUserClass;
    HKEY                        hkClassKey = NULL;

    BOOL                        fClassesRoot = FALSE;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    if (HKEY_CLASSES_ROOT == hKey) {
        fClassesRoot = TRUE;
    }

    if( IsPredefinedRegistryHandle( hKey ) &&
        ( ( RequestedInformation & SACL_SECURITY_INFORMATION ) != 0 )
      ) {
        //
        //  If SACL is to be retrieved, open a handle with special access
        //
        DesiredAccess = ACCESS_SYSTEM_SECURITY;
        if( ( RequestedInformation &
              ( DACL_SECURITY_INFORMATION |
                OWNER_SECURITY_INFORMATION |
                GROUP_SECURITY_INFORMATION
              ) ) != 0 ) {
            DesiredAccess |= READ_CONTROL;
        }

        Error = OpenPredefinedKeyForSpecialAccess( hKey,
                                                   DesiredAccess,
                                                   &hKey );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }
        ASSERT( IsLocalHandle( hKey ) );
        hkSpecialHandle = hKey;

    } else {
        hKey = MapPredefinedHandle( hKey, &TempHandle );

        DesiredAccess = MAXIMUM_ALLOWED;
    }

    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    if (IsLocalHandle( hKey )) {

        NTSTATUS Status;

        if (IsSpecialClassesHandle( hKey ) || fClassesRoot) {

            Status = BaseRegGetUserAndMachineClass(
                NULL,
                hKey,
                DesiredAccess,
                &hkMachineClass,
                &hkUserClass);

            if (!NT_SUCCESS(Status)) {
                Error = (error_status_t) RtlNtStatusToDosError(Status);
                goto ExitCleanup;
            }

            if (hkMachineClass && hkUserClass) {

                if (hkMachineClass != hKey) {
                    hkClassKey = hkMachineClass;
                } else {
                    hkClassKey = hkUserClass;
                }

                if (fClassesRoot) {
                    hKey = hkMachineClass;
                } else {
                    hKey = hkUserClass;
                }
            }
        }
    }

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor    = pSecurityDescriptor;
    RpcSD.cbInSecurityDescriptor  = *lpcbSecurityDescriptor;
    RpcSD.cbOutSecurityDescriptor = 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegGetKeySecurity(
                                hKey,
                                RequestedInformation,
                                &RpcSD
                                );
    } else {

        Error = (LONG)BaseRegGetKeySecurity(
                                DereferenceRemoteHandle( hKey ),
                                RequestedInformation,
                                &RpcSD
                                );
    }

    //
    // Extract the size of the SECURITY_DESCRIPTOR from the RPCable version.
    //

    *lpcbSecurityDescriptor = RpcSD.cbInSecurityDescriptor;

    if (hkClassKey) {
        NtClose(hkClassKey);
    }

ExitCleanup:
    if(hkSpecialHandle) {
        RegCloseKey(hkSpecialHandle);
    }
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;

}

LONG
APIENTRY
RegSetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    Win32 RPC wrapper for setting a key's security descriptor.

--*/

{
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    LONG                        Error;
    REGSAM                      DesiredAccess;

    HKEY                        hkSpecialHandle = NULL;
    HKEY                        hkMachineClass;
    HKEY                        hkUserClass;
    HKEY                        hkClassKey = NULL;

    BOOL                        fClassesRoot = FALSE;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    if (HKEY_CLASSES_ROOT == hKey) {
        fClassesRoot = TRUE;
    }

    if( IsPredefinedRegistryHandle( hKey ) &&
        ( ( SecurityInformation & SACL_SECURITY_INFORMATION ) != 0 )
      ) {
        //
        //  If the SACL is to be set, open a handle with
        //  special access
        //
        DesiredAccess = MAXIMUM_ALLOWED | ACCESS_SYSTEM_SECURITY;
        if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            DesiredAccess |= WRITE_DAC;
        } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            DesiredAccess |= WRITE_OWNER;
        }

        Error = OpenPredefinedKeyForSpecialAccess( hKey,
                                                   DesiredAccess,
                                                   &hKey );
        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }
        ASSERT( IsLocalHandle( hKey ) );
        hkSpecialHandle = hKey;

    } else {
        hKey = MapPredefinedHandle( hKey, &TempHandle );

        DesiredAccess = MAXIMUM_ALLOWED;
    }

    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    if (IsLocalHandle( hKey )) {

        NTSTATUS Status;

        if (IsSpecialClassesHandle( hKey ) || fClassesRoot) {

            Status = BaseRegGetUserAndMachineClass(
                NULL,
                hKey,
                DesiredAccess,
                &hkMachineClass,
                &hkUserClass);

            if (!NT_SUCCESS(Status)) {
                Error = (error_status_t) RtlNtStatusToDosError(Status);
                goto ExitCleanup;
            }

            if (hkMachineClass && hkUserClass) {

                if (hkMachineClass != hKey) {
                    hkClassKey = hkMachineClass;
                } else {
                    hkClassKey = hkUserClass;
                }

                if (fClassesRoot) {
                    hKey = hkMachineClass;
                } else {
                    hKey = hkUserClass;
                }
            }
        }
    }

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor = NULL;

    Error = MapSDToRpcSD(
        pSecurityDescriptor,
        &RpcSD
        );


    if( Error != ERROR_SUCCESS ) {
        goto ExitCleanup;
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSetKeySecurity (
                            hKey,
                            SecurityInformation,
                            &RpcSD
                            );
#if defined(_WIN64)
            if ( Error == 0)
                Wow64RegSetKeyDirty (hKey);
#endif

    } else {

        Error = (LONG)BaseRegSetKeySecurity (
                            DereferenceRemoteHandle( hKey ),
                            SecurityInformation,
                            &RpcSD
                            );
    }

    //
    // Free the buffer allocated by MapSDToRpcSD.
    //

    RtlFreeHeap(
        RtlProcessHeap( ), 0,
        RpcSD.lpSecurityDescriptor
        );

    if (hkClassKey) {
        NtClose(hkClassKey);
    }

ExitCleanup:
    if(hkSpecialHandle) {
        RegCloseKey(hkSpecialHandle);
    }
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regqval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regqval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    query value APIs.  That is:

        - RegQueryValueA
        - RegQueryValueW
        - RegQueryValueExA
        - RegQueryValueExW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regqval.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"

LONG
RegQueryValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpData,
    PLONG lpcbData
    )

/*++

Routine Description:


    Win 3.1 ANSI RPC wrapper for querying a value.

--*/

{
    HKEY            ChildKey;
    LONG            Error;
    DWORD           ValueType;
    LONG            InitialCbData;
    HKEY            TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // If the sub-key is NULL or points to an empty string then the value is
    // to be queried from this key (i.e.  hKey) otherwise the sub-key needs
    // to be opened.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        ChildKey = hKey;

    } else {

        //
        // The sub-key was supplied so impersonate the
        // client and attempt to open it.
        //

        Error = RegOpenKeyExA(
                    hKey,
                    lpSubKey,
                    0,
                    KEY_QUERY_VALUE,
                    &ChildKey
                    );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }
    }

    InitialCbData = ARGUMENT_PRESENT(lpcbData) ? (*lpcbData) : 0;

    //
    // ChildKey contains an HKEY which may be the one supplied (hKey) or
    // returned from RegOpenKeyExA. Query the value using the special value
    // name NULL.
    //

    Error = RegQueryValueExA(
                ChildKey,
                NULL,
                NULL,
                &ValueType,
                lpData,
                lpcbData
                );
    //
    // If the sub key was opened, close it.
    //

    if( ChildKey != hKey ) {

        if( IsLocalHandle( ChildKey )) {

            LocalBaseRegCloseKey( &ChildKey );

        } else {

            ChildKey = DereferenceRemoteHandle( ChildKey );
            BaseRegCloseKey( &ChildKey );
        }
    }

    //
    // If the type of the value is not a null terminate string, then return
    // an error. (Win 3.1 compatibility)
    //

    if (!Error && ((ValueType != REG_SZ) && (ValueType != REG_EXPAND_SZ))) {
        Error = ERROR_INVALID_DATA;
    }

    //
    // If value doesn't exist, return ERROR_SUCCESS and an empty string.
    // (Win 3.1 compatibility)
    //
    if( Error == ERROR_FILE_NOT_FOUND ) {
        if( ARGUMENT_PRESENT( lpcbData ) ) {
            *lpcbData = sizeof( CHAR );
        }
        if( ARGUMENT_PRESENT( lpData ) ) {
            *lpData = '\0';
        }
        Error = ERROR_SUCCESS;
    }

    //
    // Expand if necessary (VB compatibility)
    //

    if (!Error && (ValueType == REG_EXPAND_SZ)) {
        if ( (!ARGUMENT_PRESENT(lpcbData)) || (!ARGUMENT_PRESENT(lpData)) ) {
            Error = ERROR_INVALID_DATA;
        } else {
            LPSTR ExpandBuffer;
            LONG ExpandedSize;
            LONG BufferSize = (InitialCbData>*lpcbData)?InitialCbData:*lpcbData;
            //
            // if InitialCbData was 0, allocate a buffer of the real size
            //
            ExpandBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, BufferSize);
            if (ExpandBuffer == NULL) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                RtlCopyMemory(ExpandBuffer, lpData, *lpcbData);
                ExpandedSize = ExpandEnvironmentStringsA(ExpandBuffer, lpData, BufferSize);
                if (ExpandedSize > InitialCbData) {
                    Error = ERROR_MORE_DATA;
                }
                *lpcbData = ExpandedSize;
                RtlFreeHeap( RtlProcessHeap(), 0, ExpandBuffer );
            }
        }
    }

    //
    // Return the results of querying the value.
    //

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
RegQueryValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpData,
    PLONG  lpcbData
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for querying a value.

--*/

{
    HKEY        ChildKey;
    LONG        Error;
    DWORD       ValueType;
    LONG            InitialCbData;
    HKEY            TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    //
    // If the sub-key is NULL or points to an empty string then the value is
    // to be queried from this key (i.e.  hKey) otherwise the sub-key needs
    // to be opened.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        ChildKey = hKey;

    } else {

        //
        // The sub-key was supplied so attempt to open it.
        //

        Error = RegOpenKeyExW(
                    hKey,
                    lpSubKey,
                    0,
                    KEY_QUERY_VALUE,
                    &ChildKey
                    );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }
    }

    InitialCbData = ARGUMENT_PRESENT(lpcbData) ? (*lpcbData) : 0;

    //
    // ChildKey contains an HKEY which may be the one supplied (hKey) or
    // returned from RegOpenKeyExA. Query the value using the special value
    // name NULL.
    //

    Error = RegQueryValueExW(
                ChildKey,
                NULL,
                NULL,
                &ValueType,
                ( LPBYTE )lpData,
                lpcbData
                );
    //
    // If the sub key was opened, close it.
    //

    if( ChildKey != hKey ) {

        if( IsLocalHandle( ChildKey )) {

            LocalBaseRegCloseKey( &ChildKey );

        } else {

            ChildKey = DereferenceRemoteHandle( ChildKey );
            BaseRegCloseKey( &ChildKey );
        }
    }

    //
    // If the type of the value is not a null terminate string, then return
    // an error. (Win 3.1 compatibility)
    //

    if (!Error && ((ValueType != REG_SZ) && (ValueType != REG_EXPAND_SZ))) {
        Error = ERROR_INVALID_DATA;
    }

    //
    // If value doesn't exist, return ERROR_SUCCESS and an empty string.
    // (Win 3.1 compatibility)
    //
    if( Error == ERROR_FILE_NOT_FOUND ) {
        if( ARGUMENT_PRESENT( lpcbData ) ) {
            *lpcbData = sizeof( WCHAR );
        }
        if( ARGUMENT_PRESENT( lpData ) ) {
            *lpData = ( WCHAR )'\0';
        }
        Error = ERROR_SUCCESS;
    }

    //
    // Expand if necessary (VB compatibility)
    //

    if (!Error && (ValueType == REG_EXPAND_SZ)) {
        if ( (!ARGUMENT_PRESENT(lpcbData)) || (!ARGUMENT_PRESENT(lpData)) ) {
            Error = ERROR_INVALID_DATA;
        } else {
            LPWSTR ExpandBuffer;
            LONG ExpandedSize;
            LONG BufferSize = (InitialCbData>*lpcbData)?InitialCbData:*lpcbData;
            //
            // if InitialCbData was 0, allocate a buffer of the real size
            //
            ExpandBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, BufferSize);
            if (ExpandBuffer == NULL) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                RtlCopyMemory(ExpandBuffer, lpData, *lpcbData);
                ExpandedSize = ExpandEnvironmentStringsW(ExpandBuffer, lpData, BufferSize / sizeof(WCHAR));
                if (ExpandedSize > (LONG)(InitialCbData / sizeof(WCHAR))) {
                    Error = ERROR_MORE_DATA;
                }
                *lpcbData = ExpandedSize;
                RtlFreeHeap( RtlProcessHeap(), 0, ExpandBuffer );
            }
        }
    }

    //
    // Return the results of querying the value.
    //

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}


LONG
APIENTRY
RegQueryValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for querying a value.

    RegQueryValueExA converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegQueryValue.

--*/

{
    PUNICODE_STRING     ValueName;
    UNICODE_STRING      StubValueName;
    DWORD               ValueType;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error;
    DWORD               ValueLength;
    DWORD               InputLength;
    PWSTR               UnicodeValueBuffer;
    ULONG               UnicodeValueLength;

    PSTR                AnsiValueBuffer;
    ULONG               AnsiValueLength;
    ULONG               Index;
    ULONG               cbAnsi = 0;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Validate dependency between lpData and lpcbData parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpData ) && ( ! ARGUMENT_PRESENT( lpcbData )))) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode string using the static
    // Unicode string in the TEB.
    //

    StubValueName.Buffer = NULL;
    ValueName = &NtCurrentTeb( )->StaticUnicodeString;
    ASSERT( ValueName != NULL );
    RtlInitAnsiString( &AnsiString, lpValueName );
    Status = RtlAnsiStringToUnicodeString(
                ValueName,
                &AnsiString,
                FALSE
                );

    if( ! NT_SUCCESS( Status )) {
        //
        // The StaticUnicodeString is not long enough; Try to allocate a bigger one
        //
        Status = RtlAnsiStringToUnicodeString(
                    &StubValueName,
                    &AnsiString,
                    TRUE
                    );
        if( ! NT_SUCCESS( Status )) {
            Error = RtlNtStatusToDosError( Status );
            goto ExitCleanup;
        }

        ValueName = &StubValueName;
    }

    //
    //  Add the terminating NULL to the Length so that RPC transmits
    //  it.
    //

    ValueName->Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings. Note that zero bytes are transmitted (i.e.
    // InputLength = 0) for the data.
    //

    ValueLength = ARGUMENT_PRESENT( lpcbData )? *lpcbData : 0;
    InputLength = 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegQueryValue (
                             hKey,
                             ValueName,
                             &ValueType,
                             lpData,
                             &ValueLength,
                             &InputLength
                             );
        //
        //  Make sure that the local side didn't destroy the Buffer in
        //  the StaticUnicodeString
        //
        ASSERT( ValueName->Buffer );


    } else {

        Error = (LONG)BaseRegQueryValue (
                             DereferenceRemoteHandle( hKey ),
                             ValueName,
                             &ValueType,
                             lpData,
                             &ValueLength,
                             &InputLength
                             );
    }

    //
    // If no error or callers buffer too small, and type is one of the null
    // terminated string types, then do the UNICODE to ANSI translation.
    // We handle the buffer too small case, because the callers buffer may
    // be big enough for the ANSI representation, but not the UNICODE one.
    // In this case, we need to allocate a buffer big enough, do the query
    // again and then the translation into the callers buffer.  We only do
    // this if the caller actually wants the value data (lpData != NULL)
    //

    if ((Error == ERROR_SUCCESS || Error == ERROR_MORE_DATA) &&
        (ARGUMENT_PRESENT( lpData ) || ARGUMENT_PRESENT( lpcbData ))&&
        (ValueType == REG_SZ ||
         ValueType == REG_EXPAND_SZ ||
         ValueType == REG_MULTI_SZ)
		 ) {
		UnicodeValueLength         = ValueLength;


		AnsiValueBuffer            = lpData;
		AnsiValueLength            = ARGUMENT_PRESENT( lpcbData )?
													 *lpcbData : 0;

		//
		// Allocate a buffer for the UNICODE value and reissue the query.
		//

		UnicodeValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
											  UnicodeValueLength
											 );
		if (UnicodeValueBuffer == NULL) {
			Error = ERROR_NOT_ENOUGH_MEMORY;
		} else {
			InputLength = 0;

			if( IsLocalHandle( hKey )) {

				//
				//  Add the terminating NULL to the Length
				//  (remember that in the local case, ValueName->Length
				//  was decremented by sizeof( UNICODE_NULL ) in the first
				//  call to LocalBaseRegQueryValue).
				//  This won't happen in the remote case, since the
				//  server side will decrement ValueName->Length on
				//  the transmitted structure (a copy of ValueName), and
				//  the new Valuename->Length won't be transmitted back to
				//  the client.
				//

				ValueName->Length += sizeof( UNICODE_NULL );


				Error = (LONG)LocalBaseRegQueryValue (
									 hKey,
									 ValueName,
									 &ValueType,
									 (LPBYTE)UnicodeValueBuffer,
									 &ValueLength,
									 &InputLength
									 );
				//
				//  Make sure that the local side didn't destroy the
				//  Buffer in the StaticUnicodeString
				//

				ASSERT(ValueName->Buffer);


			} else {

				Error = (LONG)BaseRegQueryValue (
									 DereferenceRemoteHandle( hKey ),
									 ValueName,
									 &ValueType,
									 (LPBYTE)UnicodeValueBuffer,
									 &ValueLength,
									 &InputLength
									 );
			}
            if( Error == ERROR_SUCCESS ) {
                // Compute needed buffer size , cbAnsi will keeps the byte
			    // counts to keep MBCS string after following step.

			    RtlUnicodeToMultiByteSize( &cbAnsi ,
									       UnicodeValueBuffer ,
									       ValueLength );

			    // If we could not store all MBCS string to buffer that
			    // Apps gives me.  We set ERROR_MORE_DATA to Error

			    if( ARGUMENT_PRESENT( lpcbData ) ) {
				    if( cbAnsi > *lpcbData && lpData != NULL ) {
					    Error = ERROR_MORE_DATA;
				    }
			    }
            } else {
                // to be used below
                cbAnsi = ValueLength;
            }
		}

		if ((Error == ERROR_SUCCESS) && (AnsiValueBuffer != NULL) ) {
			//
			// We have a UNICODE value, so translate it to ANSI in the callers
			// buffer.  In the case where the caller's buffer was big enough
			// for the UNICODE version, we do the conversion in place, which
			// works since the ANSI version is smaller than the UNICODE version.
			//


			Index = 0;
			Status = RtlUnicodeToMultiByteN( AnsiValueBuffer,
											 AnsiValueLength,
											 &Index,
											 UnicodeValueBuffer,
											 UnicodeValueLength
											);
			if (!NT_SUCCESS( Status )) {
				Error = RtlNtStatusToDosError( Status );
			}

			// Now Index keeps Byte counts of MBCS string in AnsiValueBuffer
			cbAnsi = Index;
		}

		//
		// Free the buffer if it was successfully allocated
		//
		if (UnicodeValueBuffer != NULL) {
			RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValueBuffer );
		}

		//
		// Return the length of the ANSI version to the caller.
		//
		ValueLength = cbAnsi;

		//
		// Special hack to help out all the people who
		// believe the length of a NULL terminated string is
		// strlen(foo) instead of strlen(foo) + 1.
		// If the last character of the buffer is not a NULL
		// and there is enough space left in the caller's buffer,
		// slap a NULL in there to prevent him from going nuts
		// trying to do a strlen().
		//
		if (ARGUMENT_PRESENT( lpData ) &&
			(*lpcbData > ValueLength)  &&
            (ValueLength > 0) &&
			(lpData[ValueLength-1] != '\0')) {

			lpData[ValueLength] = '\0';
		}
    }

    //
    // Stored the returned length in the caller specified location and
    // return the error code.
    //

    if (lpdwType != NULL) {
        *lpdwType = ValueType;
    }

    if( ARGUMENT_PRESENT( lpcbData ) ) {
        *lpcbData = ValueLength;
    }

    //
    // Free the temporary Unicode string stub allocated for the ValueName
    //
    RtlFreeUnicodeString(&StubValueName);

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}


LONG
APIENTRY
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for querying a value.

    RegQueryValueExW converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegQueryValue.

--*/

{
    UNICODE_STRING      ValueName;
    DWORD               InputLength;
    DWORD               ValueLength;
    DWORD               ValueType;
    LONG                Error;
    UNALIGNED WCHAR     *String;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Validate dependency between lpData and lpcbData parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpData ) && ( ! ARGUMENT_PRESENT( lpcbData )))) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    //
    //  Add the terminating NULL to the Length so that RPC transmits
    //  it.
    //

    ValueName.Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings. Note that zero bytes are transmitted (i.e.
    // InputLength = 0) for the data.
    //
    InputLength = 0;
    ValueLength = ( ARGUMENT_PRESENT( lpcbData ) )? *lpcbData : 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegQueryValue (
                            hKey,
                            &ValueName,
                            &ValueType,
                            lpData,
                            &ValueLength,
                            &InputLength
                            );
    } else {

        Error =  (LONG)BaseRegQueryValue (
                            DereferenceRemoteHandle( hKey ),
                            &ValueName,
                            &ValueType,
                            lpData,
                            &ValueLength,
                            &InputLength
                            );
    }
    //
    // Special hack to help out all the people who
    // believe the length of a NULL terminated string is
    // strlen(foo) instead of strlen(foo) + 1.
    // If the last character of the buffer is not a NULL
    // and there is enough space left in the caller's buffer,
    // slap a NULL in there to prevent him from going nuts
    // trying to do a strlen().
    //
    if ( (Error == ERROR_SUCCESS) &&
         ARGUMENT_PRESENT( lpData ) &&
         ( (ValueType == REG_SZ) ||
           (ValueType == REG_EXPAND_SZ) ||
           (ValueType==REG_MULTI_SZ)) &&
         ( ValueLength > sizeof(WCHAR))) {

        UNALIGNED WCHAR *String = (UNALIGNED WCHAR *)lpData;
        DWORD Length = ValueLength/sizeof(WCHAR);

        if ((String[Length-1] != UNICODE_NULL) &&
            (ValueLength+sizeof(WCHAR) <= *lpcbData)) {
            String[Length] = UNICODE_NULL;
        }
    }
    if( ARGUMENT_PRESENT( lpcbData ) ) {
        *lpcbData = ValueLength;
    }
    if ( ARGUMENT_PRESENT( lpdwType )) {
        *lpdwType = ValueType;
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regsval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    set value APIs. That is:

        - RegSetValueA
        - RegSetValueW
        - RegSetValueExA
        - RegSetValueExW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regsval.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <string.h>
#include <wow64reg.h>


LONG
RegSetValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Win 3.1 ANSI RPC wrapper for setting a value.

--*/

{
    HKEY        ChildKey;
    LONG        Error;
    HKEY        TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Check the value type for compatability w/Win 3.1
    //

    if( dwType != REG_SZ ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Win3.1ism - Win 3.1 ignores the cbData parameter so it is computed
    // here instead as the length of the string plus the NUL character.
    //

    cbData = strlen( lpData ) + 1;


    //
    // If the sub-key is NULL or points to an empty string then the value is
    // set in this key (i.e.  hKey) otherwise the sub-key needs to be
    // opened/created.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        ChildKey = hKey;

    } else {

        //
        // The sub-key was supplied so attempt to open/create it.
        //

        Error = RegCreateKeyExA(
                    hKey,
                    lpSubKey,
                    0,
                    WIN31_CLASS,
                    0,
                    KEY_SET_VALUE,
                    NULL,
                    &ChildKey,
                    NULL
                    );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }
    }

    //
    // ChildKey contains an HKEY which may be the one supplied (hKey) or
    // returned from RegCreateKeyA. Set the value using the special value
    // name NULL.
    //

    Error = RegSetValueExA(
                ChildKey,
                NULL,
                0,
                dwType,
                lpData,
                cbData
                );

    //
    // If the sub key was opened, close it.
    //

    if( ChildKey != hKey ) {

        Error = RegCloseKey( ChildKey );
        ASSERT( Error == ERROR_SUCCESS );
    }

    //
    // Return the results of setting the value.
    //

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
RegSetValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for setting a value.

--*/

{
    HKEY        ChildKey;
    LONG        Error;
    HKEY        TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Check the value type for compatability w/Win 3.1
    //

    if( dwType != REG_SZ ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle);
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Win3.1ism - Win 3.1 ignores the cbData parameter so it is computed
    // here instead as the length of the string plus the UNICODE_NUL
    // character.
    //

    cbData = wcslen( lpData ) * sizeof( WCHAR ) + sizeof( UNICODE_NULL );;

    //
    // If the sub-key is NULL or points to an empty string then the value is
    // set in this key (i.e.  hKey) otherwise the sub-key needs to be
    // opened/created.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        ChildKey = hKey;

    } else {

        //
        // The sub-key was supplied attempt to open/create it.
        //

        Error = RegCreateKeyExW(
                    hKey,
                    lpSubKey,
                    0,
                    WIN31_CLASS,
                    0,
                    KEY_SET_VALUE,
                    NULL,
                    &ChildKey,
                    NULL
                    );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }
    }

    //
    // ChildKey contains an HKEY which may be the one supplied (hKey) or
    // returned from RegCreateKeyW. Set the value using the special value
    // name NULL.
    //

    Error = RegSetValueExW(
                ChildKey,
                NULL,
                0,
                dwType,
                ( LPBYTE ) lpData,
                cbData
                );

    //
    // If the sub key was opened/created, close it.
    //

    if( ChildKey != hKey ) {

        RegCloseKey( ChildKey );
    }

    //
    // Return the results of querying the value.
    //

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSetValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for setting a value.

    RegSetValueExA converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegSetValue.

--*/

{
    PUNICODE_STRING     ValueName;
    UNICODE_STRING      TempValueName;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    LPBYTE              ValueData;

    PSTR                AnsiValueBuffer;
    ULONG               AnsiValueLength;
    PWSTR               UnicodeValueBuffer;
    ULONG               UnicodeValueLength;
    ULONG               Index;

    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Ensure Reserved is zero to avoid future compatability problems.
    //

    if( Reserved != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode string 
    //
    if ( lpValueName ) {

        //
        // Convert the SubKey name to a counted Unicode 
        //
        if( !RtlCreateUnicodeStringFromAsciiz(&TempValueName,lpValueName) ) {
            Status = STATUS_NO_MEMORY;
            Error = RtlNtStatusToDosError( Status );
            goto ExitCleanup;
        }

        ValueName = &TempValueName;

        //
        //  Add the NULL to the Length, so that RPC will transmit it
        //
        ValueName->Length += sizeof( UNICODE_NULL );

        if( ValueName->Length == 0 ) {
            //
            // overflow in RtlCreateUnicodeStringFromAsciiz
            //
            Error = ERROR_INVALID_PARAMETER;
            goto ExitCleanup;
        }
    } else {

        //
        //  No name was passed. Use our internal UNICODE string
        //  and set its fields to NULL. We don't use the static
        //  unicode string in the TEB in this case because we
        //  can't mess with its Buffer and MaximumLength fields.
        //
        ValueName = &UnicodeString;
        ValueName->Length           = 0;
        ValueName->MaximumLength    = 0;
        ValueName->Buffer           = NULL;
    }

    //
    // If type is one of the null terminated string types, then do the ANSI to
    // UNICODE translation into an allocated buffer.
    //
    ValueData = ( LPBYTE )lpData;
    if (dwType == REG_SZ || dwType == REG_EXPAND_SZ || dwType == REG_MULTI_SZ) {

        //
        // Special hack to help out all the people who
        // believe the length of a NULL terminated string is
        // strlen(foo) instead of strlen(foo) + 1.
        //
        if ((cbData > 0) &&
            (lpData[cbData-1] != 0)) {
            //
            // Do this under an exception handler in case the last
            // little bit crosses a page boundary.
            //
            try {
                if (lpData[cbData] == 0) {
                    cbData += 1;        // increase string length to account for NULL terminator
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                ; // guess they really really did not want a NULL terminator

            }
        }
        AnsiValueBuffer        = ValueData;
        AnsiValueLength        = cbData;

        UnicodeValueLength = cbData * sizeof( WCHAR );
        UnicodeValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                              UnicodeValueLength
                                            );
        if (UnicodeValueBuffer == NULL) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            Status = RtlMultiByteToUnicodeN( UnicodeValueBuffer,
                                             UnicodeValueLength,
                                             &Index,
                                             AnsiValueBuffer,
                                             AnsiValueLength
                                           );
            if (!NT_SUCCESS( Status )) {
                Error = RtlNtStatusToDosError( Status );
            } else {
                ValueData   = (LPBYTE)UnicodeValueBuffer;
                cbData      = Index;
                Error       = ERROR_SUCCESS;
            }
        }
    } else {
        Error = ERROR_SUCCESS;
    }

    if ( Error == ERROR_SUCCESS ) {

        //
        // Call the Base API, passing it the supplied parameters and the
        // counted Unicode strings.
        //

        if( IsLocalHandle( hKey )) {

            Error =  (LONG)LocalBaseRegSetValue (
                                hKey,
                                ValueName,
                                dwType,
                                ValueData,
                                cbData
                                );
#if defined(_WIN64)
            if ( Error == 0)
                Wow64RegSetKeyDirty (hKey);
#endif
        } else {

            Error =  (LONG)BaseRegSetValue (
                                DereferenceRemoteHandle( hKey ),
                                ValueName,
                                dwType,
                                ValueData,
                                cbData
                                );
        }
    }

    if( ValueData != lpData ) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValueBuffer );
    }
    if ( lpValueName ) {
        // free the allocated unicode string
        RtlFreeUnicodeString( &TempValueName );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for setting a value.

    RegSetValueExW converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegSetValue.

--*/

{
    UNICODE_STRING      ValueName;
    UNALIGNED WCHAR     *String;
    DWORD               StringLength;
    LONG                Error;
    HKEY                TempHandle = NULL;
    ULONG               Length;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    if ((hKey == HKEY_PERFORMANCE_TEXT) ||
        (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        return(PerfRegSetValue(hKey,
                               ( LPWSTR )lpValueName,
                               Reserved,
                               dwType,
                               ( LPBYTE )lpData,
                               cbData));
    }

    //
    // Ensure Reserved is zero to avoid future compatability problems.
    //

    if( Reserved != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Special hack to help out all the people who
    // believe the length of a NULL terminated string is
    // strlen(foo) instead of strlen(foo) + 1.
    //
    String = (UNALIGNED WCHAR *)lpData;
    StringLength = cbData/sizeof(WCHAR);
    if (((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ) || (dwType == REG_MULTI_SZ)) &&
        (StringLength > 0) &&
        (String[StringLength-1] != 0)) {
        //
        // Do this under an exception handler in case the last
        // little bit crosses a page boundary.
        //
        try {
            if (String[StringLength] == 0) {
                cbData += sizeof(WCHAR);        // increase string length to account for NULL terminator
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ; // guess they really really did not want a NULL terminator

        }
    }


    if( lpValueName != NULL ) {
        Length = wcslen( lpValueName ) * sizeof( WCHAR );    
        ValueName.Length = (USHORT)Length;
        if( Length != (ULONG)ValueName.Length ) {
            //
            // 32K overflow
            //
            Error = ERROR_INVALID_PARAMETER;
            goto ExitCleanup;
        }
    }
    //
    // Convert the value name to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    //
    //  Add the NULL to the Length, so that RPC will transmit it
    //
    ValueName.Length += sizeof( UNICODE_NULL );

    if( ValueName.Length == 0 ) {
        //
        // overflow in RtlInitUnicodeString
        //
        Error = ERROR_INVALID_PARAMETER;
        goto ExitCleanup;
    }
    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSetValue (
                        hKey,
                        &ValueName,
                        dwType,
                        ( LPBYTE )lpData,
                        cbData
                        );
#if defined(_WIN64)
            if ( Error == 0)
                Wow64RegSetKeyDirty (hKey);
#endif

    } else {

        Error = (LONG)BaseRegSetValue (
                        DereferenceRemoteHandle( hKey ),
                        &ValueName,
                        dwType,
                        ( LPBYTE )lpData,
                        cbData
                        );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\shutdown.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Shutdown.c

Abstract:

    This module contains the client side wrappers for the Win32 remote
    shutdown APIs, that is:

        - InitiateSystemShutdownA
        - InitiateSystemShutdownW
        - AbortSystemShutdownA
        - AbortSystemShutdownW

Author:

    Dave Chalmers (davidc) 29-Apr-1992

Notes:


Revision History:
    
    Dragos C. Sambotin (dragoss) 21-May-1999
        Added support for the new winlogon's Shutdown interface

--*/


#define UNICODE

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include "shutinit.h"
#include "..\regconn\regconn.h"

LONG
BaseBindToMachine(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    );

LONG
ShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PUNICODE_STRING Message,
    IN PVOID Context2
    );

LONG
ShutdownCallbackEx(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PUNICODE_STRING Message,
    IN PVOID Context2
    );

LONG
AbortShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Context1,
    IN PVOID Context2
    );

BOOL
APIENTRY
InitiateSystemShutdownW(
    IN LPWSTR lpMachineName OPTIONAL,
    IN LPWSTR lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown    
    )

/*++

Routine Description:

    Win32 Unicode API for initiating the shutdown of a (possibly remote) machine.

Arguments:

    lpMachineName - Name of machine to shutdown.

    lpMessage -     Message to display during shutdown timeout period.

    dwTimeout -     Number of seconds to delay before shutting down

    bForceAppsClosed - Normally applications may prevent system shutdown.
                    If this flag is set, all applications are terminated
                    unconditionally.

    bRebootAfterShutdown - TRUE if the system should reboot.
                    FALSE if it should be left in a shutdown state.

Return Value:

    Returns TRUE on success, FALSE on failure (GetLastError() returns error code)

    Possible errors :

        ERROR_SHUTDOWN_IN_PROGRESS - a shutdown has already been started on
                                     the specified machine.

--*/

{
    DWORD Result;
    UNICODE_STRING  Message;
    SHUTDOWN_CONTEXT ShutdownContext;
    BOOL    TryOld = TRUE;

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(lpMachineName)) {
        lpMachineName = L"";
        TryOld = FALSE;
    }

    ShutdownContext.dwTimeout = dwTimeout;
    ShutdownContext.bForceAppsClosed = (bForceAppsClosed != 0);
    ShutdownContext.bRebootAfterShutdown = (bRebootAfterShutdown != 0);
    RtlInitUnicodeString(&Message, lpMessage);

    //
    // Call the server
    //
    
    //
    // First try to connect to the new InitShutdown interface
    //
    Result = BaseBindToMachineShutdownInterface(lpMachineName,
                                                NewShutdownCallback,
                                                &Message,
                                                &ShutdownContext);

    if( (Result != ERROR_SUCCESS) && (TryOld == TRUE) ) {
        //
        // try the old one, maybe we are calling into a NT4 machine
        // which doesn't know about the new interface
        //
        Result = BaseBindToMachine(lpMachineName,
                                   ShutdownCallback,
                                   &Message,
                                   &ShutdownContext);
    }

    if (Result != ERROR_SUCCESS) {
        SetLastError(Result);
    }

    return(Result == ERROR_SUCCESS);
}


BOOL
APIENTRY
InitiateSystemShutdownExW(
    IN LPWSTR lpMachineName OPTIONAL,
    IN LPWSTR lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown,
    IN DWORD dwReason
    )

/*++

Routine Description:

    Win32 Unicode API for initiating the shutdown of a (possibly remote) machine.

Arguments:

    lpMachineName - Name of machine to shutdown.

    lpMessage -     Message to display during shutdown timeout period.

    dwTimeout -     Number of seconds to delay before shutting down

    bForceAppsClosed - Normally applications may prevent system shutdown.
                    If this flag is set, all applications are terminated
                    unconditionally.

    bRebootAfterShutdown - TRUE if the system should reboot.
                    FALSE if it should be left in a shutdown state.

    dwReason        - Reason for initiating the shutdown.  This reason is logged
                        in the eventlog #6006 event.

Return Value:

    Returns TRUE on success, FALSE on failure (GetLastError() returns error code)

    Possible errors :

        ERROR_SHUTDOWN_IN_PROGRESS - a shutdown has already been started on
                                     the specified machine.

--*/

{
    DWORD Result;
    UNICODE_STRING  Message;
    SHUTDOWN_CONTEXTEX ShutdownContext;
    BOOL    TryOld = TRUE;

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(lpMachineName)) {
        lpMachineName = L"";
        TryOld = FALSE;
    }

    ShutdownContext.dwTimeout = dwTimeout;
    ShutdownContext.bForceAppsClosed = (bForceAppsClosed != 0);
    ShutdownContext.bRebootAfterShutdown = (bRebootAfterShutdown != 0);
    ShutdownContext.dwReason = dwReason;
    RtlInitUnicodeString(&Message, lpMessage);

    //
    // Call the server
    //

    //
    // First try to connect to the new InitShutdown interface
    //
    Result = BaseBindToMachineShutdownInterface(lpMachineName,
                                                NewShutdownCallbackEx,
                                                &Message,
                                                &ShutdownContext);

    if( (Result != ERROR_SUCCESS) && (TryOld == TRUE) ) {
        //
        // try the old one, maybe we are calling into a NT4 machine
        // which doesn't know about the new interface
        //
        Result = BaseBindToMachine(lpMachineName,
                                   ShutdownCallbackEx,
                                   &Message,
                                   &ShutdownContext);
    }

    if (Result != ERROR_SUCCESS) {
        SetLastError(Result);
    }

    return(Result == ERROR_SUCCESS);
}


BOOL
APIENTRY
InitiateSystemShutdownA(
    IN LPSTR lpMachineName OPTIONAL,
    IN LPSTR lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown
    )

/*++

Routine Description:

    See InitiateSystemShutdownW

--*/

{
    UNICODE_STRING      MachineName;
    UNICODE_STRING      Message;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    BOOL                Result;

    //
    // Convert the ansi machinename to wide-character
    //

    RtlInitAnsiString( &AnsiString, lpMachineName );
    Status = RtlAnsiStringToUnicodeString(
                &MachineName,
                &AnsiString,
                TRUE
                );

    if( NT_SUCCESS( Status )) {

        //
        // Convert the ansi message to wide-character
        //

        RtlInitAnsiString( &AnsiString, lpMessage );
        Status = RtlAnsiStringToUnicodeString(
                    &Message,
                    &AnsiString,
                    TRUE
                    );

        if (NT_SUCCESS(Status)) {

            //
            // Call the wide-character api
            //

            Result = InitiateSystemShutdownW(
                                MachineName.Buffer,
                                Message.Buffer,
                                dwTimeout,
                                bForceAppsClosed,
                                bRebootAfterShutdown                                
                                );

            RtlFreeUnicodeString(&Message);
        }

        RtlFreeUnicodeString(&MachineName);
    }

    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        Result = FALSE;
    }

    return(Result);
}


BOOL
APIENTRY
InitiateSystemShutdownExA(
    IN LPSTR lpMachineName OPTIONAL,
    IN LPSTR lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown,
    IN DWORD dwReason
    )

/*++

Routine Description:

    See InitiateSystemShutdownW

--*/

{
    UNICODE_STRING      MachineName;
    UNICODE_STRING      Message;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    BOOL                Result;

    //
    // Convert the ansi machinename to wide-character
    //

    RtlInitAnsiString( &AnsiString, lpMachineName );
    Status = RtlAnsiStringToUnicodeString(
                &MachineName,
                &AnsiString,
                TRUE
                );

    if( NT_SUCCESS( Status )) {

        //
        // Convert the ansi message to wide-character
        //

        RtlInitAnsiString( &AnsiString, lpMessage );
        Status = RtlAnsiStringToUnicodeString(
                    &Message,
                    &AnsiString,
                    TRUE
                    );

        if (NT_SUCCESS(Status)) {

            //
            // Call the wide-character api
            //

            Result = InitiateSystemShutdownExW(
                                MachineName.Buffer,
                                Message.Buffer,
                                dwTimeout,
                                bForceAppsClosed,
                                bRebootAfterShutdown,
                                dwReason
                                );

            RtlFreeUnicodeString(&Message);
        }

        RtlFreeUnicodeString(&MachineName);
    }

    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        Result = FALSE;
    }

    return(Result);
}



BOOL
APIENTRY
AbortSystemShutdownW(
    IN LPWSTR lpMachineName OPTIONAL
    )

/*++

Routine Description:

    Win32 Unicode API for aborting the shutdown of a (possibly remote) machine.

Arguments:

    lpMachineName - Name of target machine.

Return Value:

    Returns TRUE on success, FALSE on failure (GetLastError() returns error code)

--*/

{
    DWORD   Result;
    RPC_BINDING_HANDLE binding;
    BOOL    TryOld = TRUE;

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(lpMachineName)) {
        lpMachineName = L"";
        TryOld = FALSE;
    }

    //
    // Call the server
    //

    //
    // First try to connect to the new InitShutdown interface
    //
    Result = BaseBindToMachineShutdownInterface(lpMachineName,
                                                NewAbortShutdownCallback,
                                                NULL,
                                                NULL);

    if( (Result != ERROR_SUCCESS) && (TryOld == TRUE) ) {
        //
        // try the old one, maybe we are calling into a NT4 machine
        // which doesn't know about the new interface
        Result = BaseBindToMachine(lpMachineName,
                                   AbortShutdownCallback,
                                   NULL,
                                   NULL);
    }

    if (Result != ERROR_SUCCESS) {
        SetLastError(Result);
    }

    return(Result == ERROR_SUCCESS);
}



BOOL
APIENTRY
AbortSystemShutdownA(
    IN LPSTR lpMachineName OPTIONAL
    )

/*++

Routine Description:

    See AbortSystemShutdownW

--*/

{
    UNICODE_STRING      MachineName;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    BOOL                Result;

    //
    // Convert the ansi machinename to wide-character
    //

    RtlInitAnsiString( &AnsiString, lpMachineName );
    Status = RtlAnsiStringToUnicodeString(
                &MachineName,
                &AnsiString,
                TRUE
                );

    if( NT_SUCCESS( Status )) {

        //
        // Call the wide-character api
        //

        Result = AbortSystemShutdownW(
                            MachineName.Buffer
                            );

        RtlFreeUnicodeString(&MachineName);
    }


    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        Result = FALSE;
    }

    return(Result);
}

LONG
ShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PUNICODE_STRING Message,
    IN PSHUTDOWN_CONTEXT ShutdownContext
    )
/*++

Routine Description:

    Callback for binding to a machine to initiate a shutdown.

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

    Message - Supplies message to display during shutdown timeout period.

    ShutdownContext - Supplies remaining parameters for BaseInitiateSystemShutdown

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseInitiateSystemShutdown((PREGISTRY_SERVER_NAME)pbinding,
                                            Message,
                                            ShutdownContext->dwTimeout,
                                            ShutdownContext->bForceAppsClosed,
                                            ShutdownContext->bRebootAfterShutdown);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}

LONG
ShutdownCallbackEx(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PUNICODE_STRING Message,
    IN PSHUTDOWN_CONTEXTEX ShutdownContext
    )
/*++

Routine Description:

    Callback for binding to a machine to initiate a shutdown.

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

    Message - Supplies message to display during shutdown timeout period.

    ShutdownContext - Supplies remaining parameters for BaseInitiateSystemShutdown

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseInitiateSystemShutdownEx((PREGISTRY_SERVER_NAME)pbinding,
                                            Message,
                                            ShutdownContext->dwTimeout,
                                            ShutdownContext->bForceAppsClosed,
                                            ShutdownContext->bRebootAfterShutdown,
                                            ShutdownContext->dwReason);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}

LONG
AbortShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Unused1,
    IN PVOID Unused2
    )
/*++

Routine Description:

    Callback for binding to a machine to abort a shutdown.

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseAbortSystemShutdown((PREGISTRY_SERVER_NAME)pbinding);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\regsrkey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsrkey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    save/restore key APIs, that is:

        - RegRestoreKeyA
        - RegRestoreKeyW
        - RegSaveKeyA
        - RegSaveKeyW

Author:

    David J. Gilman (davegi) 23-Jan-1992

Notes:

    The RegSaveKey and RegRestoreKey APIs involve up to 3 machines:

    1.- CLIENT: The machine where the API is invoked.
    2.- SERVER: The machine where the Registry resides.
    3.- TARGET: The machine of the specified file.

    Note that both the client and the server will be running Windows NT,
    but that the target machine might not.

    Even though the target might be accessible from the client, it might
    not be accessible from the server (e.g. the share is protected).



Revision History:

    25-Mar-1992     Ramon J. San Andres (ramonsa)
                    Changed to use RPC.

--*/


#include <rpc.h>
#include "regrpc.h"
#include "client.h"




LONG
APIENTRY
RegRestoreKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    Win32 Ansi API for restoring a key.

--*/

{
    PUNICODE_STRING     FileName;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    ASSERT( lpFile != NULL );

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    //
    // Convert the file name to a counted Unicode string using the static
    // Unicode string in the TEB.
    //

    FileName = &NtCurrentTeb( )->StaticUnicodeString;
    ASSERT( FileName != NULL );
    RtlInitAnsiString( &AnsiString, lpFile );
    Status = RtlAnsiStringToUnicodeString(
                FileName,
                &AnsiString,
                FALSE
                );

    //
    // If the file name could not be converted, map the results and return.
    //

    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }


    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName->Length > 0 ) {
        FileName->Length += sizeof( UNICODE_NULL );
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegRestoreKey(
                            hKey,
                            FileName,
                            dwFlags
                            );

    } else {

        Error = (LONG)BaseRegRestoreKey(
                            DereferenceRemoteHandle( hKey ),
                            FileName,
                            dwFlags
                            );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}



LONG
APIENTRY
RegRestoreKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    Restore the tree in the supplied file onto the key referenced by the
    supplied key handle. The restored tree will overwrite all of the
    contents of the supplied hKey except for its name. Pictorially, if
    the file contains:

                    A
                   / \
                  /   \
                 B     C

    and the supplied key refers to a key name X, the resultant tree would
    look like:

                    X
                   / \
                  /   \
                 B     C

Arguments:

    hKey - Supplies a handle to the key where the file is to be restored.

    lpFile - Supplies a pointer to an existing file name whose contents was
        created with RegSaveKey.

    dwFlags - Supplies an optional flag argument which can be:

                - REG_WHOLE_HIVE_VOLATILE

                    If specified this flag causes a new, volatile
                    (i.e. memory only) hive to be created. In this case
                    the hKey can only refer to a child of HKEY_USERS or
                    HKEY_LOCAL_MACHINE.

                    If not specified, hKey can refer to any key in the
                    Registry.


Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING  FileName;
    LONG            Error;
    HKEY            TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    ASSERT( lpFile != NULL );

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    RtlInitUnicodeString( &FileName, lpFile );


    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName.Length > 0 ) {
        FileName.Length += sizeof( UNICODE_NULL );
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegRestoreKey(
                                hKey,
                                &FileName,
                                dwFlags
                                );

    } else {

        Error = (LONG)BaseRegRestoreKey(
                                DereferenceRemoteHandle( hKey ),
                                &FileName,
                                dwFlags
                                );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSaveKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    Win32 ANSI wrapper to RegSaveKeyW.

    Save the key (and all of its decsendants) to the non-existant file
    named by the supplied string.

Arguments:

    hKey    - Supplies a handle to the key where the save operation is to
              begin.

    lpFile  - Supplies a pointer to a non-existant file name where the tree
              rooted at the supplied key handle will be saved.

    lpSecurityAttributes - Supplies an optional pointer to a
        SECURITY_ATTRIBUTES structure for the newly created file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    PUNICODE_STRING             FileName;
    ANSI_STRING                 AnsiString;
    NTSTATUS                    Status;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    ASSERT( lpFile != NULL );

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Note that we must map the handle here even though RegSaveKeyW
    //  will map it again. This is so that the second map will not
    //  overwrite the static Unicode string in the TEB that will
    //  contain the file name.
    //

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    //
    // Convert the file name to a counted Unicode string using the static
    // Unicode string in the TEB.
    //
    FileName = &NtCurrentTeb( )->StaticUnicodeString;
    ASSERT( FileName != NULL );
    RtlInitAnsiString( &AnsiString, lpFile );
    Status = RtlAnsiStringToUnicodeString(
                FileName,
                &AnsiString,
                FALSE
                );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName->Length > 0 ) {
        FileName->Length += sizeof( UNICODE_NULL );
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //
        pRpcSA = NULL;
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSaveKey(
                                hKey,
                                FileName,
                                pRpcSA
                                );

    } else {

        Error = (LONG)BaseRegSaveKey(
                                DereferenceRemoteHandle( hKey ),
                                FileName,
                                pRpcSA
                                );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSaveKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    Save the key (and all of its decsendants) to the non-existant file
    named by the supplied string.

Arguments:

    hKey - Supplies a handle to the key where the save operation is to
        begin.

    lpFile - Supplies a pointer to a non-existant file name where the tree
            rooted at the supplied key handle will be saved.

    lpSecurityAttributes - Supplies an optional pointer to a
        SECURITY_ATTRIBUTES structure for the newly created file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING              FileName;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    ASSERT( lpFile != NULL );


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Note that we must map the handle here even though RegSaveKeyW
    //  will map it again. This is so that the second map will not
    //  overwrite the static Unicode string in the TEB that will
    //  contain the file name.
    //
    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    RtlInitUnicodeString( &FileName, lpFile );


    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName.Length > 0 ) {
        FileName.Length += sizeof( UNICODE_NULL );
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //
        pRpcSA = NULL;
    }


    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSaveKey(
                                hKey,
                                &FileName,
                                pRpcSA
                                );

    } else {

        Error = (LONG)BaseRegSaveKey(
                                DereferenceRemoteHandle( hKey ),
                                &FileName,
                                pRpcSA
                                );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}


LONG
APIENTRY
RegSaveKeyExA (
    HKEY hKey,
    LPCSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD Flags
    )

/*++

Routine Description:

    Win32 ANSI wrapper to RegSaveKeyExW.

    Save the key (and all of its decsendants) to the non-existant file
    named by the supplied string.

Arguments:

    hKey    - Supplies a handle to the key where the save operation is to
              begin.

    lpFile  - Supplies a pointer to a non-existant file name where the tree
              rooted at the supplied key handle will be saved.

    lpSecurityAttributes - Supplies an optional pointer to a
        SECURITY_ATTRIBUTES structure for the newly created file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    PUNICODE_STRING             FileName;
    ANSI_STRING                 AnsiString;
    NTSTATUS                    Status;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    ASSERT( lpFile != NULL );

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Note that we must map the handle here even though RegSaveKeyW
    //  will map it again. This is so that the second map will not
    //  overwrite the static Unicode string in the TEB that will
    //  contain the file name.
    //

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    //
    // Convert the file name to a counted Unicode string using the static
    // Unicode string in the TEB.
    //
    FileName = &NtCurrentTeb( )->StaticUnicodeString;
    ASSERT( FileName != NULL );
    RtlInitAnsiString( &AnsiString, lpFile );
    Status = RtlAnsiStringToUnicodeString(
                FileName,
                &AnsiString,
                FALSE
                );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName->Length > 0 ) {
        FileName->Length += sizeof( UNICODE_NULL );
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //
        pRpcSA = NULL;
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSaveKeyEx(
                                hKey,
                                FileName,
                                pRpcSA,
                                Flags
                                );

    } else {

        Error = (LONG)BaseRegSaveKeyEx(
                                DereferenceRemoteHandle( hKey ),
                                FileName,
                                pRpcSA,
                                Flags
                                );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegSaveKeyExW (
    HKEY                    hKey,
    LPCWSTR                 lpFile,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   Flags
    )

/*++

Routine Description:

    Save the key (and all of its decsendants) to the non-existant file
    named by the supplied string.

    This variant is used by setup in order to create a hive in the latest
    format. Helps creating hives in %systemroot%\system32\config in the 
    latest (presumably the best) format, and allows RegSaveKey to use the 
    standard format (bacward compatible) for roaming profiles and tools
    using registry hives on downlevel OSes.

Arguments:

    hKey - Supplies a handle to the key where the save operation is to
        begin.

    lpFile - Supplies a pointer to a non-existant file name where the tree
            rooted at the supplied key handle will be saved.

    lpSecurityAttributes - Supplies an optional pointer to a
        SECURITY_ATTRIBUTES structure for the newly created file.

    Flags - [REG_STANDARD_FORMAT]	- roaming format
            [REG_LATEST_FORMAT]		- latest format
            [REG_NO_COMPRESSION]	- no hive compression : faster

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING              FileName;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    ASSERT( lpFile != NULL );


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Note that we must map the handle here even though RegSaveKeyW
    //  will map it again. This is so that the second map will not
    //  overwrite the static Unicode string in the TEB that will
    //  contain the file name.
    //
    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    RtlInitUnicodeString( &FileName, lpFile );


    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( FileName.Length > 0 ) {
        FileName.Length += sizeof( UNICODE_NULL );
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //
        pRpcSA = NULL;
    }


    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSaveKeyEx(
                                hKey,
                                &FileName,
                                pRpcSA,
                                Flags
                                );

    } else {

        Error = (LONG)BaseRegSaveKeyEx(
                                DereferenceRemoteHandle( hKey ),
                                &FileName,
                                pRpcSA,
                                Flags
                                );
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\shutinit.c ===
#include <shutinit_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\common.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    common.c

Abstract:

    Utility routines used by Lodctr and/or UnLodCtr
    

Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
//
//  Windows Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <accctrl.h>
#include <aclapi.h>
#include <winperf.h>
#include <tchar.h>
#include <initguid.h>
#include <guiddef.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  local include files
//
#define _INIT_WINPERFP_
#include "winperfp.h"
#include "ldprfmsg.h"
#include "common.h"
//
//
//  Text string Constant definitions
//
LPCTSTR NamesKey = (LPCTSTR)TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
LPCTSTR DefaultLangId = (LPCTSTR)TEXT("009");
LPCTSTR DefaultLangTag = (LPCTSTR)TEXT("000");
LPCTSTR Counters = (LPCTSTR)TEXT("Counters");
LPCTSTR Help = (LPCTSTR)TEXT("Help");
LPCTSTR VersionStr = (LPCTSTR)TEXT("Version");
LPCTSTR LastHelp = (LPCTSTR)TEXT("Last Help");
LPCTSTR LastCounter = (LPCTSTR)TEXT("Last Counter");
LPCTSTR FirstHelp = (LPCTSTR)TEXT("First Help");
LPCTSTR cszFirstCounter = (LPCTSTR)TEXT("First Counter");
LPCTSTR Busy = (LPCTSTR)TEXT("Updating");
LPCTSTR Slash = (LPCTSTR)TEXT("\\");
LPCTSTR BlankString = (LPCTSTR)TEXT(" ");
LPCTSTR DriverPathRoot = (LPCTSTR)TEXT("SYSTEM\\CurrentControlSet\\Services");
LPCTSTR Performance = (LPCTSTR)TEXT("Performance");
LPCTSTR CounterNameStr = (LPCTSTR)TEXT("Counter ");
LPCTSTR HelpNameStr = (LPCTSTR)TEXT("Explain ");
LPCTSTR AddCounterNameStr = (LPCTSTR)TEXT("Addcounter ");
LPCTSTR AddHelpNameStr = (LPCTSTR)TEXT("Addexplain ");
LPCTSTR szObjectList = (LPCTSTR)TEXT("Object List");
LPCTSTR szLibraryValidationCode = (LPCTSTR)TEXT("Library Validation Code");
LPCTSTR szDisplayName = (LPCTSTR) TEXT("DisplayName");
LPCTSTR szPerfIniPath = (LPCTSTR) TEXT("PerfIni");

BOOLEAN g_bCheckTraceLevel = FALSE;

//  Global (to this module) Buffers
//
static  TCHAR   DisplayStringBuffer[DISP_BUFF_SIZE];
static  TCHAR   TextFormat[DISP_BUFF_SIZE];
static  HANDLE  hMod = NULL;    // process handle
static  DWORD   dwLastError = ERROR_SUCCESS;

HANDLE hEventLog      = NULL;
HANDLE hLoadPerfMutex = NULL;
//
//  local static data
//
static  TCHAR   cDoubleQuote =  TEXT('\"');

BOOL
__stdcall
DllEntryPoint(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    BOOL    bReturn = FALSE;

    ReservedAndUnused;

    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            setlocale(LC_ALL, ".OCP");

            hMod = DLLHandle;   // use DLL handle , not APP handle

            // register eventlog source
            hEventLog = RegisterEventSourceW (
                NULL, (LPCWSTR)L"LoadPerf");

            bReturn = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            if (hEventLog != NULL) {
                if (DeregisterEventSource(hEventLog)) {
                    hEventLog = NULL;
                }
            }
            if (hLoadPerfMutex != NULL) {
                CloseHandle(hLoadPerfMutex);
                hLoadPerfMutex = NULL;
            }
            bReturn = TRUE;
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bReturn = TRUE;
            break;
    }

    return bReturn;
}

LPCTSTR
GetStringResource (
    UINT    wStringId
)
/*++

    Retrived UNICODE strings from the resource file for display 

--*/
{

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        if ((LoadString(hMod, wStringId, DisplayStringBuffer, DISP_BUFF_SIZE)) > 0) {
            return (LPTSTR)&DisplayStringBuffer[0];
        } else {
            dwLastError = GetLastError();
            return BlankString;
        }
    } else {
        return BlankString;
    }
}
LPCWSTR
GetFormatResource (
    UINT    wStringId
)
/*++

    Returns an ANSI string for use as a format string in a printf fn.

--*/
{

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        if ((LoadStringW(hMod, wStringId, TextFormat, DISP_BUFF_SIZE)) > 0) {
            return (LPCTSTR)&TextFormat[0];
        } else {
            dwLastError = GetLastError();
            return BlankString;
        }
    } else {
        return BlankString;
    }
}

VOID
DisplayCommandHelp (
    UINT    iFirstLine,
    UINT    iLastLine
)
/*++

DisplayCommandHelp

    displays usage of command line arguments

Arguments

    NONE

Return Value

    NONE

--*/
{
    UINT  iThisLine;
    WCHAR StringBuffer[DISP_BUFF_SIZE];
    CHAR  OemStringBuffer[DISP_BUFF_SIZE];
    int   nStringBufferLen;
    int   nOemStringBufferLen;

    if (! hMod) {
        hMod = (HINSTANCE) GetModuleHandle(NULL);
    }
    
    if (hMod) {
        for (iThisLine = iFirstLine; iThisLine <= iLastLine; iThisLine++) {
            ZeroMemory(StringBuffer,    DISP_BUFF_SIZE * sizeof(WCHAR));
            ZeroMemory(OemStringBuffer, DISP_BUFF_SIZE * sizeof(CHAR));

            nStringBufferLen = LoadStringW(
                    hMod, iThisLine, StringBuffer, DISP_BUFF_SIZE);
            if (nStringBufferLen > 0) {
                nOemStringBufferLen = DISP_BUFF_SIZE;
                WideCharToMultiByte(CP_OEMCP,
                                    0,
                                    StringBuffer,
                                    nStringBufferLen,
                                    OemStringBuffer,
                                    nOemStringBufferLen,
                                    NULL,
                                    NULL);
                fprintf (stdout, "\n%s", OemStringBuffer);
            }
        }    
    } // else do nothing

} // DisplayCommandHelp

BOOL
TrimSpaces (
    IN  OUT LPTSTR  szString
)
/*++

Routine Description:

    Trims leading and trailing spaces from szString argument, modifying
        the buffer passed in

Arguments:

    IN  OUT LPTSTR  szString
        buffer to process

Return Value:

    TRUE if string was modified
    FALSE if not

--*/
{
    LPTSTR  szSource;
    LPTSTR  szDest;
    LPTSTR  szLast;
    BOOL    bChars;

    szLast = szSource = szDest = szString;
    bChars = FALSE;

    while (*szSource != 0) {
        // skip leading non-space chars
        if (!_istspace(*szSource)) {
            szLast = szDest;
            bChars = TRUE;
        }
        if (bChars) {
            // remember last non-space character
            // copy source to destination & increment both
            *szDest++ = *szSource++;
        } else {
            szSource++;
        }
    }

    if (bChars) {
        *++szLast = 0; // terminate after last non-space char
    } else {
        // string was all spaces so return an empty (0-len) string
        *szString = 0;
    }

    return (szLast != szSource);
}

BOOL
IsDelimiter (
    IN  TCHAR   cChar,
    IN  TCHAR   cDelimiter
)
/*++

Routine Description:

    compares the characte to the delimiter. If the delimiter is
        a whitespace character then any whitespace char will match
        otherwise an exact match is required
--*/
{
    if (_istspace(cDelimiter)) {
        // delimiter is whitespace so any whitespace char will do
        return (_istspace(cChar));
    } else {
        // delimiter is not white space so use an exact match
        return (cChar == cDelimiter);
    }
}

LPCTSTR
GetItemFromString (
    IN  LPCTSTR     szEntry,
    IN  DWORD       dwItem,
    IN  TCHAR       cDelimiter

)
/*++

Routine Description:

    returns nth item from a list delimited by the cDelimiter Char.
        Leaves (double)quoted strings intact.

Arguments:

    IN  LPCTSTR szEntry
        Source string returned to parse

    IN  DWORD   dwItem
        1-based index indicating which item to return. (i.e. 1= first item
        in list, 2= second, etc.)

    IN  TCHAR   cDelimiter
        character used to separate items. Note if cDelimiter is WhiteSpace
        (e.g. a tab or a space) then any white space will serve as a delim.

Return Value:

    pointer to buffer containing desired entry in string. Note, this
        routine may only be called 4 times before the string
        buffer is re-used. (i.e. don't use this function more than
        4 times in single function call!!)

--*/
{
    static  TCHAR   szReturnBuffer[4][MAX_PATH];
    static  LONG    dwBuff;
    LPTSTR  szSource, szDest;
    DWORD   dwThisItem;
    DWORD   dwStrLeft;

    dwBuff = ++dwBuff % 4; // wrap buffer index

    szSource = (LPTSTR)szEntry;
    szDest = &szReturnBuffer[dwBuff][0];

    // clear previous contents
    memset (szDest, 0, (MAX_PATH * sizeof(TCHAR)));

    // find desired entry in string
    dwThisItem = 1;
    while (dwThisItem < dwItem) {
        if (*szSource != 0) {
            while (!IsDelimiter(*szSource, cDelimiter) && (*szSource != 0)) {
                if (*szSource == cDoubleQuote) {
                    // if this is a quote, then go to the close quote
                    szSource++;
                    while ((*szSource != cDoubleQuote) && (*szSource != 0)) szSource++;
                }
                if (*szSource != 0) szSource++;
            }
        }
        dwThisItem++;
        if (*szSource != 0) szSource++;
    }
    // copy this entry to the return buffer
    if (*szSource != 0) {
        dwStrLeft = MAX_PATH-1;
        while (!IsDelimiter(*szSource, cDelimiter) && (*szSource != 0)) {
            if (*szSource == cDoubleQuote) {
                // if this is a quote, then go to the close quote
                // don't copy quotes!
                szSource++;
                while ((*szSource != cDoubleQuote) && (*szSource != 0)) {
                    *szDest++ = *szSource++;
                    dwStrLeft--;
                    if (!dwStrLeft) break;   // dest is full (except for term NULL
                }
                if (*szSource != 0) szSource++;
            } else {
                *szDest++ = *szSource++;
                dwStrLeft--;
                if (!dwStrLeft) break;   // dest is full (except for term NULL
            }
        }
        *szDest = 0;
    }

    // remove any leading and/or trailing spaces

    TrimSpaces (&szReturnBuffer[dwBuff][0]);

    return &szReturnBuffer[dwBuff][0];
}

void
ReportLoadPerfEvent(
    IN  WORD    EventType,
    IN  DWORD   EventID,
    IN  DWORD   dwDataCount,
    IN  DWORD   dwData1,
    IN  DWORD   dwData2,
    IN  DWORD   dwData3,
    IN  DWORD   dwData4,
    IN  WORD    wStringCount,
    IN  LPWSTR  szString1,
    IN  LPWSTR  szString2,
    IN  LPWSTR  szString3
)
{
    DWORD  dwData[5];
    LPWSTR szMessageArray[4];
    BOOL   bResult           = FALSE;
    WORD   wLocalStringCount = 0;
    DWORD  dwLastError       = GetLastError();

    if (dwDataCount > 4)  dwDataCount  = 4;
    if (wStringCount > 3) wStringCount = 3;

    if (dwDataCount > 0) dwData[0] = dwData1;
    if (dwDataCount > 1) dwData[1] = dwData2;
    if (dwDataCount > 2) dwData[2] = dwData3;
    if (dwDataCount > 3) dwData[3] = dwData4;
    dwDataCount *= sizeof(DWORD);

    if (wStringCount > 0 && szString1) {
        szMessageArray[wLocalStringCount] = szString1;
        wLocalStringCount ++;
    }
    if (wStringCount > 1 && szString2) {
        szMessageArray[wLocalStringCount] = szString2;
        wLocalStringCount ++;
    }
    if (wStringCount > 2 && szString3) {
        szMessageArray[wLocalStringCount] = szString3;
        wLocalStringCount ++;
    }

    if (hEventLog == NULL) {
        hEventLog = RegisterEventSourceW (NULL, (LPCWSTR)L"LoadPerf");
    }

    if (dwDataCount > 0 && wLocalStringCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type 
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     wLocalStringCount,     // number of strings
                     dwDataCount,           // sizeof raw data
                     szMessageArray,        // message text array
                     (LPVOID) & dwData[0]); // raw data
    }
    else if (dwDataCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     0,                     // number of strings
                     dwDataCount,           // sizeof raw data
                     NULL,                  // message text array
                     (LPVOID) & dwData[0]); // raw data
    }
    else if (wLocalStringCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     wLocalStringCount,     // number of strings
                     0,                     // sizeof raw data
                     szMessageArray,        // message text array
                     NULL);                 // raw data
    }
    else {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     0,                     // number of strings
                     0,                     // sizeof raw data
                     NULL,                  // message text array
                     NULL);                 // raw data
    }

    if (! bResult) {
        DbgPrint("LOADPERF(0x%08X)::(%d,0x%08X,%d)(%d,%d,%d,%d,%d)(%d,%ws,%ws,%ws)\n",
                GetCurrentThreadId(),
                EventType, EventID, GetLastError(),
                dwDataCount, dwData1, dwData2, dwData3, dwData4,
                wStringCount, szString1, szString2, szString3);
    }

    SetLastError(dwLastError);
}

BOOLEAN LoadPerfGrabMutex()
{
    BOOL    bResult      = TRUE;
    HANDLE  hLocalMutex  = NULL;
    DWORD   dwWaitStatus = 0;

    SECURITY_ATTRIBUTES      SecurityAttributes; 
    PSECURITY_DESCRIPTOR     pSD = NULL; 
    EXPLICIT_ACCESS          ea[3]; 
    SID_IDENTIFIER_AUTHORITY authNT    = SECURITY_NT_AUTHORITY; 
    SID_IDENTIFIER_AUTHORITY authWorld = SECURITY_WORLD_SID_AUTHORITY; 
    PSID  psidSystem   = NULL;
    PSID  psidAdmin    = NULL;
    PSID  psidEveryone = NULL; 
    PACL  pAcl         = NULL; 

    if (hLoadPerfMutex == NULL) {
        ZeroMemory(& ea, 3 * sizeof(EXPLICIT_ACCESS));

        // Get the system sid
        //
        bResult = AllocateAndInitializeSid(& authNT,
                                           1,
                                           SECURITY_LOCAL_SYSTEM_RID,
                                           0, 0, 0, 0, 0, 0, 0,
                                           & psidSystem);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup;
        }

        // Set the access rights for system sid
        //
        ea[0].grfAccessPermissions = MUTEX_ALL_ACCESS;
        ea[0].grfAccessMode        = SET_ACCESS;
        ea[0].grfInheritance       = NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm  = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType  = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName    = (LPTSTR) psidSystem;

        // Get the Admin sid
        //
        bResult = AllocateAndInitializeSid(& authNT,
                                           2,
                                           SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS,
                                           0, 0, 0, 0, 0, 0,
                                           & psidAdmin);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup;
        }

        // Set the access rights for Admin sid
        //
        ea[1].grfAccessPermissions = MUTEX_ALL_ACCESS;
        ea[1].grfAccessMode        = SET_ACCESS;
        ea[1].grfInheritance       = NO_INHERITANCE;
        ea[1].Trustee.TrusteeForm  = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType  = TRUSTEE_IS_GROUP;
        ea[1].Trustee.ptstrName    = (LPTSTR) psidAdmin;

        // Get the World sid
        //
        bResult = AllocateAndInitializeSid(& authWorld,
                                           1,
                                           SECURITY_WORLD_RID,
                                           0, 0, 0, 0, 0, 0, 0,
                                           & psidEveryone);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup;
        }

        // Set the access rights for world
        //
        ea[2].grfAccessPermissions = READ_CONTROL | SYNCHRONIZE | MUTEX_MODIFY_STATE;
        ea[2].grfAccessMode        = SET_ACCESS;
        ea[2].grfInheritance       = NO_INHERITANCE;
        ea[2].Trustee.TrusteeForm  = TRUSTEE_IS_SID;
        ea[2].Trustee.TrusteeType  = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[2].Trustee.ptstrName    = (LPTSTR) psidEveryone;

        // Create a new ACL that contains the new ACEs. 
        // 
        dwWaitStatus = SetEntriesInAcl(3, ea, NULL, & pAcl);
        if (dwWaitStatus != ERROR_SUCCESS) {
            bResult = FALSE;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup; 
        }

        // Initialize a security descriptor.
        //
        pSD = (PSECURITY_DESCRIPTOR)
              LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH); 
        if (pSD == NULL)  {
            dwWaitStatus = GetLastError();
            bResult      = FALSE;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup; 
        }
  
        bResult = InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup; 
        }

        // Add the ACL to the security descriptor.
        //
        bResult = SetSecurityDescriptorDacl(pSD, TRUE, pAcl, FALSE);
        if (! bResult) {
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADPERFGRABMUTEX,
                    0,
                    dwWaitStatus,
                    NULL));
            goto Cleanup; 
        }

        SecurityAttributes.nLength              = sizeof(SECURITY_ATTRIBUTES); 
        SecurityAttributes.bInheritHandle       = TRUE; 
        SecurityAttributes.lpSecurityDescriptor = pSD; 

        __try {
            hLocalMutex = CreateMutex(& SecurityAttributes,
                                      FALSE,
                                      TEXT("LOADPERF_MUTEX"));
            if (hLocalMutex == NULL) {
                bResult      = FALSE;
                dwWaitStatus = GetLastError();
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADPERFGRABMUTEX,
                        0,
                        dwWaitStatus,
                        NULL));
            }
            else if (InterlockedCompareExchangePointer(& hLoadPerfMutex,
                                                       hLocalMutex,
                                                       NULL) != NULL) {
                CloseHandle(hLocalMutex);
                hLocalMutex = NULL;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            bResult      = FALSE;
            dwWaitStatus = GetLastError();
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_LOADPERFGRABMUTEX,
                   0,
                   dwWaitStatus,
                   NULL));
        }
    }

    __try {
        dwWaitStatus = WaitForSingleObject(hLoadPerfMutex, H_MUTEX_TIMEOUT);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        bResult      = FALSE;
        dwWaitStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_LOADPERFGRABMUTEX,
               0,
               dwWaitStatus,
               NULL));
    }
    if (dwWaitStatus != WAIT_OBJECT_0 && dwWaitStatus != WAIT_ABANDONED) {
        bResult = FALSE;
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_LOADPERFGRABMUTEX,
               0,
               dwWaitStatus,
               NULL));
    }

Cleanup:
    if (psidSystem)   FreeSid(psidSystem);
    if (psidAdmin)    FreeSid(psidAdmin);
    if (psidEveryone) FreeSid(psidEveryone);
    if (pAcl)         LocalFree(pAcl);
    if (pSD)          LocalFree(pSD);
    if (! bResult)    SetLastError(dwWaitStatus);

    return bResult ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\client\support.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Support.c

Abstract:

    This module contains support functions for the client side of the
    Win32 Registry APIs. That is:

        - MakeSemiUniqueName

Author:

    David J. Gilman (davegi) 15-Nov-1991

--*/

#include <rpc.h>
#include "regrpc.h"
#include <stdio.h>


#define REG_SUNAME_FORMAT_STRING    "Win32Reg.%08x.%08x"



BOOL
MakeSemiUniqueName (
    OUT PUNICODE_STRING     Name,
    IN  DWORD               Sequence
    )
/*++

Routine Description:

    Forms a name that is very probably unique in the system, based on
    the current process and thread id and a sequence provided by the
    caller.

Arguments:

    Name        -   Supplies a unicode string where the name will be put.
                    This string must contain a valid buffer of size
                    MAX_PATH * sizeof(WCHAR)

    Sequence    -   Supplies a sequence number that will be appended to
                    the name. If a name happens not to be unique, the
                    caller can try again with other sequence numbers.

Return Value:

    BOOL - Returns TRUE if a name was obtained.

--*/
{
    CHAR            NameBuffer[ MAX_PATH ];
    ANSI_STRING     AnsiName;
    NTSTATUS        NtStatus;

    ASSERT( Name && Name->Buffer );

    sprintf( NameBuffer,
             REG_SUNAME_FORMAT_STRING,
             HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
             Sequence
           );


    RtlInitAnsiString( &AnsiName, NameBuffer );

    NtStatus = RtlAnsiStringToUnicodeString(
                    Name,
                    &AnsiName,
                    FALSE
                    );

    return NT_SUCCESS( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\common.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

common.h

    constants and globals that are common to LODCTR and UNLODCTR

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

--*/
#ifndef _LODCTR_COMMON_H_
#define _LODCTR_COMMON_H_
//
//  Local constants
//
#define RESERVED                0L
#define LARGE_BUFFER_SIZE       0x10000         // 64K
#define MEDIUM_BUFFER_SIZE      0x8000          // 32K
#define SMALL_BUFFER_SIZE       0x1000          //  4K
#define FILE_NAME_BUFFER_SIZE   MAX_PATH
#define DISP_BUFF_SIZE          256L
#define SIZE_OF_OFFSET_STRING   15
#define PERFLIB_BASE_INDEX      1847
#define FIRST_EXT_COUNTER_INDEX 1848
#define FIRST_EXT_HELP_INDEX    1849

#define H_MUTEX_TIMEOUT         10000L
#define LODCTR_UPNF_RESTORE     0x00000001
//
//  Data structure and type definitions
//
typedef struct _NAME_ENTRY {
    struct _NAME_ENTRY  *pNext;
    DWORD               dwOffset;
    DWORD               dwType;
    LPTSTR              lpText;
} NAME_ENTRY, *PNAME_ENTRY;

typedef struct _LANGUAGE_LIST_ELEMENT {
    struct _LANGUAGE_LIST_ELEMENT   *pNextLang;     // next lang. list
    LPTSTR  LangId;                                 // lang ID string for this elem
    PNAME_ENTRY pFirstName;                         // head of name list
    PNAME_ENTRY pThisName;                          // pointer to current entry
    DWORD   dwNumElements;                          // number of elements in array
    DWORD   dwNameBuffSize;
    DWORD   dwHelpBuffSize;
    PBYTE   NameBuffer;                             // buffer to store strings
    PBYTE   HelpBuffer;                             // buffer to store help strings
} LANGUAGE_LIST_ELEMENT, *PLANGUAGE_LIST_ELEMENT;

typedef struct _SYMBOL_TABLE_ENTRY {
    struct _SYMBOL_TABLE_ENTRY    *pNext;
    LPTSTR  SymbolName;
    DWORD   Value;
} SYMBOL_TABLE_ENTRY, *PSYMBOL_TABLE_ENTRY;

//
//  Utility Routine prototypes for routines in common.c
//
#define StringToInt(in,out) \
    (((_stscanf ((in), (LPCTSTR)TEXT(" %d"), (out))) == 1) ? TRUE : FALSE)

//#define _LOADPERF_SHOW_MEM_ALLOC 1
#define MemorySize(x) \
    ((x != NULL) ? (DWORD) HeapSize(GetProcessHeap(), 0, x) : (DWORD) 0)

#ifndef _LOADPERF_SHOW_MEM_ALLOC
#define MemoryAllocate(x) \
    ((LPVOID) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x))
#define MemoryFree(x) \
    ((VOID) HeapFree(GetProcessHeap(), 0, x))
#define MemoryResize(x,y) \
    ((LPVOID) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x, y));
#else
__inline
LPVOID LoadPerfHeapAlloc(LPSTR szSource, DWORD dwLine, SIZE_T x)
{
    LPVOID lpReturn = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x);
#ifdef _WIN64
    DbgPrint("HeapAlloc(%s#%d)(%I64d,0x%08X)\n",
            szSource, dwLine, (lpReturn != NULL ? x : 0), lpReturn);
#else
    DbgPrint("HeapAlloc(%s#%d)(%d,0x%08X)\n",
            szSource, dwLine, (lpReturn != NULL ? x : 0), lpReturn);
#endif
    return lpReturn;
}

__inline
BOOL
LoadPerfHeapFree(LPSTR szSource, DWORD dwLine, LPVOID x)
{
    BOOL   bReturn = TRUE;
    SIZE_T dwSize;

    if (x != NULL) {
        dwSize  = HeapSize(GetProcessHeap(), 0, x);
        bReturn = HeapFree(GetProcessHeap(), 0, x);
#ifdef _WIN64
    DbgPrint("HeapFree(%s#%d)(0x%08X,%I64d)\n",
            szSource, dwLine, x, (bReturn ? dwSize : 0));
#else
    DbgPrint("HeapFree(%s#%d)(0x%08X,%d)\n",
            szSource, dwLine, x, (bReturn ? dwSize : 0));
#endif
    }
    return bReturn;
}

__inline
LPVOID
LoadPerfHeapReAlloc(LPSTR szSource, DWORD dwLine, LPVOID x, SIZE_T y)
{
    LPVOID  lpReturn;
    SIZE_T  dwSize;

    dwSize   = HeapSize(GetProcessHeap(), 0, x);
    lpReturn = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x, y);
#ifdef _WIN64
    DbgPrint("HeapReAlloc(%s#%d)(0x%08X,%I64d)(0x%08X,%I64d)\n",
            szSource, dwLine, x, dwSize, lpReturn, (lpReturn != NULL ? y : 0));
#else
    DbgPrint("HeapReAlloc(%s#%d)(0x%08X,%d)(0x%08X,%d)\n",
            szSource, dwLine, x, dwSize, lpReturn, (lpReturn != NULL ? y : 0));
#endif
    return lpReturn;
}

#define MemoryAllocate(x) LoadPerfHeapAlloc(__FILE__,__LINE__,x)
#define MemoryFree(x)     LoadPerfHeapFree(__FILE__,__LINE__,x)
#define MemoryResize(x,y) LoadPerfHeapReAlloc(__FILE__,__LINE__,x,y)
#endif


LPCTSTR
GetStringResource (
    UINT    wStringId
);

LPCTSTR
GetFormatResource (
    UINT    wStringId
);

VOID
DisplayCommandHelp (
    UINT    iFirstLine,
    UINT    iLastLine
);

BOOL
TrimSpaces (
    IN  OUT LPTSTR  szString
);

BOOL
IsDelimiter (
    IN  TCHAR   cChar,
    IN  TCHAR   cDelimiter
);

LPCTSTR
GetItemFromString (
    IN  LPCTSTR     szEntry,
    IN  DWORD       dwItem,
    IN  TCHAR       cDelimiter

);

BOOLEAN LoadPerfGrabMutex();

void
ReportLoadPerfEvent(
    IN  WORD    EventType,
    IN  DWORD   EventID,
    IN  DWORD   dwDataCount,
    IN  DWORD   dwData1,
    IN  DWORD   dwData2,
    IN  DWORD   dwData3,
    IN  DWORD   dwData4,
    IN  WORD    wStringCount,
    IN  LPWSTR  szString1,
    IN  LPWSTR  szString2,
    IN  LPWSTR  szString3
);

// defined in dumpload.c

DWORD
BackupPerfRegistryToFileW (
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szCommentString
);

DWORD
RestorePerfRegistryFromFileW (
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szLangId
);

extern LPCTSTR NamesKey;
extern LPCTSTR DefaultLangId;
extern LPCTSTR DefaultLangTag;
extern LPCTSTR Counters;
extern LPCTSTR Help;
extern LPCTSTR LastHelp;
extern LPCTSTR LastCounter;
extern LPCTSTR FirstHelp;
extern LPCTSTR cszFirstCounter;
extern LPCTSTR Busy;
extern LPCTSTR Slash;
extern LPCTSTR BlankString;
extern LPCTSTR DriverPathRoot;
extern LPCTSTR Performance;
extern LPCTSTR CounterNameStr;
extern LPCTSTR HelpNameStr;
extern LPCTSTR AddCounterNameStr;
extern LPCTSTR AddHelpNameStr;
extern LPCTSTR VersionStr;
extern LPCTSTR szObjectList;
extern LPCTSTR szLibraryValidationCode;
extern LPCTSTR szDisplayName;
extern LPCTSTR szPerfIniPath;

extern HANDLE hEventLog; 
extern HANDLE hLoadPerfMutex; 

#endif  // _LODCTR_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\makefile.inc ===
!IFNDEF BUILDMSG
BUILDMSG=
!ENDIF

!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

.\ldprfmsg.h .\msg00001.bin .\ldprfmsg.rc : .\ldprfmsg.mc
	mc -v  ldprfmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\dumpload.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    dumpload.c

Abstract:

    functions to dump and load the contents of the performance related registry
	entries

Author:

    Bob Watson (bobw) 13 Jun 99

Revision History:



--*/
#ifndef     UNICODE
#define     UNICODE     1
#endif

#ifndef     _UNICODE
#define     _UNICODE    1
#endif
//
//  "C" Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <loadperf.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  application include files
//
#include "winperfp.h"
#include "common.h"
#include "ldprfmsg.h"

static const WCHAR  cszServiceKeyName[] = {L"SYSTEM\\CurrentControlSet\\Services"};
static const WCHAR  cszPerflibKeyName[] = {L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"};
static const WCHAR  cszLastCounter[] = {L"Last Counter"};
static const WCHAR  cszFirstHelp[] = {L"First Help"};
static const WCHAR  cszLastHelp[] = {L"Last Help"};
static const WCHAR  cszBaseIndex[] = {L"Base Index"};
static const WCHAR  cszPerformance[] = {L"\\Performance"};
static const WCHAR  cszDisablePerformanceCounters[] = {L"Disable Performance Counters"};

// headings in save file
static const WCHAR  cszFmtSectionHeader[] = {L"\r\n\r\n[%s]"};
static const WCHAR  cszFmtServiceSectionHeader[] = {L"\r\n\r\n[PERF_%s]"};
static const WCHAR  cszFmtServiceSectionName[] = {L"PERF_%s"};
static const WCHAR  cszFmtStringSectionHeader[] = {L"\r\n\r\n[PerfStrings_%s]"};
static const WCHAR  cszFmtExtCtrString[] = {L"\r\n%d=%s"};
static const WCHAR  cszFmtDecimalParam[] = {L"\r\n%s=%d"};
static const WCHAR  cszFmtNoParam[] = {L"\r\n%s="};

static const WCHAR  cszExtensiblePerfStrings[] = {L"Strings"};
static const WCHAR  cszPerfCounterServices[] = {L"PerfCounterServices"};
static const WCHAR  cszNoPerfCounterServices[] = {L"NoPerfCounterServices"};
static const WCHAR  cszPerflib[] = {L"Perflib"};

// external forward definitions
LPWSTR
*BuildNameTable(
    HKEY    hKeyRegistry,   // handle to registry db with counter names
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
);

DWORD
UpdatePerfNameFilesX (
	IN  LPCWSTR     szNewCtrFilePath,   // data file with new base counter strings
	IN  LPCWSTR     szNewHlpFilePath,   // data file with new base counter strings
    IN 	LPWSTR      szLanguageID,       // Lang ID to update
    IN  ULONG_PTR   dwFlags             // flags
);

DWORD
DumpNameTable (
    IN  HANDLE  hOutputFile,
    IN  LPCWSTR szLangId,
    IN  LPCWSTR *pszNameTable,
    IN  DWORD   dwStartIndex,
    IN  DWORD   dwLastIndex
)
{
    DWORD   dwStatus       = ERROR_SUCCESS;
    DWORD   ndx            = 0;
    LPWSTR  szOutputBuffer = NULL;
    DWORD   dwBufSize      = 4096;
    DWORD   dwSize         = 0;
    DWORD   dwSizeWritten  = 0;

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
           __LINE__,
           LOADPERF_DUMPNAMETABLE,
           ARG_DEF(ARG_TYPE_WSTR, 1),
           ERROR_SUCCESS,
           TRACE_WSTR(szLangId),
           TRACE_DWORD(dwStartIndex),
           TRACE_DWORD(dwLastIndex),
           NULL));

    szOutputBuffer = MemoryAllocate(sizeof(WCHAR) * dwBufSize);
    if (szOutputBuffer == NULL) {
        dwStatus = GetLastError();
        goto Cleanup;
    }
    ZeroMemory(szOutputBuffer, dwBufSize * sizeof(WCHAR));

    dwSize  = swprintf(szOutputBuffer, cszFmtStringSectionHeader, szLangId);
    dwSize *= sizeof(WCHAR);
    WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);

    for (ndx = dwStartIndex; ndx <= dwLastIndex; ndx++) {
        if (pszNameTable[ndx] != NULL) {
            if (dwBufSize <= (DWORD) (lstrlenW(pszNameTable[ndx]) + 11)) {
                MemoryFree((LPVOID) szOutputBuffer);
                dwBufSize = (DWORD) (lstrlenW(pszNameTable[ndx]) + 11);
                szOutputBuffer = MemoryAllocate(dwBufSize * sizeof(WCHAR));
                if (szOutputBuffer == NULL) {
                    dwStatus = GetLastError();
                    goto Cleanup;
                }
            }

            ZeroMemory(szOutputBuffer, dwBufSize * sizeof(WCHAR));
            dwSize  = swprintf(szOutputBuffer, cszFmtExtCtrString, ndx, pszNameTable[ndx]);
            dwSize *= sizeof(WCHAR);
            WriteFile(hOutputFile, szOutputBuffer, dwSize, & dwSizeWritten, NULL);
        }
    }

Cleanup:
    if (szOutputBuffer != NULL) MemoryFree((LPVOID) szOutputBuffer);
    return dwStatus;
}

DWORD
DumpPerfServiceEntries (
    IN  HANDLE  hOutputFile,
    IN  LPCWSTR szServiceName
)
{
    LONG    lStatus = ERROR_SUCCESS;
    WCHAR   szPerfSubKeyName[MAX_PATH+20];
    HKEY    hKeyPerformance;
    HKEY    hKeyServices = NULL;
    DWORD   dwItemSize, dwType, dwValue;
    DWORD   dwRegAccessMask;
    DWORD   dwRetStatus = ERROR_SUCCESS;

    DWORD   dwSize, dwSizeWritten;
    WCHAR   szOutputBuffer[4096];

    // try read-only then
    dwRegAccessMask = KEY_READ;
    __try {
        lStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                cszServiceKeyName,
                                0L,
                                dwRegAccessMask,
                                & hKeyServices);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus == ERROR_SUCCESS) {
        //try to open the perfkey under this key.
        lstrcpy (szPerfSubKeyName, szServiceName);
        lstrcat (szPerfSubKeyName, cszPerformance);

        __try {
            lStatus = RegOpenKeyExW(
                        hKeyServices,
                        szPerfSubKeyName,
                        0L,
                        dwRegAccessMask,
                        & hKeyPerformance);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
        if (lStatus == ERROR_SUCCESS) {
            // key found so service has perf data
            ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
            dwSize = swprintf (szOutputBuffer, cszFmtServiceSectionHeader, szServiceName);
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);

            // now check to see if the strings have been loaded
            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            __try {
                lStatus = RegQueryValueExW(
                                hKeyPerformance,
                                cszFirstCounter,
                                NULL,
                                & dwType,
                                (LPBYTE) & dwValue,
                                & dwItemSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszFirstCounter),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszFirstCounter, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            __try {
                lStatus = RegQueryValueExW(
                                hKeyPerformance,
                                cszFirstHelp,
                                NULL,
                                & dwType,
                                (LPBYTE) & dwValue,
                                & dwItemSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszFirstHelp),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszFirstHelp, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            __try {
                lStatus = RegQueryValueExW(
                                hKeyPerformance,
                                cszLastCounter,
                                NULL,
                                & dwType,
                                (LPBYTE) & dwValue,
                                & dwItemSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszLastCounter),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszLastCounter, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            __try {
                lStatus = RegQueryValueExW(
                                hKeyPerformance,
                                cszLastHelp,
                                NULL,
                                & dwType,
                                (LPBYTE) & dwValue,
                                & dwItemSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszLastHelp),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszLastHelp, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            __try {
                lStatus = RegQueryValueExW(
                                hKeyPerformance,
                                cszDisablePerformanceCounters,
                                NULL,
                                & dwType,
                                (LPBYTE) & dwValue,
                                & dwItemSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszDisablePerformanceCounters),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszDisablePerformanceCounters, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            RegCloseKey (hKeyPerformance);
        } else {
            dwRetStatus = lStatus;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   NULL));
        }

        RegCloseKey (hKeyServices);
    }
    else {
        dwRetStatus = lStatus;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFSERVICEENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               lStatus,
               TRACE_WSTR(cszServiceKeyName),
               NULL));
    }

    return dwRetStatus;
}

DWORD
DumpPerflibEntries (
    IN  HANDLE  hOutputFile,
    IN  LPDWORD pdwFirstExtCtrIndex

)
{
    HKEY    hKeyPerflib = NULL;
    DWORD   dwStatus;
    DWORD   dwItemSize, dwType, dwValue;

    DWORD   dwSize, dwSizeWritten;
    WCHAR   szOutputBuffer[4096];

    __try {
        dwStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                 cszPerflibKeyName,
                                 0L,
                                 KEY_READ,
                                 & hKeyPerflib);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = GetExceptionCode();
    }
    if (dwStatus == ERROR_SUCCESS) {
        ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
        dwSize = swprintf (szOutputBuffer, cszFmtSectionHeader, cszPerflib);
        dwSize *= sizeof (WCHAR);
        WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(cszPerflibKeyName),
               NULL));
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof (dwValue);
        __try {
            dwStatus = RegQueryValueEx(
                            hKeyPerflib,
                            cszBaseIndex,
                            NULL,
                            & dwType,
                            (LPBYTE) & dwValue,
                            & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(cszBaseIndex),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
            dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszBaseIndex, dwValue);
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            *pdwFirstExtCtrIndex = dwValue + 1;
        }
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof (dwValue);
        __try {
            dwStatus = RegQueryValueEx(
                            hKeyPerflib,
                            cszLastCounter,
                            NULL,
                            & dwType,
                            (LPBYTE) & dwValue,
                            & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(cszLastCounter),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
            dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszLastCounter, dwValue);
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
        }
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof (dwValue);
        __try {
            dwStatus = RegQueryValueEx(
                            hKeyPerflib,
                            cszLastHelp,
                            NULL,
                            & dwType,
                            (LPBYTE) & dwValue,
                            & dwItemSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(cszLastHelp),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            ZeroMemory(szOutputBuffer, 4096 * sizeof(WCHAR));
            dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszLastHelp, dwValue);
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
        }
    }

    if (hKeyPerflib != NULL) RegCloseKey (hKeyPerflib);

    return dwStatus;
}


DWORD
BuildServiceLists (
    IN  LPWSTR  mszPerfServiceList,
    IN  LPDWORD pcchPerfServiceListSize,
    IN  LPWSTR  mszNoPerfServiceList,
    IN  LPDWORD pcchNoPerfServiceListSize
)
{
    LONG    lStatus = ERROR_SUCCESS;
    LONG    lEnumStatus = ERROR_SUCCESS;
    DWORD   dwServiceIndex = 0;
    WCHAR   szServiceSubKeyName[MAX_PATH];
    WCHAR   szPerfSubKeyName[MAX_PATH+20];
    DWORD   dwNameSize = MAX_PATH;
    HKEY    hKeyPerformance;
    HKEY    hKeyServices = NULL;
    DWORD   dwItemSize, dwType, dwValue;
    DWORD   dwRegAccessMask;
    DWORD   bServiceHasPerfCounters;
    DWORD   dwRetStatus = ERROR_SUCCESS;

    LPWSTR  szNextNoPerfChar, szNextPerfChar;
    DWORD   dwNoPerfSizeRem, dwPerfSizeRem;
    DWORD   dwPerfSizeUsed = 0, dwNoPerfSizeUsed = 0;

    // try read-only then
    dwRegAccessMask = KEY_READ;
    __try {
        lStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                cszServiceKeyName,
                                0L,
                                dwRegAccessMask,
                                & hKeyServices);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus == ERROR_SUCCESS) {
        szNextNoPerfChar = mszNoPerfServiceList;
        szNextPerfChar = mszPerfServiceList;
        dwNoPerfSizeRem = *pcchPerfServiceListSize;
        dwPerfSizeRem = *pcchNoPerfServiceListSize;
        dwPerfSizeUsed = 0;
        dwNoPerfSizeUsed = 0;

        while ((lEnumStatus = RegEnumKeyExW (
            hKeyServices,
            dwServiceIndex,
            szServiceSubKeyName,
            &dwNameSize,
            NULL,
            NULL,
            NULL,
            NULL)) == ERROR_SUCCESS) {

            //try to open the perfkey under this key.
            lstrcpy (szPerfSubKeyName, szServiceSubKeyName);
            lstrcat (szPerfSubKeyName, cszPerformance);

            __try {
                lStatus = RegOpenKeyExW(
                            hKeyServices,
                            szPerfSubKeyName,
                            0L,
                            dwRegAccessMask,
                            & hKeyPerformance);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus == ERROR_SUCCESS) {
                // key found so service has perf data
                // now check to see if the strings have been loaded
                dwType = dwValue = 0;
                dwItemSize = sizeof (dwValue);
                __try {
                    lStatus = RegQueryValueExW(
                                    hKeyPerformance,
                                    cszFirstCounter,
                                    NULL,
                                    & dwType,
                                    (LPBYTE) & dwValue,
                                    & dwItemSize);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    lStatus = GetExceptionCode();
                }
                if ((lStatus == ERROR_SUCCESS) &&
                    ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                    bServiceHasPerfCounters = TRUE;
                } else {
                    bServiceHasPerfCounters = FALSE;
                }

                RegCloseKey (hKeyPerformance);
            } else {
                // key not found so service doesn't have perfdata
                bServiceHasPerfCounters = FALSE;
            }

            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_BUILDSERVICELISTS,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   lStatus,
                   TRACE_WSTR(szServiceSubKeyName),
                   TRACE_DWORD(bServiceHasPerfCounters),
                   NULL));

            if (bServiceHasPerfCounters != FALSE) {
                // add to the perf service list
                if ((dwNameSize + 1)< dwPerfSizeRem) {
                    // add to list
                    lstrcpyW (szNextPerfChar, szServiceSubKeyName);
                    szNextPerfChar += dwNameSize;
                    *szNextPerfChar = 0;
                    szNextPerfChar++;
                    dwPerfSizeRem -= dwNameSize + 1;
                } else {
                    dwRetStatus = ERROR_MORE_DATA;
                }
                dwPerfSizeUsed += dwNameSize + 1;
            } else {
                // add to the no perf list
                if ((dwNameSize + 1) < dwNoPerfSizeRem) {
                    // add to list
                    lstrcpyW (szNextNoPerfChar, szServiceSubKeyName);
                    szNextNoPerfChar += dwNameSize;
                    *szNextNoPerfChar = 0;
                    szNextNoPerfChar++;
                    dwNoPerfSizeRem -= dwNameSize + 1;
                } else {
                    dwRetStatus = ERROR_MORE_DATA;
                }
                dwNoPerfSizeUsed += dwNameSize + 1;
            }
            // reset for next loop
            dwServiceIndex++;
            dwNameSize = MAX_PATH;
        }

        // zero term the MSZ
        if (1 < dwPerfSizeRem) {
            *szNextPerfChar = 0;
            szNextPerfChar++;
            dwPerfSizeRem -= 1;
        } else {
            dwRetStatus = ERROR_MORE_DATA;
        }
        dwPerfSizeUsed += 1;

        // zero term the no perf list
        if (1 < dwNoPerfSizeRem) {
            // add to list
            *szNextNoPerfChar = 0;
            szNextNoPerfChar++;
            dwNoPerfSizeRem -= 1;
        } else {
            dwRetStatus = ERROR_MORE_DATA;
        }
        dwNoPerfSizeUsed += 1;
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_BUILDSERVICELISTS,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               lStatus,
               TRACE_WSTR(cszServiceKeyName),
               NULL));
    }

    if (hKeyServices != NULL) RegCloseKey (hKeyServices);

    *pcchPerfServiceListSize = dwPerfSizeUsed;
    *pcchNoPerfServiceListSize = dwNoPerfSizeUsed;

    return dwRetStatus;
}


DWORD
BackupPerfRegistryToFileW (
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szCommentString
)
{
    HANDLE  hOutFile;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szNewFileName = NULL;
    DWORD   dwNewFileNameLen;
    DWORD   dwOrigFileNameLen;
    DWORD   dwFileNameSN;

    LPWSTR  mszPerfServiceList = NULL;
    DWORD   dwPerfServiceListSize = 0;
    LPWSTR  mszNoPerfServiceList = NULL;
    DWORD   dwNoPerfServiceListSize = 0;

    LPWSTR  *lpCounterText = NULL;
    DWORD   dwLastElement = 0;
    DWORD   dwFirstExtCtrIndex = 0;

    LPWSTR  szThisServiceName;


    DBG_UNREFERENCED_PARAMETER (szCommentString);

    WinPerfStartTrace(NULL);

    // open output file
    hOutFile = CreateFileW (
        szFileName,
        GENERIC_WRITE,
        0,  // no sharing
        NULL,   // default security
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    // if the file open failed
    if (hOutFile == INVALID_HANDLE_VALUE) {
        // see if it's because the file already exists
        dwStatus = GetLastError();
        if (dwStatus == ERROR_FILE_EXISTS) {
            // then try appending a serial number to the name
            dwOrigFileNameLen = lstrlenW (szFileName);
            dwNewFileNameLen = dwOrigFileNameLen + 4;
            szNewFileName = MemoryAllocate(
                        (dwNewFileNameLen +1) * sizeof(WCHAR));
            if (szNewFileName != NULL) {
                lstrcpyW (szNewFileName, szFileName);
                for (dwFileNameSN = 1; dwFileNameSN < 1000; dwFileNameSN++) {
                    swprintf (&szNewFileName[dwOrigFileNameLen],
                        (LPCWSTR)L"_%3.3d", dwFileNameSN);
                    hOutFile = CreateFileW (
                        szNewFileName,
                        GENERIC_WRITE,
                        0,  // no sharing
                        NULL,   // default security
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

                    // if the file open failed
                    if (hOutFile == INVALID_HANDLE_VALUE) {
                        dwStatus = GetLastError();
                        if (dwStatus != ERROR_FILE_EXISTS) {
                            // some other error occurred so bail out
                            break;
                        } else {
                            continue; // with the next try
                        }
                    } else {
                        // found one not in use so continue on
                        dwStatus = ERROR_SUCCESS;
                        break;
                    }
                }
            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }
        }
    } else {
        // file opened so continue
        dwStatus = ERROR_SUCCESS;
    }

    if (dwStatus == ERROR_SUCCESS) {
        // dump perflib key entires
        dwStatus = DumpPerflibEntries (hOutFile, &dwFirstExtCtrIndex);
    }

    if (dwStatus == ERROR_SUCCESS) {
        do {
            if (mszPerfServiceList != NULL) {
                MemoryFree(mszPerfServiceList);
                mszPerfServiceList = NULL;
            }

            if (mszNoPerfServiceList != NULL) {
                MemoryFree(mszNoPerfServiceList);
                mszNoPerfServiceList = NULL;
            }

            // build service lists
            dwPerfServiceListSize += 32768;
            dwNoPerfServiceListSize += 65536;
            mszPerfServiceList = MemoryAllocate(
                    (dwPerfServiceListSize) * sizeof(WCHAR));

            mszNoPerfServiceList = MemoryAllocate(
                    (dwNoPerfServiceListSize) * sizeof(WCHAR));

            if ((mszNoPerfServiceList == NULL) || (mszPerfServiceList  == NULL)) {
                dwStatus = ERROR_OUTOFMEMORY;
                break;
            }

            if (dwStatus == ERROR_SUCCESS) {
                dwStatus = BuildServiceLists (
                    mszPerfServiceList,
                    &dwPerfServiceListSize,
                    mszNoPerfServiceList,
                    &dwNoPerfServiceListSize);
                if (dwStatus == ERROR_SUCCESS) break; // and continue on
            }
        } while (dwPerfServiceListSize < 4194304);
    }

    // dump service entries for those services with perf counters
    if (dwStatus == ERROR_SUCCESS) {
        for (szThisServiceName = mszPerfServiceList;
            *szThisServiceName != 0;
            szThisServiceName += lstrlenW(szThisServiceName)+1) {

            dwStatus = DumpPerfServiceEntries (
                hOutFile,
                szThisServiceName);

            if (dwStatus != ERROR_SUCCESS) break;
        }
    }

    // dump perf string entries
    if (dwStatus == ERROR_SUCCESS) {
        WCHAR   szLangId[8];
        DWORD   dwIndex      = 0;
        DWORD   dwBufferSize;
        HKEY    hPerflibRoot = NULL;

        __try {
            dwStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                     NamesKey,
                                     RESERVED,
                                     KEY_READ,
                                     & hPerflibRoot);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwStatus = GetExceptionCode();
        }
        while (dwStatus == ERROR_SUCCESS) {
            dwBufferSize = 8;
            ZeroMemory(szLangId, 8 * sizeof(WCHAR));
            dwStatus = RegEnumKeyExW(hPerflibRoot,
                                     dwIndex,
                                     szLangId,
                                     & dwBufferSize,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
            if (dwStatus == ERROR_SUCCESS) {
                lpCounterText = BuildNameTable(HKEY_LOCAL_MACHINE,
                                               (LPWSTR) szLangId,		
                                               & dwLastElement);
                if (lpCounterText != NULL) {
                    __try {
                        dwStatus = DumpNameTable(hOutFile,
                                                 szLangId,
                                                 lpCounterText,
                                                 0,
                                                 dwLastElement);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        dwStatus = GetExceptionCode();
                        TRACE((WINPERF_DBG_TRACE_ERROR),
                              (& LoadPerfGuid,
                               __LINE__,
                               LOADPERF_BACKUPPERFREGISTRYTOFILEW,
                               ARG_DEF(ARG_TYPE_WSTR, 1),
                               dwStatus,
                               TRACE_WSTR(szLangId),
                               TRACE_DWORD(dwLastElement),
                               NULL));
                    }
                    MemoryFree(lpCounterText);
                    lpCounterText = NULL;
                }
                else {
                    dwStatus = GetLastError();
                }
            }
            dwIndex ++;
        }
        if (dwStatus == ERROR_NO_MORE_ITEMS) dwStatus = ERROR_SUCCESS;
        if (hPerflibRoot != NULL) RegCloseKey(hPerflibRoot);
    }

    // free buffers
    if (lpCounterText != NULL) {
        MemoryFree(lpCounterText);
        lpCounterText = NULL;
    }

    if (mszNoPerfServiceList != NULL) {
        MemoryFree(mszNoPerfServiceList);
        mszNoPerfServiceList = NULL;
    }

    if (mszPerfServiceList != NULL) {
        MemoryFree(mszPerfServiceList);
        mszPerfServiceList = NULL;
    }

    if (szNewFileName  != NULL) {
        MemoryFree(szNewFileName);
        szNewFileName = NULL;
    }

    // close file handles
    if (hOutFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hOutFile);
    }

    return dwStatus;
}

DWORD
RestorePerfRegistryFromFileW (
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szLangId
)
{
    LONG    lStatus = ERROR_SUCCESS;
    LONG    lEnumStatus = ERROR_SUCCESS;
    DWORD   dwServiceIndex = 0;
    WCHAR   szServiceSubKeyName[MAX_PATH];
    WCHAR   szPerfSubKeyName[MAX_PATH+20];
    DWORD   dwNameSize = MAX_PATH;
    HKEY    hKeyPerformance;
    HKEY    hKeyServices = NULL;
    HKEY    hKeyPerflib = NULL;
    DWORD   dwItemSize;
    DWORD   dwRegAccessMask;
    DWORD   dwRetStatus = ERROR_SUCCESS;
    UINT    nValue;
    DWORD   dwnValue;
    BOOL    bServiceRegistryOk = TRUE;

    WCHAR   wPerfSection[MAX_PATH * 2];

    WCHAR   szLocalLangId[8];

    WinPerfStartTrace(NULL);

    __try {
        lStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                cszServiceKeyName,
                                0L,
                                KEY_READ,
                                & hKeyServices);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus == ERROR_SUCCESS) {
        // enum service list
        while ((lEnumStatus = RegEnumKeyExW (
            hKeyServices,
            dwServiceIndex,
            szServiceSubKeyName,
            &dwNameSize,
            NULL,
            NULL,
            NULL,
            NULL)) == ERROR_SUCCESS) {

            //try to open the perfkey under this key.
            lstrcpy (szPerfSubKeyName, szServiceSubKeyName);
            lstrcat (szPerfSubKeyName, cszPerformance);

            bServiceRegistryOk = TRUE;
            dwRegAccessMask = KEY_READ | KEY_WRITE;
            // look for a performance subkey
            __try {
                lStatus = RegOpenKeyExW(
                            hKeyServices,
                            szPerfSubKeyName,
                            0L,
                            dwRegAccessMask,
                            & hKeyPerformance);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus == ERROR_SUCCESS) {
                // key found so service has perf data
                // if performance subkey then
                dwItemSize = swprintf (wPerfSection,
                    cszFmtServiceSectionName, szServiceSubKeyName);
                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                        wPerfSection,
                        cszFirstCounter,
                        -1,
                        szFileName);

                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    __try {
                        lStatus = RegSetValueExW(hKeyPerformance,
                                                 cszFirstCounter,
                                                 0L,
                                                 REG_DWORD,
                                                 (const BYTE *) & nValue,
                                                 sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           lStatus,
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(cszFirstCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                } else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                        wPerfSection,
                        cszFirstHelp,
                        -1,
                        szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    __try {
                        lStatus = RegSetValueExW(hKeyPerformance,
                                                 cszFirstHelp,
                                                 0L,
                                                 REG_DWORD,
                                                 (const BYTE *)&nValue,
                                                 sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           lStatus,
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(cszFirstHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                } else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                    wPerfSection,
                    cszLastCounter,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    __try {
                        lStatus = RegSetValueExW(hKeyPerformance,
                                                 cszLastCounter,
                                                 0L,
                                                 REG_DWORD,
                                                 (const BYTE *)&nValue,
                                                 sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           lStatus,
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(cszLastCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                } else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                    wPerfSection,
                    cszLastHelp,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    __try {
                        lStatus = RegSetValueExW(hKeyPerformance,
                                                 cszLastHelp,
                                                 0L,
                                                 REG_DWORD,
                                                 (const BYTE *) & nValue,
                                                 sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           lStatus,
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(cszLastHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                } else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                if (!bServiceRegistryOk) {
                    // an error occurred so delete the first/last counter/help values
                    RegDeleteValue (hKeyPerformance, cszFirstCounter);
                    RegDeleteValue (hKeyPerformance, cszFirstHelp);
                    RegDeleteValue (hKeyPerformance, cszLastCounter);
                    RegDeleteValue (hKeyPerformance, cszLastHelp);
                } // else continiue

                RegCloseKey (hKeyPerformance);
            } // else this service has no perf data so skip
            else {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                       ARG_DEF(ARG_TYPE_WSTR, 1),
                       lStatus,
                       TRACE_WSTR(szServiceSubKeyName),
                       NULL));
            }

            // reset for next loop
            dwServiceIndex++;
            dwNameSize = MAX_PATH;
        } // end enum service list
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               lStatus,
               TRACE_WSTR(cszServiceKeyName),
               NULL));
    }

    if (hKeyServices != NULL) RegCloseKey (hKeyServices);

    if (dwRetStatus == ERROR_SUCCESS) {
        __try {
            lStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                    cszPerflibKeyName,
                                    RESERVED,
                                    KEY_ALL_ACCESS,
                                    & hKeyPerflib);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
        if (lStatus != ERROR_SUCCESS) {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   lStatus,
                   TRACE_WSTR(cszPerflibKeyName),
                   NULL));
            dwRetStatus = lStatus;
        }

        if (szLangId != NULL) {
            // merge registry string values:
            lstrcpyW(szLocalLangId, szLangId);
            dwRetStatus = UpdatePerfNameFilesX(szFileName,
                                               NULL,
                                               szLocalLangId,
                                               LODCTR_UPNF_RESTORE);
        }
        else if (lStatus == ERROR_SUCCESS) {
            DWORD dwIndex = 0;
            DWORD dwBufferSize;

            while (dwRetStatus == ERROR_SUCCESS) {
                dwBufferSize = 8;
                ZeroMemory(szLocalLangId, 8 * sizeof(WCHAR));
                dwRetStatus = RegEnumKeyExW(hKeyPerflib,
                                            dwIndex,
                                            szLocalLangId,
                                            & dwBufferSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);
                if (dwRetStatus == ERROR_SUCCESS) {
                    dwRetStatus = UpdatePerfNameFilesX(szFileName,
                                                       NULL,
                                                       szLocalLangId,
                                                       LODCTR_UPNF_RESTORE);
                }
                dwIndex ++;
            }

            if (dwRetStatus == ERROR_NO_MORE_ITEMS) {
                dwRetStatus = ERROR_SUCCESS;
            }
        }

        if (dwRetStatus == ERROR_SUCCESS) {
            // update the keys in the registry

            if (lStatus == ERROR_SUCCESS) {
               nValue = GetPrivateProfileIntW (
                    cszPerflib,
                    cszLastCounter,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    __try {
                        lStatus = RegSetValueExW(hKeyPerflib,
                                                 cszLastCounter,
                                                 0L,
                                                 REG_DWORD,
                                                 (const BYTE *) & nValue,
                                                 sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           lStatus,
                           TRACE_WSTR(cszLastCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

            if (lStatus == ERROR_SUCCESS) {
                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                    cszPerflib,
                    cszLastHelp,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    __try {
                        lStatus = RegSetValueExW(hKeyPerflib,
                                                 cszLastHelp,
                                                 0L,
                                                 REG_DWORD,
                                                 (const BYTE *) & nValue,
                                                 sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           lStatus,
                           TRACE_WSTR(cszLastHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

            if (lStatus == ERROR_SUCCESS) {
                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                    cszPerflib,
                    cszBaseIndex,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    __try {
                        lStatus = RegSetValueExW(hKeyPerflib,
                                                 cszBaseIndex,
                                                 0L,
                                                 REG_DWORD,
                                                 (const BYTE *) & nValue,
                                                 sizeof(nValue));
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           lStatus,
                           TRACE_WSTR(cszBaseIndex),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

            if (hKeyPerflib != NULL) RegCloseKey (hKeyPerflib);
        }
        dwRetStatus = lStatus;
    }

    return dwRetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\mofcomp.h ===
#ifndef _LODCTR_MOFCOMP_H
#define _LODCTR_MOFCOMP_H

#ifdef __cplusplus
extern "C" {
#endif

#define WMI_LODCTR_EVENT    1
#define WMI_UNLODCTR_EVENT  2


DWORD SignalWmiWithNewData ( DWORD  dwEventId );
DWORD LodctrCompileMofFile ( LPCWSTR szComputerName, LPCWSTR szMofFileName );
DWORD LodctrCompileMofBuffer ( LPCWSTR szComputerName, LPVOID pMofBuffer, DWORD dwBufSize );

#ifdef __cplusplus
}
#endif 
#endif  //_LODCTR_MOFCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\lodctr.h ===
/*++

lodctr.h

    Include file for lodctr 
    
--*/
#ifndef _LODCTR_H
#define _LODCTR_H

#define cC          TEXT('C')
#define cH          TEXT('H')
#define cSpace      TEXT(' ')
#define cEquals     TEXT('=')
#define cQuestion   TEXT('?')
#define cBackslash  TEXT('\\')
#define cUnderscore TEXT('_')
#define cHyphen		TEXT('-')
#define cSlash		TEXT('/')
#define cM			TEXT('M')
#define cm			TEXT('m')


#define TYPE_HELP   1
#define TYPE_NAME   2


#define LC_CMD_HELP_1           201
#define LC_CMD_HELP_2           202
#define LC_CMD_HELP_3           203
#define LC_CMD_HELP_4           204
#define LC_CMD_HELP_5           205
#define LC_CMD_HELP_6           206
#define LC_CMD_HELP_7           207
#define LC_CMD_HELP_8           208
#define LC_CMD_HELP_9           209 
#define LC_CMD_HELP_10          210
#define LC_CMD_HELP_11          211
#define LC_CMD_HELP_12          212
#define LC_CMD_HELP_13          213
#define LC_CMD_HELP_14          214
#define LC_CMD_HELP_15          215
#define LC_FIRST_CMD_HELP   LC_CMD_HELP_1
#define LC_LAST_CMD_HELP    LC_CMD_HELP_15

#define LC_DEVNAME_ERR_1        107
#define LC_DEVNAME_ERR_2        108

#define LC_NO_INIFILE           109
                  
#define LC_LANGLIST_ERR         110

#define LC_ERR_OPEN_INCLUDE     111

#define LC_ERR_OPEN_DRIVERPERF1 113
#define LC_ERR_OPEN_DRIVERPERF2 114
#define LC_ERR_OPEN_PERFLIB     115
#define LC_ERR_READLASTPERFLIB  116
#define LC_ERR_ALREADY_IN       117
#define LC_ERR_UNABLESETBUSY    118
#define LC_ERRO_READBASEINDEX   119

#define LC_BAD_KEY              120
#define LC_LANGNOTFOUND         121
#define LC_ERR_ADDENTRY         122
#define LC_ERRADDTOLANG         123
#define LC_UNABLESORTTABLES     124
#define LC_UNABLEOPENLANG       125
#define LC_UNABLESETVALUE       126
#define LC_ERR_UPDATELANG       127
#define LC_PERFLIBISBUSY        128
#define LC_CONNECT_PROBLEM      129

#endif  // _LODCTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\unlodctr.h ===
/*++

unlodctr.h

    Definitions that are specific to the counter unloader
   
Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#ifndef _UNLODCTR_H_
#define _UNLODCTR_H_

// resource file constants
#define UC_CMD_HELP_1       401
#define UC_CMD_HELP_2       402
#define UC_CMD_HELP_3       403
#define UC_CMD_HELP_4       404
#define UC_CMD_HELP_5       405
#define UC_CMD_HELP_6       406
#define UC_CMD_HELP_7       407
#define UC_CMD_HELP_8       408
#define UC_CMD_HELP_9       409
#define UC_CMD_HELP_10      410
#define UC_CMD_HELP_11      411
#define UC_FIRST_CMD_HELP   UC_CMD_HELP_1
#define UC_LAST_CMD_HELP    UC_CMD_HELP_11
                           
#define UC_DRIVERNOTFOUND   311
#define UC_NOTINSTALLED     312
#define UC_REMOVINGDRIVER   313
#define UC_UNABLEOPENKEY    314
#define UC_UNABLESETVALUE   315
#define UC_UNABLEREADVALUE  316
#define UC_DOINGLANG        318
#define UC_UNABLELOADLANG   320 
#define UC_CONNECT_PROBLEM  322
#define UC_BAD_DRIVER_NAME  323

#endif // _UNLODCTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\lodctr.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lodctr.c

Abstract:

    Program to read the contents of the file specified in the command line
    and update the registry accordingly

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

    a-robw  25-Feb-93   revised calls to make it compile as a UNICODE or
            an ANSI app.

    Bob Watson (bobw)   10 Mar 99 added event log messages


--*/
#ifndef     UNICODE
#define     UNICODE     1
#endif

#ifndef     _UNICODE
#define     _UNICODE    1
#endif

#ifdef      _LODCTR_DBG_OUTPUT
#undef      _LODCTR_DBG_OUTPUT
#endif
//#define      _LODCTR_DBG_OUTPUT

//
//  "C" Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>
#include <assert.h>
//
//  Windows Include files
//
#include <windows.h>
#define __LOADPERF__
#include <loadperf.h>
#include <winperf.h>
#include <tchar.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  application include files
//
#include "winperfp.h"
#include "common.h"
#include "lodctr.h"
#include "wbemutil.h"
#include "mofcomp.h"
#include "ldprfmsg.h"

typedef struct _DllValidationData {
    FILETIME    CreationDate;
    LONGLONG    FileSize;
} DllValidationData, *pDllValidationData;

#define  OLD_VERSION 0x010000
#define  MAX_PROFILE_BUFFER 65536

static DWORD    dwSystemVersion;
static DWORD    dwFileSize;
static TCHAR    ComputerName[FILE_NAME_BUFFER_SIZE];
static TCHAR    szServiceName[MAX_PATH];
static TCHAR    szServiceDisplayName[MAX_PATH];
static HKEY     hPerfData;
static BOOL     bQuietMode = TRUE;     // quiet means no _tprintf's

// string constants
static const TCHAR  szDataFileRoot[] = {TEXT("%systemroot%\\system32\\Perf")};
static const TCHAR  szDatExt[] = {TEXT(".DAT")};
static const TCHAR  szBakExt[] = {TEXT(".BAK")};
static const TCHAR  szInfo[] = {TEXT("info")};
static const TCHAR  szDriverName[] = {TEXT("drivername")};
static const TCHAR  szMofFileName[] = {TEXT("MofFile")};
static const TCHAR  szNotFound[] = {TEXT("NotFound")};
static const TCHAR  szLanguages[] = {TEXT("languages")};
static const TCHAR  sz009[] = {TEXT("009")};
static const TCHAR  szSymbolFile[] = {TEXT("symbolfile")};
static const TCHAR  szName[] = {TEXT("_NAME")};
static const TCHAR  szHelp[] = {TEXT("_HELP")};
static const TCHAR  sz_DFormat[] = {TEXT(" %d")};
static const TCHAR  szDFormat[] = {TEXT("%d")};
static const TCHAR  szText[] = {TEXT("text")};
static const TCHAR  szObjects[] = {TEXT("objects")};
static const TCHAR  szSpace[] = {TEXT(" ")};
static const TCHAR  MapFileName[] = {TEXT("Perflib Busy")};
static const TCHAR  szPerflib[] = {TEXT("Perflib")};
static const TCHAR  cszLibrary[] = {TEXT("Library")};
static const CHAR   caszOpen[] = {"Open"};
static const CHAR   caszCollect[] = {"Collect"};
static const CHAR   caszClose[] = {"Close"};
static const TCHAR  szBaseIndex[] = {TEXT("Base Index")};
static const TCHAR  szTrusted[] = {TEXT("Trusted")};
static const TCHAR  szDisablePerformanceCounters[] = {TEXT("Disable Performance Counters")};

#define  OLD_VERSION 0x010000
LPCWSTR VersionName = (LPCWSTR)L"Version";
LPCWSTR CounterName = (LPCWSTR)L"Counter ";
LPCWSTR HelpName = (LPCWSTR)L"Explain ";

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
    );

__inline
void __cdecl
OUTPUT_MESSAGE (
    const TCHAR* format,
    ...
)
{
    va_list args;
    va_start( args, format );

    if (!bQuietMode) {
        My_vfwprintf(stdout, format, args);
    }

    va_end(args);
}

__inline
static
PPERF_OBJECT_TYPE
NextObject (
    PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pObject + pObject->TotalByteLength));
}  // NextObject

__inline
static
PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->HeaderLength);
}

__inline
static
PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pCounterDef + pCounterDef->ByteLength);
}

DWORD
MakeTempFileName (
    LPCWSTR wszRoot,
    LPWSTR wszTempFilename
)
{
    FILETIME    ft;
    DWORD       dwReturn;
    WCHAR       wszLocalFilename[MAX_PATH];

    GetSystemTimeAsFileTime (&ft);
    dwReturn = (DWORD) swprintf(wszLocalFilename,
        (LPCWSTR)L"%%windir%%\\system32\\wbem\\%s_%8.8x%8.8x.mof",
        (wszRoot != NULL ? wszRoot : (LPCWSTR)L"LodCtr"),
        ft.dwHighDateTime, ft.dwLowDateTime);
    if (dwReturn > 0) {
        // expand env. vars
        dwReturn = ExpandEnvironmentStringsW (
            wszLocalFilename,
            wszTempFilename,
            MAX_PATH-1);
    }
    return dwReturn;
}

DWORD
WriteWideStringToAnsiFile (
    HANDLE  hFile,
    LPCWSTR szWideString,
    LPDWORD pdwLength
)
{
    BOOL    bStatus;
    DWORD    dwStatus;
    LPSTR    szAnsiString;
    DWORD    dwBytesWritten = 0;

    szAnsiString = MemoryAllocate(* pdwLength);
    if (szAnsiString != NULL) {
        wcstombs (szAnsiString, szWideString, *pdwLength);
        bStatus = WriteFile (
            hFile,
            (LPCVOID) szAnsiString,
            *pdwLength,
            &dwBytesWritten,
            NULL);

        if (bStatus) {
            *pdwLength = dwBytesWritten;
            dwStatus = ERROR_SUCCESS;
        } else {
            dwStatus = GetLastError();
        }
        MemoryFree (szAnsiString);
    } else {
        dwStatus = GetLastError();
    }
    return dwStatus;
}

LPWSTR
*BuildNameTable(
    HKEY    hKeyRegistry,   // handle to registry db with counter names
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
)
/*++

BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:

    pointer to an allocated table. (the caller must MemoryFree it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{

    LPWSTR  *lpReturnValue;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;

    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;
    DWORD   dwLastCounterId;

    DWORD   dwLastCounterIdUsed;
    DWORD   dwLastHelpIdUsed;

    HKEY    hKeyValue;
    HKEY    hKeyNames;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];

    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;
    hKeyValue = NULL;
    hKeyNames = NULL;

    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = (LPWSTR)DefaultLangId;
    }

    // open registry to get number of items for computing array size

    __try {
        lWin32Status = RegOpenKeyEx (
                        hKeyRegistry,
                        NamesKey,
                        RESERVED,
                        KEY_READ,
                        & hKeyValue);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(NamesKey),
                NULL));
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastHelpId);
    __try {
        lWin32Status = RegQueryValueEx (
                        hKeyValue,
                        LastHelp,
                        RESERVED,
                        & dwValueType,
                        (LPBYTE) & dwLastHelpId,
                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(LastHelp),
                NULL));
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastId);
    __try {
        lWin32Status = RegQueryValueEx (
                        hKeyValue,
                        LastCounter,
                        RESERVED,
                        & dwValueType,
                        (LPBYTE) & dwLastCounterId,
                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(LastCounter),
                NULL));
        goto BNT_BAILOUT;
    }

    dwLastId = (dwLastCounterId < dwLastHelpId)
             ? (dwLastHelpId) : (dwLastCounterId);

    // compute size of pointer array
    dwArraySize = (dwLastId + 1) * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    __try {
        lWin32Status = RegQueryValueEx (
                        hKeyValue,
                        VersionName,
                        RESERVED,
                        & dwValueType,
                        (LPBYTE) & dwSystemVersion,
                        & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
        // reset the error status
        lWin32Status = ERROR_SUCCESS;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LODCTR_BUILDNAMETABLE,
            0,
            lWin32Status,
            TRACE_DWORD(dwLastCounterId),
            TRACE_DWORD(dwLastHelpId),
            NULL));

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = MemoryAllocate (
            lstrlen(NamesKey) * sizeof (WCHAR) +
            lstrlen(Slash) * sizeof (WCHAR) +
            lstrlen(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));

        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpy (lpValueNameString, NamesKey);
        lstrcat (lpValueNameString, Slash);
        lstrcat (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyEx (
                    hKeyRegistry,
                    lpValueNameString,
                    RESERVED,
                    KEY_READ,
                    & hKeyNames);
    } else {
        if (ComputerName[0] == 0) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        } else {
            __try {
            lWin32Status = RegConnectRegistry(ComputerName,
                                              HKEY_PERFORMANCE_DATA,
                                              & hKeyNames);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lWin32Status = GetExceptionCode();
            }
        }
        lstrcpy (CounterNameBuffer, CounterName);
        lstrcat (CounterNameBuffer, lpszLangId);

        lstrcpy (HelpNameBuffer, HelpName);
        lstrcat (HelpNameBuffer, lpszLangId);
    }

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_ACCESS_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        goto BNT_BAILOUT;
    }
    dwBufferSize = 0;
    __try {
        lWin32Status = RegQueryValueEx (
                hKeyNames,
                dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
                RESERVED,
                & dwValueType,
                NULL,
                & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Counters),
                NULL));
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    __try {
        lWin32Status = RegQueryValueEx (
                hKeyNames,
                dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
                RESERVED,
                & dwValueType,
                NULL,
                & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Help),
                NULL));
        goto BNT_BAILOUT;
    }

    dwHelpSize = dwBufferSize;

    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        lWin32Status = ERROR_OUTOFMEMORY;
        SetLastError(lWin32Status);
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                1, __LINE__, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                0,
                ERROR_OUTOFMEMORY,
                NULL));
        goto BNT_BAILOUT;
    }
    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    __try {
        lWin32Status = RegQueryValueEx (
                hKeyNames,
                dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
                RESERVED,
                & dwValueType,
                (LPVOID) lpCounterNames,
                & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Counters),
                NULL));
        goto BNT_BAILOUT;
    }

    dwBufferSize = dwHelpSize;
    __try {
        lWin32Status = RegQueryValueEx (
                hKeyNames,
                dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
                RESERVED,
                & dwValueType,
                (LPVOID) lpHelpText,
                & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Help),
                NULL));
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed = 0;

    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if ((dwThisCounter == 0) || (dwThisCounter > dwLastId)) {
            lWin32Status = ERROR_INVALID_DATA;
            SetLastError(lWin32Status);
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT, // event,
                    4, dwThisCounter, dwLastCounterId, dwLastId, __LINE__,
                    1, lpThisName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lWin32Status,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwLastId),
                    NULL));
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;

    }

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if ((dwThisCounter == 0) || (dwThisCounter > dwLastId)) {
            lWin32Status = ERROR_INVALID_DATA;
            SetLastError(lWin32Status);
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT, // event,
                    4, dwThisCounter, dwLastHelpId, dwLastId, __LINE__,
                    1, lpThisName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lWin32Status,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwLastId),
                    NULL));
            goto BNT_BAILOUT;  // bad entry
        }
        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LODCTR_BUILDNAMETABLE,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lWin32Status,
            TRACE_WSTR(lpszLangId),
            TRACE_DWORD(dwLastCounterIdUsed),
            TRACE_DWORD(dwLastHelpIdUsed),
            TRACE_DWORD(dwLastId),
            NULL));

    // check the registry for consistency
    // the last help string index should be the last ID used
    if (dwLastCounterIdUsed > dwLastId) {
        lWin32Status = ERROR_INVALID_DATA;
        SetLastError(lWin32Status);
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                3, dwLastId, dwLastCounterIdUsed, __LINE__, 0,
                0, NULL, NULL, NULL);
        goto BNT_BAILOUT;  // bad registry
    }
    if (dwLastHelpIdUsed > dwLastId) {
        lWin32Status = ERROR_INVALID_DATA;
        SetLastError(lWin32Status);
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                3, dwLastId, dwLastHelpIdUsed, __LINE__, 0,
                0, NULL, NULL, NULL);
        goto BNT_BAILOUT;  // bad registry
    }

    if (pdwLastItem) *pdwLastItem = dwLastId;

    MemoryFree ((LPVOID)lpValueNameString);
    if (hKeyValue) {
        RegCloseKey (hKeyValue);
    }
    if (hKeyNames && hKeyNames != HKEY_PERFORMANCE_DATA) {
        RegCloseKey (hKeyNames);
    }

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }
    if (lpValueNameString) {
        MemoryFree ((LPVOID)lpValueNameString);
    }
    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }

    if (hKeyValue) {
        RegCloseKey (hKeyValue);
    }
    if (hKeyNames && hKeyNames != HKEY_PERFORMANCE_DATA) {
        RegCloseKey (hKeyNames);
    }

    return NULL;
}

BOOL
MakeBackupCopyOfLanguageFiles (
    IN  LPCTSTR szLangId
)
{
    TCHAR   szOldFileName[MAX_PATH];
    TCHAR   szTmpFileName[MAX_PATH];
    TCHAR   szNewFileName[MAX_PATH];

    BOOL    bStatus;

    DWORD   dwStatus;
    HANDLE  hOutFile;

    UNREFERENCED_PARAMETER (szLangId);

    ExpandEnvironmentStrings (szDataFileRoot, szOldFileName, MAX_PATH);
    _stprintf (szNewFileName, (LPCTSTR)(TEXT("%sStringBackup.INI")), szOldFileName);
    _stprintf(szTmpFileName,
              (LPCTSTR)(TEXT("%sStringBackup.TMP")),
              szOldFileName);

    // see if the file already exists
    hOutFile = CreateFile(
            szTmpFileName,
            GENERIC_READ,
            0,      // no sharing
            NULL,   // default security
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (hOutFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hOutFile);
        bStatus = DeleteFile(szTmpFileName);
    }

    // create backup of file
    //
    dwStatus = BackupPerfRegistryToFileW (szTmpFileName, NULL);
    if (dwStatus == ERROR_SUCCESS) {
        bStatus = CopyFile(szTmpFileName, szNewFileName, FALSE);
        if (bStatus) {
            DeleteFile(szTmpFileName);
        }
    } else {
        // unable to create a backup file
        SetLastError (dwStatus);
        bStatus = FALSE;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_MAKEBACKUPCOPYOFLANGUAGEFILES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            GetLastError(),
            TRACE_WSTR(szNewFileName),
            NULL));

    return bStatus;
}

BOOL
GetFileFromCommandLine (
    IN  LPTSTR   lpCommandLine,
    OUT LPTSTR   *lpFileName,
    IN    DWORD_PTR *pdwFlags
)
/*++

GetFileFromCommandLine

    parses the command line to retrieve the ini filename that should be
    the first and only argument.

Arguments

    lpCommandLine   pointer to command line (returned by GetCommandLine)
    lpFileName      pointer to buffer that will recieve address of the
            validated filename entered on the command line
    pdwFlags        pointer to dword containing flag bits

Return Value

    TRUE if a valid filename was returned
    FALSE if the filename is not valid or missing
        error is returned in GetLastError

--*/
{
    INT     iNumArgs;

    LPTSTR  lpExeName = NULL;
    LPTSTR  lpCmdLineName = NULL;
    LPWSTR  lpIniFileName = NULL;
    LPWSTR  lpMofFlag = NULL;
    HANDLE  hFileHandle;
    TCHAR   LocalComputerName[FILE_NAME_BUFFER_SIZE];
    DWORD   NameBuffer;

    DWORD    dwCpuArg, dwIniArg;

    // check for valid arguments

    if (!lpCommandLine) return (ERROR_INVALID_PARAMETER);
    if (!lpFileName) return (ERROR_INVALID_PARAMETER);
    if (!pdwFlags) return (ERROR_INVALID_PARAMETER);

    // allocate memory for parsing operation

    lpExeName = MemoryAllocate (FILE_NAME_BUFFER_SIZE * sizeof(TCHAR));
    lpCmdLineName = MemoryAllocate (FILE_NAME_BUFFER_SIZE * sizeof(TCHAR));
    lpIniFileName = MemoryAllocate (FILE_NAME_BUFFER_SIZE * sizeof(WCHAR));
    lpMofFlag = MemoryAllocate (FILE_NAME_BUFFER_SIZE * sizeof(WCHAR));

    if (!lpExeName || !lpIniFileName || !lpCmdLineName || !lpMofFlag) {
        SetLastError (ERROR_OUTOFMEMORY);
        if (lpExeName) MemoryFree (lpExeName);
        if (lpIniFileName) MemoryFree (lpIniFileName);
        if (lpCmdLineName) MemoryFree (lpCmdLineName);
        if (lpMofFlag) MemoryFree (lpMofFlag);
        return FALSE;
    } else {
        // get strings from command line
        RtlZeroMemory(ComputerName, sizeof(TCHAR) * FILE_NAME_BUFFER_SIZE);
        RtlZeroMemory(LocalComputerName, sizeof(TCHAR) * FILE_NAME_BUFFER_SIZE);

        // check for mof Flag
        lstrcpyW (lpMofFlag, GetItemFromString (lpCommandLine, 2, cSpace));

        *pdwFlags |= LOADPERF_FLAGS_LOAD_REGISTRY_ONLY; // default unless a switch is found
        
        if ((lpMofFlag[0] == cHyphen) || (lpMofFlag[0] == cSlash)) {
            if ((lpMofFlag[1] == cM)  || (lpMofFlag[1] == cm)) {
                *pdwFlags &= ~LOADPERF_FLAGS_LOAD_REGISTRY_ONLY; // clear that bit
            } else if ((lpMofFlag[1] == cQuestion)) {
               // ask for usage
               if (lpExeName) MemoryFree (lpExeName);
               if (lpIniFileName) MemoryFree (lpIniFileName);
               if (lpMofFlag) MemoryFree (lpMofFlag);
               return FALSE;
            }
            dwCpuArg = 3;
            dwIniArg = 4;
        } else {
            dwCpuArg = 2;
            dwIniArg = 3;
        }

        // Get INI File name

        lstrcpy (lpCmdLineName, GetItemFromString (lpCommandLine, dwIniArg, cSpace));
        if (lstrlen(lpCmdLineName) == 0) {
            // then no computer name was specified so try to get the
            // ini file from the 2nd entry
            lstrcpy (lpCmdLineName, GetItemFromString (lpCommandLine, dwCpuArg, cSpace));
            if (lstrlen(lpCmdLineName) == 0) {
                // no ini file found
                iNumArgs = 1;
            } else {
                // fill in a blank computer name
                iNumArgs = 2;
                ComputerName[0] = 0;
            }
        } else {
            // the computer name must be present so fetch it
            lstrcpy (LocalComputerName, GetItemFromString (lpCommandLine, dwCpuArg, cSpace));
            iNumArgs = 3;
        }

        if (iNumArgs != 2 && iNumArgs != 3) {
            // wrong number of arguments
            SetLastError (ERROR_INVALID_PARAMETER);
            if (lpExeName) MemoryFree (lpExeName);
            if (lpIniFileName) MemoryFree (lpIniFileName);
            if (lpMofFlag) MemoryFree (lpMofFlag);
            return FALSE;
        } else {
            // check if there is a computer name in the input line
            if (LocalComputerName[0] == cBackslash &&
                LocalComputerName[1] == cBackslash) {
                // save it form now
                lstrcpy (ComputerName, LocalComputerName);
                // reuse local buffer to get the this computer's name
                NameBuffer = sizeof (LocalComputerName) / sizeof (TCHAR);
                GetComputerName(LocalComputerName, &NameBuffer);
                if (!lstrcmpi(LocalComputerName, &ComputerName[2])) {
                    // same name as local computer name
                    // so clear computer name buffer
                    ComputerName[0] = 0;
                }
            }

            if (SearchPath (NULL, lpCmdLineName,
                NULL, FILE_NAME_BUFFER_SIZE,
                lpIniFileName, NULL) > 0) {

                hFileHandle = CreateFile (
                    lpIniFileName,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

                MemoryFree (lpCmdLineName);

                if (hFileHandle && hFileHandle != INVALID_HANDLE_VALUE) {
                    // get file size
                    dwFileSize = GetFileSize (hFileHandle, NULL);
                    if (dwFileSize == 0xffffffff) {
                        dwFileSize = 0L;
                    } else {
                        dwFileSize *= sizeof (TCHAR);
                    }

                    CloseHandle (hFileHandle);

                    // file exists, so return name and success
                    if (lpExeName) MemoryFree (lpExeName);

                    lstrcpyW (*lpFileName, lpIniFileName);

                    if (lpIniFileName) MemoryFree (lpIniFileName);
                    return TRUE;
                } else {
                    // filename was on command line, but not valid so return
                    // false, but send name back for error message
                    if (lpExeName) MemoryFree (lpExeName);
                    lstrcpyW (*lpFileName, lpIniFileName);
                    if (lpIniFileName) MemoryFree (lpIniFileName);
                    return FALSE;
                }
            } else {
                MemoryFree (lpCmdLineName);
                SetLastError (ERROR_OPEN_FAILED);
                if (lpExeName) MemoryFree (lpExeName);
                if (lpIniFileName) MemoryFree (lpIniFileName);
                return FALSE;
            }
        }
    }
}

BOOL
LodctrSetSericeAsTrusted(
    IN  LPCTSTR  lpIniFile,
    IN  LPCTSTR  szMachineName,
    IN  LPCTSTR  szServiceName
)
/*++
GetDriverName

    looks up driver name in the .ini file and returns it in lpDevName

Arguments

    lpIniFile

    Filename of ini file

    lpDevName

    pointer to pointer to reciev buffer w/dev name in it

Return Value

    TRUE if found
    FALSE if not found in .ini file

--*/
{
    DWORD          dwRetSize;
    DWORD          dwStatus;
    BOOL           bReturn;
    static WCHAR   szParam[MAX_PATH];

    dwRetSize = GetPrivateProfileString (
            szInfo,         // info section
            szTrusted,      // Trusted name value
            szNotFound,     // default value
            szParam,
            MAX_PATH,
            lpIniFile);

    if ((lstrcmpi(szParam, szNotFound)) != 0) {
        // Trusted string found so set
        dwStatus = SetServiceAsTrustedW (
            szMachineName,
            szServiceName);
        if (dwStatus != ERROR_SUCCESS) {
            SetLastError (dwStatus);
            bReturn = FALSE;
        }
        bReturn = TRUE;
    } else {
        // Service is not trusted to have a good Perf DLL
        SetLastError (ERROR_SUCCESS);
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL
GetDriverName (
    IN  LPTSTR  lpIniFile,
    OUT LPTSTR  *lpDevName
)
/*++
GetDriverName

    looks up driver name in the .ini file and returns it in lpDevName

Arguments

    lpIniFile

    Filename of ini file

    lpDevName

    pointer to pointer to reciev buffer w/dev name in it

Return Value

    TRUE if found
    FALSE if not found in .ini file

--*/
{
    DWORD   dwRetSize;
    BOOL    bReturn = FALSE;

    if (lpDevName) {
        dwRetSize = GetPrivateProfileString (
                szInfo,         // info section
                szDriverName,   // driver name value
                szNotFound,     // default value
                * lpDevName,
                MAX_PATH,
                lpIniFile);

        if ((lstrcmpi(*lpDevName, szNotFound)) != 0) {
            // name found
            bReturn = TRUE;
        } else {
            // name not found, default returned so return NULL string
            SetLastError (ERROR_BAD_DRIVER);
            *lpDevName = 0;
        }
    } else {
        SetLastError (ERROR_INVALID_PARAMETER);
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_GETDRIVERNAME,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            GetLastError(),
            TRACE_WSTR(lpIniFile),
            NULL));
    return bReturn;
}

BOOL
BuildLanguageTables (
    IN  LPTSTR  lpIniFile,
    IN OUT PLANGUAGE_LIST_ELEMENT   pFirstElem
)
/*++

BuildLanguageTables

    Creates a list of structures that will hold the text for
    each supported language

Arguments

    lpIniFile

    Filename with data

    pFirstElem

    pointer to first list entry

ReturnValue

    TRUE if all OK
    FALSE if not

--*/
{

    LPTSTR  lpEnumeratedLangs = NULL;
    LPTSTR  lpThisLang        = NULL;
    PLANGUAGE_LIST_ELEMENT   pThisElem;
    PLANGUAGE_LIST_ELEMENT   pPrevElem;
    DWORD   dwSize;
    BOOL    bReturn = FALSE;

    if (lpIniFile == NULL || pFirstElem == NULL) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    lpEnumeratedLangs = MemoryAllocate(SMALL_BUFFER_SIZE * sizeof(TCHAR));

    if (!lpEnumeratedLangs) {
        SetLastError (ERROR_OUTOFMEMORY);
        goto Cleanup;
    }

    dwSize = GetPrivateProfileString (
            szLanguages,
            NULL,                   // return all values in multi-sz string
            sz009,                  // english as the default
            lpEnumeratedLangs,
            SMALL_BUFFER_SIZE,
            lpIniFile);

    // do first language

    lpThisLang = lpEnumeratedLangs;
    pThisElem = NULL;
    pPrevElem = NULL;

    while (*lpThisLang) {
        //
        //  see if this language is supporte on this machine
        //
        if (pThisElem == NULL) {
            pThisElem = pPrevElem = pFirstElem;
        } else {
            pThisElem->pNextLang = MemoryAllocate  (sizeof(LANGUAGE_LIST_ELEMENT));
            if (!pThisElem->pNextLang) {
                SetLastError (ERROR_OUTOFMEMORY);
                goto Cleanup;
            }
            pPrevElem = pThisElem;
            pThisElem = pThisElem->pNextLang;   // point to new one
        }
        pThisElem->pNextLang = NULL;
        pThisElem->LangId = (LPTSTR) MemoryAllocate ((lstrlen(lpThisLang) + 1) * sizeof(TCHAR));
        if (pThisElem->LangId == NULL) {
            if (pThisElem == pFirstElem) {
                pThisElem = pPrevElem = NULL;
            }
            else {
                MemoryFree(pThisElem);
                pThisElem = pPrevElem;
                pThisElem->pNextLang = NULL;
            }
            SetLastError(ERROR_OUTOFMEMORY);
            goto Cleanup;
        }
        lstrcpy (pThisElem->LangId, lpThisLang);
        pThisElem->pFirstName = NULL;
        pThisElem->pThisName = NULL;
        pThisElem->dwNumElements=0;
        pThisElem->NameBuffer = NULL;
        pThisElem->HelpBuffer = NULL;
        pThisElem->dwNameBuffSize = 0;
        pThisElem->dwHelpBuffSize = 0;

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_BUILDLANGUAGETABLES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_SUCCESS,
                TRACE_WSTR(lpIniFile),
                TRACE_WSTR(pThisElem->LangId),
                NULL));

        // go to next string

        lpThisLang += lstrlen(lpThisLang) + 1;
    }

    if (pThisElem == NULL) {
        // then no languages were found
        SetLastError (ERROR_RESOURCE_LANG_NOT_FOUND);
    } else {
        bReturn = TRUE;
    }

Cleanup:
    if (! bReturn) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_BUILDLANGUAGETABLES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lpThisLang),
                NULL));
    }
    if (lpEnumeratedLangs != NULL) {
        MemoryFree(lpEnumeratedLangs);
    }
    return bReturn;
}

BOOL
LoadIncludeFile (
    IN LPTSTR lpIniFile,
    OUT PSYMBOL_TABLE_ENTRY   *pTable
)
/*++

LoadIncludeFile

    Reads the include file that contains symbolic name definitions and
    loads a table with the values defined

Arguments

    lpIniFile

    Ini file with include file name

    pTable

    address of pointer to table structure created
Return Value

    TRUE if table read or if no table defined
    FALSE if error encountere reading table

--*/
{
    INT         iNumArgs;
    DWORD       dwSize;
    BOOL        bReUse;
    PSYMBOL_TABLE_ENTRY   pThisSymbol = NULL;
    LPTSTR      lpIncludeFileName     = NULL;
    LPTSTR      lpIncludeFile         = NULL;
    LPTSTR      lpIniPath             = NULL;
    LPSTR       lpLineBuffer          = NULL;
    LPSTR       lpAnsiSymbol          = NULL;
    TCHAR       szIniDrive[_MAX_DRIVE];
    TCHAR       szIniDir[_MAX_DIR];
    FILE        * fIncludeFile = NULL;
    DWORD       dwLen;
    BOOL        bReturn = TRUE;

    lpIncludeFileName = MemoryAllocate  (MAX_PATH * sizeof (TCHAR));
    lpIncludeFile = MemoryAllocate (MAX_PATH * sizeof(TCHAR));
    lpLineBuffer = MemoryAllocate (DISP_BUFF_SIZE);
    lpAnsiSymbol = MemoryAllocate (DISP_BUFF_SIZE);
    lpIniPath = MemoryAllocate (MAX_PATH * sizeof (TCHAR));

    if (!lpIncludeFileName || !lpLineBuffer || !lpAnsiSymbol || !lpIniPath) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                1, __LINE__, 0, 0, 0,
                0, NULL, NULL, NULL);
        SetLastError (ERROR_OUTOFMEMORY);
        bReturn = FALSE;
        goto Cleanup;
    }

    // get name of include file (if present)

    dwSize = GetPrivateProfileString (
            szInfo,
            szSymbolFile,
            szNotFound,
            lpIncludeFileName,
            MAX_PATH,
            lpIniFile);

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LOADINCLUDEFILE,
            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
            ERROR_SUCCESS,
            TRACE_WSTR(lpIniFile),
            TRACE_WSTR(lpIncludeFileName),
            NULL));

    if (lstrcmpi(lpIncludeFileName, szNotFound) == 0) {
        // no symbol file defined
        * pTable = NULL;
        bReturn = TRUE;
        goto Cleanup;
    }

    // if here, then a symbol file was defined and is now stored in
    // lpIncludeFileName

    // get path for the ini file and search that first

    _tsplitpath (lpIniFile, szIniDrive, szIniDir, NULL, NULL);
    lpIniPath = lstrcpy (lpIniPath, szIniDrive);
    lpIniPath = lstrcat (lpIniPath, szIniDir);

    dwLen = SearchPath(lpIniPath, lpIncludeFileName, NULL,
        MAX_PATH, lpIncludeFile, NULL);
    if (dwLen == 0) {
        // include file not found with the ini file so search the std. path
        dwLen = SearchPath(NULL, lpIncludeFileName, NULL,
                MAX_PATH, lpIncludeFile, NULL);
    }

    if (dwLen > 0) {

        // file name expanded and found so open
        fIncludeFile = _tfopen (lpIncludeFile, (LPCTSTR)TEXT("rt"));

        if (fIncludeFile == NULL) {
            OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_INCLUDE), lpIncludeFileName);
            *pTable = NULL;
            SetLastError (ERROR_OPEN_FAILED);
            bReturn = FALSE;
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADINCLUDEFILE,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    ERROR_OPEN_FAILED,
                    TRACE_WSTR(lpIniFile),
                    TRACE_WSTR(lpIncludeFile),
                    NULL));
            goto Cleanup;
        }
    } else {
        // unable to find the include filename
        // error is already in GetLastError
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_INCLUDE), lpIncludeFileName);
        *pTable = NULL;
        SetLastError (ERROR_BAD_PATHNAME);
        bReturn = FALSE;
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADINCLUDEFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_BAD_PATHNAME,
                TRACE_WSTR(lpIniFile),
                TRACE_WSTR(lpIncludeFileName),
                NULL));
        goto Cleanup;
    }

    //
    //  read ANSI Characters from include file
    //

    bReUse = FALSE;

    while (fgets(lpLineBuffer, DISP_BUFF_SIZE, fIncludeFile) != NULL) {
        if (strlen(lpLineBuffer) > 8) {
            if (!bReUse) {
                if (*pTable) {
                    // then add to list
                    pThisSymbol->pNext = MemoryAllocate (sizeof (SYMBOL_TABLE_ENTRY));
                    pThisSymbol = pThisSymbol->pNext;
                } else { // allocate first element
                    *pTable = MemoryAllocate (sizeof (SYMBOL_TABLE_ENTRY));
                    pThisSymbol = *pTable;
                }

                if (!pThisSymbol) {
                    SetLastError (ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                    goto Cleanup;
                }

                // allocate room for the symbol name by using the line length
                // - the size of "#define "

//              pThisSymbol->SymbolName = MemoryAllocate ((strlen(lpLineBuffer) - 8) * sizeof (TCHAR));
                pThisSymbol->SymbolName = MemoryAllocate (DISP_BUFF_SIZE * sizeof (TCHAR));

                if (!pThisSymbol->SymbolName) {
                   SetLastError (ERROR_OUTOFMEMORY);
                   bReturn = FALSE;
                   goto Cleanup;
                }

            }

            // all the memory is allocated so load the fields

            pThisSymbol->pNext = NULL;

            iNumArgs = sscanf (lpLineBuffer, "#define %s %d",
            lpAnsiSymbol, &pThisSymbol->Value);

            if (iNumArgs != 2) {
                *(pThisSymbol->SymbolName) = 0;
                pThisSymbol->Value = (DWORD)-1L;
                bReUse = TRUE;
            } else {
                // OemToChar (lpAnsiSymbol, pThisSymbol->SymbolName);
                mbstowcs (pThisSymbol->SymbolName,
                    lpAnsiSymbol, lstrlenA(lpAnsiSymbol)+1);
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADINCLUDEFILE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_SUCCESS,
                        TRACE_WSTR(lpIncludeFileName),
                        TRACE_WSTR(pThisSymbol->SymbolName),
                        TRACE_DWORD(pThisSymbol->Value),
                        NULL));
                bReUse = FALSE;
            }
        }
    }

Cleanup:
    if (! bReturn) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADINCLUDEFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lpIniFile),
                NULL));
    }
    if (lpIncludeFileName)    MemoryFree(lpIncludeFileName);
    if (lpIncludeFile)        MemoryFree(lpIncludeFile);
    if (lpLineBuffer)         MemoryFree(lpLineBuffer);
    if (lpIniPath)            MemoryFree(lpIniPath);
    if (fIncludeFile != NULL) fclose(fIncludeFile);

    return bReturn;

}

BOOL
ParseTextId (
    IN LPTSTR  lpTextId,
    IN PSYMBOL_TABLE_ENTRY pFirstSymbol,
    OUT PDWORD  pdwOffset,
    OUT LPTSTR  *lpLangId,
    OUT PDWORD  pdwType
)
/*++

ParseTextId

    decodes Text Id key from .INI file

    syntax for this process is:

    {<DecimalNumber>}                {"NAME"}
    {<SymbolInTable>}_<LangIdString>_{"HELP"}

     e.g. 0_009_NAME
          OBJECT_1_009_HELP

Arguments

    lpTextId

    string to decode

    pFirstSymbol

    pointer to first entry in symbol table (NULL if no table)

    pdwOffset

    address of DWORD to recive offest value

    lpLangId

    address of pointer to Language Id string
    (NOTE: this will point into the string lpTextID which will be
    modified by this routine)

    pdwType

    pointer to dword that will recieve the type of string i.e.
    HELP or NAME

Return Value

    TRUE    text Id decoded successfully
    FALSE   unable to decode string

    NOTE: the string in lpTextID will be modified by this procedure

--*/
{
    LPTSTR  lpThisChar;
    PSYMBOL_TABLE_ENTRY pThisSymbol;

    // check for valid return arguments

    if (!(pdwOffset) || !(lpLangId) || !(pdwType)) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // search string from right to left in order to identify the
    // components of the string.

    lpThisChar = lpTextId + lstrlen(lpTextId); // point to end of string

    while (*lpThisChar != cUnderscore) {
        lpThisChar--;
        if (lpThisChar <= lpTextId) {
            // underscore not found in string
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
    }

    // first underscore found

    if ((lstrcmpi(lpThisChar, szName)) == 0) {
        // name found, so set type
        *pdwType = TYPE_NAME;
    } else if ((lstrcmpi(lpThisChar, szHelp)) == 0) {
        // help text found, so set type
        *pdwType = TYPE_HELP;
    } else {
        // bad format
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // set the current underscore to \0 and look for language ID

    *lpThisChar-- = 0;

    while (*lpThisChar != cUnderscore) {
        lpThisChar--;
        if (lpThisChar <= lpTextId) {
            // underscore not found in string
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
    }

    // set lang ID string pointer to current char ('_') + 1

    *lpLangId = lpThisChar + 1;

    // set this underscore to a NULL and try to decode the remaining text

    *lpThisChar = 0;

    // see if the first part of the string is a decimal digit

    if ((_stscanf (lpTextId, sz_DFormat, pdwOffset)) != 1) {
        // it's not a digit, so try to decode it as a symbol in the
        // loaded symbol table

        for (pThisSymbol=pFirstSymbol;
            pThisSymbol && *(pThisSymbol->SymbolName);
            pThisSymbol = pThisSymbol->pNext) {

            if ((lstrcmpi(lpTextId, pThisSymbol->SymbolName)) == 0) {
            // a matching symbol was found, so insert it's value
            // and return (that's all that needs to be done
            *pdwOffset = pThisSymbol->Value;
            return TRUE;
            }
        }
        // if here, then no matching symbol was found, and it's not
        // a number, so return an error

        SetLastError (ERROR_BAD_TOKEN_TYPE);
        return FALSE;
    } else {
        // symbol was prefixed with a decimal number
        return TRUE;
    }
}

PLANGUAGE_LIST_ELEMENT
FindLanguage (
    IN PLANGUAGE_LIST_ELEMENT   pFirstLang,
    IN LPCTSTR   pLangId
)
/*++

FindLanguage

    searchs the list of languages and returns a pointer to the language
    list entry that matches the pLangId string argument

Arguments

    pFirstLang

    pointer to first language list element

    pLangId

    pointer to text string with language ID to look up

Return Value

    Pointer to matching language list entry
    or NULL if no match

--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    for (pThisLang = pFirstLang;
         pThisLang;
         pThisLang = pThisLang->pNextLang) {
        if ((lstrcmpi(pLangId, pThisLang->LangId)) == 0) {
            // match found so return pointer
            return pThisLang;
        }
    }
    return NULL;    // no match found
}

BOOL
GetValue(
    LPTSTR lpLocalSectionBuff,
    LPTSTR lpLocalStringBuff
)
{

    LPTSTR  lpPosition;

    BOOL    bReturn = FALSE;

    lpPosition = _tcschr(lpLocalSectionBuff,cEquals);
    if (lpPosition) {
        lpPosition++;
        // make sure the "=" isn't the last char
        if (*lpPosition != 0) {
            //Found the "equals" sign
            lstrcpy (lpLocalStringBuff,lpPosition);
        } else {
            // empty string, return a pseudo blank string
            lstrcpy(lpLocalStringBuff, L" ");
        }
        bReturn = TRUE;
    } else {
        //ErrorFinfing the "="
        // bad format
        SetLastError (ERROR_INVALID_DATA);
    }
    return bReturn;
}

BOOL
GetValueFromIniKey (LPTSTR lpValueKey,
                    LPTSTR lpTextSection,
                    DWORD* pdwLastReadOffset,
                    DWORD  dwTryCount,
                    LPTSTR lpLocalStringBuff
                    )
{
    LPTSTR  lpLocalSectionBuff;
    DWORD   dwIndex;
    DWORD   dwLastReadOffset;
    BOOL    bRetVal = FALSE;

    if ((lpTextSection) && (lpValueKey)) {
        dwLastReadOffset = *pdwLastReadOffset;
        lpLocalSectionBuff = lpTextSection ;
        lpLocalSectionBuff += dwLastReadOffset;

        while(!(*lpLocalSectionBuff)){

            dwLastReadOffset += (lstrlen(lpTextSection + dwLastReadOffset) + 1);
            lpLocalSectionBuff = lpTextSection + dwLastReadOffset;
            *pdwLastReadOffset = dwLastReadOffset;

        }

        // search next N entries in buffer for entry
        // this should usually work since the file
        // is scanned sequentially so it's tried first
        for (dwIndex = 0;
             dwIndex < dwTryCount ;
             dwIndex++) {
            //  see if this is the correct entry
            // and return it if it is
            if (_tcsstr(lpLocalSectionBuff,lpValueKey)) {
                bRetVal = GetValue(lpLocalSectionBuff,
                        lpLocalStringBuff);
                //Set the lastReadOffset First
                dwLastReadOffset += (lstrlen(lpTextSection + dwLastReadOffset) + 1);
                *pdwLastReadOffset = dwLastReadOffset;
                break; // out of the for loop
            } else {
                // this isn't the correct one so go to the next
                // entry in the file
                dwLastReadOffset += (lstrlen(lpTextSection + dwLastReadOffset) + 1);
                lpLocalSectionBuff = lpTextSection + dwLastReadOffset;
                *pdwLastReadOffset = dwLastReadOffset;
            }
        }

        if (!bRetVal) {
            //Cannont Find the key using lastReadOffset
            //try again from the beggining of the Array
            dwLastReadOffset = 0;
            lpLocalSectionBuff = lpTextSection;
            *pdwLastReadOffset = dwLastReadOffset;

            while (*lpLocalSectionBuff != 0) {
                if (_tcsstr(lpLocalSectionBuff,lpValueKey)) {
                     bRetVal = GetValue(lpLocalSectionBuff,
                                lpLocalStringBuff);
                     break;
                } else {
                    // go to the next entry
                    dwLastReadOffset += (lstrlen(lpTextSection + dwLastReadOffset) + 1);
                    lpLocalSectionBuff = lpTextSection + dwLastReadOffset;
                    *pdwLastReadOffset = dwLastReadOffset;
                }
            }
        }
    } else {
        // one or two null pointers so give up now
    }
    return bRetVal;
}

BOOL
AddEntryToLanguage (
    PLANGUAGE_LIST_ELEMENT  pLang,
    LPTSTR                  lpValueKey,
    LPTSTR                  lpTextSection,
    DWORD                   *pdwLastReadOffset,
    DWORD                   dwTryCount,
    DWORD                   dwType,
    DWORD                   dwOffset,
    LPTSTR                  lpIniFile
)
/*++

AddEntryToLanguage

    Add a text entry to the list of text entries for the specified language

Arguments

    pLang

    pointer to language structure to update

    lpValueKey

    value key to look up in .ini file

    dwOffset

    numeric offset of name in registry

    lpIniFile

    ini file

Return Value

    TRUE if added successfully
    FALSE if error
    (see GetLastError for status)

--*/
{
    LPTSTR  lpLocalStringBuff = NULL;
    DWORD   dwBufferSize;
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bRetVal;
    BOOL    bReturn = FALSE;

    UNREFERENCED_PARAMETER (lpIniFile);

    if (   (dwType == TYPE_NAME && dwOffset < FIRST_EXT_COUNTER_INDEX)
        || (dwType == TYPE_HELP && dwOffset < FIRST_EXT_HELP_INDEX)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE,
                (DWORD) LDPRFMSG_CORRUPT_INDEX,
                3, dwOffset, dwType, __LINE__, 0,
                1, lpValueKey, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_ADDENTRYTOLANGUAGE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_BADKEY,
                TRACE_WSTR(lpTextSection),
                TRACE_WSTR(lpValueKey),
                TRACE_DWORD(dwType),
                TRACE_DWORD(dwOffset),
                NULL));
        dwStatus = ERROR_BADKEY;
        goto Cleanup;
    }

    dwBufferSize = SMALL_BUFFER_SIZE * 4 * sizeof(TCHAR);
    if (dwBufferSize < dwFileSize) {
        dwBufferSize = dwFileSize;
    }

    lpLocalStringBuff = MemoryAllocate (dwBufferSize);

    if (!lpLocalStringBuff) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    bRetVal = GetValueFromIniKey(lpValueKey,
                       lpTextSection,
                       pdwLastReadOffset,
                       dwTryCount,
                       lpLocalStringBuff);

    if (!bRetVal) {
        DWORD dwLastReadOffset = * pdwLastReadOffset;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_ADDENTRYTOLANGUAGE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_BADKEY,
                TRACE_WSTR(lpTextSection),
                TRACE_WSTR(lpValueKey),
                TRACE_DWORD(dwLastReadOffset),
                NULL));
        dwStatus = ERROR_BADKEY;
        goto Cleanup;
    }

    if ((lstrcmpi(lpLocalStringBuff, szNotFound))== 0) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_ADDENTRYTOLANGUAGE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_BADKEY,
                TRACE_WSTR(lpTextSection),
                TRACE_WSTR(lpValueKey),
                NULL));
        dwStatus = ERROR_BADKEY;
        goto Cleanup;
    }
    // key found, so load structure

    if (!pLang->pThisName) {
        // this is the first
        pLang->pThisName =
                MemoryAllocate (sizeof (NAME_ENTRY) +
                        (lstrlen(lpLocalStringBuff) + 1) * sizeof (TCHAR));
        if (!pLang->pThisName) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        } else {
            pLang->pFirstName = pLang->pThisName;
        }
    } else {
        pLang->pThisName->pNext =
            MemoryAllocate (sizeof (NAME_ENTRY) +
                (lstrlen(lpLocalStringBuff) + 1) * sizeof (TCHAR));
        if (!pLang->pThisName->pNext) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        } else {
            pLang->pThisName = pLang->pThisName->pNext;
        }
    }

    // pLang->pThisName now points to an uninitialized structre

    pLang->pThisName->pNext    = NULL;
    pLang->pThisName->dwOffset = dwOffset;
    pLang->pThisName->dwType   = dwType;
    pLang->pThisName->lpText   = (LPTSTR) & (pLang->pThisName[1]);
    lstrcpy (pLang->pThisName->lpText, lpLocalStringBuff);
    bReturn = TRUE;

Cleanup:
    if (lpLocalStringBuff != NULL) MemoryFree (lpLocalStringBuff);
    SetLastError(dwStatus);
    return (bReturn);
}

BOOL
CreateObjectList (
    IN  LPTSTR  lpIniFile,
    IN  DWORD   dwFirstDriverCounter,
    IN  PSYMBOL_TABLE_ENTRY pFirstSymbol,
    IN  LPTSTR  lpszObjectList,
    IN  PPERFOBJECT_LOOKUP  pObjectGuidTable,
    IN  LPDWORD pdwObjectGuidTableEntries
    )
{
    TCHAR    szDigits[32];
    LPTSTR   szLangId;
    TCHAR    szTempString[256];
    LPWSTR   szGuidStringBuffer;
    LPTSTR   szThisKey;
    DWORD    dwSize;
    DWORD    dwObjectCount = 0;
    DWORD    dwId;
    DWORD    dwType;
    DWORD    dwObjectGuidIndex = 0;

    DWORD    dwBufferSize           = dwFileSize;
    LPTSTR   szObjectSectionEntries = NULL;
    BOOL     bResult                = TRUE;

    if (dwBufferSize < MAX_PROFILE_BUFFER * sizeof(TCHAR)) {
        dwBufferSize = MAX_PROFILE_BUFFER * sizeof(TCHAR);
    }
    szObjectSectionEntries = MemoryAllocate(dwBufferSize);
    if (szObjectSectionEntries == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        bResult = FALSE;
        goto Cleanup;
    }

    ZeroMemory(szObjectSectionEntries, dwBufferSize);
    szThisKey = & szObjectSectionEntries[0];

    dwSize = GetPrivateProfileString (
            szObjects,
            NULL,
            szNotFound,
            szObjectSectionEntries,
            dwBufferSize / sizeof(TCHAR),
            lpIniFile);

    * lpszObjectList = 0;
    if (lstrcmp(szObjectSectionEntries, szNotFound) != 0) {
        // then some entries were found so read each one, compute the
        // index value and save in the string buffer passed by the caller
        for (szThisKey = szObjectSectionEntries;
            *szThisKey != 0;
            szThisKey += lstrlen(szThisKey) + 1) {
            // ParstTextId modifies the string so we need to make a work copy
            lstrcpy (szTempString, szThisKey);
            if (ParseTextId(szTempString, pFirstSymbol, &dwId, &szLangId, &dwType)) {
                // then dwID is the id of an object supported by this DLL
                if (dwObjectCount != 0) {
                    lstrcat (lpszObjectList, szSpace);
                }
                _ultot ((dwId + dwFirstDriverCounter), szDigits, 10);
                lstrcat (lpszObjectList, szDigits);
                //
                //  now see if this object has a GUID string
                //
                szGuidStringBuffer = MemoryAllocate(1024);
                if (szGuidStringBuffer == NULL) {
                    // cannot allocate memory for szGuidStringBuffer, ignore
                    // and continue the next one.
                    //
                    dwObjectCount ++;
                    continue;
                }
                dwSize = GetPrivateProfileStringW (
                        szObjects,
                        szThisKey,
                        szNotFound,
                        szGuidStringBuffer,
                        1024,
                        lpIniFile);
                if (dwSize > 0) {
                    if (lstrcmpW (szGuidStringBuffer, szNotFound) != 0) {
                        // then some string is present, so see if
                        // it looks like a GUID
                        if ((szGuidStringBuffer[0] == L'{') &&
                            (szGuidStringBuffer[9] == L'-') &&
                            (szGuidStringBuffer[14] == L'-') &&
                            (szGuidStringBuffer[19] == L'-') &&
                            (szGuidStringBuffer[24] == L'-') &&
                            (szGuidStringBuffer[37] == L'}')) {
                            // then it's probably a GUID so store it
                            szGuidStringBuffer = MemoryResize (szGuidStringBuffer,
                                (dwSize + 1) * sizeof(WCHAR));
                            if (szGuidStringBuffer == NULL) {
                                // cannot reallocate memory for
                                // szGuidStringBuffer, ignore and continue
                                // the next one.
                                //
                                continue;
                            }
                            if (dwObjectGuidIndex < *pdwObjectGuidTableEntries) {
                                pObjectGuidTable[dwObjectGuidIndex].PerfObjectId =
                                    dwId + dwFirstDriverCounter;
                                pObjectGuidTable[dwObjectGuidIndex].GuidString =
                                    szGuidStringBuffer;
                                dwObjectGuidIndex++;

                                TRACE((WINPERF_DBG_TRACE_INFO),
                                      (& LoadPerfGuid,
                                        __LINE__,
                                        LOADPERF_CREATEOBJECTLIST,
                                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                                        ERROR_SUCCESS,
                                        TRACE_WSTR(lpIniFile),
                                        TRACE_WSTR(szGuidStringBuffer),
                                        TRACE_DWORD(dwObjectGuidIndex),
                                        NULL));
                            } else {
                                // table is full
                            }
                        } else {
                            // not a GUID so ignore
                        }
                    } else {
                        // no string after object reference
                    }
                }
                dwObjectCount++;
            } else {
                // invalid key format
            }
        }
        // save size of Guid Table
        *pdwObjectGuidTableEntries = dwObjectGuidIndex;
    } else {
        // log message that object list is not used
        TRACE((WINPERF_DBG_TRACE_WARNING),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_CREATEOBJECTLIST,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_SUCCESS,
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwFirstDriverCounter),
                NULL));
    }

Cleanup:
    if (szObjectSectionEntries != NULL) {
        MemoryFree(szObjectSectionEntries);
    }
    return bResult;
}

BOOL
LoadLanguageLists (
    IN LPTSTR  lpIniFile,
    IN DWORD   dwFirstCounter,
    IN DWORD   dwFirstHelp,
    IN PSYMBOL_TABLE_ENTRY   pFirstSymbol,
    IN PLANGUAGE_LIST_ELEMENT  pFirstLang
)
/*++

LoadLanguageLists

    Reads in the name and explain text definitions from the ini file and
    builds a list of these items for each of the supported languages and
    then combines all the entries into a sorted MULTI_SZ string buffer.

Arguments

    lpIniFile

    file containing the definitions to add to the registry

    dwFirstCounter

    starting counter name index number

    dwFirstHelp

    starting help text index number

    pFirstLang

    pointer to first element in list of language elements

Return Value

    TRUE if all is well
    FALSE if not
    error is returned in GetLastError

--*/
{
    LPTSTR  lpTextIdArray;
    LPTSTR  lpLocalKey;
    LPTSTR  lpThisKey;
    LPTSTR  lpTextSectionArray;
    DWORD   dwSize;
    LPTSTR  lpLang;
    DWORD   dwOffset;
    DWORD   dwType;
    PLANGUAGE_LIST_ELEMENT  pThisLang, pLangPointer=NULL;
    DWORD   dwBufferSize;
    DWORD   dwSuccessCount = 0;
    DWORD   dwErrorCount = 0;
    DWORD   dwLastReadOffset = 0;
    DWORD   dwTryCount = 4;     //Init this value with 4 (at least 4 times to try maching Key and Value)

    pLangPointer = pFirstLang;

    while (pFirstLang) {
         pFirstLang = pFirstLang->pNextLang;
         //if you have more languages then increase this try limit to 4 + No. of langs
         dwTryCount++;
    }
    pFirstLang = pLangPointer;

    dwBufferSize = SMALL_BUFFER_SIZE * 4 * sizeof(TCHAR);
    if (dwBufferSize < dwFileSize) {
        dwBufferSize = dwFileSize;
    }

    lpTextIdArray = MemoryAllocate (dwBufferSize);
    if (lpTextIdArray == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADLANGUAGELISTS,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_OUTOFMEMORY,
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwFirstCounter),
                TRACE_DWORD(dwFirstHelp),
                NULL));
        return FALSE;
    }

    lpLocalKey = MemoryAllocate (MAX_PATH * sizeof(TCHAR));
    if (lpLocalKey == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        if (lpTextIdArray) MemoryFree (lpTextIdArray);
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADLANGUAGELISTS,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_OUTOFMEMORY,
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwFirstCounter),
                TRACE_DWORD(dwFirstHelp),
                NULL));
        return FALSE;
    }

    lpTextSectionArray = MemoryAllocate (dwBufferSize);
    if (lpTextSectionArray == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        if (lpTextIdArray) MemoryFree(lpTextIdArray);
        if (lpLocalKey)    MemoryFree(lpLocalKey);
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADLANGUAGELISTS,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_OUTOFMEMORY,
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwFirstCounter),
                TRACE_DWORD(dwFirstHelp),
                NULL));
        return FALSE;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LOADLANGUAGELISTS,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ERROR_SUCCESS,
            TRACE_WSTR(lpIniFile),
            TRACE_DWORD(dwFirstCounter),
            TRACE_DWORD(dwFirstHelp),
            NULL));

    // get list of text keys to look up

    dwSize = GetPrivateProfileString (
            szText,         // [text] section of .INI file
            NULL,           // return all keys
            szNotFound,
            lpTextIdArray,  // return buffer
            dwBufferSize / sizeof(TCHAR),
            lpIniFile);     // .INI file name

    if ((lstrcmpi(lpTextIdArray, szNotFound)) == 0) {
        // key not found, default returned
        SetLastError (ERROR_NO_SUCH_GROUP);
        if (lpTextIdArray)      MemoryFree(lpTextIdArray);
        if (lpLocalKey)         MemoryFree(lpLocalKey);
        if (lpTextSectionArray) MemoryFree(lpTextSectionArray);
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADLANGUAGELISTS,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_NO_SUCH_GROUP,
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwFirstCounter),
                TRACE_DWORD(dwFirstHelp),
                NULL));
        return FALSE;
    }

    // get the the [text] section from the ini file

    dwSize = GetPrivateProfileSection (
            szText,              // [text] section of .INI file
            lpTextSectionArray,  // return buffer
            dwBufferSize / sizeof(TCHAR),
            lpIniFile);          // .INI file name

    // do each key returned

    for (lpThisKey=lpTextIdArray;
         * lpThisKey;
         lpThisKey += (lstrlen(lpThisKey) + 1)) {

        lstrcpy (lpLocalKey, lpThisKey);    // make a copy of the key

        // parse key to see if it's in the correct format

        if (ParseTextId(lpLocalKey, pFirstSymbol, &dwOffset, &lpLang, &dwType)) {
            // so get pointer to language entry structure
            pThisLang = FindLanguage (pFirstLang, lpLang);
            if (pThisLang) {
                if (!AddEntryToLanguage(pThisLang,
                                        lpThisKey,
                                        lpTextSectionArray,
                                        & dwLastReadOffset,
                                        dwTryCount,
                                        dwType,
                                        (dwOffset + (  (dwType == TYPE_NAME)
                                                     ? dwFirstCounter
                                                     : dwFirstHelp)),
                                        lpIniFile)) {
                    OUTPUT_MESSAGE (GetFormatResource (LC_ERRADDTOLANG),
                        lpThisKey,
                        lpLang,
                        GetLastError());
                    dwErrorCount ++;
                } else {
                    dwSuccessCount ++;
                }
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADLANGUAGELISTS,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_SUCCESS,
                        TRACE_WSTR(lpThisKey),
                        TRACE_WSTR(lpLang),
                        TRACE_DWORD(dwOffset),
                        TRACE_DWORD(dwType),
                        NULL));
            } else { // language not in list
                OUTPUT_MESSAGE (GetFormatResource(LC_LANGNOTFOUND), lpLang, lpThisKey);
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADLANGUAGELISTS,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_SUCCESS,
                        TRACE_WSTR(lpThisKey),
                        TRACE_WSTR(lpLang),
                        NULL));
            }
        } else { // unable to parse ID string
            OUTPUT_MESSAGE(GetFormatResource(LC_BAD_KEY), lpThisKey);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADLANGUAGELISTS,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisKey),
                    TRACE_WSTR(lpLang),
                    NULL));
        }
    }

    if (lpTextIdArray)      MemoryFree(lpTextIdArray);
    if (lpLocalKey)         MemoryFree(lpLocalKey);
    if (lpTextSectionArray) MemoryFree(lpTextSectionArray);

    return (BOOL) (dwErrorCount == 0);
}

BOOL
SortLanguageTables (
    PLANGUAGE_LIST_ELEMENT pFirstLang,
    PDWORD                 pdwLastName,
    PDWORD                 pdwLastHelp
)
/*++

SortLangageTables

    walks list of languages loaded, allocates and loads a sorted multi_SZ
    buffer containing new entries to be added to current names/help text

Arguments

    pFirstLang

    pointer to first element in list of languages

ReturnValue

    TRUE    everything done as expected
    FALSE   error occurred, status in GetLastError

--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    BOOL            bSorted;

    LPTSTR          pNameBufPos, pHelpBufPos;

    PNAME_ENTRY     pThisName, pPrevName;

    DWORD           dwHelpSize, dwNameSize, dwSize;
    DWORD           dwCurrentLastName;
    DWORD           dwCurrentLastHelp;

    if (!pdwLastName || !pdwLastHelp) {
        SetLastError (ERROR_BAD_ARGUMENTS);
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SORTLANGUAGETABLES,
                0,
                ERROR_BAD_ARGUMENTS,
                NULL));
        return FALSE;
    }

    for (pThisLang = pFirstLang;
         pThisLang;
         pThisLang = pThisLang->pNextLang) {
        // do each language in list
        // sort elements in list by value (offset) so that lowest is first

        if (pThisLang->pFirstName == NULL) {
            // no elements in this list, continue the next one
            continue;
        }

        bSorted = FALSE;
        while (!bSorted ) {
            // point to start of list

            pPrevName = pThisLang->pFirstName;
            if (pPrevName) {
                pThisName = pPrevName->pNext;
            } else {
                break; // no elements in this list
            }

            if (!pThisName) {
                break;      // only one element in the list
            }
            bSorted = TRUE; // assume that it's sorted

            // go until end of list

            while (pThisName->pNext) {
                if (pThisName->dwOffset > pThisName->pNext->dwOffset) {
                    // switch 'em
                    PNAME_ENTRY     pA, pB;
                    pPrevName->pNext = pThisName->pNext;
                    pA = pThisName->pNext;
                    pB = pThisName->pNext->pNext;
                    pThisName->pNext = pB;
                    pA->pNext = pThisName;
                    pThisName = pA;
                    bSorted = FALSE;
                }
                //move to next entry
                pPrevName = pThisName;
                pThisName = pThisName->pNext;
            }
            // if bSorted = TRUE , then we walked all the way down
            // the list without changing anything so that's the end.
        }

        // with the list sorted, build the MULTI_SZ strings for the
        // help and name text strings

        // compute buffer size

        dwNameSize = dwHelpSize = 0;
        dwCurrentLastName = 0;
        dwCurrentLastHelp = 0;

        for (pThisName = pThisLang->pFirstName;
            pThisName;
            pThisName = pThisName->pNext) {
            // compute buffer requirements for this entry
            dwSize = SIZE_OF_OFFSET_STRING;
            dwSize += lstrlen (pThisName->lpText);
            dwSize += 1;   // null
            dwSize *= sizeof (TCHAR);   // adjust for character size
            // add to appropriate size register
            if (pThisName->dwType == TYPE_NAME) {
                dwNameSize += dwSize;
                if (pThisName->dwOffset > dwCurrentLastName) {
                    dwCurrentLastName = pThisName->dwOffset;
                }
            } else if (pThisName->dwType == TYPE_HELP) {
                dwHelpSize += dwSize;
                if (pThisName->dwOffset > dwCurrentLastHelp) {
                    dwCurrentLastHelp = pThisName->dwOffset;
                }
            }
        }

        // allocate buffers for the Multi_SZ strings

        pThisLang->NameBuffer = MemoryAllocate (dwNameSize);
        pThisLang->HelpBuffer = MemoryAllocate (dwHelpSize);

        if (!pThisLang->NameBuffer || !pThisLang->HelpBuffer) {
            SetLastError (ERROR_OUTOFMEMORY);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_SORTLANGUAGETABLES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_OUTOFMEMORY,
                    TRACE_WSTR(pThisLang->LangId),
                    TRACE_DWORD(pThisLang->dwNumElements),
                    TRACE_DWORD(dwCurrentLastName),
                    TRACE_DWORD(dwCurrentLastHelp),
                    NULL));
            return FALSE;
        }

        // fill in buffers with sorted strings

        pNameBufPos = (LPTSTR)pThisLang->NameBuffer;
        pHelpBufPos = (LPTSTR)pThisLang->HelpBuffer;

        for (pThisName = pThisLang->pFirstName;
            pThisName;
            pThisName = pThisName->pNext) {
            if (pThisName->dwType == TYPE_NAME) {
                // load number as first 0-term. string
                dwSize = _stprintf (pNameBufPos, szDFormat, pThisName->dwOffset);
                pNameBufPos += dwSize + 1;  // save NULL term.
                // load the text to match
                lstrcpy (pNameBufPos, pThisName->lpText);
                pNameBufPos += lstrlen(pNameBufPos) + 1;
            } else if (pThisName->dwType == TYPE_HELP) {
                // load number as first 0-term. string
                dwSize = _stprintf (pHelpBufPos, szDFormat, pThisName->dwOffset);
                pHelpBufPos += dwSize + 1;  // save NULL term.
                // load the text to match
                lstrcpy (pHelpBufPos, pThisName->lpText);
                pHelpBufPos += lstrlen(pHelpBufPos) + 1;
            }
        }

        // add additional NULL at end of string to terminate MULTI_SZ

        * pHelpBufPos = 0;
        * pNameBufPos = 0;

        // compute size of MULTI_SZ strings

        pThisLang->dwNameBuffSize = (DWORD)((PBYTE)pNameBufPos -
                            (PBYTE)pThisLang->NameBuffer) +
                            sizeof(TCHAR);
        pThisLang->dwHelpBuffSize = (DWORD)((PBYTE)pHelpBufPos -
                            (PBYTE)pThisLang->HelpBuffer) +
                            sizeof(TCHAR);

        if (* pdwLastName < dwCurrentLastName) {
            * pdwLastName = dwCurrentLastName;
        }
        if (* pdwLastHelp < dwCurrentLastHelp) {
            * pdwLastHelp = dwCurrentLastHelp;
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SORTLANGUAGETABLES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_SUCCESS,
                TRACE_WSTR(pThisLang->LangId),
                TRACE_DWORD(pThisLang->dwNumElements),
                TRACE_DWORD(dwCurrentLastName),
                TRACE_DWORD(dwCurrentLastHelp),
                NULL));
    }

    dwCurrentLastName = * pdwLastName;
    dwCurrentLastHelp = * pdwLastHelp;
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_SORTLANGUAGETABLES,
            0,
            ERROR_SUCCESS,
            TRACE_DWORD(dwCurrentLastName),
            TRACE_DWORD(dwCurrentLastHelp),
            NULL));
    return TRUE;
}

BOOL
GetInstalledLanguageList (
    HKEY hPerflibRoot,
    LPTSTR *mszLangList
)
/*++
    returns a list of language sub keys found under the perflib key

--*/
{
    BOOL    bReturn = TRUE;
    LONG    lStatus;
    DWORD   dwIndex = 0;
    LPTSTR  szBuffer;
    DWORD   dwBufSize;
    LPTSTR  szRetBuffer = NULL;
    DWORD   dwRetBufSize = 0;
    DWORD   dwLastBufSize = 0;
    LPTSTR  szNextString;

    dwBufSize = MAX_PATH;
    szBuffer = MemoryAllocate(MAX_PATH * sizeof(TCHAR));

    if (szBuffer == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        bReturn = FALSE;
    }

    if (bReturn) {
        while ((lStatus = RegEnumKeyEx (hPerflibRoot,
            dwIndex, szBuffer, &dwBufSize,
                NULL, NULL, NULL, NULL)) == ERROR_SUCCESS) {

            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_GETINSTALLEDLANGUAGELIST,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_SUCCESS,
                    TRACE_WSTR(szBuffer),
                    TRACE_DWORD(dwIndex),
                    NULL));

            dwRetBufSize += (lstrlen(szBuffer) + 1) * sizeof(TCHAR);
            if (szRetBuffer != NULL) {
                LPTSTR szTmpBuffer = szRetBuffer;
                szRetBuffer = MemoryResize(szRetBuffer, dwRetBufSize);
                if (szRetBuffer == NULL) {
                    MemoryFree(szTmpBuffer);
                }
            } else {
                szRetBuffer = MemoryAllocate(dwRetBufSize);
            }

            if (szRetBuffer == NULL) {
                SetLastError (ERROR_OUTOFMEMORY);
                bReturn = FALSE;
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_GETINSTALLEDLANGUAGELIST,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_OUTOFMEMORY,
                        TRACE_WSTR(szBuffer),
                        TRACE_DWORD(dwIndex),
                        NULL));
                break;
            }

            szNextString  = (LPTSTR) ((LPBYTE) szRetBuffer + dwLastBufSize);
            lstrcpy(szNextString, szBuffer);
            dwLastBufSize = dwRetBufSize;
            dwIndex ++;
            dwBufSize = MAX_PATH;
            RtlZeroMemory(szBuffer, MAX_PATH * sizeof(TCHAR));
        }
    }

    if (bReturn) {
        LPTSTR szTmpBuffer = szRetBuffer;
        // add terminating null char
        dwRetBufSize += sizeof (TCHAR);
        if (szRetBuffer != NULL) {
            szRetBuffer = MemoryResize(szRetBuffer, dwRetBufSize);
        } else {
            szRetBuffer = MemoryAllocate(dwRetBufSize);
        }

        if (szRetBuffer == NULL) {
            if (szTmpBuffer != NULL) MemoryFree(szTmpBuffer);
            SetLastError (ERROR_OUTOFMEMORY);
            bReturn = FALSE;
        }
        else {
            szNextString   = (LPTSTR) ((LPBYTE) szRetBuffer + dwLastBufSize);
            * szNextString = _T('\0');
        }
    }

    if (bReturn) {
        * mszLangList = szRetBuffer;
    }
    else {
        * mszLangList = NULL;
        MemoryFree(szRetBuffer);
    }
    return bReturn;
}

BOOL
CheckNameTable(
    LPTSTR   lpNameStr,
    LPTSTR   lpHelpStr,
    LPDWORD  pdwLastCounter,
    LPDWORD  pdwLastHelp,
    BOOL     bUpdate
    )
{
    BOOL   bResult          = TRUE;
    BOOL   bChanged         = FALSE;
    LPTSTR lpThisId;
    DWORD  dwThisId;
    DWORD  dwLastCounter    = * pdwLastCounter;
    DWORD  dwLastHelp       = * pdwLastHelp;
    DWORD  dwLastId         = (dwLastCounter > dwLastHelp)
                            ? (dwLastCounter) : (dwLastHelp);

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
             __LINE__,
             LOADPERF_CHECKNAMETABLE,
             0,
             ERROR_SUCCESS,
             TRACE_DWORD(dwLastCounter),
             TRACE_DWORD(dwLastHelp),
             NULL));
    for (lpThisId = lpNameStr;
         * lpThisId;
         lpThisId += (lstrlen(lpThisId) + 1)) {
        dwThisId = _tcstoul(lpThisId, NULL, 10);
        if ((dwThisId == 0) || (dwThisId != 1 && dwThisId % 2 != 0)) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT,
                    4, dwThisId, dwLastCounter, dwLastId, __LINE__,
                    1, lpThisId, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_CHECKNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisId),
                    TRACE_DWORD(dwThisId),
                    TRACE_DWORD(dwLastCounter),
                    TRACE_DWORD(dwLastHelp),
                    NULL));
            SetLastError(ERROR_BADKEY);
            bResult = FALSE;
            break;
        }
        else if (dwThisId > dwLastId || dwThisId > dwLastCounter) {
            if (bUpdate) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT,
                        4, dwThisId, dwLastCounter, dwLastId, __LINE__,
                        1, lpThisId, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_CHECKNAMETABLE,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_BADKEY,
                        TRACE_WSTR(lpThisId),
                        TRACE_DWORD(dwThisId),
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
                SetLastError(ERROR_BADKEY);
                bResult = FALSE;
                break;
            }
            else {
                bChanged = TRUE;
                if (dwThisId > dwLastCounter) dwLastCounter = dwThisId;
                if (dwLastCounter > dwLastId) dwLastId      = dwLastCounter;
            }
        }

        lpThisId += (lstrlen(lpThisId) + 1);
    }

    if (! bResult) goto Cleanup;

    for (lpThisId = lpHelpStr;
         * lpThisId;
         lpThisId += (lstrlen(lpThisId) + 1)) {

        dwThisId = _tcstoul(lpThisId, NULL, 10);
        if ((dwThisId == 0) || (dwThisId != 1 && dwThisId % 2 == 0)) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT,
                    4, dwThisId, dwLastHelp, dwLastId, __LINE__,
                    1, lpThisId, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_CHECKNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisId),
                    TRACE_DWORD(dwThisId),
                    TRACE_DWORD(dwLastCounter),
                    TRACE_DWORD(dwLastHelp),
                    NULL));
            SetLastError(ERROR_BADKEY);
            bResult = FALSE;
            break;
        }
        else if (dwThisId > dwLastId || dwThisId > dwLastHelp) {
            if (bUpdate) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT,
                        4, dwThisId, dwLastHelp, dwLastId, __LINE__,
                        1, lpThisId, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_CHECKNAMETABLE,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_BADKEY,
                        TRACE_WSTR(lpThisId),
                        TRACE_DWORD(dwThisId),
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
                SetLastError(ERROR_BADKEY);
                bResult = FALSE;
                break;
            }
            else {
                bChanged = TRUE;
                if (dwThisId > dwLastHelp) dwLastHelp = dwThisId;
                if (dwLastHelp > dwLastId) dwLastId   = dwLastHelp;
            }
        }
        lpThisId += (lstrlen(lpThisId) + 1);
    }

Cleanup:
    if (bResult) {
        if (bChanged) {
            ReportLoadPerfEvent(
                EVENTLOG_WARNING_TYPE,
                (DWORD) LDPRFMSG_CORRUPT_PERFLIB_INDEX,
                4, * pdwLastCounter, * pdwLastHelp, dwLastCounter, dwLastHelp,
                0, NULL, NULL, NULL);
            * pdwLastCounter = dwLastCounter;
            * pdwLastHelp    = dwLastHelp;
        }
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
             __LINE__,
             LOADPERF_CHECKNAMETABLE,
             0,
             GetLastError(),
             TRACE_DWORD(dwLastCounter),
             TRACE_DWORD(dwLastHelp),
             NULL));

    return bResult;
}

BOOL
UpdateEachLanguage (
    HKEY                    hPerflibRoot,
    LPWSTR                  mszInstalledLangList,
    LPDWORD                 pdwLastCounter,
    LPDWORD                 pdwLastHelp,
    PLANGUAGE_LIST_ELEMENT  pFirstLang,
    BOOL                    bUpdate
)
/*++

UpdateEachLanguage

    Goes through list of languages and adds the sorted MULTI_SZ strings
    to the existing counter and explain text in the registry.
    Also updates the "Last Counter and Last Help" values

Arguments

    hPerflibRoot    handle to Perflib key in the registry

    mszInstalledLangList
                    MSZ string of installed language keys

    pFirstLanguage  pointer to first language entry

Return Value

    TRUE    all went as planned
    FALSE   an error occured, use GetLastError to find out what it was.

--*/
{

    PLANGUAGE_LIST_ELEMENT  pThisLang;

    LPTSTR      pHelpBuffer   = NULL;
    LPTSTR      pNameBuffer   = NULL;
    LPTSTR      pNewName      = NULL;
    LPTSTR      pNewHelp      = NULL;
    DWORD       dwLastCounter = * pdwLastCounter;
    DWORD       dwLastHelp    = * pdwLastHelp;
    DWORD       dwBufferSize;
    DWORD       dwValueType;
    DWORD       dwCounterSize;
    DWORD       dwHelpSize;
    HKEY        hKeyThisLang;
    LONG        lStatus;
    TCHAR       CounterNameBuffer [20];
    TCHAR       HelpNameBuffer [20];
    TCHAR       AddCounterNameBuffer [20];
    TCHAR       AddHelpNameBuffer [20];
    LPTSTR      szThisLang;
    BOOL        bResult = TRUE;

    if (bUpdate && dwSystemVersion != OLD_VERSION) {
        //  this isn't possible on 3.1
        MakeBackupCopyOfLanguageFiles(NULL);
    }

    for (szThisLang = mszInstalledLangList;
        *szThisLang != 0;
        szThisLang += (lstrlen(szThisLang) + 1)) {

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                 __LINE__,
                 LOADPERF_UPDATEEACHLANGUAGE,
                 ARG_DEF(ARG_TYPE_WSTR, 1),
                 ERROR_SUCCESS,
                 TRACE_WSTR(szThisLang),
                 NULL));

        if (dwSystemVersion == OLD_VERSION) {
            // Open key for this language
            lStatus = RegOpenKeyEx(
                    hPerflibRoot,
                    szThisLang,
                    RESERVED,
                    KEY_READ | KEY_WRITE,
                    & hKeyThisLang);
        } else {
            lstrcpy(CounterNameBuffer, CounterNameStr);
            lstrcat(CounterNameBuffer, szThisLang);
            lstrcpy(HelpNameBuffer, HelpNameStr);
            lstrcat(HelpNameBuffer, szThisLang);
            lstrcpy(AddCounterNameBuffer, AddCounterNameStr);
            lstrcat(AddCounterNameBuffer, szThisLang);
            lstrcpy(AddHelpNameBuffer, AddHelpNameStr);
            lstrcat(AddHelpNameBuffer, szThisLang);

            // make sure this language is loaded
            __try {
                lStatus = RegOpenKeyEx(
                        hPerflibRoot,
                        szThisLang,
                        RESERVED,
                        KEY_READ,
                        & hKeyThisLang);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                         __LINE__,
                         LOADPERF_UPDATEEACHLANGUAGE,
                         ARG_DEF(ARG_TYPE_WSTR, 1),
                         lStatus,
                         TRACE_WSTR(szThisLang),
                         NULL));
            }

            // we just need the open status, not the key handle so
            // close this handle and set the one we need.

            if (lStatus == ERROR_SUCCESS) {
                RegCloseKey (hKeyThisLang);
            }
            hKeyThisLang = hPerfData;
        }

        if (bUpdate) {
            // look up the new strings to add
            pThisLang = FindLanguage(pFirstLang, szThisLang);
            if (pThisLang == NULL) {
                // try default language if available
                pThisLang = FindLanguage(pFirstLang, DefaultLangTag);
            }
            if (pThisLang == NULL) {
                // try english language if available
                pThisLang = FindLanguage(pFirstLang, DefaultLangId);
            }

            if (pThisLang == NULL) {
                // unable to add this language so continue
                lStatus = ERROR_NO_MATCH;
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        0,
                        lStatus,
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
            }
            else {
                if (   pThisLang->NameBuffer == NULL
                    || pThisLang->HelpBuffer == NULL) {
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_CORRUPT_INCLUDE_FILE, // event,
                            1, __LINE__, 0, 0, 0,
                            1, pThisLang->LangId, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_WARNING),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_UPDATEEACHLANGUAGE,
                            ARG_DEF(ARG_TYPE_WSTR, 1),
                            LDPRFMSG_CORRUPT_INCLUDE_FILE,
                            TRACE_WSTR(pThisLang->LangId),
                            NULL));
                    lStatus = LDPRFMSG_CORRUPT_INCLUDE_FILE;
                }
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
            }
        }

        if (lStatus == ERROR_SUCCESS) {
            // get size of counter names

            dwBufferSize = 0;
            __try {
                lStatus = RegQueryValueEx (
                            hKeyThisLang,
                            (dwSystemVersion == OLD_VERSION) ? Counters : CounterNameBuffer,
                            RESERVED,
                            & dwValueType,
                            NULL,
                            & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                if (dwSystemVersion != OLD_VERSION) {
                    // this means the language is not installed in the system.
                    continue;
                }
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                        2, lStatus, __LINE__, 0, 0,
                        1, szThisLang, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(szThisLang),
                        TRACE_WSTR(Counters),
                        NULL));
                bResult = FALSE;
                goto Cleanup;
            }

            dwCounterSize = dwBufferSize;

            // get size of help text

            dwBufferSize = 0;
            __try {
                lStatus = RegQueryValueEx (
                            hKeyThisLang,
                            (dwSystemVersion == OLD_VERSION) ? Help : HelpNameBuffer,
                            RESERVED,
                            & dwValueType,
                            NULL,
                            & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                if (dwSystemVersion != OLD_VERSION) {
                    // this means the language is not installed in the system.
                    continue;
                }
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                        2, lStatus, __LINE__, 0, 0,
                        1, szThisLang, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(szThisLang),
                        TRACE_WSTR(Help),
                        NULL));
                bResult = FALSE;
                goto Cleanup;
            }

            dwHelpSize = dwBufferSize;

            // allocate new buffers

            if (bUpdate) {
                dwCounterSize += pThisLang->dwNameBuffSize;
                dwHelpSize    += pThisLang->dwHelpBuffSize;
            }

            pNameBuffer = MemoryAllocate(dwCounterSize);
            pHelpBuffer = MemoryAllocate(dwHelpSize);
            if (!pNameBuffer || !pHelpBuffer) {
                lStatus = ERROR_OUTOFMEMORY;
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        0,
                        ERROR_OUTOFMEMORY,
                        NULL));
                bResult = FALSE;
                goto Cleanup;
            }

            ZeroMemory(pNameBuffer, dwCounterSize);
            ZeroMemory(pHelpBuffer, dwHelpSize);

            // load current buffers into memory

            // read counter names into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Name"

            dwBufferSize = dwCounterSize;
            __try {
                lStatus = RegQueryValueEx (
                            hKeyThisLang,
                            (dwSystemVersion == OLD_VERSION) ? Counters : CounterNameBuffer,
                            RESERVED,
                            & dwValueType,
                            (LPVOID)pNameBuffer,
                            & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                        2, lStatus, __LINE__, 0, 0,
                        1, szThisLang, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(szThisLang),
                        TRACE_WSTR(Counters),
                        NULL));
                bResult = FALSE;
                goto Cleanup;
            }

            if (bUpdate) {
                // set pointer to location in buffer where new string should be
                // appended: end of buffer - 1 (second null at end of MULTI_SZ
                pNewName = (LPTSTR)
                           ((PBYTE)pNameBuffer + dwBufferSize - sizeof(TCHAR));

                // adjust buffer length to take into account 2nd null from 1st
                // buffer that has been overwritten
                dwCounterSize -= sizeof(TCHAR);
            }

            // read explain text into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Text..."
            dwBufferSize = dwHelpSize;
            __try {
                lStatus = RegQueryValueEx (
                            hKeyThisLang,
                            (dwSystemVersion == OLD_VERSION) ? Help : HelpNameBuffer,
                            RESERVED,
                            & dwValueType,
                            (LPVOID)pHelpBuffer,
                            & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                        2, lStatus, __LINE__, 0, 0,
                        1, szThisLang, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(szThisLang),
                        TRACE_WSTR(Help),
                        NULL));
                bResult = FALSE;
                goto Cleanup;
            }

            if (bUpdate) {
                // set pointer to location in buffer where new string should be
                // appended: end of buffer - 1 (second null at end of MULTI_SZ
                pNewHelp = (LPTSTR)
                           ((PBYTE)pHelpBuffer + dwBufferSize - sizeof(TCHAR));

                // adjust buffer length to take into account 2nd null from 1st
                // buffer that has been overwritten
                dwHelpSize -= sizeof(TCHAR);
            }

            if (bUpdate) {
                // append new strings to end of current strings
                memcpy(pNewHelp, pThisLang->HelpBuffer, pThisLang->dwHelpBuffSize);
                memcpy(pNewName, pThisLang->NameBuffer, pThisLang->dwNameBuffSize);
            }

            if (! CheckNameTable(pNameBuffer, pHelpBuffer,
                                 & dwLastCounter, & dwLastHelp, bUpdate)) {
                bResult = FALSE;
                goto Cleanup;
            }

            if (bUpdate) {
                if (dwSystemVersion == OLD_VERSION) {
                    // load new strings back to the registry
                    lStatus = RegSetValueEx (
                            hKeyThisLang,
                            Counters,
                            RESERVED,
                            REG_MULTI_SZ,
                            (LPBYTE) pNameBuffer,
                            dwCounterSize);
                    if (lStatus != ERROR_SUCCESS) {
                        ReportLoadPerfEvent(
                                EVENTLOG_ERROR_TYPE, // error type
                                (DWORD) LDPRFMSG_UNABLE_UPDATE_COUNTER_STRINGS, // event,
                                2, lStatus, __LINE__, 0, 0,
                                1, pThisLang->LangId, NULL, NULL);
                        TRACE((WINPERF_DBG_TRACE_ERROR),
                              (& LoadPerfGuid,
                                __LINE__,
                            LOADPERF_UPDATEEACHLANGUAGE,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            lStatus,
                            TRACE_WSTR(pThisLang->LangId),
                            TRACE_WSTR(Counters),
                            NULL));
                        bResult = FALSE;
                        goto Cleanup;
                    }

                    lStatus = RegSetValueEx (
                            hKeyThisLang,
                            Help,
                            RESERVED,
                            REG_MULTI_SZ,
                            (LPBYTE) pHelpBuffer,
                            dwHelpSize);
                    if (lStatus != ERROR_SUCCESS) {
                        ReportLoadPerfEvent(
                                EVENTLOG_ERROR_TYPE, // error type
                                (DWORD) LDPRFMSG_UNABLE_UPDATE_HELP_STRINGS, // event,
                                2, lStatus, __LINE__, 0, 0,
                                1, pThisLang->LangId, NULL, NULL);
                        TRACE((WINPERF_DBG_TRACE_ERROR),
                              (& LoadPerfGuid,
                                __LINE__,
                            LOADPERF_UPDATEEACHLANGUAGE,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            lStatus,
                            TRACE_WSTR(pThisLang->LangId),
                            TRACE_WSTR(Help),
                            NULL));
                        bResult = FALSE;
                        goto Cleanup;
                    }
                } else {
                    // write to the file thru PerfLib
                    dwBufferSize = dwCounterSize;
                    __try {
                        lStatus = RegQueryValueEx (
                                        hKeyThisLang,
                                        AddCounterNameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        (LPVOID) pNameBuffer,
                                        & dwBufferSize);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    if (lStatus != ERROR_SUCCESS) {
                        ReportLoadPerfEvent(
                                EVENTLOG_ERROR_TYPE, // error type
                                (DWORD) LDPRFMSG_UNABLE_UPDATE_COUNTER_STRINGS, // event,
                                2, lStatus, __LINE__, 0, 0,
                                1, pThisLang->LangId, NULL, NULL);
                        TRACE((WINPERF_DBG_TRACE_ERROR),
                              (& LoadPerfGuid,
                                __LINE__,
                            LOADPERF_UPDATEEACHLANGUAGE,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            lStatus,
                            TRACE_WSTR(pThisLang->LangId),
                            TRACE_WSTR(AddCounterNameBuffer),
                            NULL));
                        bResult = FALSE;
                        goto Cleanup;
                    }
                    dwBufferSize = dwHelpSize;
                    __try {
                        lStatus = RegQueryValueEx (
                                    hKeyThisLang,
                                    AddHelpNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID) pHelpBuffer,
                                    & dwBufferSize);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }
                    if (lStatus != ERROR_SUCCESS) {
                        ReportLoadPerfEvent(
                                EVENTLOG_ERROR_TYPE, // error type
                                (DWORD) LDPRFMSG_UNABLE_UPDATE_HELP_STRINGS, // event,
                                2, lStatus, __LINE__, 0, 0,
                                1, pThisLang->LangId, NULL, NULL);
                        TRACE((WINPERF_DBG_TRACE_ERROR),
                              (& LoadPerfGuid,
                                __LINE__,
                            LOADPERF_UPDATEEACHLANGUAGE,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            lStatus,
                            TRACE_WSTR(pThisLang->LangId),
                            TRACE_WSTR(AddHelpNameBuffer),
                            NULL));
                        bResult = FALSE;
                        goto Cleanup;
                    }
                }
            }
            MemoryFree(pNameBuffer);
            MemoryFree(pHelpBuffer);
            pNameBuffer = NULL;
            pHelpBuffer = NULL;

            if (dwSystemVersion == OLD_VERSION) {
                RegCloseKey (hKeyThisLang);
            }
        } else {
            OUTPUT_MESSAGE (GetFormatResource (LC_UNABLEOPENLANG), szThisLang);
        }
    }

Cleanup:

    if (! bResult) {
        SetLastError(lStatus);
    }
    else if (! bUpdate) {
        * pdwLastCounter = dwLastCounter;
        * pdwLastHelp    = dwLastHelp;
    }
    if (pNameBuffer != NULL) MemoryFree(pNameBuffer);
    if (pHelpBuffer != NULL) MemoryFree(pHelpBuffer);
    return bResult;
}

BOOL
UpdateRegistry (
    LPTSTR                  lpIniFile,
    LPTSTR                  lpDriverName,
    PLANGUAGE_LIST_ELEMENT  pFirstLang,
    PSYMBOL_TABLE_ENTRY     pFirstSymbol,
    PPERFOBJECT_LOOKUP      plObjectGuidTable,
    LPDWORD                 pdwObjectGuidTableSize,
    LPDWORD                 pdwIndexValues

)
/*++

UpdateRegistry

    - checks, and if not busy, sets the "busy" key in the registry
    - Reads in the text and help definitions from the .ini file
    - Reads in the current contents of the HELP and COUNTER names
    - Builds a sorted MULTI_SZ struct containing the new definitions
    - Appends the new MULTI_SZ to the current as read from the registry
    - loads the new MULTI_SZ string into the registry
    - updates the keys in the driver's entry and Perflib's entry in the
        registry (e.g. first, last, etc)
    - deletes the DisablePerformanceCounters value if it's present in 
        order to re-enable the perf counter DLL
    - clears the "busy" key

Arguments

    lpIniFile
    pathname to .ini file conatining definitions

    hKeyMachine
    handle to HKEY_LOCAL_MACHINE in registry on system to
    update counters for.

    lpDriverName
    Name of device driver to load counters for

    pFirstLang
    pointer to first element in language structure list

    pFirstSymbol
    pointer to first element in symbol definition list


Return Value

    TRUE if registry updated successfully
    FALSE if registry not updated
    (This routine will print an error message to stdout if an error
    is encountered).

--*/
{

    HKEY    hDriverPerf = NULL;
    HKEY    hPerflib = NULL;

    LPTSTR  lpDriverKeyPath;
    HKEY    hKeyMachine = NULL;

    DWORD   dwType;
    DWORD   dwSize;

    DWORD   dwFirstDriverCounter;
    DWORD   dwFirstDriverHelp;
    DWORD   dwLastDriverCounter;
    DWORD   dwLastPerflibCounter;
    DWORD   dwLastPerflibHelp;
    DWORD   dwPerflibBaseIndex;
    DWORD   dwLastCounter;
    DWORD   dwLastHelp;

    BOOL    bStatus;
    LONG    lStatus;

    LPTSTR  lpszObjectList = NULL;
    DWORD   dwObjectList   = dwFileSize;
    LPTSTR  mszLangList    = NULL;

    DWORD dwWaitStatus;
    HANDLE  hLocalMutex = NULL;

    if (LoadPerfGrabMutex() == FALSE) {
        return FALSE;
    }

    bStatus = FALSE;
    SetLastError (ERROR_SUCCESS);

    // allocate temporary buffers
    lpDriverKeyPath = MemoryAllocate (MAX_PATH * sizeof(TCHAR));
    if (dwObjectList < MAX_PROFILE_BUFFER * sizeof(TCHAR)) {
        dwObjectList = MAX_PROFILE_BUFFER * sizeof(TCHAR);
    }
    lpszObjectList = MemoryAllocate(dwObjectList);
    if (lpDriverKeyPath == NULL || lpszObjectList == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        goto UpdateRegExit;
    }
    ZeroMemory(lpDriverKeyPath, MAX_PATH * sizeof(TCHAR));
    ZeroMemory(lpszObjectList, dwObjectList);

    // build driver key path string

    lstrcpy (lpDriverKeyPath, DriverPathRoot);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, lpDriverName);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, Performance);

    // check if we need to connect to remote machine
    if (ComputerName[0]) {
        lStatus = !ERROR_SUCCESS;
        try {
            lStatus = RegConnectRegistry(
                        (LPTSTR) ComputerName,
                        HKEY_LOCAL_MACHINE,
                        & hKeyMachine);
        } finally {
            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                hKeyMachine = NULL;
                OUTPUT_MESSAGE (GetFormatResource(LC_CONNECT_PROBLEM),
                    ComputerName, lStatus);
                bStatus = FALSE;
            }
        }
        if (lStatus != ERROR_SUCCESS)
            goto UpdateRegExit;
    } else {
        hKeyMachine = HKEY_LOCAL_MACHINE;
    }

    // open keys to registry
    // open key to driver's performance key

    __try {
        lStatus = RegOpenKeyEx(
                    hKeyMachine,
                    lpDriverKeyPath,
                    RESERVED,
                    KEY_WRITE | KEY_READ,
                    & hDriverPerf);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) lpDriverKeyPath, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_DRIVERPERF1), lpDriverKeyPath);
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_DRIVERPERF2), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpIniFile),
                TRACE_WSTR(lpDriverName),
                NULL));
        goto UpdateRegExit;
    }

    // open key to perflib's "root" key

    __try {
        lStatus = RegOpenKeyEx(
                    hKeyMachine,
                    NamesKey,
                    RESERVED,
                    KEY_WRITE | KEY_READ,
                    & hPerflib);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_PERFLIB), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(NamesKey),
                NULL));
        goto UpdateRegExit;
    }

    // get "LastCounter" values from PERFLIB

    dwType = 0;
    dwLastPerflibCounter = 0;
    dwSize = sizeof (dwLastPerflibCounter);
    __try {
        lStatus = RegQueryValueEx (
                    hPerflib,
                    LastCounter,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwLastPerflibCounter,
                    & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_ERR_READLASTPERFLIB), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastCounter),
                NULL));
        goto UpdateRegExit;
    }

    // get "LastHelp" value now

    dwType = 0;
    dwLastPerflibHelp = 0;
    dwSize = sizeof (dwLastPerflibHelp);
    __try {
       lStatus = RegQueryValueEx (
                 hPerflib,
                 LastHelp,
                 RESERVED,
                 & dwType,
                 (LPBYTE) & dwLastPerflibHelp,
                 & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_ERR_READLASTPERFLIB), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastHelp),
                NULL));
        goto UpdateRegExit;
    }

    // get "Base Index" value now
    dwType = 0;
    dwPerflibBaseIndex = 0;
    dwSize = sizeof (dwPerflibBaseIndex);
    __try {
        lStatus = RegQueryValueEx (
                    hPerflib,
                    szBaseIndex,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwPerflibBaseIndex,
                    & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                2, (LPWSTR) szBaseIndex, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_ERR_READLASTPERFLIB), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(szBaseIndex),
                NULL));
        goto UpdateRegExit;
    }

    // get "Version" value now

    dwType = 0;
    dwSize = sizeof (dwSystemVersion);
    __try {
        lStatus = RegQueryValueEx (
                    hPerflib,
                    VersionStr,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwSystemVersion,
                    & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        dwSystemVersion = OLD_VERSION;
    }


    // set the hPerfData to HKEY_PERFORMANCE_DATA for new version
    // if remote machine, then need to connect to it.
    if (dwSystemVersion != OLD_VERSION) {
        hPerfData = HKEY_PERFORMANCE_DATA;
        lStatus = !ERROR_SUCCESS;
        if (ComputerName[0]) {
        // have to do it the old faction way
        dwSystemVersion = OLD_VERSION;
        lStatus = ERROR_SUCCESS;
        }
    } // NEW_VERSION

    // see if this driver's counter names have already been installed
    // by checking to see if LastCounter's value is less than Perflib's
    // Last Counter

    dwType = 0;
    dwLastDriverCounter = 0;
    dwSize = sizeof (dwLastDriverCounter);
    __try {
        lStatus = RegQueryValueEx (
                    hDriverPerf,
                    LastCounter,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwLastDriverCounter,
                    & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }

    if (lStatus == ERROR_SUCCESS) {
        // if key found, then compare with perflib value and exit this
        // procedure if the driver's last counter is <= to perflib's last
        //
        // if key not found, then continue with installation
        // on the assumption that the counters have not been installed

        if (dwLastDriverCounter <= dwLastPerflibCounter) {
            OUTPUT_MESSAGE (GetFormatResource(LC_ERR_ALREADY_IN), lpDriverName);
            SetLastError (ERROR_ALREADY_EXISTS);
            goto UpdateRegExit;
        }
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UPDATEREGISTRY,
            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
            lStatus,
            TRACE_WSTR(lpIniFile),
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwLastPerflibCounter),
            TRACE_DWORD(dwLastPerflibHelp),
            TRACE_DWORD(dwPerflibBaseIndex),
            TRACE_DWORD(dwSystemVersion),
            NULL));

    // set the "busy" indicator under the PERFLIB key

    dwSize = lstrlen(lpDriverName) * sizeof (TCHAR);
    __try {
        lStatus = RegSetValueEx(
                    hPerflib,
                    Busy,
                    RESERVED,
                    REG_SZ,
                    (LPBYTE) lpDriverName,
                    dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }

    if (lStatus != ERROR_SUCCESS) {
        OUTPUT_MESSAGE (GetFormatResource (LC_ERR_UNABLESETBUSY), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(Busy),
                NULL));
        goto UpdateRegExit;
    }

    dwLastCounter        = dwLastPerflibCounter;
    dwLastHelp           = dwLastPerflibHelp;

    // get the list of installed languages on this machine
    if (!GetInstalledLanguageList (hPerflib, &mszLangList)) {
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_UPDATELANG), GetLastError());
        goto UpdateRegExit;
    }
    if (!UpdateEachLanguage(hPerflib,
                            mszLangList,
                            & dwLastCounter,
                            & dwLastHelp,
                            pFirstLang,
                            FALSE)) {
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_UPDATELANG), GetLastError());
        goto UpdateRegExit;
    }


    // increment (by 2) the last counters so they point to the first
    // unused index after the existing names and then
    // set the first driver counters

    dwFirstDriverCounter = dwLastCounter + 2;
    dwFirstDriverHelp    = dwLastHelp    + 2;

    if (   (dwPerflibBaseIndex < PERFLIB_BASE_INDEX)
        || (dwFirstDriverCounter < dwPerflibBaseIndex)
        || (dwFirstDriverHelp < dwPerflibBaseIndex)) {
        // potential CounterIndex/HelpIndex overlap with Base counters,
        //
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                4, dwPerflibBaseIndex, dwFirstDriverCounter, dwFirstDriverHelp, __LINE__,
                1, lpDriverName, NULL, NULL);
        lStatus = ERROR_BADKEY;
        SetLastError(lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_DWORD(dwPerflibBaseIndex),
                TRACE_DWORD(dwFirstDriverCounter),
                TRACE_DWORD(dwFirstDriverHelp),
                NULL));
        goto UpdateRegExit;
    }

    // load .INI file definitions into language tables

    if (!LoadLanguageLists (lpIniFile, dwFirstDriverCounter , dwFirstDriverHelp,
        pFirstSymbol, pFirstLang)) {
        // error message is displayed by LoadLanguageLists so just abort
        // error is in GetLastError already
        goto UpdateRegExit;
    }

    if (!CreateObjectList (lpIniFile, dwFirstDriverCounter, pFirstSymbol,
        lpszObjectList, plObjectGuidTable, pdwObjectGuidTableSize)) {
        // error message is displayed by CreateObjectList so just abort
        // error is in GetLastError already

        goto UpdateRegExit;
    }

    // all the symbols and definitions have been loaded into internal
    // tables. so now they need to be sorted and merged into a multiSZ string
    // this routine also updates the "last" counters

    if (!SortLanguageTables (pFirstLang, &dwLastCounter, &dwLastHelp)) {
        OUTPUT_MESSAGE (GetFormatResource(LC_UNABLESORTTABLES), GetLastError());
        goto UpdateRegExit;
    }

    if (   (dwLastCounter < dwLastPerflibCounter)
        || (dwLastHelp < dwLastPerflibHelp)) {
        // potential CounterIndex/HelpIndex overlap with Base counters,
        //
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                4, dwLastPerflibCounter, dwLastCounter, dwLastHelp, __LINE__,
                1 , lpDriverName, NULL, NULL);
        lStatus = ERROR_BADKEY;
        SetLastError(lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_DWORD(dwLastPerflibCounter),
                TRACE_DWORD(dwLastPerflibHelp),
                TRACE_DWORD(dwLastCounter),
                TRACE_DWORD(dwLastHelp),
                NULL));
        goto UpdateRegExit;
    }

    if (!UpdateEachLanguage(hPerflib,
                            mszLangList,
                            & dwLastCounter,
                            & dwLastHelp,
                            pFirstLang,
                            TRUE)) {
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_UPDATELANG), GetLastError());
        goto UpdateRegExit;
    }

    dwLastPerflibCounter = dwLastCounter;
    dwLastPerflibHelp    = dwLastHelp;

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UPDATEREGISTRY,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwFirstDriverCounter),
            TRACE_DWORD(dwFirstDriverHelp),
            TRACE_DWORD(dwLastPerflibCounter),
            TRACE_DWORD(dwLastPerflibHelp),
            NULL));

    if (dwLastCounter < dwFirstDriverCounter) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_CORRUPT_INDEX_RANGE, // event,
                3, dwFirstDriverCounter, dwLastCounter, __LINE__, 0,
                2, (LPWSTR) Counters, (LPWSTR) lpDriverKeyPath, NULL);
        goto UpdateRegExit;
    }
    if (dwLastHelp < dwFirstDriverHelp) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_CORRUPT_INDEX_RANGE, // event,
                3, dwFirstDriverHelp, dwLastHelp, __LINE__, 0,
                2, (LPWSTR) Help, (LPWSTR) lpDriverKeyPath, NULL);
        goto UpdateRegExit;
    }

    // update last counters for driver and perflib

    // perflib...

    __try {
        lStatus = RegSetValueEx(
                    hPerflib,
                    LastCounter,
                    RESERVED,
                    REG_DWORD,
                    (LPBYTE) & dwLastPerflibCounter,
                    sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwLastPerflibCounter, __LINE__, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            LastCounter, szPerflib);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastCounter),
                TRACE_DWORD(dwLastPerflibCounter),
                NULL));
    }

    __try {
        lStatus = RegSetValueEx(
                    hPerflib,
                    LastHelp,
                    RESERVED,
                    REG_DWORD,
                    (LPBYTE) & dwLastPerflibHelp,
                    sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwLastPerflibHelp, __LINE__, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            LastHelp, szPerflib);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastHelp),
                TRACE_DWORD(dwLastPerflibHelp),
                NULL));
    }

    // and the driver

    __try {
        lStatus = RegSetValueEx(
                    hDriverPerf,
                    LastCounter,
                    RESERVED,
                    REG_DWORD,
                    (LPBYTE) & dwLastPerflibCounter,
                    sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwLastPerflibCounter, __LINE__, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            LastCounter, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastCounter),
                TRACE_DWORD(dwLastPerflibCounter),
                NULL));
    }

    __try {
        lStatus = RegSetValueEx(
                    hDriverPerf,
                    LastHelp,
                    RESERVED,
                    REG_DWORD,
                    (LPBYTE) & dwLastPerflibHelp,
                    sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwLastPerflibHelp, __LINE__, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            LastHelp, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastHelp),
                TRACE_DWORD(dwLastPerflibHelp),
                NULL));
    }

    __try {
        lStatus = RegSetValueEx(
                    hDriverPerf,
                    cszFirstCounter,
                    RESERVED,
                    REG_DWORD,
                    (LPBYTE) & dwFirstDriverCounter,
                    sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwFirstDriverCounter, __LINE__, 0,
                2, (LPWSTR) cszFirstCounter, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            cszFirstCounter, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(cszFirstCounter),
                TRACE_DWORD(dwFirstDriverCounter),
                NULL));
    }

    __try {
        lStatus = RegSetValueEx(
                    hDriverPerf,
                    FirstHelp,
                    RESERVED,
                    REG_DWORD,
                    (LPBYTE) & dwFirstDriverHelp,
                    sizeof(DWORD));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                3, lStatus, dwFirstDriverHelp, __LINE__, 0,
                2, (LPWSTR) FirstHelp, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            FirstHelp, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(FirstHelp),
                TRACE_DWORD(dwFirstDriverHelp),
                NULL));
    }

    if (*lpszObjectList != 0) {
        __try {
            lStatus = RegSetValueEx(
                        hDriverPerf,
                        szObjectList,
                        RESERVED,
                        REG_SZ,
                        (LPBYTE) lpszObjectList,
                        (lstrlen(lpszObjectList) + 1) * sizeof (TCHAR));
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
        if (lStatus != ERROR_SUCCESS) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                    2, lStatus, __LINE__, 0, 0,
                    2, (LPWSTR) szObjectList, (LPWSTR) lpDriverKeyPath, NULL);
            OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            szObjectList, lpDriverName);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEREGISTRY,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    lStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_WSTR(szObjectList),
                    NULL));
        }
    }

    bStatus = TRUE;

    pdwIndexValues[0] = dwFirstDriverCounter;   // first Counter
    pdwIndexValues[1] = dwLastPerflibCounter;   // last Counter
    pdwIndexValues[2] = dwFirstDriverHelp;      // first Help
    pdwIndexValues[3] = dwLastPerflibHelp;      // last Help

    // remove "DisablePerformanceCounter" value so perf counters are re-enabled.
    lStatus = RegDeleteValue (hDriverPerf, szDisablePerformanceCounters);

    // MemoryFree temporary buffers
UpdateRegExit:
    // clear busy flag

    if (hPerflib) {
        lStatus = RegDeleteValue (
                hPerflib,
                Busy);
    }

    ReleaseMutex(hLoadPerfMutex);

    // MemoryFree temporary buffers

    // free any guid string buffers here
    // TODO: add this code

    if (lpDriverKeyPath) MemoryFree (lpDriverKeyPath);
    if (lpszObjectList)  MemoryFree (lpszObjectList);
    if (hDriverPerf)     RegCloseKey (hDriverPerf);
    if (hPerflib)        RegCloseKey (hPerflib);

    if (mszLangList != NULL) MemoryFree(mszLangList);

    if (hPerfData && hPerfData != HKEY_PERFORMANCE_DATA) {
        RegCloseKey (hPerfData);
    }

    if (hKeyMachine && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey (hKeyMachine) ;
    }

    return bStatus;
}

DWORD
GetMofFileFromIni (
    LPCWSTR    lpIniFile,
    LPWSTR    MofFilename
)
{
    DWORD   dwRetSize;
    DWORD   dwReturn = ERROR_SUCCESS;

    if (MofFilename) {
        dwRetSize = GetPrivateProfileString (
                szInfo,         // info section
                szMofFileName,  // Mof Filename value
                szNotFound,     // default value
                MofFilename,    // output buffer
                MAX_PATH,        // buffer size
                lpIniFile);        // ini file to read

        if ((lstrcmpi(MofFilename, szNotFound)) != 0) {
            // name found
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_GETMOFFILEFROMINI,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    dwReturn,
                    TRACE_WSTR(MofFilename),
                    NULL));
        } else {
            // name not found, default returned so return NULL string
            MofFilename[0] = 0;
            dwReturn = ERROR_FILE_NOT_FOUND;
        }
    } else {
        dwReturn = ERROR_INVALID_PARAMETER;
    }

    if (dwReturn != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_GETMOFFILEFROMINI, 0, dwReturn, NULL));
    }

    return dwReturn;
}

DWORD
OpenCounterAndBuildMofFile (
    LPCWSTR                lpDriverName,
    LPCWSTR                MofFilename,
    PPERFOBJECT_LOOKUP  plObjectGuidTable,
    DWORD               dwObjectGuidTableSize
)
{
    DWORD    dwType;
    DWORD    dwSize;
    HKEY    hKeyMachine = NULL;
    HKEY    hDriverPerf = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    LPWSTR    *lpCounterText;
    LPWSTR    *lpDisplayText = NULL; // Localized name strings array
    DWORD    dwLastElement;
    WCHAR    lpDriverKeyPath[MAX_PATH];
    WCHAR    wszPerfLibraryName[MAX_PATH];
    WCHAR    wszLibraryExpPath[MAX_PATH];
    WCHAR    szProviderName[MAX_PATH];
    DWORD    dwProviderNameSize;
    HANDLE    hPerfLibrary = NULL;
    CHAR    szOpenProcName[MAX_PATH];
    PM_OPEN_PROC    *pOpenProc = NULL;
    CHAR    szCollectProcName[MAX_PATH];
    PM_COLLECT_PROC    *pCollectProc = NULL;
    CHAR    szCloseProcName[MAX_PATH];
    PM_CLOSE_PROC    *pCloseProc = NULL;
    LPBYTE    pPerfBuffer = NULL;
    LPBYTE    pPerfBufferArg;
    DWORD    dwPerfBufferSize;
    DWORD    dwThisObject;
    DWORD    dwThisCounterDef;
    WCHAR    szMofBuffer[8192*2];
    DWORD    dwMofBufferSize;
    HANDLE    hMofFile;
    PERF_COUNTER_DLL_INFO    PcDllInfo;
    DWORD   dwGuidIdx;
    WCHAR    wszLocalLang[8];

    PPERF_OBJECT_TYPE    pThisObject;
    PPERF_COUNTER_DEFINITION    pThisCounterDef;

    // get registry key for this object
    // build driver key path string

    lstrcpy (lpDriverKeyPath, DriverPathRoot);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, lpDriverName);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, Performance);

    // check if we need to connect to remote machine

    if (ComputerName[0]) {
        lStatus = !ERROR_SUCCESS;
        try {
            lStatus = RegConnectRegistry (
                        (LPTSTR)ComputerName,
                        HKEY_LOCAL_MACHINE,
                        & hKeyMachine);
        } finally {
            if (lStatus != ERROR_SUCCESS) {
                hKeyMachine = NULL;
            }
        }
    } else {
        hKeyMachine = HKEY_LOCAL_MACHINE;
    }

    // bail out here if unable to open the registry
    if (hKeyMachine == NULL) return lStatus;

    // get ENGLISH string list
    lpCounterText = BuildNameTable (
        hKeyMachine,
        (LPWSTR)L"009",        // Use english as the language entry for WBEM
        &dwLastElement);

    if (lpCounterText == NULL) {
        goto MakeMofErrorExit;
    }

    // get LOCAL strings
    // get locale and convert to string first
    memset (wszLocalLang, 0, sizeof(wszLocalLang));
    swprintf (wszLocalLang,  (LPCWSTR)L"0%2.2x", (GetSystemDefaultLCID() & 0x000000FF));

    lpDisplayText = BuildNameTable (
        hKeyMachine,
        (LPWSTR)wszLocalLang,        // Use local language for strings
        &dwLastElement);

    if (lpDisplayText == NULL) {

        lpDisplayText = BuildNameTable (
                hKeyMachine,
                (LPWSTR)L"009",        // then Use english
                &dwLastElement);

        if (lpDisplayText == NULL) {
            goto MakeMofErrorExit;
        }
    }

    // open key to driver's performance key

    __try {
        lStatus = RegOpenKeyEx (
                    hKeyMachine,
                    lpDriverKeyPath,
                    RESERVED,
                    KEY_WRITE | KEY_READ,
                    & hDriverPerf);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) lpDriverKeyPath, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                NULL));
        goto MakeMofErrorExit;
    }

    // get library name
    dwType = 0;
    dwSize = sizeof(wszPerfLibraryName);
    __try {
        lStatus = RegQueryValueExW (hDriverPerf,
                        cszLibrary,
                        NULL,
                        & dwType,
                        (LPBYTE) & wszPerfLibraryName[0],
                        & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus == ERROR_SUCCESS) {
        if (dwType == REG_EXPAND_SZ) {
            // expand any environment vars
            dwSize = ExpandEnvironmentStringsW(
                wszPerfLibraryName,
                wszLibraryExpPath,
                MAX_PATH);

            if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                lStatus = ERROR_INVALID_DLL;
            }
        } else if (dwType == REG_SZ) {
            // look for dll and save full file Path
            dwSize = SearchPathW (
                NULL,   // use standard system search path
                wszPerfLibraryName,
                NULL,
                MAX_PATH,
                wszLibraryExpPath,
                NULL);

            if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                lStatus = ERROR_INVALID_DLL;
            }
        } else {
            lStatus = ERROR_INVALID_DLL;
        }
        if (lStatus != ERROR_SUCCESS) {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    lStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_WSTR(wszPerfLibraryName),
                    NULL));
        }
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(cszLibrary),
                NULL));
    }

    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        goto MakeMofErrorExit;
    }

    // get open procedure name
    dwType = 0;
    dwSize = sizeof(szOpenProcName);
    __try {
    lStatus = RegQueryValueExA (hDriverPerf,
                        caszOpen,
                        NULL,
                        & dwType,
                        (LPBYTE) & szOpenProcName[0],
                        & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(caszOpen),
                NULL));
        goto MakeMofErrorExit;
    }

    // get collect procedure name
    dwType = 0;
    dwSize = sizeof(szCollectProcName);
    __try {
        lStatus = RegQueryValueExA (hDriverPerf,
                        caszCollect,
                        NULL,
                        & dwType,
                        (LPBYTE) & szCollectProcName[0],
                        & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(caszCollect),
                NULL));
        goto MakeMofErrorExit;
    }

    // get close procedure name
    dwType = 0;
    dwSize = sizeof(szCloseProcName);
    __try {
        lStatus = RegQueryValueExA (hDriverPerf,
                        caszClose,
                        NULL,
                        & dwType,
                        (LPBYTE) & szCloseProcName[0],
                        & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(caszClose),
                NULL));
        goto MakeMofErrorExit;
    }

    // load perf counter library
    hPerfLibrary = LoadLibraryW (wszPerfLibraryName);
    if (hPerfLibrary == NULL) {
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(wszPerfLibraryName),
                NULL));
        goto MakeMofErrorExit;
    }

    // get open procedure pointer
    pOpenProc = (PM_OPEN_PROC *) GetProcAddress (
        hPerfLibrary,
        szOpenProcName);

    if (pOpenProc == NULL) {
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(szOpenProcName),
                NULL));
        goto MakeMofErrorExit;
    }

    // get collect procedure pointer
    pCollectProc = (PM_COLLECT_PROC *) GetProcAddress (
        hPerfLibrary,
        szCollectProcName);

    if (pCollectProc == NULL) {
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(szCollectProcName),
                NULL));
        goto MakeMofErrorExit;
    }

    // get close procedure pointer
    pCloseProc = (PM_CLOSE_PROC *) GetProcAddress (
        hPerfLibrary,
        szCloseProcName);

    if (pCloseProc == NULL) {
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(szCloseProcName),
                NULL));
        goto MakeMofErrorExit;
    }

    // call open procedure to initialize the counter
    __try {
        lStatus = (*pOpenProc)((LPWSTR)L"");
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        goto MakeMofErrorExit;
    }

    dwPerfBufferSize = 0;
    // call the collect function to get a buffer
    do {
        // allocate a query buffer to pass to the collect function
        dwPerfBufferSize += 0x8000;
        if (pPerfBuffer == NULL) {
            pPerfBuffer = (LPBYTE) MemoryAllocate (dwPerfBufferSize);
        } else {
            // if buffer is too small, resize and try again
            pPerfBuffer = (LPBYTE) MemoryResize (pPerfBuffer, dwPerfBufferSize);
        }

        if (pPerfBuffer == NULL) {
            goto MakeMofErrorExit;
        }

        dwSize = dwPerfBufferSize;
        dwType = 0; // count of object types
        pPerfBufferArg = pPerfBuffer;
        lStatus = (* pCollectProc) (
            (LPWSTR)L"Global",
            &pPerfBufferArg,
            &dwSize,
            &dwType);

    } while (lStatus == ERROR_MORE_DATA);

    if (lStatus != ERROR_SUCCESS) {
        goto MakeMofErrorExit;
    }

    // create temporary file for writing the MOF to

    hMofFile = CreateFileW (
        MofFilename,
        GENERIC_WRITE,
        0, // no sharing
        NULL, // default security
        CREATE_ALWAYS,    // always start fresh
        FILE_ATTRIBUTE_NORMAL, // nothing special
        NULL); // no template

    if (hMofFile == INVALID_HANDLE_VALUE) {
        // unable to create MOF file
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(MofFilename),
                NULL));
        goto MakeMofErrorExit;
    }

    lstrcpyW (szProviderName, wszPerfLibraryName);
    dwProviderNameSize = (sizeof(szProviderName) / sizeof(szProviderName[0]));
    dwMofBufferSize = (sizeof(szMofBuffer) / sizeof(szMofBuffer[0]));
    lStatus = GenerateMofHeader (szMofBuffer, (LPTSTR)ComputerName, &dwMofBufferSize);
    if (lStatus == ERROR_SUCCESS) {
        lStatus = WriteWideStringToAnsiFile (hMofFile, szMofBuffer, &dwMofBufferSize);
    }

    PcDllInfo.szWbemProviderName = szProviderName;
    PcDllInfo.szRegistryKey = (LPWSTR)lpDriverName;

    // for each object returned
    pThisObject = (PPERF_OBJECT_TYPE)pPerfBuffer;
    for (dwThisObject = 0; dwThisObject < dwType; dwThisObject++) {
        PcDllInfo.szClassGuid = (LPWSTR)L"";
        // look up class guid string in table passed in
        if (plObjectGuidTable != NULL) {
            dwGuidIdx = 0;
            while (dwGuidIdx < dwObjectGuidTableSize) {
                if (pThisObject->ObjectNameTitleIndex == (DWORD)plObjectGuidTable[dwGuidIdx].PerfObjectId) {
                    PcDllInfo.szClassGuid = plObjectGuidTable[dwGuidIdx].GuidString;
                    break;
                }
                dwGuidIdx++;
            }
        }
        if (PcDllInfo.szClassGuid[0] == 0) {
            // try the standard list
            PcDllInfo.szClassGuid = (LPWSTR)GetPerfObjectGuid (pThisObject->ObjectNameTitleIndex);
        } else {
            // just leave it blank
        }
        //   create WBEM Class object for this perf object
        dwMofBufferSize = (sizeof(szMofBuffer) / sizeof(szMofBuffer[0]));
        lStatus = GenerateMofObject (szMofBuffer, &dwMofBufferSize,
            &PcDllInfo,
            pThisObject, lpCounterText, lpDisplayText, WM_GMO_RAW_DEFINITION);
        if (lStatus == ERROR_SUCCESS) {
            if (lStatus == ERROR_SUCCESS) {
                lStatus = WriteWideStringToAnsiFile (
                    hMofFile, szMofBuffer, &dwMofBufferSize);
            }
            //    for each counter defined in this object
            pThisCounterDef = FirstCounter (pThisObject);
            for (dwThisCounterDef = 0;
                 dwThisCounterDef < pThisObject->NumCounters;
                 dwThisCounterDef++) {
                //        define a WBEM property
                dwMofBufferSize = (sizeof(szMofBuffer) / sizeof(szMofBuffer[0]));
                lStatus = GenerateMofCounter (szMofBuffer, &dwMofBufferSize,
                    pThisCounterDef, lpCounterText,lpDisplayText, WM_GMO_RAW_DEFINITION);
                if (lStatus == ERROR_SUCCESS) {
                    lStatus = WriteWideStringToAnsiFile (
                        hMofFile, szMofBuffer, &dwMofBufferSize);
                }

                pThisCounterDef = NextCounter (pThisCounterDef);
            }
            dwMofBufferSize = (sizeof(szMofBuffer) / sizeof(szMofBuffer[0]));
            lStatus = GenerateMofObjectTail (szMofBuffer, &dwMofBufferSize);
            if (lStatus == ERROR_SUCCESS) {
                lStatus = WriteWideStringToAnsiFile (
                    hMofFile, szMofBuffer, &dwMofBufferSize);
            }
        }

        // end for each object
        pThisObject = NextObject (pThisObject);    
    }

    // write end of file
    SetEndOfFile(hMofFile);
    CloseHandle(hMofFile);
    // call close proc

    lStatus = (* pCloseProc)();

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) |
                    ARG_DEF(ARG_TYPE_WSTR, 3) | ARG_DEF(ARG_TYPE_STR, 4) |
                    ARG_DEF(ARG_TYPE_STR, 5) | ARG_DEF(ARG_TYPE_STR, 6),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_WSTR(MofFilename),
            TRACE_WSTR(wszPerfLibraryName),
            TRACE_STR(szOpenProcName),
            TRACE_STR(szCollectProcName),
            TRACE_STR(szCloseProcName),
            NULL));

MakeMofErrorExit:
    // close the registry key if necessary
    if ((hKeyMachine != HKEY_LOCAL_MACHINE) &&
        (hKeyMachine != NULL)) {
        RegCloseKey (hKeyMachine);
    }

    if (hDriverPerf != NULL) RegCloseKey (hDriverPerf);

    if (lpCounterText == NULL) MemoryFree (lpCounterText);
    if (lpDisplayText == NULL) MemoryFree (lpDisplayText);

    // MemoryFree perf counter library
    if (hPerfLibrary != NULL) FreeLibrary (hPerfLibrary);

    // MemoryFree the collection buffer
    if (pPerfBuffer != NULL) MemoryFree (pPerfBuffer);

    // return
    return (DWORD)lStatus;
}

LOADPERF_FUNCTION
InstallPerfDllW (
    IN  LPCWSTR    szComputerName,
    IN  LPCWSTR    lpIniFile,
    IN  ULONG_PTR  dwFlags
)
{
    LPWSTR                lpDriverName = NULL;
    WCHAR                  MofFilename[MAX_PATH];
    PERFOBJECT_LOOKUP      plObjectGuidTable[16];
    DWORD                  dwObjectGuidTableSize;
    DWORD                  dwObjectIndex;
    LANGUAGE_LIST_ELEMENT  LangList;
    PSYMBOL_TABLE_ENTRY    SymbolTable = NULL;
    DWORD                  ErrorCode = ERROR_SUCCESS;
    DWORD                  dwIndexValues[4] = {0,0,0,0};
    HKEY                   hKeyMachine = HKEY_LOCAL_MACHINE;
    HKEY                   hKeyDriver  = NULL;

    WinPerfStartTrace(NULL);
    bQuietMode = (BOOL)((dwFlags & LOADPERF_FLAGS_DISPLAY_USER_MSGS) == 0);
    
    // initialize the object GUID table
    memset (plObjectGuidTable, 0, sizeof (plObjectGuidTable));
    dwObjectGuidTableSize = sizeof (plObjectGuidTable) / sizeof (plObjectGuidTable[0]) ;

    if (szComputerName == NULL) {
        ComputerName[0] = 0;    // use the local computer
    } else {
        if (lstrlenW(szComputerName) < FILE_NAME_BUFFER_SIZE) {
            lstrcpyW (ComputerName, szComputerName);
        } else {
            ErrorCode = ERROR_INVALID_PARAMETER;
        }
    }

    if ((lpIniFile != NULL)  && (ErrorCode == ERROR_SUCCESS)) {
        lpDriverName = MemoryAllocate (MAX_PATH * sizeof (WCHAR));
        if (lpDriverName == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto EndOfMain;
        } 

        // valid filename (i.e. file exists)
        // get device driver name

        if (!GetDriverName ((LPWSTR)lpIniFile, &lpDriverName)) {
            OUTPUT_MESSAGE (GetFormatResource(LC_DEVNAME_ERR_1), lpIniFile);
            OUTPUT_MESSAGE (GetFormatResource(LC_DEVNAME_ERR_2));
            ErrorCode = GetLastError();
            MemoryFree(lpDriverName);
            lpDriverName = NULL;
            goto EndOfMain;
        }

        hKeyMachine = HKEY_LOCAL_MACHINE;
        if (ComputerName[0]) {
            ErrorCode = RegConnectRegistry (
                          (LPTSTR) ComputerName,
                          HKEY_LOCAL_MACHINE,
                          & hKeyMachine);
            if (ErrorCode != ERROR_SUCCESS) {
                hKeyMachine = HKEY_LOCAL_MACHINE;
            }
        }
        RtlZeroMemory(szServiceDisplayName, MAX_PATH * sizeof(TCHAR));
        RtlZeroMemory(szServiceName, MAX_PATH * sizeof(TCHAR));
        lstrcpy(szServiceName, DriverPathRoot);
        lstrcat(szServiceName, Slash);
        lstrcat(szServiceName, lpDriverName);
        ErrorCode = RegOpenKeyEx(hKeyMachine,
                               szServiceName,
                               RESERVED,
                               KEY_READ | KEY_WRITE,
                               & hKeyDriver);
        if (ErrorCode == ERROR_SUCCESS) {
            DWORD dwType       = 0;
            DWORD dwBufferSize = MAX_PATH * sizeof(TCHAR);
            __try {
                ErrorCode = RegQueryValueEx(hKeyDriver,
                                  szDisplayName,
                                  RESERVED,
                                  & dwType,
                                  (LPBYTE) szServiceDisplayName,
                                  & dwBufferSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                ErrorCode = GetExceptionCode();
            }
        }
        if (ErrorCode != ERROR_SUCCESS) {
            lstrcpy(szServiceDisplayName, lpDriverName);
        }

        if (hKeyDriver != NULL) {
            RegCloseKey(hKeyDriver);
        }
        if (hKeyMachine != NULL && hKeyMachine != HKEY_LOCAL_MACHINE) {
            RegCloseKey(hKeyMachine);
        }
        ErrorCode = ERROR_SUCCESS;

        if (!BuildLanguageTables((LPWSTR)lpIniFile, &LangList)) {
            OUTPUT_MESSAGE (GetFormatResource(LC_LANGLIST_ERR), lpIniFile);
            ErrorCode = GetLastError();
            goto EndOfMain;
        }

        if (!LoadIncludeFile((LPWSTR)lpIniFile, &SymbolTable)) {
            // open errors displayed in routine
            ErrorCode = GetLastError();
            goto EndOfMain;
        }

        if (!UpdateRegistry((LPWSTR) lpIniFile,
                            lpDriverName,
                            & LangList,
                            SymbolTable,
                            plObjectGuidTable,
                            & dwObjectGuidTableSize,
                            (LPDWORD) & dwIndexValues)) {
            ErrorCode = GetLastError();
            goto EndOfMain;
        }

        if (ComputerName[0] == 0) {   // until remote is supported
            LodctrSetSericeAsTrusted(
                    lpIniFile,
                    NULL,
                    lpDriverName);
        }

        // now it's time to load the MOF for WBEM access
        if (!(dwFlags & LOADPERF_FLAGS_LOAD_REGISTRY_ONLY)) {
            // the didn't say not to, so create if necessary and
            // load the MOF into the CIMOM

            // see if there's a mof file in the Ini file (if so, use that)
            ErrorCode = GetMofFileFromIni (lpIniFile, MofFilename);

            if (ErrorCode == ERROR_FILE_NOT_FOUND) {
                WCHAR    wszTempFilename[MAX_PATH];
                MakeTempFileName (lpDriverName, wszTempFilename);
                // otherwise we'll try to make one
                ErrorCode = OpenCounterAndBuildMofFile (
                    lpDriverName, wszTempFilename,
                    plObjectGuidTable,
                    dwObjectGuidTableSize);

                if (ErrorCode == ERROR_SUCCESS) {
                    lstrcpyW (MofFilename, wszTempFilename);
                } else {
                    // report unable to create mof file
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_NO_MOF_FILE_CREATED, // event,
                            2, ErrorCode, __LINE__, 0, 0,
                            2, (LPWSTR) lpDriverName, wszTempFilename, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_INSTALLPERFDLL,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            ErrorCode,
                            TRACE_WSTR(lpDriverName),
                            TRACE_WSTR(wszTempFilename),
                            NULL));
                }
            }

            // now let's load it into the CIMOM
            if (ErrorCode == ERROR_SUCCESS) {
                ErrorCode = LodctrCompileMofFile ( ComputerName, MofFilename );
                if (ErrorCode != ERROR_SUCCESS) {
                    // display error message
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_NO_MOF_FILE_LOADED, // event,
                            2, ErrorCode, __LINE__, 0, 0,
                            2, (LPWSTR) lpDriverName, MofFilename, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_INSTALLPERFDLL,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            ErrorCode,
                            TRACE_WSTR(lpDriverName),
                            TRACE_WSTR(MofFilename),
                            NULL));
                }
            }

            // toss the mof if they don't want it
            if ((ErrorCode == ERROR_SUCCESS) &&
                (dwFlags & LOADPERF_FLAGS_DELETE_MOF_ON_EXIT)) {
                // display error message
                ReportLoadPerfEvent(
                        EVENTLOG_WARNING_TYPE, // error type
                        (DWORD) LDPRFMSG_CANT_DELETE_MOF, // event,
                        1, __LINE__, 0, 0, 0,
                        1, (LPWSTR) lpDriverName, NULL, NULL);
            }
            // reset the error code to success since all worked before the
            // MOF operations.
            ErrorCode = ERROR_SUCCESS;
        }
        // signal WMI with this change, ignore WMI return error.
        SignalWmiWithNewData (WMI_LODCTR_EVENT);
    } else {
        if (lpIniFile == NULL) {
            OUTPUT_MESSAGE (GetFormatResource(LC_NO_INIFILE), lpIniFile);
            ErrorCode = ERROR_OPEN_FAILED;
        } else {
            //Incorrect Command Format
            // display command line usage
            if (!bQuietMode) {
                DisplayCommandHelp(LC_FIRST_CMD_HELP, LC_LAST_CMD_HELP);
            }
            ErrorCode = ERROR_INVALID_PARAMETER;
        }
    }

EndOfMain:
    if (ErrorCode != ERROR_SUCCESS) {
        if (ErrorCode == ERROR_ALREADY_EXISTS) {
            ReportLoadPerfEvent(
                    EVENTLOG_INFORMATION_TYPE, // error type
                    (DWORD) LDPRFMSG_ALREADY_EXIST, // event,
                    1, __LINE__, 0, 0, 0,
                    2, (LPWSTR) lpDriverName, (LPWSTR) szServiceDisplayName, NULL);
            ErrorCode = ERROR_SUCCESS;
        }
        else if (lpDriverName != NULL) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_LOAD_FAILURE, // event,
                    2, ErrorCode, __LINE__, 0, 0,
                    1, (LPWSTR) lpDriverName, NULL, NULL);
        }
        else if (lpIniFile != NULL) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_LOAD_FAILURE, // event,
                    2, ErrorCode, __LINE__, 0, 0,
                    1, (LPWSTR) lpIniFile, NULL, NULL);
        }
        else {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_LOAD_FAILURE, // event,
                    2, ErrorCode, __LINE__, 0, 0,
                    0, NULL, NULL, NULL);
        }
    } else {
        // log success message
        ReportLoadPerfEvent(
                EVENTLOG_INFORMATION_TYPE,  // error type
                (DWORD) LDPRFMSG_LOAD_SUCCESS, // event,
                1, __LINE__, 0, 0, 0,
                2, (LPWSTR) lpDriverName, (LPWSTR) szServiceDisplayName, NULL);
    }
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_INSTALLPERFDLL,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ErrorCode,
            TRACE_WSTR(lpDriverName),
            NULL));

    for (dwObjectIndex = 0; dwObjectIndex < dwObjectGuidTableSize; dwObjectIndex++) {
        if (plObjectGuidTable[dwObjectIndex].GuidString != NULL) {
            MemoryFree (plObjectGuidTable[dwObjectIndex].GuidString);
        }
    }
    if (lpDriverName) MemoryFree (lpDriverName);
    return (ErrorCode);
}

LOADPERF_FUNCTION
InstallPerfDllA (
    IN  LPCSTR    szComputerName,
    IN  LPCSTR    szIniFile,
    IN  ULONG_PTR dwFlags
)
{
    LPWSTR    lpWideComputerName = NULL;
    LPWSTR  lpWideFileName = NULL;
    DWORD   dwStrLen;
    DWORD   lReturn;

    if (szIniFile != NULL) {
        //length of string including terminator
        dwStrLen = lstrlenA(szIniFile) + 1;

        lpWideFileName = MemoryAllocate (dwStrLen * sizeof(WCHAR));
        if (lpWideFileName != NULL) {
            mbstowcs (lpWideFileName, szIniFile, dwStrLen);
            lReturn = ERROR_SUCCESS;
        } else {
            lReturn = ERROR_OUTOFMEMORY;
        }
    } else {
        lReturn = ERROR_INVALID_PARAMETER;
    }

    if (lReturn == ERROR_SUCCESS) {
        if (szComputerName != NULL) {
            dwStrLen = lstrlenA (szComputerName) + 1;
            lpWideComputerName = (LPWSTR)MemoryAllocate (dwStrLen * sizeof(WCHAR));
            if (lpWideComputerName != NULL) {
                mbstowcs (lpWideComputerName, szComputerName, dwStrLen);
                lReturn = ERROR_SUCCESS;
            } else {
                lReturn = ERROR_OUTOFMEMORY;
            }
        } else {
            lpWideComputerName = NULL;
            lReturn = ERROR_SUCCESS;
        }

    }

    if (lReturn == ERROR_SUCCESS) {
        lReturn = InstallPerfDllW (
            lpWideComputerName,
            lpWideFileName,
            dwFlags);
        MemoryFree (lpWideFileName);
        MemoryFree (lpWideComputerName);
    }

    return lReturn;
}

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
)
/*++

LoadPerfCounterTexStringsW

    loads the perf counter strings into the registry and updates
    the perf counter text registry values

Arguments

    command line string in the following format:

    "/?"                    displays the usage text
    "file.ini"              loads the perf strings found in file.ini
    "\\machine file.ini"    loads the perf strings found onto machine


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPWSTR  lpIniFile;

    DWORD                        ErrorCode = ERROR_SUCCESS;
    ULONG_PTR                    dwFlags = 0;

    WinPerfStartTrace(NULL);

    dwFlags |= (bQuietModeArg ? 0 : LOADPERF_FLAGS_DISPLAY_USER_MSGS);

    lpIniFile = MemoryAllocate (MAX_PATH * sizeof (TCHAR));

    if (!lpIniFile) {
        return (ERROR_OUTOFMEMORY);
    }
    *lpIniFile = 0;

    // init last error value
    SetLastError (ERROR_SUCCESS);

    // read command line to determine what to do
    if (GetFileFromCommandLine (lpCommandLine, &lpIniFile, &dwFlags)) {
        dwFlags |= LOADPERF_FLAGS_LOAD_REGISTRY_ONLY; // don't do mof's even if they want
        // call installation function
        ErrorCode = InstallPerfDllW (ComputerName, lpIniFile, dwFlags);
    } else {
        //Incorrect Command Format
        // display command line usage
        if (!bQuietModeArg) {
            DisplayCommandHelp(LC_FIRST_CMD_HELP, LC_LAST_CMD_HELP);
        }
        ErrorCode = ERROR_INVALID_PARAMETER;
    }

    if (lpIniFile) MemoryFree (lpIniFile);

    return (ErrorCode);
}

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA (
    IN  LPSTR   lpAnsiCommandLine,
    IN  BOOL    bQuietModeArg
)
{
    LPWSTR  lpWideCommandLine;
    DWORD   dwStrLen;
    DWORD    lReturn;

    if (lpAnsiCommandLine != NULL) {
        //length of string including terminator
        dwStrLen = lstrlenA(lpAnsiCommandLine) + 1;

        lpWideCommandLine = MemoryAllocate (dwStrLen * sizeof(WCHAR));
        if (lpWideCommandLine != NULL) {
            mbstowcs (lpWideCommandLine, lpAnsiCommandLine, dwStrLen);
            lReturn = LoadPerfCounterTextStringsW (lpWideCommandLine,
            bQuietModeArg );
            MemoryFree (lpWideCommandLine);
        } else {
            lReturn = GetLastError();
        }
    } else {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    return lReturn;
}

LOADPERF_FUNCTION
LoadMofFromInstalledServiceW (
    IN  LPCWSTR    szServiceName,     // service to create mof for
    IN  LPCWSTR    szMofFilenameArg,  // name of file to create
    IN  ULONG_PTR  dwFlags            // flags
)
{
    DWORD ErrorCode;
    WCHAR    wszTempFilename[MAX_PATH];

    WinPerfStartTrace(NULL);

    if (szServiceName == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
    } else {
        ZeroMemory(wszTempFilename, sizeof(WCHAR) * MAX_PATH);
        if (szMofFilenameArg == NULL) {
            MakeTempFileName (szServiceName, wszTempFilename);
        } else {
            lstrcpyW (wszTempFilename, szMofFilenameArg);
        }
    
        // otherwise we'll try to make one
        ErrorCode = OpenCounterAndBuildMofFile (
                       szServiceName, wszTempFilename,
                    NULL, 0L);

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADMOFFROMINSTALLEDSERVICE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ErrorCode,
                TRACE_WSTR(szServiceName),
                TRACE_WSTR(wszTempFilename),
                NULL));
    
        // now let's load it into the CIMOM        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = SignalWmiWithNewData (WMI_LODCTR_EVENT);
        } else {
            ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE,        // error type
                    (DWORD) LDPRFMSG_NO_MOF_FILE_CREATED, // event,
                    2, ErrorCode, __LINE__, 0, 0,
                    1, (LPWSTR) szServiceName, NULL, NULL);
        }

        // if everything is going well and the caller
        // wants to delete the  file created to contain the MOF
        // then delete it
        if (ErrorCode == ERROR_SUCCESS) {
            if ((dwFlags & LOADPERF_FLAGS_DELETE_MOF_ON_EXIT) && (szMofFilenameArg == NULL)) {
                if (!DeleteFile(wszTempFilename)) {
                    ErrorCode = GetLastError();
                }
            }
        } else {
            ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE,        // error type
                    (DWORD) LDPRFMSG_NO_MOF_FILE_LOADED, // event,
                    2, ErrorCode, __LINE__, 0, 0,
                    1, (LPWSTR) szServiceName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_WARNING),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADMOFFROMINSTALLEDSERVICE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ErrorCode,
                    TRACE_WSTR(szServiceName),
                    NULL));
        }
    }

    return (ErrorCode);
}

LOADPERF_FUNCTION
LoadMofFromInstalledServiceA (
    IN  LPCSTR    szServiceName,  // service to create mof for
    IN     LPCSTR    szMofFilenameArg,  // name of file to create
    IN  ULONG_PTR   dwFlags     // delete mof on exit
)
{
    DWORD   ErrorCode = ERROR_SUCCESS;
    LPWSTR  wszServiceName;
    DWORD   dwServiceNameLen;
    LPWSTR  wszMofFilename;
    DWORD   dwMofFilenameLen;

    if (szServiceName == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
    } else {
        dwServiceNameLen = lstrlenA(szServiceName) + 1;
        wszServiceName = MemoryAllocate (
            dwServiceNameLen * sizeof(WCHAR));
        if (wszServiceName == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
        } else {
            mbstowcs (wszServiceName, szServiceName, dwServiceNameLen);
            if (szMofFilenameArg != NULL) {
                dwMofFilenameLen = lstrlenA(szMofFilenameArg) + 1;
                wszMofFilename = MemoryAllocate (dwMofFilenameLen);
                if (wszMofFilename != NULL) {
                    mbstowcs (wszMofFilename, szMofFilenameArg, dwMofFilenameLen);
                } else {
                    ErrorCode = ERROR_OUTOFMEMORY;
                }
            } else {
                wszMofFilename = NULL;
            }
            if (ErrorCode == ERROR_SUCCESS) {
                ErrorCode = LoadMofFromInstalledServiceW (
                    wszServiceName,
                    wszMofFilename,
                    dwFlags);
            }
            if (wszMofFilename != NULL) MemoryFree (wszMofFilename);
            MemoryFree (wszServiceName);
        }
    }
    return ErrorCode;
}

LOADPERF_FUNCTION
UpdatePerfNameFilesX (
    IN  LPCWSTR     szNewCtrFilePath,   // data file with new base counter strings
    IN  LPCWSTR     szNewHlpFilePath,   // data file with new base counter strings
    IN     LPWSTR      szLanguageID,       // Lang ID to update
    IN  ULONG_PTR   dwFlags             // flags
)
{
    DWORD   dwReturn = ERROR_SUCCESS;

    LPWSTR  szCtrNameIn = NULL;
    LPWSTR  szHlpNameIn = NULL;
    LPWSTR  szNewCtrStrings = NULL;
    LPWSTR  szNewHlpStrings = NULL;
    LPWSTR  szNewCtrMSZ = NULL;
    LPWSTR  szNewHlpMSZ = NULL;
    WCHAR   szSystemPath[MAX_PATH];
    DWORD   dwLength;
    LPWSTR  *pszNewNameTable = NULL;
    LPWSTR  *pszOldNameTable = NULL;
    LPWSTR  lpThisName;
    LPWSTR  szThisCtrString = NULL;
    LPWSTR  szThisHlpString = NULL;
    WCHAR   szLangSection[MAX_PATH];
    DWORD   dwOldLastEntry = 0;
    DWORD   dwNewLastEntry = 0;
    DWORD   dwStringSize;
    DWORD   dwHlpFileSize = 0, dwCtrFileSize = 0 ;
    DWORD   dwThisCounter;
    DWORD   dwSize;
    DWORD   dwLastBaseValue = 0;
    DWORD   dwType;
    DWORD   dwIndex;
    HANDLE  hCtrFileIn = INVALID_HANDLE_VALUE;
    HANDLE  hCtrFileMap = NULL;
    HANDLE  hHlpFileIn = INVALID_HANDLE_VALUE;
    HANDLE  hHlpFileMap = NULL;
    HKEY    hKeyPerflib;

    WinPerfStartTrace(NULL);

    if (szNewCtrFilePath == NULL) dwReturn = ERROR_INVALID_PARAMETER;
    if ((szNewHlpFilePath == NULL) && !(dwFlags & LODCTR_UPNF_RESTORE)) dwReturn = ERROR_INVALID_PARAMETER;
    if (szLanguageID == NULL) dwReturn = ERROR_INVALID_PARAMETER;

    if (dwReturn == ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_SUCCESS,
                TRACE_WSTR(szNewCtrFilePath),
                TRACE_WSTR(szLanguageID),
                NULL));
    }

    if ((dwReturn == ERROR_SUCCESS) && !(dwFlags & LODCTR_UPNF_RESTORE)) {
        // save the original files, unless it's a restoration
        MakeBackupCopyOfLanguageFiles (szLanguageID);
        dwLength = ExpandEnvironmentStringsW ((LPCWSTR)L"%windir%\\system32",
            (LPWSTR)szSystemPath, (sizeof(szSystemPath) / sizeof(szSystemPath[0])));
    } else {
        dwLength = 0;
        SetLastError (dwReturn);
    }

    if (dwLength > 0) {
        // create input filenames
        szCtrNameIn = MemoryAllocate (MAX_PATH * 2 * sizeof (WCHAR));
        szHlpNameIn = MemoryAllocate (MAX_PATH * 2 * sizeof (WCHAR));

        if ((szCtrNameIn != NULL) && (szHlpNameIn != NULL)) {
            ExpandEnvironmentStrings (szNewCtrFilePath, szCtrNameIn, (MAX_PATH * 2));
            ExpandEnvironmentStrings (szNewHlpFilePath, szHlpNameIn, (MAX_PATH * 2));
        } else {
            dwReturn = ERROR_OUTOFMEMORY;
        }

        if (dwReturn == ERROR_SUCCESS) {
            // open and map new files
            hCtrFileIn = CreateFile (
                szCtrNameIn, GENERIC_READ,
                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);
            if (hCtrFileIn != INVALID_HANDLE_VALUE) {
                // map file
                dwCtrFileSize = GetFileSize(hCtrFileIn, NULL);
                if (dwCtrFileSize == 0xFFFFFFFF){
                    dwReturn =GetLastError();
                }

                hCtrFileMap = CreateFileMapping (
                    hCtrFileIn, NULL, PAGE_READONLY, 0, 0, NULL);
                if (hCtrFileMap != NULL) {
                    szNewCtrStrings = (LPWSTR)MapViewOfFileEx (
                        hCtrFileMap, FILE_MAP_READ, 0, 0, 0, NULL);
                    if (szNewCtrStrings == NULL) {
                        dwReturn = GetLastError();
                    }
                } else {
                    dwReturn = GetLastError();
                }
            } else {
                dwReturn = GetLastError();
            }
        } else {
            dwReturn = GetLastError();
        }

        if (dwReturn == ERROR_SUCCESS) {
            // open and map new files
            hHlpFileIn = CreateFile (
                szHlpNameIn, GENERIC_READ,
                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);
            if (hHlpFileIn != INVALID_HANDLE_VALUE) {
                // map file
                dwHlpFileSize = GetFileSize (hHlpFileIn, NULL);
                if (dwHlpFileSize == 0xFFFFFFFF){
                    dwReturn =GetLastError();
                }
                hHlpFileMap = CreateFileMapping (
                    hHlpFileIn, NULL, PAGE_READONLY, 0, 0, NULL);
                if (hHlpFileMap != NULL) {
                    szNewHlpStrings = (LPWSTR)MapViewOfFileEx (
                        hHlpFileMap, FILE_MAP_READ, 0, 0, 0, NULL);
                    if (szNewHlpStrings == NULL) {
                        dwReturn = GetLastError();
                    }
                } else {
                    dwReturn = GetLastError();
                }
            } else {
                dwReturn = GetLastError();
            }
        } else {
            dwReturn = GetLastError();
        }
    } else if (dwFlags & LODCTR_UPNF_RESTORE) {
        szCtrNameIn = MemoryAllocate (MAX_PATH * 2 * sizeof (WCHAR));

        if (szCtrNameIn != NULL) {
            dwLength = ExpandEnvironmentStringsW (szNewCtrFilePath,
                szCtrNameIn, (sizeof(szSystemPath) / sizeof(szSystemPath[0])));

            dwNewLastEntry = GetPrivateProfileIntW (
                    (LPCWSTR)L"Perflib",
                    (LPCWSTR)L"Last Help",
                    -1,
                    szCtrNameIn);
            if (dwNewLastEntry != (DWORD)-1) {
                // get the input file size
                hCtrFileIn = CreateFile (
                    szCtrNameIn, GENERIC_READ,
                    FILE_SHARE_READ, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL);
                if (hCtrFileIn != INVALID_HANDLE_VALUE) {
                    // map file
                    dwCtrFileSize = GetFileSize (hCtrFileIn, NULL);
                } else {
                    dwCtrFileSize = 64 * 1024;  // assign 64k if unable to read it
                }
                // load new values from ini file
                szNewCtrStrings = (LPWSTR)MemoryAllocate (dwCtrFileSize * sizeof(WCHAR));
                if (szNewCtrStrings) {
                    lstrcpyW (szLangSection, (LPCWSTR)L"Perfstrings_");
                    lstrcatW (szLangSection, szLanguageID);
                    dwSize = GetPrivateProfileSectionW (
                            szLangSection,
                            szNewCtrStrings,
                            dwCtrFileSize,
                            szCtrNameIn);
                    if (dwSize == 0) {
                        lstrcpyW (szLangSection, (LPCWSTR) L"Perfstrings_009");
                        dwSize = GetPrivateProfileSectionW(
                                        szLangSection,
                                        szNewCtrStrings,
                                        dwCtrFileSize,
                                        szCtrNameIn);
                    }
                    if (dwSize == 0) {
                        dwReturn = ERROR_FILE_INVALID;
                    } else {
                        // set file sizes
                        dwHlpFileSize = 0;
                        dwCtrFileSize = (dwSize+2) * sizeof(WCHAR);
                    }
               } else {
                    dwReturn = ERROR_OUTOFMEMORY;
                }
            } else {
                // unable to open input file or file is invalid
                dwReturn = ERROR_FILE_INVALID;
            }
        } else {
            dwReturn = ERROR_OUTOFMEMORY;
        }
    }

    if ((dwReturn == ERROR_SUCCESS) && (!(dwFlags & LODCTR_UPNF_RESTORE))) {
        // build name table of current strings
        pszOldNameTable = BuildNameTable (
            HKEY_LOCAL_MACHINE,
            szLanguageID,
            &dwOldLastEntry);
        if (pszOldNameTable == NULL) {
            dwReturn = GetLastError();
        }
        dwNewLastEntry = (dwOldLastEntry == 0) ? (PERFLIB_BASE_INDEX)
                                               : (dwOldLastEntry);
    }
    else if (dwFlags & LODCTR_UPNF_RESTORE) {
        dwOldLastEntry = dwNewLastEntry;
    }

    if (dwReturn == ERROR_SUCCESS) {
        // build name table of new strings
        pszNewNameTable = (LPWSTR *)MemoryAllocate(
            (dwNewLastEntry + 2) * sizeof(LPWSTR));    // allow for index offset
        if (pszNewNameTable != NULL) {
            for (lpThisName = szNewCtrStrings;
                 *lpThisName;
                 lpThisName += (lstrlen(lpThisName)+1) ) {

                // first string should be an integer (in decimal unicode digits)

                dwThisCounter = wcstoul (lpThisName, NULL, 10);
                if (dwThisCounter == 0) {
                    continue;  // bad entry, try next
                }

                // point to corresponding counter name

                if (dwFlags & LODCTR_UPNF_RESTORE) {
                    // point to string that follows the "=" char
                    lpThisName = wcschr (lpThisName, L'=');
                    if (lpThisName != NULL) {
                        lpThisName++;
                    } else {
                        continue;
                    }
                } else {
                    // string is next in MSZ
                    lpThisName += (lstrlen(lpThisName)+1);
                }

                // and load array element;

                pszNewNameTable[dwThisCounter] = lpThisName;
            }

            if (!(dwFlags & LODCTR_UPNF_RESTORE)) {
                for (lpThisName = szNewHlpStrings;
                     *lpThisName;
                     lpThisName += (lstrlen(lpThisName)+1) ) {

                    // first string should be an integer (in decimal unicode digits)

                    dwThisCounter = wcstoul (lpThisName, NULL, 10);
                    if (dwThisCounter == 0) {
                        continue;  // bad entry, try next
                    }

                    // point to corresponding counter name

                    lpThisName += (lstrlen(lpThisName)+1);

                    // and load array element;

                    pszNewNameTable[dwThisCounter] = lpThisName;
                }
            }

            // allocate string buffers for the resulting string
            // we want to make sure there's plenty of room so we'll make it
            // the size of the input file + the current buffer

            dwStringSize = dwHlpFileSize;
            dwStringSize += dwCtrFileSize;
            if (pszOldNameTable != NULL) {
                dwStringSize += MemorySize(pszOldNameTable);
            }

            szNewCtrMSZ = MemoryAllocate (dwStringSize);
            szNewHlpMSZ = MemoryAllocate (dwStringSize);

            if ((szNewCtrMSZ == NULL) || (szNewHlpMSZ == NULL)) {
                dwReturn = ERROR_OUTOFMEMORY;
            }
        } else {
            dwReturn = ERROR_OUTOFMEMORY;
        }
    }

    if (dwReturn == ERROR_SUCCESS) {
        // write new strings into registry
        __try {
            dwReturn = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        NamesKey,
                        RESERVED,
                        KEY_READ,
                        & hKeyPerflib);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = GetExceptionCode();
        }
        dwSize = sizeof (dwLastBaseValue);
        dwLastBaseValue = 0;
        if (dwReturn == ERROR_SUCCESS) {
            __try {
                dwReturn = RegQueryValueEx (
                        hKeyPerflib,
                        szBaseIndex,
                        RESERVED,
                        & dwType,
                        (LPBYTE) & dwLastBaseValue,
                        & dwSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                dwReturn = GetExceptionCode();
            }
            if (dwLastBaseValue == 0) {
                dwReturn = ERROR_BADDB;
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEPERFNAMEFILES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    dwReturn,
                    TRACE_WSTR(szBaseIndex),
                    TRACE_DWORD(dwLastBaseValue),
                    NULL));

            RegCloseKey (hKeyPerflib);
        }
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                dwReturn,
                TRACE_WSTR(NamesKey),
                NULL));
    }

    if (dwReturn == ERROR_SUCCESS) {
        DWORD   dwLoopLimit;
        // the strings should be mapped by now
        // pszNewNameTable contains the new strings from the
        // source path and pszOldNameTable contains the strings
        // from the original system. The merge will consist of
        // taking all base values from the new table and the
        // extended values from the old table.
        dwIndex =1;
        szThisCtrString = szNewCtrMSZ;
        szThisHlpString = szNewHlpMSZ;

        // index 1 is a special case and belongs in the counter string
        // after that even numbers (starting w/ #2) go into the counter string
        // and odd numbers (starting w/ #3) go into the help string

        assert (pszNewNameTable[dwIndex] != NULL);

        szThisCtrString += swprintf (szThisCtrString,
            (LPCWSTR)L"%d", dwIndex) + 1;

        szThisCtrString += swprintf (szThisCtrString,
            (LPCWSTR)L"%s", pszNewNameTable[dwIndex]) + 1;

        dwIndex++;
        assert (dwIndex == 2);

        if (dwFlags & LODCTR_UPNF_RESTORE) {
            // restore ALL strings from the input file only if this
            // is a restoration
            dwLoopLimit = dwOldLastEntry;
        } else {
            // only update the system counters from the input file
            dwLoopLimit = dwLastBaseValue;
        }

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                0,
                ERROR_SUCCESS,
                TRACE_DWORD(dwOldLastEntry),
                TRACE_DWORD(dwLastBaseValue),
                NULL));

        for (/*dwIndex from above*/; dwIndex <= dwLoopLimit; dwIndex++) {
            if (pszNewNameTable[dwIndex] != NULL) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEPERFNAMEFILES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_SUCCESS,
                        TRACE_WSTR(pszNewNameTable[dwIndex]),
                        TRACE_DWORD(dwIndex),
                        NULL));
                if (dwIndex & 0x01) {
                    // then it's a help string
                    szThisHlpString += swprintf (szThisHlpString,
                        (LPCWSTR)L"%d", dwIndex) + 1;

                    szThisHlpString += swprintf (szThisHlpString,
                        (LPCWSTR)L"%s", pszNewNameTable[dwIndex]) + 1;
                } else {
                    // it's a counter string
                    szThisCtrString += swprintf (szThisCtrString,
                        (LPCWSTR)L"%d", dwIndex) + 1;

                    szThisCtrString += swprintf (szThisCtrString,
                        (LPCWSTR)L"%s", pszNewNameTable[dwIndex]) + 1;
                }
            } // else just skip it
        }
        for (/*dwIndex from last run */;dwIndex <= dwOldLastEntry; dwIndex++) {
            if (pszOldNameTable[dwIndex] != NULL) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEPERFNAMEFILES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_SUCCESS,
                        TRACE_WSTR(pszOldNameTable[dwIndex]),
                        TRACE_DWORD(dwIndex),
                        NULL));
               if (dwIndex & 0x01) {
                    // then it's a help string
                    szThisHlpString += swprintf (szThisHlpString,
                        (LPCWSTR)L"%d", dwIndex) + 1;

                    szThisHlpString += swprintf (szThisHlpString,
                        (LPCWSTR)L"%s", pszOldNameTable[dwIndex]) + 1;
                } else {
                    // it's a counter string
                    szThisCtrString += swprintf (szThisCtrString,
                        (LPCWSTR)L"%d", dwIndex) + 1;

                    szThisCtrString += swprintf (szThisCtrString,
                        (LPCWSTR)L"%s", pszOldNameTable[dwIndex]) + 1;
                }
            } // else just skip it
        }
        // terminate the MSZ
        *szThisCtrString++ = 0;
        *szThisHlpString++ = 0;
    }

    // close mapped memory sections:
    if (szNewCtrStrings != NULL) UnmapViewOfFile(szNewCtrStrings);
    if (hCtrFileMap != NULL)     CloseHandle(hCtrFileMap);
    if (hCtrFileIn != NULL)      CloseHandle(hCtrFileIn);
    if (szNewHlpStrings != NULL) UnmapViewOfFile(szNewHlpStrings);
    if (hHlpFileMap != NULL)     CloseHandle(hHlpFileMap);
    if (hHlpFileIn != NULL)      CloseHandle(hHlpFileIn);

    if (dwReturn == ERROR_SUCCESS) {
        // write new values to registry
        LONG        lStatus;
        WCHAR       AddCounterNameBuffer[20];
        WCHAR       AddHelpNameBuffer[20];

        lstrcpyW(AddCounterNameBuffer, AddCounterNameStr);
        lstrcatW(AddCounterNameBuffer, szLanguageID);
        lstrcpyW(AddHelpNameBuffer,    AddHelpNameStr);
        lstrcatW(AddHelpNameBuffer,    szLanguageID);

        // because these are perf counter strings, RegQueryValueEx
        // is used instead of RegSetValueEx as one might expect.

        dwSize = (DWORD)((DWORD_PTR)szThisCtrString - (DWORD_PTR)szNewCtrMSZ);
        __try {
            lStatus = RegQueryValueExW (
                        HKEY_PERFORMANCE_DATA,
                        AddCounterNameBuffer,
                        RESERVED,
                        & dwType,
                        (LPVOID) szNewCtrMSZ,
                        & dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
        if (lStatus != ERROR_SUCCESS) {
            dwReturn = (DWORD)lStatus;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEPERFNAMEFILES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(AddCounterNameBuffer),
                    TRACE_DWORD(dwSize),
                    NULL));
        }

        dwSize = (DWORD)((DWORD_PTR)szThisHlpString - (DWORD_PTR)szNewHlpMSZ);
        __try {
            lStatus = RegQueryValueExW (
                        HKEY_PERFORMANCE_DATA,
                        AddHelpNameBuffer,
                        RESERVED,
                        & dwType,
                        (LPVOID) szNewHlpMSZ,
                        & dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
        if (lStatus != ERROR_SUCCESS) {
            dwReturn = (DWORD)lStatus;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEPERFNAMEFILES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(AddHelpNameBuffer),
                    TRACE_DWORD(dwSize),
                    NULL));
        }
    }

    if (szCtrNameIn != NULL) MemoryFree (szCtrNameIn);
    if (szHlpNameIn != NULL) MemoryFree (szHlpNameIn);
    if (pszNewNameTable != NULL) MemoryFree (pszNewNameTable);
    if (pszOldNameTable != NULL) MemoryFree (pszOldNameTable);
    if (szNewCtrMSZ != NULL) MemoryFree (szNewCtrMSZ);
    if (szNewHlpMSZ != NULL) MemoryFree (szNewHlpMSZ);

    return dwReturn;
}

// exported version of the above function
LOADPERF_FUNCTION
UpdatePerfNameFilesW (
    IN  LPCWSTR     szNewCtrFilePath,   // data file with new base counter strings
    IN  LPCWSTR     szNewHlpFilePath,   // data file with new base counter strings
    IN     LPWSTR      szLanguageID,       // Lang ID to update
    IN  ULONG_PTR   dwFlags             // flags
)
{
volatile    DWORD dwStatus;

    dwStatus = UpdatePerfNameFilesX (
        szNewCtrFilePath,   // data file with new base counter strings
        szNewHlpFilePath,   // data file with new base counter strings
        szLanguageID,       // Lang ID to update
        dwFlags);             // flags

    return dwStatus;
}

LOADPERF_FUNCTION
UpdatePerfNameFilesA (
    IN  LPCSTR      szNewCtrFilePath, // data file with new base counter strings
    IN  LPCSTR      szNewHlpFilePath, // data file with new base counter strings
    IN     LPSTR       szLanguageID,  // Lang ID to update
    IN  ULONG_PTR   dwFlags     // flags
)
{
    DWORD   dwError = ERROR_SUCCESS;
    LPWSTR  wszNewCtrFilePath = NULL;
    LPWSTR  wszNewHlpFilePath = NULL;
    LPWSTR  wszLanguageID = NULL;
    DWORD   dwLength;

    if (szNewCtrFilePath != NULL) {
        dwLength = lstrlenA (szNewCtrFilePath);
        dwLength += 1; //add term null
        wszNewCtrFilePath = MemoryAllocate (dwLength * sizeof(WCHAR));
        if (wszNewCtrFilePath != NULL) {
            mbstowcs (wszNewCtrFilePath, szNewCtrFilePath, dwLength);
        }
    } else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (szNewHlpFilePath != NULL) {
        dwLength = lstrlenA (szNewHlpFilePath);
        dwLength += 1; //add term null
        wszNewHlpFilePath = MemoryAllocate (dwLength * sizeof(WCHAR));
        if (wszNewHlpFilePath != NULL) {
            mbstowcs (wszNewHlpFilePath, szNewHlpFilePath, dwLength);
        }
    } else {
        // this parameter can only be NULL if this flag bit is set.
        if (!(dwFlags & LODCTR_UPNF_RESTORE)) {
            dwError = ERROR_INVALID_PARAMETER;
        } else {
            wszNewHlpFilePath = NULL;
        }
    }

    if (szLanguageID != NULL) {
        dwLength = lstrlenA (szLanguageID);
        dwLength += 1; //add term null
        wszLanguageID= MemoryAllocate (dwLength * sizeof(WCHAR));
        if (wszLanguageID != NULL) {
            mbstowcs (wszLanguageID, szLanguageID, dwLength);
        }
    } else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (dwError == ERROR_SUCCESS) {
        dwError = UpdatePerfNameFilesX (
                        wszNewCtrFilePath,
                        wszNewHlpFilePath,
                        wszLanguageID,
                        dwFlags);
    }

    if (wszNewCtrFilePath != NULL) MemoryFree (wszNewCtrFilePath);
    if (wszNewHlpFilePath != NULL) MemoryFree (wszNewHlpFilePath);
    if (wszLanguageID != NULL) MemoryFree (wszLanguageID);

    return dwError;
}

LOADPERF_FUNCTION
SetServiceAsTrustedW (
    LPCWSTR szMachineName,  // reserved, MBZ
    LPCWSTR szServiceName
)
{
    HKEY    hKeyService_Perf;
    DWORD   dwReturn;
    WCHAR   szPerfKeyString[MAX_PATH * 2];
    HKEY    hKeyLM = HKEY_LOCAL_MACHINE;    // until remote machine access is supported
    WCHAR   szLibName[MAX_PATH * 2];
    WCHAR   szExpLibName[MAX_PATH * 2];
    WCHAR   szFullPathName[MAX_PATH * 2];
    DWORD   dwSize, dwType;
    HANDLE  hFile;
    DllValidationData   dvdLibrary;
    LARGE_INTEGER   liSize;
    BOOL    bStatus;

    WinPerfStartTrace(NULL);

    if ((szMachineName != NULL) || (szServiceName == NULL)) {
        // reserved for future use
        return ERROR_INVALID_PARAMETER;
    }

    // build path to performance subkey
    lstrcpyW (szPerfKeyString, DriverPathRoot); // SYSTEM\CurrentControlSet\Services
    lstrcatW (szPerfKeyString, Slash);
    lstrcatW (szPerfKeyString, szServiceName);
    lstrcatW (szPerfKeyString, Slash);
    lstrcatW (szPerfKeyString, Performance);

    // open performance key under the service key
    __try {
        dwReturn = RegOpenKeyExW (
                        hKeyLM,
                        szPerfKeyString,
                        0L,
                        KEY_READ | KEY_WRITE,
                        & hKeyService_Perf);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwReturn = GetExceptionCode();
    }

    if (dwReturn == ERROR_SUCCESS) {
        // get library name
        dwType = 0;
        dwSize = sizeof(szLibName) / sizeof (szLibName[0]);
        __try {
            dwReturn = RegQueryValueExW (
                        hKeyService_Perf,
                        cszLibrary,
                        NULL,
                        & dwType,
                        (LPBYTE) & szLibName[0],
                        & dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = GetExceptionCode();
        }
        if (dwReturn == ERROR_SUCCESS) {
            // expand path name if necessary
            if (dwType == REG_EXPAND_SZ) {
               dwSize = ExpandEnvironmentStringsW (
                   szLibName,
                   szExpLibName,
                   sizeof(szExpLibName) / sizeof (szExpLibName[0]));
            } else {
                lstrcpyW (szExpLibName, szLibName);
                // dwSize is same as returned from Fn Call.
            }

            if (dwSize != 0) {
                // find DLL file
                dwSize = SearchPathW (
                    NULL,
                    szExpLibName,
                    NULL,
                    sizeof(szFullPathName) / sizeof (szFullPathName[0]),
                    szFullPathName,
                    NULL);

                if (dwSize > 0) {
                    hFile = CreateFileW (
                        szFullPathName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
                    if (hFile != INVALID_HANDLE_VALUE) {
                         // read file date/time & size
                        bStatus = GetFileTime (
                            hFile,
                            &dvdLibrary.CreationDate,
                            NULL,
                            NULL);
                        if (bStatus) {
                            liSize.LowPart = GetFileSize (
                                hFile,
                                (DWORD *)&liSize.HighPart);
                            dvdLibrary.FileSize = liSize.QuadPart;
                            // set registry value
                            __try {
                                dwReturn = RegSetValueExW (
                                            hKeyService_Perf,
                                            szLibraryValidationCode,
                                            0L,
                                            REG_BINARY,
                                            (LPBYTE) & dvdLibrary,
                                            sizeof(dvdLibrary));
                            }
                            __except (EXCEPTION_EXECUTE_HANDLER) {
                                dwReturn = GetExceptionCode();
                            }

                            TRACE((WINPERF_DBG_TRACE_INFO),
                                  (& LoadPerfGuid,
                                    __LINE__,
                                    LOADPERF_SETSERVICEASTRUSTED,
                                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_WSTR, 3),
                                    dwReturn,
                                    TRACE_WSTR(szServiceName),
                                    TRACE_WSTR(szExpLibName),
                                    TRACE_WSTR(szLibraryValidationCode),
                                    NULL));
                        } else {
                            dwReturn = GetLastError();
                        }
                        CloseHandle (hFile);
                    } else {
                        dwReturn = GetLastError();
                    }
                } else {
                    dwReturn = ERROR_FILE_NOT_FOUND;
                }
            } else {
                // unable to expand environment strings
                dwReturn = GetLastError();
            }
        }
        else {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_SETSERVICEASTRUSTED,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    dwReturn,
                    TRACE_WSTR(szServiceName),
                    TRACE_WSTR(cszLibrary),
                    NULL));
        }
        // close key
        RegCloseKey (hKeyService_Perf);
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SETSERVICEASTRUSTED,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                dwReturn,
                TRACE_WSTR(szServiceName),
                TRACE_WSTR(Performance),
                NULL));
    }

    return dwReturn;
}

LOADPERF_FUNCTION
SetServiceAsTrustedA (
    LPCSTR szMachineName,  // reserved, MBZ
    LPCSTR szServiceName
)
{
    LPWSTR lpWideServiceName;
    DWORD  dwStrLen;
    DWORD  lReturn;

    if ((szMachineName != NULL) || (szServiceName == NULL)) {
        // reserved for future use
        return ERROR_INVALID_PARAMETER;
    }

    if (szServiceName != NULL) {
        //length of string including terminator
        dwStrLen = lstrlenA(szServiceName) + 1;
        lpWideServiceName = MemoryAllocate (dwStrLen * sizeof(WCHAR));
        if (lpWideServiceName != NULL) {
            mbstowcs (lpWideServiceName, szServiceName, dwStrLen);
            lReturn = SetServiceAsTrustedW (NULL, lpWideServiceName);
            MemoryFree (lpWideServiceName);
        } else {
            lReturn = GetLastError();
        }
    } else {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    return lReturn;
}

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
    )
{
    HANDLE hOut;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[1024];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return vfwprintf(str, format, argptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\wbemutil.c ===
/*
	WbemUtil.C

	functions and definitions used to access WBEM perf 
	data

*/
#include <windows.h>
#include <rpc.h>
#include <ntprfctr.h>
#include <stdio.h>
#include <assert.h>
#include "wbemutil.h"

const PERFTYPE_LOOKUP PerfTypeTable[] = 
{
	{PERF_100NSEC_MULTI_TIMER,      (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_100NSEC_MULTI_TIMER_INV,  (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_100NSEC_TIMER,            (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_100NSEC_TIMER_INV,        (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_AVERAGE_BASE,             (LPWSTR)L"uint32"	,(LPWSTR)L""},
	{PERF_AVERAGE_BULK,             (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_AVERAGE_TIMER,            (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_BULK_COUNT,       (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_COUNTER,          (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_DELTA,            (LPWSTR)L"uint32"	,(LPWSTR)L"uint32"},
	{PERF_COUNTER_HISTOGRAM_TYPE,   (LPWSTR)L""        ,(LPWSTR)L""},
	{PERF_COUNTER_LARGE_DELTA,      (LPWSTR)L"uint64"	,(LPWSTR)L"uint64"},
	{PERF_COUNTER_LARGE_QUEUELEN_TYPE, (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_LARGE_RAWCOUNT,   (LPWSTR)L"uint64"	,(LPWSTR)L"uint64"},
	{PERF_COUNTER_LARGE_RAWCOUNT_HEX, (LPWSTR)L"uint64",(LPWSTR)L"uint64"},
	{PERF_COUNTER_MULTI_BASE,       (LPWSTR)L"uint64"  ,(LPWSTR)L""},
	{PERF_COUNTER_MULTI_TIMER,      (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_MULTI_TIMER_INV,  (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_NODATA,           (LPWSTR)L""        ,(LPWSTR)L""},
	{PERF_COUNTER_QUEUELEN_TYPE,    (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_RAWCOUNT,         (LPWSTR)L"uint32"	,(LPWSTR)L"uint32"},
	{PERF_COUNTER_RAWCOUNT_HEX,     (LPWSTR)L"uint32"	,(LPWSTR)L"uint32"},
	{PERF_COUNTER_TEXT,             (LPWSTR)L"string"	,(LPWSTR)L"string"},
	{PERF_COUNTER_TIMER,            (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_TIMER_INV,        (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_ELAPSED_TIME,             (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_RAW_BASE,                 (LPWSTR)L"uint32"	,(LPWSTR)L""},
	{PERF_RAW_FRACTION,             (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_SAMPLE_FRACTION,          (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_SAMPLE_BASE,              (LPWSTR)L"uint32"	,(LPWSTR)L""},
	{PERF_SAMPLE_COUNTER,           (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_100NS_QUEUELEN_TYPE, (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE, (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_OBJ_TIME_TIMER,           (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_LARGE_RAW_BASE,           (LPWSTR)L"uint64"	,(LPWSTR)L""},
	{PERF_LARGE_RAW_FRACTION,       (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_PRECISION_SYSTEM_TIMER,   (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_PRECISION_100NS_TIMER,    (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_PRECISION_OBJECT_TIMER,   (LPWSTR)L"uint64"	,(LPWSTR)L"real64"}
};

const PPERFTYPE_LOOKUP PerfTypes = (const PPERFTYPE_LOOKUP)&PerfTypeTable[0];
const DWORD			 dwNumPerfTypes = (sizeof(PerfTypeTable) / sizeof(PerfTypeTable[0]));

const PERFOBJECT_LOOKUP PerfObjectGuidTable[] = 
{
     {SYSTEM_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F5C-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {PROCESSOR_OBJECT_TITLE_INDEX,      (LPWSTR)L"{5C7A4F5D-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {MEMORY_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F5E-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {CACHE_OBJECT_TITLE_INDEX,          (LPWSTR)L"{5C7A4F5F-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {PHYSICAL_DISK_OBJECT_TITLE_INDEX,  (LPWSTR)L"{5C7A4F60-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {LOGICAL_DISK_OBJECT_TITLE_INDEX,   (LPWSTR)L"{5C7A4F61-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {PROCESS_OBJECT_TITLE_INDEX,        (LPWSTR)L"{5C7A4F62-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {THREAD_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F63-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {OBJECT_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F64-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {REDIRECTOR_OBJECT_TITLE_INDEX,     (LPWSTR)L"{5C7A4F65-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {SERVER_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F66-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {SERVER_QUEUE_OBJECT_TITLE_INDEX,   (LPWSTR)L"{5C7A4F67-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {PAGEFILE_OBJECT_TITLE_INDEX,       (LPWSTR)L"{5C7A4F68-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {BROWSER_OBJECT_TITLE_INDEX,        (LPWSTR)L"{5C7A4F69-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {EXPROCESS_OBJECT_TITLE_INDEX,      (LPWSTR)L"{5C7A4F6A-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {IMAGE_OBJECT_TITLE_INDEX,          (LPWSTR)L"{5C7A4F6B-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {THREAD_DETAILS_OBJECT_TITLE_INDEX, (LPWSTR)L"{5C7A4F6C-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {LONG_IMAGE_OBJECT_TITLE_INDEX,     (LPWSTR)L"{5C7A4F6D-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {TCP_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F6E-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {UDP_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F6F-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {IP_OBJECT_TITLE_INDEX,             (LPWSTR)L"{5C7A4F70-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {ICMP_OBJECT_TITLE_INDEX,           (LPWSTR)L"{5C7A4F71-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {NET_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F72-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {NBT_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F73-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {NBF_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F74-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {NBF_RESOURCE_OBJECT_TITLE_INDEX,   (LPWSTR)L"{5C7A4F75-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {FTP_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F76-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {RAS_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F77-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {WIN_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F78-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {SFM_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F79-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {ATK_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F7A-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {BH_FIRST_COUNTER_INDEX,            (LPWSTR)L"{5C7A4F7B-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {TAPI_FIRST_COUNTER_INDEX,          (LPWSTR)L"{5C7A4F7C-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {LSPL_FIRST_COUNTER_INDEX,          (LPWSTR)L"{5C7A4F7D-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {JOB_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F7E-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {JOB_DETAILS_OBJECT_TITLE_INDEX,    (LPWSTR)L"{5C7A4F7F-9E4D-11d1-BB3C-00A0C913CAD4}"}
//    {RSVP_FIRST_COUNTER_INDEX,          (LPWSTR)L"{5C7A4F80-9E4D-11d1-BB3C-00A0C913CAD4}"}
};

const PPERFOBJECT_LOOKUP PerfObjectGuids = (const PPERFOBJECT_LOOKUP)&PerfObjectGuidTable[0];
const DWORD				dwNumPerfObjectGuids = (sizeof(PerfObjectGuidTable) / sizeof(PerfObjectGuidTable[0]));

LPCWSTR szRawClass = (LPCWSTR)L"Win32_PerfRawData";
LPCWSTR szFmtClass = (LPCWSTR)L"Win32_PerfFormattedData";
LPCWSTR szGenericProviderName = (LPCWSTR)L"NT5_GenericPerfProvider_V1";
LPCWSTR szGenericProviderGuid = (LPCWSTR)L"{FF37A93C-C28E-11D1-AEB6-00C04FB68820}";

__inline
static
PPERF_OBJECT_TYPE
FirstObject (
    PPERF_DATA_BLOCK pPerfData
)
{
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pPerfData + pPerfData->HeaderLength));
}


__inline
static
PPERF_OBJECT_TYPE
NextObject (
    PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pObject + pObject->TotalByteLength));
}  // NextObject

__inline
static
PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->HeaderLength);
}

__inline
static
PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pCounterDef + pCounterDef->ByteLength);
}

__inline
static
PERF_INSTANCE_DEFINITION *
FirstInstance(
    PERF_OBJECT_TYPE * pObjectDef)
{
    return (PERF_INSTANCE_DEFINITION * )
               ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}

__inline
static
PERF_INSTANCE_DEFINITION *
NextInstance(
    PERF_INSTANCE_DEFINITION * pInstDef)
{
    PERF_COUNTER_BLOCK *pCounterBlock;

    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION * )
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

__inline
static
LPCWSTR
GetInstanceName(
    PERF_INSTANCE_DEFINITION *pInstDef
)
{
    static WCHAR    szLocalName[MAX_PATH];
    LPWSTR  szSrc, szDest;

    assert ((pInstDef->NameLength) < (MAX_PATH * sizeof(WCHAR)));
    szDest = &szLocalName[0];
    szSrc = (LPWSTR) ((PCHAR) pInstDef + pInstDef->NameOffset); 

    while (*szSrc != 0) {
        switch (*szSrc) {
        case '\\':
            *szDest++ = *szSrc;
            *szDest++ = *szSrc++;
            break;

        default:
            *szDest++ = *szSrc++;
        };
    }
    *szDest++ = 0;

    return (LPCWSTR)&szLocalName[0];
}

static
__inline
DWORD
AddStringToBuffer (
	LPWSTR szBuffer, 
	LPWSTR szNewString,
	LPDWORD pLength, 
	LPDWORD pTotalLength, 
	DWORD dwMaxLength
)
{
	DWORD	dwReturn = ERROR_SUCCESS;
	if ((*pTotalLength + *pLength) < dwMaxLength) {
		memcpy (&szBuffer[*pTotalLength], szNewString, (*pLength * sizeof(WCHAR)));
		*pTotalLength += *pLength;
		szBuffer[*pTotalLength] = 0;
	} else {
		*pTotalLength += *pLength;
		dwReturn = ERROR_INSUFFICIENT_BUFFER;
	}

	return dwReturn;
}

LPCWSTR 
FormatPerfName (
    LPWSTR  szNameIn,
    BOOL    bHiddenCounter
)
{
    static WCHAR szStringBuffer[MAX_PATH];
    LPWSTR  szSrc, szDest;
    BOOL    bUpCase = FALSE;

    memset(szStringBuffer, 0, sizeof(szStringBuffer));
    szDest = &szStringBuffer[0];

    if (szNameIn != NULL) {
        for (szSrc = szNameIn; *szSrc != 0; szSrc++) {
            switch (*szSrc) {
                case '%':
                    lstrcpyW(szDest, (LPCWSTR)L"Percent");
                    szDest += lstrlenW((LPCWSTR)L"Percent");
                    bUpCase = TRUE;
                    break;
                case '#':
                    lstrcpyW(szDest, (LPCWSTR)L"NumberOf");
                    szDest += lstrlenW((LPCWSTR)L"NumberOf");
                    bUpCase = TRUE;
                    break;
                case '/':
                    lstrcpyW(szDest, (LPCWSTR)L"Per");
                    szDest += lstrlenW((LPCWSTR)L"Per");
                    bUpCase = TRUE;
                    break;
                case ' ':
                case ')':
                case '(':
                case '.':
                case '-':
                    // skip
                    bUpCase = TRUE;
                    break;
                default:
                    if (bUpCase) {
                        *szDest++ = towupper(*szSrc);
                        bUpCase = FALSE;
                    } else {
                        *szDest++ = *szSrc;
                    }
                    break;
            }
        }
        if (bHiddenCounter) {
            lstrcpyW (szDest, (LPCWSTR)L"_Base");
            szDest += lstrlenW((LPCWSTR)L"_Base");
        }
    }
    *szDest = 0;
    
    return (LPCWSTR)&szStringBuffer[0];
}

PERFTYPE_LOOKUP *
GetPerfTypeInfo (
    DWORD dwType
)
{
    DWORD   dwIndex = 0;
    
    while (dwIndex < dwNumPerfTypes) {
        if (dwType == (DWORD)PerfTypes[dwIndex].PerfType) {
            return (&PerfTypes[dwIndex]);
        } else {
            dwIndex++;
        }
    }
    return NULL;
}

LPCWSTR
GetPerfObjectGuid (
    DWORD dwObjectId
)
{
    DWORD   dwIndex = 0;
    
    while (dwIndex < dwNumPerfObjectGuids) {
        if (dwObjectId == (DWORD)PerfObjectGuids[dwIndex].PerfObjectId) {
            return ((LPCWSTR)PerfObjectGuids[dwIndex].GuidString);
        } else {
            dwIndex++;
        }
    }
    return (LPCWSTR)L"";
}

DWORD
GenerateMofHeader (
	LPWSTR	szBuffer,			// string buffer
	LPCWSTR	szComputerName,
	LPDWORD	pcchBufferSize		// max size in characters in, size used out
)
{
    WCHAR   szMachineName[MAX_PATH];
	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength = sizeof(szMachineName)/sizeof(szMachineName[0]);
    SYSTEMTIME  st;
	DWORD	dwReturn = ERROR_SUCCESS;

    if (szComputerName == NULL) {
		GetComputerNameW(&szMachineName[0], &dwLength);
	} else if (szComputerName[0] == 0){
		GetComputerNameW(&szMachineName[0], &dwLength);
	} else {
		lstrcpyW (szMachineName, szComputerName);
	}

    GetLocalTime( &st );

    dwLength = swprintf (szTempBuffer, (LPCWSTR)L"\x0D\x0A//WBEM Performance Data MOF Dumped from machine %ws on %2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d\x0D\x0A",
        szMachineName,
        st.wMonth, st.wDay, (st.wYear % 100),
        st.wHour, st.wMinute, st.wSecond);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A#pragma autorecover");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A#pragma namespace (\"\\\\\\\\.\\\\Root\\\\Default\")");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A#pragma classflags(\"forceupdate\")\x0D\x0A");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier vendor:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier classguid:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier locale:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier display:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier perfindex:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier helpindex:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier perfdetail:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier countertype:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier perfdefault:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier defaultscale:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	*pcchBufferSize = dwTotalLength;
	return dwReturn;
}

DWORD
GenerateMofObject (
	LPWSTR				szBuffer,
	LPDWORD				pcchBufferSize,
	PPERF_COUNTER_DLL_INFO	pPcDllInfo,
    PERF_OBJECT_TYPE    *pPerfObject,
	LPWSTR				*lpCounterText,	// name strings array
	LPWSTR				*lpDisplayText, // Localized name strings array
	DWORD				dwFlags
)
{
    BOOL                bRawDefinition = (dwFlags & WM_GMO_RAW_DEFINITION);
    BOOL                bCostlyObject = (dwFlags & WM_GMO_COSTLY_OBJECT);
	BOOL				bDefaultObject = (dwFlags & WM_GMO_DEFAULT_OBJECT); 

	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength;
	DWORD	dwReturn = ERROR_SUCCESS;

    dwLength = swprintf (szTempBuffer, (LPCWSTR)L"\x0D\x0A\x0D\x0A[");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A singleton,");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
    }
    if (bCostlyObject) {
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A costly,");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
    }
	if (bDefaultObject) {
		dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A perfdefault,");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	}

	if (pPcDllInfo != NULL) {
		dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A dynamic,");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
	
		if ((dwReturn == ERROR_SUCCESS) && (pPcDllInfo->szWbemProviderName != NULL)) {
			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A provider(\"%s\"),",
				szGenericProviderName);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
		} else {
			// if this structure is used, all fields must be present
			dwReturn = ERROR_INVALID_PARAMETER;
		}

		if ((dwReturn == ERROR_SUCCESS) && (pPcDllInfo->szRegistryKey != NULL)) {
			dwLength = swprintf (szTempBuffer, (LPCWSTR)L"\x0D\x0A registrykey(\"%s\"),",
				pPcDllInfo->szRegistryKey);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
		} else {
			// if this structure is used, all fields must be present
			dwReturn = ERROR_INVALID_PARAMETER;
		}

		if ((dwReturn == ERROR_SUCCESS) && (pPcDllInfo->szClassGuid != NULL)) {
            if (pPcDllInfo->szClassGuid[0] != 0) {
			    dwLength = swprintf (szTempBuffer, (LPCWSTR)L"\x0D\x0A classguid(\"%s\"),",
				    pPcDllInfo->szClassGuid);
			    dwReturn = AddStringToBuffer (
				    szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
            }
		} else {
			// if this structure is used, all fields must be present
			dwReturn = ERROR_INVALID_PARAMETER;
		}
	}
	
    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A locale(\"0x%4.4x\"),", (GetSystemDefaultLCID() & 0x0000FFFF));
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A display(\"%ws\"),", 
		lpDisplayText[pPerfObject->ObjectNameTitleIndex]);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A perfindex(%d),", pPerfObject->ObjectNameTitleIndex);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A helpindex(%d),", pPerfObject->ObjectHelpTitleIndex);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A perfdetail(%d)", pPerfObject->DetailLevel);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A]%sclass Win32Perf_%ws%ws : %ws\x0D\x0A{",
		(LPCWSTR)L"\x0D\x0A", (bRawDefinition ? (LPCWSTR)L"Raw" : (LPCWSTR)L""),
        FormatPerfName(lpCounterText[pPerfObject->ObjectNameTitleIndex],FALSE), 
        (bRawDefinition ? szRawClass : szFmtClass));
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    // add an entry for the instance name here if the object has instances
    if (pPerfObject->NumInstances != PERF_NO_INSTANCES) {
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    [key]\x0D\x0A    string\tName;");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
    }

	*pcchBufferSize = dwTotalLength;
	return dwReturn;
}

DWORD
GenerateMofObjectTail (
	LPWSTR				szBuffer,
	LPDWORD				pcchBufferSize
)
{
	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength;
	DWORD	dwReturn = ERROR_SUCCESS;

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A};\x0D\x0A");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	*pcchBufferSize = dwTotalLength;
	return dwReturn;
}

DWORD
GenerateMofCounter (
	LPWSTR					szBuffer,
	LPDWORD					pcchBufferSize,
    PERF_COUNTER_DEFINITION *pPerfCounter,
	LPWSTR				*lpCounterText,	// name strings array
	LPWSTR				*lpDisplayText, // Localized name strings array
	DWORD				dwFlags
)
{
	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength;
	DWORD	dwReturn = ERROR_SUCCESS;

    BOOL                bRawDefinition = (dwFlags & WM_GMO_RAW_DEFINITION);
    BOOL                bDefaultCounter = (dwFlags & WM_GMO_DEFAULT_COUNTER);
    PERFTYPE_LOOKUP		*pType;

    pType = GetPerfTypeInfo (pPerfCounter->CounterType);
	
	if (pType != NULL) {
		if (bRawDefinition || IsDisplayableType(pPerfCounter->CounterType)) {
			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    [");
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			if (bDefaultCounter) {
				dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     perfdefault,");
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
			}
			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     display(\"%ws\"),", 
				lpDisplayText[pPerfCounter->CounterNameTitleIndex]);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     countertype(%u),", pPerfCounter->CounterType);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     perfindex(%d),", pPerfCounter->CounterNameTitleIndex);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     helpindex(%d),", pPerfCounter->CounterHelpTitleIndex);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     defaultscale(%d),", pPerfCounter->DefaultScale);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     perfdetail(%d)", pPerfCounter->DetailLevel);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    ]\x0D\x0A    %ws\t%ws;\x0D\x0A",
				(bRawDefinition ? pType->RawType : pType->FmtType),
				 FormatPerfName (lpCounterText[pPerfCounter->CounterNameTitleIndex],
					(IsDisplayableType(pPerfCounter->CounterType) ? FALSE : TRUE)));
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
			// return size used
			*pcchBufferSize = dwTotalLength;
		}
	} else {
		dwReturn = ERROR_FILE_NOT_FOUND;
	}

	return dwReturn;
}

DWORD
GenerateMofInstances (
	LPWSTR					szBuffer,
	LPDWORD					pcchBufferSize,
    PERF_DATA_BLOCK		*   pPerfDataBlock,
    PERF_OBJECT_TYPE	*   pPerfObject,
	LPWSTR				*	lpCounterText,	// name strings array
	LPWSTR				*	lpDisplayText, // Localized name strings array
	DWORD					dwFlags
)
{
	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength;
	DWORD	dwReturn = ERROR_SUCCESS;

    BOOL bRawDefinition = (dwFlags & WM_GMO_RAW_DEFINITION);
    //
    //  for each instance, dump all the counter data for that instance
    //
    PERF_INSTANCE_DEFINITION *  pThisInstance;
    PERF_INSTANCE_DEFINITION *  pParentInstance;
    PERF_OBJECT_TYPE *          pParentObject;
    PERF_COUNTER_DEFINITION  *  pThisCounter;
    DWORD   dwParentInstIdx;
    DWORD   dwObjectIdx;
    DWORD   dwInstanceIndex;
    DWORD   dwCounterCount;
    LPDWORD   pValue;
    LONGLONG 	llTimeStamp;

    UNREFERENCED_PARAMETER (lpDisplayText);

    if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A\x0D\x0Ainstance of Win32Perf_%ws%ws\x0D\x0A{",
            (bRawDefinition ? (LPCWSTR)L"Raw" : (LPCWSTR)L""),
            FormatPerfName(lpCounterText[pPerfObject->ObjectNameTitleIndex], FALSE));
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

		GetSystemTimeAsFileTime ((LPFILETIME)&llTimeStamp);
		dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    Timestamp = ");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

		pValue = (LPDWORD)&llTimeStamp;
        pValue++;
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x", *pValue);
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

        pValue--;
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"%8.8x;", *pValue);
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);


        pThisCounter = FirstCounter(pPerfObject);
        assert (pThisCounter != NULL);
        for (dwCounterCount = 0; dwCounterCount < pPerfObject->NumCounters; dwCounterCount++) {
            dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    %ws = ", 
                 FormatPerfName (lpCounterText[pThisCounter->CounterNameTitleIndex],
                    (IsDisplayableType(pThisCounter->CounterType) ? FALSE : TRUE)));
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            pValue = (LPDWORD)pPerfObject;
            pValue = (LPDWORD)((LPBYTE)pValue + pPerfObject->DefinitionLength);
            pValue = (LPDWORD)((LPBYTE)pValue + pThisCounter->CounterOffset);

            if (pThisCounter->CounterSize == 8) {
                pValue++;
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x", *pValue);
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                pValue--;
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"%8.8x;", *pValue);
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            } else {
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x;", *pValue);
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            }
            pThisCounter = NextCounter (pThisCounter);
        }
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A};\x0D\x0A");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    } else {
        // do the multiple instance case here
        pThisInstance = FirstInstance(pPerfObject);
        for (dwInstanceIndex = 0; dwInstanceIndex < (DWORD)pPerfObject->NumInstances; dwInstanceIndex++)  {
            dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A\x0D\x0Ainstance of Win32Perf_%ws%ws\x0D\x0A{",
                (bRawDefinition ? (LPCWSTR)L"Raw" : (LPCWSTR)L""),
                FormatPerfName(lpCounterText[pPerfObject->ObjectNameTitleIndex],FALSE));
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            if (pThisInstance->ParentObjectTitleIndex > 0) {
                // get parent instance name
                pParentObject = FirstObject(pPerfDataBlock);
                dwObjectIdx = 0;
                while ((pParentObject != NULL) && 
                    (pParentObject->ObjectNameTitleIndex != pThisInstance->ParentObjectTitleIndex) &&
                    (dwObjectIdx < pPerfDataBlock->NumObjectTypes)) {
                    pParentObject = NextObject (pParentObject);
                    dwObjectIdx++;
                }
                if (pParentObject->ObjectNameTitleIndex == pThisInstance->ParentObjectTitleIndex) {
                    pParentInstance = FirstInstance (pParentObject);
                    for (dwParentInstIdx = 0; 
                        dwParentInstIdx < pThisInstance->ParentObjectInstance; 
                        dwParentInstIdx++) {
                        pParentInstance = NextInstance(pParentInstance);
                    }
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    Name = \"%ws/",
                        GetInstanceName (pParentInstance));
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"%ws\";", GetInstanceName (pThisInstance));
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                } else {
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    Name = \"%ws\";",
                        GetInstanceName (pThisInstance));
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                }
            } else {
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    Name = \"%ws\";",
                    GetInstanceName (pThisInstance));
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            }
            pThisCounter = FirstCounter(pPerfObject);
            assert (pThisCounter != NULL);
            for (dwCounterCount = 0; dwCounterCount < pPerfObject->NumCounters; dwCounterCount++) {
                assert (pThisCounter != NULL);
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    %ws = ", 
                     FormatPerfName (lpCounterText[pThisCounter->CounterNameTitleIndex],
                        (IsDisplayableType(pThisCounter->CounterType) ? FALSE : TRUE)));
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                pValue = (LPDWORD)pThisInstance;
                pValue = (LPDWORD)((LPBYTE)pValue + pThisInstance->ByteLength);
                pValue = (LPDWORD)((LPBYTE)pValue + pThisCounter->CounterOffset);
                if (pThisCounter->CounterSize == 8) {
                    pValue++;
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x", *pValue);
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                    pValue--;
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"%8.8x;", *pValue);
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                } else {
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x;", *pValue);
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                }
                pThisCounter = NextCounter (pThisCounter);
            }
            dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A};\x0D\x0A");
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            pThisInstance = NextInstance(pThisInstance);
        }
    }
	*pcchBufferSize = dwTotalLength;

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\mofcomp.cpp ===
#include    <windows.h>
#include    <wbemidl.h>
#include    <wbemint.h>
#include    <assert.h>
#include    <stdio.h>
#include    "mofcomp.h"

static CONST WCHAR cszWmiLoadEventName[] = {L"WMI_SysEvent_LodCtr"};
static CONST WCHAR cszWmiUnloadEventName[] = {L"WMI_SysEvent_UnLodCtr"};

DWORD SignalWmiWithNewData (DWORD  dwEventId)
{
    HANDLE  hEvent;
    DWORD   dwStatus = ERROR_SUCCESS;

    LPWSTR szEventName = NULL;

    switch (dwEventId) {
    case WMI_LODCTR_EVENT:
        szEventName = (LPWSTR)cszWmiLoadEventName;
        break;

    case WMI_UNLODCTR_EVENT:
        szEventName = (LPWSTR)cszWmiUnloadEventName;
        break;

    default:
        dwStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    if (dwStatus == ERROR_SUCCESS) {
        hEvent = OpenEventW (
            EVENT_MODIFY_STATE | SYNCHRONIZE,
            FALSE,
            szEventName);
        if (hEvent != NULL) {
            // set event
            SetEvent (hEvent);
            CloseHandle (hEvent);
        } else {
            dwStatus = GetLastError();
        }
        
    }
    return dwStatus;
}


DWORD LodctrCompileMofFile ( LPCWSTR szComputerName, LPCWSTR szMofFileName )
{
    HRESULT hRes;
    IMofCompiler    *pMofComp = NULL;
    DWORD   dwReturn = ERROR_SUCCESS;
    WBEM_COMPILE_STATUS_INFO    Info;
 
    WCHAR   szLocalServerName[1024];
    LPWSTR  szServerPath;

    hRes = CoInitializeEx (0, COINIT_MULTITHREADED);

    if (hRes == S_OK) {
        // open the COM interface to the mof compiler object
        hRes = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            (LPVOID *)&pMofComp);
                       
        if (hRes == S_OK) {
            // load mof
            assert (pMofComp != NULL);

            if (szComputerName == NULL) {
                szServerPath = NULL;
            } else {
                assert (lstrlenW(szComputerName) < MAX_PATH);
                lstrcpyW (szLocalServerName, szComputerName);
                lstrcatW (szLocalServerName, L"\\root\\default");
                szServerPath = &szLocalServerName[0];
            }

            hRes = pMofComp->CompileFile (
                (LPWSTR)szMofFileName,
                NULL,			// load into namespace specified in MOF file
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                0,				// no class flags
                0,              // no instance flags
                &Info);

            if (hRes != S_OK) {
                dwReturn = (DWORD)Info.hRes;
            }

            // close COM interface
            pMofComp->Release();
        } else {
            dwReturn = (DWORD)hRes;
        }
        CoUninitialize();
    } else {
        dwReturn = (DWORD)hRes;
    }

    return dwReturn;
}

DWORD LodctrCompileMofBuffer ( LPCWSTR szComputerName, LPVOID pMofBuffer, DWORD dwBufSize )
{
    HRESULT hRes;
    IMofCompiler    *pMofComp = NULL;
    DWORD   dwReturn = ERROR_SUCCESS;
    WBEM_COMPILE_STATUS_INFO    Info;
    
    DBG_UNREFERENCED_PARAMETER (szComputerName);

    hRes = CoInitializeEx (0, COINIT_MULTITHREADED);

    if (hRes == S_OK) {
        // open the COM interface to the mof compiler object
        hRes = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            (LPVOID *)&pMofComp);
                       
        if (hRes == S_OK) {
            // load mof
            assert (pMofComp != NULL);

            hRes = pMofComp->CompileBuffer (
                dwBufSize,
                (LPBYTE) pMofBuffer,
                NULL,           // load into Root\Default on local mashine
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                WBEM_FLAG_UPDATE_FORCE_MODE,    // no class flags
                0,              // no instance flags
                &Info);

            if (hRes != S_OK) {
                // return the detailed error code
                dwReturn = (DWORD)Info.hRes;
            }

            // close COM interface
            pMofComp->Release();
        } else {
            dwReturn = (DWORD)hRes;
        }
        CoUninitialize();
    } else {
        dwReturn = (DWORD)hRes;
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\unlodctr.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    unlodctr.c

Abstract:

    Program to remove the counter names belonging to the driver specified
        in the command line and update the registry accordingly

Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

    Bob Watson (bobw)   10 Mar 99 added event log messages

--*/
#ifndef     UNICODE
#define     UNICODE     1
#endif

#ifndef     _UNICODE
#define     _UNICODE    1
#endif
//
//  "C" Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//
//  Windows Include files
//
#include <windows.h>
#define __LOADPERF__
#include <loadperf.h>
#include <tchar.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  local include files
//
#include "winperfp.h"
#include "common.h"
#include "unlodctr.h"
#include "mofcomp.h"
#include "ldprfmsg.h"

// version number for NT 1.0
#define OLD_VERSION  0x010000
static DWORD   dwSystemVersion;    // PerfLib version number
static DWORD   dwHelpItems;        // number of explain text items
static DWORD   dwCounterItems;     // number of counter text items
static DWORD   dwLastCounter;
static DWORD   dwLastHelp;
static TCHAR   ComputerName[MAX_PATH];
static TCHAR   szServiceDisplayName[MAX_PATH];
static HKEY    hPerfData;    // handle to remote machine HKEY_PERFORMANCE_DATA
static BOOL     bQuietMode = TRUE;     // quiet means no _tprintf's

#define  OUTPUT_MESSAGE     if (!bQuietMode) _tprintf

static
LPTSTR
*BuildNameTable(
    IN HKEY    hKeyPerflib,     // handle to perflib key with counter names
    IN LPTSTR  lpszLangId,      // unicode value of Language subkey
    OUT PDWORD  pdwLastItem,     // size of array in elements
    OUT HKEY    *hKeyNames,
    OUT LPTSTR  CounterNameBuffer,  // New version counter name key
    OUT LPTSTR  HelpNameBuffer     // New version help name key
)
/*++

BuildNameTable

    Caches the counter names and explain text to accelerate name lookups
    for display.

Arguments:

    hKeyPerflib
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 009)

    pdwLastItem
            The last array element

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated TEXT strings.

    A NULL pointer is returned if an error occured. (error value is
    available using the GetLastError function).

    The structure of the buffer returned is:

        Array of pointers to zero terminated strings consisting of
            pdwLastItem elements

        MULTI_SZ string containing counter id's and names returned from
            registry for the specified language

        MULTI_SZ string containing explain text id's and explain text strings
            as returned by the registry for the specified language

    The structures listed above are contiguous so that they may be freed
    by a single "free" call when finished with them, however only the
    array elements are intended to be used.

--*/
{

    LPTSTR  *lpReturnValue;     // returned pointer to buffer

    LPTSTR  *lpCounterId;       //
    LPTSTR  lpCounterNames;     // pointer to Names buffer returned by reg.
    LPTSTR  lpHelpText ;        // pointet to exlpain buffer returned by reg.

    LPTSTR  lpThisName;         // working pointer


    BOOL    bStatus;            // return status from TRUE/FALSE fn. calls
    LONG    lWin32Status;       // return status from fn. calls

    DWORD   dwValueType;        // value type of buffer returned by reg.
    DWORD   dwArraySize;        // size of pointer array in bytes
    DWORD   dwBufferSize;       // size of total buffer in bytes
    DWORD   dwCounterSize;      // size of counter text buffer in bytes
    DWORD   dwHelpSize;         // size of help text buffer in bytes
    DWORD   dwThisCounter;      // working counter

    DWORD   dwLastId;           // largest ID value used by explain/counter text

    DWORD   dwLastCounterIdUsed;
    DWORD   dwLastHelpIdUsed;

    LPTSTR  lpValueNameString;  // pointer to buffer conatining subkey name

    //initialize pointers to NULL

    lpValueNameString = NULL;
    lpReturnValue = NULL;

    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = (LPTSTR)DefaultLangId;
    }

    if (hKeyNames) {
        *hKeyNames = NULL;
    } else {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return NULL;
    }

    // use the greater of Help items or Counter Items to size array

    if (dwHelpItems >= dwCounterItems) {
        dwLastId = dwHelpItems;
    } else {
        dwLastId = dwCounterItems;
    }

    // array size is # of elements (+ 1, since names are "1" based)
    // times the size of a pointer

    dwArraySize = (dwLastId + 1) * sizeof(LPTSTR);

    // allocate string buffer for language ID key string

    dwBufferSize = sizeof(TCHAR) * lstrlen(NamesKey)
                 + sizeof(TCHAR) * lstrlen(Slash)
                 + sizeof(TCHAR) * lstrlen(lpszLangId)
                 + sizeof(TCHAR);
    lpValueNameString = MemoryAllocate(dwBufferSize);
    if (!lpValueNameString) {
        lWin32Status = ERROR_OUTOFMEMORY;
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                1, __LINE__, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               0,
               lWin32Status,
               NULL));
        goto BNT_BAILOUT;
    }

    if (dwSystemVersion == OLD_VERSION) {
        lWin32Status = RegOpenKeyEx (   // get handle to this key in the
                    hKeyPerflib,        // registry
                    lpszLangId,
                    RESERVED,
                    KEY_READ | KEY_WRITE,
                    hKeyNames);
    } else {
//        *hKeyNames = HKEY_PERFORMANCE_DATA;
        *hKeyNames = hPerfData;

        lstrcpy (CounterNameBuffer, CounterNameStr);
        lstrcat (CounterNameBuffer, lpszLangId);
        lstrcpy (HelpNameBuffer, HelpNameStr);
        lstrcat (HelpNameBuffer, lpszLangId);

        lWin32Status = ERROR_SUCCESS;
    }

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_ACCESS_STRINGS, // event,
                2, lWin32Status, __LINE__, 0, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               NULL));
        goto BNT_BAILOUT;
    }

    // get size of counter names

    dwBufferSize = 0;
    __try {
        lWin32Status = RegQueryValueEx (
                    * hKeyNames,
                    dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
                    RESERVED,
                    & dwValueType,
                    NULL,
                    & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                4, lWin32Status, dwSystemVersion, dwBufferSize, __LINE__,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Counters),
               TRACE_DWORD(dwSystemVersion),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // get size of help text

    dwBufferSize = 0;
    __try {
        lWin32Status = RegQueryValueEx (
                    * hKeyNames,
                    dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
                    RESERVED,
                    & dwValueType,
                    NULL,
                    & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                4, lWin32Status, dwSystemVersion, dwBufferSize, __LINE__,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Help),
               TRACE_DWORD(dwSystemVersion),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }

    dwHelpSize = dwBufferSize;

    // allocate buffer with room for pointer array, counter name
    // strings and help name strings

    lpReturnValue = MemoryAllocate(dwArraySize + dwCounterSize + dwHelpSize);
    if (!lpReturnValue) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                4, dwArraySize, dwCounterSize, dwHelpSize, __LINE__,
                0, NULL, NULL, NULL);
        lWin32Status = ERROR_OUTOFMEMORY;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               0,
               lWin32Status,
               TRACE_DWORD(dwArraySize),
               TRACE_DWORD(dwCounterSize),
               TRACE_DWORD(dwHelpSize),
               NULL));
        goto BNT_BAILOUT;
    }

    // initialize pointers into buffer
    lpCounterId = lpReturnValue;
    lpCounterNames = (LPTSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPTSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counter names into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Name"

    dwBufferSize = dwCounterSize;
    __try {
        lWin32Status = RegQueryValueEx (
                    * hKeyNames,
                    dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
                    RESERVED,
                    & dwValueType,
                    (LPVOID)lpCounterNames,
                    & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                4, lWin32Status, dwSystemVersion, dwBufferSize, __LINE__,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Counters),
               TRACE_DWORD(dwSystemVersion),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }
    // read explain text into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Text..."

    dwBufferSize = dwHelpSize;
    __try {
        lWin32Status = RegQueryValueEx (
                    * hKeyNames,
                    dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
                    RESERVED,
                    & dwValueType,
                    (LPVOID)lpHelpText,
                    & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lWin32Status = GetExceptionCode();
    }
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                4, lWin32Status, dwSystemVersion, dwBufferSize, __LINE__,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Help),
               TRACE_DWORD(dwSystemVersion),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed = 0;

    // load counter array items, by locating each text string
    // in the returned buffer and loading the
    // address of it in the corresponding pointer array element.

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal digit characters)
        // so translate to an integer for use in array element identification

        do {
            bStatus = StringToInt (lpThisName, &dwThisCounter);

            if (!bStatus) {
                ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_CORRUPT_MULTI_SZ, // event,
                    1, __LINE__, 0, 0, 0,
                    2, CounterNameBuffer, lpThisName, NULL);
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_UNLODCTR_BUILDNAMETABLE,
                       ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                       ERROR_BADKEY,
                       TRACE_WSTR(Counters),
                       TRACE_WSTR(lpThisName),
                       NULL));
                lpThisName += (lstrlen(lpThisName) + 1);
            }
        }
        while ((! bStatus) && (* lpThisName));

        if (! bStatus) {
            lWin32Status = ERROR_BADKEY;
            goto BNT_BAILOUT;  // bad entry
        }
        if (dwThisCounter > dwCounterItems || dwThisCounter > dwLastId) {
            lWin32Status = ERROR_BADKEY;
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT, // event,
                    4, dwThisCounter, dwCounterItems, dwLastId, __LINE__,
                    1, lpThisName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwCounterItems),
                    TRACE_DWORD(dwHelpItems),
                    NULL));
            goto BNT_BAILOUT;
        }

        // point to corresponding counter name which follows the id number
        // string.

        lpThisName += (lstrlen(lpThisName) + 1);

        // and load array element with pointer to string

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;
    }

    // repeat the above for the explain text strings

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        do {
            bStatus = StringToInt (lpThisName, &dwThisCounter);
            if (! bStatus) {
                ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_CORRUPT_MULTI_SZ, // event,
                    1, __LINE__, 0, 0, 0,
                    2, HelpNameBuffer, lpThisName, NULL);
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_UNLODCTR_BUILDNAMETABLE,
                       ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                       ERROR_BADKEY,
                       TRACE_WSTR(Help),
                       TRACE_WSTR(lpThisName),
                       NULL));
                lpThisName += (lstrlen(lpThisName) + 1);
            }
        }
        while ((! bStatus) && (* lpThisName));
        if (!bStatus) {
            lWin32Status = ERROR_BADKEY;
            goto BNT_BAILOUT;  // bad entry
        }
        if (dwThisCounter > dwHelpItems || dwThisCounter > dwLastId) {
            lWin32Status = ERROR_BADKEY;
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT, // event,
                    4, dwThisCounter, dwHelpItems, dwLastId, __LINE__,
                    1, lpThisName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwCounterItems),
                    TRACE_DWORD(dwHelpItems),
                    NULL));
            goto BNT_BAILOUT;
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
           __LINE__,
           LOADPERF_UNLODCTR_BUILDNAMETABLE,
           0,
           ERROR_SUCCESS,
           TRACE_DWORD(dwLastId),
           TRACE_DWORD(dwLastCounterIdUsed),
           TRACE_DWORD(dwLastHelpIdUsed),
           TRACE_DWORD(dwCounterItems),
           TRACE_DWORD(dwHelpItems),
           NULL));

    if (dwLastHelpIdUsed > dwLastId) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                3, dwLastId, dwLastHelpIdUsed, __LINE__, 0,
                0, NULL, NULL, NULL);
        lWin32Status = ERROR_BADKEY;
        goto BNT_BAILOUT;  // bad registry
    }

    // if the last item arugment was used, then load the last ID value in it

    if (pdwLastItem) *pdwLastItem = dwLastId;

    // free the temporary buffer used

    if (lpValueNameString) {
        MemoryFree((LPVOID)lpValueNameString);
    }

    // exit returning the pointer to the buffer

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        // if lWin32Status has error, then set last error value to it,
        // otherwise assume that last error already has value in it
        SetLastError (lWin32Status);
    }

    // free buffers used by this routine

    if (lpValueNameString) {
        MemoryFree((LPVOID)lpValueNameString);
    }

    if (lpReturnValue) {
        MemoryFree((LPVOID)lpReturnValue);
    }

    return NULL;
} // BuildNameTable

static
BOOL
GetDriverFromCommandLine (
    LPTSTR   lpCommandLine,
    HKEY   * hKeyMachine,
    LPTSTR   lpDriverName,
    HKEY   * hDriverPerf,
    HKEY   * hKeyDriver
)
/*++

GetDriverFromCommandLine

    locates the first argument in the command line string (after the
    image name) and checks to see if

        a) it's there

        b) it's the name of a device driver listed in the
            Registry\Machine\System\CurrentControlSet\Services key
            in the registry and it has a "Performance" subkey

        c) that the "First Counter" value under the Performance subkey
            is defined.

    if all these criteria are true, then the routine returns TRUE and
    passes the pointer to the driver name back in the argument. If any
    one of them fail, then NULL is returned in the DriverName arg and
    the routine returns FALSE

Arguments

    lpDriverName

        the address of a LPTSTR to recive the pointer to the driver name

    hDriverPerf

        the key to the driver's performance subkey

Return Value

    TRUE if a valid driver was found in the command line

    FALSE if not (see above)

--*/
{
    LPTSTR  lpDriverKey = NULL;    // buffer to build driver key name in

    LONG    lStatus;
    DWORD   dwFirstCounter;
    DWORD   dwSize;
    DWORD   dwType;
    TCHAR   LocalComputerName[MAX_PATH];
    DWORD   NameBuffer;
    INT     iNumArgs;
    BOOL    bComputerName = FALSE;
    BOOL    bReturn = FALSE;

    if (!lpDriverName || !hDriverPerf) {
        SetLastError (ERROR_BAD_ARGUMENTS);
        goto Cleanup;
    }

    *hDriverPerf = NULL;

    // an argument was found so see if it's a driver
    lpDriverKey = MemoryAllocate(MAX_PATH * sizeof (TCHAR));
    if (!lpDriverKey) {
        SetLastError (ERROR_OUTOFMEMORY);
        goto Cleanup;
    }
    lstrcpy(lpDriverName, GetItemFromString (lpCommandLine, 3, TEXT(' ')));
    lstrcpy(ComputerName, GetItemFromString (lpCommandLine, 2, TEXT(' ')));
    // check for usage
    if (ComputerName[1] == TEXT('?')) {
        if (!bQuietMode) {
            DisplayCommandHelp (UC_FIRST_CMD_HELP, UC_LAST_CMD_HELP);
        }
        SetLastError (ERROR_SUCCESS);
        goto Cleanup;
    }

    // no /? so process args read

    if (lstrlen(lpDriverName) == 0) {
        // then no computer name is specifed so assume the local computer
        // and the driver name is listed in the computer name param
        if (lstrlen(ComputerName) == 0) {
            iNumArgs = 1;   // command line only
        } else {
            lstrcpy (lpDriverName, ComputerName);
            ComputerName[0] = 0;
            ComputerName[1] = 0;
            iNumArgs = 2;
        }
    } else {
        if (lstrlen(ComputerName) == 0) {
              // this case is impossible since the driver name is after the computer name
            iNumArgs = 1;
        } else {
            iNumArgs = 3;
        }
    }

    // check if there is any computer name
    if (ComputerName[0] == TEXT('\\') &&
        ComputerName[1] == TEXT('\\')) {
        // see if the specified computer is THIS computer and remove
        // name if it is
        NameBuffer = sizeof (LocalComputerName) / sizeof (TCHAR);
        GetComputerName(LocalComputerName, &NameBuffer);
        if (!lstrcmpi(LocalComputerName, &ComputerName[2])) {
            // same name as local computer name
            ComputerName[0] = TEXT('\0');
        }
        bComputerName = TRUE;
    } else {
        // this is a driver name
        ComputerName[0] = TEXT('\0');
    }

    if (iNumArgs >= 2) {
        if (ComputerName[0]) {
            lStatus = !ERROR_SUCCESS;
            try {
                lStatus = RegConnectRegistry (
                            (LPTSTR) ComputerName,
                            HKEY_LOCAL_MACHINE,
                            hKeyMachine);
            } finally {
                if (lStatus != ERROR_SUCCESS) {
                    SetLastError (lStatus);
                    *hKeyMachine = NULL;
                    OUTPUT_MESSAGE (GetFormatResource(UC_CONNECT_PROBLEM),
                        ComputerName, lStatus);
                }
            }
            if (lStatus != ERROR_SUCCESS)
                goto Cleanup;
        } else {
            *hKeyMachine = HKEY_LOCAL_MACHINE;
        }

        if (lstrlen(lpDriverName) > (MAX_PATH / 2)) {
            // then it's too long to make a path out of
            dwSize = 0;
        } else {
            lstrcpy (lpDriverKey, DriverPathRoot);
            lstrcat (lpDriverKey, Slash);
            lstrcat (lpDriverKey, lpDriverName);
            dwSize = lstrlen(lpDriverKey);
        }

        if ((dwSize > 0) && (dwSize < MAX_PATH)) {
            lStatus = RegOpenKeyEx (
                    * hKeyMachine,
                    lpDriverKey,
                    RESERVED,
                    KEY_READ | KEY_WRITE,
                    hKeyDriver);
        }

        lStatus = ERROR_SUCCESS;
        RtlZeroMemory(lpDriverKey, MAX_PATH * sizeof(TCHAR));
        if (lstrlen(lpDriverName) > (MAX_PATH / 2)) {
            // then it's too long to make a path out of
            dwSize = 0;
        } else {
            lstrcpy (lpDriverKey, DriverPathRoot);
            lstrcat (lpDriverKey, Slash);
            lstrcat (lpDriverKey, lpDriverName);
            lstrcat (lpDriverKey, Slash);
            lstrcat (lpDriverKey, Performance);
            dwSize = lstrlen(lpDriverKey);
        }

        if ((dwSize > 0) && (dwSize < MAX_PATH)) {
            lStatus = RegOpenKeyEx (
                *hKeyMachine,
                lpDriverKey,
                RESERVED,
                KEY_READ | KEY_WRITE,
                hDriverPerf);
        } else {
            // driver name is too long
            lStatus = ERROR_INVALID_PARAMETER;
        }

        if (lStatus == ERROR_SUCCESS) {
            //
            //  this driver has a performance section so see if its
            //  counters are installed by checking the First Counter
            //  value key for a valid return. If it returns a value
            //  then chances are, it has some counters installed, if
            //  not, then display a message and quit.
            //
            dwType = 0;
            dwSize = sizeof (dwFirstCounter);

            __try {
                lStatus = RegQueryValueEx (
                            * hDriverPerf,
                            cszFirstCounter,
                            RESERVED,
                            & dwType,
                            (LPBYTE)&dwFirstCounter,
                            & dwSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus == ERROR_SUCCESS) {
                // counter names are installed so return success
                SetLastError (ERROR_SUCCESS);
                bReturn = TRUE;
            } else {
                // counter names are probably not installed so return FALSE
                OUTPUT_MESSAGE (GetFormatResource (UC_NOTINSTALLED), lpDriverName);
                *lpDriverName = TEXT('\0'); // remove driver name
                SetLastError (ERROR_BADKEY);
            }
        } else { // key not found
            if (lStatus != ERROR_INVALID_PARAMETER) {
                OUTPUT_MESSAGE (GetFormatResource (UC_DRIVERNOTFOUND),
                    lpDriverKey, lStatus);
            } else {
                OUTPUT_MESSAGE (GetFormatResource (UC_BAD_DRIVER_NAME), 0);
            }
            SetLastError (lStatus);
        }
    } else {
        if (!bQuietMode) {
            DisplayCommandHelp (UC_FIRST_CMD_HELP, UC_LAST_CMD_HELP);
        }
        SetLastError (ERROR_INVALID_PARAMETER);
    }

Cleanup:
    if (lpDriverKey != NULL) MemoryFree(lpDriverKey);
    if (bReturn) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_GETDRIVERFROMCOMMANDLINE,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               ERROR_SUCCESS,
               TRACE_WSTR(lpDriverName),
               NULL));
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_GETDRIVERFROMCOMMANDLINE,
               0,
               GetLastError(),
               NULL));
    }
    return bReturn;
}

static
LONG
FixNames (
    HANDLE  hKeyLang,
    LPTSTR  *lpOldNameTable,
    IN LPTSTR  lpszLangId,      // unicode value of Language subkey
    DWORD   dwLastItem,
    DWORD   dwFirstNameToRemove,
    DWORD   dwLastNameToRemove
   )
{
    LONG    lStatus;
    LPTSTR  lpNameBuffer = NULL;
    LPTSTR  lpHelpBuffer = NULL;
    DWORD   dwTextIndex, dwSize, dwValueType;
    LPTSTR  lpNextHelpText;
    LPTSTR  lpNextNameText;
    TCHAR   AddHelpNameBuffer[40];
    TCHAR   AddCounterNameBuffer[40];

    // allocate space for the array of new text it will point
    // into the text buffer returned in the lpOldNameTable buffer)

    lpNameBuffer = MemoryAllocate(MemorySize(lpOldNameTable));
    lpHelpBuffer = MemoryAllocate(MemorySize(lpOldNameTable));

    if (!lpNameBuffer || !lpHelpBuffer) {
        lStatus = ERROR_OUTOFMEMORY;
        goto UCN_FinishLang;
    }

    // remove this driver's counters from array

    for (dwTextIndex = dwFirstNameToRemove;
         dwTextIndex <= dwLastNameToRemove;
         dwTextIndex++) {

        if (dwTextIndex > dwLastItem)
           break;

        lpOldNameTable[dwTextIndex] = NULL;
    }

    lpNextHelpText = lpHelpBuffer;
    lpNextNameText = lpNameBuffer;

    // build new Multi_SZ strings from New Table

    for (dwTextIndex = 0; dwTextIndex <= dwLastItem; dwTextIndex++){
        if (lpOldNameTable[dwTextIndex]) {
            // if there's a text string at that index, then ...
            if ((dwTextIndex & 0x1) && dwTextIndex != 1) {    // ODD number == Help Text
                lpNextHelpText +=
                    _stprintf (lpNextHelpText, (LPCTSTR)TEXT("%d"), dwTextIndex) + 1;
                lpNextHelpText +=
                    _stprintf (lpNextHelpText, (LPCTSTR)TEXT("%s"),
                    lpOldNameTable[dwTextIndex]) + 1;
                if (dwTextIndex > dwLastHelp){
                    dwLastHelp = dwTextIndex;
                }
            } else { // EVEN number == counter name text
                lpNextNameText +=
                    _stprintf (lpNextNameText, (LPCTSTR)TEXT("%d"), dwTextIndex) + 1;
                lpNextNameText +=
                    _stprintf (lpNextNameText, (LPCTSTR)TEXT("%s"),
                lpOldNameTable[dwTextIndex]) + 1;
                if (dwTextIndex > dwLastCounter){
                    dwLastCounter = dwTextIndex;
                }
            }
        }
    } // for dwTextIndex

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_FIXNAMES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ERROR_SUCCESS,
            TRACE_WSTR(lpszLangId),
            TRACE_DWORD(dwLastItem),
            TRACE_DWORD(dwLastCounter),
            TRACE_DWORD(dwLastHelp),
            TRACE_DWORD(dwCounterItems),
            TRACE_DWORD(dwHelpItems),
            TRACE_DWORD(dwFirstNameToRemove),
            TRACE_DWORD(dwLastNameToRemove),
            NULL));

    if (   (dwLastCounter < PERFLIB_BASE_INDEX - 1)
        || (dwLastHelp < PERFLIB_BASE_INDEX)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                4, PERFLIB_BASE_INDEX, dwLastCounter, dwLastHelp, __LINE__,
                1, (LPWSTR) Performance, NULL, NULL);
        lStatus = ERROR_BADKEY;
        goto UCN_FinishLang;
    }

    // add MULTI_SZ terminating NULL
    *lpNextNameText++ = TEXT ('\0');
    *lpNextHelpText++ = TEXT ('\0');

    // update counter name text buffer

    dwSize = (DWORD)((LPBYTE)lpNextNameText - (LPBYTE)lpNameBuffer);
    if (dwSystemVersion == OLD_VERSION) {
        lStatus = RegSetValueEx (
            hKeyLang,
            Counters,
            RESERVED,
            REG_MULTI_SZ,
            (LPBYTE)lpNameBuffer,
            dwSize);
    } else {
        lstrcpy (AddCounterNameBuffer, AddCounterNameStr);
        lstrcat (AddCounterNameBuffer, lpszLangId);
        __try {
            lStatus = RegQueryValueEx (
                        hKeyLang,
                        AddCounterNameBuffer,
                        RESERVED,
                        & dwValueType,
                        (LPBYTE)lpNameBuffer,
                        & dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
    }
    if (lStatus != ERROR_SUCCESS) {
       ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_COUNTER_STRINGS, // event,
                3, lStatus, dwSize, __LINE__, 0,
                1, lpszLangId, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLELOADLANG),
                Counters, lpszLangId, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_FIXNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Counters),
                TRACE_DWORD(dwSize),
                NULL));
        goto UCN_FinishLang;
    }

    dwSize = (DWORD)((LPBYTE)lpNextHelpText - (LPBYTE)lpHelpBuffer);
    if (dwSystemVersion == OLD_VERSION) {
        lStatus = RegSetValueEx (
            hKeyLang,
            Help,
            RESERVED,
            REG_MULTI_SZ,
            (LPBYTE)lpHelpBuffer,
            dwSize);
    } else {
        lstrcpy (AddHelpNameBuffer, AddHelpNameStr);
        lstrcat (AddHelpNameBuffer, lpszLangId);
        __try {
            lStatus = RegQueryValueEx (
                        hKeyLang,
                        AddHelpNameBuffer,
                        RESERVED,
                        & dwValueType,
                        (LPBYTE)lpHelpBuffer,
                        & dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_HELP_STRINGS, // event,
                3, lStatus, dwSize, __LINE__, 0,
                1, lpszLangId, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLELOADLANG),
                Help, lpszLangId, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_FIXNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Help),
                TRACE_DWORD(dwSize),
                NULL));
        goto UCN_FinishLang;
    }

UCN_FinishLang:
    if (lpNameBuffer)
        MemoryFree(lpNameBuffer);
    if (lpHelpBuffer)
        MemoryFree(lpHelpBuffer);
    MemoryFree(lpOldNameTable);

    if (dwSystemVersion == OLD_VERSION) {
        RegCloseKey (hKeyLang);
    }

    return lStatus;
}

static
LONG
UnloadCounterNames (
    HKEY    hKeyMachine,
    HKEY    hDriverPerf,
    HKEY    hKeyDriver,
    LPTSTR  lpDriverName
)
/*++

UnloadCounterNames

    removes the names and explain text for the driver referenced by
    hDriverPerf and updates the first and last counter values accordingly

    update process:

        - set "updating" flag under Perflib to name of driver being modified
        - FOR each language under perflib key
            -- load current counter names and explain text into array of
                pointers
            -- look at all drivers and copy their names and text into a new
                buffer adjusting for the removed counter's entries keeping
                track of the lowest entry copied.  (the names for the driver
                to be removed will not be copied, of course)
            -- update each driver's "first" and "last" index values
            -- copy all other entries from 0 to the lowest copied (i.e. the
                system counters)
            -- build a new MULIT_SZ string of help text and counter names
            -- load new strings into registry
        - update perflibl "last" counters
        - delete updating flag

     ******************************************************
     *                                                    *
     *  NOTE: FUNDAMENTAL ASSUMPTION.....                 *
     *                                                    *
     *  this routine assumes that:                        *
     *                                                    *
     *      ALL COUNTER NAMES are even numbered and       *
     *      ALL HELP TEXT STRINGS are odd numbered        *
     *                                                    *
     ******************************************************

Arguments

    hKeyMachine

        handle to HKEY_LOCAL_MACHINE node of registry on system to
        remove counters from

    hDrivefPerf
        handle to registry key of driver to be de-installed

    lpDriverName
        name of driver being de-installed

Return Value

    DOS Error code.

        ERROR_SUCCESS if all went OK
        error value if not.

--*/
{
    HKEY    hPerflib;
    HKEY    hServices;
    HKEY    hKeyLang;

    LONG    lStatus;

    DWORD   dwLangIndex;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwLastItem;

    DWORD   dwRemLastDriverCounter;
    DWORD   dwRemFirstDriverCounter;
    DWORD   dwRemLastDriverHelp;
    DWORD   dwRemFirstDriverHelp;

    DWORD   dwFirstNameToRemove;
    DWORD   dwLastNameToRemove;
    DWORD   dwLastNameInTable;

    LPTSTR  *lpOldNameTable;

    LPTSTR  lpLangName = NULL;
    LPTSTR  lpThisDriver = NULL;

    BOOL    bPerflibUpdated = FALSE;

    DWORD   dwBufferSize;       // size of total buffer in bytes

    TCHAR   CounterNameBuffer [40];
    TCHAR   HelpNameBuffer [40];
    HANDLE  hFileMapping = NULL;
    DWORD             MapFileSize;
    SECURITY_ATTRIBUTES  SecAttr;
    TCHAR MapFileName[] = TEXT("Perflib Busy");
    DWORD             *lpData;

    LONG_PTR    TempFileHandle = -1;

    if (LoadPerfGrabMutex() == FALSE) {
        return (GetLastError());
    }

    RtlZeroMemory(szServiceDisplayName, MAX_PATH * sizeof(TCHAR));
    if (hKeyDriver != NULL) {
        dwBufferSize = MAX_PATH * sizeof(TCHAR);
        lStatus = RegQueryValueEx(hKeyDriver,
                                  szDisplayName,
                                  RESERVED,
                                  & dwType,
                                  (LPBYTE) szServiceDisplayName,
                                  & dwBufferSize);
        if (lStatus != ERROR_SUCCESS) {
            lstrcpy(szServiceDisplayName, lpDriverName);
        }
    }
    else {
        lstrcpy(szServiceDisplayName, lpDriverName);
    }

    __try {
        lStatus = RegOpenKeyEx(
                    hKeyMachine,
                    DriverPathRoot,
                    RESERVED,
                    KEY_READ | KEY_WRITE,
                    & hServices);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) DriverPathRoot, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLEOPENKEY),
                DriverPathRoot, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(DriverPathRoot),
                NULL));
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    // open registry handle to perflib key

    __try {
        lStatus = RegOpenKeyEx (
                    hKeyMachine,
                    NamesKey,
                    RESERVED,
                    KEY_READ | KEY_WRITE,
                    & hPerflib);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLEOPENKEY),
                NamesKey, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(NamesKey),
                NULL));
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    __try {
        lStatus = RegSetValueEx (
                    hPerflib,
                    Busy,
                    RESERVED,
                    REG_SZ,
                    (LPBYTE) lpDriverName,
                    lstrlen(lpDriverName) * sizeof(TCHAR));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }

    if (lStatus != ERROR_SUCCESS) {
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLESETVALUE),
                Busy, NamesKey, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Busy),
                NULL));
        RegCloseKey (hPerflib);
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    // query registry to get number of Explain text items

    dwBufferSize = sizeof (dwHelpItems);
    __try {
        lStatus = RegQueryValueEx (
                    hPerflib,
                    LastHelp,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwHelpItems,
                    & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(LastHelp),
                NULL));
        RegCloseKey (hPerflib);
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    // query registry to get number of counter and object name items

    dwBufferSize = sizeof (dwCounterItems);
    __try {
        lStatus = RegQueryValueEx (
                    hPerflib,
                    LastCounter,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwCounterItems,
                    & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(LastCounter),
                NULL));
        RegCloseKey (hPerflib);
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    dwLastNameInTable = dwHelpItems;
    if (dwLastNameInTable < dwCounterItems) dwLastNameInTable = dwCounterItems;

    // query registry to get PerfLib system version

    dwBufferSize = sizeof (dwSystemVersion);
    __try {
        lStatus = RegQueryValueEx (
                    hPerflib,
                    VersionStr,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwSystemVersion,
                    & dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        // Key not there, must be NT 1.0 version
        dwSystemVersion = OLD_VERSION;
    }

    // set the hPerfData to HKEY_PERFORMANCE_DATA for new version
    // if remote machine, then need to connect to it.
    if (dwSystemVersion != OLD_VERSION) {
        lStatus = !ERROR_SUCCESS;
        hPerfData = HKEY_PERFORMANCE_DATA;
        if (ComputerName[0]) {
            // have to do it the old faction way
            dwSystemVersion = OLD_VERSION;
            lStatus = ERROR_SUCCESS;
        }
    } // NEW_VERSION

    // allocate temporary String buffer

    lpLangName   = MemoryAllocate(MAX_PATH * sizeof(TCHAR));
    lpThisDriver = MemoryAllocate(MAX_PATH * sizeof(TCHAR));

    if (!lpLangName || !lpThisDriver) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                1, __LINE__, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                0,
                ERROR_OUTOFMEMORY,
                NULL));
        lStatus = ERROR_OUTOFMEMORY;
        goto UCN_ExitPoint;
    }

    // Get the values that are in use by the driver to be removed

    dwSize = sizeof (dwRemLastDriverCounter);
    __try {
        lStatus = RegQueryValueEx (
                    hDriverPerf,
                    LastCounter,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwRemLastDriverCounter,
                    & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, LastCounter, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastCounter),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemFirstDriverCounter);
    __try {
        lStatus = RegQueryValueEx (
                    hDriverPerf,
                    cszFirstCounter,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwRemFirstDriverCounter,
                    & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) cszFirstCounter, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, cszFirstCounter, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(cszFirstCounter),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemLastDriverHelp);
    __try {
        lStatus = RegQueryValueEx(
                    hDriverPerf,
                    LastHelp,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwRemLastDriverHelp,
                    & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, LastHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastHelp),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemFirstDriverHelp);
    __try {
        lStatus = RegQueryValueEx (
                    hDriverPerf,
                    FirstHelp,
                    RESERVED,
                    & dwType,
                    (LPBYTE) & dwRemFirstDriverHelp,
                    & dwSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                2, lStatus, __LINE__, 0, 0,
                1, (LPWSTR) FirstHelp, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, FirstHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(FirstHelp),
                NULL));
        goto UCN_ExitPoint;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UNLOADCOUNTERNAMES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwLastNameInTable),
            TRACE_DWORD(dwCounterItems),
            TRACE_DWORD(dwHelpItems),
            TRACE_DWORD(dwRemFirstDriverCounter),
            TRACE_DWORD(dwRemLastDriverCounter),
            TRACE_DWORD(dwRemFirstDriverHelp),
            TRACE_DWORD(dwRemLastDriverHelp),
            NULL));

    //  get the first and last counters to define block of names used
    //  by this device

    dwFirstNameToRemove = (dwRemFirstDriverCounter <= dwRemFirstDriverHelp ?
        dwRemFirstDriverCounter : dwRemFirstDriverHelp);

    dwLastNameToRemove = (dwRemLastDriverCounter >= dwRemLastDriverHelp ?
        dwRemLastDriverCounter : dwRemLastDriverHelp);

    dwLastCounter = dwLastHelp = 0;

    // create the file mapping
    SecAttr.nLength = sizeof (SecAttr);
    SecAttr.bInheritHandle = TRUE;
    SecAttr.lpSecurityDescriptor = NULL;

    MapFileSize = sizeof(DWORD);
    hFileMapping = CreateFileMapping ((HANDLE)TempFileHandle, &SecAttr,
       PAGE_READWRITE, (DWORD_PTR)0, MapFileSize, (LPCTSTR)MapFileName);
    if (hFileMapping) {
        lpData = MapViewOfFile (hFileMapping,
            FILE_MAP_ALL_ACCESS, 0L, 0L, 0L);
        if (lpData) {
            *lpData = 1L;
            UnmapViewOfFile (lpData);
        } else {
            lStatus = GetLastError();
        }
    } else {
        lStatus = GetLastError();
    }

    if (lStatus != ERROR_SUCCESS) {
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, FirstHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                NULL));
        goto UCN_ExitPoint;
    }

    // do each language under perflib
    if (dwSystemVersion == OLD_VERSION) {
        for (dwLangIndex = 0, dwSize = MemorySize(lpLangName);
             (RegEnumKey(hPerflib, dwLangIndex, lpLangName, dwSize)) == ERROR_SUCCESS;
            dwLangIndex++, dwSize = MemorySize(lpLangName)) {

            OUTPUT_MESSAGE (GetFormatResource (UC_DOINGLANG), lpLangName);

            lpOldNameTable = BuildNameTable (hPerflib, lpLangName,
                &dwLastItem, &hKeyLang, CounterNameBuffer, HelpNameBuffer);

            if (lpOldNameTable) {
                if (dwLastItem <= dwLastNameInTable) {
                    // registry is OK so continue
                    if ((lStatus = FixNames (
                        hKeyLang,
                        lpOldNameTable,
                        lpLangName,
                        dwLastItem,
                        dwFirstNameToRemove,
                        dwLastNameToRemove)) == ERROR_SUCCESS) {
                        bPerflibUpdated = TRUE;
                    }
                } else {
                    // registry has been corrupted so abort
                    lStatus = ERROR_BADDB;
                    break;
                }
            } else { // unable to unload names for this language
                // display error message
                lStatus = GetLastError();
            }
        } // end for (more languages)
    } // end of OLD_VERSION
    else {
        CHAR  *pSystemRoot;
        WIN32_FIND_DATA FindFileInfo ;
        HANDLE         hFindFile ;
        CHAR  FileName[128];
        WCHAR wFileName[128];
        WCHAR LangId[10];
        WCHAR *pLangId;
        DWORD   dwIdx;

        pSystemRoot = getenv ("SystemRoot");

        if (pSystemRoot == NULL) {
            // unable to find systemroot so try windir
            pSystemRoot = getenv ("windir");
        }

        if (pSystemRoot != NULL) {
            strcpy(FileName, pSystemRoot);
            strcat(FileName, "\\system32\\perfc???.dat");
        } else {
            // unable to look up the windows directory so
            // try searching from the root of the boot drive
            strcpy(FileName, "C:\\perfc???.dat");
        }
        mbstowcs(wFileName, FileName, strlen(FileName) + 1);

        hFindFile = FindFirstFile ((LPCTSTR)wFileName, &FindFileInfo) ;

        if (!hFindFile || hFindFile == INVALID_HANDLE_VALUE) {
            lStatus = GetLastError();
        } else {
            do {
                // get langid
                // start at lang id # of file name based on the format
                //      perfxyyy.dat
                //  where x= h for help file, c for counter names
                //        y= hex digits of language ID
                //
                dwIdx = 0;
                pLangId = &FindFileInfo.cFileName[0];
                // go to lang ID code in filename (yyy above)
                for (dwIdx = 0; (dwIdx < 5) && (*pLangId++ > 0); dwIdx++);
                if (*pLangId > 0) {
                    // get lang ID from file name
                    LangId[0] = *pLangId++;
                    LangId[1] = *pLangId++;
                    LangId[2] = *pLangId++;
                    LangId[3] = L'\0';
                } else {
                    continue; // on to next file
                }

                OUTPUT_MESSAGE (GetFormatResource (UC_DOINGLANG), LangId);

                lpOldNameTable = BuildNameTable (hPerflib, LangId,
                    &dwLastItem, &hKeyLang, CounterNameBuffer, HelpNameBuffer);

                if (lpOldNameTable) {
                    if (dwLastItem <= dwLastNameInTable) {
                        // registry is OK so continue

                        if ((lStatus = FixNames (
                            hKeyLang,
                            lpOldNameTable,
                            LangId,
                            dwLastItem,
                            dwFirstNameToRemove,
                            dwLastNameToRemove)) == ERROR_SUCCESS) {
                            bPerflibUpdated = TRUE;
                        }
                    } else {
                        lStatus = ERROR_BADDB;
                        break;
                    }
                } else { // unable to unload names for this language
                    lStatus = GetLastError();
                }
            } while (FindNextFile(hFindFile, &FindFileInfo));
        }
        FindClose (hFindFile);
    } // end of NEW_VERSION


    if ((bPerflibUpdated) && (lStatus == ERROR_SUCCESS)) {
        // update perflib's "last" values

        dwSize = sizeof (dwLastCounter);
        __try {
            lStatus = RegSetValueEx (
                        hPerflib,
                        LastCounter,
                        RESERVED,
                        REG_DWORD,
                        (LPBYTE) & dwLastCounter,
                        dwSize);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = GetExceptionCode();
        }

        if (lStatus == ERROR_SUCCESS) {
            dwSize = sizeof (dwLastHelp);
            __try {
                lStatus = RegSetValueEx (
                            hPerflib,
                            LastHelp,
                            RESERVED,
                            REG_DWORD,
                            (LPBYTE) & dwLastHelp,
                            dwSize);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                lStatus = GetExceptionCode();
            }
            if (lStatus != ERROR_SUCCESS) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                        3, lStatus, dwLastHelp, __LINE__, 0,
                        2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UNLOADCOUNTERNAMES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        lStatus,
                        TRACE_WSTR(LastHelp),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
            }
        }
        else {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                    3, lStatus, dwLastCounter, __LINE__, 0,
                    2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLOADCOUNTERNAMES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(LastCounter),
                    TRACE_DWORD(dwLastCounter),
                    NULL));
        }

        if (lStatus == ERROR_SUCCESS) {
            ReportLoadPerfEvent(
                    EVENTLOG_INFORMATION_TYPE, // error type
                    (DWORD) LDPRFMSG_UNLOAD_SUCCESS, // event,
                    3, dwLastCounter, dwLastHelp, __LINE__, 0,
                    2, (LPWSTR) lpDriverName, (LPWSTR) szServiceDisplayName, NULL);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLOADCOUNTERNAMES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_DWORD(dwLastCounter),
                    TRACE_DWORD(dwLastHelp),
                    NULL));
            RegDeleteValue (hDriverPerf, cszFirstCounter);
            RegDeleteValue (hDriverPerf, LastCounter);
            RegDeleteValue (hDriverPerf, FirstHelp);
            RegDeleteValue (hDriverPerf, LastHelp);
            RegDeleteValue (hDriverPerf, szObjectList);
            RegDeleteValue (hDriverPerf, szLibraryValidationCode);
        }
    }

UCN_ExitPoint:
    RegDeleteValue (hPerflib, Busy);
    RegCloseKey (hPerflib);
    RegCloseKey (hServices);
    if (lpLangName) MemoryFree(lpLangName);
    if (lpThisDriver) MemoryFree(lpThisDriver);

    if (hFileMapping) {
        CloseHandle (hFileMapping);
    }

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNLOAD_FAILURE, // event,
                2, lStatus, __LINE__, 0, 0,
                2, (LPWSTR) lpDriverName, (LPWSTR) szServiceDisplayName, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                NULL));
    }
    ReleaseMutex(hLoadPerfMutex);
    return lStatus;

}

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
)
/*++

UnloadPerfCounterTextStringsW

    entry point to Counter Name Unloader


Arguments

    command line string in the format:

    "/?"                displays the usage help
    "driver"            driver containing the performance counters
    "\\machine driver"  removes the counters from the driver on \\machine

ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpDriverName = NULL; // name of driver to delete from perflib
    HKEY    hDriverPerf  = NULL; // handle to performance sub-key of driver
    HKEY    hMachineKey  = NULL; // handle to remote machine HKEY_LOCAL_MACHINE
    HKEY    hKeyDriver   = NULL;

    DWORD   dwStatus = ERROR_SUCCESS;       // return status of fn. calls

    WinPerfStartTrace(NULL);

    lpDriverName = (LPTSTR)MemoryAllocate(MAX_PATH * sizeof(TCHAR));
    bQuietMode   = bQuietModeArg;
    if (lpDriverName != NULL) {
        if (! GetDriverFromCommandLine(
                lpCommandLine, & hMachineKey,
                lpDriverName, & hDriverPerf, & hKeyDriver)) {
            // error message was printed in routine if there was an error
            dwStatus = GetLastError();
            goto Exit0;
        }
    } else {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Exit0;
    }

    OUTPUT_MESSAGE(GetFormatResource(UC_REMOVINGDRIVER), lpDriverName);

    // removes names and explain text for driver in lpDriverName
    // displays error messages for errors encountered

    dwStatus = (DWORD) UnloadCounterNames(hMachineKey,
                hDriverPerf, hKeyDriver, lpDriverName);

    if (dwStatus == ERROR_SUCCESS) {
        SignalWmiWithNewData (WMI_UNLODCTR_EVENT);
    }

Exit0:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UNLOADPERFCOUNTERTEXTSTRINGS,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            dwStatus,
            TRACE_WSTR(lpDriverName),
            NULL));
    if (lpDriverName != NULL) MemoryFree(lpDriverName);

    if (hDriverPerf)
        RegCloseKey (hDriverPerf);

    if (hMachineKey != HKEY_LOCAL_MACHINE && hMachineKey != NULL) {
        RegCloseKey (hMachineKey);
    }
    if (hPerfData != HKEY_PERFORMANCE_DATA && hPerfData != NULL) {
        RegCloseKey (hPerfData);
    }
    return dwStatus;
}

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA (
    IN  LPSTR   lpAnsiCommandLine,
    IN  BOOL    bQuietModeArg
)
{
    LPWSTR  lpWideCommandLine;
    DWORD   dwStrLen;
    DWORD   lReturn;

    if (lpAnsiCommandLine != 0) { // to catch bogus parameters
        //length of string including terminator
        dwStrLen = lstrlenA(lpAnsiCommandLine) + 1;

        lpWideCommandLine = GlobalAlloc (GPTR, (dwStrLen * sizeof(WCHAR)));
        if (lpWideCommandLine != NULL) {
            mbstowcs (lpWideCommandLine, lpAnsiCommandLine, dwStrLen);
            lReturn = UnloadPerfCounterTextStringsW(lpWideCommandLine,
                bQuietModeArg );
            GlobalFree (lpWideCommandLine);
        } else {
            lReturn = GetLastError();
        }
    } else {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\common\wbemutil.h ===
/*
	WBEMUtil.H

	utilities & definitions for use with WBEM perf counters

*/
#ifndef __CNTRTEXT_WBEMUTIL_H_
#define __CNTRTEXT_WBEMUTIL_H_
#include <winperf.h>

#ifdef __cplusplus
extern "c" {
#endif

typedef struct _PERFTYPE_LOOKUP {
	LONG	PerfType;
	LPWSTR	RawType;
	LPWSTR	FmtType;
} PERFTYPE_LOOKUP, *PPERFTYPE_LOOKUP;

typedef struct _PERFOBJECT_LOOKUP {
    LONG    PerfObjectId;
    LPWSTR  GuidString;
} PERFOBJECT_LOOKUP, *PPERFOBJECT_LOOKUP;

typedef struct _PERF_COUNTER_DLL_INFO {
	LPWSTR	szWbemProviderName;
	LPWSTR	szClassGuid;
	LPWSTR	szRegistryKey;
} PERF_COUNTER_DLL_INFO, *PPERF_COUNTER_DLL_INFO;

extern const PPERFTYPE_LOOKUP PerfTypes;
extern const DWORD			dwNumPerfTypes;
extern const PPERFOBJECT_LOOKUP PerfObjectGuids;
extern const DWORD			dwNumPerfObjectGuids;

extern LPCWSTR szRawClass;
extern LPCWSTR szFmtClass;
extern LPCWSTR	szGenericProviderName;
extern LPCWSTR	szGenericProviderGuid;

__inline
BOOL
IsDisplayableType (
    DWORD   dwCounterType
)
{
    if ((dwCounterType & PERF_DISPLAY_NOSHOW) &&
        (dwCounterType != PERF_AVERAGE_BULK)) {
        return FALSE;
    } else {
        return TRUE;
    }
}

LPCWSTR
GetPerfObjectGuid (
    DWORD dwObjectId
);

PERFTYPE_LOOKUP *
GetPerfTypeInfo (
    DWORD dwType
);

LPCWSTR 
FormatPerfName (
    LPWSTR  szNameIn,
    BOOL    bHiddenCounter
);

DWORD
GenerateMofHeader (
	LPWSTR	szBuffer,			// string buffer
	LPCWSTR	szComputerName,
	LPDWORD	pcchBufferSize
);

// dwFlags values
#define	WM_GMO_RAW_DEFINITION	((DWORD)0x00000001)
#define	WM_GMO_COSTLY_OBJECT	((DWORD)0x00000002)
#define WM_GMO_DEFAULT_OBJECT	((DWORD)0x00000004)
#define WM_GMO_DEFAULT_COUNTER	((DWORD)0x00000008)

DWORD
GenerateMofObject (
	LPWSTR				szBuffer,
	LPDWORD				pcchBufferSize,
	PPERF_COUNTER_DLL_INFO	pPcDllInfo,
    PERF_OBJECT_TYPE    *pPerfObject,
	LPWSTR				*lpCounterText,
	LPWSTR				*lpDisplayText, // Localized name strings array
	DWORD				dwFlags
);

DWORD
GenerateMofCounter (
	LPWSTR					szBuffer,
	LPDWORD					pcchBufferSize,
    PERF_COUNTER_DEFINITION *pPerfCounter,
	LPWSTR					*lpCounterText,	// ENGLISH name strings array
	LPWSTR					*lpDisplayText, // Localized name strings array
	DWORD					dwFlags
);

DWORD
GenerateMofObjectTail (
	LPWSTR				szBuffer,
	LPDWORD				pcchBufferSize
);


DWORD
GenerateMofInstances (
	LPWSTR					szBuffer,
	LPDWORD					pcchBufferSize,
    PERF_DATA_BLOCK		*   pPerfDataBlock,
    PERF_OBJECT_TYPE	*   pPerfObject,
	LPWSTR				*	lpCounterText,	// ENGLISH name strings array
	LPWSTR				*	lpDisplayText, // Localized name strings array
	DWORD					dwFlags
);

#ifdef __cplusplus
}
#endif

#endif //__CNTRTEXT_WBEMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\initodat\common.h ===
/*++

Copyright (c) 1993-1994 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Utility routines used by IniToDat.exe
    

Author:

    HonWah Chan (a-honwah) October, 1993 

Revision History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_


//
//  Local constants
//
#define RESERVED                0L
#define LARGE_BUFFER_SIZE       0x10000         // 64K
#define MEDIUM_BUFFER_SIZE      0x8000          // 32K
#define SMALL_BUFFER_SIZE       0x1000          //  4K
#define FILE_NAME_BUFFER_SIZE   MAX_PATH
#define DISP_BUFF_SIZE          256L
#define SIZE_OF_OFFSET_STRING   15



LPTSTR
GetStringResource (
    UINT    wStringId
);

LPSTR
GetFormatResource (
    UINT    wStringId
);

VOID
DisplayCommandHelp (
    UINT    iFirstLine,
    UINT    iLastLine
);

VOID
DisplaySummary (
    LPTSTR  lpLastID,
    LPTSTR  lpLastText,
    UINT    NumOfID
);

VOID
DisplaySummaryError (
    LPTSTR  lpLastID,
    LPTSTR  lpLastText,
    UINT    NumOfID
);


#endif  // _COMMON_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\initodat\common.c ===
/*++

Copyright (c) 1993-1994 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Utility routines used by IniToDat.exe
    

Author:

    HonWah Chan (a-honwah) October, 1993 

Revision History:

--*/

//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <tchar.h>
//
//  local include files
//
#include "common.h"
#include "strids.h"

//  Global Buffers
//
TCHAR   DisplayStringBuffer[DISP_BUFF_SIZE];
CHAR    TextFormat[DISP_BUFF_SIZE];
HANDLE  hMod;
DWORD   dwLastError;
const   LPTSTR BlankString = (const LPTSTR)TEXT(" ");
const   LPSTR  BlankAnsiString = " ";


LPTSTR
GetStringResource (
    UINT    wStringId
)
/*++

    Retrived UNICODE strings from the resource file for display 

--*/
{

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        if ((LoadString(hMod, wStringId, DisplayStringBuffer, DISP_BUFF_SIZE)) > 0) {
            return (LPTSTR)&DisplayStringBuffer[0];
        } else {
            dwLastError = GetLastError();
            return BlankString;
        }
    } else {
        return BlankString;
    }
}
LPSTR
GetFormatResource (
    UINT    wStringId
)
/*++

    Returns an ANSI string for use as a format string in a printf fn.

--*/
{

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        if ((LoadStringA(hMod, wStringId, TextFormat, DISP_BUFF_SIZE)) > 0) {
            return (LPSTR)&TextFormat[0];
        } else {
            dwLastError = GetLastError();
            return BlankAnsiString;
        }
    } else {
        return BlankAnsiString;
    }
}

VOID
DisplayCommandHelp (
    UINT    iFirstLine,
    UINT    iLastLine
)
/*++

DisplayCommandHelp

    displays usage of command line arguments

Arguments

    NONE

Return Value

    NONE

--*/
{
    UINT iThisLine;

    for (iThisLine = iFirstLine;
        iThisLine <= iLastLine;
        iThisLine++) {
        printf ("\n%ws", GetStringResource(iThisLine));
    }

} // DisplayCommandHelp

VOID
DisplaySummary (
    LPTSTR  lpLastID,
    LPTSTR  lpLastText,
    UINT    NumOfID
)
{
   printf ("%ws", GetStringResource(LC_SUMMARY));
   printf ("%ws", GetStringResource(LC_NUM_OF_ID));
   printf ("%ld\n", NumOfID);
   printf ("%ws", GetStringResource(LC_LAST_ID));
   printf ("%ws\n", lpLastID ? lpLastID : (LPCTSTR)TEXT(""));
   printf ("%ws", GetStringResource(LC_LAST_TEXT));
   printf ("%ws\n", lpLastText ? lpLastText : (LPCTSTR)TEXT(""));
}


VOID
DisplaySummaryError (
    LPTSTR  lpLastID,
    LPTSTR  lpLastText,
    UINT    NumOfID
)
{
   printf ("%ws", GetStringResource(LC_BAD_ID));
   printf ("%ws\n", lpLastID ? lpLastID : (LPCTSTR)TEXT(""));
   printf ("%ws\n", GetStringResource(LC_MISSING_DEL));
   DisplaySummary (lpLastID, lpLastText, NumOfID);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\ctrlist\ctrlist.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ctrlist.c

Abstract:

    Program to read the current perfmon counters and dump a list of
        objects and counters returned by the registry

Author:

    Bob Watson (a-robw) 4 Dec 92

Revision History:
    HonWah Chan May 22, 93 - added more features
    HonWah Chan Oct 18, 93 - added check for perflib version.
            Old version --> get names from registry
            New version --> get names from PerfLib thru HKEY_PERFORMANCE_DATA
    Bob Watson (a-robw) 1 Dec 95    added new counter types

--*/
#define UNICODE 1
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <wbemutil.h>

#define MAX_LEVEL 400
LPSTR DetailLevelStr[] = { "Novice", "Advanced", "Expert", "Wizard"};
// LPCWSTR lpwszDiskPerfKey = (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\Diskperf";        
LPCWSTR NamesKey = (LPCWSTR)L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR DefaultLangId = (LPCWSTR)L"009";
LPCWSTR Counters = (LPCWSTR)L"Counters";
LPCWSTR Help = (LPCWSTR)L"Help";
LPCWSTR LastHelp = (LPCWSTR)L"Last Help";
LPCWSTR LastCounter = (LPCWSTR)L"Last Counter";
LPCWSTR Slash = (LPCWSTR)L"\\";

// the following strings are for getting texts from perflib
#define  OLD_VERSION 0x010000
LPCWSTR VersionName = (LPCWSTR)L"Version";
LPCWSTR CounterName = (LPCWSTR)L"Counter ";
LPCWSTR HelpName = (LPCWSTR)L"Explain ";

#define RESERVED    0L
#define INITIAL_SIZE     (1024*64)
#define EXTEND_SIZE      (1024*16)
#define LINE_LENGTH     80
#define WRAP_POINT      LINE_LENGTH-12

typedef LPVOID  LPMEMORY;
typedef HGLOBAL HMEMORY;

#define MemoryAllocate(x)   ((LPMEMORY)GlobalAlloc(GPTR, x))
#define MemoryFree(x)       ((VOID)GlobalFree(x))
#define MemorySize(x)       ((x != NULL) ? (DWORD)GlobalSize(x) : (DWORD)0)
#define MemoryResize(x,y)   ((LPMEMORY)GlobalReAlloc(x,y,GMEM_MOVEABLE));

LPWSTR  *lpCounterText;
LPWSTR	*lpDisplayText;

TCHAR  szComputerName[MAX_COMPUTERNAME_LENGTH+1];

const CHAR  PerfCounterCounter[]       = "PERF_COUNTER_COUNTER";
const CHAR  PerfCounterTimer[]         = "PERF_COUNTER_TIMER";
const CHAR  PerfCounterQueueLen[]      = "PERF_COUNTER_QUEUELEN_TYPE";
const CHAR  PerfCounterLargeQueueLen[] = "PERF_COUNTER_LARGE_QUEUELEN_TYPE";
const CHAR  PerfCounterBulkCount[]     = "PERF_COUNTER_BULK_COUNT";
const CHAR  PerfCounterText[]          = "PERF_COUNTER_TEXT";
const CHAR  PerfCounterRawcount[]      = "PERF_COUNTER_RAWCOUNT";
const CHAR  PerfCounterRawcountHex[]   = "PERF_COUNTER_RAWCOUNT_HEX";
const CHAR  PerfCounterLargeRawcount[] = "PERF_COUNTER_LARGE_RAWCOUNT";
const CHAR  PerfCounterLargeRawcountHex[] = "PERF_COUNTER_LARGE_RAWCOUNT_HEX";
const CHAR  PerfSampleFraction[]       = "PERF_SAMPLE_FRACTION";
const CHAR  PerfSampleCounter[]        = "PERF_SAMPLE_COUNTER";
const CHAR  PerfCounterNodata[]        = "PERF_COUNTER_NODATA";
const CHAR  PerfCounterTimerInv[]      = "PERF_COUNTER_TIMER_INV";
const CHAR  PerfSampleBase[]           = "PERF_SAMPLE_BASE";
const CHAR  PerfAverageTimer[]         = "PERF_AVERAGE_TIMER";
const CHAR  PerfAverageBase[]          = "PERF_AVERAGE_BASE";
const CHAR  PerfAverageBulk[]          = "PERF_AVERAGE_BULK";
const CHAR  Perf100nsecTimer[]         = "PERF_100NSEC_TIMER";
const CHAR  Perf100nsecTimerInv[]      = "PERF_100NSEC_TIMER_INV";
const CHAR  PerfCounterMultiTimer[]    = "PERF_COUNTER_MULTI_TIMER";

const CHAR  PerfCounterMultiTimerInv[] = "PERF_COUNTER_MULTI_TIMER_INV";
const CHAR  PerfCounterMultiBase[]     = "PERF_COUNTER_MULTI_BASE";
const CHAR  Perf100nsecMultiTimer[]    = "PERF_100NSEC_MULTI_TIMER";
const CHAR  Perf100nsecMultiTimerInv[] = "PERF_100NSEC_MULTI_TIMER_INV";
const CHAR  PerfRawFraction[]          = "PERF_RAW_FRACTION";
const CHAR  PerfRawBase[]              = "PERF_RAW_BASE";
const CHAR  PerfElapsedTime[]          = "PERF_ELAPSED_TIME";
const CHAR  PerfCounterHistogramType[] = "PERF_COUNTER_HISTOGRAM_TYPE";
const CHAR  PerfCounterDelta[]         = "PERF_COUNTER_DELTA";
const CHAR  PerfCounterLargeDelta[]    = "PERF_COUNTER_LARGE_DELTA";
const CHAR  NotDefineCounterType[]     = " ";

const CHAR  PerfCounter100NsQueLenType[] = "PERF_COUNTER_100NS_QUEUELEN_TYPE";
const CHAR  PerfCounterObjTimeQueLenType[] = "PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE";
const CHAR  PerfObjTimeTimer[]         = "PERF_OBJ_TIME_TIMER";
const CHAR  PerfLargeRawFraction[]     = "PERF_LARGE_RAW_FRACTION";
const CHAR  PerfLargeRawBase[]         = "PERF_LARGE_RAW_BASE";
const CHAR  PerfPrecisionSystemTimer[] = "PERF_PRECISION_SYSTEM_TIMER";
const CHAR  PerfPrecision100NsTimer[]  = "PERF_PRECISION_100NS_TIMER";
const CHAR  PerfPrecisionObjectTimer[] = "PERF_PRECISION_OBJECT_TIMER";

BOOL    bFormatCSV  = FALSE;
BOOL    bFormatMOF  = FALSE;
BOOL    bPrintMOFData = FALSE;
BOOL    bCheckCtrType = FALSE;
//
//  Object Record Fields are:
//      Record Type = "O" for Object Record
//      Object name string ID
//      Object Name in selected language
//      Object Detail Level string (in english)
//      has Instance Records [1= yes, 0= no]
//      Object Instance Code Page [0 = unicode]
//      Help text ID
//      Help text
//
const CHAR  fmtObjectRecord[] =
    "\n\"O\",\"%d\",\"%ws\",\"%s\",\"%d\",\"%d\",\"%d\",\"%ws\"";
//
//  Counter Record Fields are:
//      Record Type = "C" for Counter Record
//      Object name string ID               { these fields are used as links
//      Object Name in selected language    {   to object info records
//      Counter name string ID
//      Counter name text in selected language
//      Counter Detail Level string (in english)
//      Counter Type value as a HEX string
//      Counter Type Name
//      Counter Data field size in bytes
//      Counter Visibility [1= listed in list box, 0=hidden]
//      Counter Help text ID
//      Counter Help text
//
const CHAR  fmtCounterRecord[] =
    "\n\"C\",\"%d\",\"%ws\",\"%d\",\"%ws\",\"%s\",\"0x%8.8x\",\"%s\",\"%d\",\"%d\",\"%d\",\"%ws\"";


__inline
static
PPERF_OBJECT_TYPE
FirstObject (
    PPERF_DATA_BLOCK pPerfData
)
{
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pPerfData + pPerfData->HeaderLength));
}


__inline
static
PPERF_OBJECT_TYPE
NextObject (
    PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pObject + pObject->TotalByteLength));
}  // NextObject

__inline
static
PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->HeaderLength);
}

__inline
static
PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pCounterDef + pCounterDef->ByteLength);
}

__inline
static
BOOL
ValidCtrSizeDef(
    PERF_COUNTER_DEFINITION *pThisCounter
)
{
#define PERF_COUNTER_SIZE_MASK  0x00000300
    DWORD   dwSizeValue = pThisCounter->CounterType & PERF_COUNTER_SIZE_MASK;
    BOOL    bReturn = TRUE;
    if ((dwSizeValue == PERF_SIZE_DWORD) && (pThisCounter->CounterSize != sizeof(DWORD))) {
        bReturn = FALSE;
    } else if ((dwSizeValue == PERF_SIZE_LARGE) && (pThisCounter->CounterSize != sizeof(__int64))) {
        bReturn = FALSE;
    } else if ((dwSizeValue == PERF_SIZE_ZERO) && (pThisCounter->CounterSize != 0)) {
        bReturn = FALSE;
    } // else assume that the variable length value is valid
    return bReturn;
}

_inline
static
DWORD
CtrTypeSize (
    PERF_COUNTER_DEFINITION *pThisCounter
)
{
    DWORD   dwSizeValue = pThisCounter->CounterType & PERF_COUNTER_SIZE_MASK;

    switch (dwSizeValue) {
    case PERF_SIZE_DWORD:
        return sizeof(DWORD);

    case PERF_SIZE_LARGE:
        return sizeof(__int64);

    case PERF_SIZE_ZERO:
        return 0;

    default:
        return (pThisCounter->CounterSize);
    }
}

__inline
static
PERF_INSTANCE_DEFINITION *
FirstInstance(
    PERF_OBJECT_TYPE * pObjectDef)
{
    return (PERF_INSTANCE_DEFINITION * )
               ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}

__inline
static
PERF_INSTANCE_DEFINITION *
NextInstance(
    PERF_INSTANCE_DEFINITION * pInstDef)
{
    PERF_COUNTER_BLOCK *pCounterBlock;

    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION * )
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

__inline
static
LPCWSTR
GetInstanceName(
    PERF_INSTANCE_DEFINITION *pInstDef
)
{
    static WCHAR    szLocalName[MAX_PATH];
    LPWSTR  szSrc, szDest;

    assert ((pInstDef->NameLength) < (MAX_PATH * sizeof(WCHAR)));
    szDest = &szLocalName[0];
    szSrc = (LPWSTR) ((PCHAR) pInstDef + pInstDef->NameOffset); 

    while (*szSrc != 0) {
        switch (*szSrc) {
        case '\\':
            *szDest++ = *szSrc;
            *szDest++ = *szSrc++;
            break;

        default:
            *szDest++ = *szSrc++;
        };
    }
    *szDest++ = 0;

    return (LPCWSTR)&szLocalName[0];
}

void
PrintMofHeader ()
{
    WCHAR	szPrintBuffer[8192];
    DWORD   dwLength = 8192;
	DWORD	dwStatus;

	dwStatus = GenerateMofHeader (szPrintBuffer, szComputerName, &dwLength);

	if (dwStatus == ERROR_SUCCESS) {
		printf ("%ls", szPrintBuffer);
	}
}

void
PrintMofObject (
    PERF_OBJECT_TYPE    *pPerfObject,
    BOOL                bRawDefinition,
    BOOL                bCostlyObject,
	BOOL				bDefaultObject
)
{
    WCHAR	szPrintBuffer[8192*2];
    DWORD   dwLength = 8192*2;
	DWORD	dwStatus;
	DWORD	dwFlags;

	dwFlags = 0;
	dwFlags |= (bRawDefinition ? WM_GMO_RAW_DEFINITION : 0);
    dwFlags |= (bCostlyObject ? WM_GMO_COSTLY_OBJECT : 0);
	dwFlags |= (bDefaultObject ? WM_GMO_DEFAULT_OBJECT : 0); 

	dwStatus = GenerateMofObject (
		szPrintBuffer,
		&dwLength,
		NULL,
		pPerfObject,
		lpCounterText,
		lpDisplayText,
		dwFlags);

	if (dwStatus == ERROR_SUCCESS) {
		printf ("%ls", szPrintBuffer);
	}
}

void
PrintMofCounter (
    PERF_COUNTER_DEFINITION *pPerfCounter,
    BOOL                    bRawDefinition,
	BOOL					bDefaultCounter
)
{
    WCHAR	szPrintBuffer[8192*2];
    DWORD   dwLength = 8192*2;
	DWORD	dwStatus;
	DWORD	dwFlags;

	dwFlags = 0;
	dwFlags |= (bRawDefinition ? WM_GMO_RAW_DEFINITION : 0);
	dwFlags |= (bDefaultCounter ? WM_GMO_DEFAULT_COUNTER : 0); 

	dwStatus = GenerateMofCounter (
		szPrintBuffer,
		&dwLength,
		pPerfCounter,
		lpCounterText,
		lpDisplayText,
		dwFlags);

	if (dwStatus == ERROR_SUCCESS) {
		printf ("%ls", szPrintBuffer);
	}
}

void
PrintMofInstances (
    PERF_DATA_BLOCK *  pPerfDataBlock,
    PERF_OBJECT_TYPE * pPerfObject,
    BOOL                bRawDefinition
)
{
    WCHAR	szPrintBuffer[8192*2];
    DWORD   dwLength = 8192*2;
	DWORD	dwStatus;
	DWORD	dwFlags;

	dwFlags = 0;
	dwFlags |= (bRawDefinition ? WM_GMO_RAW_DEFINITION : 0);

	dwStatus = GenerateMofInstances (
		szPrintBuffer,
		&dwLength,
		pPerfDataBlock,
		pPerfObject,
		lpCounterText,	// name strings array
		lpDisplayText,
		dwFlags);

	if (dwStatus == ERROR_SUCCESS) {
		printf ("%ls", szPrintBuffer);
	}
}

LPCSTR
GetCounterType(
    DWORD CounterType
)
{
    switch (CounterType) {
         case PERF_COUNTER_COUNTER:
               return (PerfCounterCounter);

         case PERF_COUNTER_TIMER:
               return (PerfCounterTimer);

         case PERF_COUNTER_QUEUELEN_TYPE:
               return (PerfCounterQueueLen);

         case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
               return (PerfCounterLargeQueueLen);

         case PERF_COUNTER_100NS_QUEUELEN_TYPE:
               return (PerfCounter100NsQueLenType);

         case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
               return (PerfCounterObjTimeQueLenType);

         case PERF_COUNTER_BULK_COUNT:
               return (PerfCounterBulkCount);

         case PERF_COUNTER_TEXT:
               return (PerfCounterText);

         case PERF_COUNTER_RAWCOUNT:
               return (PerfCounterRawcount);

         case PERF_COUNTER_LARGE_RAWCOUNT:
               return (PerfCounterLargeRawcount);

         case PERF_COUNTER_RAWCOUNT_HEX:
               return (PerfCounterRawcountHex);

         case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
               return (PerfCounterLargeRawcountHex);

         case PERF_SAMPLE_FRACTION:
               return (PerfSampleFraction);

         case PERF_SAMPLE_COUNTER:
               return (PerfSampleCounter);

         case PERF_COUNTER_NODATA:
               return (PerfCounterNodata);

         case PERF_COUNTER_TIMER_INV:
               return (PerfCounterTimerInv);

         case PERF_SAMPLE_BASE:
               return (PerfSampleBase);

         case PERF_AVERAGE_TIMER:
               return (PerfAverageTimer);

         case PERF_AVERAGE_BASE:
               return (PerfAverageBase);

         case PERF_AVERAGE_BULK:
               return (PerfAverageBulk);
    
         case PERF_OBJ_TIME_TIMER:
               return (PerfObjTimeTimer);

         case PERF_100NSEC_TIMER:
               return (Perf100nsecTimer);

         case PERF_100NSEC_TIMER_INV:
               return (Perf100nsecTimerInv);

         case PERF_COUNTER_MULTI_TIMER:
               return (PerfCounterMultiTimer);

         case PERF_COUNTER_MULTI_TIMER_INV:
               return (PerfCounterMultiTimerInv);

         case PERF_COUNTER_MULTI_BASE:
               return (PerfCounterMultiBase);

         case PERF_100NSEC_MULTI_TIMER:
               return (Perf100nsecMultiTimer);

         case PERF_100NSEC_MULTI_TIMER_INV:
               return (Perf100nsecMultiTimerInv);

         case PERF_RAW_FRACTION:
               return (PerfRawFraction);

         case PERF_LARGE_RAW_FRACTION:
               return (PerfLargeRawFraction);

         case PERF_RAW_BASE:
               return (PerfRawBase);

         case PERF_LARGE_RAW_BASE:
               return (PerfLargeRawBase);

         case PERF_ELAPSED_TIME:
               return (PerfElapsedTime);

         case PERF_COUNTER_HISTOGRAM_TYPE:
               return (PerfCounterHistogramType);

         case PERF_COUNTER_DELTA:
                return (PerfCounterDelta);

         case PERF_COUNTER_LARGE_DELTA:
                return (PerfCounterLargeDelta);

         case PERF_PRECISION_SYSTEM_TIMER:
                return (PerfPrecisionSystemTimer);

         case PERF_PRECISION_100NS_TIMER:
                return (PerfPrecision100NsTimer);

         case PERF_PRECISION_OBJECT_TIMER:
                return (PerfPrecisionObjectTimer);

         default:
               return (NotDefineCounterType);
    }
}

void
DisplayUsage (
    void
)
{

    printf("\nCtrList - Lists all the objects and counters installed in\n");
    printf("          the system for the given language ID\n");
    printf("\nUsage:  ctrlist [-cmd] [LangID] [\\\\machine] > <filename>\n");
    printf("\n -c prints data in a CSV format");
    printf("\n -m prints data as a WBEM MOF");
    printf("\n -d prints data as a WBEM MOF with perf data instances defined");
    printf("\n (note: only one of the above command switches may be used");
    printf("\n   LangID  - 009 for English (default)\n");
    printf("           - 007 for German\n");
    printf("           - 00A for Spanish\n");
    printf("           - 00C for French\n");
    printf("   \\\\machine may be specified to list counters on a\n");
    printf("           remote system\n\n");
    printf("   Example - \"ctrlist 00C > french.lst\" will get all the\n");
    printf("   objects and counters for the French system and put\n");
    printf("   them in the file french.lst\n");


    return;

} /* DisplayUsage() */

LPWSTR
*BuildNameTable(
    HKEY    hKeyRegistry,   // handle to registry db with counter names
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
)
/*++
   
BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:
     
    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{

    LPWSTR  *lpReturnValue;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;
    
    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;
    
    HKEY    hKeyValue;
    HKEY    hKeyNames;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];



    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;
    hKeyValue = NULL;
    hKeyNames = NULL;
   
    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = (LPWSTR)DefaultLangId;
    }

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyEx (
        hKeyRegistry,
        NamesKey,
        RESERVED,
        KEY_READ,
        &hKeyValue);
    
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items
    
    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastHelp,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    // get number of items
    
    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastCounter,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }


    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        VersionName,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = MemoryAllocate (
            lstrlen(NamesKey) * sizeof (WCHAR) +
            lstrlen(Slash) * sizeof (WCHAR) +
            lstrlen(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));
        
        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpy (lpValueNameString, NamesKey);
        lstrcat (lpValueNameString, Slash);
        lstrcat (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyEx (
            hKeyRegistry,
            lpValueNameString,
            RESERVED,
            KEY_READ,
            &hKeyNames);
    } else {
        if (szComputerName[0] == 0) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        } else {
            lWin32Status = RegConnectRegistry (szComputerName,
                HKEY_PERFORMANCE_DATA,
                &hKeyNames);
        }
        lstrcpy (CounterNameBuffer, CounterName);
        lstrcat (CounterNameBuffer, lpszLangId);

        lstrcpy (HelpNameBuffer, HelpName);
        lstrcat (HelpNameBuffer, lpszLangId);
    }

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
   
    dwHelpSize = dwBufferSize;

    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) goto BNT_BAILOUT;

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpCounterNames,
        &dwBufferSize);

    if (!lpReturnValue) goto BNT_BAILOUT;
 
    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpHelpText,
        &dwBufferSize);
                            
    if (!lpReturnValue) goto BNT_BAILOUT;
 
    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) goto BNT_BAILOUT;  // bad entry

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);  

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) goto BNT_BAILOUT;  // bad entry

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }
    
    if (pdwLastItem) *pdwLastItem = dwLastId;

    MemoryFree ((LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
//    if (dwSystemVersion == OLD_VERSION)
        RegCloseKey (hKeyNames);

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpValueNameString) {
        MemoryFree ((LPVOID)lpValueNameString);
    }
    
    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }
    
    if (hKeyValue) RegCloseKey (hKeyValue);

//    if (dwSystemVersion == OLD_VERSION &&
//        hKeyNames) 
       RegCloseKey (hKeyNames);


    return NULL;
}

LONG
GetEnumPerfData (
    IN HKEY hKeySystem,
    IN DWORD dwIndex,
    IN PPERF_DATA_BLOCK *pPerfData
)
{  // GetSystemPerfData
    LONG     lError ;
    DWORD    Size;
    DWORD    Type;

    if (dwIndex >= 2)
        return !ERROR_SUCCESS;

    if (*pPerfData == NULL) {
        *pPerfData = MemoryAllocate (INITIAL_SIZE);
        if (*pPerfData == NULL) { 
            return ERROR_OUTOFMEMORY;
	    }
    }
#pragma warning ( disable : 4127 )
    while (TRUE) {
        Size = MemorySize (*pPerfData);
   
        lError = RegQueryValueEx (
            hKeySystem,
            dwIndex == 0 ?
               (LPCWSTR)L"Global" :
               (LPCWSTR)L"Costly",
            RESERVED,
            &Type,
            (LPBYTE)*pPerfData,
            &Size);

        if ((!lError) &&
            (Size > 0) &&
            (*pPerfData)->Signature[0] == (WCHAR)'P' &&
            (*pPerfData)->Signature[1] == (WCHAR)'E' &&
            (*pPerfData)->Signature[2] == (WCHAR)'R' &&
            (*pPerfData)->Signature[3] == (WCHAR)'F' ) {

            return (ERROR_SUCCESS);
        }

        if (lError == ERROR_MORE_DATA) {
            *pPerfData = MemoryResize (
                *pPerfData, 
                MemorySize (*pPerfData) +
                EXTEND_SIZE);

            if (!*pPerfData) {
                return (lError);
            }
        } else {
            return (lError);  
        }  // else
    }
#pragma warning ( default : 4127 )

}  // GetSystemPerfData

LONG
PrintHelpText(
    DWORD   Indent,
    DWORD   dwID,
    LPWSTR  szTextString
)
{
    LPWSTR  szThisChar;

    BOOL    bNewLine;

    DWORD   dwThisPos;
    DWORD   dwLinesUsed;

    szThisChar = szTextString;
    dwLinesUsed = 0;

    // check arguments

    if (!szTextString) {
        return dwLinesUsed;
    }
    
    if (Indent > WRAP_POINT) {
        return dwLinesUsed; // can't do this
    }

    // display id number 

    for (dwThisPos = 0; dwThisPos < Indent - 6; dwThisPos++) {
        putchar (' ');
    }

    dwThisPos += printf ("[%3.3d] ", dwID);
    bNewLine = FALSE;

    // print text

    while (*szThisChar) {

        if (bNewLine){
            for (dwThisPos = 0; dwThisPos < Indent; dwThisPos++) {
                putchar (' ');
            }

            bNewLine = FALSE;
        }
        if ((*szThisChar == L' ') && (dwThisPos >= WRAP_POINT)) {
            putchar ('\n');
            bNewLine = TRUE;
            // go to next printable character
            while (*szThisChar <= L' ') {
                szThisChar++;
            }
            dwLinesUsed++;
        } else {
            putchar (*szThisChar);
            szThisChar++;
        }

        dwThisPos++;
    }

    putchar ('\n');
    bNewLine = TRUE;
    dwLinesUsed++;

    return dwLinesUsed;
}

#pragma warning ( disable : 4706 )
int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    int     ArgNo;

    DWORD   dwLastElement;

    DWORD   dwIndex;
    
    DWORD   dwDisplayLevel;

    PPERF_DATA_BLOCK   pDataBlock; // pointer to perfdata block
    BOOL   bError;

    DWORD   dwThisObject;
    DWORD   dwThisCounter;
    CHAR    LangID[10];
    WCHAR   wLangID[10];
    BOOL    UseDefaultID = FALSE;
    LPSTR   szComputerNameArg = NULL;
    DWORD   dwLoop;
    DWORD   dwLoopEnd;
    DWORD   dwErrorCount;
    DWORD   dwStatus;

    PPERF_OBJECT_TYPE   pThisObject;
    PPERF_COUNTER_DEFINITION pThisCounter;

    HKEY    hKeyMachine = HKEY_LOCAL_MACHINE;
    HKEY    hKeyPerformance = HKEY_PERFORMANCE_DATA;

    dwDisplayLevel = PERF_DETAIL_WIZARD;
    
    // open key to registry or use default

    if (argc >= 2) {
        if ((argv[1][0] == '-' || argv[1][0] == '/') &&
             argv[1][1] == '?') {
            DisplayUsage();
            return 0;
        }

        if (argv[1][0] != '\\') {
            if ((argv[1][0] == '-') || (argv[1][0] == '/')) {
                // then this is a command switch
                if ((argv[1][1] == 'c') || (argv[1][1] == 'C')) {
                    // then format is a CSV
                    bFormatCSV = TRUE;
                } else if ((argv[1][1] == 'm') || (argv[1][1] == 'M')) {
                    // then format is a MOF
                    bFormatMOF = TRUE;
                } else if ((argv[1][1] == 'd') || (argv[1][1] == 'D')) {
                    // then format is a MOF w/ data
                    bFormatMOF = TRUE;
                    bPrintMOFData = TRUE;
                } else if ((argv[1][1] == 'e') || (argv[1][1] == 'E')) {
                    bCheckCtrType = TRUE;
                }
                ArgNo = 2;
            } else {
                ArgNo = 1;
            }

            if (argc > ArgNo) {
                // get the lang ID
                if (argv[ArgNo][0] != '\\') {
                    LangID[0] = argv[ArgNo][0];        
                    LangID[1] = argv[ArgNo][1];        
                    LangID[2] = argv[ArgNo][2];        
                    LangID[3] = '\0';
                    mbstowcs(wLangID, LangID, 4);
                    ++ArgNo;
                } else {
                    lstrcpyW (wLangID, (LPCWSTR)L"009");
                }

                if (argc > (ArgNo)) {
                    // see if the next arg is a computer name
                    if (argv[ArgNo][0] == '\\') {
                        mbstowcs (szComputerName, argv[ArgNo],
                            MAX_COMPUTERNAME_LENGTH);
                        szComputerNameArg = argv[ArgNo];
                    } else {
                        szComputerName[0] = 0;
                    }
                }
            }
        } else {
            // 1st arg is a computer name
            mbstowcs (szComputerName, argv[1], MAX_COMPUTERNAME_LENGTH);
            szComputerNameArg = argv[1];
        }

#if 0
        // get user level from command line
        if (argc > 2 && sscanf(argv[2], " %d", &dwDisplayLevel) == 1) {
            if (dwDisplayLevel <= PERF_DETAIL_NOVICE) {
                dwDisplayLevel = PERF_DETAIL_NOVICE;
            } else if (dwDisplayLevel <= PERF_DETAIL_ADVANCED) {
                dwDisplayLevel = PERF_DETAIL_ADVANCED;
            } else if (dwDisplayLevel <= PERF_DETAIL_EXPERT) {
                dwDisplayLevel = PERF_DETAIL_EXPERT;
            } else {
                dwDisplayLevel = PERF_DETAIL_WIZARD;
            }
        } else {
            dwDisplayLevel = PERF_DETAIL_WIZARD;
        }
#endif

    } else {
        UseDefaultID = TRUE;
        szComputerName[0] = 0;
    }

    if (szComputerName[0] != 0) {
        if (RegConnectRegistry (szComputerName, HKEY_LOCAL_MACHINE,
            &hKeyMachine) != ERROR_SUCCESS) {
            printf ("\nUnable to connect to %s", szComputerNameArg);
            return 0;
        }
        dwStatus = RegConnectRegistry (szComputerName, HKEY_PERFORMANCE_DATA,
            &hKeyPerformance);
        if (dwStatus  != ERROR_SUCCESS) {
            printf ("\nUnable to connect to %s", szComputerNameArg);
            return 0;
        }
    } else {
        // use default initializations
    }

    lpCounterText = BuildNameTable (
        hKeyMachine,
        (LPWSTR)(DefaultLangId),	// counter text is in ENGLISH always
        &dwLastElement);

    if (!lpCounterText) {
        printf("***FAILure*** Cannot open the registry\n");
        return 0;
    }

    lpDisplayText = BuildNameTable (
        hKeyMachine,
        (LPWSTR)(UseDefaultID ? DefaultLangId : wLangID),
        &dwLastElement);

    if (!lpDisplayText) {
        printf("***FAILure*** Cannot open the registry\n");
        return 0;
    }

    if (bFormatMOF) {
        // then print the header block
        PrintMofHeader ();
    }

    // get a performance data buffer with counters

    pDataBlock = 0;


    for (dwIndex = 0; (bError = GetEnumPerfData (  
        hKeyPerformance,
        dwIndex,
        &pDataBlock) == ERROR_SUCCESS); dwIndex++) {

        for (dwThisObject = 0, pThisObject = FirstObject (pDataBlock);
            dwThisObject < pDataBlock->NumObjectTypes;
            dwThisObject++, pThisObject = NextObject(pThisObject)) {

            if (bFormatMOF) {
                if (bPrintMOFData) {
                    dwLoopEnd = 2;
                } else {
                    dwLoopEnd = 1;
                }
            } else {
                dwLoopEnd = 0;
            }

            dwLoop = 0;
            do {
                if (bFormatCSV) {
                    printf (fmtObjectRecord,
                        pThisObject->ObjectNameTitleIndex,
                        lpDisplayText[pThisObject->ObjectNameTitleIndex],
                        pThisObject->DetailLevel <= MAX_LEVEL ?
                            DetailLevelStr[pThisObject->DetailLevel/100-1] :
                            "<N\\A>",
                        pThisObject->NumInstances == PERF_NO_INSTANCES ?
                            0 : 1,
                        pThisObject->CodePage,
                        pThisObject->ObjectHelpTitleIndex,
                        lpDisplayText[pThisObject->ObjectHelpTitleIndex]);
                } else if (bFormatMOF) {
                    if (dwLoop < 2) PrintMofObject (pThisObject, 
                            (dwLoop == 0 ? FALSE : TRUE),
                            (dwIndex == 0 ? FALSE : TRUE),
							((DWORD)pDataBlock->DefaultObject == 
								pThisObject->ObjectNameTitleIndex ? TRUE : FALSE));
                } else {
                    printf ("\nObject: \"%ws\"  [%3.3d]",
                        lpDisplayText[pThisObject->ObjectNameTitleIndex],
                        pThisObject->ObjectNameTitleIndex);
                    if (!bCheckCtrType) {
                        printf ("\n   Detail Level: %s\n",
                            pThisObject->DetailLevel <= MAX_LEVEL ?
                            DetailLevelStr[pThisObject->DetailLevel/100-1] :
                            "<N\\A>");
                   
                        PrintHelpText (9,
                            pThisObject->ObjectHelpTitleIndex,
                            lpDisplayText[pThisObject->ObjectHelpTitleIndex]);
                    }
                }

                dwErrorCount = 0;

                for (dwThisCounter = 0, pThisCounter = FirstCounter(pThisObject);
                    dwThisCounter < pThisObject->NumCounters;
                    dwThisCounter++, pThisCounter = NextCounter(pThisCounter)) {

                    __try {
                        if (pThisCounter->DetailLevel <= dwDisplayLevel) {
                            if (bFormatCSV) {
                                printf (fmtCounterRecord,
                                    pThisObject->ObjectNameTitleIndex,
                                    lpDisplayText[pThisObject->ObjectNameTitleIndex],
                                    pThisCounter->CounterNameTitleIndex,
                                    lpDisplayText[pThisCounter->CounterNameTitleIndex],
                                    ((pThisCounter->DetailLevel <= MAX_LEVEL)  &&
                                        (pThisCounter->DetailLevel > 0 )) ?
                                        DetailLevelStr[pThisCounter->DetailLevel/100-1] :
                                        "<N\\A>",
                                    pThisCounter->CounterType,
                                    GetCounterType(pThisCounter->CounterType),
                                    pThisCounter->CounterSize,
                                    IsDisplayableType(pThisCounter->CounterType) ?
                                        1 : 0,
                                    pThisCounter->CounterHelpTitleIndex,
                                    lpDisplayText[pThisCounter->CounterHelpTitleIndex]);
                            } else if (bFormatMOF) {
                                if (dwLoop < 2) {
                                    PrintMofCounter (pThisCounter, 
										(dwLoop == 0 ? FALSE : TRUE),
										(dwThisCounter == (DWORD)pThisObject->DefaultCounter ? TRUE : FALSE));
                                }
                            } else if (bCheckCtrType) {
                                if (!ValidCtrSizeDef(pThisCounter)) {
                                    printf ("\n    [%3.3d] \"%ws\" data size should be %d bytes, but reports a size of %d bytes",
                                        pThisCounter->CounterNameTitleIndex,
                                        lpDisplayText[pThisCounter->CounterNameTitleIndex],
                                        CtrTypeSize (pThisCounter),
                                        pThisCounter->CounterSize);
                                    dwErrorCount++;
                                }
                            } else {
                                printf ("\n    <%ws> [%3.3d]",
                                    lpDisplayText[pThisCounter->CounterNameTitleIndex],
                                    pThisCounter->CounterNameTitleIndex);
                                printf ("\n          Default Scale: %d",
                                    pThisCounter->DefaultScale);
                                printf ("\n          Detail Level: %s",
                                    ((pThisCounter->DetailLevel <= MAX_LEVEL)  &&
                                    (pThisCounter->DetailLevel > 0 ))?
                                    DetailLevelStr[pThisCounter->DetailLevel/100-1] :
                                    "<N\\A>");
                                printf ("\n          Counter Type: 0x%x, %s",
                                    pThisCounter->CounterType,
                                    GetCounterType(pThisCounter->CounterType));
                                printf ("\n          Counter Size: %d bytes",
                                    pThisCounter->CounterSize);

                                printf ("\n");
                                PrintHelpText (16,
                                    pThisCounter->CounterHelpTitleIndex,
                                    lpDisplayText[pThisCounter->CounterHelpTitleIndex]);
                            }
                        } // end if the right detail level
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        if (!bFormatCSV) {
                            printf ("\n          Error (%d) reading this counter",
                                GetExceptionCode());
                        }
                    }
                }  // end for each counter

                if ((dwLoop == 2) && bFormatMOF) {
                    // dump data for raw classes only
                    PrintMofInstances (pDataBlock, pThisObject, TRUE);
                } 

                // close up object text
                if ((bFormatMOF) && (dwLoop != 2)) {
                    //{ brace inserted to not throw off the brace counter
                    printf("\n};\n");
                }

                if (bCheckCtrType) {
                    printf ("\n    %d bad counters in this object.\n",
                        dwErrorCount);
                } else {
                    printf ("\n");
                }


            } while (dwLoop++ < dwLoopEnd); // end while
        }
        RegCloseKey (hKeyPerformance);
        if (szComputerName[0] != 0) {
            RegCloseKey (hKeyMachine);
        }
    }

	if (lpDisplayText != NULL) MemoryFree (lpDisplayText);
	if (lpCounterText != NULL) MemoryFree (lpCounterText);

    return 0;
}
#pragma warning ( default : 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\initodat\initodat.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    initodat.c

Abstract:

    Routines for converting Perf???.ini to Perf???.dat files.

Author:

    HonWah Chan (a-honwah)  October, 1993

Revision History:

--*/

#include "initodat.h"
#include "strids.h"
#include "common.h"
#include "tchar.h"

#define ALLOCMEM(x)	HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (DWORD)(x))
#define FREEMEM(x)	HeapFree (GetProcessHeap(), 0, (LPVOID)(x))

BOOL
MakeUpgradeFilename (
    LPCTSTR szDataFileName,
    LPTSTR  szUpgradeFileName
)
{
    BOOL    bReturn = FALSE;
    // note: assumes szUpgradeFileName buffer is large enough for result
    TCHAR   szDrive[_MAX_DRIVE];
    TCHAR   szDir[_MAX_DIR];
    TCHAR   szFileName[_MAX_FNAME];
    TCHAR   szExt[_MAX_EXT];

    _tsplitpath(szDataFileName, 
        (LPTSTR)szDrive,
        (LPTSTR)szDir,
        (LPTSTR)szFileName,
        (LPTSTR)szExt);

    // see if the filename fits the "PERF[C|H]XXX" format
    if (((szFileName[4] == TEXT('C')) || (szFileName[4] == TEXT('H'))) ||
        ((szFileName[4] == TEXT('c')) || (szFileName[4] == TEXT('h')))) {
        // then it's the correct format so change the 4th letter up 1 letter
        szFileName[4] += 1;
        // and make a new path
        _tmakepath (szUpgradeFileName, 
            (LPCTSTR)szDrive, 
            (LPCTSTR)szDir, 
            (LPCTSTR)szFileName, 
            (LPCTSTR)szExt);
        bReturn = TRUE;
    } else {
        // bogus name so return false
    }
    return bReturn;
}

BOOL
GetFilesFromCommandLine (
    IN LPTSTR   lpCommandLine,
#ifdef FE_SB
    OUT UINT    *puCodePage,
#endif
    OUT LPTSTR  *lpFileNameI,
    OUT LPTSTR  *lpFileNameD
)
/*++

GetFilesFromCommandLine

    parses the command line to retrieve the ini filename that should be
    the first and only argument.

Arguments

    lpCommandLine   pointer to command line (returned by GetCommandLine)
    lpFileNameI     pointer to buffer that will receive address of the
                        validated input filename entered on the command line
    lpFileNameD     pointer to buffer that will receive address of the
                        optional output filename entered on the command line

Return Value

    TRUE if a valid filename was returned
    FALSE if the filename is not valid or missing
            error is returned in GetLastError

--*/
{
    INT     iNumArgs;

    HFILE   hIniFile;
    OFSTRUCT    ofIniFile;

    LPSTR   lpIniFileName = NULL;
    LPTSTR  lpExeName = NULL;
    LPTSTR  lpIniName = NULL;

    // check for valid arguments

    if (lpCommandLine == NULL) return (FALSE);
    if (*lpFileNameI == NULL) return (FALSE);
    if (*lpFileNameD == NULL) return (FALSE);

    // allocate memory for parsing operation

    lpExeName = ALLOCMEM (FILE_NAME_BUFFER_SIZE * sizeof(TCHAR));
    lpIniName = ALLOCMEM (FILE_NAME_BUFFER_SIZE * sizeof(TCHAR));
    lpIniFileName = ALLOCMEM (FILE_NAME_BUFFER_SIZE);

    if ((lpExeName == NULL) ||
	 (lpIniFileName == NULL) ||
	 (lpIniName == NULL)) {
        if (lpExeName) FREEMEM (lpExeName);
        if (lpIniFileName) FREEMEM (lpIniFileName);
        if (lpIniName) FREEMEM (lpIniName);
        return FALSE;
    } else {
        // get strings from command line

#ifdef FE_SB
        iNumArgs = _stscanf (lpCommandLine, (LPCTSTR)TEXT(" %s %d %s %s "), lpExeName, puCodePage, lpIniName, *lpFileNameD);
#else
        iNumArgs = _stscanf (lpCommandLine, (LPCTSTR)TEXT(" %s %s %s "), lpExeName, lpIniName, *lpFileNameD);
#endif

#ifdef FE_SB
        if (iNumArgs < 3 || iNumArgs > 4) {
#else
        if (iNumArgs < 2 || iNumArgs > 3) {
#endif
            // wrong number of arguments
            FREEMEM (lpExeName);
            FREEMEM (lpIniFileName);
            FREEMEM (lpIniName);
            return FALSE;
        } else {
            // see if file specified exists
            // file name is always an ANSI buffer
            wcstombs (lpIniFileName, lpIniName, lstrlenW(lpIniName)+1);
            FREEMEM (lpIniName);
            FREEMEM (lpExeName);
            hIniFile = OpenFile (lpIniFileName,
                &ofIniFile,
                OF_PARSE);

            if (hIniFile != HFILE_ERROR) {
                hIniFile = OpenFile (lpIniFileName,
                    &ofIniFile,
                    OF_EXIST);

                if ((hIniFile && hIniFile != HFILE_ERROR) ||
                    (GetLastError() == ERROR_FILE_EXISTS)) {
                    // file exists, so return name and success
                    // return full pathname if found
                    mbstowcs (*lpFileNameI, ofIniFile.szPathName, lstrlenA(ofIniFile.szPathName)+1);
                    FREEMEM (lpIniFileName);
                    return TRUE;
                } else {
                    // filename was on command line, but not valid so return
                    // false, but send name back for error message
                    mbstowcs (*lpFileNameI, lpIniFileName, lstrlenA(lpIniFileName)+1);
                    FREEMEM (lpIniFileName);
                    return FALSE;
                }
            } else {
                FREEMEM (lpIniFileName);
                return FALSE;
            }
        }
    }
}

BOOL  VerifyIniData(
    IN PVOID  pValueBuffer,
    IN ULONG  ValueLength
)
/*++

VerifyIniData
   This routine does some simple check to see if the ini file is good.
   Basically, it is looking for (ID, Text) and checking that ID is an
   integer.   Mostly in case of missing comma or quote, the ID will be
   an invalid integer.

--*/
{
    INT     iNumArg;
    INT     TextID;
    LPTSTR  lpID = NULL;
    LPTSTR  lpText = NULL;
    LPTSTR  lpLastID;
    LPTSTR  lpLastText;
    LPTSTR  lpInputBuffer = (LPTSTR) pValueBuffer;
    LPTSTR  lpBeginBuffer = (LPTSTR) pValueBuffer;
    BOOL    returnCode = TRUE;
    UINT    NumOfID = 0;
    ULONG   CurrentLength;

#pragma warning ( disable : 4127 )
    while (TRUE) {

        // save up the last items for summary display later
        lpLastID = lpID;
        lpLastText = lpText;

        // increment to next ID and text location
        lpID = lpInputBuffer;
        CurrentLength = (ULONG)((PBYTE)lpID - (PBYTE)lpBeginBuffer + sizeof(WCHAR));

        if (CurrentLength >= ValueLength)
            break;

        try {
            lpText = lpID + lstrlen (lpID) + 1;

            lpInputBuffer = lpText + lstrlen (lpText) + 1;

            iNumArg = _stscanf (lpID, (LPCTSTR)TEXT("%d"), &TextID);
        }
        except (TRUE) {
            iNumArg = -1;
        }

        if (iNumArg != 1) {
            // bad ID
            returnCode = FALSE;
            break ;
        }
        NumOfID++;
    }
#pragma warning ( default : 4127 )

    if (returnCode == FALSE) {
       DisplaySummaryError (lpLastID, lpLastText, NumOfID);
    }
    else {
       DisplaySummary (lpLastID, lpLastText, NumOfID);
    }
    return (returnCode);
}


__cdecl main(
//    int argc,
//    char *argv[]
)
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpCommandLine;
    LPTSTR  lpIniFile;
    LPTSTR  lpDatFile;
    UNICODE_STRING IniFileName;
    PVOID   pValueBuffer;
    ULONG   ValueLength;
    BOOL    bStatus;
    NTSTATUS   NtStatus;
#if 0
    // part of bogus filename change code
    LPTSTR      pchar ;
    INT         npos;   
    TCHAR       ch = TEXT('f');
#endif
#ifdef FE_SB
    UINT    uCodePage=CP_ACP;
#endif

    lpIniFile = ALLOCMEM (MAX_PATH * sizeof (TCHAR));
    lpDatFile = ALLOCMEM (MAX_PATH * sizeof (TCHAR));
    if (lpIniFile == NULL) return ERROR_OUTOFMEMORY;
    if (lpDatFile == NULL) return ERROR_OUTOFMEMORY;
    lstrcpy(lpDatFile, (LPCTSTR)TEXT("\0"));

    lpCommandLine = GetCommandLine(); // get command line
    if (lpCommandLine == NULL) {
        NtStatus = GetLastError();
        FREEMEM (lpIniFile);
        FREEMEM (lpDatFile);
        return NtStatus;
    }

    // read command line to determine what to do

#ifdef FE_SB  // FE_SB
    if (GetFilesFromCommandLine (lpCommandLine, &uCodePage, &lpIniFile, &lpDatFile)) {

        if (!IsValidCodePage(uCodePage)) {
            uCodePage = CP_ACP;
        }
#else
    if (GetFilesFromCommandLine (lpCommandLine, &lpIniFile, &lpDatFile)) {
#endif // FE_SB



        // valid filename (i.e. ini file exists)
        IniFileName.Buffer = lpIniFile;
        IniFileName.MaximumLength = 
        IniFileName.Length = (WORD)((lstrlen (lpIniFile) + 1 ) * sizeof(WCHAR)) ;
#ifdef FE_SB
        bStatus = DatReadMultiSzFile (uCodePage, &IniFileName,
#else
        bStatus = DatReadMultiSzFile (&IniFileName,
#endif
            &pValueBuffer,
            &ValueLength);

        if (bStatus) {
            bStatus = VerifyIniData (pValueBuffer, ValueLength);
            if (bStatus) {
                bStatus = OutputIniData (&IniFileName,
                    lpDatFile,
                    pValueBuffer,
                    ValueLength);
#if 0
                // this is a really bogus way to find "PERF" in the 
                // filename string

                //Add the new file that'll be used in upgrade
                // find the last "F" in the file name by reversing
                // the string, finding the first "F"
                // then go to the previous character and incrementing
                // it. Finally reverse the characters in the file name
                // returning it to the correct order.
                //
                // this creates the "upgrade" file with a slightly different
                // filename that is used by Lodctr to insert the new system 
                // strings into the existing list of system strings.
                //
                _tcsrev(lpDatFile);
                pchar = _tcschr(lpDatFile,ch);
                npos = (INT)(pchar - lpDatFile) - 1;
                lpDatFile[npos]  = (TCHAR)((lpDatFile[npos]) + 1);
                _tcsrev(lpDatFile);
#else
                bStatus = MakeUpgradeFilename (
                    lpDatFile, lpDatFile);

#endif
                if (bStatus) {
                    bStatus = OutputIniData (&IniFileName,
                        lpDatFile,
                        pValueBuffer,
                        ValueLength);
                }
            }
        }
    } else {
        if (*lpIniFile) {
            printf (GetFormatResource(LC_NO_INIFILE), lpIniFile);
        } else {
            //Incorrect Command Format
            // display command line usage
            DisplayCommandHelp(LC_FIRST_CMD_HELP, LC_LAST_CMD_HELP);
        }
    }


    if (lpIniFile) FREEMEM (lpIniFile);
    if (lpDatFile) FREEMEM (lpDatFile);

    return (ERROR_SUCCESS); // success
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\initodat\initodat.h ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    initodat.h

Abstract:

    This is the include file for the ini to data file conversion functions.

Author:

    HonWah Chan (a-honwah)  October, 1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
// #include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tchar.h>


#define VALUE_BUFFER_SIZE (4096 * 100)


typedef struct _REG_UNICODE_FILE {
    LARGE_INTEGER LastWriteTime;
    PWSTR FileContents;
    PWSTR EndOfFile;
    PWSTR BeginLine;
    PWSTR EndOfLine;
    PWSTR NextLine;
} REG_UNICODE_FILE, *PREG_UNICODE_FILE;

NTSTATUS
DatReadMultiSzFile(
#if FE_SB
    UINT uCodePage,
#endif
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    );

NTSTATUS
DatLoadAsciiFileAsUnicode(
#if FE_SB
    UINT uCodePage,
#endif
    IN PUNICODE_STRING FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    );


BOOLEAN
DatGetMultiString(
    IN OUT PUNICODE_STRING ValueString,
    OUT PUNICODE_STRING MultiString
    );


BOOL
OutputIniData (
    IN PUNICODE_STRING FileName,
    IN LPTSTR OutFileCandidate,
    IN PVOID  pValueBuffer,
    IN ULONG  ValueLength
   );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\initodat\strids.h ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    strids.h

Abstract:

    This is the include file for the strings ids use in initodat.exe

Author:

    HonWah Chan (a-honwah)  October, 1993

Revision History:

--*/

// strings defines for Help
#define  LC_CMD_HELP_1     100
#define  LC_CMD_HELP_2     101
#define  LC_CMD_HELP_3     102
#define  LC_CMD_HELP_4     103
#define  LC_CMD_HELP_5     104
#define  LC_CMD_HELP_6     105
#define  LC_CMD_HELP_7     106
#define  LC_CMD_HELP_8     107
#define  LC_CMD_HELP_9     108
#define  LC_CMD_HELP_10    109
#define  LC_CMD_HELP_11    110
#define  LC_CMD_HELP_12    111
#define  LC_CMD_HELP_13    112

#define  LC_FIRST_CMD_HELP 100
#define  LC_LAST_CMD_HELP  112


// strings defines for error

#define  LC_NO_INIFILE     202
#define  LC_SUMMARY        203
#define  LC_NUM_OF_ID      204
#define  LC_LAST_ID        205
#define  LC_LAST_TEXT      206
#define  LC_BAD_ID         207
#define  LC_MISSING_DEL    208
#define  LC_CANT_CREATE    209
#define  LC_CANT_WRITE     210
#define  LC_ACCESS_DENIED  211
#define  LC_DISK_FULL      212
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\initodat\fileutl.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    fileutl.c

Abstract:

    Routines for getting data from ini file

Author:

    HonWah Chan (a-honwah)  October, 1993

Revision History:

--*/

#include "initodat.h"
#include "strids.h"
#include "common.h"
#include "winerror.h"

NTSTATUS
DatReadMultiSzFile(
#ifdef FE_SB
    IN UINT uCodePage,
#endif
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    PWSTR s;
    UNICODE_STRING MultiSource;
    UNICODE_STRING MultiValue;
    REG_UNICODE_FILE MultiSzFile;
    ULONG MultiSzFileSize;

    if (ValueBuffer == NULL || ValueLength == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    FileName->Buffer[ FileName->Length/sizeof(WCHAR) ] = UNICODE_NULL;

    RtlDosPathNameToNtPathName_U( FileName->Buffer,
                                  &NtFileName,
                                  NULL,
                                  NULL );

    #ifdef FE_SB
    Status = DatLoadAsciiFileAsUnicode( uCodePage, &NtFileName,  &MultiSzFile );
    #else
    Status = DatLoadAsciiFileAsUnicode( &NtFileName, &MultiSzFile );
    #endif

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    MultiSzFileSize = (ULONG)(MultiSzFile.EndOfFile -
                       MultiSzFile.NextLine) * sizeof(WCHAR);

    *ValueLength = 0;
    *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                    MultiSzFileSize);
    if (* ValueBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    MultiSource.Buffer = MultiSzFile.NextLine;
    if (MultiSzFileSize <= MAXUSHORT) {
        MultiSource.Length =
        MultiSource.MaximumLength = (USHORT)MultiSzFileSize;
    } else {
        MultiSource.Length =
        MultiSource.MaximumLength = MAXUSHORT;
    }

    while (DatGetMultiString(&MultiSource, &MultiValue)) {
        RtlMoveMemory( (PUCHAR)*ValueBuffer + *ValueLength,
                       MultiValue.Buffer,
                       MultiValue.Length );
        *ValueLength += MultiValue.Length;

        s = MultiSource.Buffer;
        while ( *s != L'"' &&
                *s != L',' &&
                ((s - MultiSource.Buffer) * sizeof(WCHAR)) <
                    MultiSource.Length ) s++;
        if ( ((s - MultiSource.Buffer) * sizeof(WCHAR)) ==
             MultiSource.Length ||
             *s == L',' ||
             *s == L';'   ) {

            ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] =
                UNICODE_NULL;
            *ValueLength += sizeof(UNICODE_NULL);
            if ( *s ==  L';' ) {
                break;
            }
        }

        if ( (MultiSzFile.EndOfFile - MultiSource.Buffer) * sizeof(WCHAR) >=
              MAXUSHORT ) {
            MultiSource.Length =
            MultiSource.MaximumLength = MAXUSHORT;
        } else {
            MultiSource.Length =
            MultiSource.MaximumLength =
                (USHORT)((MultiSzFile.EndOfFile - MultiSource.Buffer) *
                         sizeof(WCHAR));
        }
    }

    ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] = UNICODE_NULL;
    *ValueLength += sizeof(UNICODE_NULL);

    // Virtual memory for reading of MultiSzFile freed at process
    // death?

    return( TRUE );
}

NTSTATUS
DatLoadAsciiFileAsUnicode(
#ifdef FE_SB
    IN UINT uCodePage,
#endif
    IN PUNICODE_STRING FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE File;
    FILE_BASIC_INFORMATION FileDateTimeInfo;
    FILE_STANDARD_INFORMATION FileInformation;
    SIZE_T BufferSize;
    ULONG i, i1, LineCount;
    PVOID BufferBase;
    PCHAR Src = NULL;
    PCHAR Src1;
    PWSTR Dst = NULL;

    memset (&FileDateTimeInfo, 0, sizeof(FileDateTimeInfo));

    InitializeObjectAttributes( &ObjectAttributes,
                                FileName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL
                              );

    Status = NtOpenFile( &File,
                         SYNCHRONIZE | GENERIC_READ,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_DELETE |
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = NtQueryInformationFile( File,
                                     &IoStatus,
                                     (PVOID)&FileInformation,
                                     sizeof( FileInformation ),
                                     FileStandardInformation
                                   );
    if (NT_SUCCESS( Status )) {
        if (FileInformation.EndOfFile.HighPart) {
            Status = STATUS_BUFFER_OVERFLOW;
            }
        }
    if (!NT_SUCCESS( Status )) {
        NtClose( File );
        return( Status );
        }

#ifdef FE_SB
    BufferSize = FileInformation.EndOfFile.LowPart * sizeof( WCHAR ) * 2;
#else
    BufferSize = FileInformation.EndOfFile.LowPart * sizeof( WCHAR );
#endif

    BufferSize += sizeof( UNICODE_NULL );
    BufferBase = NULL;
    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      (PVOID *)&BufferBase,
                                      0,
                                      &BufferSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if (NT_SUCCESS( Status )) {
        Src = (PCHAR)BufferBase + ((FileInformation.EndOfFile.LowPart+1) & ~1);
        Dst = (PWSTR)BufferBase;
        Status = NtReadFile( File,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             Src,
                             FileInformation.EndOfFile.LowPart,
                             NULL,
                             NULL
                           );

        if (NT_SUCCESS( Status )) {
            Status = IoStatus.Status;

            if (NT_SUCCESS( Status )) {
                if (IoStatus.Information != FileInformation.EndOfFile.LowPart) {
                    Status = STATUS_END_OF_FILE;
                    }
                else {
                    Status = NtQueryInformationFile( File,
                                                     &IoStatus,
                                                     (PVOID)&FileDateTimeInfo,
                                                     sizeof( FileDateTimeInfo ),
                                                     FileBasicInformation
                                                   );
                    }
                }
            }

        if (!NT_SUCCESS( Status )) {
            NtFreeVirtualMemory( NtCurrentProcess(),
                                 (PVOID *)&BufferBase,
                                 &BufferSize,
                                 MEM_RELEASE
                               );
            }
        }

    NtClose( File );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    i = 0;
    while (i < FileInformation.EndOfFile.LowPart) {

        if (i > 1 && (Src[-2] == ' ' || Src[-2] == '\t') &&
            Src[-1] == '\\' && (*Src == '\r' || *Src == '\n')
           ) {
            if (Dst[-1] == L'\\') {
                --Dst;
                }
            while (Dst > (PWSTR)BufferBase) {
                if (Dst[-1] > L' ') {
                    break;
                    }
                Dst--;
                }
            LineCount = 0;
            while (i < FileInformation.EndOfFile.LowPart) {
                if (*Src == '\n') {
                    i++;
                    Src++;
                    LineCount++;
                    }
                else
                if (*Src == '\r' &&
                    (i+1) < FileInformation.EndOfFile.LowPart &&
                    Src[ 1 ] == '\n'
                   ) {
                    i += 2;
                    Src += 2;
                    LineCount++;
                    }
                else {
                    break;
                    }
                }

            if (LineCount > 1) {
                *Dst++ = L'\n';
                }
            else {
                *Dst++ = L' ';
                while (i < FileInformation.EndOfFile.LowPart && (*Src == ' ' || *Src == '\t')) {
                    i++;
                    Src++;
                    }
                }

            if (i >= FileInformation.EndOfFile.LowPart) {
                break;
                }
            }
        else
        if ((*Src == '\r' && Src[1] == '\n') || *Src == '\n') {
#pragma warning ( disable : 4127 )
            while (TRUE) {
                while (i < FileInformation.EndOfFile.LowPart && (*Src == '\r' || *Src == '\n')) {
                    i++;
                    Src++;
                    }
                Src1 = Src;
                i1 = i;
                while (i1 < FileInformation.EndOfFile.LowPart && (*Src1 == ' ' || *Src1 == '\t')) {
                    i1++;
                    Src1++;
                    }
                if (i1 < FileInformation.EndOfFile.LowPart &&
                    (*Src1 == '\r' && Src1[1] == '\n') || *Src1 == '\n'
                   ) {
                    Src = Src1;
                    i = i1;
                    }
                else {
                    break;
                    }
                }
#pragma warning ( default : 4127 )

            *Dst++ = L'\n';
            }
        else {
#ifdef FE_SB
            WCHAR UnicodeCharacter;
            LONG cbCharSize = IsDBCSLeadByteEx(uCodePage,*Src) ? 2 : 1;

            if ( MultiByteToWideChar(
                     uCodePage,
                     0,
                     Src,
                     cbCharSize,
                     &UnicodeCharacter,
                     1) == 0) {
                //
                // Check for error - The only time this will happen is if there is
                // a leadbyte without a trail byte.
                //
                UnicodeCharacter = 0x0020;
            }
            i += cbCharSize;
            Src += cbCharSize;
            *Dst++ = UnicodeCharacter;
#else
            i++;
            *Dst++ = RtlAnsiCharToUnicodeChar( &Src );
#endif
            }
        }

    if (NT_SUCCESS( Status )) {
        *Dst = UNICODE_NULL;
        UnicodeFile->FileContents = BufferBase;
        UnicodeFile->EndOfFile = Dst;
        UnicodeFile->BeginLine = NULL;
        UnicodeFile->EndOfLine = NULL;
        UnicodeFile->NextLine = BufferBase;
        UnicodeFile->LastWriteTime = FileDateTimeInfo.LastWriteTime;
        }
    else {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             (PVOID *)&BufferBase,
                             &BufferSize,
                             MEM_RELEASE
                           );
        }

    return( Status );
}

//
//  Define an upcase macro for temporary use by the upcase routines
//

#define upcase(C) (WCHAR )(((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C)))

BOOLEAN
DatGetMultiString(
    IN OUT PUNICODE_STRING ValueString,
    OUT PUNICODE_STRING MultiString
    )

/*++

Routine Description:

    This routine parses multi-strings of the form

        "foo" "bar" "bletch"

    Each time it is called, it strips the first string in quotes from
    the input string, and returns it as the multi-string.

    INPUT ValueString: "foo" "bar" "bletch"

    OUTPUT ValueString: "bar" "bletch"
           MultiString: foo

Arguments:

    ValueString - Supplies the string from which the multi-string will be
                  parsed
                - Returns the remaining string after the multi-string is
                  removed

    MultiString - Returns the multi-string removed from ValueString

Return Value:

    TRUE - multi-string found and removed.

    FALSE - no more multi-strings remaining.

--*/

{
    //
    // Find the first quote mark.
    //
    while ((*(ValueString->Buffer) != L'"') &&
           (ValueString->Length > 0)) {
        ++ValueString->Buffer;
        ValueString->Length -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        return(FALSE);
    }

    //
    // We have found the start of the multi-string.  Now find the end,
    // building up our return MultiString as we go.
    //
    ++ValueString->Buffer;
    ValueString->Length -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);
    MultiString->Buffer = ValueString->Buffer;
    MultiString->Length = 0;
    MultiString->MaximumLength = 0;
    while ((*(ValueString->Buffer) != L'"') &&
           (ValueString->Length > 0)) {
        ++ValueString->Buffer;
        ValueString->Length -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);

        MultiString->Length += sizeof(WCHAR);
        MultiString->MaximumLength += sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        return(FALSE);
    }

    ++ValueString->Buffer;
    ValueString->Length -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);

    return( TRUE );

}

#define EXTENSION_DELIMITER      TEXT('.')
LPTSTR
FindFileExtension (
    IN PUNICODE_STRING FileName
)
{
   LPTSTR          lpszDelimiter ;

   lpszDelimiter = _tcsrchr ((LPCTSTR)FileName->Buffer, (TCHAR)EXTENSION_DELIMITER) ;

   if (lpszDelimiter)
      return lpszDelimiter;
   else
      return (LPTSTR)((PBYTE)FileName->Buffer + FileName->Length - sizeof(WCHAR));
}

BOOL
OutputIniData (
    IN PUNICODE_STRING FileName,
    IN LPTSTR OutFileCandidate,
    IN PVOID  pValueBuffer,
    IN ULONG  ValueLength
   )
{
    HANDLE   hOutFile = NULL;
    LPTSTR   lpExtension = NULL;
    DWORD    nAmtWritten ;
    BOOL     bSuccess ;
    DWORD    ErrorCode ;

    // If output file not specified, derive from input file name

    if (! lstrcmp(OutFileCandidate, (LPCWSTR)L"\0")) {
        lpExtension = FindFileExtension (FileName);
        lstrcpy (lpExtension, (LPCTSTR)TEXT(".dat"));
        lstrcpy (OutFileCandidate, FileName->Buffer);
    }

   hOutFile = (HANDLE) CreateFile (
      OutFileCandidate,
      GENERIC_READ | GENERIC_WRITE,
      FILE_SHARE_READ,
      NULL, CREATE_ALWAYS,
      FILE_ATTRIBUTE_NORMAL, NULL);

   if ((hOutFile == NULL) || (hOutFile == INVALID_HANDLE_VALUE)) {
      ErrorCode = GetLastError();
      printf (GetFormatResource(LC_CANT_CREATE), ErrorCode);
      if (ErrorCode == ERROR_ACCESS_DENIED)
         printf ("%ws\n", GetStringResource(LC_ACCESS_DENIED));
      return FALSE;
      }

   bSuccess = WriteFile (
      hOutFile,
      pValueBuffer,
      ValueLength,
      &nAmtWritten,
      NULL) ;

   bSuccess = bSuccess && (nAmtWritten == ValueLength) ;

   CloseHandle( hOutFile );

   if (!bSuccess) {
      ErrorCode = GetLastError();
      printf (GetFormatResource(LC_CANT_WRITE), ErrorCode);
      if (ErrorCode == ERROR_DISK_FULL)
         printf ("%ws\n", GetStringResource(LC_DISK_FULL));
      }

   return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\lodctr\lodctr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lodctr.c

Abstract:

    Program to read the contents of the file specified in the command line
        and update the registry accordingly

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

    a-robw  25-Feb-93   revised calls to make it compile as a UNICODE or
                        an ANSI app.

    a-robw  10-Nov-95   revised to use DLL functions for all the dirty work

    // command line arguments supported:

    /C:<filename>   upgrade counter text strings using <filename>
    /H:<filename>   upgrade help text strings using <filename>
    /L:<LangID>     /C and /H params are for language <LangID>

    /S:<filename>   save current perf registry strings & info to <filname>
    /R:<filename>   restore perf registry strings & info using <filname>

    /T:<service>    set <service> to be Trusted using current DLL 

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  Windows Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>

#include <loadperf.h>
#include "..\common\common.h"

static CHAR szFileNameBuffer[MAX_PATH*2];

static
LPCSTR
GetTrustedServiceName (
    LPCSTR  szArg1
)
{
    LPSTR   szReturn = NULL;

    if ((szArg1[0] == '-') || (szArg1[0] == '/')) {
        //it's a switch command
        if ((szArg1[1] == 't') || (szArg1[1] == 'T')) {
            // the command is to Save the configuration to a file
            if (szArg1[2] == ':') {
                // then the rest of the string is the name of the trusted service
                szReturn = (LPSTR)&szArg1[3];
            }
        }
    }
    return (LPCSTR)szReturn;
}
static
BOOL
GetUpgradeFileNames (
    LPCSTR  *szArgs,
    LPSTR   *szCounterFile,
    LPSTR   *szHelpFile,
    LPSTR   *szLangId
)
{
    DWORD   dwArgIdx = 1;
    DWORD   dwMask = 0;

    do {
        // check first arg, function assumes there are 2 args or more
        if ((szArgs[dwArgIdx][0] == '-') || (szArgs[dwArgIdx][0] == '/')) {
            //it's a switch command
            if ((szArgs[dwArgIdx][1] == 'c') || (szArgs[dwArgIdx ][1] == 'C')) {
                // the command is to load a service
                if (szArgs[dwArgIdx ][2] == ':') {
                    // then the rest of the string is the service name
                    *szCounterFile = (LPSTR)&szArgs[dwArgIdx ][3];
                    dwMask |= 1;
                }
            } else if ((szArgs[dwArgIdx][1] == 'h') || (szArgs[dwArgIdx ][1] == 'H')) {
                // the command is to load a service
                if (szArgs[dwArgIdx][2] == ':') {
                    // then the rest of the string is the service name
                    *szHelpFile = (LPSTR)&szArgs[dwArgIdx ][3];
                    dwMask |= 2;
                }
            } else if ((szArgs[dwArgIdx][1] == 'l') || (szArgs[dwArgIdx ][1] == 'L')) {
                // the command is to load a service
                if (szArgs[dwArgIdx][2] == ':') {
                    // then the rest of the string is the service name
                    *szLangId = (LPSTR)&szArgs[dwArgIdx ][3];
                    dwMask |= 4;
                }
            }
        }
        dwArgIdx++;
    } while (dwArgIdx <= 3);

    if (dwMask == 7) {
        // all names found
        return TRUE;
    } else {
        return FALSE;
    }
}

static
LPCSTR
GetSaveFileName (
    LPCSTR  szArg1
)
{
    LPSTR   szReturn = NULL;
    DWORD   dwSize;

    if ((szArg1[0] == '-') || (szArg1[0] == '/')) {
        //it's a switch command
        if ((szArg1[1] == 's') || (szArg1[1] == 'S')) {
            // the command is to Save the configuration to a file
            if (szArg1[2] == ':') {
                // then the rest of the string is the input file name
                dwSize = SearchPathA (NULL, (LPSTR)&szArg1[3], NULL, 
                    sizeof(szFileNameBuffer)/sizeof(szFileNameBuffer[0]),
                    szFileNameBuffer, NULL);
                if (dwSize == 0) {
                    //unable to find file in path so use it as is
                    szReturn = (LPSTR)&szArg1[3];
                } else {
                    // else return the expanded file name
                    szReturn = szFileNameBuffer;
                }
            }
        }
    }
    return (LPCSTR)szReturn;
}
static
LPCSTR
GetRestoreFileName (
    LPCSTR  szArg1  
)
{
    LPSTR   szReturn = NULL;
    DWORD   dwSize;

    if ((szArg1[0] == '-') || (szArg1[0] == '/')) {
        //it's a switch command
        if ((szArg1[1] == 'r') || (szArg1[1] == 'R')) {
            // the command is to Save the configuration to a file
            if (szArg1[2] == ':') {
                // then the rest of the string is the input file name
                dwSize = SearchPathA (NULL, (LPSTR)&szArg1[3], NULL, 
                    sizeof(szFileNameBuffer)/sizeof(szFileNameBuffer[0]),
                    szFileNameBuffer, NULL);
                if (dwSize == 0) {
                    //unable to find file in path so use it as is
                    szReturn = (LPSTR)&szArg1[3];
                } else {
                    // else return the expanded file name
                    szReturn = szFileNameBuffer;
                }
            }
        }
    }
    return (LPCSTR)szReturn;
}

int
__cdecl main(
    int argc,
    char *argv[]
)
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpCommandLine;
    LPSTR   szCmdArgFileName;
    LPWSTR  wszFileName;
    DWORD   dwFileNameLen;
    int     nReturn;

    lpCommandLine = GetCommandLine(); // get command line

    // check for a service name in the command line

    if (argc >= 2) {
        if (argc >= 4) {
            BOOL    bDoUpdate;
            LPSTR   szCounterFile = NULL;
            LPSTR   szHelpFile = NULL;
            LPSTR   szLanguageID = NULL;

            bDoUpdate = GetUpgradeFileNames (
                argv,
                &szCounterFile,
                &szHelpFile,
                &szLanguageID);

            if (bDoUpdate) {
                return (int) UpdatePerfNameFilesA (
	                szCounterFile, 
	                szHelpFile, 
                    szLanguageID,
                    0);

            }
        } else {    
            // then there's a param to check
            szCmdArgFileName = (LPSTR)GetSaveFileName (argv[1]);
            if (szCmdArgFileName != NULL) {
                dwFileNameLen = lstrlenA(szCmdArgFileName) + 1;
                wszFileName = HeapAlloc (GetProcessHeap(), 0, (dwFileNameLen) * sizeof (WCHAR));
                if (wszFileName != NULL) {
                    mbstowcs (wszFileName, szCmdArgFileName, dwFileNameLen);
                    nReturn = (int)BackupPerfRegistryToFileW (
                            (LPCWSTR)wszFileName,
                            (LPCWSTR)L"");
                    HeapFree (GetProcessHeap(), 0, wszFileName);
                    return nReturn;
                }
            } 

            // try Restore file name
            szCmdArgFileName = (LPSTR)GetRestoreFileName (argv[1]);
            if (szCmdArgFileName != NULL) {
                dwFileNameLen = lstrlenA(szCmdArgFileName) + 1;
                wszFileName = HeapAlloc (GetProcessHeap(), 0, (dwFileNameLen) * sizeof (WCHAR));
                if (wszFileName != NULL) {
                    mbstowcs (wszFileName, szCmdArgFileName, dwFileNameLen);
                    nReturn = (int)RestorePerfRegistryFromFileW(
                            (LPCWSTR) wszFileName,
                            NULL);
                    HeapFree (GetProcessHeap(), 0, wszFileName);
                    return nReturn;
                }
            }

            // try Trusted service name
            szCmdArgFileName = (LPSTR)GetTrustedServiceName (argv[1]);
            if (szCmdArgFileName != NULL) {
                dwFileNameLen = lstrlenA(szCmdArgFileName) + 1;
                wszFileName = HeapAlloc (GetProcessHeap(), 0, (dwFileNameLen) * sizeof (WCHAR));
                if (wszFileName != NULL) {
                    mbstowcs (wszFileName, szCmdArgFileName, dwFileNameLen);
                    nReturn = (int)SetServiceAsTrusted  (NULL,
                            (LPCWSTR)wszFileName);  // filename is really the service name
                    HeapFree (GetProcessHeap(), 0, wszFileName);
                    return nReturn;
                }
            }
        }
    }
    // if here then load the registry from an ini file
    return (int) LoadPerfCounterTextStrings (
        lpCommandLine,
        FALSE);     // show text strings to console
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETPATH=obj
TARGETNAME=NOTARGET
TARGETTYPE=NOTARGET
SOURCES=
SOURCES_USED=..\sources.inc

#
#   define _LANGCODE to be the primary language id in hex
#
#   usa = 009
#

!if "$(ALT_PROJECT)"=="."
_LANGCODE=009
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="ARA"
_LANGCODE=001
CODEPAGE=1256
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="CHS"
_LANGCODE=0804
CODEPAGE=936
_PERFNAME=prf
!elseif "$(ALT_PROJECT)"=="CHT"
_LANGCODE=0404
CODEPAGE=950
_PERFNAME=prf
!elseif "$(ALT_PROJECT)"=="GER"
_LANGCODE=007
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="HEB"
_LANGCODE=00D
CODEPAGE=1255
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="JPN"
_LANGCODE=011
CODEPAGE=932
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="KOR"
_LANGCODE=012
CODEPAGE=949
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="br"
_LANGCODE=016
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="cs"
_LANGCODE=005
CODEPAGE=1250
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="da"
_LANGCODE=006
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="el"
_LANGCODE=008
CODEPAGE=1253
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="es"
_LANGCODE=00a
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="fi"
_LANGCODE=00b
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="fr"
_LANGCODE=00c
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="hu"
_LANGCODE=00e
CODEPAGE=1250
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="it"
_LANGCODE=010
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="nl"
_LANGCODE=013
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="no"
_LANGCODE=014
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="pl"
_LANGCODE=015
CODEPAGE=1250
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="psu"
_LANGCODE=01f
CODEPAGE=1253
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="pt"
_LANGCODE=016
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="ru"
_LANGCODE=019
CODEPAGE=1251
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="sv"
_LANGCODE=01d
CODEPAGE=1252
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="tr"
_LANGCODE=01f
CODEPAGE=1254
_PERFNAME=perf
!elseif "$(ALT_PROJECT)"=="TST"
_LANGCODE=009
CODEPAGE=1252
_PERFNAME=perf
!endif

PERFCINI=$(_PERFNAME)c$(_LANGCODE).ini
PERFHINI=$(_PERFNAME)h$(_LANGCODE).ini

NTTARGETFILES=

MISCFILES= \
        $(O)\$(_PERFNAME)c$(_LANGCODE).dat \
        $(O)\$(_PERFNAME)d$(_LANGCODE).dat \
        $(O)\$(_PERFNAME)h$(_LANGCODE).dat \
        $(O)\$(_PERFNAME)i$(_LANGCODE).dat
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\ara\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\chs\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\cht\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\br\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\cs\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\da\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\el\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\es\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\fi\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\fr\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\ger\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\heb\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\hu\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\it\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\jpn\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\kor\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\nl\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\no\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\pl\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\psu\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\pt\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\ru\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\sv\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\tr\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\tst\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\perfini\usa\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\maindlg.h ===
INT_PTR
MainDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\mainwnd.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mainwnd.c

Abstract:

    Main Window procedure for ShowPerf app

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <tchar.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <string.h>
#include    "resource.h"
#include    "SHOWPERF.h"
#include    "mainwnd.h"
#include    "maindlg.h"

//
//  GLOBAL functions
//
LRESULT CALLBACK
MainWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    Windows Message processing routine for restkeys application.

Arguments:

    Standard WNDPROC api arguments

ReturnValue:

    0   or
    value returned by DefWindowProc

--*/
{
    switch (message) {
        case WM_CLOSE:
            DestroyWindow (hWnd);
            return ERROR_SUCCESS;

        case WM_DESTROY:
            PostQuitMessage (ERROR_SUCCESS);
            return ERROR_SUCCESS;

        default:
        	return (DefWindowProc(hWnd, message, wParam, lParam));
    }
}

BOOL
RegisterMainWindowClass (
    IN  HINSTANCE   hInstance
)
/*++

Routine Description:

    Registers the main window class for this application

Arguments:

    hInstance   application instance handle

Return Value:

    Return value of RegisterClass function

--*/
{
    WNDCLASS    wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;   // Window Procedure
    wc.cbClsExtra    = 0;                      // No per-class extra data.
    wc.cbWndExtra    = 0;                      // no extra data bytes.
    wc.hInstance     = hInstance;              // Owner of this class
    wc.hIcon         = NULL;                   // No Icon
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);     // Cursor
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);        // Default color
    wc.lpszMenuName  = NULL;                            // No Menu
    wc.lpszClassName = GetStringResource(hInstance, IDS_APP_WINDOW_CLASS); // Name to register as

    // Register the window class and return success/failure code.
    return (BOOL)RegisterClass(&wc);
}

HWND
CreateMainWindow (
    IN  HINSTANCE   hInstance
)
{
    HWND        hWnd;   // return value
    RECT        rDesktop;  // desktop window
    
    GetWindowRect (GetDesktopWindow(), &rDesktop);

    // Create a main window for this application instance.

    hWnd = CreateWindowEx(
        0L,                 // make this window normal so debugger isn't covered
	    GetStringResource (hInstance, IDS_APP_WINDOW_CLASS), // See RegisterClass() call.
	    GetStringResource (hInstance, IDS_APP_TITLE), // Text for window title bar.
	    (DWORD)(WS_OVERLAPPEDWINDOW),   // Window style.
	    rDesktop.right+1,       // position window off desktop
	    rDesktop.bottom+1,
        1,
	    1,
	    (HWND)NULL,		    // Overlapped windows have no parent.
	    (HMENU)NULL,        // use class menu
	    hInstance,	        // This instance owns this window.
	    NULL                // not used
    );

    // If window could not be created, return "failure"
    if (hWnd != NULL) {
        DialogBox (hInstance,
            MAKEINTRESOURCE (IDD_MAIN),
            hWnd,
            MainDlgProc);

        PostMessage (hWnd, WM_CLOSE, 0, 0); // pack up and leave
    }
    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\maindlg.c ===
#include <windows.h>
#include <winperf.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include "showperf.h"
#include "perfdata.h"
#include "resource.h"
#include "maindlg.h"

static PPERF_DATA_BLOCK   pMainPerfData = NULL; // pointer to perfdata block
static LPWSTR             *szNameTable = NULL;   // pointer to perf name table
static DWORD              dwLastName = 0;
static TCHAR              szComputerName[MAX_COMPUTERNAME_LENGTH+3];
static TCHAR              szThisComputerName[MAX_COMPUTERNAME_LENGTH+3];
static HKEY               hKeyMachine = NULL;
static HKEY               hKeyPerformance = NULL;

#define NUM_TAB_STOPS       3
static INT nDataListTabs[NUM_TAB_STOPS] = {
        26
    ,   160
    ,   235
};

static
BOOL
LoadObjectList (
    IN  HWND    hDlg,
    IN  LPCTSTR  szMatchItem
)
{
    PPERF_OBJECT_TYPE   pObject;
    HWND        hWndObjectCB;
    UINT        nInitial = 0;
    UINT        nIndex;
    TCHAR       szNameBuffer[MAX_PATH];
    DWORD       dwThisObject = 0;
    DWORD       dwCounterType;
    BOOL        bReturn = TRUE;

    hWndObjectCB = GetDlgItem (hDlg, IDC_OBJECT);

    if (IsDlgButtonChecked (hDlg, IDC_INCLUDE_COSTLY) == CHECKED) {
        dwCounterType = 1;
    } else {
        dwCounterType = 0;
    }

    // get current data block
    if (GetSystemPerfData (hKeyPerformance, &pMainPerfData,
        dwCounterType) == ERROR_SUCCESS) {
        // data acquired so clear combo and display
        SendMessage (hWndObjectCB, CB_RESETCONTENT, 0, 0);
        pObject = FirstObject (pMainPerfData);
        __try {
            for (dwThisObject = 0; dwThisObject < pMainPerfData->NumObjectTypes; dwThisObject++) {

                // get counter object name here...

                _stprintf (szNameBuffer, (LPCTSTR)TEXT("(%d) %s"),
                    pObject->ObjectNameTitleIndex,
                    pObject->ObjectNameTitleIndex <= dwLastName ?
                    szNameTable[pObject->ObjectNameTitleIndex] : (LPCTSTR)TEXT("Name not loaded"));

                nIndex = (UINT)SendMessage (hWndObjectCB, CB_INSERTSTRING, (WPARAM)-1,
                    (LPARAM)szNameBuffer);

                if (nIndex != CB_ERR) {
                    // save object pointer
                    SendMessage (hWndObjectCB, CB_SETITEMDATA,
                        (WPARAM)nIndex, (LPARAM)pObject);

                    if (pObject->ObjectNameTitleIndex == (DWORD)pMainPerfData->DefaultObject) {
                        // remember this index to set the default object
                        nInitial = nIndex;
                    }
                }

                pObject = NextObject(pObject);
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            _stprintf (szNameBuffer,
                (LPCTSTR)TEXT("An exception (0x%8.8x) occured in object block # %d returned by the system."),
                GetExceptionCode (), dwThisObject+1);
            MessageBox (hDlg, szNameBuffer, (LPCTSTR)TEXT("Data Error"), MB_OK);
            // update the data buffer so that only the valid objects
            // are accessed in the future.
            pMainPerfData->NumObjectTypes = dwThisObject-1;
        }
        if (szMatchItem == NULL) {
            SendMessage (hWndObjectCB, CB_SETCURSEL, (WPARAM)nInitial, 0);
        } else {
            // match to arg string as best as possible
            if (SendMessage (hWndObjectCB, CB_SELECTSTRING, (WPARAM)-1,
                (LPARAM)szMatchItem) == CB_ERR) {
                    // no match found so use default
                SendMessage (hWndObjectCB, CB_SETCURSEL, (WPARAM)nInitial, 0);
            }
        }
    } else {
        DisplayMessageBox (hDlg,
            IDS_UNABLE_GET_DATA,
            IDS_APP_ERROR, MB_OK);
        bReturn = FALSE;
    }
    return bReturn;
}

static
LoadInstanceList (
    IN  HWND    hDlg,
    IN  LPCTSTR  szMatchItem
)
{
    PPERF_OBJECT_TYPE   pObject;
    PPERF_OBJECT_TYPE   pParentObject;
    PPERF_COUNTER_BLOCK pCounterBlock;
    PPERF_INSTANCE_DEFINITION   pInstance;
    PPERF_INSTANCE_DEFINITION   pParentInstance;
    UINT                nCbSel;
    LONG                lThisInstance;
    TCHAR               szNameBuffer[MAX_PATH];
    TCHAR               szParentName[MAX_PATH];
    UINT                nIndex;

    nCbSel = (UINT)SendDlgItemMessage (hDlg, IDC_OBJECT, CB_GETCURSEL, 0, 0);

    if (nCbSel != CB_ERR) {
        pObject = (PPERF_OBJECT_TYPE)SendDlgItemMessage (hDlg, IDC_OBJECT, CB_GETITEMDATA,
            (WPARAM)nCbSel, 0);

        if (pObject->NumInstances == PERF_NO_INSTANCES) {
            // no instances so...
            // clear old contents
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
            // add display text
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_INSERTSTRING, (WPARAM)-1,
                (LPARAM)TEXT("<No Instances>"));
            // select this (and only) string
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
            // get pointer to counter data
            pCounterBlock = (PPERF_COUNTER_BLOCK)((LPBYTE)pObject + pObject->DefinitionLength);
            // and save it as item data
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETITEMDATA, 0,
                (LPARAM)pCounterBlock);
            // finally grey the window to prevent selections
            EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE), FALSE);
        } else {
            //enable window
            EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE), TRUE);
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
            pInstance = FirstInstance (pObject);
            for (lThisInstance = 0; lThisInstance < pObject->NumInstances; lThisInstance++) {
                pParentObject = GetObjectDefByTitleIndex (
                    pMainPerfData,
                    pInstance->ParentObjectTitleIndex);
                if (pParentObject != NULL) {
                    pParentInstance = GetInstance (pParentObject,
                        pInstance->ParentObjectInstance);
                } else {
                    pParentInstance = NULL;
                }
                if (pParentInstance != NULL) {
                    if (pParentInstance->UniqueID < 0) {
                        // use the instance name
                        wcsncpy (szParentName,
                            (LPWSTR)((LPBYTE)pParentInstance+pParentInstance->NameOffset),
                            pParentInstance->NameLength);
                        lstrcat (szParentName, (LPCTSTR)TEXT("==>"));
                    } else {
                        // use the instance number
                        _stprintf (szParentName, (LPCTSTR)TEXT("[%d]==>"),
                            pParentInstance->UniqueID);
                    }
                } else {
                    // unknown parent
                    *szParentName = 0;
                }
                if (pInstance->UniqueID < 0) {
                    // use the instance name
                    wcsncpy (szNameBuffer,
                        (LPWSTR)((LPBYTE)pInstance+pInstance->NameOffset),
                        pInstance->NameLength);
                } else {
                    // use the instance number
                    _stprintf (szNameBuffer, (LPCTSTR)TEXT("(%d)"),
                        pInstance->UniqueID);
                }
                lstrcat (szParentName, szNameBuffer);
                nIndex = (UINT)SendDlgItemMessage (hDlg, IDC_INSTANCE,
                    CB_INSERTSTRING, (WPARAM)-1,
                    (LPARAM)szParentName);
                if (nIndex != CB_ERR) {
                    // save pointer to counter block
                    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstance + pInstance->ByteLength);
                    SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETITEMDATA,
                        (WPARAM)nIndex, (LPARAM)pCounterBlock);
                }
                pInstance = NextInstance (pInstance);
            }
            if (szMatchItem == NULL) {
                SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
            } else {
                if (SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SELECTSTRING,
                    (WPARAM)-1, (LPARAM)szMatchItem) == CB_ERR) {
                    SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
                }
            }
        }
    } else {
        // no object selected
        // clear old contents
        SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
        // add display text
        SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_INSERTSTRING, (WPARAM)-1,
            (LPARAM)TEXT("<No object selected>"));
        // select this (and only) string
        SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
        // and save null pointer as item data
        SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETITEMDATA, 0,
            (LPARAM)0);
        // finally grey the window to prevent selections
        EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE), FALSE);
    }

    return TRUE;
}

static
LPCTSTR
GetCounterTypeName (
    IN  DWORD   dwCounterType
)
{
    UINT    nTypeString = 0;

    switch (dwCounterType) {
        case     PERF_COUNTER_COUNTER:
            nTypeString = IDS_TYPE_COUNTER_COUNTER    ;
            break;

        case     PERF_COUNTER_TIMER:
            nTypeString = IDS_TYPE_COUNTER_TIMER      ;
            break;

        case     PERF_COUNTER_QUEUELEN_TYPE:
            nTypeString = IDS_TYPE_COUNTER_QUEUELEN   ;
            break;

        case     PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            nTypeString = IDS_TYPE_COUNTER_LARGE_QUEUELEN   ;
            break;

        case     PERF_COUNTER_100NS_QUEUELEN_TYPE:
            nTypeString = IDS_TYPE_COUNTER_100NS_QUEUELEN   ;
            break;

        case     PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
            nTypeString = IDS_TYPE_COUNTER_OBJ_TIME_QUEUELEN   ;
            break;

        case     PERF_COUNTER_BULK_COUNT:
            nTypeString = IDS_TYPE_COUNTER_BULK_COUNT ;
            break;

        case     PERF_COUNTER_TEXT:
            nTypeString = IDS_TYPE_COUNTER_TEXT       ;
            break;

        case     PERF_COUNTER_RAWCOUNT:
            nTypeString = IDS_TYPE_COUNTER_RAWCOUNT   ;
            break;

        case     PERF_COUNTER_LARGE_RAWCOUNT:
            nTypeString = IDS_TYPE_COUNTER_LARGE_RAW  ;
            break;

        case     PERF_COUNTER_RAWCOUNT_HEX:
            nTypeString = IDS_TYPE_COUNTER_RAW_HEX    ;
            break;

        case     PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            nTypeString = IDS_TYPE_COUNTER_LARGE_RAW_HEX  ;
            break;

        case     PERF_SAMPLE_FRACTION:
            nTypeString = IDS_TYPE_SAMPLE_FRACTION    ;
            break;

        case     PERF_SAMPLE_COUNTER:
            nTypeString = IDS_TYPE_SAMPLE_COUNTER     ;
            break;

        case     PERF_COUNTER_NODATA:
            nTypeString = IDS_TYPE_COUNTER_NODATA     ;
            break;

        case     PERF_COUNTER_TIMER_INV:
            nTypeString = IDS_TYPE_COUNTER_TIMER_INV  ;
            break;

        case     PERF_SAMPLE_BASE:
            nTypeString = IDS_TYPE_SAMPLE_BASE        ;
            break;

        case     PERF_AVERAGE_TIMER:
            nTypeString = IDS_TYPE_AVERAGE_TIMER      ;
            break;

        case     PERF_AVERAGE_BASE:
            nTypeString = IDS_TYPE_AVERAGE_BASE       ;
            break;

        case     PERF_AVERAGE_BULK:
            nTypeString = IDS_TYPE_AVERAGE_BULK       ;
            break;

        case     PERF_OBJ_TIME_TIMER:
            nTypeString = IDS_TYPE_OBJ_TIME_TIMER     ;
            break;

        case     PERF_100NSEC_TIMER:
            nTypeString = IDS_TYPE_100NS_TIMER        ;
            break;

        case     PERF_100NSEC_TIMER_INV:
            nTypeString = IDS_TYPE_100NS_TIMER_INV    ;
            break;

        case     PERF_COUNTER_MULTI_TIMER:
            nTypeString = IDS_TYPE_MULTI_TIMER        ;
            break;

        case     PERF_COUNTER_MULTI_TIMER_INV:
            nTypeString = IDS_TYPE_MULTI_TIMER_INV    ;
            break;

        case     PERF_COUNTER_MULTI_BASE:
            nTypeString = IDS_TYPE_MULTI_BASE         ;
            break;

        case     PERF_100NSEC_MULTI_TIMER:
            nTypeString = IDS_TYPE_100NS_MULTI_TIMER  ;
            break;

        case     PERF_100NSEC_MULTI_TIMER_INV:
            nTypeString = IDS_TYPE_100NS_MULTI_TIMER_INV ;
            break;

        case     PERF_RAW_FRACTION:
            nTypeString = IDS_TYPE_RAW_FRACTION       ;
            break;

        case     PERF_LARGE_RAW_FRACTION:
            nTypeString = IDS_TYPE_LARGE_RAW_FRACTION ;
            break;

        case     PERF_RAW_BASE:
            nTypeString = IDS_TYPE_RAW_BASE           ;
            break;

        case     PERF_LARGE_RAW_BASE:
            nTypeString = IDS_TYPE_LARGE_RAW_BASE     ;
            break;

        case     PERF_ELAPSED_TIME:
            nTypeString = IDS_TYPE_ELAPSED_TIME       ;
            break;

        case     PERF_COUNTER_HISTOGRAM_TYPE:
            nTypeString = IDS_TYPE_HISTOGRAM          ;
            break;

        case     PERF_COUNTER_DELTA:
            nTypeString = IDS_TYPE_COUNTER_DELTA      ;
            break;

        case     PERF_COUNTER_LARGE_DELTA:
            nTypeString = IDS_TYPE_COUNTER_LARGE_DELTA;
            break;

        case     PERF_PRECISION_SYSTEM_TIMER:
            nTypeString = IDS_TYPE_PRECISION_SYSTEM_TIMER;
            break;

        case     PERF_PRECISION_100NS_TIMER:
            nTypeString = IDS_TYPE_PRECISION_100NS_TIMER ;
            break;

        case     PERF_PRECISION_OBJECT_TIMER:
            nTypeString = IDS_TYPE_PRECISION_OBJECT_TIMER;
            break;

	default:
            nTypeString = 0;
            break;
    }

    if (nTypeString != 0) {
        return GetStringResource (NULL, nTypeString);
    } else {
        return (LPCTSTR)TEXT("");
    }
}

static
BOOL
ShowCounterData (
    IN  HWND    hDlg,
    IN  LONG    lDisplayIndex
)
{
    PPERF_OBJECT_TYPE   pObject;
    PPERF_COUNTER_DEFINITION pCounterDef;
    PPERF_COUNTER_BLOCK pCounterBlock;
    UINT    nSelObject, nSelInstance;
    TCHAR   szTypeNameBuffer[MAX_PATH];

    TCHAR   szDisplayBuffer [SMALL_BUFFER_SIZE];

    DWORD   *pdwLoDword, *pdwHiDword;

    DWORD   dwThisCounter;

    SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_RESETCONTENT, 0, 0);

    nSelObject = (UINT)SendDlgItemMessage (hDlg, IDC_OBJECT, CB_GETCURSEL, 0, 0);
    nSelInstance = (UINT)SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_GETCURSEL, 0, 0);

    if ((nSelObject != CB_ERR) && (nSelInstance != CB_ERR)) {
        pObject = (PPERF_OBJECT_TYPE)SendDlgItemMessage (hDlg, IDC_OBJECT,
            CB_GETITEMDATA, (WPARAM)nSelObject, 0);

        pCounterBlock = (PPERF_COUNTER_BLOCK)SendDlgItemMessage (hDlg, IDC_INSTANCE,
            CB_GETITEMDATA, (WPARAM)nSelInstance, 0);

        pCounterDef = FirstCounter (pObject);

        for (dwThisCounter = 0; dwThisCounter < pObject->NumCounters; dwThisCounter++) {
            // get pointer to this counter's data (in this instance if applicable
            pdwLoDword = (PDWORD)((LPBYTE)pCounterBlock + pCounterDef->CounterOffset);
            pdwHiDword = pdwLoDword + 1;

            lstrcpy (szTypeNameBuffer, GetCounterTypeName (pCounterDef->CounterType));
            if (*szTypeNameBuffer == 0) {
                // no string returned so format data as HEX DWORD
                _stprintf (szTypeNameBuffer, (LPCTSTR)TEXT("Undefined Type: 0x%8.8x"),
                    pCounterDef->CounterType);
            }

            if (pCounterDef->CounterSize <= sizeof(DWORD)) {
                _stprintf (szDisplayBuffer, (LPCTSTR)TEXT("%d\t%s\t%s\t0x%8.8x (%d)"),
                    pCounterDef->CounterNameTitleIndex,
                    (pCounterDef->CounterNameTitleIndex <= dwLastName ?
                    szNameTable[pCounterDef->CounterNameTitleIndex] : (LPCTSTR)TEXT("Name not loaded")),
                    szTypeNameBuffer,
                    *pdwLoDword, *pdwLoDword);
            } else {
                _stprintf (szDisplayBuffer, (LPCTSTR)TEXT("%d\t%s\t%s\t0x%8.8x%8.8x"),
                    pCounterDef->CounterNameTitleIndex,
                    (pCounterDef->CounterNameTitleIndex <= dwLastName ?
                    szNameTable[pCounterDef->CounterNameTitleIndex] : (LPCTSTR)TEXT("Name not loaded")),
                    szTypeNameBuffer,
                    *pdwHiDword, *pdwLoDword);
            }
            SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_INSERTSTRING,
                (WPARAM)-1, (LPARAM)szDisplayBuffer);
            pCounterDef = NextCounter(pCounterDef);
        }
        if (lDisplayIndex < 0) {
            if (pObject->DefaultCounter >= 0) {
                SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_SETCURSEL,
                    (WPARAM)pObject->DefaultCounter, 0);
            } else {
                SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_SETCURSEL,
                    (WPARAM)0, 0);
            }
        } else {
            SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_SETCURSEL,
                (WPARAM)lDisplayIndex, (LPARAM)0);
        }
    } else {
        // no object and/or instsance selected so nothing else to do
    }

    return TRUE;
}

static
BOOL
OnComputerChange (
    IN  HWND    hDlg
)
{
    TCHAR   szLocalComputerName [MAX_COMPUTERNAME_LENGTH+3];
    HKEY    hLocalMachineKey = NULL;
    HKEY    hLocalPerfKey = NULL;
    LPWSTR  *szLocalNameTable = NULL;
    BOOL    bResult = FALSE;
    HWND    hWndComputerName;

    SET_WAIT_CURSOR;

    // get name from edit control
    hWndComputerName = GetDlgItem (hDlg, IDC_COMPUTERNAME);

    GetWindowText (hWndComputerName,
        szLocalComputerName,
        MAX_COMPUTERNAME_LENGTH+2);

    if (lstrcmpi(szComputerName, szLocalComputerName) != 0) {
        // a new name has been entered so try to connect to it
        if (lstrcmpi(szLocalComputerName, szThisComputerName) == 0) {
            // then this is the local machine which is a special case
            hLocalMachineKey = HKEY_LOCAL_MACHINE;
            hLocalPerfKey = HKEY_PERFORMANCE_DATA;
            szLocalComputerName[0] = 0;
        } else {
            // try to connect to remote computer
            if (RegConnectRegistry (szLocalComputerName,
                HKEY_LOCAL_MACHINE, &hLocalMachineKey) == ERROR_SUCCESS) {
                // connected to the new machine, so Try to connect to
                // the performance data, too
                if (RegConnectRegistry (szLocalComputerName,
                    HKEY_PERFORMANCE_DATA, &hLocalPerfKey) == ERROR_SUCCESS) {
                } else {
                    DisplayMessageBox (hDlg,
                        IDS_UNABLE_CONNECT_PERF,
                        IDS_APP_ERROR, MB_OK);
                }
            } else {
                DisplayMessageBox (hDlg,
                    IDS_UNABLE_CONNECT_MACH,
                    IDS_APP_ERROR, MB_OK);
            }
        }
        if ((hLocalMachineKey != NULL) && (hLocalPerfKey != NULL)) {
            // try to get a new name table
            szLocalNameTable = BuildNameTable (
                (szLocalComputerName == 0 ? NULL : szLocalComputerName),
                NULL,
                &dwLastName);

            if (szLocalNameTable) {
                bResult = TRUE;
            } else {
                DisplayMessageBox (hDlg,
                    IDS_UNABLE_GET_NAMES,
                    IDS_APP_ERROR, MB_OK);
            }
        }

        if (bResult) {
            // made it so close the old connections

            if (hKeyMachine != NULL) {
                RegCloseKey (hKeyMachine);
            }
            hKeyMachine = hLocalMachineKey;

            if (hKeyPerformance != NULL) {
                RegCloseKey (hKeyPerformance);
            }
            hKeyPerformance = hLocalPerfKey;

            if (szNameTable != NULL) {
                MemoryFree (szNameTable);
            }
            szNameTable = szLocalNameTable;

            if (szLocalComputerName[0] == 0) {
                lstrcpy (szComputerName, szThisComputerName);
            }

            // then update the fields
            bResult = LoadObjectList (hDlg, NULL);
            if (bResult) {
                LoadInstanceList (hDlg, NULL);
                ShowCounterData (hDlg, -1);
            }
        } else {
            // unable to get info from machine so clean up
            if (hLocalPerfKey != NULL) RegCloseKey (hLocalPerfKey);
            if (hLocalMachineKey != NULL) RegCloseKey (hLocalMachineKey);
            if (szLocalNameTable != NULL) MemoryFree (szLocalNameTable);
            // reset computer name to the one that works.
            SetWindowText (hWndComputerName, szComputerName);
        }
    } else {
        // the name hasn't changed
    }

    return TRUE;

}

static
BOOL
MainDlg_WM_INITDIALOG (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    DWORD       dwComputerNameLength = MAX_COMPUTERNAME_LENGTH+1;

    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);

    SET_WAIT_CURSOR;

    lstrcpy (szThisComputerName, (LPCTSTR)TEXT("\\\\"));
    GetComputerName (szThisComputerName+2, &dwComputerNameLength);

    szComputerName[0] = 0;  // reset the computer name
    // load the local machine name into the edit box
    SetWindowText (GetDlgItem (hDlg, IDC_COMPUTERNAME), szThisComputerName);

    SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_SETTABSTOPS,
        (WPARAM)NUM_TAB_STOPS, (LPARAM)&nDataListTabs);
    CheckDlgButton (hDlg, IDC_INCLUDE_COSTLY, UNCHECKED);

    OnComputerChange (hDlg);

    SetFocus (GetDlgItem (hDlg, IDC_OBJECT));

    SET_ARROW_CURSOR;
    return FALSE;
}

static
BOOL
MainDlg_IDC_COMPUTERNAME (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case EN_KILLFOCUS:
            OnComputerChange(hDlg);
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_OBJECT (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case CBN_SELCHANGE:
            SET_WAIT_CURSOR;
            if (pMainPerfData) {
                LoadInstanceList (hDlg, NULL);
                ShowCounterData (hDlg, -1);
            }
            SET_ARROW_CURSOR;
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_INSTANCE (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case CBN_SELCHANGE:
            SET_WAIT_CURSOR;
            ShowCounterData (hDlg, -1);
            SET_ARROW_CURSOR;
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_DATA_LIST (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);
    UNREFERENCED_PARAMETER (hDlg);

    switch (wNotifyMsg) {
        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_REFRESH (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    TCHAR   szSelObject[MAX_PATH];
    TCHAR   szSelInstance[MAX_PATH];
    BOOL    bResult;
    LONG    lCounterIdx;

    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case BN_CLICKED:
            SET_WAIT_CURSOR;
            GetDlgItemText (hDlg, IDC_OBJECT,
                szSelObject, MAX_PATH-1);

            GetDlgItemText (hDlg, IDC_INSTANCE,
                szSelInstance, MAX_PATH-1);

            lCounterIdx = (ULONG)SendDlgItemMessage (hDlg, IDC_DATA_LIST,
                LB_GETCURSEL, 0, 0);

            bResult = LoadObjectList (hDlg, szSelObject);
            if (bResult) {
                LoadInstanceList (hDlg, szSelInstance);
                ShowCounterData (hDlg, lCounterIdx);
            }
            SET_ARROW_CURSOR;
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_ABOUT ()
{
    TCHAR buffer[1024];
    TCHAR strProgram[1024];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, 1024 );

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){
     
            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        _stprintf( buffer, _T("\nMicrosoft (R) %s\nVersion: %s\n%s"), pProduct, pVersion, pCopyRight );
                    }
                }
                free( pVersionInfo );
            }
        }
    }

    MessageBox( NULL, buffer, _T("About ShowPerf"), MB_OK );

    return TRUE;
}

static
BOOL
MainDlg_WM_COMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    WORD    wCtrlId, wNotifyMsg;
    HWND    hWndControl;

    wCtrlId = GET_CONTROL_ID (wParam);
    wNotifyMsg = GET_NOTIFY_MSG (wParam, lParam);
    hWndControl = GET_COMMAND_WND (lParam);

    switch (wCtrlId) {
        case IDC_COMPUTERNAME:
            return MainDlg_IDC_COMPUTERNAME (hDlg, wNotifyMsg, hWndControl);

        case IDC_OBJECT:
            return MainDlg_IDC_OBJECT (hDlg, wNotifyMsg, hWndControl);

        case IDC_INSTANCE:
            return MainDlg_IDC_INSTANCE (hDlg, wNotifyMsg, hWndControl);

        case IDC_DATA_LIST:
            return MainDlg_IDC_DATA_LIST (hDlg, wNotifyMsg, hWndControl);

        case IDC_REFRESH:
            return MainDlg_IDC_REFRESH (hDlg, wNotifyMsg, hWndControl);

        case IDC_ABOUT:
            return MainDlg_IDC_ABOUT ();

        case IDOK:
            EndDialog (hDlg, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_WM_SYSCOMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (lParam);

    switch (wParam) {
        case SC_CLOSE:
            EndDialog (hDlg, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_WM_CLOSE (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);
    UNREFERENCED_PARAMETER (hDlg);

    MemoryFree (pMainPerfData);
    pMainPerfData = NULL;

    MemoryFree (szNameTable);
    szNameTable = NULL;

    return TRUE;
}

INT_PTR
MainDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    switch (message) {
        case WM_INITDIALOG:
            return MainDlg_WM_INITDIALOG (hDlg, wParam, lParam);

        case WM_COMMAND:
            return MainDlg_WM_COMMAND (hDlg, wParam, lParam);

        case WM_SYSCOMMAND:
            return MainDlg_WM_SYSCOMMAND (hDlg, wParam, lParam);

        case WM_CLOSE:
            return MainDlg_WM_CLOSE (hDlg, wParam, lParam);

        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\mainwnd.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    MainWnd.H

Abstract:
    
    Global functions and constants used by the Main Application Window

Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94

--*/

#ifndef _MAINWND_H_
#define _MAINWND_H_

//  Main Window Constants

//
//  Global functions
//
LRESULT CALLBACK
MainWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
);

BOOL
RegisterMainWindowClass (
    IN  HINSTANCE   hInstance
);

HWND
CreateMainWindow (
    IN  HINSTANCE   hInstance
);

#endif  // _MAINWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\perfdata.h ===
#ifndef _PERFDATA_H_
#define _PERFDATA_H_

#define INITIAL_SIZE    4096L
#define EXTEND_SIZE     4096L
#define RESERVED        0L

typedef LPVOID  LPMEMORY;
typedef HGLOBAL HMEMORY;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

LPMEMORY
MemoryAllocate (
    DWORD dwSize
);

VOID
MemoryFree (
    LPMEMORY lpMemory
);

DWORD
MemorySize (
    LPMEMORY lpMemory
);

LPMEMORY
MemoryResize (
    LPMEMORY lpMemory,
    DWORD dwNewSize
);

LPWSTR
*BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from 
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
);

PPERF_OBJECT_TYPE
FirstObject (
    IN  PPERF_DATA_BLOCK pPerfData
);

PPERF_OBJECT_TYPE
NextObject (
    IN  PPERF_OBJECT_TYPE pObject
);

PERF_OBJECT_TYPE *
GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
);

PERF_INSTANCE_DEFINITION *
FirstInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef
);

PERF_INSTANCE_DEFINITION *
NextInstance(
    IN  PERF_INSTANCE_DEFINITION *pInstDef
);

PERF_INSTANCE_DEFINITION *
GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
);

PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
);

PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
);

LONG
GetSystemPerfData (
    IN HKEY hKeySystem,
    IN PPERF_DATA_BLOCK *pPerfData,
    IN DWORD dwIndex       // 0 = Global, 1 = Costly
);



#endif //_PERFDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\resource.h ===
#define IDC_STATIC                  -1
#define IDD_MAIN                    100
#define IDC_OBJECT                  1001
#define IDC_INSTANCE                1002
#define IDC_DATA_LIST               1003
#define IDC_REFRESH                 1004
#define IDC_INCLUDE_COSTLY          1005
#define IDC_ABOUT                   1111
#define IDH_CONTENTS                10000
#define IDI_APP_ICON                11000
#define IDS_APP_TITLE               20001
#define IDS_APP_ERROR               20003
#define IDS_APP_WINDOW_CLASS        20006
#define IDS_HELP_FILENAME           20007
#define IDS_UNABLE_GET_DATA         20009
#define IDS_UNABLE_CONNECT_PERF     20010
#define IDS_UNABLE_CONNECT_MACH     20011
#define IDS_UNABLE_GET_NAMES        20012
#define IDS_TYPE_COUNTER_COUNTER    20101
#define IDS_TYPE_COUNTER_TIMER      20102
#define IDS_TYPE_COUNTER_QUEUELEN   20103
#define IDS_TYPE_COUNTER_BULK_COUNT 20104
#define IDS_TYPE_COUNTER_TEXT       20105
#define IDS_TYPE_COUNTER_RAWCOUNT   20106
#define IDS_TYPE_COUNTER_LARGE_RAW  20107
#define IDS_TYPE_SAMPLE_FRACTION    20108
#define IDS_TYPE_SAMPLE_COUNTER     20109
#define IDS_TYPE_COUNTER_NODATA     20110
#define IDS_TYPE_COUNTER_TIMER_INV  20111
#define IDS_TYPE_SAMPLE_BASE        20112
#define IDS_TYPE_AVERAGE_TIMER      20113
#define IDS_TYPE_AVERAGE_BASE       20114
#define IDS_TYPE_AVERAGE_BULK       20115
#define IDS_TYPE_100NS_TIMER        20116
#define IDS_TYPE_100NS_TIMER_INV    20117
#define IDS_TYPE_MULTI_TIMER        20118
#define IDS_TYPE_MULTI_TIMER_INV    20119
#define IDS_TYPE_MULTI_BASE         20120
#define IDS_TYPE_100NS_MULTI_TIMER  20121
#define IDS_TYPE_100NS_MULTI_TIMER_INV 20122
#define IDS_TYPE_RAW_FRACTION       20123
#define IDS_TYPE_RAW_BASE           20124
#define IDS_TYPE_ELAPSED_TIME       20125
#define IDS_TYPE_HISTOGRAM          20126
#define IDS_TYPE_COUNTER_LARGE_QUEUELEN  20127
#define IDS_TYPE_COUNTER_DELTA      20128
#define IDS_TYPE_COUNTER_LARGE_DELTA 20129
#define IDS_TYPE_COUNTER_100NS_QUEUELEN 20130
#define IDS_TYPE_COUNTER_OBJ_TIME_QUEUELEN 20131
#define IDS_TYPE_COUNTER_RAW_HEX    20132
#define IDS_TYPE_COUNTER_LARGE_RAW_HEX 20133
#define IDS_TYPE_OBJ_TIME_TIMER     20134
#define IDS_TYPE_LARGE_RAW_FRACTION 20135
#define IDS_TYPE_LARGE_RAW_BASE     20136
#define IDS_TYPE_PRECISION_SYSTEM_TIMER 20137
#define IDS_TYPE_PRECISION_100NS_TIMER 20138
#define IDS_TYPE_PRECISION_OBJECT_TIMER 20139
#define IDD_COUNTER_DETAILS         200
#define IDC_COUNTER                 202
#define IDC_COUNTER_NAME_TITLE_INDEX 1006
#define IDC_COUNTER_NAME_TEXT       1007
#define IDC_COUNTER_HELP_TITLE_INDEX 1009
#define IDC_EXPLAIN_TEXT            1010
#define IDC_DEFAULT_SCALE           1011
#define IDC_DEFAULT_SCALE_FACTOR    1012
#define IDC_COUNTER_DETAIL_LEVEL    1013
#define IDC_COUNTER_SIZE            1014
#define IDC_COUNTER_VALUE           1015
#define IDC_COMPUTERNAME            1016
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\showperf.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    SHOWPERF.H

Abstract:


Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94


--*/
#ifndef _SHOWPERF_H_
#define _SHOWPERF_H_

//  WIN32 Constant Definitions
//
#define BEEP_EXCLAMATION    MB_ICONEXCLAMATION
#define OF_SEARCH           0

#define MAX_PATH_BYTES      (MAX_PATH * sizeof(TCHAR))

#define SMALL_BUFFER_SIZE   1023
#define SMALL_BUFFER_BYTES  ((SMALL_BUFFER_SIZE + 1) * sizeof (TCHAR))

#define MEDIUM_BUFFER_SIZE  4095
#define MEDIUM_BUFFER_BYTES ((MEDIUM_BUFFER_SIZE + 1) * sizeof (TCHAR))

#define LARGE_BUFFER_SIZE   65535
#define LARGE_BUFFER_BYTES  ((LARGE_BUFFER_SIZE + 1) * sizeof (TCHAR))

// define dialog box button states
#define     ENABLED         TRUE
#define     DISABLED        FALSE

#define     CHECKED         1
#define     UNCHECKED       0

// define Mailbox buttons
#define MBOK_EXCLAIM            (MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MBOK_INFO               (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL)
#define MBOKCANCEL_EXCLAIM      (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MBOKCANCEL_INFO         (MB_OKCANCEL | MB_ICONINFORMATION | MB_TASKMODAL)
#define MBOKCANCEL_QUESTION     (MB_OKCANCEL | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNO_QUESTION        (MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNOCANCEL_QUESTION  (MB_YESNOCANCEL | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNOCANCEL_EXCLAIM   (MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)

// other constants
#define MAX_USERNAME            15
#define MAX_DOMAINNAME          15
#define MAX_ORGNAME             255
#define MAX_PRODUCT_NAME_LENGTH 32

//
//  WIN32 Version of common macros
//
#define GLOBAL_ALLOC(s)		GlobalAlloc(GPTR,s)
#define GLOBAL_FREE_IF_ALLOC(p)	(p != NULL ? GlobalFree(p) : 0)

#define GET_CONTROL_ID(w)   (LOWORD(w))
#define GET_NOTIFY_MSG(w,l) (HIWORD(w))
#define GET_COMMAND_WND(l)  ((HWND)(l))
#define GET_INSTANCE(h)     ((HINSTANCE)GetWindowLongPtr(h, GWLP_HINSTANCE))
#define SAVE_HWND(w,o,v)    SetWindowLong (w,o,(LONG)v)
#define GET_HWND(w,o)       (HWND)GetWindowLong (w,o)
#define SET_HWND(w,o,v)     SetWindowLong (w,o, (DWORD)v)
#define SET_INFO(w,o,p)     (LPVOID)SetWindowLong (w,o,(LONG)p)
#define GET_INFO(w,o)       (LPVOID)GetWindowLong (w,o)
#define SEND_WM_COMMAND(w,c,n,cw)  SendMessage (w, WM_COMMAND, MAKEWPARAM(c,n), (LPARAM)cw)
#define POST_WM_COMMAND(w,c,n,cw)  PostMessage (w, WM_COMMAND, MAKEWPARAM(c,n), (LPARAM)cw)
#define GetMyLastError		GetLastError	
#define CLEAR_FIRST_FOUR_BYTES(x)   *(DWORD *)(x) = 0L
#define SET_WAIT_CURSOR     (SetCursor(LoadCursor(NULL, IDC_WAIT)))
#define SET_ARROW_CURSOR    (SetCursor(LoadCursor(NULL, IDC_ARROW)))

//
//  Global Functions
//
LPCTSTR
GetStringResource (
    IN  HANDLE	hInstance,
    IN  UINT    nId
);

BOOL
ShowAppHelp (
    IN  HWND    hWnd
);

int
DisplayMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
);

VOID
SetHelpContextId (
    WORD    wId
);

WORD
GetHelpContextId (
);


#endif // _SHOWPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\perfdata.c ===
#include <windows.h>
#include <winperf.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include "perfdata.h"

const LPWSTR NamesKey = (const LPWSTR)L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
const LPWSTR DefaultLangId = (const LPWSTR)L"009";
const LPWSTR Counters = (const LPWSTR)L"Counters";
const LPWSTR Help = (const LPWSTR)L"Help";
const LPWSTR LastHelp = (const LPWSTR)L"Last Help";
const LPWSTR LastCounter = (const LPWSTR)L"Last Counter";
const LPWSTR Slash = (const LPWSTR)L"\\";

// the following strings are for getting texts from perflib
#define  OLD_VERSION 0x010000
const LPWSTR VersionName = (const LPWSTR)L"Version";
const LPWSTR CounterName = (const LPWSTR)L"Counter ";
const LPWSTR HelpName = (const LPWSTR)L"Explain ";


LPMEMORY
MemoryAllocate (
    DWORD dwSize
)
{  // MemoryAllocate
    HMEMORY        hMemory ;
    LPMEMORY       lpMemory ;

    hMemory = GlobalAlloc (GHND, dwSize);
    if (!hMemory)
        return (NULL);
    lpMemory = GlobalLock (hMemory);
    if (!lpMemory)
        GlobalFree (hMemory);
    return (lpMemory);
}  // MemoryAllocate

VOID
MemoryFree (
    LPMEMORY lpMemory
)
{  // MemoryFree
    HMEMORY        hMemory ;

    if (!lpMemory)
        return ;

    hMemory = GlobalHandle (lpMemory);

    if (hMemory)
        {  // if
        GlobalUnlock (hMemory);
        GlobalFree (hMemory);
        }  // if
}  // MemoryFree

DWORD
MemorySize (
    LPMEMORY lpMemory
)
{
    HMEMORY        hMemory ;

    hMemory = GlobalHandle (lpMemory);
    if (!hMemory)
        return (0L);

    return (DWORD)(GlobalSize (hMemory));
}

LPMEMORY
MemoryResize (
    LPMEMORY lpMemory,
    DWORD dwNewSize
)
{
    HMEMORY        hMemory ;
    LPMEMORY       lpNewMemory ;

    hMemory = GlobalHandle (lpMemory);
    if (!hMemory)
        return (NULL);

    GlobalUnlock (hMemory);

    hMemory = GlobalReAlloc (hMemory, dwNewSize, GHND);

    if (!hMemory)
        return (NULL);


    lpNewMemory = GlobalLock (hMemory);

    return (lpNewMemory);
}  // MemoryResize

LPWSTR
*BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
)
/*++

BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{

    LPWSTR  *lpReturnValue;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;

    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;

    HKEY    hKeyRegistry = NULL;
    HKEY    hKeyValue = NULL;
    HKEY    hKeyNames = NULL;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];

    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;

    if (szComputerName == NULL) {
        // use local machine
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    } else {
        if (RegConnectRegistry (szComputerName,
            HKEY_LOCAL_MACHINE, &hKeyRegistry) != ERROR_SUCCESS) {
            // unable to connect to registry
            return NULL;
        }
    }

    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = DefaultLangId;
    }

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyEx (
        hKeyRegistry,
        NamesKey,
        RESERVED,
        KEY_READ,
        &hKeyValue);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastHelp,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastCounter,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }


    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        VersionName,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = MemoryAllocate (
            lstrlen(NamesKey) * sizeof (WCHAR) +
            lstrlen(Slash) * sizeof (WCHAR) +
            lstrlen(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));

        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpy (lpValueNameString, NamesKey);
        lstrcat (lpValueNameString, Slash);
        lstrcat (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyEx (
            hKeyRegistry,
            lpValueNameString,
            RESERVED,
            KEY_READ,
            &hKeyNames);
    } else {
        if (szComputerName == NULL) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        } else {
            if (RegConnectRegistry (szComputerName,
                HKEY_PERFORMANCE_DATA, &hKeyNames) != ERROR_SUCCESS) {
                goto BNT_BAILOUT;
            }
        }

        lstrcpy (CounterNameBuffer, CounterName);
        lstrcat (CounterNameBuffer, lpszLangId);

        lstrcpy (HelpNameBuffer, HelpName);
        lstrcat (HelpNameBuffer, lpszLangId);
    }

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwHelpSize = dwBufferSize;

    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) goto BNT_BAILOUT;

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpCounterNames,
        &dwBufferSize);

    if (!lpReturnValue) goto BNT_BAILOUT;

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpHelpText,
        &dwBufferSize);

    if (!lpReturnValue) goto BNT_BAILOUT;

    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }

    if (pdwLastItem) *pdwLastItem = dwLastId;

    MemoryFree ((LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
    if (dwSystemVersion == OLD_VERSION)
        RegCloseKey (hKeyNames);

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpValueNameString) {
        MemoryFree ((LPVOID)lpValueNameString);
    }

    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }

    if (hKeyValue) RegCloseKey (hKeyValue);
    if (hKeyNames) RegCloseKey (hKeyNames);
    if (hKeyRegistry) RegCloseKey (hKeyNames);

    return NULL;
}

PPERF_OBJECT_TYPE
FirstObject (
    IN  PPERF_DATA_BLOCK pPerfData
)
{
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pPerfData + pPerfData->HeaderLength));
}

PPERF_OBJECT_TYPE
NextObject (
    IN  PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    DWORD   dwOffset;
    dwOffset =  pObject->TotalByteLength;
    if (dwOffset != 0) {
        return ((PPERF_OBJECT_TYPE) ((PBYTE) pObject + dwOffset));
    } else {
        return NULL;
    }
}  // NextObject

PERF_OBJECT_TYPE *
GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
)
{
    DWORD NumTypeDef;

    PERF_OBJECT_TYPE *pObjectDef;

    pObjectDef = FirstObject(pDataBlock);

    for ( NumTypeDef = 0;
	  NumTypeDef < pDataBlock->NumObjectTypes;
	  NumTypeDef++ ) {

        if ( pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex ) {

	    return pObjectDef;
	}
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}

PERF_INSTANCE_DEFINITION *
FirstInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}

PERF_INSTANCE_DEFINITION *
NextInstance(
    IN  PERF_INSTANCE_DEFINITION *pInstDef
)
{
    PERF_COUNTER_BLOCK *pCounterBlock;


    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

PERF_INSTANCE_DEFINITION *
GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
)
{

   PERF_INSTANCE_DEFINITION *pInstanceDef;
   LONG NumInstance;

   if (!pObjectDef)
      {
      return 0;
      }

   pInstanceDef = FirstInstance(pObjectDef);

   for ( NumInstance = 0;
      NumInstance < pObjectDef->NumInstances;
      NumInstance++ )
      {
   	if ( InstanceNumber == NumInstance )
         {
         return pInstanceDef;
         }
      pInstanceDef = NextInstance(pInstanceDef);
      }

   return 0;
}

PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->HeaderLength);
}

PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    DWORD   dwOffset;
    dwOffset =  pCounterDef->ByteLength;
    if (dwOffset != 0) {
        return (PERF_COUNTER_DEFINITION *)
                ((PCHAR) pCounterDef + dwOffset);
    } else {
        return NULL;
    }
}

#pragma warning ( disable : 4127 )
LONG
GetSystemPerfData (
    IN HKEY hKeySystem,
    IN PPERF_DATA_BLOCK *pPerfData,
    IN DWORD dwIndex       // 0 = Global, 1 = Costly
)
{  // GetSystemPerfData
    LONG     lError ;
    DWORD    Size;
    DWORD    Type;

	printf ("\nGetSystemPerfdata entered in line %d of %s", __LINE__, __FILE__);
    if (dwIndex >= 2) {
        return !ERROR_SUCCESS;
    }

    if (*pPerfData == NULL) {
        *pPerfData = MemoryAllocate (INITIAL_SIZE);
        if (*pPerfData == NULL) {
			printf ("\nMemory Allocation Failure in line %d of %s", __LINE__, __FILE__);
			return ERROR_OUTOFMEMORY;
		}
    }

    while (TRUE) {
        Size = MemorySize (*pPerfData);

        lError = RegQueryValueEx (
            hKeySystem,
            dwIndex == 0 ?
               (LPCWSTR)L"Global" :
               (LPCWSTR)L"Costly",
            RESERVED,
            &Type,
            (LPBYTE)*pPerfData,
            &Size);

        if ((!lError) &&
            (Size > 0) &&
            ((*pPerfData)->Signature[0] == (WCHAR)'P') &&
            ((*pPerfData)->Signature[1] == (WCHAR)'E') &&
            ((*pPerfData)->Signature[2] == (WCHAR)'R') &&
            ((*pPerfData)->Signature[3] == (WCHAR)'F')) {

            return (ERROR_SUCCESS);
        }

        if (lError == ERROR_MORE_DATA) {
            *pPerfData = MemoryResize (
                *pPerfData,
                MemorySize (*pPerfData) +
                EXTEND_SIZE);

            if (*pPerfData == NULL) {
                return (lError);
            }
        } else {
            return (lError);
        }
    }
}  // GetSystemPerfData
#pragma warning ( default : 4127 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\showperf\showperf.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ShowPerf.c

Abstract:

    Provides a GUI interface to display the contents of a perf data
    block

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    "showperf.h"
#include    "resource.h"
#include    "mainwnd.h"
#include    "maindlg.h"

#define NUM_BUFS    4

// variable definition

static  WORD    wHelpContextId = IDH_CONTENTS;

LPCTSTR
GetStringResource (
    IN  HANDLE	hInstance,
    IN  UINT    nId
)
/*++

Routine Description:

    look up string resource and return string

Arguments:

    IN  UINT    nId
        Resource ID of string to look up

Return Value:

    pointer to string referenced by ID in arg list

--*/
{
    static  TCHAR   szBufArray[NUM_BUFS][SMALL_BUFFER_SIZE];
    static  DWORD   dwIndex;
    LPTSTR  szBuffer;
    DWORD   dwLength;

    HANDLE  hMod;

    if (hInstance != NULL) {
        hMod = hInstance;
    } else {
        hMod = GetModuleHandle(NULL);
    }

    dwIndex++;
    dwIndex %= NUM_BUFS;
    szBuffer = &szBufArray[dwIndex][0];

    // clear previous contents
    memset (szBuffer, 0, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    dwLength = LoadString (
        hMod,
        nId,
        szBuffer,
        SMALL_BUFFER_SIZE);

    return (LPCTSTR)szBuffer;
}

VOID
SetHelpContextId (
    WORD    wId
)
{
    wHelpContextId = wId;
    return;
}

WORD
GetHelpContextId (
)
{
    return wHelpContextId;
}

int
DisplayMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
)
/*++

Routine Description:

    Displays a message box displaying text from the resource file, as
        opposed to literal strings.

Arguments:

    IN  HWND    hWnd            window handle to parent window
    IN  UINT    nMessageId      String Resource ID of message text to display
    IN  UINT    nTitleId        String Resource ID of title text to display
    IN  UINT    nStyle          MB style bits (see MessageBox function)

Return Value:

    ID of button pressed to exit message box

--*/
{
    LPTSTR      szMessageText = NULL;
    LPTSTR      szTitleText = NULL;
    HINSTANCE   hInst;
    int         nReturn;

    hInst = GET_INSTANCE(hWnd);

    szMessageText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);
    szTitleText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);

    if ((szMessageText != NULL) &&
        (szTitleText != NULL)) {
        LoadString (hInst,
            ((nTitleId != 0) ? nTitleId : IDS_APP_TITLE),
            szTitleText,
            SMALL_BUFFER_SIZE -1);

        LoadString (hInst,
            nMessageId,
            szMessageText,
            SMALL_BUFFER_SIZE - 1);

        nReturn = MessageBox (
            hWnd,
            szMessageText,
            szTitleText,
            nStyle);
    } else {
        nReturn = IDCANCEL;
    }

    GLOBAL_FREE_IF_ALLOC (szMessageText);
    GLOBAL_FREE_IF_ALLOC (szTitleText);

    return nReturn;
}

BOOL
UpdateSystemMenu (
    IN  HWND    hWnd   // window handle
)
/*++

Routine Description:

    modifies the system menu by:
        Removing the "Restore", "Size", "Minimize" and "Maximize" entries

Arguments:

    IN  HWND    hWnd
        window handle of window containing the system menu to modify


Return Value:

    TRUE if successfully made changes, otherwise
    FALSE if error occurred

--*/
{
    UNREFERENCED_PARAMETER (hWnd);

    return TRUE;
}

BOOL
ShowAppHelp (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Generic routine to call WinHelp engine for displaying application
        help. wContext parameter is used for context.

Arguments:

    IN  HWND    hWnd
        window handle of calling window

Return Value:

    TRUE if help called successfully

--*/
{
    return WinHelp (hWnd,
        GetStringResource(GET_INSTANCE(hWnd), IDS_HELP_FILENAME),
        HELP_CONTEXT,
        (DWORD)GetHelpContextId());
}

int APIENTRY
WinMain(
    IN  HINSTANCE hInstance,
    IN  HINSTANCE hPrevInstance,
    IN  LPSTR     szCmdLine,
    IN  int       nCmdShow
)
/*++

Routine Description:

    Program entry point for LoadAccount application. Initializes Windows
        data structures and begins windows message processing loop.

Arguments:

    Standard WinMain arguments

ReturnValue:

    0 if unable to initialize correctly, or
    wParam from WM_QUIT message if messages processed

--*/
{
    HWND        hWnd; // Main window handle.
	MSG         msg;

    UNREFERENCED_PARAMETER (nCmdShow);
    UNREFERENCED_PARAMETER (szCmdLine);
    UNREFERENCED_PARAMETER (hPrevInstance);

    if (RegisterMainWindowClass(hInstance)) {
        hWnd = CreateMainWindow (hInstance);

        if (hWnd != NULL) {

	        // Acquire and dispatch messages until a
            //  WM_QUIT message is received.

	        while (GetMessage(&msg, // message structure
	            NULL,   // handle of window receiving the message
	            0,      // lowest message to examine
	            0))    // highest message to examine
            {
                // process this message
                TranslateMessage(&msg);// Translates virtual key codes
                DispatchMessage(&msg); // Dispatches message to window
            }
	        return (int)(msg.wParam); // Returns the value from PostQuitMessage
        } else {
            return (ERROR_CAN_NOT_COMPLETE);
        }
    } else {
        return (ERROR_CAN_NOT_COMPLETE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\local\makefile.inc ===
#
# Copy files from server to make local version of base functions.
#

$(O)\predefh.c    : ..\server\predefh.c
    copy $? $@

$(O)\regdkey.c    : ..\server\regdkey.c
    copy $? $@

$(O)\regdval.c    : ..\server\regdval.c
    copy $? $@

$(O)\regekey.c    : ..\server\regekey.c
    copy $? $@

$(O)\regeval.c    : ..\server\regeval.c
    copy $? $@

$(O)\regkey.c     : ..\server\regkey.c
    copy $? $@

$(O)\reglukey.c   : ..\server\reglukey.c
    copy $? $@

$(O)\regqkey.c    : ..\server\regqkey.c
    copy $? $@

$(O)\regqval.c    : ..\server\regqval.c
    copy $? $@

$(O)\regsckey.c   : ..\server\regsckey.c
    copy $? $@

$(O)\regsrkey.c   : ..\server\regsrkey.c
    copy $? $@

$(O)\regsval.c    : ..\server\regsval.c
    copy $? $@

$(O)\regclass.c   : ..\server\regclass.c
    copy $? $@

$(O)\regecls.c    : ..\server\regecls.c
    copy $? $@

$(O)\regvcls.c    : ..\server\regvcls.c
    copy $? $@

$(O)\regstate.c   : ..\server\regstate.c
    copy $? $@

$(O)\regnccls.c   : ..\server\regnccls.c
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\exts\regexts.cxx ===
/*++

Module Name:

    regleaks.cxx

Abstract:

        Debugger extensions for class store.

Author:

        UShaji (Adapted from  extensions, MarioGo, MazharM, JRoberts)

--*/
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include "windows.h"

// #include "stkwalk.h"
#include <imagehlp.h>
#include "wdbgexts.h"
#include "regexts.hxx"


//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion = 0;
USHORT                  SavedMinorVersion = 0;
HANDLE                  ProcessHandle = 0;
BOOL                    fKernelDebug = FALSE;
UEnvReadMemory          ReadMemoryExt = ReadMemoryUserMode;
UEnvReadMemory          WriteMemoryExt = ReadMemoryUserMode;

//
// macros
//

/*
#define ExtensionRoutinePrologue()  if (!fKernelDebug) \
                                    { \
                                        ExtensionApis = *lpExtensionApis; \
                                        ReadMemoryExt = ReadMemoryUserMode; \
                                        WriteMemoryExt = WriteMemoryUserMode; \
                                    } \
                                    ULONG_PTR dwAddr = GetExpression(lpArgumentString); \

*/

#define ALLOC_SIZE 500
#define MAX_ARGS 4


// define our own operators new and delete, so that we do not have to include the crt

void * __cdecl
::operator new(unsigned int dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void __cdecl
::operator delete (void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}


BOOL
ReadMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return ReadProcessMemory( hProcess, pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
ReadMemoryKernelMode( HANDLE, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return ReadMemory( (ULONG) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
WriteMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return WriteProcessMemory( hProcess, (void*) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
WriteMemoryKernelMode( HANDLE, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return WriteMemory( (ULONG) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
GetData(IN DWORD dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    if (!fKernelDebug)
        {
        return ReadMemoryExt(ProcessHandle, (LPVOID) dwAddress, ptr, size, 0);
        }
        else {
        }

    while( size > 0 )
        {
        count = MIN( size, 3000 );

        b = ReadMemoryExt(ProcessHandle, (LPVOID)  dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count )
            {
            if (NULL == type)
                {
                type = "unspecified" ;
                }
            dprintf("Couldn't read memory with error %d\n", GetLastError());
             
            return FALSE;
            }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
        }

    return TRUE;
}

#define MAX_MESSAGE_BLOCK_SIZE 1024
#define BLOCK_SIZE 2
// could have been bigger but hit the boundary case once.

WCHAR *ReadProcessChar(
    unsigned short * Address
    )
{
    DWORD dwAddr = (DWORD) Address;

    char       block[BLOCK_SIZE];
    WCHAR     *Block  = (WCHAR *)&block;
    char      *string_block = new char[MAX_MESSAGE_BLOCK_SIZE];
    WCHAR     *String = (WCHAR *)string_block;
    int        length = 0;
    int        i      = 0;
    BOOL       b;
    BOOL       end    = FALSE;

    if (dwAddr == NULL) {
        return (L'\0');
    }

    for (length = 0; length < MAX_MESSAGE_BLOCK_SIZE/2; ) {
        b = GetData( dwAddr, &block, BLOCK_SIZE, NULL);
        if (b == FALSE) {
            dprintf("couldn't read address %x\n", dwAddr);
            return (L'\0');
        }
        for (i = 0; i < BLOCK_SIZE/2; i++) {
            if (Block[i] == L'\0') {
                end = TRUE;
            }
            String[length] = Block[i];
            length++;
        }
        if (end == TRUE) {
            break;
        }
        dwAddr += BLOCK_SIZE;
    }

    return (String);
}

PCHAR
MapSymbol(DWORD dwAddr)
{
    static CHAR Name[256];
    DWORD Displacement;

    GetSymbol((LPVOID)dwAddr, (UCHAR *)Name, &Displacement);
    strcat(Name, "+");
    PCHAR p = strchr(Name, '\0');
    _ltoa(Displacement, p, 16);
    return(Name);
}


DECLARE_API( help )
{
    INIT_DPRINTF();

    if (lpArgumentString[0] == '\0') {
        dprintf("\n"
                "regexts help:\n\n"
                "\n"
                "!keys    - Dumps stack for all open reg handles \n"
                "!version  - Dumps the version numbers \n"
                );
    }
}



BOOL   ChkTarget;            // is debuggee a CHK build?
#define VER_PRODUCTBUILD 10
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    fKernelDebug = TRUE;
    ReadMemoryExt = ReadMemoryKernelMode;
    WriteMemoryExt = WriteMemoryKernelMode;

    ExtensionApis = *lpExtensionApis ;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s SMB Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( keys )
{
    RegLeakTable* pLeakTable;

    INIT_DPRINTF();


    if (*lpArgumentString) {
        dprintf("Dump keys for table at %s\n", lpArgumentString);
        sscanf(lpArgumentString, "%lx", &pLeakTable);
    } else {
        dprintf("Dump keys for advapi32!gLeakTable\n");
        pLeakTable = (RegLeakTable*) GetExpression( "advapi32!gLeakTable" );

        if (!pLeakTable) {
            dprintf("Unable to resolve advapi32!gLeakTable\n"
                    "Please fix symbols or specify the address of a leak table"
                    "to !keys\n");
            return;
        } 
        
        dprintf("Dump keys for table at 0x%x\n", pLeakTable);
    }

    RegLeakTableDump(pLeakTable);
}

void RegLeakTableDump(RegLeakTable* pLeakTable)
{
    TrackObjectData* pData;
    DWORD            ListHead;
    DWORD            cKeys;
    DWORD            KeysAddress;
    DWORD            dwFlags;
    DWORD            FlagsAddress;

    KeysAddress = ((DWORD) pLeakTable) + 4;
    FlagsAddress = ((DWORD) pLeakTable) + 8;

    if (!GetData(KeysAddress,
                 &cKeys,
                 sizeof(pLeakTable->cKeys),
                 NULL)) {
        dprintf("Error reading key count at 0x%x\n", KeysAddress);
        return;
    }

    dprintf("\tKeys = 0x%x\n", cKeys);

    if (!GetData(FlagsAddress,
                 &dwFlags,
                 sizeof(pLeakTable->pHead),
                 NULL)) {
        dprintf("Error reading list head at 0x%x\n", pLeakTable);
        return;
    }

    dprintf("\tFlags = 0x%x", dwFlags);

    switch (dwFlags) 
    {
    case LEAK_TRACK_FLAG_NONE:
        dprintf("\tNo tracking\n");
        return;

    case LEAK_TRACK_FLAG_USER:
        dprintf("\tOnly subkeys of HKEY_USERS\n");
        break;

    case LEAK_TRACK_FLAG_ALL:
        dprintf("\tAll keys\n");
        break;

    default:
        dprintf("\tInvalid flag -- table corrupt\n");
        return;
    }

    if (!GetData((DWORD)pLeakTable,
                 &ListHead,
                 sizeof(pLeakTable->pHead),
                 NULL)) {
        dprintf("Error reading list head at 0x%x\n", pLeakTable);
        return;
    }

    dprintf("\tList starts at 0x%x\n", ListHead);

    TrackObjectData* NextData;

    int ikey = 0;

    for (pData = (TrackObjectData*) ListHead;
         pData != NULL;
         pData = NextData)
    {
        dprintf("\tObject at 0x%x", pData);

        TrackObjectDataPrint(pData);

        if (!GetData((DWORD) pData, &NextData, sizeof(NextData), NULL)) {
            dprintf("Error reading next link for object at 0x%x\n", pData);
            return;
        }
    }
}


void TrackObjectDataPrint(TrackObjectData* pKeyData)
{
    NTSTATUS           Status;
    DWORD              dwStackDepth;
    DWORD              StackAddress;
    HKEY               hKey;
    DWORD              hKeyAddress;
    DWORD              StackDepthAddress;
    PVOID*             rgStack;
    DWORD              pStack;

    hKeyAddress = ((DWORD) pKeyData) + 8;
    StackDepthAddress = ((DWORD) pKeyData) + 12;

    rgStack = NULL;

    if (!GetData(hKeyAddress, &hKey, sizeof(hKey), NULL)) {
        dprintf("Error reading hkey for object at 0x%x\n", pKeyData);
        return;
    }

    dprintf("Tracked key data for object 0x%x\n", hKey);

    if (!fKernelDebug) 
        (void) PrintObjectInfo(hKey);
    else
        dprintf("!!!!!!Broken into kd. do '!handle 0x%x f' for details of the handle\n", hKey);

    if (!GetData(StackDepthAddress, &dwStackDepth, sizeof(dwStackDepth), NULL)) {
        dprintf("Error reading key object at 0x%x\n", pKeyData);
        return;
    }

    if (!dwStackDepth) {
        dprintf("\t\tNo stack data\n");
        return;
    }

    dprintf("\t\tStack depth 0x%x\n", dwStackDepth);

    StackAddress = ((DWORD) (pKeyData)) + 16;

    if (!GetData(StackAddress,
                 &pStack,
                 sizeof(PVOID),
                 NULL)) {
        dprintf("Error reading stack frames at 0x%x\n", StackAddress);
        return;
    } 
    dprintf("\t\tStack frames at 0x%x\n", pStack);

    rgStack = (PVOID*) RtlAllocateHeap(
        RtlProcessHeap(),
        0,
        sizeof(*rgStack) * dwStackDepth);

    if (!rgStack) {
        return;
    }

    if (!GetData(pStack,
                 rgStack,
                 sizeof(*rgStack) * dwStackDepth,
                 NULL)) {
        dprintf("Error reading stack frames at 0x%x\n", StackAddress);
        RtlFreeHeap(RtlProcessHeap(), 0, rgStack);
        return;
    } 

    for (int iFrame = 0; iFrame < dwStackDepth; iFrame++)
    {
        UCHAR Symbol[MAX_SYMBOL_LENGTH];
        DWORD_PTR Displacement;

        *Symbol = L'\0';

        GetSymbol(
            rgStack[iFrame],
            Symbol,
            &Displacement);

        dprintf("\t\t0x%x", rgStack[iFrame]);

        if (*Symbol) {
            dprintf("\t %s", Symbol);
            
            if (Displacement) {
                dprintf("+0x%x", Displacement);
            }
        } else {
            dprintf("\t ????????");
        }

        dprintf("\n");
    }

    if (rgStack) {
        RtlFreeHeap(RtlProcessHeap(), 0, rgStack);
    }

    dprintf("\n");
}


NTSTATUS PrintObjectInfo(HANDLE Handle)
{

    POBJECT_NAME_INFORMATION pNameInfo;
    BYTE     rgNameInfoBuf[512];
    NTSTATUS Status;
    HKEY     hkDup;
    DWORD    dwRequired;

    Status = NtDuplicateObject(
        ProcessHandle,
        Handle,
        NtCurrentProcess(),
        (PHANDLE) &hkDup,
        0,
        FALSE,
        DUPLICATE_SAME_ACCESS);

    if (!NT_SUCCESS(Status)) {
        dprintf("Unable to duplicate handle 0x%x from process handle 0x%x, error 0x%x\n", 
                Handle,
                ProcessHandle,
                Status);
        return Status;
    }
        
    pNameInfo = (POBJECT_NAME_INFORMATION) rgNameInfoBuf;

    Status = NtQueryObject(
        hkDup,
        ObjectNameInformation,
        pNameInfo,
        sizeof(pNameInfo),
        &dwRequired);

    if (!NT_SUCCESS(Status)) {

        if (STATUS_INFO_LENGTH_MISMATCH == Status) {

            Status = STATUS_NO_MEMORY;

            pNameInfo = (POBJECT_NAME_INFORMATION) RtlAllocateHeap(
                RtlProcessHeap(),
                0,
                dwRequired);
            
            if (pNameInfo) {

                Status = NtQueryObject(
                    hkDup,
                    ObjectNameInformation,
                    pNameInfo,
                    dwRequired,
                    &dwRequired);
            }

        }
    }


    if (!NT_SUCCESS(Status)) {
        dprintf("Unable to query object information for object error 0x%x\n",
                Status);
    } else {
        dprintf("Object 0x%x\n\tName: %S\n", Handle, pNameInfo->Name.Buffer);
    }

    NtClose(hkDup);

    if ((PBYTE) pNameInfo != rgNameInfoBuf) {
        RtlFreeHeap(RtlProcessHeap(), 0, pNameInfo);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\cntrtext\unlodctr\unlodctr.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    unlodctr.c

Abstract:

    Program to remove the counter names belonging to the driver specified
        in the command line and update the registry accordingly

Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  Windows Include files
//
#include <windows.h>
#include <tchar.h>
#include <loadperf.h>

int
__cdecl main(
    int argc,
    char *argv[]
)
/*++

main

    entry point to Counter Name Unloader



Arguments

    argc
        # of command line arguments present

    argv
        array of pointers to command line strings

    (note that these are obtained from the GetCommandLine function in
    order to work with both UNICODE and ANSI strings.)

ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{

    LPTSTR  lpCommandLine;

    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);

    lpCommandLine = GetCommandLine(); // get command line

    return (int)UnloadPerfCounterTextStrings (
        lpCommandLine,
        FALSE);     // show text strings to console
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\lib\support.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    Support.c

Abstract:

    This module contains support routines for the Win32 Registry API.

Author:

    David J. Gilman (davegi) 15-Nov-1991

--*/

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains a routine for converting NT status codes
    to DOS/OS|2 error codes.

Author:

    David Treadwell (davidtr)   04-Apr-1991

Revision History:

--*/

#include <rpc.h>
#include "regrpc.h"
#include <stdio.h>



LONG
MapSAToRpcSA (
    IN LPSECURITY_ATTRIBUTES lpSA,
    OUT PRPC_SECURITY_ATTRIBUTES lpRpcSA
    )

/*++

Routine Description:

    Maps a SECURITY_ATTRIBUTES structure to a RPC_SECURITY_ATTRIBUTES
    structure by converting the SECURITY_DESCRIPTOR to a form where it can
    be marshalled/unmarshalled.

Arguments:

    lpSA - Supplies a pointer to the SECURITY_ATTRIBUTES structure to be
        converted.

    lpRpcSA - Supplies a pointer to the converted RPC_SECURITY_ATTRIBUTES
        structure.  The caller should free (using RtlFreeHeap) the field
        lpSecurityDescriptor when its finished using it.

Return Value:

    LONG - Returns ERROR_SUCCESS if the SECURITY_ATTRIBUTES is
        succesfully mapped.

--*/

{
    LONG    Error;

    ASSERT( lpSA != NULL );
    ASSERT( lpRpcSA != NULL );

    //
    // Map the SECURITY_DESCRIPTOR to a RPC_SECURITY_DESCRIPTOR.
    //
    lpRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor = NULL;

    if( lpSA->lpSecurityDescriptor != NULL ) {
        Error = MapSDToRpcSD(
                    lpSA->lpSecurityDescriptor,
                    &lpRpcSA->RpcSecurityDescriptor
                    );
    } else {
        lpRpcSA->RpcSecurityDescriptor.cbInSecurityDescriptor = 0;
        lpRpcSA->RpcSecurityDescriptor.cbOutSecurityDescriptor = 0;
        Error = ERROR_SUCCESS;
    }

    if( Error == ERROR_SUCCESS ) {

        //
        //
        // The supplied SECURITY_DESCRIPTOR was successfully converted
        // to self relative format so assign the remaining fields.
        //

        lpRpcSA->nLength = lpSA->nLength;

        lpRpcSA->bInheritHandle = ( BOOLEAN ) lpSA->bInheritHandle;
    }

    return Error;
}

LONG
MapSDToRpcSD (
    IN  PSECURITY_DESCRIPTOR lpSD,
    IN OUT PRPC_SECURITY_DESCRIPTOR lpRpcSD
    )

/*++

Routine Description:

    Maps a SECURITY_DESCRIPTOR to a RPC_SECURITY_DESCRIPTOR by converting
    it to a form where it can be marshalled/unmarshalled.

Arguments:

    lpSD - Supplies a pointer to the SECURITY_DESCRIPTOR
        structure to be converted.

    lpRpcSD - Supplies a pointer to the converted RPC_SECURITY_DESCRIPTOR
        structure. Memory for the security descriptor is allocated if
        not provided. The caller must take care of freeing up the memory
        if necessary.

Return Value:

    LONG - Returns ERROR_SUCCESS if the SECURITY_DESCRIPTOR is
        succesfully mapped.

--*/

{
    DWORD   cbLen;


    ASSERT( lpSD != NULL );
    ASSERT( lpRpcSD != NULL );

    if( RtlValidSecurityDescriptor( lpSD )) {

        cbLen = RtlLengthSecurityDescriptor( lpSD );
        ASSERT( cbLen > 0 );

        //
        //  If we're not provided a buffer for the security descriptor,
        //  allocate it.
        //
        if ( !lpRpcSD->lpSecurityDescriptor ) {

            //
            // Allocate space for the converted SECURITY_DESCRIPTOR.
            //
            lpRpcSD->lpSecurityDescriptor =
                 ( PBYTE ) RtlAllocateHeap(
                                RtlProcessHeap( ), 0,
                                cbLen
                                );

            //
            // If the memory allocation failed, return.
            //
            if( lpRpcSD->lpSecurityDescriptor == NULL ) {
                return ERROR_OUTOFMEMORY;
            }

            lpRpcSD->cbInSecurityDescriptor = cbLen;

        } else {

            //
            //  Make sure that the buffer provided is big enough
            //
            if ( lpRpcSD->cbInSecurityDescriptor < cbLen ) {
                return ERROR_OUTOFMEMORY;
            }
        }

        //
        //  Set the size of the transmittable buffer
        //
        lpRpcSD->cbOutSecurityDescriptor = cbLen;

        //
        // Convert the supplied SECURITY_DESCRIPTOR to self relative form.
        //

        return RtlNtStatusToDosError(
            RtlMakeSelfRelativeSD(
                        lpSD,
                        lpRpcSD->lpSecurityDescriptor,
                        &lpRpcSD->cbInSecurityDescriptor
                        )
                    );
    } else {

        //
        // The supplied SECURITY_DESCRIPTOR is invalid.
        //

        return ERROR_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\local\regleak.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regleak.h

Abstract:

    This file contains declarations for data structures
    needed for tracking win32 registry leaks

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

--*/

#ifdef LOCAL

#include "winver.h"

#if !defined(_REGLEAK_H_)
#define _REGLEAK_H_

#ifdef LEAK_TRACK

#include "imagehlp.h"

#define MAX_LEAK_STACK_DEPTH 40
#define SYM_PATH_MAX_SIZE    1000

typedef struct _TrackObjectData 
{
    LIST_ENTRY Links;
    HKEY       hKey;
    DWORD      dwStackDepth;
    PVOID*     rgStack;
} TrackObjectData;

void     TrackObjectDataPrint(TrackObjectData* pKeyData);
NTSTATUS TrackObjectDataInit(TrackObjectData* pKeyData, PVOID* rgStack, DWORD dwMaxStackDepth, HKEY hKey);
NTSTATUS TrackObjectDataClear(TrackObjectData* pKeyData);

NTSTATUS GetLeakStack(PVOID** prgStack, DWORD* pdwMaxDepth, DWORD dwMaxDepth);

enum
{
    LEAK_TRACK_FLAG_NONE = 0,
    LEAK_TRACK_FLAG_USER = 1,
    LEAK_TRACK_FLAG_ALL = 0xFFFFFFFF
};

typedef struct _RegLeakTable
{
    TrackObjectData*       pHead;
    DWORD                  cKeys;
    DWORD                  dwFlags;
    BOOL                   bCriticalSectionInitialized;
    RTL_CRITICAL_SECTION   CriticalSection;

} RegLeakTable;


typedef struct _RegLeakTraceInfo {
    DWORD   dwMaxStackDepth;
    LPTSTR  szSymPath;
    BOOL    bEnableLeakTrack;    
    RTL_CRITICAL_SECTION   StackInitCriticalSection;
} RegLeakTraceInfo;

extern RegLeakTraceInfo g_RegLeakTraceInfo;


NTSTATUS RegLeakTableInit(RegLeakTable* pLeakTable, DWORD dwFlags);
NTSTATUS RegLeakTableClear(RegLeakTable* pLeakTable);
NTSTATUS RegLeakTableAddKey(RegLeakTable* pLeakTable, HKEY hKey);
NTSTATUS RegLeakTableRemoveKey(RegLeakTable* pLeakTable, HKEY hKey);

BOOL RegLeakTableIsEmpty(RegLeakTable* pLeakTable);
BOOL RegLeakTableIsTrackedObject(RegLeakTable* pLeakTable, HKEY hKey);

NTSTATUS TrackObject(HKEY hKey);
BOOL     InitializeLeakTrackTable();
BOOL     CleanupLeakTrackTable();
NTSTATUS UnTrackObject(HKEY hKey);

extern RegLeakTable gLeakTable;


#endif // LEAK_TRACK
#endif // _REGLEAK_H_
#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\local\regleak.c ===
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegLeak.h

Abstract:

    This module contains helper functions for tracking
n    win32 registry leaks

Author:

    Adam Edwards (adamed) 06-May-1998

--*/


#ifdef LOCAL
#ifdef LEAK_TRACK

#include "ntverp.h"
#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "stkwalk.h"
#include "regleak.h"
#include <malloc.h>

RegLeakTable gLeakTable;
RegLeakTraceInfo g_RegLeakTraceInfo;


void     TrackObjectDataPrint(TrackObjectData* pKeyData)
{
    NTSTATUS       Status;
    SKeySemantics  keyinfo;
    UNICODE_STRING EmptyString = {0, 0, 0};
    BYTE           rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(KEY_NAME_INFORMATION)];

    DbgPrint("WINREG: Tracked key data for object 0x%x\n", pKeyData->hKey);

    //
    // Set buffer to store info about this key
    //
    keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
    keyinfo._cbFullPath = sizeof(rgNameBuf);

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(pKeyData->hKey, &EmptyString, &keyinfo);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("WINREG: Unable to retrieve object name error 0x%x\n", Status);
    } else {
        DbgPrint("WINREG: Name: %S\n", keyinfo._pFullPath->Name);
    }

    BaseRegReleaseKeySemantics(&keyinfo);

    DbgPrint("Frames %d", pKeyData->dwStackDepth);

    {
        DWORD iFrame;

        for (iFrame = 0; iFrame < pKeyData->dwStackDepth; iFrame++) 
        {
            DbgPrint("WINREG: Frame %d = 0x%x\n", iFrame, pKeyData->rgStack[iFrame]);
        }
    }
    DbgPrint("\n");

}

NTSTATUS TrackObjectDataInit(TrackObjectData* pKeyData, PVOID* rgStack, DWORD dwMaxStackDepth, HKEY hKey)
{
    RtlZeroMemory(pKeyData, sizeof(*pKeyData));
    
    pKeyData->hKey = REG_CLASS_RESET_SPECIAL_KEY(hKey);
  
    pKeyData->dwStackDepth = dwMaxStackDepth;
    pKeyData->rgStack = rgStack;

    return STATUS_SUCCESS;
}

NTSTATUS TrackObjectDataClear(TrackObjectData* pKeyData)
{
    if (pKeyData->rgStack) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyData->rgStack);
        pKeyData->rgStack = NULL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS RegLeakTableInit(RegLeakTable* pLeakTable, DWORD dwFlags)
{
    NTSTATUS Status;

    RtlZeroMemory(pLeakTable, sizeof(*pLeakTable));
    
    pLeakTable->dwFlags = dwFlags;

    Status = RtlInitializeCriticalSection(
                    &(pLeakTable->CriticalSection));

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Remember that we have initialized this critical section
    // so we can remember to delete it.
    //

    pLeakTable->bCriticalSectionInitialized = TRUE;

    Status = RtlInitializeCriticalSection(
                    &(g_RegLeakTraceInfo.StackInitCriticalSection));

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS RegLeakTableClear(RegLeakTable* pLeakTable)
{
    NTSTATUS Status;

#if defined(DBG) // LEAK_TRACK
    DbgPrint("WINREG: Leak data for process id 0x%x\n", NtCurrentTeb()->ClientId.UniqueProcess);
    DbgPrint("WINREG: Keys Leaked 0x%x\n", pLeakTable->cKeys);
#endif // LEAK_TRACK

    Status = RtlDeleteCriticalSection(
        &(pLeakTable->CriticalSection));

    ASSERT(NT_SUCCESS(Status));

    Status = RtlDeleteCriticalSection(
        &(g_RegLeakTraceInfo.StackInitCriticalSection));

        
    ASSERT(NT_SUCCESS(Status));
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlDeleteCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
    }
#endif

    {
        DWORD cKeys;

        cKeys = 0;

        for (;;) 
        {
            if (!(pLeakTable->pHead)) {
                break;
            }
            TrackObjectDataPrint(pLeakTable->pHead);

            cKeys++;

            (void) RegLeakTableRemoveKey(pLeakTable, pLeakTable->pHead->hKey);
        }

#if defined(DBG) // LEAK_TRACK
        DbgPrint("WINREG: 0x%x total keys leaked\n", cKeys);
#endif // LEAK_TRACK
    }

    return STATUS_SUCCESS;
}

NTSTATUS RegLeakTableAddKey(RegLeakTable* pLeakTable, HKEY hKey)
{
    NTSTATUS           Status;
    TrackObjectData*   pNewData;
    PVOID*             rgStack;
    DWORD              dwMaxStackDepth;

    rgStack = NULL;
    dwMaxStackDepth = 0;

    hKey = REG_CLASS_RESET_SPECIAL_KEY(hKey);

    if (!RegLeakTableIsTrackedObject(pLeakTable, hKey)) {
        return STATUS_SUCCESS;
    }

    (void) GetLeakStack(
        &rgStack,
        &dwMaxStackDepth,
        g_RegLeakTraceInfo.dwMaxStackDepth);

    Status = RtlEnterCriticalSection(&(pLeakTable->CriticalSection));
    
    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
#endif
        return Status;
    }
    
    pNewData = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(*pNewData));

    if (!pNewData) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    Status = TrackObjectDataInit(pNewData, rgStack, dwMaxStackDepth, hKey);

    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (!RegLeakTableIsEmpty(pLeakTable)) {
        
        pNewData->Links.Flink = (PLIST_ENTRY) pLeakTable->pHead;
        pLeakTable->pHead->Links.Blink = (PLIST_ENTRY) pNewData;

    }

    pLeakTable->pHead = pNewData;

    pLeakTable->cKeys++;

cleanup:    
    {
        NTSTATUS Status;

        Status = RtlLeaveCriticalSection(&(pLeakTable->CriticalSection));

        ASSERT( NT_SUCCESS( Status ) );
#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
        }
#endif
    }

    return Status;
}

NTSTATUS RegLeakTableRemoveKey(RegLeakTable* pLeakTable, HKEY hKey)
{
    NTSTATUS         Status;
    TrackObjectData* pData;

    Status = RtlEnterCriticalSection(&(pLeakTable->CriticalSection));
    
    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
#endif
        return Status;
    }
    

    hKey = REG_CLASS_RESET_SPECIAL_KEY(hKey);

    for (pData = pLeakTable->pHead; 
         pData != NULL;
         pData = (TrackObjectData*) pData->Links.Flink)
    {
        if (hKey == pData->hKey) {
            
            PLIST_ENTRY pFlink;
            PLIST_ENTRY pBlink;
            
            pBlink = pData->Links.Blink;
            pFlink = pData->Links.Flink;

            if (pBlink) {
                pBlink->Flink = pFlink;
            }

            if (pFlink) {
                pFlink->Blink = pBlink;
            }

            if (pData == pLeakTable->pHead) {
                pLeakTable->pHead = (TrackObjectData*) pFlink;
            }

            (void) TrackObjectDataClear(pData);

            RtlFreeHeap(RtlProcessHeap(), 0, pData);

            pLeakTable->cKeys--;

            goto cleanup;
        }
    }

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

cleanup:    

    {
        NTSTATUS Status;

        Status = RtlLeaveCriticalSection(&(pLeakTable->CriticalSection));

        ASSERT( NT_SUCCESS( Status ) );
#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
        }
#endif
    }

    return Status;
}

BOOL RegLeakTableIsEmpty(RegLeakTable* pLeakTable)
{
    return pLeakTable->pHead == NULL;
}

BOOL RegLeakTableIsTrackedObject(RegLeakTable* pLeakTable, HKEY hKey)
{
    NTSTATUS       Status;
    SKeySemantics  keyinfo;
    UNICODE_STRING EmptyString = {0, 0, 0};
    BYTE           rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(KEY_NAME_INFORMATION)];
    BOOL           fTrackObject;

    fTrackObject = FALSE;

    if (LEAK_TRACK_FLAG_ALL == pLeakTable->dwFlags) {
        return TRUE;
    }

    if (LEAK_TRACK_FLAG_NONE == pLeakTable->dwFlags) {
        return FALSE;
    }
    
    //
    // Set buffer to store info about this key
    //
    keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
    keyinfo._cbFullPath = sizeof(rgNameBuf);

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(hKey, &EmptyString, &keyinfo);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (LEAK_TRACK_FLAG_USER & pLeakTable->dwFlags) {

        WCHAR UserChar;

        UserChar = keyinfo._pFullPath->Name[REG_CLASSES_FIRST_DISTINCT_ICH];

        if ((L'U' == UserChar) || (L'u' == UserChar)) {
            fTrackObject = TRUE;
        }
    }

    BaseRegReleaseKeySemantics(&keyinfo);

    return fTrackObject;

}

NTSTATUS TrackObject(HKEY hKey)
{
    return RegLeakTableAddKey(&gLeakTable, hKey);
}

#define WINLOGON_KEY            L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define LEAKTRACK_VALUE         L"LeakTrack"
#define DEFAULT_VALUE_SIZE          128

void ReadRegLeakTrackInfo()
{
    LPTSTR                          lpWinlogonKey;
    LONG                            error;
    OBJECT_ATTRIBUTES               Attributes;
    NTSTATUS                        Status;
    HKEY                            hKey;
    UNICODE_STRING                  uWinlogonPath;
    UNICODE_STRING                  uValueName;

    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;
    PVOID                           KeyValueInformation;

    BYTE                            PrivateKeyValueInformation[ sizeof( KEY_VALUE_PARTIAL_INFORMATION) +
                                        DEFAULT_VALUE_SIZE ];
    ULONG                           BufferLength;
    ULONG                           ResultLength;

    //
    // Look in the registry whether tracking is enabled uder
    // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion\Winlogon
    //

    memset(&g_RegLeakTraceInfo, 0, sizeof(g_RegLeakTraceInfo));

    g_RegLeakTraceInfo.bEnableLeakTrack = 0;
 
    RtlInitUnicodeString(&uWinlogonPath, WINLOGON_KEY);
 
    InitializeObjectAttributes(&Attributes,
                              &uWinlogonPath,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);


    Status = NtOpenKey( &hKey,
                      KEY_READ,
                      &Attributes );


    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&uValueName, LEAKTRACK_VALUE);

        KeyValueInformationClass = KeyValuePartialInformation;

        KeyValueInformation = PrivateKeyValueInformation;
        BufferLength = sizeof( PrivateKeyValueInformation );

        Status = NtQueryValueKey( hKey,
                                  &uValueName,
                                  KeyValueInformationClass,
                                  KeyValueInformation,
                                  BufferLength,
                                  &ResultLength );


       //
       // if it succeeded and the datalength is greater than zero
       // check whether it is non-zero
       //

       if ((NT_SUCCESS(Status)) && 
           (((PKEY_VALUE_PARTIAL_INFORMATION )KeyValueInformation )->DataLength)) {

            if (((( PKEY_VALUE_PARTIAL_INFORMATION )KeyValueInformation)->Data) && 
            (*((( PKEY_VALUE_PARTIAL_INFORMATION )KeyValueInformation)->Data)))
                g_RegLeakTraceInfo.bEnableLeakTrack = 1;
       }

       NtClose(hKey);

    }
//    g_RegLeakTraceInfo.bEnableLeakTrack = GetProfileInt(TEXT("RegistryLeak"), TEXT("Enable"), 0);
}


BOOL InitializeLeakTrackTable()
{
    ReadRegLeakTrackInfo();
    
    if (g_RegLeakTraceInfo.bEnableLeakTrack)
        return NT_SUCCESS(RegLeakTableInit(&gLeakTable, LEAK_TRACK_FLAG_USER));
    else
        return TRUE;
}

BOOL CleanupLeakTrackTable()
{
    BOOL fSuccess;

    if (!g_RegLeakTraceInfo.bEnableLeakTrack)
        return TRUE;

    //
    // if leak_tracking is not enabled, quit quickly.
    //
    
    fSuccess = NT_SUCCESS(RegLeakTableClear(&gLeakTable));

    (void) StopDebug();

    return fSuccess;
}

NTSTATUS UnTrackObject(HKEY hKey)
{
    return RegLeakTableRemoveKey(&gLeakTable, hKey);
}

NTSTATUS GetLeakStack(PVOID** prgStack, DWORD* pdwMaxDepth, DWORD dwMaxDepth)
{

    PCALLER_SYM pStack;
    DWORD       dwDepth;

    pStack = (PCALLER_SYM) RtlAllocateHeap(
        RtlProcessHeap(),
        0,
        dwMaxDepth * sizeof(*pStack));

    if (!pStack) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(pStack, sizeof(*pStack) * dwMaxDepth);

   *prgStack = RtlAllocateHeap(
        RtlProcessHeap(),
        0,
        dwMaxDepth * sizeof(*(*prgStack)));

    if (!*prgStack) {
        RtlFreeHeap(RtlProcessHeap(),
                    0,
                    pStack);

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(*prgStack, sizeof(*(*prgStack)) * dwMaxDepth);

    GetCallStack(
        pStack,
        4,
        dwMaxDepth,
        FALSE);

    for (dwDepth = 0; dwDepth < dwMaxDepth; dwDepth++) 
    {
        if (!(pStack[dwDepth].Addr)) {
            break;
        }

        (*prgStack)[dwDepth] = pStack[dwDepth].Addr;

    }

    *pdwMaxDepth = dwDepth;

    RtlFreeHeap(
        RtlProcessHeap(),
        0,
        pStack);

    return STATUS_SUCCESS;
}


#endif // DBG
#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\local\stkwalk.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    stkwalk.c

Abstract:

    This module contains memory debug routines for catching memory leaks and memory
    overwrites.

Author:
    Stolen from dbgmem.c
    Jim Stewart/Ramesh Pabbati    January 8, 1996

    Fixed up for regleaks
    UShaji                        Dec 11th,  1998

Revision History:

--*/

#ifdef LOCAL
#ifdef LEAK_TRACK

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include<imagehlp.h>
#include "regleak.h"
#include "stkwalk.h"
DWORD   MachineType;            // the architecutre we are on
HANDLE  OurProcess;             // the process that we are running as a part of



// typedefs from imagehlp.dll

typedef BOOL (WINAPI * PFNSYMINITIALIZE)(HANDLE hProcess,
                                         PSTR UserSearchPath,
                                         BOOL fInvadeProcess);

typedef BOOL (WINAPI * PFNSYMCLEANUP)(HANDLE hProcess);

typedef BOOL (WINAPI * PFNSTACKWALK)(DWORD MachineType,
                                  HANDLE hProcess,
                                  HANDLE hThread,
                                  LPSTACKFRAME StackFrame,
                                  PVOID ContextRecord,
                                  PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
                                  PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
                                  PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
                                  PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);

typedef BOOL (WINAPI * PFNSYMGETSYMFROMADDR)(HANDLE hProcess,
                                             DWORD_PTR Address,
                                             PDWORD_PTR Displacement,
                                             PIMAGEHLP_SYMBOL Symbol);


typedef DWORD_PTR (WINAPI * PFNSYMGETMODULEBASE)(HANDLE hProcess,
                                          DWORD_PTR dwAddr);


typedef PVOID (WINAPI * PFNSYMFUNCTIONTABLEACCESS)(HANDLE hProcess,
                                                DWORD_PTR AddrBase);


// imagehlp function pointers

PFNSYMINITIALIZE            g_pfnSymInitialize=NULL;
PFNSYMCLEANUP               g_pfnSymCleanup=NULL;
PFNSTACKWALK                g_pfnStackWalk=NULL;
PFNSYMGETSYMFROMADDR        g_pfnSymGetSymFromAddr=NULL;
PFNSYMFUNCTIONTABLEACCESS   g_pfnSymFunctionTableAccess=NULL;
PFNSYMGETMODULEBASE         g_pfnSymGetModuleBase=NULL;

HINSTANCE                   g_hImagehlpInstance=NULL;


BOOL fDebugInitialised = FALSE;


BOOL
InitDebug(
    );


DWORD GetStack(
    IN EXCEPTION_POINTERS *exp,
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind,
    IN int           fResolveSymbols
    );

BOOL LoadImageHLP()
{

   g_hImagehlpInstance = LoadLibrary ("imagehlp.dll");

   if (!g_hImagehlpInstance) {
        return FALSE;
   }


   g_pfnSymInitialize = (PFNSYMINITIALIZE) GetProcAddress (g_hImagehlpInstance,
                                                           "SymInitialize");
   if (!g_pfnSymInitialize) {
        return FALSE;
   }

   g_pfnSymCleanup = (PFNSYMCLEANUP) GetProcAddress (g_hImagehlpInstance,
                                                           "SymCleanup");
   if (!g_pfnSymCleanup) {
        return FALSE;
   }


   g_pfnStackWalk = (PFNSTACKWALK) GetProcAddress (g_hImagehlpInstance,
                                                           "StackWalk");
   if (!g_pfnStackWalk) {
        return FALSE;
   }


   g_pfnSymGetSymFromAddr = (PFNSYMGETSYMFROMADDR) GetProcAddress (g_hImagehlpInstance,
                                                           "SymGetSymFromAddr");
   if (!g_pfnSymGetSymFromAddr) {
        return FALSE;
   }


   g_pfnSymFunctionTableAccess = (PFNSYMFUNCTIONTABLEACCESS) GetProcAddress (g_hImagehlpInstance,
                                                           "SymFunctionTableAccess");
   if (!g_pfnSymFunctionTableAccess) {
        return FALSE;
   }


   g_pfnSymGetModuleBase = (PFNSYMGETMODULEBASE) GetProcAddress (g_hImagehlpInstance,
                                                           "SymGetModuleBase");
   if (!g_pfnSymGetModuleBase) {
        return FALSE;
   }

   return TRUE;
}


BOOL
InitDebug(
    )
/*++

Description:

    This routine initializes the debug memory functionality.

Arguments:

    none

Return Value:

    BOOL - pass or fail

--*/
{
    BOOL        status;
    SYSTEM_INFO SysInfo;

    if (fDebugInitialised)
        return TRUE;

    status = RtlEnterCriticalSection(&(g_RegLeakTraceInfo.StackInitCriticalSection));
    ASSERT( NT_SUCCESS( status ) );

    if (fDebugInitialised)
        return TRUE;

    OurProcess = GetCurrentProcess();



    g_RegLeakTraceInfo.szSymPath = (LPTSTR) RtlAllocateHeap(
                                                            RtlProcessHeap(),
                                                            0,
                                                            SYM_PATH_MAX_SIZE*sizeof(TCHAR));


    if (!g_RegLeakTraceInfo.szSymPath) {
        // looks like machine already doesn't have enough memory
        // disable leak tracking
        g_RegLeakTraceInfo.bEnableLeakTrack = 0;
        return FALSE;
    }

    g_RegLeakTraceInfo.dwMaxStackDepth = GetProfileInt(TEXT("RegistryLeak"), TEXT("StackDepth"), MAX_LEAK_STACK_DEPTH);
    GetProfileString(TEXT("RegistryLeak"), TEXT("SymbolPath"), TEXT(""), g_RegLeakTraceInfo.szSymPath, SYM_PATH_MAX_SIZE);


    if (!(*g_RegLeakTraceInfo.szSymPath)) {

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            g_RegLeakTraceInfo.szSymPath);

            g_RegLeakTraceInfo.szSymPath = NULL;
    }


    if (!LoadImageHLP()) {
        g_RegLeakTraceInfo.bEnableLeakTrack = FALSE;
        status = RtlLeaveCriticalSection(&(g_RegLeakTraceInfo.StackInitCriticalSection));
        return FALSE;
    }

    GetSystemInfo( &SysInfo );
    switch (SysInfo.wProcessorArchitecture) {

    default:
    case PROCESSOR_ARCHITECTURE_INTEL:
        MachineType = IMAGE_FILE_MACHINE_I386;
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        //
        // note this may not detect R10000 machines correctly
        //
        MachineType = IMAGE_FILE_MACHINE_R4000;
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        MachineType = IMAGE_FILE_MACHINE_ALPHA;
        break;

    case PROCESSOR_ARCHITECTURE_PPC:
        MachineType = IMAGE_FILE_MACHINE_POWERPC;
        break;

    }


    // symbols from Current directory/Environment variable _NT_SYMBOL_PATH
    // Environment variable _NT_ALTERNATE_SYMBOL_PATH or Environment variable SYSTEMROOT

    status = g_pfnSymInitialize ( OurProcess, g_RegLeakTraceInfo.szSymPath, FALSE );

    fDebugInitialised = TRUE;

    status = RtlLeaveCriticalSection(&(g_RegLeakTraceInfo.StackInitCriticalSection));
    return( TRUE );
}

BOOL
StopDebug()
{
    if (fDebugInitialised) {

        BOOL fSuccess;

        fSuccess = g_pfnSymCleanup(OurProcess);

        fDebugInitialised = FALSE;

        FreeLibrary(g_hImagehlpInstance);

        if (g_RegLeakTraceInfo.szSymPath) {
            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                g_RegLeakTraceInfo.szSymPath);
        }

        return fSuccess;
    }
    return TRUE;
}

BOOL
ReadMem(
    IN HANDLE   hProcess,
    IN LPCVOID  BaseAddr,
    IN LPVOID   Buffer,
    IN DWORD    Size,
    IN LPDWORD  NumBytes )
/*++

Description:

    This is a callback routine that StackWalk uses - it just calls teh system ReadProcessMemory
    routine with this process's handle

Arguments:


Return Value:

    none

--*/

{
    BOOL    status;
    SIZE_T  RealNumberBytesRead;

    status = ReadProcessMemory( GetCurrentProcess(),BaseAddr,Buffer,Size,&RealNumberBytesRead );
    *NumBytes = (DWORD)RealNumberBytesRead;

    return( status );
}


VOID
GetCallStack(
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind,
    IN int           fResolveSymbols
    )
/*++

Description:

    This routine walks te stack to find the return address of caller. The number of callers
    and the number of callers on top to be skipped can be specified.

Arguments:

    pdwCaller       array of DWORD to return callers
                    return addresses
    Skip            no. of callers to skip
    cFInd           no. of callers to find

Return Value:

    none

--*/
{

    if (!g_RegLeakTraceInfo.bEnableLeakTrack) {
        return;
    }

    if (!InitDebug()) {
        return;
    }

    __try {
        memset(Caller, 0, cFind * sizeof(CALLER_SYM));
        RaiseException(MY_DBG_EXCEPTION, 0, 0, NULL);
        // raise an exception to get the exception record to start the stack walk
        //
    }
    __except(GetStack(GetExceptionInformation(), Caller, Skip, cFind, fResolveSymbols)) {
    }
}

DWORD GetStack(
    IN EXCEPTION_POINTERS *exp,
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind,
    IN int           fResolveSymbols
    )
{
    BOOL             status;
    CONTEXT          ContextRecord;
    PUCHAR           Buffer[sizeof(IMAGEHLP_SYMBOL)-1 + MAX_FUNCTION_INFO_SIZE]; // symbol info
    PIMAGEHLP_SYMBOL Symbol = (PIMAGEHLP_SYMBOL)Buffer;
    STACKFRAME       StackFrame;
    INT              i;
    DWORD            Count;

    memcpy(&ContextRecord, exp->ContextRecord, sizeof(CONTEXT));

    ZeroMemory( &StackFrame,sizeof(STACKFRAME) );
    StackFrame.AddrPC.Segment = 0;
    StackFrame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
    StackFrame.AddrFrame.Offset = ContextRecord.Ebp;
    StackFrame.AddrFrame.Mode = AddrModeFlat;

    StackFrame.AddrStack.Offset = ContextRecord.Esp;
    StackFrame.AddrStack.Mode = AddrModeFlat;

    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Eip;
#elif defined(_M_MRX000)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Fir;
#elif defined(_M_ALPHA)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Fir;
#elif defined(_M_PPC)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Iar;
#endif

    Count = 0;
    for (i=0;i<cFind+Skip ;i++ ) {
        status = g_pfnStackWalk( MachineType,
            OurProcess,
            GetCurrentThread(),
            &StackFrame,
            (PVOID)&ContextRecord,
            (PREAD_PROCESS_MEMORY_ROUTINE)ReadMem,
            g_pfnSymFunctionTableAccess,
            g_pfnSymGetModuleBase,
            NULL );


        if (status) {
            if ( i >= Skip) {
                DWORD   Displacement;

                ZeroMemory( Symbol,sizeof(IMAGEHLP_SYMBOL)-1 + MAX_FUNCTION_INFO_SIZE );
                Symbol->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
                Symbol->Address = StackFrame.AddrPC.Offset;
                Symbol->MaxNameLength = MAX_FUNCTION_INFO_SIZE-1;
                Symbol->Flags = SYMF_OMAP_GENERATED;

                if (fResolveSymbols)
                    status = g_pfnSymGetSymFromAddr( OurProcess,StackFrame.AddrPC.Offset,(DWORD_PTR*)&Displacement,Symbol );

                //
                // save the name of the function and the displacement into it for later printing
                //

                Caller[Count].Addr = (PVOID)StackFrame.AddrPC.Offset;

                if (status) {
                    strcpy( Caller[Count].Buff,Symbol->Name );
                    Caller[Count].Displacement = Displacement;
                }
                Count++;
            }

        } else {
            break;
        }
    }

    return EXCEPTION_CONTINUE_EXECUTION;
    // done with exceptions
}

#endif // LEAK_TRACK
#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\common\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME    (TEXT("Perflib"))

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_NONE

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\datalogi.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datalogi.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Physical Disk Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datalogi.h"

// dummy variable for field sizing.
static LDISK_COUNTER_DATA   lcd;

//
//  Constant structure initializations 
//      defined in datalogi.h
//
LDISK_DATA_DEFINITION LogicalDiskDataDefinition = {

    {   0,
        sizeof(LDISK_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        LOGICAL_DISK_OBJECT_TITLE_INDEX,
        0,
        237,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(LDISK_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        5,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        408,
        0,
        409,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof (lcd.DiskFreeMbytes1),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskFreeMbytes1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        408,
        0,
        409,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_BASE,
        sizeof (lcd.DiskTotalMbytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTotalMbytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        410,
        0,
        411,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (lcd.DiskFreeMbytes2),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskFreeMbytes2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        198,
        0,
        199,
        0,
        1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (lcd.DiskCurrentQueueLength),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskCurrentQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        200,
        0,
        201,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (lcd.DiskTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        200,
        0,
        201,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (lcd.DiskTimeTimestamp),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTimeTimestamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1400,
        0,
        1401,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (lcd.DiskAvgQueueLength),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        202,
        0,
        203,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (lcd.DiskReadTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        202,
        0,
        203,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (lcd.DiskTimeTimestamp),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTimeTimestamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1402,
        0,
        1403,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (lcd.DiskReadQueueLength),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        204,
        0,
        205,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (lcd.DiskWriteTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWriteTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        204,
        0,
        205,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (lcd.DiskTimeTimestamp),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTimeTimestamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1404,
        0,
        1405,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (lcd.DiskWriteQueueLength),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWriteQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        206,
        0,
        207,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (lcd.DiskAvgTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        206,
        0,
        207,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskTransfersBase1),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTransfersBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        208,
        0,
        209,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (lcd.DiskAvgReadTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgReadTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        208,
        0,
        209,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskReadsBase1),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadsBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        210,
        0,
        211,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (lcd.DiskAvgWriteTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgWriteTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        210,
        0,
        211,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskWritesBase1),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWritesBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        212,
        0,
        213,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (lcd.DiskTransfers),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTransfers
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        214,
        0,
        215,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (lcd.DiskReads),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        216,
        0,
        217,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (lcd.DiskWrites),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWrites
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        218,
        0,
        219,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (lcd.DiskBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        220,
        0,
        221,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (lcd.DiskReadBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        222,
        0,
        223,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (lcd.DiskWriteBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        224,
        0,
        225,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (lcd.DiskAvgBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        224,
        0,
        225,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskTransfersBase2),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTransfersBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        226,
        0,
        227,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (lcd.DiskAvgReadBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        226,
        0,
        227,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskReadsBase2),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskReadsBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        228,
        0,
        229,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (lcd.DiskAvgWriteBytes),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskAvgWriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        228,
        0,
        229,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (lcd.DiskWritesBase2),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskWritesBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1482,
        0,
        1483,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_PRECISION_100NS_TIMER,
        sizeof (lcd.IdleTime),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->IdleTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1482,
        0,
        1483,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (lcd.DiskTimeTimestamp),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->DiskTimeTimestamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1484,
        0,
        1485,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (lcd.SplitCount),
        (DWORD)(ULONG_PTR)&((PLDISK_COUNTER_DATA)0)->SplitCount
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\local\stkwalk.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    stkwalk.h

Abstract:

    This module contains memory debug function prototypes and macros.

Author:

    Stolen from dbgmem.h
    Jim Stewart/Ramesh Pabbati    January 8, 1996

    Fixed up for regleaks
    UShaji                        Dev 11th,  1998

Revision History:

--*/

#ifdef LOCAL
#ifdef LEAK_TRACK

//
// define the amount of symbol info to keep per function in the stack trace.
//
#define MAX_FUNCTION_INFO_SIZE  40
typedef struct {

    DWORD   Displacement;                   // displacement into the function
    UCHAR   Buff[MAX_FUNCTION_INFO_SIZE];   // name of function on call stack
    PVOID   Addr;
    

} CALLER_SYM, *PCALLER_SYM;

BOOL
InitDebug(
    );

BOOL 
StopDebug();


VOID
GetCallStack(
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind,
    IN int           fResolveSymbols
    );

#define MY_DBG_EXCEPTION 3

extern BOOL fDebugInitialised;

#endif // LEAK_TRACK
#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\common\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

#include <windows.h>
#include <winperf.h>

#define MAX_INSTANCE_NAME   32
#define SMALL_BUFFER_SIZE   ((DWORD)4096)
#define MEDIUM_BUFFER_SIZE  ((DWORD)(4096*8))
#define LARGE_BUFFER_SIZE   ((DWORD)(4096*16))
#define INCREMENT_BUFFER_SIZE ((DWORD)(4096*2))

#define MAX_VALUE_NAME_LENGTH 256*sizeof(WCHAR)
#define MAX_VALUE_DATA_LENGTH 256*sizeof(WCHAR)
//
//  Until USER supports Unicode, we have to work in ASCII:
//

#define DEFAULT_NT_CODE_PAGE 437
#define UNICODE_CODE_PAGE      0

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
//  Assumes x is DWORD, and returns a DWORD
//
#define DWORD_MULTIPLE(x) (((ULONG)(x) + ((4)-1)) & ~((ULONG)(4)-1))
#define QWORD_MULTIPLE(x) (((ULONG)(x) + ((8)-1)) & ~((ULONG)(8)-1))

//
//  Returns a PVOID
//
#define ALIGN_ON_DWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((4)-1)) & ~((ULONG_PTR)(4)-1)))
#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))

extern const    WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern const    WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern const    WCHAR  COSTLY_STRING[];      
extern const    WCHAR  NULL_STRING[];

extern const    WCHAR  szTotalValue[];
extern const    WCHAR  szDefaultTotalString[];
#define DEFAULT_TOTAL_STRING_LEN    14

extern DWORD  MESSAGE_LEVEL;

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// function prototypes for data collection routines
typedef DWORD (APIENTRY PM_LOCAL_COLLECT_PROC) (LPVOID *, LPDWORD, LPDWORD);

typedef struct _POS_FUNCTION_INFO {
    DWORD   dwObjectId;
    DWORD   dwCollectFunctionBit;
    DWORD   dwDataFunctionBit;
    PM_LOCAL_COLLECT_PROC *pCollectFunction;
} POS_FUNCTION_INFO, * PPOS_FUNCTION_INFO;

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog (IN LPWSTR);
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name
    );

LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
);

//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif


#define ALLOCMEM(heap, flags, size)     HeapAlloc (heap, flags, size)
#define REALLOCMEM(heap, flags, pointer, newsize) \
                                    HeapReAlloc (heap, flags, pointer, newsize)
#define FREEMEM(heap, flags, pointer)   HeapFree (heap, flags, pointer)

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\common\perfutil.c ===
/*++

Copyright (c) 1995-6  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
    common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Bob Watson  28-Jul-1995

Revision History:

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "perfutil.h"
#include "perfmsg.h"

//
// Global data definitions.
//

ULONG ulInfoBufferSize = 0;

extern HANDLE hEventLog;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

const WCHAR GLOBAL_STRING[] = L"Global";
const WCHAR FOREIGN_STRING[] = L"Foreign";
const WCHAR COSTLY_STRING[] = L"Costly";

const WCHAR NULL_STRING[] = L"\0";    // pointer to null string

const WCHAR  szTotalValue[] = L"TotalInstanceName";
const WCHAR  szDefaultTotalString[] = L"_Total";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
)
/*++

    read and return the current value of the specified value
    under the Perflib registry key. If unable to read the value
    return the default value from the argument list.

    the value is returned in the pReturnBuffer.

--*/
{

    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          PerflibSubKeyString;
    UNICODE_STRING          ValueNameString;
    LONG                    lReturn = ERROR_SUCCESS;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation, pBuffer;
    DWORD                   ValueBufferLength;
    DWORD                   ResultLength;
    BOOL                    bUseDefault = TRUE;

    // initialize UNICODE_STRING structures used in this function

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        (LPCWSTR)L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    RtlInitUnicodeString (
        &ValueNameString,
        (LPWSTR)szItem);

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //
    InitializeObjectAttributes(
            &Obja,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                KEY_READ,
                &Obja
                );

    if (NT_SUCCESS( Status )) {
        // read value of desired entry

        ValueBufferLength = ResultLength = 1024;
        pValueInformation = ALLOCMEM(RtlProcessHeap(), 0, ResultLength);

        if (pValueInformation != NULL) {
            while ( (Status = NtQueryValueKey(hPerflibKey,
                                            &ValueNameString,
                                            KeyValuePartialInformation,
                                            pValueInformation,
                                            ValueBufferLength,
                                            &ResultLength))
                    == STATUS_BUFFER_OVERFLOW ) {

                pBuffer = pValueInformation;
                pValueInformation = REALLOCMEM(RtlProcessHeap(), 0,
                                                        pValueInformation,
                                                        ResultLength);
                if ( pValueInformation == NULL) {
                    FREEMEM(RtlProcessHeap(), 0, pBuffer);
                    break;
                } else {
                    ValueBufferLength = ResultLength;
                }
            }

            if (NT_SUCCESS(Status)) {
                // check to see if it's the desired type
                if (pValueInformation->Type == dwRegType) {
                    // see if it will fit
                    if (pValueInformation->DataLength <= dwMaxSize) {
                        memcpy (pReturnBuffer, &pValueInformation->Data[0],
                            pValueInformation->DataLength);
                        bUseDefault = FALSE;
                        lReturn = STATUS_SUCCESS;
                    }
                }
            } else {
                // return the default value
                lReturn = Status;
            }
            // release temp buffer
            FREEMEM (RtlProcessHeap(), 0, pValueInformation);
        } else {
            // unable to allocate memory for this operation so
            // just return the default value
        }
        // close the registry key
        NtClose(hPerflibKey);
    } else {
        // return default value
    }

    if (bUseDefault) {
        memcpy (pReturnBuffer, pDefault, dwDefaultSize);
        lReturn = STATUS_SUCCESS;
    }

    return lReturn;
}

HANDLE
MonOpenEventLog (
    IN  LPWSTR  szAppName
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
    TCHAR LogLevelValueName[] = TEXT("EventLogLevel");

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSourceW (
            (LPTSTR)NULL,            // Use Local Machine
            szAppName);               // event log app name to find in registry
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible
    BOOL    bNotDone;
    BOOL    bReturnValue = FALSE;

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    bNotDone = TRUE;

    while ( bNotDone ) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) {
                        bNotDone = FALSE;
                        bReturnValue = TRUE;
                    } else {
                        bValidNumber = FALSE;
                    }
                }
                if (*pwcThisChar == 0) {
                    bNotDone = FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }
    return bReturnValue;
}   // IsNumberInUnicodeList


BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                            NameLength;

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    memcpy(pName,Name,NameLength);

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    // round up to put next buffer on a QUADWORD boundry
    *pBufferNext = ALIGN_ON_QWORD (*pBufferNext);
    // adjust length value to match new length
    pBuffer->ByteLength = (ULONG)((ULONG_PTR)*pBufferNext - (ULONG_PTR)pBuffer);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\datalogi.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATALOGI.h

Abstract:

    Header file for the Windows NT Processor Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATALOGI_H_
#define _DATALOGI_H_

//
//  logical disk performance definition structure
//

typedef struct _LDISK_DATA_DEFINITION {
    PERF_OBJECT_TYPE            DiskObjectType;
    PERF_COUNTER_DEFINITION     cdDiskFreeMbytes1;
    PERF_COUNTER_DEFINITION     cdDiskTotalMbytes;
    PERF_COUNTER_DEFINITION     cdDiskFreeMbytes2;
    PERF_COUNTER_DEFINITION     cdDiskCurrentQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskTime;
    PERF_COUNTER_DEFINITION     cdDiskTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskAvgQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskReadTime;
    PERF_COUNTER_DEFINITION     cdDiskReadTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskReadQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskWriteTime;
    PERF_COUNTER_DEFINITION     cdDiskWriteTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskWriteQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskAvgTime;
    PERF_COUNTER_DEFINITION     cdDiskTransfersBase1;
    PERF_COUNTER_DEFINITION     cdDiskAvgReadTime;
    PERF_COUNTER_DEFINITION     cdDiskReadsBase1;
    PERF_COUNTER_DEFINITION     cdDiskAvgWriteTime;
    PERF_COUNTER_DEFINITION     cdDiskWritesBase1;
    PERF_COUNTER_DEFINITION     cdDiskTransfers;
    PERF_COUNTER_DEFINITION     cdDiskReads;
    PERF_COUNTER_DEFINITION     cdDiskWrites;
    PERF_COUNTER_DEFINITION     cdDiskBytes;
    PERF_COUNTER_DEFINITION     cdDiskReadBytes;
    PERF_COUNTER_DEFINITION     cdDiskWriteBytes;
    PERF_COUNTER_DEFINITION     cdDiskAvgBytes;
    PERF_COUNTER_DEFINITION     cdDiskTransfersBase2;
    PERF_COUNTER_DEFINITION     cdDiskAvgReadBytes;
    PERF_COUNTER_DEFINITION     cdDiskReadsBase2;
    PERF_COUNTER_DEFINITION     cdDiskAvgWriteBytes;
    PERF_COUNTER_DEFINITION     cdDiskWritesBase2;
    PERF_COUNTER_DEFINITION     cdIdleTime;
    PERF_COUNTER_DEFINITION     cdIdleTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdSplitCount;
} LDISK_DATA_DEFINITION, *PLDISK_DATA_DEFINITION;

typedef struct _LDISK_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   DiskFreeMbytes1;
    DWORD                   DiskTotalMbytes;
    DWORD                   DiskFreeMbytes2;
    DWORD                   DiskCurrentQueueLength;
    DWORD                   DiskTransfersBase1;
    LONGLONG                DiskTime;
    LONGLONG                DiskAvgQueueLength;
    LONGLONG                DiskReadTime;
    LONGLONG                DiskReadQueueLength;
    LONGLONG                DiskWriteTime;
    LONGLONG                DiskWriteQueueLength;
    LONGLONG                DiskAvgTime;
    LONGLONG                DiskAvgReadTime;
    LONGLONG                DiskAvgWriteTime;
    DWORD                   DiskReadsBase1;
    DWORD                   DiskWritesBase1;
    DWORD                   DiskTransfers;
    DWORD                   DiskReads;
    DWORD                   DiskWrites;
    DWORD                   DiskTransfersBase2;
    LONGLONG                DiskBytes;
    LONGLONG                DiskReadBytes;
    LONGLONG                DiskWriteBytes;
    LONGLONG                DiskAvgBytes;
    LONGLONG                DiskAvgReadBytes;
    LONGLONG                DiskAvgWriteBytes;
    DWORD                   DiskReadsBase2;
    DWORD                   DiskWritesBase2;
    LONGLONG                IdleTime;
    LONGLONG                DiskTimeTimestamp;
    DWORD                   SplitCount;
} LDISK_COUNTER_DATA, * PLDISK_COUNTER_DATA;

extern LDISK_DATA_DEFINITION LogicalDiskDataDefinition;

#endif // _DATALOGI_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\dataphys.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAPHYS.h

Abstract:

    Header file for the Windows NT Processor Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAPHYS_H_
#define _DATAPHYS_H_

//
//  physical disk performance definition structure
//

typedef struct _PDISK_DATA_DEFINITION {
    PERF_OBJECT_TYPE            DiskObjectType;
    PERF_COUNTER_DEFINITION     cdDiskCurrentQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskTime;
    PERF_COUNTER_DEFINITION     cdDiskTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskAvgQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskReadTime;
    PERF_COUNTER_DEFINITION     cdDiskReadTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskReadQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskWriteTime;
    PERF_COUNTER_DEFINITION     cdDiskWriteTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdDiskWriteQueueLength;
    PERF_COUNTER_DEFINITION     cdDiskAvgTime;
    PERF_COUNTER_DEFINITION     cdDiskTransfersBase1;
    PERF_COUNTER_DEFINITION     cdDiskAvgReadTime;
    PERF_COUNTER_DEFINITION     cdDiskReadsBase1;
    PERF_COUNTER_DEFINITION     cdDiskAvgWriteTime;
    PERF_COUNTER_DEFINITION     cdDiskWritesBase1;
    PERF_COUNTER_DEFINITION     cdDiskTransfers;
    PERF_COUNTER_DEFINITION     cdDiskReads;
    PERF_COUNTER_DEFINITION     cdDiskWrites;
    PERF_COUNTER_DEFINITION     cdDiskBytes;
    PERF_COUNTER_DEFINITION     cdDiskReadBytes;
    PERF_COUNTER_DEFINITION     cdDiskWriteBytes;
    PERF_COUNTER_DEFINITION     cdDiskAvgBytes;
    PERF_COUNTER_DEFINITION     cdDiskTransfersBase2;
    PERF_COUNTER_DEFINITION     cdDiskAvgReadBytes;
    PERF_COUNTER_DEFINITION     cdDiskReadsBase2;
    PERF_COUNTER_DEFINITION     cdDiskAvgWriteBytes;
    PERF_COUNTER_DEFINITION     cdDiskWritesBase2;
    PERF_COUNTER_DEFINITION     cdIdleTime;
    PERF_COUNTER_DEFINITION     cdIdleTimeTimeStamp;
    PERF_COUNTER_DEFINITION     cdSplitCount;
} PDISK_DATA_DEFINITION, * PPDISK_DATA_DEFINITION;



typedef struct _PDISK_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   DiskCurrentQueueLength;
    LONGLONG                DiskTime;
    LONGLONG                DiskAvgQueueLength;
    LONGLONG                DiskReadTime;
    LONGLONG                DiskReadQueueLength;
    LONGLONG                DiskWriteTime;
    LONGLONG                DiskWriteQueueLength;
    LONGLONG                DiskAvgTime;
    LONGLONG                DiskAvgReadTime;
    DWORD                   DiskTransfersBase1;
    DWORD                   DiskReadsBase1;
    LONGLONG                DiskAvgWriteTime;
    DWORD                   DiskWritesBase1;
    DWORD                   DiskTransfers;
    DWORD                   DiskReads;
    DWORD                   DiskWrites;
    LONGLONG                DiskBytes;
    LONGLONG                DiskReadBytes;
    LONGLONG                DiskWriteBytes;
    LONGLONG                DiskAvgBytes;
    LONGLONG                DiskAvgReadBytes;
    DWORD                   DiskTransfersBase2;
    DWORD                   DiskReadsBase2;
    LONGLONG                DiskAvgWriteBytes;
    LONGLONG                IdleTime;
    LONGLONG                DiskTimeTimeStamp;
    DWORD                   DiskWritesBase2;
    DWORD                   SplitCount;
} PDISK_COUNTER_DATA, * PPDISK_COUNTER_DATA;

extern PDISK_DATA_DEFINITION PhysicalDiskDataDefinition;

#endif // _DATAPHYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\dataphys.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataphys.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Physical Disk Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataphys.h"

// dummy variable for field sizing.
static PDISK_COUNTER_DATA   pcd;

//
//  Constant structure initializations 
//      defined in dataphys.h
//

PDISK_DATA_DEFINITION PhysicalDiskDataDefinition = {

    {   0,
        sizeof(PDISK_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        PHYSICAL_DISK_OBJECT_TITLE_INDEX,
        0,
        235,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(PDISK_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        2,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        198,
        0,
        199,
        0,
        1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (pcd.DiskCurrentQueueLength),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskCurrentQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        200,
        0,
        201,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (pcd.DiskTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        200,
        0,
        201,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (pcd.DiskTimeTimeStamp),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTimeTimeStamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1400,
        0,
        1401,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (pcd.DiskAvgQueueLength),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        202,
        0,
        203,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (pcd.DiskReadTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        202,
        0,
        203,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (pcd.DiskTimeTimeStamp),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTimeTimeStamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1402,
        0,
        1403,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (pcd.DiskReadQueueLength),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        204,
        0,
        205,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_100NS_TIMER,
        sizeof (pcd.DiskWriteTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWriteTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        204,
        0,
        205,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (pcd.DiskTimeTimeStamp),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTimeTimeStamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1404,
        0,
        1405,
        0,
        2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_100NS_QUEUELEN_TYPE,
        sizeof (pcd.DiskWriteQueueLength),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWriteQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        206,
        0,
        207,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (pcd.DiskAvgTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        206,
        0,
        207,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskTransfersBase1),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTransfersBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        208,
        0,
        209,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (pcd.DiskAvgReadTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgReadTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        208,
        0,
        209,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskReadsBase1),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadsBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        210,
        0,
        211,
        0,
        3,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_TIMER,
        sizeof (pcd.DiskAvgWriteTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgWriteTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        210,
        0,
        211,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskWritesBase1),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWritesBase1
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        212,
        0,
        213,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (pcd.DiskTransfers),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTransfers
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        214,
        0,
        215,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (pcd.DiskReads),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        216,
        0,
        217,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (pcd.DiskWrites),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWrites
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        218,
        0,
        219,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (pcd.DiskBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        220,
        0,
        221,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (pcd.DiskReadBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        222,
        0,
        223,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (pcd.DiskWriteBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        224,
        0,
        225,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (pcd.DiskAvgBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        224,
        0,
        225,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskTransfersBase2),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTransfersBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        226,
        0,
        227,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (pcd.DiskAvgReadBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        226,
        0,
        227,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskReadsBase2),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskReadsBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        228,
        0,
        229,
        0,
        -2,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BULK,
        sizeof (pcd.DiskAvgWriteBytes),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskAvgWriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        228,
        0,
        229,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_AVERAGE_BASE,
        sizeof (pcd.DiskWritesBase2),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskWritesBase2
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1482,
        0,
        1483,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_PRECISION_100NS_TIMER,
        sizeof (pcd.IdleTime),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->IdleTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1482,
        0,
        1483,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_PRECISION_TIMESTAMP,
        sizeof (pcd.DiskTimeTimeStamp),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->DiskTimeTimeStamp
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1484,
        0,
        1485,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (pcd.SplitCount),
        (DWORD)(ULONG_PTR)&((PPDISK_COUNTER_DATA)0)->SplitCount
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\perfdisk.h ===
#ifndef _PERFDISK_H_
#define _PERFDISK_H_
#include "diskutil.h"

//
//  Definition of handle table for disks
//

//  Information for collecting disk driver statistics

extern  HANDLE  hEventLog;       // handle to event log
extern  LPWSTR  wszTotal;

extern  BOOL    bShownDiskPerfMessage;  // flag to reduce eventlog noise
extern  BOOL    bShownDiskVolumeMessage;

extern  const   WCHAR  szTotalValue[];
extern  const   WCHAR  szDefaultTotalString[];

extern  WMIHANDLE   hWmiDiskPerf;
extern  LPBYTE  WmiBuffer;

extern PDRIVE_VOLUME_ENTRY  pPhysDiskList;
extern DWORD                dwNumPhysDiskListEntries;
extern PDRIVE_VOLUME_ENTRY  pVolumeList;
extern DWORD                dwNumVolumeListEntries;
extern BOOL                 bRemapDriveLetters;
extern DWORD                dwMaxVolumeNumber;
extern DWORD                dwWmiDriveCount;

extern DOUBLE               dSysTickTo100Ns;

DWORD APIENTRY MapDriveLetters();   // function to map drive letters to volume  or device name

//  logidisk.c
PM_LOCAL_COLLECT_PROC CollectLDiskObjectData;

//  Physdisk.c
PM_LOCAL_COLLECT_PROC CollectPDiskObjectData;

#endif // _PERFDISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\diskutil.h ===
#ifndef __DISKUTIL_H_
#define __DISKUTIL_H_

#ifndef _DBG_PRINT_INSTANCES
#define _DBG_PRINT_INSTANCES 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning ( disable : 4201 ) 

#include <ntdddisk.h>
#include <ntddvol.h>

extern BOOL                 bUseNT4InstanceNames;
extern HANDLE               hLibHeap;       // Handle to DLL Heap
extern LONG                 g_lRefreshInterval;

#define DU_MAX_VOLUMES      ((WORD)0xFFFF)
#define DU_MAX_DRIVES       ((WORD)0xFFFF)
#define DU_MAX_PARTITIONS   ((WORD)0xFFFF)

#define INITIAL_NUM_VOL_LIST_ENTRIES    ((DWORD)0x0000001A)

#define DVE_DEV_NAME_LEN    ((DWORD)368)

typedef struct _DRIVE_VOLUME_ENTRY {
    union {
        DWORD   dwDriveId;      // 00-03
        struct {
            WORD    wPartNo;
            WORD    wDriveNo;
        };
    };                  
    WORD    wcDriveLetter;      // 04-05
    WORD    wReserved;          // 06-07
    union {
        WCHAR   szVolumeManager[8];
        ULONG64 llVolMgr[2];
    };                          // 08-17
    DWORD   dwVolumeNumber;     // 18-1B
    HANDLE  hVolume;            // 1C-17
    WCHAR   wszInstanceName[DVE_DEV_NAME_LEN];  // 20-1FF
    UNICODE_STRING DeviceName;
    ULONGLONG TotalBytes;
    ULONGLONG FreeBytes;
    LONGLONG  LastRefreshTime;
} DRIVE_VOLUME_ENTRY, *PDRIVE_VOLUME_ENTRY;

typedef struct _DRIVE_LIST {
    LIST_ENTRY          Entry;
    DRIVE_VOLUME_ENTRY  DiskEntry;
} DRIVE_LIST, *PDRIVE_LIST;

#define LL_PARTMGR_0    ((LONGLONG)0x0074007200610050) //"Part"
#define LL_PARTMGR_1    ((LONGLONG)0x002000720067006D) //"mgr "

#define LL_PHYSDISK_0   ((LONGLONG)0x0073007900680050) //"Phys"
#define LL_PHYSDISK_1   ((LONGLONG)0x006B007300690044) //"Disk"

#define LL_LOGIDISK_0   ((LONGLONG)0x00690067006F004C) //"Logi"
#define LL_LOGIDISK_1   ((LONGLONG)0x006B007300690044) //"Disk"

#pragma warning ( default : 4201 )

__inline
BOOL
IsPhysicalDrive (PDISK_PERFORMANCE pPerfInf) {
    LPWSTR szName = &pPerfInf->StorageManagerName[0];

    if ( ((ULONG_PTR) szName & 0x07) != 0) {
        if (!wcsncmp(szName, L"Partmgr ", sizeof(LONG64)))
            return TRUE;
        if (!wcsncmp(szName, L"PhysDisk", sizeof(LONG64)))
            return TRUE;
        return FALSE;
    }
    else
    if (((*(LONGLONG *)(szName[0]) == LL_PARTMGR_0) &&
         (*(LONGLONG *)(szName[4]) == LL_PARTMGR_1)) ||
        ((*(LONGLONG *)(szName[0]) == LL_PHYSDISK_0) &&
         (*(LONGLONG *)(szName[4]) == LL_PHYSDISK_1))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

DWORD
BuildPhysDiskList (
    HANDLE  hDiskPerf,
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries
);

DWORD
MakePhysDiskInstanceNames (
    PDRIVE_VOLUME_ENTRY pPhysDiskList,
    DWORD               dwNumPhysDiskListItems,
    LPDWORD             pdwMaxDriveNo,
    PDRIVE_VOLUME_ENTRY pVolumeList,
    DWORD               dwNumVolumeListItems
);

DWORD
BuildVolumeList (
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries
);

DWORD
MapLoadedDisks (
    HANDLE  hDiskPerf,
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries,
    LPDWORD             pdwMaxVolumeNo,
    LPDWORD             pdwWmiItemCount
);

DWORD
GetDriveNameString (
    LPCWSTR             szDevicePath,
    DWORD               cchDevicePathSize,
    PDRIVE_VOLUME_ENTRY pList,
    DWORD               dwNumEntries,
    LPWSTR              szNameBuffer,
    LPDWORD             pcchNameBufferSize,
    LPCWSTR             szVolumeManagerName,
    DWORD               dwVolumeNumber,
    PDRIVE_VOLUME_ENTRY *ppVolume
);

DWORD
CompressPhysDiskTable (
    PDRIVE_VOLUME_ENTRY     pOrigTable,
    DWORD                   dwOrigCount,
    PDRIVE_VOLUME_ENTRY     pNewTable,
    DWORD                   dwNewCount
);

BOOL
GetPhysicalDriveNameString (
    DWORD                   dwDriveNumber,    
    PDRIVE_VOLUME_ENTRY     pList,
    DWORD                   dwNumEntries,
    LPWSTR                  szNameBuffer
);

DWORD
FindNewVolumes (
    PDRIVE_VOLUME_ENTRY *ppPhysDiskList,
    LPDWORD             pdwNumPhysDiskListEntries,
    PDRIVE_VOLUME_ENTRY pVolumeList,
    DWORD               dwNumVolumeListItems
);

#if DBG

extern ULONG_PTR HeapUsed;

VOID
PerfDiskDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x)   PerfDiskDebugPrint x

#else

#define DebugPrint(x)
#endif // DBG

#ifdef __cplusplus
}
#endif
#endif // __DISKUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\diskutil.cpp ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#pragma warning ( disable : 4201 ) 
#include <ntdddisk.h>
#pragma warning ( default : 4201 ) 
#include <wtypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <ftapi.h>
#include <mountmgr.h>
#pragma warning ( disable : 4201 ) 
#include <wmium.h>
#pragma warning ( default : 4201 ) 
#include <wmiguid.h>
#include <assert.h>

#include "diskutil.h"
#include "perfutil.h"

#define HEAP_FLAGS  (HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS)
#define INITIAL_MOUNTMGR_BUFFER_SIZE    8192

// sizes are in characters (not bytes)
#define SIZE_OF_DOSDEVICES  12L     // size of "\DosDevices\" string
#define SIZE_OF_DEVICE       8L     // size of "\Device\" string
#define SIZE_OF_HARDDISK     8L     // size of "Harddisk" string

static const LONGLONG   llDosDevicesId  = 0x0073006f0044005c; // "\Dos"
static const LONGLONG   llFloppyName    = 0x0070006f006c0046; // "Flop"
static const LONGLONG   llCdRomName     = 0x006f005200640043; // "CdRo"

LONG g_lRefreshInterval = 300;     // default to 5 mins

BOOL                bUseNT4InstanceNames = FALSE;

NTSTATUS
OpenDevice(
    IN PUNICODE_STRING DeviceName,
    OUT PHANDLE Handle
    );

NTSTATUS
GetDeviceName(
    PMOUNTMGR_MOUNT_POINTS  pMountPoints,
    IN PMOUNTMGR_MOUNT_POINT Point,
    OUT PUNICODE_STRING DeviceName
    );

VOID
RefreshVolume(
    PDRIVE_VOLUME_ENTRY pVolume
    );

ULONG
GetDiskExtent(
    IN HANDLE hVol,
    IN OUT PVOLUME_DISK_EXTENTS *pVolExtents,
    IN OUT PULONG ReturnedSize
    );

#if DBG
VOID
DumpDiskList(
    IN PDRIVE_VOLUME_ENTRY pList,
    IN ULONG nCount
    );
#endif

DWORD
GetDriveNumberFromDevicePath (
    LPCWSTR szDevicePath,
    LPDWORD pdwDriveId
)
/*
    evaluates the device path and returns the Drive Number 
    if the string is in the following format

        \Device\HarddiskX

    where X is a decimal number (consisting of 1 or more decimal
    digits representing a value between 0 and 65535 inclusive)

    The function returns a value of:
        ERROR_SUCCESS           if successful
        ERROR_INVALID_PARAMETER if the input string is incorrectly formatted
        ERROR_INVALID_DATA      if the volume number is too big
        
*/
{
    PWCHAR  pNumberChar;
    LONG    lValue;
    DWORD   dwDriveAndPartition;
    DWORD   dwReturn;
    DWORD   dwRetry = 4;

    // validate the input arguments
    assert (szDevicePath != NULL);
    assert (*szDevicePath != 0);
    assert (pdwDriveId != NULL);

    // start at the beginning of the string
    pNumberChar = (PWCHAR)szDevicePath;

    // make sure it starts with a backslash. if not then
    // try the next 4 characters to see if there's some garbage
    // in front of the string.
    while (*pNumberChar != L'\\') {
        --dwRetry;
        if (dwRetry) {
            pNumberChar++;
        } else {
            break;
        }
    }

    if (*pNumberChar == L'\\') {
        // and go to the end of the Device string to see 
        // if this is a harddisk path
       pNumberChar += SIZE_OF_DEVICE;
        if (*pNumberChar == L'H') {
            // this is a volume Entry so go to the number
            pNumberChar += SIZE_OF_HARDDISK;
            lValue = _wtol(pNumberChar);
            if (lValue <= (LONG)0x0000FFFF) {
                // load the drive number into the DWORD
                dwDriveAndPartition = (DWORD)lValue;
                *pdwDriveId = dwDriveAndPartition;
                dwReturn = ERROR_SUCCESS;
            } else {
                // drive ID Is out of range
                dwReturn = ERROR_INVALID_DATA;
            }
        } else {
            // not a valid path
            dwReturn = ERROR_INVALID_PARAMETER;
        }
    } else {
        dwReturn = ERROR_INVALID_PARAMETER;
    }

    return dwReturn;
}

DWORD
GetSymbolicLink (
    LPCWSTR szDeviceString,
    LPWSTR  szLinkString,
    LPDWORD pcchLength
)
/*
    this functions opens the device string as a symbolic link
    and returns the corresponding link string
*/
{
    OBJECT_ATTRIBUTES   Attributes;
    UNICODE_STRING      ObjectName;
    UNICODE_STRING      LinkName;
    WORD                wDevStrLen;
    NTSTATUS            ntStatus;
    DWORD               dwRetSize = 0;
    DWORD               dwReturnStatus;
    HANDLE              hObject = NULL;

    // validate arguments
    assert (szDeviceString != NULL);
    assert (*szDeviceString != 0);
    assert (szLinkString != NULL);
    assert (pcchLength != NULL);
    assert (*pcchLength > 0);

    // get the length of the input string
    wDevStrLen = (WORD)lstrlenW(szDeviceString);

    // create the object name UNICODE string structure
    ObjectName.Length = (WORD)(wDevStrLen * sizeof (WCHAR));
    ObjectName.MaximumLength = (WORD)((wDevStrLen + 1) * sizeof (WCHAR));
    ObjectName.Buffer = (LPWSTR)szDeviceString;

    // initialize the object attributes for the open call
    InitializeObjectAttributes( &Attributes,
                            &ObjectName,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL );

    // open the name as a symbolic link, if this fails, the input
    // name is probably not a link

    ntStatus = NtOpenSymbolicLinkObject(
                            &hObject,
                            SYMBOLIC_LINK_QUERY,
                            &Attributes);

    if (NT_SUCCESS(ntStatus)) {
        // init a Unicode String for the return buffer using the caller's
        // buffer
        LinkName.Length = 0;
        LinkName.MaximumLength = (WORD)(*pcchLength * sizeof (WCHAR));
        LinkName.Buffer = szLinkString;
        RtlZeroMemory(LinkName.Buffer, LinkName.MaximumLength);

        // and look up the link
        ntStatus = NtQuerySymbolicLinkObject(
            hObject, &LinkName, &dwRetSize);

        if (NT_SUCCESS(ntStatus)) {
            // buffer is loaded so set the return status and length
            *pcchLength = LinkName.Length / sizeof (WCHAR);
            // make sure the string is 0 terminated
            szLinkString[*pcchLength] = 0;
            dwReturnStatus = ERROR_SUCCESS;
        } else {
            // unable to look up the link so return the error
            dwReturnStatus = RtlNtStatusToDosError(ntStatus);
        }
        
        // close the handle to the link
        NtClose (hObject);
    } else {
        dwReturnStatus = RtlNtStatusToDosError(ntStatus);
    }
    
    return dwReturnStatus;  
}

LONG
LookupInstanceName(
    LPCWSTR                 szName,
    PDRIVE_VOLUME_ENTRY     pList,
    DWORD                   dwNumEntries,
    DWORD                   dwRetry
    )
{
    LONG i, j;

    j = (LONG) dwRetry;
    for (i=(LONG) dwNumEntries; i>=0 && j>=0; i--, j--) {
        if (!lstrcmp(pList[i].wszInstanceName, szName))
            return (DWORD) i;
    }
    return -1;
}

DWORD
BuildPhysDiskList (
    HANDLE  hDiskPerf,
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries
)
{
    DWORD   status = ERROR_SUCCESS; // return value of the function
    HANDLE  hWmiDiskPerf = NULL;    // local handle value 
    DWORD   dwLocalWmiItemCount = 0;

    // WMI Buffer variables
    DWORD   WmiBufSize = 0;
    DWORD   WmiAllocSize = 0x8000;     
    LPBYTE  WmiBuffer = NULL;

    // WMI buffer processing variables
    PWNODE_ALL_DATA     WmiDiskInfo;
    DISK_PERFORMANCE    *pDiskPerformance;    //  Disk driver returns counters here
    DWORD               dwInstanceNameOffset;
    WORD                wNameLen;   // string length is first word in buffer
    LPWSTR              wszInstanceName; // pointer to string in WMI buffer
    
    WCHAR   wszInstName[MAX_PATH];
    DWORD   dwBytesToCopy;

    DWORD   dwListEntry;

    BOOL    bNotDone = TRUE;

    DWORD   dwLocalStatus;
    DWORD   dwLocalDriveId;
    DWORD   dwLocalPartition;
    WCHAR   szDrivePartString[MAX_PATH];
    DWORD   dwSymbLinkLen;
    WCHAR   szSymbLinkString[MAX_PATH];

    if (hDiskPerf == NULL) {
        // open handle to disk perf device driver
        status = WmiOpenBlock (
            (GUID *)&DiskPerfGuid,
            GENERIC_READ,
            &hWmiDiskPerf);
    } else {
        // use caller's handle
        hWmiDiskPerf = hDiskPerf;
    }

    assert (pList != NULL);
    assert (pdwNumEntries != NULL);

    DebugPrint((3, "BuildPhysDisk: dwEntries is %d\n", *pdwNumEntries));
    dwListEntry = 0;

    if (status == ERROR_SUCCESS) {
        // allocate a buffer to send to WMI to get the diskperf data
        WmiBufSize = WmiAllocSize;
        WmiBuffer = (LPBYTE)ALLOCMEM (hLibHeap, HEAP_FLAGS, WmiBufSize);

        if (WmiBuffer  == NULL) {
            status = ERROR_OUTOFMEMORY;
        } else {
#if DBG
            HeapUsed += WmiBufSize;
            DebugPrint((4,"\tWmiBuffer add %d to %d\n", WmiBufSize, HeapUsed));
#endif
            status = WmiQueryAllDataW (
                hWmiDiskPerf,
                &WmiBufSize,
                WmiBuffer);

            DebugPrint((2,
                "BuildPhysDisk: WmiQueryAllDataW status1=%d\n",
                status));
#if DBG
            if (!HeapValidate(hLibHeap, 0, WmiBuffer)) {
                DebugPrint((2,
                    "BuildPhysDisk: WmiQueryAllDataW corrupted WmiBuffer\n"));
                DbgBreakPoint();
            }
#endif

            // if buffer size attempted is too big or too small, resize
            if ((WmiBufSize > 0) && (WmiBufSize != WmiAllocSize)) {
                WmiBuffer = (LPBYTE)REALLOCMEM (hLibHeap, HEAP_FLAGS, WmiBuffer, WmiBufSize);

                if (WmiBuffer == NULL) {
                    // reallocation failed so bail out
                    status = ERROR_OUTOFMEMORY;
                } else {
#if DBG
                    HeapUsed += (WmiBufSize - WmiAllocSize);
                    DebugPrint((4, "\tRealloc WmiBuffer old %d new %d to %d\n",
                        WmiAllocSize, WmiBufSize, HeapUsed));
                    WmiAllocSize = WmiBufSize;
                    if (!HeapValidate(hLibHeap, 0, WmiBuffer)) {
                        DebugPrint((2, "\tHeapReAlloc is corrupted!\n"));
                        DbgBreakPoint();
                    }
#endif
                }
            }

            if (status == ERROR_INSUFFICIENT_BUFFER) {
                // if it didn't work because it was too small the first time
                // try one more time
                status = WmiQueryAllDataW (
                    hWmiDiskPerf,
                    &WmiBufSize,
                    WmiBuffer);
            
#if DBG
                if (!HeapValidate(hLibHeap, 0, WmiBuffer)) {
                    DebugPrint((2,
                        "BuildPhysDisk: WmiQueryAllDataW2 corrupted WmiBuffer\n"));
                    DbgBreakPoint();
                }
#endif
                DebugPrint((2,
                    "BuildPhysDisk: WmiQueryAllDataW status2=%d\n",
                    status));

            } else {
                // it either worked the fisrt time or it failed because of 
                // something other than a buffer size problem
            }
        }

        if (status == ERROR_SUCCESS) {
            WmiDiskInfo = (PWNODE_ALL_DATA)WmiBuffer;
            // go through returned names and add to the buffer
            while (bNotDone) {
#if DBG
                if ((PCHAR) WmiDiskInfo > (PCHAR) WmiBuffer + WmiAllocSize) {
                    DebugPrint((2,
                        "BuildPhysDisk: WmiDiskInfo %d exceeded %d + %d\n",
                        WmiDiskInfo, WmiBuffer, WmiAllocSize));
                }
#endif
                pDiskPerformance = (PDISK_PERFORMANCE)(
                    (PUCHAR)WmiDiskInfo +  WmiDiskInfo->DataBlockOffset);

#if DBG
                if ((PCHAR) pDiskPerformance > (PCHAR) WmiBuffer + WmiAllocSize) {
                    DebugPrint((2,
                        "BuildPhysDisk: pDiskPerformance %d exceeded %d + %d\n",
                        pDiskPerformance, WmiBuffer, WmiAllocSize));
                }
#endif
        
                dwInstanceNameOffset = WmiDiskInfo->DataBlockOffset + 
                                      ((sizeof(DISK_PERFORMANCE) + 1) & ~1) ;

#if DBG
                if ((dwInstanceNameOffset+(PCHAR)WmiDiskInfo) > (PCHAR) WmiBuffer + WmiAllocSize) {
                    DebugPrint((2,
                        "BuildPhysDisk: dwInstanceNameOffset %d exceeded %d + %d\n",
                        dwInstanceNameOffset, WmiBuffer, WmiAllocSize));
                }
#endif
                // get length of string (it's a counted string) length is in chars
                wNameLen = *(LPWORD)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset);

#if DBG
                if ((wNameLen + (PCHAR)WmiDiskInfo + dwInstanceNameOffset) >
                         (PCHAR) WmiBuffer + WmiAllocSize) {
                    DebugPrint((2,
                        "BuildPhysDisk: wNameLen %d exceeded %d + %d\n",
                        wNameLen, WmiBuffer, WmiAllocSize));
                }
#endif
                if (wNameLen > 0) {
                    // just a sanity check here
                    assert (wNameLen < MAX_PATH);
                    // get pointer to string text
                    wszInstanceName = (LPWSTR)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset + sizeof(WORD));

                    // truncate to last characters if name is larger than the buffer in the table
                    if (wNameLen >= DVE_DEV_NAME_LEN) {
                        // copy the last DVE_DEV_NAME_LEN chars
                        wszInstanceName += (wNameLen  - DVE_DEV_NAME_LEN) + 1;
                        dwBytesToCopy = (DVE_DEV_NAME_LEN - 1) * sizeof(WCHAR);
                        wNameLen = DVE_DEV_NAME_LEN - 1;
                    } else {
                        dwBytesToCopy = wNameLen;
                    }
                    // copy it to the buffer to make it a SZ string
                    memcpy (wszInstName, &wszInstanceName[0], dwBytesToCopy);
                    // zero terminate it
                    wszInstName[wNameLen/sizeof(WCHAR)] = 0;

                    DebugPrint((2, "Checking PhysDisk: '%ws'\n",
                        wszInstName));

                    if (IsPhysicalDrive(pDiskPerformance)) {
                        // enum partitions
                        dwLocalDriveId = 0;
                        dwLocalStatus = GetDriveNumberFromDevicePath (wszInstName, &dwLocalDriveId);
                        if (dwLocalStatus == ERROR_SUCCESS) {
                            // then take the drive ID and find all the matching partitions with logical
                            // drives
                            for (dwLocalPartition = 0; 
                                dwLocalPartition <= 0xFFFF;
                                dwLocalPartition++) {
                                swprintf (szDrivePartString, L"\\Device\\Harddisk%d\\Partition%d",
                                    dwLocalDriveId, dwLocalPartition);
                                dwSymbLinkLen = sizeof (szSymbLinkString) / sizeof(szSymbLinkString[0]);
                                dwLocalStatus = GetSymbolicLink (szDrivePartString, 
                                    szSymbLinkString, &dwSymbLinkLen);
                                if (dwLocalStatus == ERROR_SUCCESS) {
                                    if (dwListEntry < *pdwNumEntries) {
                                        if (LookupInstanceName(
                                                szSymbLinkString,
                                                pList,
                                                dwListEntry,
                                                dwLocalPartition) >= 0) {
                                            dwListEntry++;
                                            continue;
                                        }
                                        DebugPrint((2,
                                            "Adding Partition: '%ws' as '%ws'\n",
                                            szDrivePartString, szSymbLinkString));
                                        pList[dwListEntry].wPartNo = (WORD)dwLocalPartition;
                                        pList[dwListEntry].wDriveNo = (WORD)dwLocalDriveId;
                                        pList[dwListEntry].wcDriveLetter = 0;
                                        pList[dwListEntry].wReserved = 0;
                                        memcpy (&pList[dwListEntry].szVolumeManager, 
                                            pDiskPerformance->StorageManagerName,
                                            sizeof(pDiskPerformance->StorageManagerName));
                                        pList[dwListEntry].dwVolumeNumber = pDiskPerformance->StorageDeviceNumber;
                                        pList[dwListEntry].hVolume = NULL;
                                        memset (&pList[dwListEntry].wszInstanceName[0],
                                            0, (DVE_DEV_NAME_LEN * sizeof(WCHAR)));
                                        if (dwSymbLinkLen < DVE_DEV_NAME_LEN) {
                                            lstrcpyW (&pList[dwListEntry].wszInstanceName[0],
                                                szSymbLinkString);
                                        } else {
                                            memcpy (&pList[dwListEntry].wszInstanceName[0],
                                                szSymbLinkString, DVE_DEV_NAME_LEN * sizeof(WCHAR));
                                            pList[dwListEntry].wszInstanceName[DVE_DEV_NAME_LEN-1] = 0;
                                        }
                                    } else {
                                        status = ERROR_INSUFFICIENT_BUFFER;
                                    }
                                    dwListEntry++;
                                } else {
                                    // that's it for this disk
                                    break;
                                }
                            }  // end of partition search
                        } // else unable to get the harddisk number from the path
                    } else {
                        // not a physical drive so ignore
                    }
                    // count the number of entries
                    dwLocalWmiItemCount++;
                } else {
                    // no string to examine (length == 0)
                }

                // bump pointers inside WMI data block
                if (WmiDiskInfo->WnodeHeader.Linkage != 0) {
                    // continue
                    WmiDiskInfo = (PWNODE_ALL_DATA) (
                        (LPBYTE)WmiDiskInfo + WmiDiskInfo->WnodeHeader.Linkage);
                } else {
                    bNotDone = FALSE;
                }
            } // end while looking through the WMI data block
        }

        if (hDiskPerf == NULL) {
            // then the disk perf handle is local so close it
            status = WmiCloseBlock (hWmiDiskPerf);
        }
    }

    if (WmiBuffer != NULL) {
        FREEMEM(hLibHeap, 0, WmiBuffer);
#if DBG
        HeapUsed -= WmiBufSize;
        DebugPrint((4, "\tFreed WmiBuffer %d to %d\n", WmiBufSize, HeapUsed));
#endif
    }

#if DBG
    DumpDiskList(pList, *pdwNumEntries);
#endif

    *pdwNumEntries = dwListEntry;
    DebugPrint((3,"BuildPhysDisk: Returning dwNumEntries=%d\n",*pdwNumEntries));

    return status;
}

DWORD
BuildVolumeList (
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries
)
/*

  Using the Mount manager, this function builds a list of all mounted 
  hard drive volumes (CD, Floppy & other types of disks are ignored).

  The calling function must pass in a buffer and indicate the maximum
  number of entries in the buffer. If successful, the buffer contains 
  one entry for each disk volume found and the number of entries used
  is returned

    pList           IN: pointer to a buffer that will receive the entries
                    OUT: buffer containing disk entries

    pdwNumEntries   IN: pointer to DWORD that specifies the max # of entries 
                        in the buffer referenced by pList
                    OUT: pointer to DWORD that contains the number of entries
                        written into the buffer referenced by pList
    pdwMaxVolume    IN: ignored
                    OUT: the max volume ID returned by the mount manager

  The function can return one of the following return values:

    ERROR_SUCCESS   if successful

    If unsuccessful:
        an error returned by 
*/
{
    DWORD       dwReturnValue = ERROR_SUCCESS;  // return value of function

    HANDLE      hMountMgr;      // handle to mount manger service
 
    // mount manager function variables
    PMOUNTMGR_MOUNT_POINTS  pMountPoints = NULL;
    MOUNTMGR_MOUNT_POINT    mountPoint;
    DWORD                   dwBufferSize = 0;
    DWORD                   dwReturnSize;
    BOOL                    bStatus;

    // processing loop functions
    LONG                    nListEntry;     // entry in caller's buffer
    DWORD                   dwBufEntry;     // entry in mount manager buffer
    PMOUNTMGR_MOUNT_POINT   point;          // the current entry 
    PWCHAR                  pDriveLetter;
    DWORD                   dwDone;

    NTSTATUS          status;
    LPWSTR            pThisChar;
    LPWSTR            szDeviceName;
    DWORD             dwBytesToCopy;
    BOOL              bNeedMoreData = TRUE;
    DWORD             dwRetryCount = 100;

    UINT              dwOrigErrorMode;


    BOOL              bIsHardDisk;
    LONG              nExistingEntry = -1;
    LONG              nOldListEntry  = -1;
    
    // pList can be NULL for size queries
    assert (pdwNumEntries != NULL);

    DebugPrint((3, "BuildVolumeList: Building %d entries\n", *pdwNumEntries));

    hMountMgr = CreateFile(MOUNTMGR_DOS_DEVICE_NAME, 0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);

    if (hMountMgr == INVALID_HANDLE_VALUE) {
        dwReturnValue = GetLastError();
        DebugPrint((2,
            "VolumeList: Mount Manager connection returned %d\n",
            dwReturnValue));
        goto BVL_ERROR_EXIT;
    }

    while ((bNeedMoreData) && (dwRetryCount)) {
        dwBufferSize += INITIAL_MOUNTMGR_BUFFER_SIZE;
        if (pMountPoints != NULL) {
            FREEMEM(hLibHeap, HEAP_FLAGS, pMountPoints);
            pMountPoints = NULL;
#if DBG
            HeapUsed -= dwBufferSize;
            DebugPrint((4,
                "\tFreed MountPoints %d to %d\n", dwBufferSize, HeapUsed));
#endif
        }
        pMountPoints = (PMOUNTMGR_MOUNT_POINTS) ALLOCMEM (
            hLibHeap, HEAP_FLAGS, dwBufferSize);
        if (pMountPoints == NULL) {
            dwReturnValue = ERROR_OUTOFMEMORY;
            DebugPrint((2, "VolumeList: Buffer Alloc failed\n"));
            goto BVL_ERROR_EXIT;
        }

#if DBG
        HeapUsed += dwBufferSize;
        DebugPrint((4,
            "\tAdded MountPoints %d to %d\n", dwBufferSize, HeapUsed));
#endif
        dwReturnSize = 0;
        memset(&mountPoint, 0, sizeof(MOUNTMGR_MOUNT_POINT));
        bStatus = DeviceIoControl(hMountMgr,
                    IOCTL_MOUNTMGR_QUERY_POINTS,
                    &mountPoint, sizeof(MOUNTMGR_MOUNT_POINT),
                    pMountPoints, dwBufferSize,
                    &dwReturnSize, NULL); 

        if (!bStatus) {
            dwReturnValue = GetLastError();
            if (dwReturnValue != ERROR_MORE_DATA) {
                DebugPrint((2,
                    "VolumeList: Mount Manager IOCTL returned %d\n",
                    dwReturnValue));
                goto BVL_ERROR_EXIT;
            } else {
                // we need a bigger buffer so try again
                dwReturnValue = ERROR_SUCCESS;
            }
            dwRetryCount--;
        } else {
            // everything worked so leave the loop
            bNeedMoreData = FALSE;
        }
    }

    if (!dwRetryCount)  {
        // then we gave up trying to get a big enough buffer so return an error
        dwReturnValue = ERROR_MORE_DATA;
    } else {
        // see if there's room in the caller's buffer for this data
        // **note that even though not all mounted drives will be returned
        // this is an easy and fast, if overstated, check
        // load size for caller to know required buffer size
        DebugPrint((2,
           "VolumeList: Mount Manager returned %d Volume entries\n",
           pMountPoints->NumberOfMountPoints));

        if (pMountPoints->NumberOfMountPoints > *pdwNumEntries) {
            *pdwNumEntries = (DWORD)pMountPoints->NumberOfMountPoints;
            if (pList != NULL) {
                // they passed in a buffer that wasn't big enough
                dwReturnValue = ERROR_INSUFFICIENT_BUFFER;
            } else {
                // they just wanted to know the size
                dwReturnValue = ERROR_SUCCESS;
            }
            goto BVL_ERROR_EXIT;
        }

        // assume there's room in the buffer now
        // load the caller's buffer
        
        dwOrigErrorMode = SetErrorMode (
            SEM_FAILCRITICALERRORS      |
            SEM_NOALIGNMENTFAULTEXCEPT  |
            SEM_NOGPFAULTERRORBOX       |
            SEM_NOOPENFILEERRORBOX);

        for (dwBufEntry=0, nListEntry = 0; 
                dwBufEntry < pMountPoints->NumberOfMountPoints; 
                dwBufEntry++) {
            point = &pMountPoints->MountPoints[dwBufEntry];
            // there are 2 steps to complete to know this is a good
            // entry for the caller. so set the count to 2 and decrement
            // it as the steps are successful.
            dwDone = 2; 
            bIsHardDisk = TRUE;

            pList[nListEntry].hVolume = NULL;
            pList[nListEntry].dwVolumeNumber = 0;
            memset(&pList[nListEntry].DeviceName, 0, sizeof(UNICODE_STRING));
            pList[nListEntry].TotalBytes = 0;
            pList[nListEntry].FreeBytes = 0;
            nExistingEntry = -1;
            nOldListEntry  = -1;
            if (point->DeviceNameLength) {
                UNALIGNED LONGLONG    *pSig;
                WCHAR wszInstanceName[DVE_DEV_NAME_LEN+1];

                // device name is in bytes
                pList[nListEntry].dwVolumeNumber = 0;
                szDeviceName = (LPWSTR)((PCHAR) pMountPoints + point->DeviceNameOffset);
                if ((DWORD)point->DeviceNameLength >= (DVE_DEV_NAME_LEN * sizeof(WCHAR))) {
                    // copy the last DVE_DEV_NAME_LEN chars
                    szDeviceName += ((DWORD)point->DeviceNameLength - DVE_DEV_NAME_LEN) + 1;
                    dwBytesToCopy = (DVE_DEV_NAME_LEN - 1) * sizeof(WCHAR);
                } else {
                    dwBytesToCopy = (DWORD)point->DeviceNameLength;
                }
                memcpy(wszInstanceName, szDeviceName, dwBytesToCopy);
                // null terminate
                assert ((dwBytesToCopy / sizeof(WCHAR)) < DVE_DEV_NAME_LEN);
                wszInstanceName[dwBytesToCopy / sizeof(WCHAR)] = 0;

                // Lookup an existing instance in the list and reset nListEntry accordingly.
                // Save the current value of nListEntry so that we can restore the indexing through the pList.
                if (nListEntry > 0)
                {
                    nExistingEntry = LookupInstanceName(wszInstanceName,
                        pList, nListEntry, nListEntry);

                    // Found it!
                    if (nExistingEntry != -1)
                    {
                        // If a drive letter has already been added for the volume, skip any further processing here.
                        // We've already processed this volume and we don't need to process it again.  This is done
                        // because mount manager returns the same volume twice:  once for the drive letter, once for
                        // the unique volume name.  Skip ahead but don't increment nListEntry.
                        if ((pList[nExistingEntry].wcDriveLetter >= L'A') && (pList[nExistingEntry].wcDriveLetter <= L'Z')) {
                            continue;
                        }

                        // If the drive letter field has not already been set, then close the volume handle which will
                        // be reset to a value later on in the loop.
                        nOldListEntry = nListEntry;
                        nListEntry = nExistingEntry;

                        CloseHandle(pList[nListEntry].hVolume);
                        pList[nListEntry].hVolume = NULL;
                    }
                }

                memcpy (pList[nListEntry].wszInstanceName, wszInstanceName, dwBytesToCopy + 1);

                DebugPrint((4, "MNT_PT %d: Device %d %ws\n",
                  dwBufEntry, nListEntry, pList[nListEntry].wszInstanceName));

                pSig = (UNALIGNED LONGLONG *)&(pList[nListEntry].wszInstanceName[SIZE_OF_DEVICE]);
                if ((*pSig == llFloppyName) || (*pSig == llCdRomName)) {
                    // this to avoid opening drives that we won't be collecting data from
                    bIsHardDisk = FALSE;
                }

                dwDone--;
            }

            if (point->SymbolicLinkNameLength) {
                PWCHAR szDeviceName = NULL;
                pDriveLetter = (PWCHAR)((PCHAR)pMountPoints + point->SymbolicLinkNameOffset);
                // make sure this is a \DosDevices path
                DebugPrint((4, "BuildVolumeList: From Symbolic %d %ws\n", nListEntry, pDriveLetter));
                if (*(UNALIGNED LONGLONG *)pDriveLetter == llDosDevicesId) {
                    pDriveLetter += SIZE_OF_DOSDEVICES;
                    if (((*pDriveLetter >= L'A') && (*pDriveLetter <= L'Z')) ||
                        ((*pDriveLetter >= L'a') && (*pDriveLetter <= L'z'))) {
                        pList[nListEntry].wcDriveLetter = towupper(*pDriveLetter);

                        if (bIsHardDisk) {
                            status =  GetDeviceName(
                                        pMountPoints, point,
                                        &pList[nListEntry].DeviceName);
                            if (!NT_SUCCESS(status)) {
                                dwReturnValue = RtlNtStatusToDosError(status);
                            }
                        }

                        dwDone--;
                    }
                } else if (bIsHardDisk) {
                    WCHAR szTempPath[MAX_PATH+1];

                    pThisChar = (PWCHAR)((PCHAR) pMountPoints + point->SymbolicLinkNameOffset);
                    memcpy (szTempPath, pThisChar, point->SymbolicLinkNameLength);

                    pThisChar = &szTempPath[point->SymbolicLinkNameLength / sizeof(WCHAR)];
                   *pThisChar++ = L'\\';
                   *pThisChar = 0;

                    DebugPrint((4, "BuildVolumeList: From HardDisk %d %ws\n", nListEntry, pThisChar));
                    if (wcsstr(szTempPath, L"DosDevices") == NULL)
                    {
                        pList[nListEntry].wcDriveLetter = L'\0';

                        status =  GetDeviceName(
                                    pMountPoints, point,
                                    &pList[nListEntry].DeviceName);
                        if (!NT_SUCCESS(status)) {
                            dwReturnValue = RtlNtStatusToDosError(status);
                        }
                        dwDone--;
                    }
                }
            }

            if (nOldListEntry != -1)
            {
                nListEntry = nOldListEntry;
            }

            if (dwDone == 0) {
                DebugPrint((4,
                    "Perfdisk!BuildVolumeList - Added %ws as drive %c\n",
                    pList[nListEntry].wszInstanceName,
                    pList[nListEntry].wcDriveLetter));

                // then the data fields have been satisfied so 
                // this entry is done and we can now go 
                // to the next entry in the caller's buffer
                if (nOldListEntry == -1) {
                    nListEntry++;
                }
            }
        }

        SetErrorMode (dwOrigErrorMode);

        // return the number of entries actually used here
        *pdwNumEntries = nListEntry;
    }

BVL_ERROR_EXIT:
    CloseHandle(hMountMgr);

    if (pMountPoints != NULL) {
        FREEMEM (hLibHeap, 0, pMountPoints);
#if DBG
        DebugPrint((4,
            "\tFreed mountpoints %d to %d\n", dwBufferSize, HeapUsed));
        dwBufferSize = 0;
#endif
    }

    DebugPrint((3, "BuildVolumeList: returning with %d entries\n", *pdwNumEntries));
    return dwReturnValue;
}

DWORD
MapLoadedDisks (
    HANDLE  hDiskPerf,
    PDRIVE_VOLUME_ENTRY pList,
    LPDWORD             pdwNumEntries,
    LPDWORD             pdwMaxVolNo,
    LPDWORD             pdwWmiItemCount
)
/*
    This function maps the hard disk partitions to the corresponding 
    volume and drive letter found in the list of volume entries 
    passed in by the caller.

    This function can use a handle to WMI if the caller has one, or if 
    not, it will try to open it's own.

*/
{
    DWORD   status = ERROR_SUCCESS; // return value of the function
    HANDLE  hWmiDiskPerf = NULL;    // local handle value 
    DWORD   dwLocalMaxVolNo = 0;
    DWORD   dwLocalWmiItemCount = 0;

    // WMI Buffer variables
    DWORD   WmiBufSize = 0;
    DWORD   WmiAllocSize = 0x8000;     
    LPBYTE  WmiBuffer = NULL;

    // WMI buffer processing variables
    PWNODE_ALL_DATA     WmiDiskInfo;
    DISK_PERFORMANCE    *pDiskPerformance;    //  Disk driver returns counters here
    DWORD               dwInstanceNameOffset;
    WORD                wNameLen;   // string length is first word in buffer
    LPWSTR              wszInstanceName; // pointer to string in WMI buffer
    
    WCHAR   wszInstName[MAX_PATH];
    DWORD   dwBytesToCopy;

    DWORD   dwListEntry;

    BOOL    bNotDone = TRUE;

    if (hDiskPerf == NULL) {
        // open handle to disk perf device driver
        status = WmiOpenBlock (
            (GUID *)&DiskPerfGuid,
            GENERIC_READ,
            &hWmiDiskPerf);
    } else {
        // use caller's handle
        hWmiDiskPerf = hDiskPerf;
    }

    assert (pList != NULL);
    assert (pdwNumEntries != NULL);
    assert (pdwMaxVolNo != NULL);

    DebugPrint((3, "MapLoadedDisks with %d entries %d volumes",
        *pdwNumEntries, *pdwMaxVolNo));
    if (status == ERROR_SUCCESS) {
        // allocate a buffer to send to WMI to get the diskperf data
        WmiBufSize = WmiAllocSize;
        WmiBuffer = (LPBYTE)ALLOCMEM (hLibHeap,  HEAP_FLAGS, WmiBufSize);

        if (WmiBuffer  == NULL) {
            status = ERROR_OUTOFMEMORY;
        } else {
#if DBG
            HeapUsed += WmiBufSize;
            DebugPrint((4,"\tWmiBuffer add %d to %d\n", WmiBufSize, HeapUsed));
#endif
            status = WmiQueryAllDataW (
                hWmiDiskPerf,
                &WmiBufSize,
                WmiBuffer);

            // if buffer size attempted is too big or too small, resize
            if ((WmiBufSize > 0) && (WmiBufSize != WmiAllocSize)) {
                WmiBuffer = (LPBYTE) REALLOCMEM (hLibHeap,
                    HEAP_FLAGS,  WmiBuffer, WmiBufSize);

                if (WmiBuffer == NULL) {
                    // reallocation failed so bail out
                    status = ERROR_OUTOFMEMORY;
                } else {
#if DBG
                    HeapUsed += (WmiBufSize - WmiAllocSize);
                    DebugPrint((4, "\tRealloc WmiBuffer old %d new %d to %d\n",
                        WmiAllocSize, WmiBufSize, HeapUsed));
#endif
                    WmiAllocSize = WmiBufSize;
                }
            }

            if (status == ERROR_INSUFFICIENT_BUFFER) {
                // if it didn't work because it was too small the first time
                // try one more time
                status = WmiQueryAllDataW (
                    hWmiDiskPerf,
                    &WmiBufSize,
                    WmiBuffer);
            
            } else {
                // it either worked the fisrt time or it failed because of 
                // something other than a buffer size problem
            }
        }

        if (status == ERROR_SUCCESS) {
            WmiDiskInfo = (PWNODE_ALL_DATA)WmiBuffer;
            // go through returned names and add to the buffer
            while (bNotDone) {
                pDiskPerformance = (PDISK_PERFORMANCE)(
                    (PUCHAR)WmiDiskInfo +  WmiDiskInfo->DataBlockOffset);
        
                dwInstanceNameOffset = WmiDiskInfo->DataBlockOffset + 
                                      ((sizeof(DISK_PERFORMANCE) + 1) & ~1) ;

                // get length of string (it's a counted string) length is in chars
                wNameLen = *(LPWORD)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset);

                if (wNameLen > 0) {
                    // just a sanity check here
                    assert (wNameLen < MAX_PATH);
                    // get pointer to string text
                    wszInstanceName = (LPWSTR)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset + sizeof(WORD));

                    // truncate to last characters if name is larger than the buffer in the table
                    if (wNameLen >= DVE_DEV_NAME_LEN) {
                        // copy the last DVE_DEV_NAME_LEN chars
                        wszInstanceName += (wNameLen  - DVE_DEV_NAME_LEN) + 1;
                        dwBytesToCopy = (DVE_DEV_NAME_LEN - 1) * sizeof(WCHAR);
                        wNameLen = DVE_DEV_NAME_LEN - 1;
                    } else {
                        dwBytesToCopy = wNameLen;
                    }
                    // copy it to the buffer to make it a SZ string
                    memcpy (wszInstName, &wszInstanceName[0], dwBytesToCopy);
                    // zero terminate it
                    wszInstName[wNameLen/sizeof(WCHAR)] = 0;

                    // find matching entry in list
                    // sent by caller and update
                    // the drive & partition info
                    for (dwListEntry = 0; 
                        dwListEntry < *pdwNumEntries;
                        dwListEntry++) {

                        DebugPrint((6,
                            "MapDrive: Comparing '%ws' to '%ws'(pList)\n",
                            wszInstName,
                            pList[dwListEntry].wszInstanceName));

                        if (lstrcmpW(wszInstName, pList[dwListEntry].wszInstanceName) == 0) {
                            // update entry and...
                            pList[dwListEntry].dwVolumeNumber = pDiskPerformance->StorageDeviceNumber;
                            memcpy (&pList[dwListEntry].szVolumeManager, 
                                pDiskPerformance->StorageManagerName,
                                sizeof(pDiskPerformance->StorageManagerName));
                            if (dwLocalMaxVolNo < pList[dwListEntry].dwVolumeNumber) {
                                dwLocalMaxVolNo = pList[dwListEntry].dwVolumeNumber;
                            }
                            DebugPrint ((2,
                                "MapDrive: Mapped %8.8s, %d to drive %c\n",
                                pList[dwListEntry].szVolumeManager,
                                pList[dwListEntry].dwVolumeNumber,
                                pList[dwListEntry].wcDriveLetter));

                            // break out of loop
                            dwListEntry = *pdwNumEntries; 
                        }
                    }
                    // count the number of entries
                    dwLocalWmiItemCount++;
                } else {
                    // no string to examine (length == 0)
                }

                // bump pointers inside WMI data block
                if (WmiDiskInfo->WnodeHeader.Linkage != 0) {
                    // continue
                    WmiDiskInfo = (PWNODE_ALL_DATA) (
                        (LPBYTE)WmiDiskInfo + WmiDiskInfo->WnodeHeader.Linkage);
                } else {
                    bNotDone = FALSE;
                }
            } // end while looking through the WMI data block
        }

        if (hDiskPerf == NULL) {
            // then the disk perf handle is local so close it
            status = WmiCloseBlock (hWmiDiskPerf);
        }

        *pdwMaxVolNo = dwLocalMaxVolNo;
        *pdwWmiItemCount = dwLocalWmiItemCount;
    }

    if (WmiBuffer != NULL) {
        FREEMEM (hLibHeap, 0, WmiBuffer);
#if DBG
        HeapUsed -= WmiBufSize;
        DebugPrint((4, "\tFreed WmiBuffer %d to %d\n", WmiBufSize, HeapUsed));
#endif
    }

    DebugPrint((3, "MapLoadedDisks returning with %d entries %d volumes",
        *pdwNumEntries, *pdwMaxVolNo));
    return status;

}

DWORD
GetDriveNameString (
    LPCWSTR             szDevicePath,
    DWORD               cchDevicePathSize,
    PDRIVE_VOLUME_ENTRY pList,
    DWORD               dwNumEntries,
    LPWSTR              szNameBuffer,
    LPDWORD             pcchNameBufferSize,
    LPCWSTR             szVolumeManagerName,
    DWORD               dwVolumeNumber,
    PDRIVE_VOLUME_ENTRY *ppVolume
)
/*
    This function will try to look up a disk device referenced by 
    it's Volume Manager Name and ID and return
    either the drive letter that corresponds to this disk as found in 
    the pList buffer or the generic name \HarddiskX\PartitionY if no 
    drive letter can be found.

    szDevicePath    IN: a partition or volume name in the format of
                            \Device\HarddiskX\PartitionY  or
                            \Device\VolumeX

    cchDevicePathSize   IN: length of the device Path in chars.

    pList           IN: pointer to an initialized list of drives, 
                            volumes and partitions

    dwNumEntries    IN: the number of drive letter entries in the pList buffer

    szNameBuffer    IN: pointer to buffer to receive the name of the
                            drive letter or name that corresponds to the
                            device specified by the szDevicePath buffer
                    OUT: pointer to buffer containing the name or drive 
                            letter of disk partition

    pcchNameBufferSize  IN: pointer to DWORD containing the size of the
                            szNameBuffer in characters
                    OUT: pointer to DWORD that contains the size of the
                        string returned in szNameBuffer

  The return value of this function can be one of the following values
    ERROR_SUCCESS   the function succeded and a string was returned in 
                    the buffer referenced by szNameBuffer

    
*/
{
    DWORD   dwReturnStatus = ERROR_SUCCESS;

    WCHAR   szLocalDevicePath[MAX_PATH];
    LPWSTR  szSrcPtr;
    DWORD   dwBytesToCopy;
    DWORD   dwThisEntry;
    DWORD   dwDestSize;

    ULONG64 *pllVolMgrName;
    PDRIVE_VOLUME_ENTRY pVolume = NULL;

    // validate the input arguments
    assert (szDevicePath != NULL);
    assert (*szDevicePath != 0);
    assert (cchDevicePathSize > 0);
    assert (cchDevicePathSize <= MAX_PATH);
    assert (pList != NULL);
    assert (dwNumEntries > 0);
    assert (szNameBuffer != NULL);
    assert (pcchNameBufferSize != NULL);
    assert (*pcchNameBufferSize > 0);

    pllVolMgrName = (ULONG64 *)szVolumeManagerName;

    DebugPrint((4, "GetDriveNameString: VolMgrName %ws\n", pllVolMgrName));
    if ((pllVolMgrName[0] == LL_LOGIDISK_0) && 
        (pllVolMgrName[1] == LL_LOGIDISK_1) &&
        ((dwVolumeNumber == 0) || (dwVolumeNumber == (ULONG)-1))) {
        // no short cut exists so look up by matching
        // the szDevicePath param to the wszInstanceName field

            assert (DVE_DEV_NAME_LEN < (sizeof(szLocalDevicePath)/sizeof(szLocalDevicePath[0])));
            szSrcPtr = (LPWSTR)szDevicePath;
            dwBytesToCopy = lstrlenW (szSrcPtr); // length is really in chars
            if (dwBytesToCopy >= DVE_DEV_NAME_LEN) {
                // copy the last DVE_DEV_NAME_LEN chars
                szSrcPtr += (dwBytesToCopy - DVE_DEV_NAME_LEN) + 1;
                dwBytesToCopy = (DVE_DEV_NAME_LEN - 1) * sizeof(WCHAR);
            } else {
                dwBytesToCopy *= sizeof(WCHAR);
            }
            // now dwBytesToCopy is in bytes
            memcpy (szLocalDevicePath, szSrcPtr, dwBytesToCopy);
            // null terminate
            assert ((dwBytesToCopy / sizeof(WCHAR)) < DVE_DEV_NAME_LEN);
            szLocalDevicePath[dwBytesToCopy / sizeof(WCHAR)] = 0;

        for (dwThisEntry = 0; dwThisEntry < dwNumEntries; dwThisEntry++) {
            if (lstrcmpW(szLocalDevicePath, pList[dwThisEntry].wszInstanceName) == 0) {
                break;
            }
        }
        // continue to assign letter
    } else {
        // use the faster look up

        for (dwThisEntry = 0; dwThisEntry < dwNumEntries; dwThisEntry++) {
            if (((pList[dwThisEntry].llVolMgr[0] == pllVolMgrName[0]) &&
                 (pList[dwThisEntry].llVolMgr[1] == pllVolMgrName[1])) &&
                 (pList[dwThisEntry].dwVolumeNumber == dwVolumeNumber)) {
                break;
            }
        }
    }

    DebugPrint((4, "GetDriveNameString: Trying long route %d %d\n", dwThisEntry, dwNumEntries));
    if (dwThisEntry < dwNumEntries) {
        // then a matching entry was found so copy the drive letter
        //then this is the matching entry
        if (pList[dwThisEntry].wcDriveLetter != 0) {
            DebugPrint((4,
                "GetDriveNameString: Found drive %c\n", pList[dwThisEntry].wcDriveLetter));
            if (*pcchNameBufferSize > 3) {
                szNameBuffer[0] = pList[dwThisEntry].wcDriveLetter;
                szNameBuffer[1] = L':';
                szNameBuffer[2] = 0;
                pVolume = &pList[dwThisEntry];
            } else {
                dwReturnStatus = ERROR_INSUFFICIENT_BUFFER;
            }
            *pcchNameBufferSize = 3;
        }
        else {
            DebugPrint((4,
                "GetDriveNameString: Missing drive->%ws\n", szDevicePath));
            // then this is a valid path, but doesn't match 
            // any assigned drive letters, so remove "\device\"
            // and copy the remainder of the string
            dwDestSize = cchDevicePathSize;
            dwDestSize -= SIZE_OF_DEVICE;   // subtract front of string not copied
            if (dwDestSize < *pcchNameBufferSize) {
                memcpy (szNameBuffer, &szDevicePath[SIZE_OF_DEVICE],
                (dwDestSize * sizeof (WCHAR)));
                szNameBuffer[dwDestSize] = 0;

                pVolume = &pList[dwThisEntry];
             } else {
                 dwReturnStatus = ERROR_INSUFFICIENT_BUFFER;
             }
             *pcchNameBufferSize = dwDestSize + 1;                
        }
    } else {
        DebugPrint((4,
            "GetDriveNameString: New drive->%ws\n", szDevicePath));
        // then this is a valid path, but doesn't match 
        // any assigned drive letters, so remove "\device\"
        // and copy the remainder of the string
        dwDestSize = cchDevicePathSize;
        dwDestSize -= SIZE_OF_DEVICE;   // subtract front of string not copied
        if (dwDestSize < *pcchNameBufferSize) {
            memcpy (szNameBuffer, &szDevicePath[SIZE_OF_DEVICE],
                (dwDestSize * sizeof (WCHAR)));
            szNameBuffer[dwDestSize] = 0;
        } else {
            dwReturnStatus = ERROR_INSUFFICIENT_BUFFER;
        }
        *pcchNameBufferSize = dwDestSize + 1;
    }
    DebugPrint((4, "GetDriveNameString: NameBufSize %d Entries %d\n",
        *pcchNameBufferSize, dwNumEntries));

    if (pVolume != NULL) {
        RefreshVolume(pVolume);
        *ppVolume = pVolume;
    }
    else {
        *ppVolume = NULL;
    }
    return dwReturnStatus;
}

DWORD
MakePhysDiskInstanceNames (
    PDRIVE_VOLUME_ENTRY pPhysDiskList,
    DWORD               dwNumPhysDiskListItems,
    LPDWORD             pdwMaxDriveNo,
    PDRIVE_VOLUME_ENTRY pVolumeList,
    DWORD               dwNumVolumeListItems
)
{
    DWORD   dwPDItem;
    DWORD   dwVLItem;
    WCHAR   szLocalInstanceName[MAX_PATH];
    WCHAR   *pszNextChar;
    DWORD   dwMaxDriveNo = 0;

    // for each HD in the PhysDisk List, 
    // find matching Volumes in the Volume list

    DebugPrint((3, "MakePhysDiskInstanceNames: maxdriveno %d\n",
        *pdwMaxDriveNo));

    DebugPrint((3, "Dumping final physical disk list\n"));
#if DBG
    DumpDiskList(pPhysDiskList, dwNumPhysDiskListItems);
#endif

    for (dwPDItem = 0; dwPDItem < dwNumPhysDiskListItems; dwPDItem++) {
        if (pPhysDiskList[dwPDItem].wPartNo != 0) {
            //only do partitions that might have logical volumes first
            // initialize the instance name for this HD
            for (dwVLItem = 0; dwVLItem < dwNumVolumeListItems; dwVLItem++) {

                DebugPrint((6,
                    "Phys Disk -- Comparing '%ws' to '%ws'\n",
                pPhysDiskList[dwPDItem].wszInstanceName,
                pVolumeList[dwVLItem].wszInstanceName));

                if (lstrcmpiW(pPhysDiskList[dwPDItem].wszInstanceName, 
                    pVolumeList[dwVLItem].wszInstanceName) == 0) {

                   DebugPrint ((4,
                       "Phys Disk: Drive/Part %d/%d (%s) is Logical Drive %c\n",
                       pPhysDiskList[dwPDItem].wDriveNo, 
                       pPhysDiskList[dwPDItem].wPartNo,
                       pPhysDiskList[dwPDItem].wszInstanceName,
                       pVolumeList[dwVLItem].wcDriveLetter));

                    // then this partition matches so copy the volume information
                    pPhysDiskList[dwPDItem].wcDriveLetter = 
                        pVolumeList[dwVLItem].wcDriveLetter;
                    pPhysDiskList[dwPDItem].llVolMgr[0] =
                        pVolumeList[dwVLItem].llVolMgr[0];
                    pPhysDiskList[dwPDItem].llVolMgr[1] =
                        pVolumeList[dwVLItem].llVolMgr[1];
                    pPhysDiskList[dwPDItem].dwVolumeNumber =
                        pVolumeList[dwVLItem].dwVolumeNumber;
                    // there should only one match so bail out and go to the next item
                    break;
                }
            }
        }
    }

    // all the partitions with volumes now have drive letters so build the physical 
    // drive instance strings

    for (dwPDItem = 0; dwPDItem < dwNumPhysDiskListItems; dwPDItem++) {
        if (pPhysDiskList[dwPDItem].wPartNo == 0) {
            // only do the physical partitions
            // save the \Device\HarddiskVolume path here
            lstrcpyW (szLocalInstanceName, pPhysDiskList[dwPDItem].wszInstanceName);
            // initialize the instance name for this HD
            memset(&pPhysDiskList[dwPDItem].wszInstanceName[0], 0, (DVE_DEV_NAME_LEN * sizeof(WCHAR)));
            _ltow ((LONG)pPhysDiskList[dwPDItem].wDriveNo, pPhysDiskList[dwPDItem].wszInstanceName, 10);
            pPhysDiskList[dwPDItem].wReserved = (WORD)(lstrlenW (pPhysDiskList[dwPDItem].wszInstanceName));
            // search the entries that are logical partitions of this drive
            for (dwVLItem = 0; dwVLItem < dwNumPhysDiskListItems; dwVLItem++) {
                if (pPhysDiskList[dwVLItem].wPartNo != 0) {

                        DebugPrint ((6, "Phys Disk: Comparing %d/%d (%s) to %d/%d\n",
                            pPhysDiskList[dwPDItem].wDriveNo,
                            pPhysDiskList[dwPDItem].wPartNo,
                            szLocalInstanceName,
                            pPhysDiskList[dwVLItem].wDriveNo,
                            pPhysDiskList[dwVLItem].wPartNo));

                    if ((pPhysDiskList[dwVLItem].wDriveNo == pPhysDiskList[dwPDItem].wDriveNo) &&
                        (pPhysDiskList[dwVLItem].wcDriveLetter >= L'A')) {  // only allow letters to be added
                        // then this logical drive is on the physical disk
                        pszNextChar = &pPhysDiskList[dwPDItem].wszInstanceName[0];
                        pszNextChar += pPhysDiskList[dwPDItem].wReserved;
                        *pszNextChar++ = L' ';
                        *pszNextChar++ = (WCHAR)(pPhysDiskList[dwVLItem].wcDriveLetter); 
                        *pszNextChar++ = L':';
                        *pszNextChar = L'\0';
                        pPhysDiskList[dwPDItem].wReserved += 3;

                        DebugPrint ((4, " -- Drive %c added.\n",
                            pPhysDiskList[dwVLItem].wcDriveLetter));

                        if ((DWORD)pPhysDiskList[dwPDItem].wDriveNo > dwMaxDriveNo) {
                            dwMaxDriveNo = (DWORD)pPhysDiskList[dwPDItem].wDriveNo;

                            DebugPrint((2,
                                "Phys Disk: Drive count now = %d\n",
                                dwMaxDriveNo));

                        }
                    }
                }
            }

            DebugPrint((2,
                "Mapped Phys Disk: '%ws'\n",
                pPhysDiskList[dwPDItem].wszInstanceName));

        } // else not a physical partition
    } //end of loop    

    // return max drive number
    *pdwMaxDriveNo = dwMaxDriveNo;

    DebugPrint((3, "MakePhysDiskInstanceNames: return maxdriveno %d\n",
        *pdwMaxDriveNo));
    return ERROR_SUCCESS;
}

DWORD
CompressPhysDiskTable (
    PDRIVE_VOLUME_ENTRY     pOrigTable,
    DWORD                   dwOrigCount,
    PDRIVE_VOLUME_ENTRY     pNewTable,
    DWORD                   dwNewCount
)
{
    DWORD   dwPDItem;
    DWORD   dwVLItem;
    DWORD   dwDriveId;

    for (dwPDItem = 0; dwPDItem < dwNewCount; dwPDItem++) {
        // for each drive entry in the new table find the matching 
        // harddisk entry in the original table
        dwDriveId = (WORD)dwPDItem;
        dwDriveId <<= 16;
        dwDriveId &= 0xFFFF0000;

        for (dwVLItem = 0; dwVLItem < dwOrigCount; dwVLItem++) {
            if (pOrigTable[dwVLItem].dwDriveId == dwDriveId) {

               DebugPrint((2,
                   "CompressPhysDiskTable:Phys Disk: phys drive %d is mapped as %s\n",
                   dwPDItem, pOrigTable[dwVLItem].wszInstanceName));

                // copy this entry
                memcpy (&pNewTable[dwPDItem], &pOrigTable[dwVLItem],
                    sizeof(DRIVE_VOLUME_ENTRY));
                break;
            }
        }
    }

    return ERROR_SUCCESS;
}


BOOL
GetPhysicalDriveNameString (
    DWORD                   dwDriveNumber,    
    PDRIVE_VOLUME_ENTRY     pList,
    DWORD                   dwNumEntries,
    LPWSTR                  szNameBuffer
)
{
    LPWSTR  szNewString = NULL;

    // see if the indexed entry matches
    if (dwNumEntries > 0) {
        if ((dwDriveNumber < dwNumEntries) && (!bUseNT4InstanceNames)) {
            if ((DWORD)(pList[dwDriveNumber].wDriveNo) == dwDriveNumber) {
                // this matches so we'll get the address of the instance string
                szNewString = &pList[dwDriveNumber].wszInstanceName[0];
            } else {
                // this drive number doesn't match the one in the table
            }
        } else {
            // this is an unknown drive no or we don't want to use
            // the fancy ones
        }
    } else {
        // no entries to look up
    }

    if (szNewString == NULL) {
        // then we have to make one 
        _ltow ((LONG)dwDriveNumber, szNameBuffer, 10);
    } else {
        lstrcpyW (szNameBuffer, szNewString);
    }

    return TRUE;
}

NTSTATUS
OpenDevice(
    IN PUNICODE_STRING DeviceName,
    OUT PHANDLE Handle
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK status_block;
    
    InitializeObjectAttributes(&objectAttributes,
        DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtOpenFile(Handle,
//                 (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                 (ACCESS_MASK) FILE_GENERIC_READ,
                 &objectAttributes,
                 &status_block,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_NONALERT // | FILE_DIRECTORY_FILE
                 );

    return status;
}

NTSTATUS
GetDeviceName(
    PMOUNTMGR_MOUNT_POINTS  pMountPoints,
    IN PMOUNTMGR_MOUNT_POINT Point,
    OUT PUNICODE_STRING DeviceName
    )
{
    PWCHAR pThisChar;
    DeviceName->Length = (WORD)(Point->SymbolicLinkNameLength + (WORD)sizeof(WCHAR));
    DeviceName->MaximumLength = (WORD)(DeviceName->Length + (WORD)sizeof(WCHAR));
    DeviceName->Buffer = (PWCHAR) ALLOCMEM(hLibHeap, HEAP_FLAGS, DeviceName->MaximumLength);
    if (DeviceName->Buffer == NULL)
        return STATUS_NO_MEMORY;
    memcpy(DeviceName->Buffer,
           (LPVOID)((PCHAR) pMountPoints + Point->SymbolicLinkNameOffset),
           Point->SymbolicLinkNameLength);

    DebugPrint((4, "GetDeviceName: %ws\n", DeviceName->Buffer));
    pThisChar = &DeviceName->Buffer[Point->SymbolicLinkNameLength / sizeof(WCHAR)];
    *pThisChar++ = L'\\';
    *pThisChar = 0;

    return STATUS_SUCCESS;
}

VOID
RefreshVolume(
    PDRIVE_VOLUME_ENTRY pVolume
    )
{
    LONGLONG CurrentTime, Interval;
    HANDLE hVolume;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK status_block;
    FILE_FS_SIZE_INFORMATION FsSizeInformation;
    ULONG AllocationUnitBytes;

    GetSystemTimeAsFileTime((LPFILETIME) &CurrentTime);
    Interval = (CurrentTime - pVolume->LastRefreshTime) / 10000000;
    if (Interval > g_lRefreshInterval) {
        pVolume->LastRefreshTime = CurrentTime;
        hVolume = pVolume->hVolume;
        if (hVolume == NULL) {
            NtStatus = OpenDevice(&pVolume->DeviceName, &hVolume);
            if (!NT_SUCCESS(NtStatus)) {
                hVolume = NULL;
            }
            else {
                pVolume->hVolume = hVolume;
            }
        }
        if (hVolume != NULL) {
            NtStatus = NtQueryVolumeInformationFile(hVolume,
                          &status_block,
                          &FsSizeInformation,
                          sizeof(FILE_FS_SIZE_INFORMATION),
                          FileFsSizeInformation);
        }

        if ( hVolume && NT_SUCCESS(NtStatus) ) {
             AllocationUnitBytes =
                 FsSizeInformation.BytesPerSector *
                 FsSizeInformation.SectorsPerAllocationUnit;
             pVolume->TotalBytes =  FsSizeInformation.TotalAllocationUnits.QuadPart *
                                     AllocationUnitBytes;

             pVolume->FreeBytes = FsSizeInformation.AvailableAllocationUnits.QuadPart *
                                     AllocationUnitBytes;

             //  Express in megabytes, truncated

             pVolume->TotalBytes /= (1024*1024);
             pVolume->FreeBytes /= (1024*1024);
        }
        if (g_lRefreshInterval > 0) {
            if (pVolume->hVolume != NULL) {
                NtClose(pVolume->hVolume);
            }
            pVolume->hVolume = NULL;
        }
    }
}

ULONG
GetDiskExtent(
    IN HANDLE hVol,
    IN OUT PVOLUME_DISK_EXTENTS *pVolExtents,
    IN OUT PULONG ReturnedSize
    )
{
    ULONG Size, nDisks = 10;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PVOLUME_DISK_EXTENTS Buffer;

    Size = *ReturnedSize;
    Buffer = *pVolExtents;

    *ReturnedSize = Size;
    Status = STATUS_BUFFER_OVERFLOW;
    while (Status == STATUS_BUFFER_OVERFLOW) {
        if (Buffer == NULL) {
            Size = sizeof(VOLUME_DISK_EXTENTS) + (nDisks * sizeof(DISK_EXTENT));
            Buffer = (PVOLUME_DISK_EXTENTS)
                     ALLOCMEM(hLibHeap, HEAP_FLAGS, Size);
            if (Buffer == NULL) {
                *pVolExtents = NULL;
                *ReturnedSize = 0;
                return 0;
            }
        }
        IoStatus.Status = 0;
        IoStatus.Information = 0;
        Status = NtDeviceIoControlFile(hVol,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                    NULL,
                    0,
                    (PVOID) Buffer,
                    Size);
        if (Status == STATUS_BUFFER_OVERFLOW) {
            nDisks = Buffer->NumberOfDiskExtents;
            FREEMEM(hLibHeap, 0, Buffer);
            Buffer = NULL;
        }
    }
    *pVolExtents = Buffer;
    *ReturnedSize = Size;

    if (!NT_SUCCESS(Status)) {
        DebugPrint((2, "GetDiskExtent: IOCTL Failure %X\n", Status));
        return 0;
    }
    return Buffer->NumberOfDiskExtents;
}

DWORD
FindNewVolumes (
    PDRIVE_VOLUME_ENTRY *ppPhysDiskList,
    LPDWORD             pdwNumPhysDiskListEntries,
    PDRIVE_VOLUME_ENTRY pVolumeList,
    DWORD               dwNumVolumeListItems
)
{
    DWORD dwVLItem;
    PVOLUME_DISK_EXTENTS      pVolExtents = NULL;
    ULONG             ReturnedSize = 0;
    PDRIVE_VOLUME_ENTRY pPhysDiskList, pDisk, pVolume;
    LIST_ENTRY NewVolumes, *pEntry;
    PDRIVE_LIST pNewDisk;
    DWORD dwNumPhysDiskListItems = *pdwNumPhysDiskListEntries;
    DWORD dwNewDisks = 0;
    UNICODE_STRING VolumeName;

    // for each HD in the PhysDisk List,
    // find matching Volumes in the Volume list

    DebugPrint((3, "FindNewVolumes: NumPhysDisk %d NumVol %d\n",
        *pdwNumPhysDiskListEntries, dwNumVolumeListItems));

    pPhysDiskList = *ppPhysDiskList;
    InitializeListHead(&NewVolumes);

    for (dwVLItem=0; dwVLItem < dwNumVolumeListItems; dwVLItem++) {
        ULONG nCount;
        HANDLE hVol;
        PDISK_EXTENT pDiskExtent;
        PWCHAR wszVolume;
        NTSTATUS status;

        pVolume = &pVolumeList[dwVLItem];
        if (LookupInstanceName(
                pVolume->wszInstanceName,
                pPhysDiskList,
                dwNumPhysDiskListItems,
                dwNumPhysDiskListItems) >= 0) {
            continue;
        }
        pEntry = NewVolumes.Flink;
        while (pEntry != &NewVolumes) {
            pDisk = &((PDRIVE_LIST)pEntry)->DiskEntry;
            if (!wcscmp(pDisk->wszInstanceName,
                        pVolume->wszInstanceName)) {
                    continue;
            }
            pEntry = pEntry->Flink;
        }
        wszVolume = &pVolume->wszInstanceName[0];
        RtlInitUnicodeString(&VolumeName, pVolume->wszInstanceName);
        nCount = VolumeName.Length / sizeof(WCHAR);
        if (nCount > 0) {
            if (wszVolume[nCount-1] == L'\\') {
                wszVolume[nCount-1] = 0;
                nCount--;
                VolumeName.Length -= sizeof(WCHAR);
            }
        }

        if (wszVolume != NULL && nCount > 0) {
            status = OpenDevice(&VolumeName, &hVol);
            DebugPrint((3, "Opening '%ws' with status %x\n", wszVolume, status));
            if (NT_SUCCESS(status) && (hVol != NULL)) {
                PDISK_EXTENT pExtent;
                nCount = GetDiskExtent(hVol, &pVolExtents, &ReturnedSize);
                DebugPrint((3, "nDisks = %d\n", nCount));
                if (nCount > 0) {
                    pExtent = &pVolExtents->Extents[0];
                    while (nCount-- > 0) {
                        if (dwNumPhysDiskListItems < INITIAL_NUM_VOL_LIST_ENTRIES) {
                            pDisk = &pPhysDiskList[dwNumPhysDiskListItems];
                            dwNumPhysDiskListItems++;
                        }
                        else {
                            pNewDisk = (PDRIVE_LIST)
                                       ALLOCMEM(hLibHeap, HEAP_ZERO_MEMORY, sizeof(DRIVE_LIST));
                            if (pNewDisk != NULL) {
                                dwNewDisks++;
                                pDisk = &pNewDisk->DiskEntry;
                                InsertTailList(&NewVolumes, &pNewDisk->Entry);
                            }
                            else {
                                pDisk = NULL;
                            }
                        }
                        if (pDisk == NULL) {
                            continue;
                        }
                        pDisk->wDriveNo = (WORD) pExtent->DiskNumber;
                        pDisk->wPartNo = 0xFF;
                        memcpy(pDisk->szVolumeManager, L"Partmgr ", sizeof(WCHAR) * 8);
                        wcscpy(pDisk->wszInstanceName, pVolume->wszInstanceName);

                        DebugPrint((3, "Extent %d Disk %d Start %I64u Size %I64u\n",
                            nCount, pExtent->DiskNumber,
                            pExtent->StartingOffset, pExtent->ExtentLength));
                        pExtent++;
                    }
                }
                NtClose(hVol);
            }
        }
    }
    if (pVolExtents != NULL) {
        FREEMEM(hLibHeap, 0, pVolExtents);
    }

    if ((!IsListEmpty(&NewVolumes)) && (dwNewDisks > 0)) {
        PDRIVE_VOLUME_ENTRY pOldBuffer;
        PDRIVE_LIST pOldDisk;

        pOldBuffer = pPhysDiskList;
        pPhysDiskList = (PDRIVE_VOLUME_ENTRY) REALLOCMEM(
            hLibHeap, HEAP_ZERO_MEMORY,
            pPhysDiskList, (dwNumPhysDiskListItems + dwNewDisks) * sizeof (DRIVE_VOLUME_ENTRY));
        if (pPhysDiskList == NULL) {
            DebugPrint((3, "MakePhysDiskInstance realloc failure"));
            FREEMEM(hLibHeap, 0, pOldBuffer);
            *ppPhysDiskList = NULL;
            return ERROR_OUTOFMEMORY;
        }
        //
        // NOTE: Below assumes Entry is the first thing in DRIVE_LIST!!
        //
        pEntry = NewVolumes.Flink;
        while (pEntry != &NewVolumes) {
            pNewDisk = (PDRIVE_LIST) pEntry;
            RtlCopyMemory(
                &pPhysDiskList[dwNumPhysDiskListItems],
                &pNewDisk->DiskEntry,
                sizeof(DRIVE_VOLUME_ENTRY));
            dwNumPhysDiskListItems++;
            pOldDisk = pNewDisk;
            pEntry = pEntry->Flink;
            FREEMEM(hLibHeap, 0, pOldDisk);
        }
    }
    *ppPhysDiskList = pPhysDiskList;
    *pdwNumPhysDiskListEntries = dwNumPhysDiskListItems;
    return ERROR_SUCCESS;
}

#if DBG
VOID
DumpDiskList(
    IN PDRIVE_VOLUME_ENTRY pList,
    IN ULONG nCount
    )
{
    ULONG i;

    for (i=0; i<nCount; i++) {
        DebugPrint((4, "\nEntry count       = %d\n", i));
        DebugPrint((4, "dwDriveId         = %X\n", pList[i].dwDriveId));
        DebugPrint((4, "DriveLetter       = %c\n",
            pList[i].wcDriveLetter == 0 ? ' ' : pList[i].wcDriveLetter));
        DebugPrint((4, "VolMgr            = %c%c%c%c%c%c%c%c\n",
            pList[i].szVolumeManager[0],
            pList[i].szVolumeManager[1],
            pList[i].szVolumeManager[2],
            pList[i].szVolumeManager[3],
            pList[i].szVolumeManager[4],
            pList[i].szVolumeManager[5],
            pList[i].szVolumeManager[6],
            pList[i].szVolumeManager[7]));
        DebugPrint((4, "VolumeNumber      = %d\n", pList[i].dwVolumeNumber));
        DebugPrint((4, "Handle            = %X\n", pList[i].hVolume));
        DebugPrint((4, "InstanceName      = %ws\n",
            pList[i].wszInstanceName));
        DebugPrint((4, "DeviceName        = %ws\n",
            pList[i].DeviceName.Buffer ? pList[i].DeviceName.Buffer : L""));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\physdisk.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    physdisk.c

Abstract:

    This file implements a Performance Object that presents
    Physical Disk Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#pragma warning ( disable : 4201 ) 
#include <ntdddisk.h>
#include <windows.h>
#include <ole2.h>
#include <wmium.h>
#pragma warning ( default : 4201 )
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfdisk.h"
#if _DBG_PRINT_INSTANCES
#include <wtypes.h>
#include <stdio.h>
#include <stdlib.h>
#endif
#include "diskmsg.h"
#include "dataphys.h"

DWORD APIENTRY
CollectPDiskObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the logical disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    PPDISK_DATA_DEFINITION      pPhysicalDiskDataDefinition;
    DWORD  TotalLen;            //  Length of the total return block
    PDISK_COUNTER_DATA          pcdTotal;

    DWORD   dwStatus    = ERROR_SUCCESS;
    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition = NULL;

    PWNODE_ALL_DATA WmiDiskInfo;
    DISK_PERFORMANCE            *pDiskPerformance;    //  Disk driver returns counters here

    PWCHAR  wszWmiInstanceName;
    WCHAR   wszInstanceName[MAX_PATH]; // the numbers shouldn't ever get this big
    DWORD   dwInstanceNameOffset;

    DWORD   dwNumPhysicalDisks = 0;

    PPDISK_COUNTER_DATA         pPCD;

    BOOL    bMoreEntries;

    LONGLONG    llTemp;
    DWORD       dwTemp;

    DWORD   dwReturn = ERROR_SUCCESS;
    WORD    wNameLength;

    BOOL    bSkip;

    DWORD       dwCurrentWmiObjCount = 0;
    DWORD       dwRemapCount = 10;

    DOUBLE      dReadTime, dWriteTime, dTransferTime;

    //
    //  Check for sufficient space for Physical Disk object
    //  type definition
    //

    do {
        dwNumPhysicalDisks = 0;
        // make sure the drive letter map is up-to-date
        if (bRemapDriveLetters) {
            dwStatus = MapDriveLetters();
            // MapDriveLetters clears the remap flag when successful
            if (dwStatus != ERROR_SUCCESS) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return dwStatus;
            }
        }

        pPhysicalDiskDataDefinition = (PDISK_DATA_DEFINITION *) *lppData;

        // clear the accumulator structure

        memset (&pcdTotal, 0, sizeof(pcdTotal));
        //
        //  Define Logical Disk data block
        //

        TotalLen = sizeof (PDISK_DATA_DEFINITION);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        memmove(pPhysicalDiskDataDefinition,
               &PhysicalDiskDataDefinition,
               sizeof(PDISK_DATA_DEFINITION));

        // read the data from the diskperf driver

        if (dwStatus == ERROR_SUCCESS) {

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                        &pPhysicalDiskDataDefinition[1];

            WmiDiskInfo = (PWNODE_ALL_DATA)WmiBuffer;

            // make sure the structure is valid
            if (WmiDiskInfo->WnodeHeader.BufferSize < sizeof(WNODE_ALL_DATA)) {
                bMoreEntries = FALSE;
                // just to make sure someone notices on a checked build
                assert (WmiDiskInfo->WnodeHeader.BufferSize >= sizeof(WNODE_ALL_DATA));
            } else {
                // make sure there are some entries to return
                bMoreEntries =
                    (WmiDiskInfo->InstanceCount > 0) ? TRUE : FALSE;
            }

            while (bMoreEntries) {

                pDiskPerformance = (PDISK_PERFORMANCE)(
                            (PUCHAR)WmiDiskInfo +  WmiDiskInfo->DataBlockOffset);
                dwInstanceNameOffset = *((LPDWORD)(
                            (LPBYTE)WmiDiskInfo +  WmiDiskInfo->OffsetInstanceNameOffsets));
                wNameLength = *(WORD *)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset);
                if (wNameLength > 0) {
                    wszWmiInstanceName = (LPWSTR)((LPBYTE)WmiDiskInfo + dwInstanceNameOffset + sizeof(WORD));

                    if (IsPhysicalDrive(pDiskPerformance)) {
#if _DBG_PRINT_INSTANCES
                        WCHAR szOutputBuffer[512];
#endif  
                        // then the format is correct AND this is a physical
                        // partition so set the name string pointer and
                        // length for use in creating the instance.
                        memset (wszInstanceName, 0, sizeof(wszInstanceName));
                        GetPhysicalDriveNameString (
                            pDiskPerformance->StorageDeviceNumber,
                            pPhysDiskList,
                            dwNumPhysDiskListEntries,
                            wszInstanceName);
#if _DBG_PRINT_INSTANCES
                        swprintf (szOutputBuffer, (LPCWSTR)L"\nPERFDISK: [%d] PhysDrive [%8.8s,%d] is mapped as: ",
                            dwNumPhysDiskListEntries,
                            pDiskPerformance->StorageManagerName,
                            pDiskPerformance->StorageDeviceNumber);
                        OutputDebugStringW (szOutputBuffer);
                        OutputDebugStringW (wszInstanceName);
#endif  
                        bSkip = FALSE;
                    } else {
                        bSkip = TRUE;
                    }           
                
                    if (!bSkip) {
                        // first see if there's room for this entry....

                        TotalLen =
                            // space already used
                            (DWORD)((PCHAR) pPerfInstanceDefinition -
                            (PCHAR) pPhysicalDiskDataDefinition)
                            // + estimate of this instance
                            +   sizeof(PERF_INSTANCE_DEFINITION)
                            +   (lstrlenW(wszInstanceName) + 1) * sizeof(WCHAR) ;
                        TotalLen = QWORD_MULTIPLE (TotalLen);
                        TotalLen += sizeof(PDISK_COUNTER_DATA);
                        TotalLen = QWORD_MULTIPLE (TotalLen);

                        if ( *lpcbTotalBytes < TotalLen ) {
                            *lpcbTotalBytes = (DWORD) 0;
                            *lpNumObjectTypes = (DWORD) 0;
                            dwReturn = ERROR_MORE_DATA;
                            break;
                        }

                        MonBuildInstanceDefinition(
                            pPerfInstanceDefinition,
                            (PVOID *) &pPCD,
                            0, 0,   // no parent
                            (DWORD)-1,// no unique ID
                            wszInstanceName);

                        // clear counter data block
                        memset (pPCD, 0, sizeof(PDISK_COUNTER_DATA));
                        pPCD->CounterBlock.ByteLength = sizeof(PDISK_COUNTER_DATA);

//                      KdPrint (("PERFDISK: (P)   Entry %8.8x for: %ws\n", (DWORD)pPCD, wszWmiInstanceName));

                        // insure quadword alignment of the data structure
                        assert (((DWORD)(pPCD) & 0x00000007) == 0);

                        //  Set up pointer for data collection

                        // the QueueDepth counter is only a byte so clear the unused bytes
                        pDiskPerformance->QueueDepth &= 0x000000FF;

                        //
                        //  Format and collect Physical data
                        //
                        pcdTotal.DiskCurrentQueueLength += pDiskPerformance->QueueDepth;
                        pPCD->DiskCurrentQueueLength = pDiskPerformance->QueueDepth;

                        llTemp = pDiskPerformance->ReadTime.QuadPart +
                                 pDiskPerformance->WriteTime.QuadPart;

                        // these values are read in 100 NS units but are expected
                        // to be in sys perf freq (tick) units for the Sec/op ctrs 
                        // so convert them here

                        dReadTime = (DOUBLE)(pDiskPerformance->ReadTime.QuadPart);
                        dWriteTime = (DOUBLE)(pDiskPerformance->WriteTime.QuadPart);
                        dTransferTime = (DOUBLE)(llTemp);

                        dReadTime *= dSysTickTo100Ns;
                        dWriteTime *= dSysTickTo100Ns;
                        dTransferTime *= dSysTickTo100Ns;

                        pPCD->DiskTime = llTemp;
                        pPCD->DiskAvgQueueLength = llTemp;
                        pcdTotal.DiskAvgQueueLength += llTemp;
                        pcdTotal.DiskTime += llTemp;

                        pPCD->DiskReadTime = pDiskPerformance->ReadTime.QuadPart;
                        pPCD->DiskReadQueueLength = pDiskPerformance->ReadTime.QuadPart;
                        pcdTotal.DiskReadTime +=  pDiskPerformance->ReadTime.QuadPart;
                        pcdTotal.DiskReadQueueLength += pDiskPerformance->ReadTime.QuadPart;

                        pPCD->DiskWriteTime = pDiskPerformance->WriteTime.QuadPart;
                        pPCD->DiskWriteQueueLength = pDiskPerformance->WriteTime.QuadPart;

                        pcdTotal.DiskWriteTime += pDiskPerformance->WriteTime.QuadPart;
                        pcdTotal.DiskWriteQueueLength += pDiskPerformance->WriteTime.QuadPart;

                        pPCD->DiskAvgTime = (LONGLONG)dTransferTime;
                        pcdTotal.DiskAvgTime += (LONGLONG)dTransferTime;

                        dwTemp = pDiskPerformance->ReadCount +
                                 pDiskPerformance->WriteCount;

                        pcdTotal.DiskTransfersBase1 += dwTemp;
                        pPCD->DiskTransfersBase1 = dwTemp;

                        pcdTotal.DiskAvgReadTime += (LONGLONG)dReadTime;
                        pPCD->DiskAvgReadTime = (LONGLONG)dReadTime;
                        pcdTotal.DiskReadsBase1 += pDiskPerformance->ReadCount;
                        pPCD->DiskReadsBase1 = pDiskPerformance->ReadCount;

                        pcdTotal.DiskAvgWriteTime += (LONGLONG)dWriteTime;
                        pPCD->DiskAvgWriteTime = (LONGLONG)dWriteTime;
                        pcdTotal.DiskWritesBase1 += pDiskPerformance->WriteCount;
                        pPCD->DiskWritesBase1 = pDiskPerformance->WriteCount;

                        pcdTotal.DiskTransfers += dwTemp;
                        pPCD->DiskTransfers = dwTemp;

                        pcdTotal.DiskReads += pDiskPerformance->ReadCount;
                        pPCD->DiskReads = pDiskPerformance->ReadCount;
                        pcdTotal.DiskWrites += pDiskPerformance->WriteCount;
                        pPCD->DiskWrites = pDiskPerformance->WriteCount;

                        llTemp = pDiskPerformance->BytesRead.QuadPart +
                                 pDiskPerformance->BytesWritten.QuadPart;
                        pcdTotal.DiskBytes += llTemp;
                        pPCD->DiskBytes = llTemp;

                        pcdTotal.DiskReadBytes += pDiskPerformance->BytesRead.QuadPart;
                        pPCD->DiskReadBytes = pDiskPerformance->BytesRead.QuadPart;
                        pcdTotal.DiskWriteBytes += pDiskPerformance->BytesWritten.QuadPart;
                        pPCD->DiskWriteBytes = pDiskPerformance->BytesWritten.QuadPart;

                        pcdTotal.DiskAvgBytes += llTemp;
                        pPCD->DiskAvgBytes = llTemp;
                        pcdTotal.DiskTransfersBase2 += dwTemp;
                        pPCD->DiskTransfersBase2 = dwTemp;

                        pcdTotal.DiskAvgReadBytes += pDiskPerformance->BytesRead.QuadPart;
                        pPCD->DiskAvgReadBytes = pDiskPerformance->BytesRead.QuadPart;
                        pcdTotal.DiskReadsBase2 += pDiskPerformance->ReadCount;
                        pPCD->DiskReadsBase2 = pDiskPerformance->ReadCount;

                        pcdTotal.DiskAvgWriteBytes += pDiskPerformance->BytesWritten.QuadPart;
                        pPCD->DiskAvgWriteBytes = pDiskPerformance->BytesWritten.QuadPart;
                        pcdTotal.DiskWritesBase2 += pDiskPerformance->WriteCount;
                        pPCD->DiskWritesBase2 = pDiskPerformance->WriteCount;

                        pPCD->IdleTime = pDiskPerformance->IdleTime.QuadPart;
                        pcdTotal.IdleTime += pDiskPerformance->IdleTime.QuadPart;
                        pPCD->SplitCount = pDiskPerformance->SplitCount;
                        pcdTotal.SplitCount += pDiskPerformance->SplitCount;

                        pPCD->DiskTimeTimeStamp = pDiskPerformance->QueryTime.QuadPart;
                        pcdTotal.DiskTimeTimeStamp += pDiskPerformance->QueryTime.QuadPart;

                        // move to the end of the buffer for the next instance
                        pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)&pPCD[1];
                        dwNumPhysicalDisks++;

                    } else {
//                      KdPrint (("PERFDISK: (P) Skipping Instance: %ws\n", wszWmiInstanceName));
                    }
                    // count the number of items returned by WMI
                    dwCurrentWmiObjCount++;
                } else {
                    // the name has 0 length so skip
                }
               
                // bump pointers inside WMI data block
                if (WmiDiskInfo->WnodeHeader.Linkage != 0) {
                    // continue
                    WmiDiskInfo = (PWNODE_ALL_DATA) (
                        (LPBYTE)WmiDiskInfo + WmiDiskInfo->WnodeHeader.Linkage);
                } else {
                    // this is the end of the line
                    bMoreEntries = FALSE;
                }
            } // end for each volume
            // see if number of WMI objects returned is different from
            // the last time the instance table was built, if so then 
            // remap the letters and redo the instances
            if (dwCurrentWmiObjCount != dwWmiDriveCount) {
                DebugPrint((1, "CollectPDisk: Remap Current %d Drive %d\n",
                    dwCurrentWmiObjCount, dwWmiDriveCount));
                bRemapDriveLetters = TRUE;
                dwRemapCount--;
            }
        } // end if mem init was successful
    } while (bRemapDriveLetters && dwRemapCount);


    if ((dwNumPhysicalDisks > 0) && (dwStatus == ERROR_SUCCESS)) {
        // see if there's room for this entry....

        TotalLen =
            // space already used
            (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pPhysicalDiskDataDefinition)
            // + estimate of this instance
            +   sizeof(PERF_INSTANCE_DEFINITION)
            +   (lstrlenW(wszTotal) + 1) * sizeof(WCHAR) ;
        TotalLen = QWORD_MULTIPLE (TotalLen);
        TotalLen += sizeof(PDISK_COUNTER_DATA);
        TotalLen = QWORD_MULTIPLE (TotalLen);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            dwReturn = ERROR_MORE_DATA;
        } else {
            // normalize the total times
            pcdTotal.DiskTime /= dwNumPhysicalDisks;
            pcdTotal.DiskReadTime /= dwNumPhysicalDisks;
            pcdTotal.DiskWriteTime /= dwNumPhysicalDisks;
            pcdTotal.IdleTime /= dwNumPhysicalDisks;
            pcdTotal.DiskTimeTimeStamp /= dwNumPhysicalDisks;

            MonBuildInstanceDefinition(
                pPerfInstanceDefinition,
                (PVOID *) &pPCD,
                0,
                0,
                (DWORD)-1,
                wszTotal);

            // update the total counters

            // insure quadword alignment of the data structure
            assert (((DWORD)(pPCD) & 0x00000007) == 0);
            memcpy (pPCD, &pcdTotal, sizeof (pcdTotal));
            pPCD->CounterBlock.ByteLength = sizeof(PDISK_COUNTER_DATA);

            // and update the "next byte" pointer
            pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)&pPCD[1];

            // update pointer to next available buffer...
            pPhysicalDiskDataDefinition->DiskObjectType.NumInstances =
                dwNumPhysicalDisks + 1; // add 1 for "Total" disk
        }
    } else {
        //  If we are diskless, then return no instances
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pPhysicalDiskDataDefinition[1];
        pPhysicalDiskDataDefinition->DiskObjectType.NumInstances = 0;
    }

    if (dwReturn == ERROR_SUCCESS) {
        *lpcbTotalBytes =
            pPhysicalDiskDataDefinition->DiskObjectType.TotalByteLength =
                (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pPhysicalDiskDataDefinition);

#if DBG
        // sanity check on buffer size estimates
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFDISK: Physical Disk Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFDISK:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) pPerfInstanceDefinition;

        *lpNumObjectTypes = 1;
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\logidisk.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    logidisk.c

Abstract:

    This file implements a Performance Object that presents
    Logical Disk Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#pragma warning ( disable : 4201 ) 
#include <ntdddisk.h>
#include <windows.h>
#include <ole2.h>
#include <wmium.h>
#pragma warning ( default : 4201 )
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfdisk.h"
#include "diskmsg.h"
#include "datalogi.h"

DWORD APIENTRY
CollectLDiskObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the logical disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    PLDISK_DATA_DEFINITION      pLogicalDiskDataDefinition;
    DWORD  TotalLen;            //  Length of the total return block
    LDISK_COUNTER_DATA          lcdTotal;

    DWORD   dwStatus    = ERROR_SUCCESS;
    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition;

    PWNODE_ALL_DATA WmiDiskInfo;
    DISK_PERFORMANCE            *pDiskPerformance;    //  Disk driver returns counters here

    PWCHAR  wszInstanceName;
    DWORD   dwInstanceNameOffset;

    DWORD   dwNumLogicalDisks;

    WCHAR   wszTempName[MAX_PATH];
    WORD    wNameLength;
    WCHAR   wszDriveName[MAX_PATH];
    DWORD   dwDriveNameSize;

    PLDISK_COUNTER_DATA         pLCD;

    BOOL    bMoreEntries;

    DWORD   dwReturn = ERROR_SUCCESS;

    LONGLONG    llTemp;
    DWORD       dwTemp;
    PDRIVE_VOLUME_ENTRY pVolume;

    LONGLONG    TotalBytes;
    LONGLONG    FreeBytes;

    DWORD       dwCurrentWmiObjCount = 0;
    DWORD       dwRemapCount = 10;

    DOUBLE      dReadTime, dWriteTime, dTransferTime;

    //
    //  Check for sufficient space for Logical Disk object
    //  type definition
    //

    do {
        dwNumLogicalDisks = 0;
        // make sure the drive letter map is up-to-date
        if (bRemapDriveLetters) {
            dwStatus = MapDriveLetters();
            // MapDriveLetters clears the remap flag when successful
            if (dwStatus != ERROR_SUCCESS) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return dwStatus;
            }
        }

        pLogicalDiskDataDefinition = (LDISK_DATA_DEFINITION *) *lppData;

        // clear the accumulator structure

        memset (&lcdTotal, 0, sizeof(lcdTotal));
        //
        //  Define Logical Disk data block
        //

        TotalLen = sizeof (LDISK_DATA_DEFINITION);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        memmove(pLogicalDiskDataDefinition,
               &LogicalDiskDataDefinition,
               sizeof(LDISK_DATA_DEFINITION));


        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pLogicalDiskDataDefinition[1];

        WmiDiskInfo = (PWNODE_ALL_DATA)WmiBuffer;

        // make sure the structure is valid
        if (WmiDiskInfo->WnodeHeader.BufferSize < sizeof(WNODE_ALL_DATA)) {
            bMoreEntries = FALSE;
            // just to make sure someone notices on a checked build
            assert (WmiDiskInfo->WnodeHeader.BufferSize >= sizeof(WNODE_ALL_DATA));
        } else {
            // make sure there are some entries to return
            bMoreEntries =
                (WmiDiskInfo->InstanceCount > 0) ? TRUE : FALSE;
        }

        while (bMoreEntries) {
            ULONG64 StorageManagerName[2];

            pDiskPerformance = (PDISK_PERFORMANCE)(
                        (PUCHAR)WmiDiskInfo +  WmiDiskInfo->DataBlockOffset);
            dwInstanceNameOffset = (sizeof(DISK_PERFORMANCE)+1) & ~1;
            wNameLength = *(WORD *)((LPBYTE)pDiskPerformance +
                                            dwInstanceNameOffset);
            if (wNameLength > 0) {
                wszInstanceName = (LPWSTR)((LPBYTE)pDiskPerformance +
                                           dwInstanceNameOffset + sizeof(WORD));

                // copy to local buffer for processing
                if (wNameLength >= MAX_PATH)
                    wNameLength = MAX_PATH-1; // truncate if necessary
                // copy text
                memcpy (wszTempName, wszInstanceName, wNameLength);
                // then null terminate
                wNameLength /= 2;
                wszTempName[wNameLength] = 0;
                memcpy(&StorageManagerName[0],
                    &pDiskPerformance->StorageManagerName[0],
                    2*sizeof(ULONG64));

                DebugPrint((4,
                    "PERFDISK: Logical Disk Instance: %ws\n", wszTempName));
                // see if this is a Physical Drive
                if (!IsPhysicalDrive(pDiskPerformance)) {
                    // it's not so get the name of it for this instance
                    dwDriveNameSize = sizeof (wszDriveName)
                                        / sizeof(wszDriveName[0]);
                    dwStatus = GetDriveNameString (
                        wszTempName, 
                        (DWORD)wNameLength,
                        pVolumeList,
                        dwNumVolumeListEntries,
                        wszDriveName,
                        &dwDriveNameSize,
                        (LPCWSTR) &StorageManagerName[0],
                        pDiskPerformance->StorageDeviceNumber,
                        &pVolume);
                    if (dwStatus != ERROR_SUCCESS) {
                        // just so we have a name
                        lstrcpyW (wszDriveName, wszTempName);
                        dwDriveNameSize = lstrlenW(wszDriveName);
                    }
                    DebugPrint((4, "\t loaded as %ws\n", wszDriveName));

                    TotalLen =
                        // space already used
                        (DWORD)((PCHAR) pPerfInstanceDefinition -
                            (PCHAR) pLogicalDiskDataDefinition)
                        // + estimate of this instance
                        +   sizeof(PERF_INSTANCE_DEFINITION)
                        +   (dwDriveNameSize + 1) * sizeof(WCHAR) ;
                    TotalLen = QWORD_MULTIPLE (TotalLen);
                    TotalLen += sizeof(LDISK_COUNTER_DATA);
                    TotalLen = QWORD_MULTIPLE (TotalLen);

                    if ( *lpcbTotalBytes < TotalLen ) {
                        *lpcbTotalBytes = (DWORD) 0;
                        *lpNumObjectTypes = (DWORD) 0;
                        dwReturn = ERROR_MORE_DATA;
                        break;
                    }

                    MonBuildInstanceDefinition(
                        pPerfInstanceDefinition,
                        (PVOID *) &pLCD,
                        0, 0,   // no parent
                        (DWORD)-1,// no unique ID
                        &wszDriveName[0]);

                    // insure quadword alignment of the data structure
                    assert (((DWORD)(pLCD) & 0x00000007) == 0);

                    //  Set up pointer for data collection

                    // the QueueDepth counter is only a byte so clear the unused bytes
                    pDiskPerformance->QueueDepth &= 0x000000FF;

                    //
                    //  Format and collect Physical data
                    //
                    lcdTotal.DiskCurrentQueueLength += pDiskPerformance->QueueDepth;
                    pLCD->DiskCurrentQueueLength = pDiskPerformance->QueueDepth;

                    llTemp = pDiskPerformance->ReadTime.QuadPart +
                             pDiskPerformance->WriteTime.QuadPart;

                    // these values are read in 100 NS units but are expected
                    // to be in sys perf freq (tick) units for the Sec/op ctrs 
                    // so convert them here

                    dReadTime = (DOUBLE)(pDiskPerformance->ReadTime.QuadPart);
                    dWriteTime = (DOUBLE)(pDiskPerformance->WriteTime.QuadPart);
                    dTransferTime = (DOUBLE)(llTemp);

                    dReadTime *= dSysTickTo100Ns;
                    dWriteTime *= dSysTickTo100Ns;
                    dTransferTime *= dSysTickTo100Ns;

                    pLCD->DiskTime = llTemp;
                    pLCD->DiskAvgQueueLength = llTemp;
                    lcdTotal.DiskAvgQueueLength += llTemp;
                    lcdTotal.DiskTime += llTemp;

                    pLCD->DiskReadTime = pDiskPerformance->ReadTime.QuadPart;
                    pLCD->DiskReadQueueLength = pDiskPerformance->ReadTime.QuadPart;
                    lcdTotal.DiskReadTime +=  pDiskPerformance->ReadTime.QuadPart;
                    lcdTotal.DiskReadQueueLength += pDiskPerformance->ReadTime.QuadPart;

                    pLCD->DiskWriteTime = pDiskPerformance->WriteTime.QuadPart;
                    pLCD->DiskWriteQueueLength = pDiskPerformance->WriteTime.QuadPart;

                    lcdTotal.DiskWriteTime += pDiskPerformance->WriteTime.QuadPart;
                    lcdTotal.DiskWriteQueueLength += pDiskPerformance->WriteTime.QuadPart;

                    pLCD->DiskAvgTime = (LONGLONG)dTransferTime;
                    lcdTotal.DiskAvgTime += (LONGLONG)dTransferTime;

                    dwTemp = pDiskPerformance->ReadCount +
                             pDiskPerformance->WriteCount;

                    lcdTotal.DiskTransfersBase1 += dwTemp;
                    pLCD->DiskTransfersBase1 = dwTemp;

                    lcdTotal.DiskAvgReadTime += (LONGLONG)dReadTime;
                    pLCD->DiskAvgReadTime = (LONGLONG)dReadTime;
                    lcdTotal.DiskReadsBase1 += pDiskPerformance->ReadCount;
                    pLCD->DiskReadsBase1 = pDiskPerformance->ReadCount;

                    lcdTotal.DiskAvgWriteTime += (LONGLONG)dWriteTime;
                    pLCD->DiskAvgWriteTime = (LONGLONG)dWriteTime;
                    lcdTotal.DiskWritesBase1 += pDiskPerformance->WriteCount;
                    pLCD->DiskWritesBase1 = pDiskPerformance->WriteCount;

                    lcdTotal.DiskTransfers += dwTemp;
                    pLCD->DiskTransfers = dwTemp;

                    lcdTotal.DiskReads += pDiskPerformance->ReadCount;
                    pLCD->DiskReads = pDiskPerformance->ReadCount;
                    lcdTotal.DiskWrites += pDiskPerformance->WriteCount;
                    pLCD->DiskWrites = pDiskPerformance->WriteCount;

                    llTemp = pDiskPerformance->BytesRead.QuadPart +
                             pDiskPerformance->BytesWritten.QuadPart;
                    lcdTotal.DiskBytes += llTemp;
                    pLCD->DiskBytes = llTemp;

                    lcdTotal.DiskReadBytes += pDiskPerformance->BytesRead.QuadPart;
                    pLCD->DiskReadBytes = pDiskPerformance->BytesRead.QuadPart;
                    lcdTotal.DiskWriteBytes += pDiskPerformance->BytesWritten.QuadPart;
                    pLCD->DiskWriteBytes = pDiskPerformance->BytesWritten.QuadPart;

                    lcdTotal.DiskAvgBytes += llTemp;
                    pLCD->DiskAvgBytes = llTemp;
                    lcdTotal.DiskTransfersBase2 += dwTemp;
                    pLCD->DiskTransfersBase2 = dwTemp;

                    lcdTotal.DiskAvgReadBytes += pDiskPerformance->BytesRead.QuadPart;
                    pLCD->DiskAvgReadBytes = pDiskPerformance->BytesRead.QuadPart;
                    lcdTotal.DiskReadsBase2 += pDiskPerformance->ReadCount;
                    pLCD->DiskReadsBase2 = pDiskPerformance->ReadCount;

                    lcdTotal.DiskAvgWriteBytes += pDiskPerformance->BytesWritten.QuadPart;
                    pLCD->DiskAvgWriteBytes = pDiskPerformance->BytesWritten.QuadPart;
                    lcdTotal.DiskWritesBase2 += pDiskPerformance->WriteCount;
                    pLCD->DiskWritesBase2 = pDiskPerformance->WriteCount;

                    pLCD->IdleTime = pDiskPerformance->IdleTime.QuadPart;
                    lcdTotal.IdleTime += pDiskPerformance->IdleTime.QuadPart;
                    pLCD->SplitCount = pDiskPerformance->SplitCount;
                    lcdTotal.SplitCount += pDiskPerformance->SplitCount;

                    pLCD->DiskTimeTimestamp = pDiskPerformance->QueryTime.QuadPart;
                    lcdTotal.DiskTimeTimestamp += pDiskPerformance->QueryTime.QuadPart;

                    if (pVolume != NULL) {
                        TotalBytes = pVolume->TotalBytes;
                        FreeBytes = pVolume->FreeBytes;

                        //  First two yield percentage of free space;
                        //  last is for raw count of free space in megabytes

                        lcdTotal.DiskFreeMbytes1 +=
                            pLCD->DiskFreeMbytes1 = (DWORD)FreeBytes;

                        lcdTotal.DiskTotalMbytes +=
                            pLCD->DiskTotalMbytes = (DWORD)TotalBytes;
                        lcdTotal.DiskFreeMbytes2 +=
                            pLCD->DiskFreeMbytes2 = (DWORD)FreeBytes;
                    } else {
                        if (!NT_SUCCESS (dwStatus)) {
                            if (!bShownDiskVolumeMessage) {
                                bShownDiskVolumeMessage = ReportEvent (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    PERFDISK_UNABLE_QUERY_VOLUME_INFO,
                                    NULL,
                                    0,
                                    sizeof(DWORD),
                                    NULL,
                                    (LPVOID)&dwStatus);
                            }
                        }
                        // Cannot get space information
                        pLCD->DiskFreeMbytes1 = 0;
                        pLCD->DiskTotalMbytes = 0;
                        pLCD->DiskFreeMbytes2 = 0;
                    }

                    // bump pointers in Perf Data Block
                    dwNumLogicalDisks++;
                    pLCD->CounterBlock.ByteLength = sizeof (LDISK_COUNTER_DATA);
                    pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)&pLCD[1];

                } else {
                    // this is a physical drive entry so skip it
#if _DBG_PRINT_INSTANCES
                    OutputDebugStringW ((LPCWSTR)L" (skipped)");
#endif
                }
                // count the number of items returned
                dwCurrentWmiObjCount++;
            } else {
                // 0 length name string so skip
            }
            // bump pointers inside WMI data block
            if (WmiDiskInfo->WnodeHeader.Linkage != 0) {
                // continue
                WmiDiskInfo = (PWNODE_ALL_DATA) (
                    (LPBYTE)WmiDiskInfo + WmiDiskInfo->WnodeHeader.Linkage);
            } else {
                // this is the end of the line
                bMoreEntries = FALSE;
            }

        } // end for each volume

        // see if number of WMI objects returned is different from
        // the last time the instance table was built, if so then 
        // remap the letters and redo the instances
        if (dwCurrentWmiObjCount != dwWmiDriveCount) {
            DebugPrint((1, "CollectLDisk: Remap Current %d Drive %d\n",
                dwCurrentWmiObjCount, dwWmiDriveCount));
            bRemapDriveLetters = TRUE;
            dwRemapCount--;
        }
    } while (bRemapDriveLetters && dwRemapCount);

    if (dwNumLogicalDisks > 0) {
        // see if there's room for the TOTAL entry....

        TotalLen =
            // space already used
            (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pLogicalDiskDataDefinition)
            // + estimate of this instance
            +   sizeof(PERF_INSTANCE_DEFINITION)
            +   (lstrlenW(wszTotal) + 1) * sizeof(WCHAR) ;
        TotalLen = QWORD_MULTIPLE (TotalLen);
        TotalLen += sizeof(LDISK_COUNTER_DATA);
        TotalLen = QWORD_MULTIPLE (TotalLen);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            dwReturn = ERROR_MORE_DATA;
        } else {
            // normalize the total times
            lcdTotal.DiskTime /= dwNumLogicalDisks;
            lcdTotal.DiskReadTime /= dwNumLogicalDisks;
            lcdTotal.DiskWriteTime /= dwNumLogicalDisks;
            lcdTotal.IdleTime /= dwNumLogicalDisks;
            lcdTotal.DiskTimeTimestamp /= dwNumLogicalDisks;

            MonBuildInstanceDefinition(
                pPerfInstanceDefinition,
                (PVOID *) &pLCD,
                0,
                0,
                (DWORD)-1,
                wszTotal);

            // update the total counters

            // insure quadword alignment of the data structure
            assert (((DWORD)(pLCD) & 0x00000007) == 0);
            memcpy (pLCD, &lcdTotal, sizeof (lcdTotal));
            pLCD->CounterBlock.ByteLength = sizeof(LDISK_COUNTER_DATA);

            // and update the "next byte" pointer
            pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)&pLCD[1];

            // update pointer to next available buffer...
            pLogicalDiskDataDefinition->DiskObjectType.NumInstances =
                dwNumLogicalDisks + 1; // add 1 for "Total" disk
        }
    } else {
        // there are  no instances so adjust the pointer for the 
        // rest of the code 
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pLogicalDiskDataDefinition[1];
    }

    if (dwReturn == ERROR_SUCCESS) {
        *lpcbTotalBytes =
            pLogicalDiskDataDefinition->DiskObjectType.TotalByteLength =
                (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pLogicalDiskDataDefinition);

#if DBG
        // sanity check on buffer size estimates
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFDISK: Logical Disk Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFDISK:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) pPerfInstanceDefinition;

        *lpNumObjectTypes = 1;

    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\databrws.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    databrws.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Browser Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "databrws.h"

// dummy variable for field sizing.
static BROWSER_COUNTER_DATA   bcd;

BROWSER_DATA_DEFINITION BrowserDataDefinition =
{
    {   sizeof (BROWSER_DATA_DEFINITION) + sizeof (BROWSER_COUNTER_DATA),
        sizeof (BROWSER_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        BROWSER_OBJECT_TITLE_INDEX,
        0,
        53,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(BROWSER_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) /
            sizeof (PERF_COUNTER_DEFINITION),
        0,
        -1,
        UNICODE_CODE_PAGE,
        {0L, 0L},
        {0L, 0L}
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        54,
        0,
        55,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (bcd.ServerAnnounce),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerAnnounce
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        78,
        0,
        79,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (bcd.DomainAnnounce),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->DomainAnnounce
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        188,
        0,
        813,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (bcd.TotalAnnounce),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->TotalAnnounce
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        80,
        0,
        81,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.ElectionPacket),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ElectionPacket
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        82,
        0,
        83,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.MailslotWrite),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotWrite
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        84,
        0,
        85,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.ServerList),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerList
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        156,
        0,
        161,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.ServerEnum),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerEnum
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        158,
        0,
        163,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.DomainEnum),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->DomainEnum
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        160,
        0,
        165,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.OtherEnum),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->OtherEnum
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        190,
        0,
        815,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.TotalEnum),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->TotalEnum
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        162,
        0,
        167,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.ServerAnnounceMiss),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerAnnounceMiss
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        164,
        0,
        169,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MailslotDatagramMiss),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotDatagramMiss
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        166,
        0,
        171,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.ServerListMiss),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerListMiss
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        168,
        0,
        381,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.ServerAnnounceAllocMiss),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->ServerAnnounceAllocMiss
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        170,
        0,
        383,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MailslotAllocFail),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotAllocFail
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        806,
        0,
        385,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MailslotReceiveFail),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotReceiveFail
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        808,
        0,
        387,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MailslotWriteFail),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotWriteFail
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        810,
        0,
        807,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (bcd.MailslotOpenFail),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MailslotOpenFail
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        812,
        0,
        809,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (bcd.MasterAnnounceDup),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->MasterAnnounceDup
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        814,
        0,
        811,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (bcd.DatagramIllegal),
        (DWORD)(ULONG_PTR)&((BROWSER_COUNTER_DATA *)0)->DatagramIllegal
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\disk\perfdisk.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfdisk.c

Abstract:


Author:

    Bob Watson (a-robw) Aug 95

Revision History:

--*/

// define the WMI Guids for this program
#ifndef INITGUID
#define INITGUID 1
#endif  

//
// Force everything to be UNICODE
//
#ifndef UNICODE
#define UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>
#include <ole2.h>
#pragma warning ( disable : 4201 ) 
#include <wmium.h>
#pragma warning ( default : 4201 )
#include <wmiguid.h>
#include <winperf.h>
#if DBG
#include <stdio.h>
#include <stdlib.h>
#endif
#include <ntprfctr.h>
#include <perfutil.h>
#include <assert.h>
#include "perfdisk.h"
#include "diskmsg.h"

// define this symbol to test if diskperf has installed itself
//  as an upper filter
// if this symbol is undefined, then check for diskperf before
//  returning any logical disk counters
#define _DONT_CHECK_FOR_VOLUME_FILTER

#ifndef _DONT_CHECK_FOR_VOLUME_FILTER
#include <regstr.h>     // for REGSTR_VAL_UPPERFILTERS
#endif

// bit field definitions for collect function flags

#define POS_COLLECT_PDISK_DATA      ((DWORD)0x00000001)
#define POS_COLLECT_LDISK_DATA      ((DWORD)0x00000003)
#define POS_COLLECT_IGNORE          ((DWORD)0x80000000)

#define POS_COLLECT_GLOBAL_DATA     ((DWORD)0x00000003)
#define POS_COLLECT_FOREIGN_DATA    ((DWORD)0)
#define POS_COLLECT_COSTLY_DATA     ((DWORD)0)

// global variables to this DLL

HANDLE  ThisDLLHandle = NULL;
HANDLE  hEventLog     = NULL;
HANDLE  hLibHeap      = NULL;

BOOL    bShownDiskPerfMessage = FALSE;
BOOL    bShownDiskVolumeMessage = FALSE;

LPWSTR  wszTotal = NULL;

const WCHAR cszNT4InstanceNames[] = {L"NT4 Instance Names"};
const WCHAR cszRegKeyPath[] = {L"System\\CurrentControlSet\\Services\\PerfDisk\\Performance"};

const WCHAR cszVolumeKey[] = {L"SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"};
const WCHAR cszRefreshInterval[] = {L"VolumeSpaceRefreshInterval"};

#define DISKPERF_SERVICE_NAME L"DiskPerf"
ULONG CheckVolumeFilter();

PDRIVE_VOLUME_ENTRY pPhysDiskList = NULL;
DWORD               dwNumPhysDiskListEntries = 0;
PDRIVE_VOLUME_ENTRY pVolumeList = NULL;
DWORD               dwNumVolumeListEntries = 0;
DWORD               dwWmiDriveCount = 0;
BOOL                bRemapDriveLetters = TRUE;
DWORD               dwMaxVolumeNumber = 0;

// start off with a big buffer then size according to return values
DWORD   WmiBufSize  = 0x10000;   // this can be smaller when the Diskperf.sys 
DWORD   WmiAllocSize = 0x10000;  // function is fixed to return the right status
LPBYTE  WmiBuffer   = NULL;

// variables local to this module

static POS_FUNCTION_INFO    posDataFuncInfo[] = {
    {LOGICAL_DISK_OBJECT_TITLE_INDEX,   POS_COLLECT_LDISK_DATA,     0, CollectLDiskObjectData},
    {PHYSICAL_DISK_OBJECT_TITLE_INDEX,  POS_COLLECT_PDISK_DATA,     0, CollectPDiskObjectData}
};

#define POS_NUM_FUNCS   (sizeof(posDataFuncInfo) / sizeof(posDataFuncInfo[1]))

static  bInitOk  = FALSE;
static  DWORD   dwOpenCount = 0;

WMIHANDLE   hWmiDiskPerf = NULL;

PM_OPEN_PROC    OpenDiskObject;
PM_COLLECT_PROC CollecDiskObjectData;
PM_CLOSE_PROC   CloseDiskObject;

DOUBLE      dSysTickTo100Ns;

#if DBG
const WCHAR cszDebugPrintLevel[] = {L"DebugPrintLevel"};

#define DEBUG_BUFFER_LENGTH MAX_PATH*2

ULONG_PTR HeapUsed = 0;
ULONG oldPLSize = 0;
ULONG oldVLSize = 0;
ULONG wszSize = 0;

ULONG PerfDiskDebug = 0;
UCHAR PerfDiskDebugBuffer[DEBUG_BUFFER_LENGTH];

#endif


BOOL
WriteNewBootTimeEntry (
    LONGLONG *pBootTime
)
{
    LONG    lStatus;
    HKEY    hKeyPerfDiskPerf;
    DWORD   dwType, dwSize;
    BOOL    bReturn = FALSE;

    // try to read the registry value of the last time
    // this error was reported 
    lStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        cszRegKeyPath,
        (DWORD)0,
        KEY_WRITE,
        &hKeyPerfDiskPerf);
    if (lStatus == ERROR_SUCCESS) {
        // read the key value
        dwType = REG_BINARY;
        dwSize = sizeof (*pBootTime);
        lStatus = RegSetValueExW (
            hKeyPerfDiskPerf,
            (LPCWSTR)L"SystemStartTimeOfLastErrorMsg",
            0L,  // reserved 
            dwType,
            (LPBYTE)pBootTime,
            dwSize);
        if (lStatus == ERROR_SUCCESS) {
            bReturn = TRUE;
        } else {
            // the value hasn't been written and 
            SetLastError (lStatus);
        } // else assume the value hasn't been written and 
          // return FALSE
        RegCloseKey (hKeyPerfDiskPerf);
    } else {
        // assume the value hasn't been written and 
        SetLastError (lStatus);
    }

    return bReturn;
}
BOOL
NT4NamesAreDefault ()
{
    LONG    lStatus;
    HKEY    hKeyPerfDiskPerf;
    DWORD   dwType, dwSize;
    DWORD   dwValue;
    BOOL    bReturn = FALSE;

    // try to read the registry value of the last time
    // this error was reported 
    lStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        cszRegKeyPath,
        (DWORD)0,
        KEY_READ,
        &hKeyPerfDiskPerf);
    if (lStatus == ERROR_SUCCESS) {
        // read the key value
        dwType = 0;
        dwSize = sizeof (dwValue);
        lStatus = RegQueryValueExW (
            hKeyPerfDiskPerf,
            cszNT4InstanceNames,
            0L,  // reserved 
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);
        if ((lStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            if (dwValue != 0) {
                bReturn = TRUE;
            } 
        } else {
            // the key is not present or not accessible so
            // leave default as is and 
            // return FALSE
        }
        RegCloseKey (hKeyPerfDiskPerf);
    } else {
        // the key could not be opened.
        SetLastError (lStatus);
    }

    return bReturn;
}

BOOL
SystemHasBeenRestartedSinceLastEntry (
    DWORD   dwReserved, // just in case we want to have multiple tests in the future
    LONGLONG *pBootTime // a buffer to receive the current boot time
)
{
    BOOL        bReturn = TRUE;
    NTSTATUS    ntStatus = ERROR_SUCCESS;
    SYSTEM_TIMEOFDAY_INFORMATION    SysTimeInfo;
    DWORD       dwReturnedBufferSize = 0;
    HKEY        hKeyPerfDiskPerf;
    LONG        lStatus;
    DWORD       dwType;
    DWORD       dwSize;
    LONGLONG    llLastErrorStartTime;

    DBG_UNREFERENCED_PARAMETER(dwReserved);

    // get the current system boot time (as a filetime)
    memset ((LPVOID)&SysTimeInfo, 0, sizeof(SysTimeInfo));

    ntStatus = NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &SysTimeInfo,
        sizeof(SysTimeInfo),
        &dwReturnedBufferSize
        );

    if (NT_SUCCESS(ntStatus)) {
        // try to read the registry value of the last time
        // this error was reported 
        lStatus = RegOpenKeyExW (
            HKEY_LOCAL_MACHINE,
            cszRegKeyPath,
            (DWORD)0,
            KEY_READ,
            &hKeyPerfDiskPerf);
        if (lStatus == ERROR_SUCCESS) {
            // read the key value
            dwType = 0;
            dwSize = sizeof (llLastErrorStartTime);
            lStatus = RegQueryValueExW (
                hKeyPerfDiskPerf,
                (LPCWSTR)L"SystemStartTimeOfLastErrorMsg",
                0L,  // reserved 
                &dwType,
                (LPBYTE)&llLastErrorStartTime,
                &dwSize);
            if (lStatus == ERROR_SUCCESS) {
                assert (dwType == REG_BINARY);  // this should be a binary type
                assert (dwSize == sizeof (LONGLONG)); // and it should be 8 bytes long
                // compare times
                // if the times are the same, then this message has already been
                // written since the last boot so we don't need to do it again.
                if (SysTimeInfo.BootTime.QuadPart ==
                    llLastErrorStartTime) {
                    bReturn = FALSE;
                } // else they are the different times so return FALSE
            } // else assume the value hasn't been written and 
              // return TRUE
            RegCloseKey (hKeyPerfDiskPerf);
        } // else assume the value hasn't been written and 
          // return TRUE

        // return the boot time if a buffer was passed in
        if (pBootTime != NULL) {
            // save the time
            *pBootTime = SysTimeInfo.BootTime.QuadPart;
        }
    } // else assume that it has been rebooted and return TRUE

    return bReturn;
}

static
BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    perform any initialization function that apply to all object
    modules
   
--*/
{
    BOOL    bReturn = TRUE;
    WCHAR   wszTempBuffer[512];
    LONG    lStatus;
    DWORD   dwBufferSize;
    HKEY    hKeyPerfDiskPerf;

    LARGE_INTEGER   liSysTick;

    UNREFERENCED_PARAMETER(DllHandle);

    // create heap for this library
    if (hLibHeap == NULL) hLibHeap = HeapCreate (0, 1, 0);
    assert (hLibHeap != NULL);

    if (hLibHeap == NULL) {
        return FALSE;
    }
    // open handle to the event log
    if (hEventLog == NULL) hEventLog = MonOpenEventLog((LPWSTR)L"PerfDisk");
    assert (hEventLog != NULL);

    lStatus = GetPerflibKeyValue (
        szTotalValue,
        REG_SZ,
        sizeof(wszTempBuffer),
        (LPVOID)&wszTempBuffer[0],
        DEFAULT_TOTAL_STRING_LEN,
        (LPVOID)&szDefaultTotalString[0]);

    if (lStatus == ERROR_SUCCESS) {
        // then a string was returned in the temp buffer
        dwBufferSize = lstrlenW (wszTempBuffer) + 1;
        dwBufferSize *= sizeof (WCHAR);
        wszTotal = ALLOCMEM (hLibHeap, HEAP_ZERO_MEMORY, dwBufferSize);
        if (wszTotal == NULL) {
            // unable to allocate buffer so use static buffer
            wszTotal = (LPWSTR)&szDefaultTotalString[0];
        } else {
            memcpy (wszTotal, wszTempBuffer, dwBufferSize);
#if DBG
            HeapUsed += dwBufferSize;
            wszSize = dwBufferSize;
            DebugPrint((4,
                "DllAttach: wszTotal add %d to %d\n",
                dwBufferSize, HeapUsed));
#endif
        }
    } else {
        // unable to get string from registry so just use static buffer
        wszTotal = (LPWSTR)&szDefaultTotalString[0];
    }

    QueryPerformanceFrequency (&liSysTick);
    dSysTickTo100Ns = (DOUBLE)liSysTick.QuadPart;
    dSysTickTo100Ns /= 10000000.0;

    lStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        cszRegKeyPath,
        (DWORD)0,
        KEY_READ,
        &hKeyPerfDiskPerf);
    if (lStatus == ERROR_SUCCESS) {
        DWORD dwType = REG_DWORD;
        DWORD dwSize = sizeof(DWORD);
        ULONG interval;
        lStatus = RegQueryValueExW (
                    hKeyPerfDiskPerf,
                    cszRefreshInterval,
                    0L,  // reserved
                    &dwType,
                    (LPBYTE)&interval,
                    &dwSize);
        if ((lStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            g_lRefreshInterval = interval;
        }
#if DBG
        dwSize = sizeof(DWORD);
        dwType = REG_DWORD;
        lStatus = RegQueryValueExW (
                    hKeyPerfDiskPerf,
                    cszDebugPrintLevel,
                    0L,
                    &dwType,
                    (LPBYTE) &interval,
                    &dwSize);
        if ((lStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            PerfDiskDebug = interval;
        }
#endif
        RegCloseKey (hKeyPerfDiskPerf);
    }

    return bReturn;
}

static
BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    UNREFERENCED_PARAMETER(DllHandle);

    if (dwOpenCount > 0) {
        // then close the object now, since the DLL's being discarded
        // prematurely, this is our last chance.
        // this is to insure the object is closed.
        dwOpenCount = 1;
        CloseDiskObject();
    }

    if ((wszTotal != NULL) && (wszTotal != &szDefaultTotalString[0])) {
        FREEMEM (hLibHeap, 0, wszTotal);
#if DBG
        HeapUsed -= wszSize;
        DebugPrint((4,
            "DllDetach: wsz freed %d to %d\n",
            wszSize, HeapUsed));
        wszSize = 0;
#endif
        wszTotal = NULL;
    }

    if (HeapDestroy (hLibHeap)) {
        hLibHeap = NULL;
        pVolumeList = NULL;
        pPhysDiskList = NULL;
        dwNumVolumeListEntries = 0;
        dwNumPhysDiskListEntries = 0;
    }

    if (hEventLog != NULL) {
        MonCloseEventLog ();
    }
    return TRUE;
}

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    ReservedAndUnused;

    // this will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach (DLLHandle);

        case DLL_PROCESS_DETACH:
            return DllProcessDetach (DLLHandle);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            return TRUE;
    }
}

DWORD APIENTRY
MapDriveLetters()
{
    DWORD   status = ERROR_SUCCESS;
    DWORD   dwLoopCount;   
    PDRIVE_VOLUME_ENTRY pTempPtr;
    DWORD   dwDriveCount;
    DWORD   dwThisEntry;
    PVOID   pOldBuffer;
#if DBG
    LONG64 startTime, endTime;
    LONG elapsed;
#endif

    if (pPhysDiskList != NULL) {
        FREEMEM (hLibHeap, 0, pPhysDiskList);
#if DBG
        HeapUsed -= oldPLSize;
        DebugPrint((4,"MapDriveLetters: PL Freed %d to %d\n",
            oldPLSize, HeapUsed));
        oldPLSize = 0;
#endif
        pPhysDiskList = NULL;
    }
#ifdef DBG
    GetSystemTimeAsFileTime((LPFILETIME) &startTime);
    DebugPrint((1, "BEGIN MapDriveLetters:\n",
                   status));
#endif
    dwNumPhysDiskListEntries = INITIAL_NUM_VOL_LIST_ENTRIES;

    // Initially allocate enough entries for drives A through Z
    pPhysDiskList = (PDRIVE_VOLUME_ENTRY)ALLOCMEM (
        hLibHeap, HEAP_ZERO_MEMORY, 
        (dwNumPhysDiskListEntries * sizeof (DRIVE_VOLUME_ENTRY)));

#if DBG
    if (pPhysDiskList == NULL) {
        DebugPrint((2,
            "MapDriveLetters: pPhysDiskList alloc failure\n"));
    }
#endif

    if (pPhysDiskList != NULL) {
        // try until we get a big enough buffer
#if DBG
        ULONG oldsize = dwNumPhysDiskListEntries * sizeof(DRIVE_VOLUME_ENTRY);
        HeapUsed += oldsize;
        oldPLSize = oldsize;
        DebugPrint((4, "MapDriveLetter: Alloc %d to %d\n",
            oldsize, HeapUsed));
#endif
        dwLoopCount = 10;   // no more than 10 retries to get the right size
        while ((status = BuildPhysDiskList (
                hWmiDiskPerf,
                pPhysDiskList,
                &dwNumPhysDiskListEntries)) == ERROR_INSUFFICIENT_BUFFER) {

            DebugPrint ((3,
                "MapDriveLetters: BuildPhysDiskList returns: %d, requesting %d entries\n",
                status, dwNumPhysDiskListEntries));
#if DBG
            if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
                DebugPrint((2,
                    "\tERROR! pPhysDiskList %X corrupted BuildPhysDiskList\n",
                    pPhysDiskList));
                DbgBreakPoint();
            }
#endif

            // if ERROR_INSUFFICIENT_BUFFER, then 
            // dwNumPhysDiskListEntries should contain the required size
            pOldBuffer = pPhysDiskList;
            pPhysDiskList = (PDRIVE_VOLUME_ENTRY)REALLOCMEM (
                hLibHeap, HEAP_ZERO_MEMORY, 
                pPhysDiskList, (dwNumPhysDiskListEntries * sizeof (DRIVE_VOLUME_ENTRY)));

            if (pPhysDiskList == NULL) {
                // bail if the allocation failed
                DebugPrint((2,
                    "MapDriveLetters: pPhysDiskList realloc failure\n"));
                status = ERROR_OUTOFMEMORY;
                FREEMEM(hLibHeap, 0, pOldBuffer);
                break;
            }
#if DBG
            else {
                HeapUsed -= oldsize; // subtract the old size and add new size
                oldPLSize = dwNumPhysDiskListEntries*sizeof(DRIVE_VOLUME_ENTRY);
                HeapUsed += oldPLSize;
                DebugPrint((4,
                    "MapDriveLetter: Realloc old %d new %d to %d\n",
                    oldsize, oldPLSize, HeapUsed));
            }
#endif
            dwLoopCount--;
            if (!dwLoopCount) {
                status = ERROR_OUTOFMEMORY;
                break;
            }
            DebugPrint ((3,
                "MapDriveLetters: %d retrying BuildPhysDiskList with %d entries\n",
                status, dwNumPhysDiskListEntries));
        }
    }

    else {      // do not bother going any further if no memory
        return ERROR_OUTOFMEMORY;
    }

    DebugPrint ((4,
        "MapDriveLetters: BuildPhysDiskList returns: %d\n", status));
#if DBG
    if (pPhysDiskList != NULL) {
        if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
            DebugPrint((2, "\tERROR! pPhysDiskList %X corrupted after Builds\n",
                pPhysDiskList));
            DbgBreakPoint();
        }
    }
#endif

    if (pVolumeList != NULL) {
        // close any open handles
        dwThisEntry = dwNumVolumeListEntries;
        while (dwThisEntry != 0) {
            dwThisEntry--;
            if (pVolumeList[dwThisEntry].hVolume != NULL) {
                NtClose (pVolumeList[dwThisEntry].hVolume);
            }
        } 
#if DBG
        HeapUsed -= oldVLSize;
        DebugPrint((4,"MapDriveLetters: VL Freed %d to %d\n",
            oldVLSize, HeapUsed));
        oldVLSize = 0;
        if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
            DebugPrint((2, "\tERROR! pVolumeList %X is corrupted before free\n",
                pVolumeList));
            DbgBreakPoint();
        }
#endif
        FREEMEM (hLibHeap, 0, pVolumeList);
        pVolumeList = NULL;
    }
    dwNumVolumeListEntries = INITIAL_NUM_VOL_LIST_ENTRIES;

    // Initially allocate enough entries for letters C through Z
    pVolumeList = (PDRIVE_VOLUME_ENTRY)ALLOCMEM (
        hLibHeap, HEAP_ZERO_MEMORY, 
        (dwNumVolumeListEntries * sizeof (DRIVE_VOLUME_ENTRY)));

#if DBG
    if (pVolumeList == NULL) {
        DebugPrint((2,
            "MapDriveLetters: pPhysVolumeList alloc failure\n"));
    }
#endif

    if (pVolumeList != NULL) {
        // try until we get a big enough buffer
#if DBG
        ULONG oldsize = dwNumVolumeListEntries * sizeof (DRIVE_VOLUME_ENTRY);
        HeapUsed += oldsize;
        oldVLSize = oldsize;
        DebugPrint((4,
            "MapDriveLetter: Add %d HeapUsed %d\n", oldsize, HeapUsed));
#endif
        dwLoopCount = 10;   // no more than 10 retries to get the right size
        while ((status = BuildVolumeList (
                pVolumeList,
                &dwNumVolumeListEntries)) == ERROR_INSUFFICIENT_BUFFER) {
            // if ERROR_INSUFFICIENT_BUFFER, then 

            DebugPrint ((3,
                "MapDriveLetters: BuildVolumeList returns: %d, requesting %d entries\n",
                status, dwNumVolumeListEntries));

#if DBG
            if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
                DebugPrint((2, "\tERROR! pVolumeList %X corrupted in while\n",
                    pVolumeList));
                DbgBreakPoint();
            }
#endif
            // dwNumVolumeListEntries should contain the required size
            pOldBuffer = pVolumeList;
            pVolumeList = (PDRIVE_VOLUME_ENTRY)REALLOCMEM (
                hLibHeap, HEAP_ZERO_MEMORY, 
                pVolumeList, (dwNumVolumeListEntries * sizeof (DRIVE_VOLUME_ENTRY)));

            if (pVolumeList == NULL) {
                // bail if the allocation failed
                DebugPrint((2,
                    "MapDriveLetters: pPhysVolumeList realloc failure\n"));
                status = ERROR_OUTOFMEMORY;
                FREEMEM(hLibHeap, 0, pOldBuffer);
                break;
            }
#if DBG
            else {
                if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
                    DebugPrint((2, "\tpVolumeList %X corrupted - realloc\n",
                        pVolumeList));
                    DbgBreakPoint();
                }
                HeapUsed -= oldsize; // subtract the old size and add new size
                oldVLSize = dwNumVolumeListEntries*sizeof(DRIVE_VOLUME_ENTRY);
                HeapUsed += oldVLSize;
                DebugPrint((4,
                    "MapDriveLetter: Realloc old %d new %d to %d\n",
                    oldsize, oldVLSize, HeapUsed));
            }
#endif
            dwLoopCount--;
            if (!dwLoopCount) {
                status = ERROR_OUTOFMEMORY;
                break;
            }
            DebugPrint ((3,
                "MapDriveLetters: retrying BuildVolumeList with %d entries\n",
                status, dwNumVolumeListEntries));
        }

        DebugPrint ((4, "MapDriveLetters: BuildVolumeList returns %d\n", status));

#if DBG
        if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
            DebugPrint((2, "\tpVolumeList %X corrupted after build\n",
                pVolumeList));
            DbgBreakPoint();
        }
#endif

        if (status == ERROR_SUCCESS) {
            status = FindNewVolumes(
                        &pPhysDiskList,
                        &dwNumPhysDiskListEntries,
                        pVolumeList,
                        dwNumVolumeListEntries);
        }

        // now map the disks to their drive letters 
        if (status == ERROR_SUCCESS) {
            status = MapLoadedDisks (
                hWmiDiskPerf,
                pVolumeList,
                &dwNumVolumeListEntries,
                &dwMaxVolumeNumber,
                &dwWmiDriveCount
                );

            DebugPrint ((4,
                "MapDriveLetters: MapLoadedDisks returns status %d %d MaxVol %d WmiDrive\n",
                status, dwNumVolumeListEntries,
                dwMaxVolumeNumber, dwWmiDriveCount));
        }
        
#if DBG
        if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
            DebugPrint((2, "\tpVolumeList %X corrupted by MapLoadedDisks\n",
                pVolumeList));
            DbgBreakPoint();
        }
#endif

        if (status == ERROR_SUCCESS) {
            // now assign drive letters to the phys disk list
            dwDriveCount = 0;
            status = MakePhysDiskInstanceNames (
                    pPhysDiskList,
                    dwNumPhysDiskListEntries,
                    &dwDriveCount,
                    pVolumeList,
                    dwNumVolumeListEntries);
        
#if DBG
        if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
            DebugPrint((2, "\tpPhysList %X corrupted by MakePhysDiskInst\n",
                pPhysDiskList));
            DbgBreakPoint();
        }
#endif
            if (status == ERROR_SUCCESS) {
                // then compress this into an indexed table
                // save original pointer
                pTempPtr = pPhysDiskList;

                // the function returns the last Drive ID
                // so we need to add 1 here to the count to include
                // the "0" drive
                dwDriveCount += 1;

                DebugPrint ((4, "\tDrive count now = %d\n",
                    dwDriveCount));

                // and allocate just enough for the actual physical drives
                pPhysDiskList = (PDRIVE_VOLUME_ENTRY)ALLOCMEM (
                    hLibHeap, HEAP_ZERO_MEMORY, 
                    (dwDriveCount * sizeof (DRIVE_VOLUME_ENTRY)));

                if (pPhysDiskList != NULL) {
                    status = CompressPhysDiskTable (
                        pTempPtr,
                        dwNumPhysDiskListEntries,
                        pPhysDiskList,
                        dwDriveCount);
        
#if DBG
        if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
            DebugPrint((2, "\tpPhysList %X corrupted by CompressPhys\n",
                pPhysDiskList));
            DbgBreakPoint();
        }
#endif
                    if (status == ERROR_SUCCESS) {
                        dwNumPhysDiskListEntries = dwDriveCount;
                    }
                    else {  // free if cannot compress
                        FREEMEM(hLibHeap, 0, pPhysDiskList);
#if DBG
                        HeapUsed -= dwDriveCount * sizeof(DRIVE_VOLUME_ENTRY);
                        DebugPrint((4,
                            "MapDriveLetters: Compress freed %d to %d\n",
                            dwDriveCount*sizeof(DRIVE_VOLUME_ENTRY), HeapUsed));
#endif
                        pPhysDiskList = NULL;
                    }
                } else {
                    DebugPrint((2,"MapDriveLetters: pPhysDiskList alloc fail for compress\n"));
                    status = ERROR_OUTOFMEMORY;
                }
                if (pTempPtr) {     // Free the previous list
                    FREEMEM(hLibHeap, 0, pTempPtr);
#if DBG
                    HeapUsed -= oldPLSize;
                    DebugPrint((4,
                        "MapDriveLetters: tempPtr freed %d to %d\n",
                        oldPLSize, HeapUsed));
                    oldPLSize = 0;
#endif
                }
#if DBG
                if (status == ERROR_SUCCESS) {
                    oldPLSize = dwDriveCount * sizeof(DRIVE_VOLUME_ENTRY);
                    HeapUsed += oldPLSize;
                    DebugPrint((4,
                        "MapDriveLetters: Compress add %d to %d\n",
                        oldPLSize, HeapUsed));
                }
#endif
            }
        }
        if (status == ERROR_SUCCESS) {
            // clear the remap flag
            bRemapDriveLetters = FALSE;
        }
    } else {
        status = ERROR_OUTOFMEMORY;
    }
#if DBG
    GetSystemTimeAsFileTime((LPFILETIME) &endTime);
    elapsed = (LONG) ((endTime - startTime) / 10000);
    DebugPrint((1, "END MapDriveLetters: %d msec\n\n", elapsed));
#endif

    // TODO: Need to keep track of different status for PhysDisk & Volumes
    //       If Physdisk succeeds whereas Volume fails, need to log event
    //       and try and continue with Physdisk counters
    // TODO Post W2K: Free stuff if status != ERROR_SUCCESS
    return status;
}

DWORD APIENTRY
OpenDiskObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    LONGLONG    llLastBootTime;
    BOOL        bWriteMessage;
#if DBG
    LONG64 startTime, endTime;
    LONG elapsed;
#endif

    UNREFERENCED_PARAMETER (lpDeviceNames);

#ifdef DBG
    GetSystemTimeAsFileTime((LPFILETIME) &startTime);
    DebugPrint((1, "BEGIN OpenDiskObject:\n",
                   status));
#endif

    if (dwOpenCount == 0) {
        status = WmiOpenBlock (
            (GUID *)&DiskPerfGuid,
            GENERIC_READ,
            &hWmiDiskPerf);

#if DBG
        GetSystemTimeAsFileTime((LPFILETIME) &endTime);
        elapsed = (LONG) ((endTime - startTime) / 10000);
        DebugPrint((3, "WmiOpenBlock returns: %d in %d msec after BEGIN\n",
                   status, elapsed));
#endif

        if (status == ERROR_SUCCESS) {
            // build drive map
            status = MapDriveLetters();

            DebugPrint((3,
                "OpenDiskObject: MapDriveLetters returns: %d\n", status));
        }
        // determine instance name format
        bUseNT4InstanceNames = NT4NamesAreDefault();
#if DBG
        GetSystemTimeAsFileTime((LPFILETIME) &endTime);
        elapsed = (LONG) ((endTime - startTime) / 10000);
        DebugPrint((3,
            "OpenDiskObject: NT4Names - %d msec after BEGIN\n", status));
#endif

        if (status == ERROR_SUCCESS) {
            bInitOk = TRUE;
        }
    }

    if (status != ERROR_SUCCESS) {
        // check to see if this is a WMI error and if so only 
        // write the error once per boot cycle

        if (status == ERROR_WMI_GUID_NOT_FOUND) {
            bWriteMessage = SystemHasBeenRestartedSinceLastEntry (
                0, &llLastBootTime);
    
            if (bWriteMessage) {
                // update registry time
                WriteNewBootTimeEntry (&llLastBootTime);
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    PERFDISK_UNABLE_QUERY_DISKPERF_INFO,
                    NULL,
                    0,
                    sizeof(DWORD),
                    NULL,
                    (LPVOID)&status);
            } // else it's already been written
        } else {
            // always write other messages
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFDISK_UNABLE_OPEN,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }
    } else {
        dwOpenCount++;
#ifndef _DONT_CHECK_FOR_VOLUME_FILTER
        if (!CheckVolumeFilter()) {
            posDataFuncInfo[0].dwCollectFunctionBit |= POS_COLLECT_IGNORE;
        }
#if DBG
        GetSystemTimeAsFileTime((LPFILETIME) &endTime);
        elapsed = (LONG) ((endTime - startTime) / 10000);
        DebugPrint((3,
            "OpenDiskObject: CheckVolFilter - %d msec after BEGIN\n", status));
#endif
#endif
    }

#if DBG
    if (status == ERROR_SUCCESS) {
        if (pPhysDiskList) {
            DebugPrint((4, "\t Validating pPhysDiskList %X at end Open\n",
                pPhysDiskList));
            if (!HeapValidate(hLibHeap, 0, pPhysDiskList)) {
                DebugPrint((2, "OpenDiskObject: PhysDiskList heap corrupt!\n"));
                DbgBreakPoint();
            }
        }
        if (pVolumeList) {
            DebugPrint((4, "\t Validating pVolumeList %X at end Open\n",
                pVolumeList));
            if (!HeapValidate(hLibHeap, 0, pVolumeList)) {
                DebugPrint((2, "OpenDiskObject: VolumeList heap corrupt!\n"));
                DbgBreakPoint();
            }
        }
        if (WmiBuffer) {
            DebugPrint((4, "\t Validating WmiBuffer %X at end Open\n",
                WmiBuffer));
            if (!HeapValidate(hLibHeap, 0, WmiBuffer)) {
                DebugPrint((2, "OpenDiskObject: WmiBuffer heap corrupt!\n"));
                DbgBreakPoint();
            }
        }
    }
    GetSystemTimeAsFileTime((LPFILETIME) &endTime);
    elapsed = (LONG) ((endTime - startTime) / 10000);
    DebugPrint((1, "END OpenDiskObject: %d msec\n\n", elapsed));
#endif
    return  status;
}

DWORD APIENTRY
CollectDiskObjectData (
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN       LPWSTR   lpValueName
            pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    NTSTATUS    Status;

    // build bit mask of functions to call

    DWORD       dwQueryType;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;

    DWORD       dwNumObjectsFromFunction;
    DWORD       dwOrigBuffSize;
    DWORD       dwByteSize;
#if DBG
    LONG64 startTime, endTime;
    LONG elapsed;

    GetSystemTimeAsFileTime((LPFILETIME) &startTime);
    DebugPrint((1, "BEGIN CollectDiskObject:\n"));
#endif

    if (!bInitOk) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        bShownDiskPerfMessage = TRUE;
        goto COLLECT_BAIL_OUT;
    }

    dwQueryType = GetQueryType (lpValueName);

    switch (dwQueryType) {
        case QUERY_ITEMS:
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (IsNumberInUnicodeList (
                    posDataFuncInfo[FunctionIndex].dwObjectId, lpValueName)) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                }
            }
            break;

        case QUERY_GLOBAL:
            FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
            break;

        case QUERY_FOREIGN:
            FunctionCallMask = POS_COLLECT_FOREIGN_DATA;
            break;

        case QUERY_COSTLY:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;

        default:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;
    }

    // collect data 

	// if either bit is set, collect data
	if (FunctionCallMask & POS_COLLECT_GLOBAL_DATA) {
		__try {
			// read the data from the diskperf driver

			// only one call at a time is permitted. This should be 
			// throttled by the perflib, but just in case we'll test it

			assert (WmiBuffer == NULL);

			if (WmiBuffer != NULL) {
				ReportEvent (hEventLog,
					EVENTLOG_ERROR_TYPE,
					0,
					PERFDISK_BUSY,
					NULL,
					0,
					0,
					NULL,
					NULL);
				*lpcbTotalBytes = (DWORD) 0;
				*lpNumObjectTypes = (DWORD) 0;
				lReturn = ERROR_SUCCESS;
				goto COLLECT_BAIL_OUT;
			} else {
				WmiBuffer = ALLOCMEM (hLibHeap, HEAP_ZERO_MEMORY, WmiAllocSize);
#if DBG
                if (WmiBuffer != NULL) {
                    HeapUsed += WmiAllocSize;
                    DebugPrint((4,
                        "CollecDiskObjectData: WmiBuffer added %d to %d\n",
                        WmiAllocSize, HeapUsed));
                }
#endif
			}

			// the buffer pointer should NOT be null if here

			if ( WmiBuffer == NULL ) {
				ReportEvent (hEventLog,
					EVENTLOG_WARNING_TYPE,
					0,
					PERFDISK_UNABLE_ALLOC_BUFFER,
					NULL,
					0,
					0,
					NULL,
					NULL);

				*lpcbTotalBytes = (DWORD) 0;
				*lpNumObjectTypes = (DWORD) 0;
				lReturn = ERROR_SUCCESS;
				goto COLLECT_BAIL_OUT;
			}

			WmiBufSize = WmiAllocSize;
			Status = WmiQueryAllDataW (
				hWmiDiskPerf,
				&WmiBufSize,
				WmiBuffer);

			// if buffer size attempted is too big or too small, resize
			if ((WmiBufSize > 0) && (WmiBufSize != WmiAllocSize)) {
				WmiBuffer = REALLOCMEM (hLibHeap,
					HEAP_ZERO_MEMORY,
					WmiBuffer, WmiBufSize);

				if (WmiBuffer == NULL) {
					// reallocation failed so bail out
					Status = ERROR_OUTOFMEMORY;
				} else {
					// if the required buffer is larger than 
					// originally planned, bump it up some
#if DBG
                    HeapUsed += (WmiBufSize - WmiAllocSize);
                    DebugPrint((4,
                        "CollectDiskObjectData: Realloc old %d new %d to %d\n",
                        WmiAllocSize, WmiBufSize, HeapUsed));
#endif
					if (WmiBufSize > WmiAllocSize) {                    
						WmiAllocSize = WmiBufSize;
					}
				}
			}

			if (Status == ERROR_INSUFFICIENT_BUFFER) {
				// if it didn't work because it was too small the first time
				// try one more time
				Status = WmiQueryAllDataW (
					hWmiDiskPerf,
					&WmiBufSize,
					WmiBuffer);
            
			} else {
				// it either worked the fisrt time or it failed because of 
				// something other than a buffer size problem
			}

		} __except (EXCEPTION_EXECUTE_HANDLER) {
            DebugPrint((2, "\tWmiBuffer %X size %d set to NULL\n",
                WmiBuffer, WmiAllocSize));
            if (WmiBuffer != NULL) {
                if (HeapValidate(hLibHeap, 0, WmiBuffer)) {
                    FREEMEM(hLibHeap, 0, WmiBuffer);
                }
            } // else we are really in trouble with WmiBuffer!!
			WmiBuffer = NULL;
			Status = ERROR_OUTOFMEMORY;
		}
        DebugPrint((3,
            "WmiQueryAllData status return: %x Buffer %d bytes\n",
            Status, WmiBufSize));

    } else {
        // no data required so these counter objects must not be in 
        // the query list
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto COLLECT_BAIL_OUT;
    }

    if (Status == ERROR_SUCCESS) {
        *lpNumObjectTypes = 0;
        dwOrigBuffSize = dwByteSize = *lpcbTotalBytes;
        *lpcbTotalBytes = 0;

        for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
            if (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit &
                POS_COLLECT_IGNORE)
                continue;

            if (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit &
                FunctionCallMask) {
                dwNumObjectsFromFunction = 0;
                lReturn = (*posDataFuncInfo[FunctionIndex].pCollectFunction) (
                    lppData,
                    &dwByteSize,
                    &dwNumObjectsFromFunction);

                if (lReturn == ERROR_SUCCESS) {
                    *lpNumObjectTypes += dwNumObjectsFromFunction;
                    *lpcbTotalBytes += dwByteSize;
                    dwOrigBuffSize -= dwByteSize;
                    dwByteSize = dwOrigBuffSize;
                } else {
                    break;
                }
            }
#if DBG
            dwQueryType = HeapValidate(hLibHeap, 0, WmiBuffer);
            DebugPrint((4,
                "CollectDiskObjectData: Index %d HeapValid %d lReturn %d\n",
                FunctionIndex, dwQueryType, lReturn));
            if (!dwQueryType)
                DbgBreakPoint();
#endif
        }
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFDISK_UNABLE_QUERY_DISKPERF_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&Status);

        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
    }

    // *lppData is updated by each function
    // *lpcbTotalBytes is updated after each successful function
    // *lpNumObjects is updated after each successful function

COLLECT_BAIL_OUT:
    if (WmiBuffer != NULL) {
        FREEMEM (hLibHeap, 0, WmiBuffer);
#if DBG
        HeapUsed -= WmiBufSize;
        DebugPrint((4, "CollectDiskObjectData: Freed %d to %d\n",
            WmiBufSize, HeapUsed));
#endif
        WmiBuffer = NULL;
    }
    
#if DBG
    GetSystemTimeAsFileTime((LPFILETIME) &endTime);
    elapsed = (LONG) ((endTime - startTime) / 10000);
    DebugPrint((1, "END CollectDiskObject: %d msec\n\n", elapsed));
#endif
    return lReturn;
}

DWORD APIENTRY
CloseDiskObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   dwThisEntry;
#if DBG
    LONG64 startTime, endTime;
    LONG elapsed;

    GetSystemTimeAsFileTime((LPFILETIME) &startTime);
    DebugPrint((1, "BEGIN CloseDiskObject:\n"));
#endif

    if (--dwOpenCount == 0) {
        if (pVolumeList != NULL) {
            // close handles in volume list
            dwThisEntry = dwNumVolumeListEntries;
            while (dwThisEntry != 0) {
                dwThisEntry--;
                if (pVolumeList[dwThisEntry].hVolume != NULL) {
                    NtClose (pVolumeList[dwThisEntry].hVolume);
                }
                if (pVolumeList[dwThisEntry].DeviceName.Buffer) {
                    FREEMEM(hLibHeap, 0,
                        pVolumeList[dwThisEntry].DeviceName.Buffer);
                }
            } 
            FREEMEM (hLibHeap, 0, pVolumeList);
#if DBG
            HeapUsed -= oldVLSize;
            DebugPrint((4, "CloseDiskObject: Freed VL %d to %d\n",
                oldVLSize, HeapUsed));
            oldVLSize = 0;
#endif
            pVolumeList = NULL;
            dwNumVolumeListEntries = 0;
        }
        if (pPhysDiskList != NULL) {
            FREEMEM (hLibHeap, 0, pPhysDiskList);
#if DBG
            HeapUsed -= oldPLSize;
            DebugPrint((4, "CloseDiskObject: Freed PL %d to %d\n",
                oldVLSize, HeapUsed));
            oldPLSize = 0;
#endif
            pPhysDiskList = NULL;
            dwNumPhysDiskListEntries = 0;
        }
        // close PDisk object
        if (hWmiDiskPerf != NULL) {
            status = WmiCloseBlock (hWmiDiskPerf);
            hWmiDiskPerf = NULL;
        }
    }
#if DBG
    GetSystemTimeAsFileTime((LPFILETIME) &endTime);
    elapsed = (LONG) ((endTime - startTime) / 10000);
    DebugPrint((1, "END CloseDiskObject %d msec\n\n", elapsed));
#endif
    return  status;

}

#ifndef _DONT_CHECK_FOR_VOLUME_FILTER
ULONG
CheckVolumeFilter(
    )
/*++

Routine Description:

    This routine checks to see if diskperf is set to be an upper filter
    for Storage Volumes

Arguments:

    None.


Return Value:

    TRUE if there is a filter

--*/
{
    WCHAR Buffer[MAX_PATH+1];
    WCHAR *string = Buffer;
    DWORD dwSize = sizeof(Buffer);
    ULONG stringLength, diskperfLen, result, status;
    HKEY hKey;

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                cszVolumeKey,
                (DWORD) 0,
                KEY_QUERY_VALUE,
                &hKey
                );
    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    status = RegQueryValueExW(
                hKey,
                (LPCWSTR)REGSTR_VAL_UPPERFILTERS,
                NULL,
                NULL,
                (LPBYTE) Buffer,
                &dwSize);
    if (status != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return FALSE;
    }

    stringLength = wcslen(string);

    diskperfLen = wcslen((LPCWSTR)DISKPERF_SERVICE_NAME);

    result = FALSE;
    while(stringLength != 0) {

        if (diskperfLen == stringLength) {
            if(_wcsicmp(string, (LPCWSTR)DISKPERF_SERVICE_NAME) == 0) {
                result = TRUE;
                break;
            }
        } else {
            string += stringLength + 1;
            stringLength = wcslen(string);
        }
    }
    RegCloseKey(hKey);
    return result;
}
#endif

#if DBG
VOID
PerfDiskDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all PerfDisk

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    if ((DebugPrintLevel <= (PerfDiskDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & PerfDiskDebug)) {
        DbgPrint("%d:Perfdisk!", GetCurrentThreadId());
    }
    else
        return;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (PerfDiskDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & PerfDiskDebug)) {

        _vsnprintf((LPSTR)PerfDiskDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint((LPSTR)PerfDiskDebugBuffer);
    }

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\databrws.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATABRWS.h

Abstract:

    Header file for the Windows NT Browser Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATABRWS_H_
#define _DATABRWS_H_

//
//    This is the Browser counter structure presently returned by NT.
//

typedef struct _BROWSER_DATA_DEFINITION {
    PERF_OBJECT_TYPE            BrowserObjectType;
    PERF_COUNTER_DEFINITION     ServerAnnounce;
    PERF_COUNTER_DEFINITION     DomainAnnounce;
    PERF_COUNTER_DEFINITION     TotalAnnounce;
    PERF_COUNTER_DEFINITION     ElectionPacket;
    PERF_COUNTER_DEFINITION     MailslotWrite;
    PERF_COUNTER_DEFINITION     ServerList;
    PERF_COUNTER_DEFINITION     ServerEnum;
    PERF_COUNTER_DEFINITION     DomainEnum;
    PERF_COUNTER_DEFINITION     OtherEnum;
    PERF_COUNTER_DEFINITION     TotalEnum;
    PERF_COUNTER_DEFINITION     ServerAnnounceMiss;
    PERF_COUNTER_DEFINITION     MailslotDatagramMiss;
    PERF_COUNTER_DEFINITION     ServerListMiss;
    PERF_COUNTER_DEFINITION     ServerAnnounceAllocMiss;
    PERF_COUNTER_DEFINITION     MailslotAllocFail;
    PERF_COUNTER_DEFINITION     MailslotReceiveFail;
    PERF_COUNTER_DEFINITION     MailslotWriteFail;
    PERF_COUNTER_DEFINITION     MailslotOpenFail;
    PERF_COUNTER_DEFINITION     MasterAnnounceDup;
    PERF_COUNTER_DEFINITION     DatagramIllegal;
}  BROWSER_DATA_DEFINITION, *PBROWSER_DATA_DEFINITION;

typedef struct _BROWSER_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG                ServerAnnounce;
    LONGLONG                DomainAnnounce;
    LONGLONG                TotalAnnounce;
    DWORD                   ElectionPacket;
    DWORD                   MailslotWrite;
    DWORD                   ServerList;
    DWORD                   ServerEnum;
    DWORD                   DomainEnum;
    DWORD                   OtherEnum;
    DWORD                   TotalEnum;
    DWORD                   ServerAnnounceMiss;
    DWORD                   MailslotDatagramMiss;
    DWORD                   ServerListMiss;
    DWORD                   ServerAnnounceAllocMiss;
    DWORD                   MailslotAllocFail;
    DWORD                   MailslotReceiveFail;
    DWORD                   MailslotWriteFail;
    DWORD                   MailslotOpenFail;
    DWORD                   MasterAnnounceDup;
    LONGLONG                DatagramIllegal;
} BROWSER_COUNTER_DATA, * PBROWSER_COUNTER_DATA;

extern BROWSER_DATA_DEFINITION BrowserDataDefinition;

#endif // _DATABRWS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\datardr.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATARDR.h

Abstract:

    Header file for the Windows NT Redirector Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATARDR_H_
#define _DATARDR_H_

//
//  This is the Rdr counter structure presently returned by NT.
//

typedef struct _RDR_DATA_DEFINITION {
    PERF_OBJECT_TYPE            RdrObjectType;
    PERF_COUNTER_DEFINITION     Bytes;
    PERF_COUNTER_DEFINITION     IoOperations;
    PERF_COUNTER_DEFINITION     Smbs;
    PERF_COUNTER_DEFINITION     BytesReceived;
    PERF_COUNTER_DEFINITION     SmbsReceived;
    PERF_COUNTER_DEFINITION     PagingReadBytesRequested;
    PERF_COUNTER_DEFINITION     NonPagingReadBytesRequested;
    PERF_COUNTER_DEFINITION     CacheReadBytesRequested;
    PERF_COUNTER_DEFINITION     NetworkReadBytesRequested;
    PERF_COUNTER_DEFINITION     BytesTransmitted;
    PERF_COUNTER_DEFINITION     SmbsTransmitted;
    PERF_COUNTER_DEFINITION     PagingWriteBytesRequested;
    PERF_COUNTER_DEFINITION     NonPagingWriteBytesRequested;
    PERF_COUNTER_DEFINITION     CacheWriteBytesRequested;
    PERF_COUNTER_DEFINITION     NetworkWriteBytesRequested;
    PERF_COUNTER_DEFINITION     ReadOperations;
    PERF_COUNTER_DEFINITION     RandomReadOperations;
    PERF_COUNTER_DEFINITION     ReadSmbs;
    PERF_COUNTER_DEFINITION     LargeReadSmbs;
    PERF_COUNTER_DEFINITION     SmallReadSmbs;
    PERF_COUNTER_DEFINITION     WriteOperations;
    PERF_COUNTER_DEFINITION     RandomWriteOperations;
    PERF_COUNTER_DEFINITION     WriteSmbs;
    PERF_COUNTER_DEFINITION     LargeWriteSmbs;
    PERF_COUNTER_DEFINITION     SmallWriteSmbs;
    PERF_COUNTER_DEFINITION     RawReadsDenied;
    PERF_COUNTER_DEFINITION     RawWritesDenied;
    PERF_COUNTER_DEFINITION     NetworkErrors;
    PERF_COUNTER_DEFINITION     Sessions;
    PERF_COUNTER_DEFINITION     Reconnects;
    PERF_COUNTER_DEFINITION     CoreConnects;
    PERF_COUNTER_DEFINITION     Lanman20Connects;
    PERF_COUNTER_DEFINITION     Lanman21Connects;
    PERF_COUNTER_DEFINITION     LanmanNtConnects;
    PERF_COUNTER_DEFINITION     ServerDisconnects;
    PERF_COUNTER_DEFINITION     HungSessions;
    PERF_COUNTER_DEFINITION     CurrentCommands;
} RDR_DATA_DEFINITION, *PRDR_DATA_DEFINITION;

typedef struct _RDR_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG                Bytes;
    DWORD                   IoOperations;
    LONGLONG                Smbs;
    LONGLONG                BytesReceived;
    LONGLONG                SmbsReceived;
    LONGLONG                PagingReadBytesRequested;
    LONGLONG                NonPagingReadBytesRequested;
    LONGLONG                CacheReadBytesRequested;
    LONGLONG                NetworkReadBytesRequested;
    LONGLONG                BytesTransmitted;
    LONGLONG                SmbsTransmitted;
    LONGLONG                PagingWriteBytesRequested;
    LONGLONG                NonPagingWriteBytesRequested;
    LONGLONG                CacheWriteBytesRequested;
    LONGLONG                NetworkWriteBytesRequested;
    DWORD                   ReadOperations;
    DWORD                   RandomReadOperations;
    DWORD                   ReadSmbs;
    DWORD                   LargeReadSmbs;
    DWORD                   SmallReadSmbs;
    DWORD                   WriteOperations;
    DWORD                   RandomWriteOperations;
    DWORD                   WriteSmbs;
    DWORD                   LargeWriteSmbs;
    DWORD                   SmallWriteSmbs;
    DWORD                   RawReadsDenied;
    DWORD                   RawWritesDenied;
    DWORD                   NetworkErrors;
    DWORD                   Sessions;
    DWORD                   Reconnects;
    DWORD                   CoreConnects;
    DWORD                   Lanman20Connects;
    DWORD                   Lanman21Connects;
    DWORD                   LanmanNtConnects;
    DWORD                   ServerDisconnects;
    DWORD                   HungSessions;
    DWORD                   CurrentCommands;
} RDR_COUNTER_DATA, * PRDR_COUNTER_DATA;

extern RDR_DATA_DEFINITION RdrDataDefinition;

#endif // _DATARDR_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\datasrvq.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datasrvq.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Physical Disk Server Queue data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datasrvq.h"

// dummy variable for field sizing.
static SRVQ_COUNTER_DATA   sqcd;

SRVQ_DATA_DEFINITION SrvQDataDefinition = {
    {
        sizeof(SRVQ_DATA_DEFINITION) + sizeof(SRVQ_COUNTER_DATA),
        sizeof(SRVQ_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        SERVER_QUEUE_OBJECT_TITLE_INDEX,
        0,
        1301,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(SRVQ_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
          sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1302,
        0,
        1303,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.QueueLength),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->QueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1304,
        0,
        1305,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.ActiveThreads),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->ActiveThreads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1306,
        0,
        1307,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.AvailableThreads),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->AvailableThreads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1308,
        0,
        1309,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.AvailableWorkItems),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->AvailableWorkItems
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1310,
        0,
        1311,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.BorrowedWorkItems),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BorrowedWorkItems
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1312,
        0,
        1313,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.WorkItemShortages),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->WorkItemShortages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1314,
        0,
        1315,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(sqcd.CurrentClients),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->CurrentClients
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        1317,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.BytesReceived),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BytesReceived
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        506,
        0,
        1319,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.BytesSent),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BytesSent
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1320,
        0,
        1321,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.TotalBytesTransfered),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->TotalBytesTransfered
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        288,
        0,
        1323,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.ReadOperations),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->ReadOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1324,
        0,
        1325,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.BytesRead),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BytesRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        298,
        0,
        1327,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.WriteOperations),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->WriteOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1328,
        0,
        1329,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.BytesWritten),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->BytesWritten
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        508,
        0,
        1331,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.TotalBytes),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->TotalBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1332,
        0,
        1333,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(sqcd.TotalOperations),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->TotalOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        404,
        0,
        405,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(sqcd.TotalContextBlocksQueued),
        (DWORD)(ULONG_PTR)&((SRVQ_COUNTER_DATA *)0)->TotalContextBlocksQueued
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\datardr.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datardr.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Redirector Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datardr.h"

// dummy variable for field sizing.
static RDR_COUNTER_DATA   rcd;

//
//  Constant structure initializations 
//      defined in datardr.h
//

RDR_DATA_DEFINITION RdrDataDefinition = {
    {   sizeof(RDR_DATA_DEFINITION) + sizeof(RDR_COUNTER_DATA),
        sizeof(RDR_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        REDIRECTOR_OBJECT_TITLE_INDEX,
        0,
        263,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(RDR_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        389,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.Bytes),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Bytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        406,
        0,
        391,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.IoOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->IoOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        400,
        0,
        401,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.Smbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Smbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        265,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.BytesReceived),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->BytesReceived
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        266,
        0,
        267,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.SmbsReceived),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->SmbsReceived
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        268,
        0,
        269,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.PagingReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->PagingReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        270,
        0,
        271,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.NonPagingReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NonPagingReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        272,
        0,
        273,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.CacheReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->CacheReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        274,
        0,
        275,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.NetworkReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NetworkReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        276,
        0,
        277,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.BytesTransmitted),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->BytesTransmitted
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        278,
        0,
        279,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.SmbsTransmitted),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->SmbsTransmitted
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        280,
        0,
        281,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.PagingReadBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->PagingReadBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        282,
        0,
        283,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.NonPagingWriteBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NonPagingWriteBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        284,
        0,
        285,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.CacheWriteBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->CacheWriteBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        286,
        0,
        287,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (rcd.NetworkWriteBytesRequested),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NetworkWriteBytesRequested
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        10,
        0,
        289,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.ReadOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->ReadOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        290,
        0,
        291,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.RandomReadOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->RandomReadOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        292,
        0,
        293,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.ReadSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->ReadSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        294,
        0,
        295,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.LargeReadSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->LargeReadSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        296,
        0,
        297,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.SmallReadSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->SmallReadSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        12,
        0,
        299,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.WriteOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->WriteOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        300,
        0,
        301,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.RandomWriteOperations),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->RandomWriteOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        302,
        0,
        303,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.WriteSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->WriteSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        304,
        0,
        305,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.LargeWriteSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->LargeWriteSmbs
    },
    {   sizeof(