SXS_ERROR_FILE_READ_FAILED,
            LastError,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            File
            );
        Success = FALSE;
        goto Exit;
    }
    if (memcmp(Buffer, Zeroes, BytesRead) == 0)
    {
        SxspDebugOut(TEXT("SXS: File %s is all zeroes\n"), File);
        MessageBoxFromMessage(
            Context->ParentWindow,
            MSG_SXS_ERROR_FILE_IS_ALL_ZEROES,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            File
            );
        Success = FALSE;
        goto Exit;
    }
    Success = TRUE;
Exit:
    if (FileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(FileHandle);
    return Success;
}

BOOL
SxspCheckLeafDirectory(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPCTSTR Directory
    )
{
    TCHAR File[MAX_PATH];
    BOOL Success = TRUE; // NOTE backwardness
    const static struct {
        const LPCTSTR* Extensions;
        SIZE_T  NumberOfExtensions;
        ULONG   Error;
    } x[] = {
        {
            DotManifestExtensions,
            NUMBER_OF(DotManifestExtensions),
            MSG_SXS_ERROR_DIRECTORY_IS_MISSING_MANIFEST
        },
        {
            DotCatalogExtensions,
            NUMBER_OF(DotCatalogExtensions),
            MSG_SXS_ERROR_DIRECTORY_IS_MISSING_CATALOG
        }
    };
    SIZE_T i;

    for (i = 0 ; i != NUMBER_OF(x) ; ++i)
    {
        if (SxspGetSameNamedFileWithExtensionFromList(Context, Directory, x[i].Extensions, x[i].NumberOfExtensions, File))
        {
            if (File[0] == 0)
            {
                TCHAR Base[MAX_PATH];

                SxspGetPathBaseName(Directory, Base);

                SxspDebugOut(TEXT("SXS: Missing manifest or catalog in %s\n"), Directory);

                MessageBoxFromMessage(
                    Context->ParentWindow,
                    x[i].Error,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    Directory,
                    Base
                    );
                Success = FALSE;
                //goto Exit;
                // keep looping, to possibly report more errors (manifest and catalog)
            }
            else
            {
                if (!SxspCheckFile(Context, File))
                    Success = FALSE;
                // keep looping, to possibly report more errors
            }
        }
    }
    // NOTE don't set Success = TRUE here.
//Exit:
    return Success;
}

BOOL
SxspFindAndCheckLeaves(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPTSTR                          Directory,
    SIZE_T                          DirectoryLength,
    LPWIN32_FIND_DATA               FindData
    )
{
    const static TCHAR T_FUNCTION[] = TEXT("SxspFindAndCheckLeaves");
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    BOOL   ChildrenDirectories = FALSE;
    BOOL   ChildrenFiles = FALSE;
    BOOL   Success = TRUE;

    //
    // first enumerate looking for any directories
    // recurse on each one
    // if none found, check it as a leaf
    //
    ConcatenatePaths(Directory, TEXT("*"), MAX_PATH);
    FindHandle = FindFirstFile(Directory, FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        CONST DWORD LastError = GetLastError();
        //
        // we already did a successful GetFileAttributes on this and
        // found it was a directory, so no error is expected here
        //
        SxspDebugOut(
            TEXT("SXS: %s(%s),FindFirstFile:%d\n"),
            T_FUNCTION, Directory, LastError
            );
        MessageBoxFromMessage(
            Context->ParentWindow,
            LastError,
            TRUE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
        Success = FALSE;
        goto Exit;
    }
    else
    {
        do
        {
            if (SxspIsDotOrDotDot(FindData->cFileName))
                continue;
            if (FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                ChildrenDirectories = TRUE;
                Directory[DirectoryLength] = 0;
                ConcatenatePaths(Directory, FindData->cFileName, MAX_PATH);
                if (!SxspFindAndCheckLeaves(
                    Context,
                    Directory,
                    StringLength(Directory),
                    FindData
                    ))
                {
                    Success = FALSE;
                    // keep looping, in order to possibly report more errors
                }
            }
            else
            {
                ChildrenFiles = TRUE;
            }
        }
        while (FindNextFile(FindHandle, FindData));
        FindClose(FindHandle);
    }
    if (!ChildrenDirectories
#if EMPTY_LEAF_DIRECTORIES_ARE_OK /* currently yes */
        && ChildrenFiles
#endif
        )
    {
        Directory[DirectoryLength] = 0;
        if (!SxspCheckLeafDirectory(Context, Directory))
            Success = FALSE;
    }
#if !EMPTY_LEAF_DIRECTORIES_ARE_OK /* currently no */
    if (!ChildrenDirectories && !ChildrenFiles)
    {
        // report an error
    }
#endif
    // NOTE do not set Success = TRUE here
Exit:
    return Success;
}

#if CHECK_FOR_MINIMUM_ASSEMBLIES /* 0 */
//
// This data is very specific to Windows 5.1.
//
// All of these should be under all roots, assuming
// corporate deployers do not add roots to dosnet.inf.
//
const static LPCTSTR MinimumAssemblies[] =
{
    TEXT("6000\\Msft\\Windows\\Common\\Controls"),
    TEXT("1000\\Msft\\Windows\\GdiPlus"),
    TEXT("5100\\Msft\\Windows\\System\\Default")
};

#endif

#if CHECK_FOR_OBSOLETE_ASSEMBLIES

//
// This data is specific to Windows 5.1.
//
// None of these should be under any root, assuming
// corporate deployers don't use these names.
//
// People internally end up with obsolete assemblies because they
// copy newer drops on top of older drops, without deleting what is
// no longer in the drop.
//
const static LPCTSTR ObsoleteAssemblies[] =
{
    // This assembly was reversioned very early in its life, from 1.0.0.0 to 5.1.0.0.
    TEXT("1000\\Msft\\Windows\\System\\Default")
};

#endif

BOOL
SxspCheckRoot(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPCTSTR                 Root
    )
{
    const static TCHAR T_FUNCTION[] = TEXT("SxspCheckRoot");
    DWORD FileAttributes = 0;
    DWORD LastError = 0;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    TCHAR RootStar[MAX_PATH];
    SIZE_T RootLength = 0;
    BOOL Empty = TRUE;
    BOOL Success = TRUE; // NOTE the backwardness
    SIZE_T i = 0;

    StringCopy(RootStar, Root);
    RootLength = StringLength(Root);

    //
    // check that the root exists
    //
    FileAttributes = GetFileAttributes(Root);
    if (FileAttributes == INVALID_FILE_ATTRIBUTES)
    {
        Success = FALSE;
        LastError = GetLastError();
        SxspDebugOut(
            TEXT("SXS: %s(%s),GetFileAttributes:%d\n"),
            T_FUNCTION, Root, LastError
            );
        //if (LastError == ERROR_FILE_NOT_FOUND || LastError == ERROR_PATH_NOT_FOUND)
        {
            MessageBoxFromMessageAndSystemError(
                Context->ParentWindow,
                MSG_SXS_ERROR_REQUIRED_DIRECTORY_MISSING,
                LastError,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                Root
                );
            goto Exit; // abort, otherwise we get many cascades, guaranteed
        }
        //else
        {
            /*
            MessageBoxFromMessage(
                Context->ParentWindow,
                LastError,
                TRUE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );
            goto Exit;
            */
        }
    }
    //
    // check that the root is a directory
    //
    if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
    {
        SxspDebugOut(TEXT("SXS: %s is file instead of directory\n"), Root);
        MessageBoxFromMessage(
            Context->ParentWindow,
            MSG_SXS_ERROR_FILE_INSTEAD_OF_DIRECTORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            Root
            );
        Success = FALSE;
        goto Exit;
    }

#if CHECK_FOR_MINIMUM_ASSEMBLIES /* We do NOT this, it is buggy wrt asms/wasms. */
    //
    // ensure all the mandatory assemblies exist
    // NOTE this check is only partial, but a more complete
    // check will be done when we enumerate and recurse
    //
    for (i = 0 ; i != NUMBER_OF(MinimumAssemblies) ; ++i)
    {
        RootStar[RootLength] = 0;
        ConcatenatePaths(RootStar, MinimumAssemblies[i], MAX_PATH);
        FileAttributes = GetFileAttributes(RootStar);
        if (FileAttributes == INVALID_FILE_ATTRIBUTES)
        {
            const DWORD LastError = GetLastError();
            SxspDebugOut(TEXT("SXS: required directory %s missing, or error %lu.\n"), RootStar, LastError);
            MessageBoxFromMessageAndSystemError(
                Context->ParentWindow,
                MSG_SXS_ERROR_REQUIRED_DIRECTORY_MISSING,
                LastError,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                RootStar
                );
            Success = FALSE;
            // keep running, look for more errors
        }
        if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            SxspDebugOut(TEXT("SXS: %s is file instead of directory\n"), RootStar);
            MessageBoxFromMessage(
                Context->ParentWindow,
                MSG_SXS_ERROR_FILE_INSTEAD_OF_DIRECTORY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                RootStar
                );
            Success = FALSE;
        }
    }
#endif

#if CHECK_FOR_OBSOLETE_ASSEMBLIES /* We do this; it somewhat against longstanding principle. */
    //
    // ensure none of the obsolete assemblies exist
    //
    for (i = 0 ; i != NUMBER_OF(ObsoleteAssemblies) ; ++i)
    {
        RootStar[RootLength] = 0;
        ConcatenatePaths(RootStar, ObsoleteAssemblies[i], MAX_PATH);
        FileAttributes = GetFileAttributes(RootStar);
        if (FileAttributes != INVALID_FILE_ATTRIBUTES)
        {
            //
            // We don't care if it's a file or directory or what
            // the directory contains. It's a fatal error no matter what.
            //
            SxspDebugOut(TEXT("SXS: obsolete %s present\n"), RootStar);
            MessageBoxFromMessage(
                Context->ParentWindow,
                MSG_SXS_ERROR_OBSOLETE_DIRECTORY_PRESENT,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                RootStar
                );
            Success = FALSE;
            // keep running, look for more errors
        }
    }
#endif

    //
    // enumerate and recurse
    //
    RootStar[RootLength] = 0;
    StringCopy(RootStar, Root);
    ConcatenatePaths(RootStar, TEXT("*"), MAX_PATH);
    FindHandle = FindFirstFile(RootStar, &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // An error here is unexplainable.
        //
        CONST DWORD LastError = GetLastError();
        SxspDebugOut(
            TEXT("SXS: %s(%s), FindFirstFile(%s):%d\n"),
            T_FUNCTION, Root, RootStar, LastError
            );
        MessageBoxFromMessage(
            Context->ParentWindow,
            LastError,
            TRUE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
        Success = FALSE;
        goto Exit;
    }
    do
    {
        if (SxspIsDotOrDotDot(FindData.cFileName))
            continue;
        //
        // REVIEW
        //  I think this is too strict.
        //  Corporate deployers might drop a readme.txt here.
        //
        if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            //RootStar[RootLength] = 0;
            //Context->ReportErrorMessage(Context, MSG_SXS_ERROR_NON_LEAF_DIRECTORY_CONTAINS_FILE, RootStar, FindData.cFileName);
        }
        else
        {
            //
            // now enumerate recursively, checking each leaf
            // munge the recursion slightly to save a function and stack space
            //   (usually we'd start at the root, instead of its first generation children)
            //
            Empty = FALSE;
            RootStar[RootLength] = 0;
            ConcatenatePaths(RootStar, FindData.cFileName, MAX_PATH);
            if (!SxspFindAndCheckLeaves(Context, RootStar, StringLength(RootStar), &FindData))
                Success = FALSE;
            // keep looping, to possibly report more errors
        }
    } while(FindNextFile(FindHandle, &FindData));
    FindClose(FindHandle);
    if (Empty)
    {
        SxspDebugOut(TEXT("SXS: directory %s empty\n"), Root);
        MessageBoxFromMessage(
            Context->ParentWindow,
            MSG_SXS_ERROR_DIRECTORY_EMPTY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            Root
            );
        Success = FALSE;
        goto Exit;
    }
Exit:
    return Success;
}

BOOL
SxsCheckLocalSource(
    PSXS_CHECK_LOCAL_SOURCE Parameters
    )
/*
Late in winnt32
    enumerate ~ls\...\asms
    ensure asms is a directory
    ensure that everything one level down in asms is a directory (I didn't do this, seems too strict).
    enumerate asms recursively
    ensure every leaf directory has a .cat with the same base name as the directory
    ensure every leaf directory has a .man or .manifest with the same base name as the directory
    Read the first 512 bytes of every .cat/.man/.manifest.
        Ensure that they are not all zero.

    REVIEW also that required exist and obsolete assemblies do not
*/
{
    ULONG i;
    TCHAR FullPath[MAX_PATH];
    BOOL Success = TRUE;
    TCHAR LocalSourceDrive;

    //
    // ensure LocalSource is present/valid
    //
    if (!MakeLocalSource)
        return TRUE;
    LocalSourceDrive = (TCHAR)towupper(LocalSourceDirectory[0]);
    if (LocalSourceDrive != towupper(LocalSourceWithPlatform[0]))
        return TRUE;
    if (LocalSourceDrive < 'C' || LocalSourceDrive > 'Z')
        return TRUE;

    //
    // flush LocalSource where the Win32 api is simple (NT, not Win9x)
    //
    if (ISNT())
    {
        CONST TCHAR LocalSourceDrivePath[] = { '\\', '\\', '.', '\\', LocalSourceDrive, ':', 0 };
        CONST HANDLE LocalSourceDriveHandle =
            CreateFile(
                LocalSourceDrivePath,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
                NULL
                );
        if (LocalSourceDriveHandle != INVALID_HANDLE_VALUE)
        {
            FlushFileBuffers(LocalSourceDriveHandle);
            CloseHandle(LocalSourceDriveHandle);
        }
    }
    for(i = 0; i != OptionalDirectoryCount; ++i)
    {
        if ((OptionalDirectoryFlags[i] & OPTDIR_SIDE_BY_SIDE) != 0)
        {
            MYASSERT(
                (OptionalDirectoryFlags[i] & OPTDIR_PLATFORM_INDEP)
                ^ (OptionalDirectoryFlags[i] & OPTDIR_ADDSRCARCH)
                );
            switch (OptionalDirectoryFlags[i] & (OPTDIR_PLATFORM_INDEP | OPTDIR_ADDSRCARCH))
            {
            case OPTDIR_ADDSRCARCH:
                StringCopy(FullPath, LocalSourceWithPlatform);
                break;
            case OPTDIR_PLATFORM_INDEP:
                StringCopy(FullPath, LocalSourceDirectory);
                break;
            }
            ConcatenatePaths(FullPath, OptionalDirectories[i], MAX_PATH);
            if (!SxspCheckRoot(Parameters, FullPath))
                Success = FALSE;
                // keep looping, to possibly report more errors
        }
    }
    return Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\util.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Utilitaries for winnt32.

Author:


Revision History:

    Ovidiu Temereanca (ovidiut) 24-Jul-2000

--*/

#include "precomp.h"
#include <mbstring.h>
#pragma hdrstop


VOID
MyWinHelp(
    IN HWND  Window,
    IN UINT  Command,
    IN ULONG_PTR Data
    )
{
    TCHAR Buffer[2*MAX_PATH];
    LPTSTR p;
    HANDLE FindHandle;
    BOOL b;
    WIN32_FIND_DATA FindData;
    LPCTSTR HelpFileName = TEXT("winnt32.hlp");

    //
    // The likely scenario is that a user invokes winnt32 from
    // a network share. We'll expect the help file to be there too.
    //
    b = FALSE;
    if(GetModuleFileName(NULL,Buffer,sizeof(Buffer)/sizeof(TCHAR))
    && (p = _tcsrchr(Buffer,TEXT('\\'))))
    {
        lstrcpy(p+1,HelpFileName);

        //
        // See whether the help file is there. If so, use it.
        //
        FindHandle = FindFirstFile(Buffer,&FindData);
        if(FindHandle != INVALID_HANDLE_VALUE) {

            FindClose(FindHandle);
            b = WinHelp(Window,Buffer,Command,Data);
        }
    }

    if(!b) {
        //
        // Try just the base help file name.
        //
        b = WinHelp(Window,HelpFileName,Command,Data);
    }

    if(!b) {
        //
        // Tell user.
        //
        MessageBoxFromMessage(
            Window,
            MSG_CANT_OPEN_HELP_FILE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION,
            HelpFileName
            );
    }
}


VOID
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;

    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
}


LPTSTR
DupString(
    IN LPCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p;

    if(p = MALLOC((lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}

PTSTR
DupMultiSz (
    IN      PCTSTR MultiSz
    )

/*++

Routine Description:

    Make a duplicate of a MultiSz.

Arguments:

    MultiSz - supplies pointer to the multi-string to duplicate.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    PCTSTR p;
    PTSTR q;
    DWORD size = sizeof (TCHAR);

    for (p = MultiSz; *p; p = _tcschr (p, 0) + 1) {
        size += (lstrlen (p) + 1) * sizeof(TCHAR);
    }
    if (q = MALLOC (size)) {
        CopyMemory (q, MultiSz, size);
    }

    return q;
}


PTSTR
CreatePrintableString (
    IN      PCTSTR MultiSz
    )

/*++

Routine Description:

    Creates a string of the form (str1, str2, ..., strN) from a MultiSz

Arguments:

    MultiSz - supplies pointer to the MultiSz string to represent.

Return Value:

    Pointer to the new string string or NULL if OOM. Caller can free with FREE().

--*/

{
    PCTSTR p;
    PTSTR q, r;
    DWORD size = 3 * sizeof (TCHAR);

    for (p = MultiSz; *p; p = _tcschr (p, 0) + 1) {
        size += (lstrlen (p) + 1) * sizeof(TCHAR);
    }
    if (r = MALLOC (size)) {
        q = r;
        *q++ = TEXT('(');
        for (p = MultiSz; *p; p = _tcschr (p, 0) + 1) {
            if (q - r > 1) {
                *q++ = TEXT(',');
            }
            q += wsprintf (q, TEXT("%s"), p);
        }
        *q++ = TEXT(')');
        *q = 0;
    }
    return r;
}


PSTR
UnicodeToAnsi (
    IN      PCWSTR Unicode
    )

/*++

Routine Description:

    Makes an ANSI duplicate of a UNICODE string.

Arguments:

    Unicode - supplies pointer to the UNICODE string to duplicate.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    PSTR p;
    DWORD size;

    if (!Unicode) {
        return NULL;
    }

    size = (lstrlenW (Unicode) + 1) * sizeof(WCHAR);
    if (p = MALLOC (size)) {
        if (!WideCharToMultiByte (
                CP_ACP,
                0,
                Unicode,
                -1,
                p,
                size,
                NULL,
                NULL
                )) {
            FREE (p);
            p = NULL;
        }
    }

    return p;
}


PWSTR
MultiSzAnsiToUnicode (
    IN      PCSTR MultiSzAnsi
    )

/*++

Routine Description:

    Makes a UNICODE duplicate of a multi-sz ANSI string.

Arguments:

    MultiSzAnsi - supplies pointer to the multisz ANSI string to duplicate.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    PCSTR p;
    PWSTR q;
    DWORD size = 1;

    if (!MultiSzAnsi) {
        return NULL;
    }

    for (p = MultiSzAnsi; *p; p = _mbschr (p, 0) + 1) {
        size += lstrlenA (p) + 1;
    }

    if (q = MALLOC (size * sizeof(WCHAR))) {
        if (!MultiByteToWideChar (
                CP_ACP,
                0,
                MultiSzAnsi,
                size,
                q,
                size
                )) {
            FREE (q);
            q = NULL;
        }
    }

    return q;
}


UINT
MyGetDriveType(
    IN      TCHAR Drive
    )

/*++

Routine Description:

    Same as GetDriveType() Win32 API except on NT returns
    DRIVE_FIXED for removeable hard drives.

Arguments:

    Drive - supplies drive letter whose type is desired.

Return Value:

    Same as GetDriveType().

--*/

{
    TCHAR DriveNameNt[] = TEXT("\\\\.\\?:");
    TCHAR DriveName[] = TEXT("?:\\");
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type. If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    //
    MYASSERT (Drive);

    DriveName[0] = Drive;
    rc = GetDriveType(DriveName);

#ifdef _X86_ //NEC98
    //
    // NT5 for NEC98 can not access AT formated HD during setup.
    // We need except these type.
    if (IsNEC98() && ISNT() && (rc == DRIVE_FIXED) && BuildNumber <= NT40) {
        TCHAR aho[100];
        //
        // Check ATA Card?
        //
        {
            HANDLE hDisk;
            TCHAR HardDiskName[] = TEXT("\\\\.\\?:");

            HardDiskName[4] = Drive;
            hDisk =   CreateFile( HardDiskName,
                                  GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hDisk == INVALID_HANDLE_VALUE) {
                return(DRIVE_UNKNOWN);
            }
            if (CheckATACardonNT4(hDisk)){
                CloseHandle(hDisk);
                return(DRIVE_REMOVABLE);
            }
            CloseHandle(hDisk);
        }
        if (!IsValidDrive(Drive)){
            // HD format is not NEC98 format.
            return(DRIVE_UNKNOWN);
        }
    }
    if((rc != DRIVE_REMOVABLE) || !ISNT() || (!IsNEC98() && (Drive < L'C'))) {
        return(rc);
    }
#else //NEC98
    if((rc != DRIVE_REMOVABLE) || !ISNT() || (Drive < L'C')) {
        return(rc);
    }
#endif

    //
    // DRIVE_REMOVABLE on NT.
    //

    //
    // Disallow use of removable media (e.g. Jazz, Zip, ...).
    //


    DriveNameNt[4] = Drive;

    hDisk = CreateFile(
                DriveNameNt,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk != INVALID_HANDLE_VALUE) {

        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(MediaInfo),
                &DataSize,
                NULL
                );

        //
        // It's really a hard disk if the media type is removable.
        //
        if(b && (MediaInfo.MediaType == RemovableMedia)) {
            rc = DRIVE_FIXED;
        }

        CloseHandle(hDisk);
    }


    return(rc);
}


#ifdef UNICODE

UINT
MyGetDriveType2 (
    IN      PCWSTR NtVolumeName
    )

/*++

Routine Description:

    Same as GetDriveType() Win32 API except on NT returns
    DRIVE_FIXED for removeable hard drives.

Arguments:

    NtVolumeName - supplies device name whose type is desired.

Return Value:

    Same as GetDriveType().

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING DeviceName;
    HANDLE hDisk;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;

    //
    // First, get the win32 drive type. If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    INIT_OBJA (&Obja, &DeviceName, NtVolumeName);
    Status = NtOpenFile (
                &hDisk,
                (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );
    if (!NT_SUCCESS( Status )) {
        return DRIVE_NO_ROOT_DIR;
    }

    //
    // Determine if this is a network or disk file system. If it
    // is a disk file system determine if this is removable or not
    //
    Status = NtQueryVolumeInformationFile(
                hDisk,
                &IoStatusBlock,
                &DeviceInfo,
                sizeof(DeviceInfo),
                FileFsDeviceInformation
                );
    if (!NT_SUCCESS (Status)) {
        rc = DRIVE_UNKNOWN;
    } else if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) {
        rc = DRIVE_REMOTE;
    } else {
        switch (DeviceInfo.DeviceType) {

            case FILE_DEVICE_NETWORK:
            case FILE_DEVICE_NETWORK_FILE_SYSTEM:
                rc = DRIVE_REMOTE;
                break;

            case FILE_DEVICE_CD_ROM:
            case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
                rc = DRIVE_CDROM;
                break;

            case FILE_DEVICE_VIRTUAL_DISK:
                rc = DRIVE_RAMDISK;
                break;

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:
                if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                    rc = DRIVE_REMOVABLE;
                } else {
                    rc = DRIVE_FIXED;
                }
                break;

            default:
                rc = DRIVE_UNKNOWN;
                break;
        }
    }

    if(rc == DRIVE_REMOVABLE) {

        //
        // DRIVE_REMOVABLE on NT.
        // Disallow use of removable media (e.g. Jazz, Zip, ...).
        //
        Status = NtDeviceIoControlFile(
                        hDisk,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                        NULL,
                        0,
                        &MediaInfo,
                        sizeof(DISK_GEOMETRY)
                        );
        //
        // It's really a hard disk if the media type is removable.
        //
        if(NT_SUCCESS (Status) && (MediaInfo.MediaType == RemovableMedia)) {
            rc = DRIVE_FIXED;
        }
    }

    NtClose (hDisk);

    return(rc);
}

#endif

BOOL
GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )

/*++

Routine Description:

    Fill in a PARTITION_INFORMATION structure with information about
    a particular drive.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    Drive - supplies drive letter whose partition info is desired.

    PartitionInfo - upon success, receives partition info for Drive.

Return Value:

    Boolean value indicating whether PartitionInfo has been filled in.

--*/

{
    TCHAR DriveName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    if(!ISNT()) {
        return(FALSE);
    }

    DriveName[4] = Drive;

    hDisk = CreateFile(
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    return(b);
}

#ifdef UNICODE

BOOL
GetPartitionInfo2 (
    IN  PCWSTR                 NtVolumeName,
    OUT PPARTITION_INFORMATION PartitionInfo
    )

/*++

Routine Description:

    Fill in a PARTITION_INFORMATION structure with information about
    a particular drive.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    NtVolumeName - supplies NT volume name whose partition info is desired.

    PartitionInfo - upon success, receives partition info for Drive.

Return Value:

    Boolean value indicating whether PartitionInfo has been filled in.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING DeviceName;
    HANDLE hDisk;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL b = FALSE;
    DWORD DataSize;

    //
    // Open the file
    //
    INIT_OBJA (&Obja, &DeviceName, NtVolumeName);
    Status = NtOpenFile (
                &hDisk,
                (ACCESS_MASK)FILE_READ_DATA | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    if (NT_SUCCESS (Status)) {

        Status = NtDeviceIoControlFile (
                    hDisk,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_DISK_GET_PARTITION_INFO,
                    NULL,
                    0,
                    PartitionInfo,
                    sizeof(PARTITION_INFORMATION)
                    );

        NtClose (hDisk);

        b = NT_SUCCESS (Status);
    }

    return(b);
}

#endif


BOOL
IsDriveNTFT(
    IN      TCHAR Drive,
    IN      PCTSTR NtVolumeName
    )

/*++

Routine Description:

    Determine whether a drive is any kind of NTFT set.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    Drive - supplies drive letter to check; optional
    NtVolumeName - supplies volume name to check; required if Drive not specified

Return Value:

    Boolean value indicating whether the drive is NTFT.

--*/

{
    PARTITION_INFORMATION PartitionInfo;

    if(!ISNT()) {
        return(FALSE);
    }

    //
    // If we can't open the drive, assume not NTFT.
    //
    if (Drive) {
        if(!GetPartitionInfo(Drive,&PartitionInfo)) {
            return(FALSE);
        }
    } else {
#ifdef UNICODE
        if(!GetPartitionInfo2 (NtVolumeName, &PartitionInfo)) {
            return(FALSE);
        }
#else
        MYASSERT (FALSE);
        return(FALSE);
#endif
    }

    //
    // It's FT if the partition type is marked NTFT (ie, high bit set).
    //

    if((IsRecognizedPartition(PartitionInfo.PartitionType)) &&
       ((PartitionInfo.PartitionType & PARTITION_NTFT) != 0)) {

#if defined(_IA64_)
        //
        // This check is dependant on the EFI system partition type not being
        // a recognized type.  It's unlikely that we'd start recognizing it
        // before we start requiring GPT partitions on the system disk, but
        // just in case we'll assert before returning true for an ESP.
        //

        ASSERT(PartitionInfo.PartitionType != 0xef);
#endif

        return TRUE;
    } else {

        return FALSE;
    }
}


BOOL
IsDriveVeritas(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    )
{
    TCHAR name[3];
    TCHAR Target[MAX_PATH];

    if(ISNT()) {
        //
        // Check for Veritas volume, which links to \Device\HarddiskDmVolumes...
        //
        if (Drive) {
            name[0] = Drive;
            name[1] = TEXT(':');
            name[2] = 0;
            if(!QueryDosDevice(name,Target,MAX_PATH)) {
                return FALSE;
            }
        } else {
            lstrcpy (Target, NtVolumeName);
        }
        if(!_tcsnicmp(Target,TEXT("\\Device\\HarddiskDm"),18)) {
            return(TRUE);
        }
    }
    return(FALSE);
}


//
// Get Harddisk BPS
// I970721
//
ULONG
GetHDBps(
    HANDLE hDisk
    )
{
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    b = DeviceIoControl(
           hDisk,
           IOCTL_DISK_GET_DRIVE_GEOMETRY,
           NULL,
           0,
           &MediaInfo,
           sizeof(MediaInfo),
           &DataSize,
           NULL
           );

    if(!b) {
       return(0);
    } else {
        return(MediaInfo.BytesPerSector);
    }

}


#ifdef UNICODE

#ifdef _WIN64

//
// define IOCTL_VOLUME_IS_PARTITION since we don't include ntddvol.h
//
#define IOCTL_VOLUME_IS_PARTITION CTL_CODE(IOCTL_VOLUME_BASE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

BOOL
IsSoftPartition(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    )
/*++

Routine Description:

    Finds out whether the given volume is soft partition 
    or not (i.e. does it have an underlying partition).

    NOTE : We just use the IOCTL_VOLUME_IS_PARTITION.

Arguments:

    Drive - supplies drive letter for the volume

    NtVolumeName - supplies NT volume name
    

Return Value:

    TRUE if the volume is soft partition otherwise FALSE.

--*/
    
{
    BOOL SoftPartition;
    HANDLE VolumeHandle = INVALID_HANDLE_VALUE;
    ULONG DataSize;

    //
    //  Assume that the partition is a soft one.
    //  If we cannot determine whether or not the partition is a soft partition, then assume it is a soft
    //  partition. This will prevent us from placing $win_nt$.~ls in such a drive.
    //
    SoftPartition = TRUE;

    if (Drive) {
        TCHAR Name[MAX_PATH];
        BOOL Result;
    
        wsprintf(Name, TEXT("\\\\.\\%c:"), Drive);

        VolumeHandle = CreateFile(Name, 
                            GENERIC_READ, 
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, 
                            OPEN_EXISTING, 
                            FILE_ATTRIBUTE_NORMAL,
                            INVALID_HANDLE_VALUE);

        if (VolumeHandle != INVALID_HANDLE_VALUE) {                        
            Result = DeviceIoControl(VolumeHandle,
                        IOCTL_VOLUME_IS_PARTITION,
                        NULL,
                        0,
                        NULL,
                        0,
                        &DataSize,
                        NULL);

            SoftPartition = !Result;

            CloseHandle(VolumeHandle);
        }                   
    } else {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES Obja;
        UNICODE_STRING DeviceName;
        IO_STATUS_BLOCK IoStatusBlock;
        
        //
        // Open the file
        //
        INIT_OBJA (&Obja, &DeviceName, NtVolumeName);
        
        Status = NtOpenFile (&VolumeHandle,
                    (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);
                    
        if (NT_SUCCESS (Status)) {
            Status = NtDeviceIoControlFile(VolumeHandle,
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_VOLUME_IS_PARTITION,
                            NULL,
                            0,
                            NULL,
                            0);

            if (NT_SUCCESS(Status)) {
                SoftPartition = FALSE;
            }

            NtClose(VolumeHandle);
        }                                                        
    }

    return SoftPartition;
}

#else 

BOOL
IsSoftPartition(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    )
{
    TCHAR                       name[80];
    PARTITION_INFORMATION       partInfo;
    DWORD                       bytes;
    BOOL                        SoftPartition = TRUE;
    BOOL                        b;
    HANDLE                      h = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK             IoStatusBlock;
    LARGE_INTEGER               SoftPartitionStartingOffset;
    ULONG                       bps;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING DeviceName;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    if( !IsDriveVeritas( Drive, NtVolumeName ) ) {
        return( FALSE );
    }
    //
    //  Assume that the partition is a soft one.
    //  If we cannot determine whether or not the partition is a soft partition, then assume it is a soft
    //  partition. This will prevent us from placing $win_nt$.~ls in such a drive.
    //
    SoftPartition = TRUE;

    if (Drive) {
        wsprintf(name, TEXT("\\\\.\\%c:"), Drive);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
#if DBG
            GetLastError();
#endif
            goto Exit;
        }

        b = DeviceIoControl(
               h,
               IOCTL_DISK_GET_DRIVE_GEOMETRY,
               NULL,
               0,
               &MediaInfo,
               sizeof(MediaInfo),
               &DataSize,
               NULL
               );

        if(!b) {
#if DBG
            GetLastError();
#endif
            goto CleanUp;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                            &partInfo, sizeof(partInfo), &bytes, NULL);
        if (!b) {
#if DBG
            GetLastError();
#endif
            goto CleanUp;
        }

    } else {
        //
        // Open the file
        //
        INIT_OBJA (&Obja, &DeviceName, NtVolumeName);
        Status = NtOpenFile (
                    &h,
                    (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                    );
        if (!NT_SUCCESS (Status)) {
            goto Exit;
        }
        Status = NtDeviceIoControlFile(
                        h,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                        NULL,
                        0,
                        &MediaInfo,
                        sizeof(DISK_GEOMETRY)
                        );
        if (!NT_SUCCESS (Status)) {
            goto CleanUp;
        }
        Status = NtDeviceIoControlFile(
                        h,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL,
                        0,
                        &partInfo,
                        sizeof(PARTITION_INFORMATION)
                        );
        if (!NT_SUCCESS (Status)) {
            goto CleanUp;
        }
    }

    bps = MediaInfo.BytesPerSector;

    //
    //  Find out the number of bytes per sector of the drive
    //
    //
    //   A soft partition always starts at sector 29 (0x1d)
    //
    SoftPartitionStartingOffset.QuadPart = 29*bps;
    SoftPartition = ( partInfo.StartingOffset.QuadPart == SoftPartitionStartingOffset.QuadPart );

CleanUp:
    if (Drive) {
        CloseHandle(h);
    } else {
        NtClose (h);
    }
Exit:
    return( SoftPartition );
}

#endif // WIN64

BOOL
MyGetDiskFreeSpace (
    IN      PCWSTR NtVolumeName,
    IN      PDWORD SectorsPerCluster,
    IN      PDWORD BytesPerSector,
    IN      PDWORD NumberOfFreeClusters,
    IN      PDWORD TotalNumberOfClusters
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING VolumeName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    WCHAR DefaultPath[2];
    DWORD dwTemp;
    BOOL  bAppHack;

    INIT_OBJA (&Obja, &VolumeName, NtVolumeName);

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if (!NT_SUCCESS (Status)) {
        return FALSE;
    }

    //
    // Determine the size parameters of the volume.
    //
    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &SizeInfo,
                sizeof(SizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    if (SizeInfo.TotalAllocationUnits.HighPart) {
        SizeInfo.TotalAllocationUnits.LowPart = (ULONG)-1;
    }
    if (SizeInfo.AvailableAllocationUnits.HighPart) {
        SizeInfo.AvailableAllocationUnits.LowPart = (ULONG)-1;
    }

    *SectorsPerCluster = SizeInfo.SectorsPerAllocationUnit;
    *BytesPerSector = SizeInfo.BytesPerSector;
    *NumberOfFreeClusters = SizeInfo.AvailableAllocationUnits.LowPart;
    *TotalNumberOfClusters = SizeInfo.TotalAllocationUnits.LowPart;

    return TRUE;
}

#endif


BOOL
IsDriveNTFS(
    IN TCHAR Drive
    )

/*++

Routine Description:

    Determine whether a drive is any kind of NTFT set.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    Drive - supplies drive letter to check.

Return Value:

    Boolean value indicating whether the drive is NTFT.

--*/

{
TCHAR       DriveName[4];
TCHAR       Filesystem[256];
TCHAR       VolumeName[MAX_PATH];
DWORD       SerialNumber;
DWORD       MaxComponent;
DWORD       Flags;
BOOL        b;

    if(!ISNT()) {
        return(FALSE);
    }

    MYASSERT (Drive);

    DriveName[0] = Drive;
    DriveName[1] = TEXT(':');
    DriveName[2] = TEXT('\\');
    DriveName[3] = 0;

    b = GetVolumeInformation(
            DriveName,
            VolumeName,MAX_PATH,
            &SerialNumber,
            &MaxComponent,
            &Flags,
            Filesystem,
            sizeof(Filesystem)/sizeof(TCHAR)
            );

    if(!b || !lstrcmpi(Filesystem,TEXT("NTFS"))) {
        return( TRUE );
    }

    return( FALSE );
}


DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an entire file for read access. The file must
    not be 0-length or the routine fails.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.  This value is
        undefined if the file being opened is 0 length.

    BaseAddress - receives the address where the file is mapped.  This
        value is undefined if the file being opened is 0 length.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with UnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {
        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize == (DWORD)(-1)) {
            rc = GetLastError();
        } else {
            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            } else {
                rc = GetLastError();
            }
        }

        CloseHandle(*FileHandle);
    }

    return(rc);
}



DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap and close a file.

Arguments:

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    NO_ERROR if the file was unmapped successfully.

    Win32 error code if the file was not successfully unmapped.

--*/

{
    DWORD rc;

    rc = UnmapViewOfFile(BaseAddress) ? NO_ERROR : GetLastError();

    if(!CloseHandle(MappingHandle)) {
        if(rc == NO_ERROR) {
            rc = GetLastError();
        }
    }

    return(rc);
}


VOID
GenerateCompressedName(
    IN  LPCTSTR Filename,
    OUT LPTSTR  CompressedName
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise assume there is a 3-character extension and replace the
    third character after the dot with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

    CompressedName - receives compressed form. This routine assumes
        that this buffer is MAX_PATH TCHARs in size.

Return Value:

    None.

--*/

{
    LPTSTR p,q;

    //
    // Leave room for the worst case, namely where there's no extension
    // (and we thus have to append ._).
    //
    lstrcpyn(CompressedName,Filename,MAX_PATH-2);

    p = _tcsrchr(CompressedName,TEXT('.'));
    q = _tcsrchr(CompressedName,TEXT('\\'));
    if(q < p) {
        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore. p points to the dot so include that in the length.
        //
        if(lstrlen(p) < 4) {
            lstrcat(CompressedName,TEXT("_"));
        } else {
            //
            // Assume there are 3 characters in the extension and replace
            // the final one with an underscore.
            //
            p[3] = TEXT('_');
        }
    } else {
        //
        // No dot, just add ._.
        //
        lstrcat(CompressedName,TEXT("._"));
    }
}


DWORD
CreateMultiLevelDirectory(
    IN LPCTSTR Directory
    )

/*++

Routine Description:

    This routine ensures that a multi-level path exists by creating individual
    levels one at a time. It can handle either paths of form x:... or \\?\Volume{...

Arguments:

    Directory - supplies fully-qualified Win32 pathspec of directory to create

Return Value:

    Win32 error code indicating outcome.

--*/

{
    TCHAR Buffer[MAX_PATH];
    PTCHAR p,q;
    TCHAR c;
    BOOL Done;
    DWORD d = ERROR_SUCCESS;
    INT Skip=0;

    lstrcpyn(Buffer,Directory,MAX_PATH);

    //
    // If it already exists do nothing. (We do this before syntax checking
    // to allow for remote paths that already exist. This is needed for
    // remote boot machines.)
    //
    d = GetFileAttributes(Buffer);
    if(d != (DWORD)(-1)) {
        return((d & FILE_ATTRIBUTE_DIRECTORY) ? NO_ERROR : ERROR_DIRECTORY);
    }

    //
    // Check path format
    //
    c = (TCHAR)CharUpper((LPTSTR)Buffer[0]);
    if(((c < TEXT('A')) || (c > TEXT('Z')) || (Buffer[1] != TEXT(':'))) && c != TEXT('\\')) {
        return(ERROR_INVALID_PARAMETER);
    }

    if (c != TEXT('\\')) {
        //
        // Ignore drive roots, which we allow to be either x:\ or x:.
        //
        if(Buffer[2] != TEXT('\\')) {
            return(Buffer[2] ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS);
        }
        q = Buffer + 3;
        if(*q == 0) {
            return(ERROR_SUCCESS);
        }
    } else {
        //
        // support \\server\share[\xxx] format
        //
        q = NULL;
        if (Buffer[1] != TEXT('\\') || Buffer[1] != 0 && Buffer[2] == TEXT('\\')) {
            return(ERROR_INVALID_PARAMETER);
        }
        q = _tcschr (&Buffer[2], TEXT('\\'));
        if (!q) {
            return(ERROR_INVALID_PARAMETER);
        }
        if (q[1] == TEXT('\\')) {
            return(ERROR_INVALID_PARAMETER);
        }
        q = _tcschr (&q[1], TEXT('\\'));
        if (!q) {
            return(ERROR_SUCCESS);
        }
        q++;

#ifdef UNICODE
        //
        // Hack to make sure the system partition case works on IA64 (arc)
        // We beieve this should be the only case where we use a
        // GlobalRoot style name as the other cases deal with OEM partitions etc.
        // which we should never touch. WE skip over by the length of
        // SystemPartitionVolumeGuid. We take care of the \ present at the end.
        //

        if (SystemPartitionVolumeGuid != NULL && _wcsnicmp (Buffer, SystemPartitionVolumeGuid, (wcslen(SystemPartitionVolumeGuid)-1)) == 0 ){

            Skip = wcslen(SystemPartitionVolumeGuid)-1;


        } else if (_wcsnicmp (Buffer, L"\\\\?\\Volume{", 11) == 0 &&
                 Buffer[47] == L'}') {
            //
            // skip over the VolumeGUID part
            //
            Skip = 48;
        }

        if (Skip > 0) {
            if (Buffer[Skip] == 0) {
                return ERROR_SUCCESS;
            }
            q = Buffer + Skip + 1;
        }

#endif

    }


    Done = FALSE;
    do {
        //
        // Locate the next path sep char. If there is none then
        // this is the deepest level of the path.
        //
        if(p = _tcschr(q,TEXT('\\'))) {
            *p = 0;
        } else {
            Done = TRUE;
        }

        //
        // Create this portion of the path.
        //
        if(CreateDirectory(Buffer,NULL)) {
            d = ERROR_SUCCESS;
        } else {
            d = GetLastError();
            if(d == ERROR_ALREADY_EXISTS) {
                d = ERROR_SUCCESS;
            }
        }

        if(d == ERROR_SUCCESS) {
            //
            // Put back the path sep and move to the next component.
            //
            if(!Done) {
                *p = TEXT('\\');
                q = p+1;
            }
        } else {
            Done = TRUE;
        }

    } while(!Done);

    return(d);
}


BOOL
ForceFileNoCompress(
    IN LPCTSTR Filename
    )

/*++

Routine Description:

    This routine makes sure that a file on a volume that supports per-file
    compression is not compressed. The caller need not ensure that the volume
    actually supports this, since this routine will query the attributes of
    the file before deciding whether any operation is actually necessary,
    and the compressed attribute will not be set on volumes that don't support
    per-file compression.

    It assumed that the file exists. If the file does not exist, this routine
    will fail.

Arguments:

    Filename - supplies the filename of the file to mke uncompressed.

Return Value:

    Boolean value indicating outcome. If FALSE, last error is set.

--*/

{
    ULONG d;
    HANDLE h;
    BOOL b;
    USHORT u;
    DWORD Attributes;

    Attributes = GetFileAttributes(Filename);
    if(Attributes == (DWORD)(-1)) {
        return(FALSE);
    }

    if(!(Attributes & FILE_ATTRIBUTE_COMPRESSED)) {
        return(TRUE);
    }

    //
    // Temporarily nullify attributes that might prevent opening
    // the file for read-write access.
    //
    // We preserve the 'standard' attributes that the file might have,
    // to be restored later.
    //
    Attributes &= (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE);
    SetFileAttributes(Filename,FILE_ATTRIBUTE_NORMAL);

    h = CreateFile(
            Filename,
            FILE_READ_DATA | FILE_WRITE_DATA,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        SetFileAttributes(Filename,Attributes);
        return(FALSE);
    }

    u = 0;
    b = DeviceIoControl( h,
                         FSCTL_SET_COMPRESSION,
                         &u,
                         sizeof(USHORT),
                         NULL,
                         0,
                         &d,
                         FALSE);
    d = GetLastError();
    CloseHandle(h);
    SetFileAttributes(Filename,Attributes);
    SetLastError(d);

    return(b);
}


BOOL
IsCurrentOsServer(
    void
    )
{
    LONG l;
    HKEY hKey;
    DWORD d;
    DWORD Size;
    TCHAR Value[100];
    DWORD Type;


    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
            0,
            NULL,
            0,
            KEY_QUERY_VALUE,
            NULL,
            &hKey,
            &d
            );

    if (l != NO_ERROR) {
        return FALSE;
    }

    Size = sizeof(Value);

    l = RegQueryValueEx(hKey,TEXT("ProductType"),NULL,&Type,(LPBYTE)Value,&Size);

    RegCloseKey(hKey);

    if (l != NO_ERROR) {
        return FALSE;
    }

    if (lstrcmpi(Value,TEXT("winnt")) == 0) {
        return FALSE;
    }

    return TRUE;
}


BOOL
IsCurrentAdvancedServer(
    void
    )
{
    LONG l;
    HKEY hKey;
    DWORD d;
    DWORD Size;
    TCHAR Value[100];
    DWORD Type;


    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
            0,
            NULL,
            0,
            KEY_QUERY_VALUE,
            NULL,
            &hKey,
            &d
            );

    if (l != NO_ERROR) {
        return FALSE;
    }

    Size = sizeof(Value);

    l = RegQueryValueEx(hKey,TEXT("ProductType"),NULL,&Type,(LPBYTE)Value,&Size);

    RegCloseKey(hKey);

    if (l != NO_ERROR) {
        return FALSE;
    }

    if (lstrcmpi(Value,TEXT("lanmannt")) == 0) {
        return TRUE;
    }

    return FALSE;
}


BOOL
ConcatenateFile(
    IN HANDLE   hOpenFile,
    IN  LPTSTR  FileName
    )
/*++

Routine Description:

    This routine will go load the named file, and concatenate its
    contents into the open file.

Arguments:
    FileName    The name of the file we're going to concatenate.

Return Value:

    TRUE        Everything went okay.
    FALSE       We failed.

--*/

{
HANDLE      hFile, hFileMapping;
DWORD       FileSize, BytesWritten;
BYTE        *pbFile;
BOOL        ReturnValue = TRUE;

    //
    // Open the file...
    //
    hFile = CreateFile( FileName,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );
    if( hFile != INVALID_HANDLE_VALUE ) {

        //
        // Map the file...
        //
        hFileMapping = CreateFileMapping( hFile,
                                          NULL,
                                          PAGE_READONLY,
                                          0,
                                          0,
                                          NULL );
        if( hFileMapping ) {
            pbFile = MapViewOfFile( hFileMapping,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0 );
            if( pbFile ) {

                //
                // Write the file...
                //
                FileSize = GetFileSize( hFile, NULL );
                if( FileSize != 0xFFFFFFFF ) {
                    if( hOpenFile ) {
                        WriteFile( hOpenFile, pbFile, FileSize, &BytesWritten, NULL );
                    } else {
                        ReturnValue = FALSE;
                    }
                } else {
                    ReturnValue = FALSE;
                }

                UnmapViewOfFile( pbFile );
            } else {
                ReturnValue = FALSE;
            }

            CloseHandle( hFileMapping );
        } else {
            ReturnValue = FALSE;
        }

        CloseHandle( hFile );
    } else {
        ReturnValue = FALSE;
    }

    return( ReturnValue );
}


BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
DoesDirectoryExist (
    IN      PCTSTR DirSpec
    )

/*++

Routine Description:

    Determine if a directory exists and is accessible.
    This routine works even with the root of drives or with the root of
    network shares (like \\server\share).

Arguments:

    DirSpec - supplies full path of dir to check for existance;

Return Value:

    TRUE if the dir exists and is accessible.

--*/

{
    TCHAR pattern[MAX_PATH];
    BOOL b = FALSE;

    if (DirSpec) {
        if (BuildPath2 (pattern, MAX_PATH, DirSpec, TEXT("*"))) {
            WIN32_FIND_DATA fd;
            HANDLE h = FindFirstFile (pattern, &fd);
            if (h != INVALID_HANDLE_VALUE) {
                FindClose (h);
                b = TRUE;
            }
        }
    }
    return b;
}


#ifdef _X86_

BOOLEAN
IsValidDrive(
TCHAR Drive
)
{
/*++

Routine Description:

    This routine check formatted disk type
    NEC98 of NT4 has supported NEC98 format and PC-AT format.
    But BIOS is handling only NEC98 format.
    So We need setup Boot stuff to ONLY NEC98 formated HD.

Arguments:
    Drive    Drive letter.

Return Value:

    TRUE        Dive is NEC98 format.
    FALSE       Drive is not NEC98 format.

--*/
    HANDLE hDisk;
    TCHAR HardDiskName[] = TEXT("\\\\.\\?:");
    PUCHAR pBuffer,pUBuffer;
    WCHAR Buffer[128];
    WCHAR DevicePath[128];
    WCHAR DriveName[3];
    WCHAR DiskNo;
    STORAGE_DEVICE_NUMBER   number;
    PWCHAR p;
    ULONG bps;
    NTSTATUS Sts;
    DWORD DataSize,ExtentSize;
    BOOL b;
    PVOLUME_DISK_EXTENTS Extent;


    if (!ISNT())
        return TRUE;

    HardDiskName[4] = Drive;
    DriveName[0] = Drive;
    DriveName[1] = ':';
    DriveName[2] = 0;
    if(QueryDosDeviceW(DriveName, Buffer, sizeof(Buffer)/sizeof(TCHAR))) {
        if (BuildNumber <= NT40){ //check NT Version
            //
            // QueryDosDevice in NT3.51 is buggy.
            // This API return "\\Harddisk\...." or
            // "\\harddisk\...."
            // We need work around.
            //
            p = wcsstr(Buffer, L"arddisk");
            if (!p) {
                return FALSE;
            }
            DiskNo = (*(p + 7) - 0x30);
        } else {
            hDisk = CreateFile(
                HardDiskName,
                0,
                FILE_SHARE_WRITE, NULL,
                OPEN_EXISTING, 0, NULL
                );
            if(hDisk == INVALID_HANDLE_VALUE) {
                return FALSE;
            }
            b = DeviceIoControl(hDisk, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                            &number, sizeof(number), &DataSize, NULL);
            if (b) {
                DiskNo = (TCHAR) number.DeviceNumber;
            } else {
                Extent = malloc(1024);
                ExtentSize = 1024;
                if(!Extent) {
                    CloseHandle( hDisk );
                    return FALSE;
                }
                b = DeviceIoControl(hDisk, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                    NULL, 0,
                                    (PVOID)Extent, ExtentSize, &DataSize, NULL);
                if (!b) {
                    free(Extent);
                    CloseHandle( hDisk );
                    return FALSE;
                }
                if (Extent->NumberOfDiskExtents != 1){
                    free(Extent);
                    CloseHandle( hDisk );
                    return FALSE;
                }
                DiskNo = (TCHAR)Extent->Extents->DiskNumber;
                free(Extent);
            }
            CloseHandle(hDisk);
        }
        swprintf(DevicePath, L"\\\\.\\PHYSICALDRIVE%u", DiskNo);
        hDisk =   CreateFileW( DevicePath,
                               GENERIC_READ|GENERIC_WRITE,
                               FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, 0, NULL);
        if(hDisk == INVALID_HANDLE_VALUE) {
            return FALSE;
        }
        if ((bps = GetHDBps(hDisk)) == 0){
            CloseHandle(hDisk);
            return FALSE;
        }
        pUBuffer = MALLOC(bps * 2);
        pBuffer = ALIGN(pUBuffer, bps);
        RtlZeroMemory(pBuffer, bps);
        Sts = SpReadWriteDiskSectors(hDisk,0,1,bps,pBuffer, NEC_READSEC);
        if(!NT_SUCCESS(Sts)) {
            FREE(pUBuffer);
            CloseHandle(hDisk);
            return FALSE;
        }
        if (!(pBuffer[4] == 'I'
           && pBuffer[5] == 'P'
           && pBuffer[6] == 'L'
           && pBuffer[7] == '1')){
            FREE(pUBuffer);
            CloseHandle(hDisk);
            return FALSE;
        }
        FREE(pUBuffer);
        CloseHandle(hDisk);
        return TRUE;
    }
    return FALSE;
}

BOOLEAN
CheckATACardonNT4(
HANDLE hDisk
)
{
//
// NT4, NT3.51 for NEC98.
// NEC98 does not handle to boot from PCMCIA ATA card disk.
// So we need to check ATA Disk.
//
// Return
//         TRUE is ATA Card
//        FALSE is Other
//

#define IOCTL_DISK_GET_FORMAT_MEDIA CTL_CODE(IOCTL_DISK_BASE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define  FORMAT_MEDIA_98      0  // TYPE NEC98
#define  FORMAT_MEDIA_AT      1  // TYPE PC-AT
#define  FORMAT_MEDIA_OTHER   2  // Unknown

    struct _OutBuffer {
        ULONG    CurrentFormatMedia;
        ULONG    InitializeFormatMedia;
    } OutBuffer;
    DWORD ReturnedByteCount;

    if (!(DeviceIoControl(hDisk, IOCTL_DISK_GET_FORMAT_MEDIA,  NULL,
                              0,
                              &OutBuffer,
                              sizeof(struct _OutBuffer),
                              &ReturnedByteCount,
                              NULL
                              ) )){
        return FALSE;
    }

    if (OutBuffer.InitializeFormatMedia == FORMAT_MEDIA_AT){
        return TRUE;
    }
        return FALSE;
}


#endif


BOOL
IsMachineSupported(
    OUT PCOMPATIBILITY_ENTRY CompEntry
    )

/*++

Routine Description:

    This function determines whether or not the machine is supported by the version
    of NT to be installed.

Arguments:

    CompEntry - If the machine is not supported, the Compatability Entry
                is updated to describe why the machine is not supported.

Return Value:

    Boolean value indicating whether the machine is supported.

--*/

{
    TCHAR       SetupLogPath[MAX_PATH];
    TCHAR       KeyName[MAX_PATH];
    TCHAR       HalName[MAX_PATH];
    LPTSTR      p;
    LPTSTR      szHalDll = TEXT("hal.dll");
    LPTSTR      SectionName;
    LPTSTR      UnsupportedName;
    BOOL        b;

    //
    //  Assume that the machine is supported
    //
    b = TRUE;

#ifdef _X86_

    try {
        ULONG Name0, Name1, Name2, Family, Flags;
        _asm {
            push    ebx             ;; save ebx
            mov     eax, 0          ;; get processor vendor
            _emit   00fh            ;; CPUID(0)
            _emit   0a2h            ;;
            mov     Name0,  ebx     ;; Name[0-3]
            mov     Name1,  edx     ;; Name[4-7]
            mov     Name2,  ecx     ;; Name[8-11]
            mov     eax, 1          ;; get family/model/stepping and features
            _emit   00fh            ;; CPUID(1)
            _emit   0a2h
            mov     Family, eax     ;; save family/model/stepping
            mov     Flags, edx      ;; save flags returned by CPUID
            pop     ebx             ;; restore ebx
        }

        //
        // Check the cmpxchg8b flag in the flags returned by CPUID.
        //

        if ((Flags  & 0x100) == 0) {

            //
            // This processor doesn't support the CMPXCHG instruction
            // which is required for Whistler.
            //
            // Some processors actually do support it but claim they
            // don't because of a bug in NT 4.   See if this processor
            // is one of these.
            //

            if (!(((Name0 == 'uneG') &&
                  (Name1 == 'Teni') &&
                  (Name2 == '68xM') &&
                  (Family >= 0x542)) ||
                  (Name0 == 'tneC') &&
                  (Name1 == 'Hrua') &&
                  (Name2 == 'slua') &&
                  (Family >= 0x500))) {
                b = FALSE;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // If this processor doesn't support CPUID, we don't
        // run on it.
        //

        b = FALSE;
    }

    if (!b) {
        CompEntry->HtmlName = TEXT("cpufeat.htm");
        CompEntry->TextName = TEXT("cpufeat.txt");
        SectionName = TEXT("UnsupportedArchitectures");
        UnsupportedName = TEXT("missprocfeat");
    }

#endif // _X86_

    if( b && ISNT() ) {
        //
        //  Build the path to setup.log
        //
        MyGetWindowsDirectory( SetupLogPath, MAX_PATH );
        ConcatenatePaths( SetupLogPath, TEXT("repair\\setup.log"), MAX_PATH );
        //
        // Find out the actual name of the hal installed
        //

        if (!IsArc()) {
#ifdef _X86_
            //
            //  On BIOS, look for %windir%\system32\hal.dll in the section
            //  [Files.WinNt]
            //
            GetSystemDirectory( KeyName, MAX_PATH );
            ConcatenatePaths(KeyName, szHalDll, MAX_PATH );
            SectionName = TEXT("Files.WinNt");

            //
            // While we are at it, see if this is Windows 2000 or higher
            // to see if the hal should be preserved or not
            //
#ifdef UNICODE
            if (BUILDNUM() >= 2195) {

                PCHAR   halName;

                halName = FindRealHalName( KeyName );
                if (halName) {

                    WriteAcpiHalValue = TRUE;
                    if (!strcmp(halName,"halacpi") ||
                        !strcmp(halName,"halmacpi") ||
                        !strcmp(halName,"halaacpi")) {

                        AcpiHalValue = TRUE;

                    }

                }

            }
#endif // UNICODE

#endif // _X86_
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            //  On ARC, look for hal.dll in the section [Files.SystemPartition]
            //
            lstrcpy( KeyName, szHalDll );
            SectionName = TEXT("Files.SystemPartition");
#endif // UNICODE
        } // if (!IsArc())
        GetPrivateProfileString( SectionName,
                                 KeyName,
                                 TEXT(""),
                                 HalName,
                                 sizeof(HalName)/sizeof(TCHAR),
                                 SetupLogPath );
        //
        //  GetPrivateProfileString() will strip the first and last '"' from the logged value,
        //  so find the next '"' character and replace it with NUL, and we will end up with
        //  the actual hal name.
        //
        if( lstrlen(HalName) &&
            ( p = _tcschr( HalName, TEXT('"') ) )
          ) {
            *p = TEXT('\0');
            //
            //  Find out if the hal is listed in [UnsupportedArchitectures] (dosnet.inf)
            //
            SectionName = TEXT("UnsupportedArchitectures");
            b = !InfDoesLineExistInSection( MainInf,
                                            SectionName,
                                            HalName );
            UnsupportedName = HalName;
        }
    }

    //
    // If architecture is not supported, look up the description.
    //

    if( !b ) {
        CompEntry->Description = (LPTSTR)InfGetFieldByKey( MainInf,
                                                           SectionName,
                                                           UnsupportedName,
                                                           0 );
    }
    return( b );
}

BOOL 
DoesCurrentSystemHasThirdPartyKernel(
    VOID
    );

BOOL 
SystemKernelCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    BOOL bResult = TRUE;
    PWSTR Buffer;

#if defined(UNICODE) && defined(_X86_)
    COMPATIBILITY_ENTRY CompEntry;

    if(!DoesCurrentSystemHasThirdPartyKernel()){
        return FALSE;
    }

    FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        hInst,
        MSG_SYSTEM_HAS_THIRD_PARTY_KERNEL,
        0,
        (PWSTR)&Buffer,
        0,
        NULL
        );

    CompEntry.Description = Buffer;
    CompEntry.HtmlName = TEXT("compdata\\krnlchk.htm");
    CompEntry.TextName = TEXT("compdata\\krnlchk.txt");
    CompEntry.RegKeyName = NULL;
    CompEntry.RegValName = NULL;
    CompEntry.RegValDataSize = 0;
    CompEntry.RegValData = NULL;
    CompEntry.SaveValue = NULL;
    CompEntry.Flags = 0;
    CompEntry.InfName = NULL;
    CompEntry.InfSection = NULL;

    bResult = CompatibilityCallback(&CompEntry, Context);

    LocalFree(Buffer);
#endif

    return bResult;
}

BOOL
UnsupportedArchitectureCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )

/*++

Routine Description:

    Check if the machine is no longer supported by Windows NT.
    This routine is meaningful only when run on NT -- it always succeeds
    on Win95.

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    Returns always TRUE.

--*/


{
    COMPATIBILITY_ENTRY CompEntry;

    CompEntry.Description = TEXT("mca");//BUGBUG: must be changed
#ifdef _X86_
    CompEntry.HtmlName = TEXT("mca.htm");
    CompEntry.TextName = TEXT("mca.txt");
#else
    CompEntry.HtmlName = TEXT("");
    CompEntry.TextName = TEXT("");
#endif
    CompEntry.RegKeyName = NULL;
    CompEntry.RegValName = NULL;
    CompEntry.RegValDataSize = 0;
    CompEntry.RegValData = NULL;
    CompEntry.SaveValue = NULL;
    CompEntry.Flags = 0;
    CompEntry.InfName = NULL;
    CompEntry.InfSection = NULL;

    if( !IsMachineSupported( &CompEntry ) ) {
        if(!CompatibilityCallback(&CompEntry, Context)){
            DWORD Error;
            Error = GetLastError();
        }
    }
    return( TRUE );
}


BOOL
GetUserPrintableFileSizeString(
    IN DWORDLONG Size,
    OUT LPTSTR Buffer,
    IN DWORD BufferSize
    )
/*++

Routine Description:

    Takes a size and comes up with a printable version of this size,
    using the appropriate size format (ie., KB, MB, GB, Bytes, etc.)

Arguments:

    Size - size to be converted (in bytes)
    Buffer - string buffer to receive the data
    BufferSize - indicates the buffer size, *in characters*

Return Value:

    TRUE indicates success, FALSE indicates failure.  If we fail,
    call GetLastError() to get extended failure status.

--*/

{
    LPTSTR  NumberString;
    UINT uResource;
    TCHAR ResourceString[100];
    DWORD cb;
    DWORD d;
    BOOL RetVal = FALSE;
    DWORDLONG TopPart;
    DWORDLONG BottomPart;

    //
    // Determine which resource string to use
    //
    if (Size < 1024) {
        uResource = IDS_SIZE_BYTES;
        TopPart = 0;
        BottomPart = 1;
        wsprintf(ResourceString, TEXT("%u"), Size);
    } else if (Size < (1024 * 1024)) {

        uResource = IDS_SIZE_KBYTES;
        TopPart = (Size%1024)*100;
        BottomPart = 1024;

        wsprintf(ResourceString,
                 TEXT("%u.%02u"),
                 (DWORD) (Size / 1024),
                 (DWORD)(TopPart/BottomPart));
    } else if (Size < (1024 * 1024 * 1024)) {
        uResource = IDS_SIZE_MBYTES;
        TopPart = (Size%(1024*1024))*100;
        BottomPart = 1024*1024;
        wsprintf(ResourceString,
                 TEXT("%u.%02u"),
                 (DWORD)(Size / (1024 * 1024)),
                 (DWORD)(TopPart/BottomPart) );
    } else {
        uResource = IDS_SIZE_GBYTES;
        TopPart = (Size%(1024*1024*1024))*100;
        BottomPart = 1024*1024*1024;
        wsprintf(ResourceString,
                 TEXT("%u.%02u"),
                 (DWORD)(Size / (1024 * 1024 * 1024)),
                 (DWORD)(TopPart/BottomPart) );
    }

    // Format the number string
    cb = GetNumberFormat(LOCALE_USER_DEFAULT, 0, ResourceString, NULL, NULL, 0);
    NumberString = (LPTSTR) MALLOC((cb + 1) * sizeof(TCHAR));
    if (!NumberString) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        RetVal = FALSE;
        goto e0;
    }

    GetNumberFormat(LOCALE_USER_DEFAULT, 0, ResourceString, NULL, NumberString, cb);

    LoadString(hInst, uResource, ResourceString, sizeof(ResourceString)/sizeof(TCHAR));

    //
    // it's tricky to know if we really have enough space in the buffer since
    // we're dealing with substitution strings.  The below is an
    // approximate check since we assume that the number string is likely
    // larger than our substitution string (%s) that we're filling in.
    //
    if (BufferSize > (DWORD)(lstrlen(ResourceString) + lstrlen(NumberString) + 1)) {
        wsprintf(Buffer, ResourceString, NumberString);
        d = ERROR_SUCCESS;
        RetVal = TRUE;
    } else {
        d = ERROR_INSUFFICIENT_BUFFER;
        RetVal = FALSE;
    }

    FREE(NumberString);
e0:
    SetLastError(d);
    return(RetVal);

}


BOOL
BuildSystemPartitionPathToFile (
    IN      PCTSTR FileName,
    OUT     PTSTR Path,
    IN      DWORD BufferSizeChars
    )
{
    //
    // must have a root
    //
    if(SystemPartitionDriveLetter) {
        Path[0] = SystemPartitionDriveLetter;
        Path[1] = TEXT(':');
        Path[2] = 0;
    } else {
#ifdef UNICODE
        if (SystemPartitionVolumeGuid) {
            lstrcpyn (Path, SystemPartitionVolumeGuid, BufferSizeChars);
        }
        else
#endif
        {
            MYASSERT (FALSE);
            return FALSE;
        }
    }
    ConcatenatePaths (Path, FileName, BufferSizeChars);
    return TRUE;
}


PTSTR
BuildPath (
    IN      PTSTR DestPath,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    )
{
    PTSTR p;

    p = _tcsrchr (Path1, TEXT('\\'));
    if (p && !p[1]) {
        *p = 0;
    }
    if (*Path2 == TEXT('\\')) {
        Path2++;
    }
    return DestPath + wsprintf (DestPath, TEXT("%s\\%s"), Path1, Path2);
}

PTSTR
BuildPath2 (
    IN      PTSTR DestPath,
    IN      DWORD Chars,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    )
{
    INT i = _sntprintf (DestPath, Chars, TEXT("%s\\%s"), Path1, Path2);
    if (i < 0) {
        return NULL;
    }
    return DestPath + i;
}


BOOL
EnumFirstFilePattern (
    OUT     PFILEPATTERN_ENUM Enum,
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern
    )
{
    TCHAR pattern[MAX_PATH];

    BuildPath (pattern, Dir, FilePattern);
    Enum->Handle = FindFirstFile (pattern, &Enum->FindData);
    if (Enum->Handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    lstrcpy (Enum->FullPath, Dir);
    Enum->FileName = _tcschr (Enum->FullPath, 0);
    *Enum->FileName++ = TEXT('\\');
    lstrcpy (Enum->FileName, Enum->FindData.cFileName);
    if (Enum->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if (!lstrcmp (Enum->FindData.cFileName, TEXT (".")) ||
            !lstrcmp (Enum->FindData.cFileName, TEXT (".."))) {
            return EnumNextFilePattern (Enum);
        }
    }
    return TRUE;
}

BOOL
EnumNextFilePattern (
    IN OUT  PFILEPATTERN_ENUM Enum
    )
{
again:
    if (!FindNextFile (Enum->Handle, &Enum->FindData)) {
        AbortEnumFilePattern (Enum);
        return FALSE;
    }
    lstrcpy (Enum->FileName, Enum->FindData.cFileName);
    if (Enum->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if (!lstrcmp (Enum->FindData.cFileName, TEXT (".")) ||
            !lstrcmp (Enum->FindData.cFileName, TEXT (".."))) {
            goto again;
        }
    }
    return TRUE;
}

VOID
AbortEnumFilePattern (
    IN OUT  PFILEPATTERN_ENUM Enum
    )
{
    if (Enum->Handle != INVALID_HANDLE_VALUE) {
        FindClose (Enum->Handle);
        Enum->Handle = INVALID_HANDLE_VALUE;
    }
}


BOOL
EnumFirstFilePatternRecursive (
    OUT     PFILEPATTERNREC_ENUM Enum,
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern,
    IN      DWORD ControlFlags
    )
{
    PFILEENUMLIST dir;

    dir = CreateFileEnumCell (Dir, FilePattern, 0, ENUM_FIRSTFILE);
    if (!dir) {
        return FALSE;
    }
    Enum->FilePattern = DupString (FilePattern);
    if (!Enum->FilePattern) {
        DeleteFileEnumCell (dir);
        return FALSE;
    }
    Enum->DirCurrent = dir;
    Enum->FindData = &dir->Enum.FindData;
    Enum->RootLen = lstrlen (Dir) + 1;
    Enum->ControlFlags = ControlFlags;
    Enum->Handle = INVALID_HANDLE_VALUE;
    return EnumNextFilePatternRecursive (Enum);
}

BOOL
EnumNextFilePatternRecursive (
    IN OUT  PFILEPATTERNREC_ENUM Enum
    )
{
    TCHAR pattern[MAX_PATH];
    WIN32_FIND_DATA fd;
    PFILEENUMLIST dir;

    while (Enum->DirCurrent) {
        if (Enum->ControlFlags & ECF_ABORT_ENUM_DIR) {
            //
            // caller wants to abort enum of this subdir
            // remove the current node from list
            //
            Enum->ControlFlags &= ~ECF_ABORT_ENUM_DIR;
            dir = Enum->DirCurrent->Next;
            DeleteFileEnumCell (Enum->DirCurrent);
            Enum->DirCurrent = dir;
            if (dir) {
                Enum->FindData = &dir->Enum.FindData;
            }
            continue;
        }
        switch (Enum->DirCurrent->EnumState) {
        case ENUM_FIRSTFILE:
            if (EnumFirstFilePattern (&Enum->DirCurrent->Enum, Enum->DirCurrent->Dir, Enum->FilePattern)) {
                Enum->DirCurrent->EnumState = ENUM_NEXTFILE;
                Enum->FullPath = Enum->DirCurrent->Enum.FullPath;
                Enum->SubPath = Enum->FullPath + Enum->RootLen;
                Enum->FileName = Enum->DirCurrent->Enum.FileName;
                return TRUE;
            }
            Enum->DirCurrent->EnumState = ENUM_SUBDIRS;
            break;
        case ENUM_NEXTFILE:
            if (EnumNextFilePattern (&Enum->DirCurrent->Enum)) {
                Enum->FullPath = Enum->DirCurrent->Enum.FullPath;
                Enum->SubPath = Enum->FullPath + Enum->RootLen;
                Enum->FileName = Enum->DirCurrent->Enum.FileName;
                return TRUE;
            }
            Enum->DirCurrent->EnumState = ENUM_SUBDIRS;
            //
            // fall through
            //
        case ENUM_SUBDIRS:
            BuildPath (pattern, Enum->DirCurrent->Dir, TEXT("*.*"));
            Enum->Handle = FindFirstFile (pattern, &fd);
            if (Enum->Handle != INVALID_HANDLE_VALUE) {
                do {
                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        if (!lstrcmp (fd.cFileName, TEXT (".")) ||
                            !lstrcmp (fd.cFileName, TEXT (".."))) {
                            continue;
                        }
                        wsprintf (pattern, TEXT("%s\\%s"), Enum->DirCurrent->Dir, fd.cFileName);
                        if (!InsertList (
                                (PGENERIC_LIST*)&Enum->DirCurrent,
                                (PGENERIC_LIST) CreateFileEnumCell (
                                                    pattern,
                                                    Enum->FilePattern,
                                                    fd.dwFileAttributes,
                                                    Enum->ControlFlags & ECF_ENUM_SUBDIRS ?
                                                        ENUM_SUBDIR : ENUM_FIRSTFILE
                                                    )
                                )) {
                            AbortEnumFilePatternRecursive (Enum);
                            return FALSE;
                        }
                    }
                } while (FindNextFile (Enum->Handle, &fd));
                FindClose (Enum->Handle);
                Enum->Handle = INVALID_HANDLE_VALUE;
            }
            //
            // remove the current node from list
            //
            dir = Enum->DirCurrent->Next;
            DeleteFileEnumCell (Enum->DirCurrent);
            Enum->DirCurrent = dir;
            if (dir) {
                Enum->FindData = &dir->Enum.FindData;
            }
            break;
        case ENUM_SUBDIR:
            Enum->FullPath = Enum->DirCurrent->Dir;
            Enum->SubPath = Enum->FullPath + Enum->RootLen;
            Enum->FileName = _tcsrchr (Enum->FullPath, TEXT('\\')) + 1;
            Enum->DirCurrent->EnumState = ENUM_FIRSTFILE;
            return TRUE;
        }
    }
    return FALSE;
}

VOID
AbortEnumFilePatternRecursive (
    IN OUT  PFILEPATTERNREC_ENUM Enum
    )
{
    if (Enum->DirCurrent) {
        DeleteFileEnumList (Enum->DirCurrent);
        Enum->DirCurrent = NULL;
    }
    if (Enum->Handle != INVALID_HANDLE_VALUE) {
        FindClose (Enum->Handle);
        Enum->Handle = INVALID_HANDLE_VALUE;
    }
}


BOOL
CopyTree (
    IN      PCTSTR SourceRoot,
    IN      PCTSTR DestRoot
    )
{
    DWORD rc = ERROR_SUCCESS;
    FILEPATTERNREC_ENUM e;
    TCHAR destFile[MAX_PATH];
    PTSTR p;

    if (EnumFirstFilePatternRecursive (&e, SourceRoot, TEXT("*"), 0)) {
        do {
            BuildPath (destFile, DestRoot, e.SubPath);
            p = _tcsrchr (destFile, TEXT('\\'));
            if (!p) {
                continue;
            }
            *p = 0;
            rc = CreateMultiLevelDirectory (destFile);
            if (rc != ERROR_SUCCESS) {
                AbortEnumFilePatternRecursive (&e);
                break;
            }
            *p = TEXT('\\');
            SetFileAttributes (destFile, FILE_ATTRIBUTE_NORMAL);
            if (!CopyFile (e.FullPath, destFile, FALSE)) {
                rc = GetLastError ();
                AbortEnumFilePatternRecursive (&e);
                break;
            }
        } while (EnumNextFilePatternRecursive (&e));
    } else {
        rc = GetLastError ();
    }

    SetLastError (rc);
    return rc == ERROR_SUCCESS;
}


PSTRINGLIST
CreateStringCell (
    IN      PCTSTR String
    )
{
    PSTRINGLIST p = MALLOC (sizeof (STRINGLIST));
    if (p) {
        ZeroMemory (p, sizeof (STRINGLIST));
        if (String) {
            p->String = DupString (String);
            if (!p->String) {
                FREE (p);
                p = NULL;
            }
        } else {
            p->String = NULL;
        }
    }
    return p;
}

VOID
DeleteStringCell (
    IN      PSTRINGLIST Cell
    )
{
    if (Cell) {
        FREE (Cell->String);
        FREE (Cell);
    }
}


VOID
DeleteStringList (
    IN      PSTRINGLIST List
    )
{
    PSTRINGLIST p, q;

    for (p = List; p; p = q) {
        q = p->Next;
        DeleteStringCell (p);
    }
}


BOOL
FindStringCell (
    IN      PSTRINGLIST StringList,
    IN      PCTSTR String,
    IN      BOOL CaseSensitive
    )
{
    PSTRINGLIST p;
    INT i;

    if (!StringList || !String) {
        return FALSE;
    }
    for (p = StringList; p; p = p->Next) {
        i = CaseSensitive ? _tcscmp (String, p->String) : _tcsicmp (String, p->String);
        if (i == 0) {
            return TRUE;
        }
    }
    return FALSE;
}

PFILEENUMLIST
CreateFileEnumCell (
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern,
    IN      DWORD Attributes,
    IN      DWORD EnumState
    )
{
    PFILEENUMLIST p = MALLOC (sizeof (FILEENUMLIST));
    if (p) {
        ZeroMemory (p, sizeof (FILEENUMLIST));
        p->Enum.FindData.dwFileAttributes = Attributes;
        p->EnumState = EnumState;
        p->Dir = DupString (Dir);
        if (!p->Dir) {
            FREE (p);
            p = NULL;
        }
    }
    return p;
}

VOID
DeleteFileEnumCell (
    IN      PFILEENUMLIST Cell
    )
{
    if (Cell) {
        FREE (Cell->Dir);
        FREE (Cell);
    }
}


BOOL
InsertList (
    IN OUT  PGENERIC_LIST* List,
    IN      PGENERIC_LIST NewList
    )
{
    PGENERIC_LIST p;

    if (!NewList) {
        return FALSE;
    }
    if (*List) {
        for (p = *List; p->Next; p = p->Next) ;
        p->Next = NewList;
    } else {
        *List = NewList;
    }
    return TRUE;
}


VOID
DeleteFileEnumList (
    IN      PFILEENUMLIST NewList
    )
{
    PFILEENUMLIST p, q;

    for (p = NewList; p; p = q) {
        q = p->Next;
        DeleteFileEnumCell (p);
    }
}

PCTSTR
FindSubString (
    IN      PCTSTR String,
    IN      TCHAR Separator,
    IN      PCTSTR SubStr,
    IN      BOOL CaseSensitive
    )
{
    SIZE_T len1, len2;
    PCTSTR end;

    MYASSERT (Separator);
    MYASSERT (!_istleadbyte (Separator));
    MYASSERT (SubStr);
    MYASSERT (!_tcschr (SubStr, Separator));

    len1 = lstrlen (SubStr);
    MYASSERT (SubStr[len1] == 0);

    while (String) {
        end = _tcschr (String, Separator);
        if (end) {
            len2 = end - String;
        } else {
            len2 = lstrlen (String);
        }
        if ((len1 == len2) &&
            (CaseSensitive ?
                !_tcsncmp (String, SubStr, len1) :
                !_tcsnicmp (String, SubStr, len1)
            )) {
            break;
        }
        if (end) {
            String = end + 1;
        } else {
            String = NULL;
        }
    }

    return String;
}

VOID
GetCurrentWinnt32RegKey (
    OUT     PTSTR Key,
    IN      DWORD Chars
    )
{
    _sntprintf (
        Key,
        Chars,
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Winnt32\\%u.%u"),
        VER_PRODUCTMAJORVERSION,
        VER_PRODUCTMINORVERSION
        );
}

BOOL
GetFileVersion (
    IN      PCTSTR FilePath,
    OUT     PTSTR FileVersion
    )
{
    DWORD dwLength, dwTemp;
    LPVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    UINT DataLength;
    BOOL b = FALSE;

    if (FileExists (FilePath, NULL)) {
        if (dwLength = GetFileVersionInfoSize ((PTSTR)FilePath, &dwTemp)) {
            if (lpData = LocalAlloc (LPTR, dwLength)) {
                if (GetFileVersionInfo ((PTSTR)FilePath, 0, dwLength, lpData)) {
                    if (VerQueryValue (lpData, TEXT("\\"), &VsInfo, &DataLength)) {
                        wsprintf (
                            FileVersion,
                            TEXT("%u.%u.%u.%u"),
                            (UINT)HIWORD(VsInfo->dwFileVersionMS),
                            (UINT)LOWORD(VsInfo->dwFileVersionMS),
                            (UINT)HIWORD(VsInfo->dwFileVersionLS),
                            (UINT)LOWORD(VsInfo->dwFileVersionLS)
                            );
                        b = TRUE;
                    }
                }
                LocalFree (lpData);
            }
        }
    }

    return b;
}

BOOL
IsFileVersionLesser (
    IN      PCTSTR FileToCompare,
    IN      PCTSTR FileToCompareWith
    )
{
    TCHAR version[20];

    if (GetFileVersion (FileToCompareWith, version) && CheckForFileVersion (FileToCompare, version)) {
        DebugLog (
            Winnt32LogInformation,
            TEXT("File %1 has a smaller version (%2) than %3"),
            0,
            FileToCompare,
            version,
            FileToCompareWith
            );
        return TRUE;
    }

    return FALSE;
}


BOOL
FindPathToInstallationFileEx (
    IN      PCTSTR FileName,
    OUT     PTSTR PathToFile,
    IN      DWORD PathToFileBufferSize,
    OUT     PBOOL Compressed                OPTIONAL
    )
{
    DWORD i;
    DWORD attr;
    BOOL b;
    HANDLE h;
    WIN32_FIND_DATA fd;
    PTSTR p, q;

    if (!FileName || !*FileName) {
        return FALSE;
    }

    //
    // Search for installation files in this order:
    // 1. AlternateSourcePath (specified on the cmd line with /M:Path
    // 2. Setup Update files (downloaded from the web)
    // 3. NativeSourcePath(s)
    // 4. SourcePath(s)
    //
    if (AlternateSourcePath[0]) {
        lstrcpyn (PathToFile, AlternateSourcePath, PathToFileBufferSize);
        ConcatenatePaths (PathToFile, FileName, PathToFileBufferSize);
        attr = GetFileAttributes (PathToFile);
        if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
            return TRUE;
        }
    }

    if (g_DynUpdtStatus->UpdatesPath[0]) {
        BuildPath (PathToFile, g_DynUpdtStatus->UpdatesPath, FileName);
        attr = GetFileAttributes (PathToFile);
        if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
            return TRUE;
        }
    }

    for (i = 0; i < SourceCount; i++) {
        lstrcpyn (PathToFile, NativeSourcePaths[i], PathToFileBufferSize);
        ConcatenatePaths (PathToFile, FileName, PathToFileBufferSize);
        p = CharPrev (PathToFile, _tcschr (PathToFile, 0));
        *p = TEXT('?');
        b = FALSE;
        h = FindFirstFile (PathToFile, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                q = CharPrev (fd.cFileName, _tcschr (fd.cFileName, 0));
                *p = *q;
                if (Compressed) {
                    *Compressed = (*q == TEXT('_'));
                }
                b = TRUE;
            }
            FindClose (h);
        }
        if (b) {
            return TRUE;
        }
    }

    for (i = 0; i < SourceCount; i++) {
        lstrcpyn (PathToFile, SourcePaths[i], PathToFileBufferSize);
        ConcatenatePaths (PathToFile, FileName, PathToFileBufferSize);
        p = CharPrev (PathToFile, _tcschr (PathToFile, 0));
        *p = TEXT('?');
        b = FALSE;
        h = FindFirstFile (PathToFile, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                q = CharPrev (fd.cFileName, _tcschr (fd.cFileName, 0));
                *p = *q;
                if (Compressed) {
                    *Compressed = (*q == TEXT('_'));
                }
                b = TRUE;
            }
            FindClose (h);
        }
        if (b) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
FindPathToWinnt32File (
    IN      PCTSTR FileRelativePath,
    OUT     PTSTR PathToFile,
    IN      DWORD PathToFileBufferSize
    )
{
    DWORD i;
    DWORD attr;
    TCHAR cdFilePath[MAX_PATH];
    PTSTR p;

    if (!FileRelativePath || !*FileRelativePath) {
        return FALSE;
    }

    if (!GetModuleFileName (NULL, cdFilePath, MAX_PATH) ||
        !(p = _tcsrchr (cdFilePath, TEXT('\\')))) {
        return FALSE;
    }
    lstrcpy (p + 1, FileRelativePath);

    //
    // Search for winnt32 files in this order:
    // 1. AlternateSourcePath (specified on the cmd line with /M:Path
    // 2. Setup Update files (downloaded from the web)
    // 3. NativeSourcePath(s)
    // 4. SourcePath(s)
    //
    if (AlternateSourcePath[0]) {
        if (BuildPath2 (PathToFile, PathToFileBufferSize, AlternateSourcePath, FileRelativePath)) {
            attr = GetFileAttributes (PathToFile);
            if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                return TRUE;
            }
        }
        p = _tcsrchr (PathToFile, TEXT('\\'));
        if (p) {
            //
            // try the root of /M too, for backward compatibility with W2K
            //
            if (BuildPath2 (PathToFile, PathToFileBufferSize, AlternateSourcePath, p + 1)) {
                attr = GetFileAttributes (PathToFile);
                if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                    return TRUE;
                }
            }
        }
    }


    if (g_DynUpdtStatus && g_DynUpdtStatus->Winnt32Path[0]) {
        BuildPath (PathToFile, g_DynUpdtStatus->Winnt32Path, FileRelativePath);
        attr = GetFileAttributes (PathToFile);


        if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // check file version relative to the CD version
            //
            if (!IsFileVersionLesser (PathToFile, cdFilePath)) {
                return TRUE;
            }
        }
    }

#ifndef UNICODE
    //
    // on Win9x systems, first check if the file was downloaded in %windir%\winnt32
    // load it from there if it's present
    //
    if (g_LocalSourcePath) {
        lstrcpynA (PathToFile, g_LocalSourcePath, PathToFileBufferSize);
        ConcatenatePaths (PathToFile, FileRelativePath, PathToFileBufferSize);
        attr = GetFileAttributes (PathToFile);
        if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
            return TRUE;
        }
    }
#endif

    for (i = 0; i < SourceCount; i++) {
        lstrcpyn (PathToFile, NativeSourcePaths[i], PathToFileBufferSize);
        ConcatenatePaths (PathToFile, FileRelativePath, PathToFileBufferSize);
        attr = GetFileAttributes (PathToFile);
        if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
            return TRUE;
        }
    }

    for (i = 0; i < SourceCount; i++) {
        lstrcpyn (PathToFile, SourcePaths[i], PathToFileBufferSize);
        ConcatenatePaths (PathToFile, FileRelativePath, PathToFileBufferSize);
        attr = GetFileAttributes (PathToFile);
        if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
            return TRUE;
        }
    }

    attr = GetFileAttributes (cdFilePath);
    if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
        lstrcpyn (PathToFile, cdFilePath, MAX_PATH);
        return TRUE;
    }

    return FALSE;
}

BOOL
CreateDir (
    IN      PCTSTR DirName
    )
{
    return CreateDirectory (DirName, NULL) || GetLastError () == ERROR_ALREADY_EXISTS;
}


BOOL
GetLinkDate (
    IN      PCTSTR FilePath,
    OUT     PDWORD LinkDate
    )
{
    HANDLE hFile;
    HANDLE hFileMapping;
    PVOID pFileBase;
    DWORD fileSize;
    PIMAGE_DOS_HEADER dosHeader;
    PIMAGE_NT_HEADERS pNtHeaders;
    DWORD rc;

    rc = MapFileForRead (FilePath, &fileSize, &hFile, &hFileMapping, &pFileBase);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    __try {
        if (fileSize < sizeof (IMAGE_DOS_HEADER)) {
            rc = ERROR_BAD_FORMAT;
            __leave;
        }
        dosHeader = (PIMAGE_DOS_HEADER)pFileBase;
        if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            rc = ERROR_BAD_FORMAT;
            __leave;
        }
        if ((DWORD)dosHeader->e_lfanew + sizeof (IMAGE_NT_HEADERS) > fileSize) {
            rc = ERROR_BAD_FORMAT;
            __leave;
        }
        pNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pFileBase + dosHeader->e_lfanew);
        if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
            rc = ERROR_BAD_FORMAT;
            __leave;
        }
        *LinkDate = pNtHeaders->FileHeader.TimeDateStamp;
        rc = ERROR_SUCCESS;
    } __finally {
        UnmapFile (hFileMapping, pFileBase);
        CloseHandle (hFile);
        SetLastError (rc);
    }

    return rc == ERROR_SUCCESS;
}



BOOL
CheckForFileVersionEx (
    LPCTSTR FileName,
    LPCTSTR FileVer,                OPTIONAL
    LPCTSTR BinProductVer,          OPTIONAL
    LPCTSTR LinkDate                OPTIONAL
    )
/*
    Arguments -

        FileName - Full path to the file to check
        Filever  - Version value to check against of the for x.x.x.x
        BinProductVer - Version value to check against of the for x.x.x.x
        LinkDate - Link date of executable

    Function will check the actual file against the fields specified. The depth of the check
    is as deep as specified in "x.x.x.x" i..e if FileVer = 3.5.1 and actual version on the file
    is 3.5.1.4 we only compare upto 3.5.1.

    Return values -

    TRUE - If the version of the file is <= FileVer which means that the file is an incompatible one

    else we return FALSE

*/

{
    TCHAR Buffer[MAX_PATH];
    TCHAR temp[MAX_PATH];
    DWORD dwLength, dwTemp;
    UINT DataLength;
    LPVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    LPTSTR s,e;
    DWORD Vers[5],File_Vers[5];//MajVer, MinVer;
    INT i, Depth;
    BOOL bEqual, bError = FALSE;
    DWORD linkDate, fileLinkDate;
    BOOL bIncompatible;
    BOOL bIncompFileVer, bIncompBinProdVer;

    if (!ExpandEnvironmentStrings( FileName, Buffer, sizeof(Buffer)/sizeof(TCHAR) )) {
        return FALSE;
    }

    if(!FileExists(Buffer, NULL))
        return FALSE;

    bIncompatible = FALSE;

    if(FileVer && *FileVer || BinProductVer && *BinProductVer) {
        //
        // we need to read the version info
        //
        if(dwLength = GetFileVersionInfoSize( Buffer, &dwTemp )) {
            if(lpData = LocalAlloc( LPTR, dwLength )) {
                if(GetFileVersionInfo( Buffer, 0, dwLength, lpData )) {
                    if (VerQueryValue( lpData, TEXT("\\"), &VsInfo, &DataLength )) {

                        if (FileVer && *FileVer) {
                            File_Vers[0] = (HIWORD(VsInfo->dwFileVersionMS));
                            File_Vers[1] = (LOWORD(VsInfo->dwFileVersionMS));
                            File_Vers[2] = (HIWORD(VsInfo->dwFileVersionLS));
                            File_Vers[3] = (LOWORD(VsInfo->dwFileVersionLS));
                            lstrcpy (temp, FileVer);
                            //
                            //Parse and get the depth of versioning we look for
                            //
                            s = e = temp;
                            bEqual = FALSE;
                            i = 0;
                            if (*e == TEXT('=')) {
                                bEqual = TRUE;
                                e++;
                                s++;
                            }
                            while (e) {
                                if (((*e < TEXT('0')) || (*e > TEXT('9'))) &&
                                    (*e != TEXT('.')) &&
                                    (*e != TEXT('\0'))
                                    ) {
                                    MYASSERT (FALSE);
                                    bError = TRUE;
                                    break;
                                }
                                if (*e == TEXT('\0')) {
                                    *e = 0;
                                    Vers[i] = _ttoi(s);
                                    break;
                                }
                                if (*e == TEXT('.')) {
                                    *e = 0;
                                    Vers[i++] = _ttoi(s);
                                    s = e+1;
                                }
                                e++;
                            }// while

                            if (!bError) {
                                Depth = i + 1;
                                if (Depth > 4) {
                                    Depth = 4;
                                }
                                for (i = 0; i < Depth; i++) {
                                    if (File_Vers[i] == Vers[i]) {
                                        continue;
                                    }
                                    if (bEqual) {
                                        break;
                                    }
                                    if (File_Vers[i] > Vers[i]) {
                                        break;
                                    }
                                    bIncompatible = TRUE;
                                    break;
                                }
                                if (i == Depth) {
                                    //
                                    // everything matched - the file is incompatible
                                    //
                                    bIncompatible = TRUE;
                                }
                            }
                        } else {
                            bIncompatible = TRUE;
                        }
                        if (!bError && bIncompatible && BinProductVer && *BinProductVer) {
                            //
                            // reset status
                            //
                            bIncompatible = FALSE;
                            File_Vers[0] = (HIWORD(VsInfo->dwProductVersionMS));
                            File_Vers[1] = (LOWORD(VsInfo->dwProductVersionMS));
                            File_Vers[2] = (HIWORD(VsInfo->dwProductVersionLS));
                            File_Vers[3] = (LOWORD(VsInfo->dwProductVersionLS));
                            lstrcpy (temp, BinProductVer);
                            //
                            //Parse and get the depth of versioning we look for
                            //
                            s = e = temp;
                            bEqual = FALSE;
                            i = 0;
                            if (*e == TEXT('=')) {
                                bEqual = TRUE;
                                e++;
                                s++;
                            }
                            while (e) {
                                if (((*e < TEXT('0')) || (*e > TEXT('9'))) &&
                                    (*e != TEXT('.')) &&
                                    (*e != TEXT('\0'))
                                    ) {
                                    MYASSERT (FALSE);
                                    bError = TRUE;
                                    break;
                                }
                                if (*e == TEXT('\0')) {
                                    *e = 0;
                                    Vers[i] = _ttoi(s);
                                    break;
                                }
                                if (*e == TEXT('.')) {
                                    *e = 0;
                                    Vers[i++] = _ttoi(s);
                                    s = e+1;
                                }
                                e++;
                            }// while

                            if (!bError) {
                                Depth = i + 1;
                                if (Depth > 4) {
                                    Depth = 4;
                                }
                                for (i = 0; i < Depth; i++) {
                                    if (File_Vers[i] == Vers[i]) {
                                        continue;
                                    }
                                    if (bEqual) {
                                        break;
                                    }
                                    if (File_Vers[i] > Vers[i]) {
                                        break;
                                    }
                                    bIncompatible = TRUE;
                                    break;
                                }
                                if (i == Depth) {
                                    //
                                    // everything matched - the file is incompatible
                                    //
                                    bIncompatible = TRUE;
                                }
                            }
                        }
                    }
                }
                LocalFree( lpData );
            }
        }
    } else {
        bIncompatible = TRUE;
    }

    if (!bError && bIncompatible && LinkDate && *LinkDate) {
        bEqual = FALSE;
        if (*LinkDate == TEXT('=')) {
            LinkDate++;
            bEqual = TRUE;
        }
        bIncompatible = FALSE;
        if (StringToInt (LinkDate, &linkDate)) {
            if (GetLinkDate (Buffer, &fileLinkDate)) {
                if (fileLinkDate == linkDate ||
                    !bEqual && fileLinkDate < linkDate
                    ) {
                    bIncompatible = TRUE;
                }
            }
        }
    }
    if (bError) {
        bIncompatible = FALSE;
    }
    return bIncompatible;
}

BOOL
StringToInt (
    IN  PCTSTR      Field,
    OUT PINT        IntegerValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    INT Value;
    UINT c;
    BOOL Neg;
    UINT Base;
    UINT NextDigitValue;
    INT OverflowCheck;
    BOOL b;

    if(!Field) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(*Field == TEXT('-')) {
        Neg = TRUE;
        Field++;
    } else {
        Neg = FALSE;
        if(*Field == TEXT('+')) {
            Field++;
        }
    }

    if((*Field == TEXT('0')) &&
       ((*(Field+1) == TEXT('x')) || (*(Field+1) == TEXT('X')))) {
        //
        // The number is in hexadecimal.
        //
        Base = 16;
        Field += 2;
    } else {
        //
        // The number is in decimal.
        //
        Base = 10;
    }

    for(OverflowCheck = Value = 0; *Field; Field++) {

        c = (UINT)*Field;

        if((c >= (UINT)'0') && (c <= (UINT)'9')) {
            NextDigitValue = c - (UINT)'0';
        } else if(Base == 16) {
            if((c >= (UINT)'a') && (c <= (UINT)'f')) {
                NextDigitValue = (c - (UINT)'a') + 10;
            } else if ((c >= (UINT)'A') && (c <= (UINT)'F')) {
                NextDigitValue = (c - (UINT)'A') + 10;
            } else {
                break;
            }
        } else {
            break;
        }

        Value *= Base;
        Value += NextDigitValue;

        //
        // Check for overflow.  For decimal numbers, we check to see whether the
        // new value has overflowed into the sign bit (i.e., is less than the
        // previous value.  For hexadecimal numbers, we check to make sure we
        // haven't gotten more digits than will fit in a DWORD.
        //
        if(Base == 16) {
            if(++OverflowCheck > (sizeof(INT) * 2)) {
                break;
            }
        } else {
            if(Value < OverflowCheck) {
                break;
            } else {
                OverflowCheck = Value;
            }
        }
    }

    if(*Field) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    if(Neg) {
        Value = 0-Value;
    }
    b = TRUE;
    try {
        *IntegerValue = Value;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return(b);
}


BOOLEAN
CheckForFileVersion (
    LPCTSTR FileName,
    LPCTSTR FileVer
    )
{
    return (BOOLEAN)CheckForFileVersionEx (FileName, FileVer, NULL, NULL);
}


VOID
FixMissingKnownDlls (
    OUT     PSTRINGLIST* MissingKnownDlls,
    IN      PCTSTR RestrictedCheckList      OPTIONAL
    )
{
    PCTSTR regStr;
    HKEY key;
    DWORD rc;
    DWORD index;
    TCHAR dllValue[MAX_PATH];
    TCHAR dllName[MAX_PATH];
    DWORD type;
    DWORD size1 = MAX_PATH, size2 = MAX_PATH;
    TCHAR systemDir[MAX_PATH];
    TCHAR dllPath[MAX_PATH];
    BOOL bCheck;

    if (!GetSystemDirectory (systemDir, MAX_PATH)) {
        return;
    }

#ifdef UNICODE
    regStr = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs";
#else
    regStr = "SYSTEM\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs";
#endif
    rc = RegOpenKey (HKEY_LOCAL_MACHINE, regStr, &key);
    if (rc == ERROR_SUCCESS) {
        index = 0;
        while (RegEnumValue (
                    key,
                    index++,
                    dllValue,
                    &size1,
                    NULL,
                    &type,
                    (LPBYTE)dllName,
                    &size2
                    ) == ERROR_SUCCESS) {
            if (type == REG_SZ) {
                bCheck = TRUE;
                if (RestrictedCheckList) {
                    PCTSTR fileName = RestrictedCheckList;
                    while (*fileName) {
                        if (!lstrcmpi (fileName, dllName)) {
                            break;
                        }
                        fileName = _tcschr (fileName, 0) + 1;
                    }
                    if (*fileName == 0) {
                        //
                        // we are not interested in this dll
                        //
                        bCheck = FALSE;
                    }
                }
                if (bCheck) {
                    BuildPath (dllPath, systemDir, dllName);
                    if (!FileExists (dllPath, NULL)) {
                        DebugLog (
                            Winnt32LogWarning,
                            TEXT("The file %1 doesn't exist, although it's registered as a Known Dll"),
                            0,
                            dllPath
                            );
                        //
                        // OK, we found a bogus reg entry; remove the value and remember the data
                        //
                        if (RegDeleteValue (key, dllValue) == ERROR_SUCCESS) {
                            InsertList (
                                (PGENERIC_LIST*)MissingKnownDlls,
                                (PGENERIC_LIST)CreateStringCell (dllValue)
                                );
                            InsertList (
                                (PGENERIC_LIST*)MissingKnownDlls,
                                (PGENERIC_LIST)CreateStringCell (dllName)
                                );
                        }
                    }
                }
            }
            size1 = size2 = MAX_PATH;
        }
        RegCloseKey (key);
    }
}


VOID
UndoFixMissingKnownDlls (
    IN      PSTRINGLIST MissingKnownDlls
    )
{
    PCTSTR regStr;
    HKEY key;
    DWORD rc;
    PSTRINGLIST p, q;

#ifdef UNICODE
    regStr = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs";
#else
    regStr = "SYSTEM\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs";
#endif
    rc = RegOpenKey (HKEY_LOCAL_MACHINE, regStr, &key);
    if (rc == ERROR_SUCCESS) {
        p = MissingKnownDlls;
        while (p) {
            q = p->Next;
            if (q) {
                RegSetValueEx (
                        key,
                        p->String,
                        0,
                        REG_SZ,
                        (const PBYTE)q->String,
                        (lstrlen (q->String) + 1) * sizeof (TCHAR)
                        );
                p = q->Next;
            } else {
                p = NULL;
            }
        }
        RegCloseKey (key);
    }
    DeleteStringList (MissingKnownDlls);
}

#ifndef UNICODE

/*++

Routine Description:

  IsPatternMatch compares a string against a pattern that may contain
  standard * or ? wildcards.

Arguments:

  wstrPattern  - A pattern possibly containing wildcards
  wstrStr      - The string to compare against the pattern

Return Value:

  TRUE when wstrStr and wstrPattern match when wildcards are expanded.
  FALSE if wstrStr does not match wstrPattern.

--*/

#define MBCHAR  INT

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    )
{

    MBCHAR chSrc, chPat;

    while (*strStr) {
        chSrc = _mbctolower ((MBCHAR) _mbsnextc (strStr));
        chPat = _mbctolower ((MBCHAR) _mbsnextc (strPattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (strStr)) == '*') {
                strStr = _mbsinc (strStr);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (strPattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchA (_mbsinc (strPattern), strStr)) {
                return TRUE;
            }

            // Allow any character and continue
            strStr = _mbsinc (strStr);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        strStr = _mbsinc (strStr);
        strPattern = _mbsinc (strPattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (strPattern) == '*') {
        strPattern = _mbsinc (strPattern);
    }
    if (_mbsnextc (strPattern)) {
        return FALSE;
    }

    return TRUE;
}

#endif

// Wierd logic here required to make builds work, as this is defined
// in another file that gets linked in on x86

#ifdef _WIN64

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    )

{
    WCHAR chSrc, chPat;

    while (*wstrStr) {
        chSrc = towlower (*wstrStr);
        chPat = towlower (*wstrPattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (wstrPattern[1] == L'*')
                wstrPattern++;

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (wstrPattern[1]);
            if (!chPat)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                wstrPattern++;
                if (IsPatternMatchW (wstrPattern, wstrStr))
                    return TRUE;

                // no, that didn't work, stick with star
                wstrPattern--;
            }

            //
            // Allow any character and continue
            //

            wstrStr++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        wstrPattern++;
        wstrStr++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *wstrPattern;
    if (chPat && (chPat != L'*' || wstrPattern[1]))
        return FALSE;

    return TRUE;
}


#endif

typedef BOOL (WINAPI * GETDISKFREESPACEEXA)(
  PCSTR lpDirectoryName,                  // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

typedef BOOL (WINAPI * GETDISKFREESPACEEXW)(
  PCWSTR lpDirectoryName,                  // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

BOOL
GetDiskFreeSpaceNewA(
    IN      PCSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    )
/*++

Routine Description:

  On Win9x GetDiskFreeSpace never return free/total space more than 2048MB.
  GetDiskFreeSpaceNew use GetDiskFreeSpaceEx to calculate real number of free/total clusters.
  Has same  declaration as GetDiskFreeSpaceA.

Arguments:

    DriveName - supplies directory name
    OutSectorsPerCluster - receive number of sectors per cluster
    OutBytesPerSector - receive number of bytes per sector
    OutNumberOfFreeClusters - receive number of free clusters
    OutTotalNumberOfClusters - receive number of total clusters

Return Value:

    TRUE if the function succeeds.
    If the function fails, the return value is FALSE. To get extended error information, call GetLastError

--*/
{
    ULARGE_INTEGER TotalNumberOfFreeBytes = {0, 0};
    ULARGE_INTEGER TotalNumberOfBytes = {0, 0};
    ULARGE_INTEGER DonotCare;
    HMODULE hKernel32;
    GETDISKFREESPACEEXA pGetDiskFreeSpaceExA;
    ULARGE_INTEGER NumberOfFreeClusters = {0, 0};
    ULARGE_INTEGER TotalNumberOfClusters = {0, 0};
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    if(!GetDiskFreeSpaceA(DriveName,
                          &SectorsPerCluster,
                          &BytesPerSector,
                          &NumberOfFreeClusters.LowPart,
                          &TotalNumberOfClusters.LowPart)){
        DebugLog (
            Winnt32LogError,
            TEXT("GetDiskFreeSpaceNewA: GetDiskFreeSpaceA failed on drive %1"),
            0,
            DriveName);
        return FALSE;
    }

    hKernel32 = LoadLibraryA("kernel32.dll");
    pGetDiskFreeSpaceExA = (GETDISKFREESPACEEXA)GetProcAddress(hKernel32, "GetDiskFreeSpaceExA");
    if(pGetDiskFreeSpaceExA &&
       pGetDiskFreeSpaceExA(DriveName, &DonotCare, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)){
        NumberOfFreeClusters.QuadPart = TotalNumberOfFreeBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
        TotalNumberOfClusters.QuadPart = TotalNumberOfBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
    }
    else{
        DebugLog (
            Winnt32LogWarning,
            pGetDiskFreeSpaceExA?
                    TEXT("GetDiskFreeSpaceNewA: GetDiskFreeSpaceExA is failed"):
                    TEXT("GetDiskFreeSpaceNewA: GetDiskFreeSpaceExA function is not in kernel32.dll"),
            0);
    }
    FreeLibrary(hKernel32);

    if(OutSectorsPerCluster){
        *OutSectorsPerCluster = SectorsPerCluster;
    }

    if(OutBytesPerSector){
        *OutBytesPerSector = BytesPerSector;
    }

    if(OutNumberOfFreeClusters){
        OutNumberOfFreeClusters->QuadPart = NumberOfFreeClusters.QuadPart;
    }

    if(OutTotalNumberOfClusters){
        OutTotalNumberOfClusters->QuadPart = TotalNumberOfClusters.QuadPart;
    }

    return TRUE;
}

BOOL
GetDiskFreeSpaceNewW(
    IN      PCWSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    )
/*++

Routine Description:

  Correct NumberOfFreeClusters and TotalNumberOfClusters out parameters
  with using GetDiskFreeSpace and GetDiskFreeSpaceEx

Arguments:

    DriveName - supplies directory name
    OutSectorsPerCluster - receive number of sectors per cluster
    OutBytesPerSector - receive number of bytes per sector
    OutNumberOfFreeClusters - receive number of free clusters
    OutTotalNumberOfClusters - receive number of total clusters

Return Value:

    TRUE if the function succeeds.
    If the function fails, the return value is FALSE. To get extended error information, call GetLastError

--*/
{
    ULARGE_INTEGER TotalNumberOfFreeBytes = {0, 0};
    ULARGE_INTEGER TotalNumberOfBytes = {0, 0};
    ULARGE_INTEGER DonotCare;
    HMODULE hKernel32;
    GETDISKFREESPACEEXW pGetDiskFreeSpaceExW;
    ULARGE_INTEGER NumberOfFreeClusters = {0, 0};
    ULARGE_INTEGER TotalNumberOfClusters = {0, 0};
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    if(!GetDiskFreeSpaceW(DriveName,
                          &SectorsPerCluster,
                          &BytesPerSector,
                          &NumberOfFreeClusters.LowPart,
                          &TotalNumberOfClusters.LowPart)){
        DebugLog (
            Winnt32LogError,
            TEXT("GetDiskFreeSpaceNewW: GetDiskFreeSpaceW failed on drive %1"),
            0,
            DriveName);
        return FALSE;
    }

    hKernel32 = LoadLibraryA("kernel32.dll");
    pGetDiskFreeSpaceExW = (GETDISKFREESPACEEXW)GetProcAddress(hKernel32, "GetDiskFreeSpaceExW");
    if(pGetDiskFreeSpaceExW &&
       pGetDiskFreeSpaceExW(DriveName, &DonotCare, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)){
        NumberOfFreeClusters.QuadPart = TotalNumberOfFreeBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
        TotalNumberOfClusters.QuadPart = TotalNumberOfBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
    }
    else{
        DebugLog (
            Winnt32LogWarning,
            pGetDiskFreeSpaceExW?
                    TEXT("GetDiskFreeSpaceNewW: GetDiskFreeSpaceExW is failed"):
                    TEXT("GetDiskFreeSpaceNewW: GetDiskFreeSpaceExW function is not in kernel32.dll"),
            0);
    }
    FreeLibrary(hKernel32);

    if(OutSectorsPerCluster){
        *OutSectorsPerCluster = SectorsPerCluster;
    }

    if(OutBytesPerSector){
        *OutBytesPerSector = BytesPerSector;
    }

    if(OutNumberOfFreeClusters){
        OutNumberOfFreeClusters->QuadPart = NumberOfFreeClusters.QuadPart;
    }

    if(OutTotalNumberOfClusters){
        OutTotalNumberOfClusters->QuadPart = TotalNumberOfClusters.QuadPart;
    }

    return TRUE;
}

BOOL
ReplaceSubStr(
    IN OUT LPTSTR SrcStr,
    IN LPTSTR SrcSubStr,
    IN LPTSTR DestSubStr
    )
/*++

Routine Description:

    Replaces the source substr with the destination substr in the source
    string.

    NOTE : SrcSubStr needs to be longer than or equal in length to
           DestSubStr.

Arguments:

    SrcStr : The source to operate upon. Also receives the new string.

    SrcSubStr : The source substring to search for and replace.

    DestSubStr : The substring to replace with for the occurences
        of SrcSubStr in SrcStr.

Return Value:

    TRUE if successful, otherwise FALSE.

--*/
{
    BOOL Result = FALSE;

    //
    // Validate the arguments
    //
    if (SrcStr && SrcSubStr && *SrcSubStr &&
        (!DestSubStr || (_tcslen(SrcSubStr) >= _tcslen(DestSubStr)))) {
        if (!DestSubStr || _tcsicmp(SrcSubStr, DestSubStr)) {
            ULONG SrcStrLen = _tcslen(SrcStr);
            ULONG SrcSubStrLen = _tcslen(SrcSubStr);
            ULONG DestSubStrLen = DestSubStr ? _tcslen(DestSubStr) : 0;
            LPTSTR DestStr = malloc((SrcStrLen + 1) * sizeof(TCHAR));

            if (DestStr) {
                LPTSTR CurrDestStr = DestStr;
                LPTSTR PrevSrcStr = SrcStr;
                LPTSTR CurrSrcStr = _tcsstr(SrcStr, SrcSubStr);

                while (CurrSrcStr) {
                    //
                    // Skip starting substr & copy previous unmatched pattern
                    //
                    if (PrevSrcStr != CurrSrcStr) {
                        _tcsncpy(CurrDestStr, PrevSrcStr, (CurrSrcStr - PrevSrcStr));
                        CurrDestStr += (CurrSrcStr - PrevSrcStr);
                        *CurrDestStr = TEXT('\0');
                    }

                    //
                    // Copy destination substr
                    //
                    if (DestSubStr) {
                        _tcscpy(CurrDestStr, DestSubStr);
                        CurrDestStr += DestSubStrLen;
                        *CurrDestStr = TEXT('\0');
                    }

                    //
                    // Look for next substr
                    //
                    CurrSrcStr += SrcSubStrLen;
                    PrevSrcStr = CurrSrcStr;
                    CurrSrcStr = _tcsstr(CurrSrcStr, SrcSubStr);
                }

                //
                // Copy remaining src string if any
                //
                if (!_tcsstr(PrevSrcStr, SrcSubStr)) {
                    _tcscpy(CurrDestStr, PrevSrcStr);
                }

                //
                // Copy the new string back to the src string
                //
                _tcscpy(SrcStr, DestStr);

                free(DestStr);
                Result = TRUE;
            }
        } else {
            Result = TRUE;
        }
    }

    return Result;
}

VOID
RemoveTrailingWack (
    PTSTR String
    )
{
    if (String) {
        PTSTR p = _tcsrchr (String, TEXT('\\'));
        if (p && p[1] == 0) {
            *p = 0;
        }
    }
}

ULONGLONG
SystemTimeToFileTime64 (
    IN      PSYSTEMTIME SystemTime
    )
{
    FILETIME ft;
    ULARGE_INTEGER result;

    SystemTimeToFileTime (SystemTime, &ft);
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;

    return result.QuadPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\util.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    util.h

Abstract:

    Interface for utility functions

Author:

    Ovidiu Temereanca (ovidiut) 08-Nov-2000

Revision History:

    <alias>  <date>      <comment>

--*/


typedef struct tagGENERIC_LIST {
    struct tagGENERIC_LIST* Next;
} GENERIC_LIST, *PGENERIC_LIST;

typedef struct tagSTRINGLIST {
    struct tagSTRINGLIST* Next;
    PTSTR String;
} STRINGLIST, *PSTRINGLIST;

typedef struct tagSDLIST {
    struct tagSDLIST* Next;
    PTSTR String;
    DWORD_PTR Data;
} SDLIST, *PSDLIST;


typedef struct {
    PTSTR FileName;
    TCHAR FullPath[MAX_PATH];
    WIN32_FIND_DATA FindData;
    //
    // private data
    //
    HANDLE Handle;
} FILEPATTERN_ENUM, *PFILEPATTERN_ENUM;


#define ENUM_FIRSTFILE  1
#define ENUM_NEXTFILE   2
#define ENUM_SUBDIRS    3
#define ENUM_SUBDIR     4

typedef struct tagFILEENUMLIST {
    struct tagFILEENUMLIST* Next;
    PTSTR Dir;
    DWORD EnumState;
    FILEPATTERN_ENUM Enum;
} FILEENUMLIST, *PFILEENUMLIST;

#define ECF_ENUM_SUBDIRS        0x0001
#define ECF_ABORT_ENUM_DIR      0x0002

typedef struct {
    PTSTR FileName;
    PTSTR SubPath;
    PTSTR FullPath;
    PWIN32_FIND_DATA FindData;
    DWORD ControlFlags;
    //
    // private data
    //
    PCTSTR FilePattern;
    DWORD RootLen;
    PFILEENUMLIST DirCurrent;
    HANDLE Handle;
} FILEPATTERNREC_ENUM, *PFILEPATTERNREC_ENUM;



PTSTR
BuildPath (
    IN      PTSTR DestPath,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    );

PTSTR
BuildPath2 (
    IN      PTSTR DestPath,
    IN      DWORD Chars,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    );

PTSTR
DupString (
    IN      PCTSTR String
    );

PTSTR
DupMultiSz (
    IN PCTSTR MultiSz
    );

PTSTR
CreatePrintableString (
    IN      PCTSTR MultiSz
    );

PWSTR
MultiSzAnsiToUnicode (
    IN      PCSTR MultiSzAnsi
    );

PSTR
UnicodeToAnsi (
    IN      PCWSTR Unicode
    );

BOOL
EnumFirstFilePattern (
    OUT     PFILEPATTERN_ENUM Enum,
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern
    );

BOOL
EnumNextFilePattern (
    IN OUT  PFILEPATTERN_ENUM Enum
    );

VOID
AbortEnumFilePattern (
    IN OUT  PFILEPATTERN_ENUM Enum
    );

BOOL
EnumFirstFilePatternRecursive (
    OUT     PFILEPATTERNREC_ENUM Enum,
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern,
    IN      DWORD ControlFlags
    );

BOOL
EnumNextFilePatternRecursive (
    IN OUT  PFILEPATTERNREC_ENUM Enum
    );

VOID
AbortEnumFilePatternRecursive (
    IN OUT  PFILEPATTERNREC_ENUM Enum
    );

BOOL
CreateDir (
    IN      PCTSTR DirName
    );

PSTRINGLIST
CreateStringCell (
    IN      PCTSTR String
    );

VOID
DeleteStringCell (
    IN      PSTRINGLIST Cell
    );

BOOL
FindStringCell (
    IN      PSTRINGLIST StringList,
    IN      PCTSTR String,
    IN      BOOL CaseSensitive
    );

VOID
DeleteStringList (
    IN      PSTRINGLIST List
    );

PFILEENUMLIST
CreateFileEnumCell (
    IN      PCTSTR Dir,
    IN      PCTSTR FilePattern,
    IN      DWORD Attributes,
    IN      DWORD EnumState
    );

VOID
DeleteFileEnumCell (
    IN      PFILEENUMLIST Cell
    );

BOOL
InsertList (
    IN OUT  PGENERIC_LIST* List,
    IN      PGENERIC_LIST NewList
    );

VOID
DeleteFileEnumList (
    IN      PFILEENUMLIST NewList
    );

PCTSTR
FindSubString (
    IN      PCTSTR String,
    IN      TCHAR Separator,
    IN      PCTSTR SubStr,
    IN      BOOL CaseSensitive
    );

VOID
GetCurrentWinnt32RegKey (
    OUT     PTSTR Key,
    IN      DWORD Chars
    );

BOOL
IsFileVersionLesser (
    IN      PCTSTR FileToCompare,
    IN      PCTSTR FileToCompareWith
    );

BOOL
CopyTree (
    IN      PCTSTR SourceRoot,
    IN      PCTSTR DestRoot
    );

BOOL
StringToInt (
    IN  PCTSTR      Field,
    OUT PINT        IntegerValue
    );

BOOL
CheckForFileVersionEx (
    LPCTSTR FileName,
    LPCTSTR FileVer,                OPTIONAL
    LPCTSTR BinProductVer,          OPTIONAL
    LPCTSTR LinkDate                OPTIONAL
    );

BOOL
GetLinkDate (
    IN      PCTSTR FilePath,
    OUT     PDWORD LinkDate
    );

VOID
FixMissingKnownDlls (
    OUT     PSTRINGLIST* MissingKnownDlls,
    IN      PCTSTR RestrictedCheckList      OPTIONAL
    );

VOID
UndoFixMissingKnownDlls (
    IN      PSTRINGLIST MissingKnownDlls
    );

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    );

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    );

#ifdef UNICODE
#define IsPatternMatch(pattern,string)  IsPatternMatchW(pattern,string)
#else
#define IsPatternMatch(pattern,string)  IsPatternMatchA(pattern,string)
#endif


BOOL 
GetDiskFreeSpaceNewA(
    IN      PCSTR  DriveName, 
    OUT     DWORD * OutSectorsPerCluster, 
    OUT     DWORD * OutBytesPerSector, 
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters, 
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    );

BOOL 
GetDiskFreeSpaceNewW(
    IN      PCWSTR  DriveName, 
    OUT     DWORD * OutSectorsPerCluster, 
    OUT     DWORD * OutBytesPerSector, 
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters, 
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    );

BOOL
ReplaceSubStr(
    IN OUT LPTSTR SrcStr,
    IN LPTSTR SrcSubStr,
    IN LPTSTR DestSubStr
    );

#ifdef UNICODE

#define GetDiskFreeSpaceNew GetDiskFreeSpaceNewW

#else

#define GetDiskFreeSpaceNew GetDiskFreeSpaceNewA

#endif

VOID
RemoveTrailingWack (
    PTSTR String
    );

ULONGLONG
SystemTimeToFileTime64 (
    IN      PSYSTEMTIME SystemTime
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\web.cpp ===
#include <windows.h>
#include <ole2.h>
#include <exdisp.h>
#include <htiframe.h>

#define INITGUID

#include <initguid.h>
#include <shlguid.h>
#include <mshtml.h>
#include <comdef.h>


const VARIANT c_vaEmpty = {0};
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)



extern "C"
BOOL
IsIE3Installed(
    VOID
)
{
HRESULT         hr;
IWebBrowserApp  *pwb;

    hr = CoCreateInstance( CLSID_InternetExplorer,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IWebBrowserApp,
                           (void **)&pwb );
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


extern "C"
BOOL
IsIE4Installed(
    VOID
)
{
HRESULT         hr;
IWebBrowserApp  *pwb;

    hr = CoCreateInstance( CLSID_InternetExplorer,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IWebBrowser2,
                           (void **)&pwb );

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


extern "C"
BOOL
LaunchIE3Instance(
    LPWSTR szResourceURL
    )
{
    HRESULT hr;
    int dx, dy;
    IWebBrowserApp *pwb;


    hr = CoCreateInstance(
        CLSID_InternetExplorer,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWebBrowserApp,
        (void **)&pwb
        );

    if (SUCCEEDED(hr)) {

        // turn off chrome
        hr = pwb->put_MenuBar(FALSE);
        hr = pwb->put_StatusBar(FALSE);
//        hr = pwb->put_ToolBar(FALSE);

        // set client area size
        int iWidth = 466L;
        int iHeight = 286L;

        pwb->ClientToWindow(&iWidth, &iHeight);

        if (iWidth > 0)
            pwb->put_Width(iWidth);

        if (iHeight > 0)
            pwb->put_Height(iHeight);

        if ((dx = ((GetSystemMetrics(SM_CXSCREEN) - iWidth) / 2)) > 0)     // center the on screen window
            pwb->put_Left(dx);

        if ((dy = ((GetSystemMetrics(SM_CYSCREEN) - iHeight) / 2)) > 0)
            pwb->put_Top(dy);

        pwb->put_Visible(TRUE);

        hr = pwb->Navigate(szResourceURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);

        pwb->Release();

        return(TRUE);
    }

    return(FALSE);
}


extern "C"
BOOL
LaunchIE4Instance(
    LPWSTR szResourceURL
    )
{
    HRESULT hr;
    HWND    hwndIE;
    int dx, dy;
    IWebBrowser2 *pwb;


    hr = CoCreateInstance(
        CLSID_InternetExplorer,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWebBrowser2,
        (void **)&pwb
        );

    if (SUCCEEDED(hr)) {
        DWORD dwFlags;
        ITargetFrame2* ptgf;

        //
        //  this marks this window as a third party window,
        //  so that the window is not reused.
        //
        pwb->put_RegisterAsBrowser(VARIANT_TRUE);

        IHTMLWindow2 *phw;
        IServiceProvider *psp;

        if (SUCCEEDED(pwb->QueryInterface(IID_IServiceProvider, (void**) &psp)) && psp) {
            if (SUCCEEDED(psp->QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void**)&phw))) {
                VARIANT var;
                var.vt = VT_BOOL;
                var.boolVal = 666;
                phw->put_opener(var);
                phw->Release();
            } else
                MessageBox(NULL, TEXT("QueryInterface of IID_IHTMLWindow2 FAILED!!!!!"), NULL, MB_ICONERROR);
            psp->Release();
        }

        // turn off chrome
        pwb->put_MenuBar(FALSE);
        pwb->put_StatusBar(FALSE);
//        pwb->put_ToolBar(FALSE);
        pwb->put_AddressBar(FALSE);
//      pwb->put_Resizable(FALSE);


        // set client area size
        int iWidth = 466L;
        int iHeight = 286L;

        pwb->ClientToWindow(&iWidth, &iHeight);

        if (iWidth > 0)
            pwb->put_Width(iWidth);

        if (iHeight > 0)
            pwb->put_Height(iHeight);

        if ((dx = ((GetSystemMetrics(SM_CXSCREEN) - iWidth) / 2)) > 0)     // center the on screen window
            pwb->put_Left(dx);

        if ((dy = ((GetSystemMetrics(SM_CYSCREEN) - iHeight) / 2)) > 0)
            pwb->put_Top(dy);

        pwb->put_Visible(TRUE);

        pwb->get_HWND((LONG_PTR*)&hwndIE);
        SetForegroundWindow(hwndIE);

        hr = pwb->Navigate(szResourceURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);

        pwb->Release();

        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\wizard.c ===
#include "precomp.h"
#pragma hdrstop

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))
#endif


typedef struct
{
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    WORD    cDlgItems;
    WORD    x;
    WORD    y;
    WORD    cx;
    WORD    cy;
}   DLGTEMPLATEEX, FAR *LPDLGTEMPLATEEX;

//
// We'll use this to disable passing through dialog boxes because we're
// unattended.
//
BOOL CancelPending = FALSE;

//
// This indicates that well give the user some detailed data-throughput
// info.
//
BOOL DetailedCopyProgress = FALSE;

//
// This indicates that one may only upgade (I.E. CCP media)
//
BOOL UpgradeOnly = FALSE;

//
// Points to thread that does the machine inspection.
//
HANDLE InspectionThreadHandle;

#ifdef _X86_
//
// Win9x upgrade report status
//

UINT g_UpgradeReportMode;
#endif

//
// Stuff used for watermarking
//
WNDPROC OldWizardProc;
UINT WatermarkHeaderHeight;
BITMAP_DATA Watermark;
BITMAP_DATA Header;
BITMAP_DATA Header2;
HWND WizardHandle;
HWND BackgroundWnd = NULL;

HWND GetBBhwnd();
BOOL StartStopBB(BOOL bStart);
void BB_SetProgressText(LPTSTR szText);
void BB_SetInfoText(LPTSTR szText);
LRESULT BB_ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam);
BOOL BB_ShowProgressGaugeWnd(UINT nCmdShow);
void SetBBStep(int iStep);

typedef enum {
    Phase_Unknown = -1,
    Phase_DynamicUpdate = 0,
    Phase_HwCompatDat,
    Phase_UpgradeReport,
    Phase_FileCopy,
    Phase_Reboot,
    Phase_RestOfSetup
} SetupPhases;

typedef struct _SETUPPHASE {
    DWORD   Time;
    BOOL    Clean;
    DWORD   OS;
} SETUPPHASE;

#define ALLOS (VER_PLATFORM_WIN32_WINDOWS | VER_PLATFORM_WIN32_NT)

#define TIME_DYNAMICUPDATE  300
#define TIME_HWCOMPDAT      120
#define TIME_UPGRADEREPORT  600
#define TIME_REBOOT         15
// 13 minnutes for text mode, 37 minutes for GUI mode.
#define TIME_RESTOFSETUP    (13+37)*60

SETUPPHASE SetupPhase[] = {
    { 0,                  TRUE, ALLOS },                         // DynamicUpdate
    { TIME_HWCOMPDAT,     FALSE, VER_PLATFORM_WIN32_WINDOWS }, // HwCompatDat
    { TIME_UPGRADEREPORT, FALSE, VER_PLATFORM_WIN32_WINDOWS }, // UpgradeReport
    {   0,                TRUE,  ALLOS },                      // FileCopy
    { TIME_REBOOT,        TRUE, ALLOS },                       // Reboot
    { TIME_RESTOFSETUP,   TRUE, ALLOS }                       // RestOfSetup
};

void SetTimeEstimates();
DWORD CalcTimeRemaining(UINT Phase);
void UpdateTimeString(DWORD RemainungTimeMsecInThisPhase,
                      DWORD *PreviousRemainingTime);
void SetRemainingTime(DWORD TimeInSeconds);
DWORD GetFileCopyEstimate();
DWORD GetHwCompDatEstimate();
DWORD GetUpgradeReportEstimate();
DWORD GetDynamicUpdateEstimate();
DWORD GetRestOfSetupEstimate();

UINT CurrentPhase = Phase_Unknown;
ULONG RemainingTime = 0;
//
// Enum for SetDialogFont().
//
typedef enum {
    DlgFontTitle,
    DlgFontSupertitle,
    DlgFontSubtitle,
    DlgFontStart
} MyDlgFont;

INT_PTR SetNextPhaseWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
INT_PTR
TimeEstimateWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
WizardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
WelcomeWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
EulaWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
SelectPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
OemPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CdPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#ifdef _X86_
INT_PTR
Win9xUpgradeReportPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
#endif

INT_PTR
DynSetupWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DynSetup2WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DynSetup3WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DynSetup4WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DynSetup5WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
RestartWizPage (
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
ServerWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CompatibilityWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
NTFSConvertWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
OptionsWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
Working1WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#ifdef _X86_
INT_PTR
FloppyWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
#endif

INT_PTR
CopyingWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DoneWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CleaningWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
NotDoneWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
AdjustWatermarkBitmap(
    IN HANDLE hdlg,
    IN HDC    hdc,
    IN OUT PBITMAP_DATA  BitmapData,
    IN BOOL FullPage
    );

//
// Page descriptors. Put this after function declarations so the initializers
// work properly and the compiler doesn't complain.
//
PAGE_CREATE_DATA ProtoPages[] = {

    {
        NULL,NULL,
        IDD_WELCOME,
        {
            WelcomeWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT,
            WIZPAGE_FULL_PAGE_WATERMARK | WIZPAGE_SEPARATOR_CREATED
        }
    },
    {
        NULL,NULL,
        IDD_EULA,
        {
            EulaWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_PID_CD,
        {
            CdPid30WizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_PID_OEM,
        {
            OemPid30WizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_PID_SELECT,
        {
            SelectPid30WizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_OPTIONS,
        {
            OptionsWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },

    {
        NULL,NULL,
        IDD_NTFS_CONVERT,
        {
            NTFSConvertWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },

    {
        NULL,NULL,
        IDD_SRVCOMP,
        {
            ServerWizPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },

#ifdef _X86_
    {
        NULL,NULL,
        IDD_REPORT_HELP,
        {
            Win9xUpgradeReportPage,
            BBSTEP_COLLECTING_INFORMATION,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
#endif

    {
        NULL,NULL,
        IDD_DYNAMICSETUP,
        {
            DynSetupWizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT | PSWIZB_BACK
        }
    },
    {
        NULL,NULL,
        IDD_DYNAMICSETUP2,
        {
            DynSetup2WizPage,
            BBSTEP_DYNAMIC_UPDATE
        }
    },
    {
        NULL,NULL,
        IDD_RESTART,
        {
            RestartWizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT
        }
    },
    {
        NULL,NULL,
        IDD_DYNAMICSETUP3,
        {
            DynSetup3WizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT
        }
    },
    {
        NULL,NULL,
        IDD_DYNAMICSETUP4,
        {
            DynSetup4WizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT
        }
    },
    {
        NULL,NULL,
        IDD_DYNAMICSETUP5,
        {
            DynSetup5WizPage,
            BBSTEP_DYNAMIC_UPDATE,
            PSWIZB_NEXT
        }
    },
    {
        NULL,NULL,
        IDD_EMPTY,
        {
            TimeEstimateWizPage,
            BBSTEP_PREPARING,
            0
        }
    },
    {
        NULL,NULL,
        IDD_EMPTY,
        {
            SetNextPhaseWizPage,
            BBSTEP_PREPARING,
            0
        }
    },
    {
        &UpgradeSupport.Pages1,
        &UpgradeSupport.AfterWelcomePageCount
    },

    {
        &UpgradeSupport.Pages2,
        &UpgradeSupport.AfterOptionsPageCount
    },

    {
        NULL,NULL,
        IDD_WORKING1,
        {
            Working1WizPage,
            BBSTEP_PREPARING
        }
    },


    {
        NULL,NULL,
        IDD_COMPATIBILITY,
        {
            CompatibilityWizPage,
            BBSTEP_PREPARING,
            PSWIZB_NEXT
        }
    },

    {
        &UpgradeSupport.Pages3,
        &UpgradeSupport.BeforeCopyPageCount
    },

#ifdef _X86_
    {
        NULL,NULL,
        IDD_FLOPPY,
        {
            FloppyWizPage,
            BBSTEP_PREPARING
        }
    },
#endif

    {
        NULL,NULL,
        IDD_COPYING,
        {
            CopyingWizPage,
            BBSTEP_PREPARING
        }
    },

    {
        NULL,NULL,
        IDD_DONE,
        {
            DoneWizPage,
            BBSTEP_PREPARING,
            PSWIZB_FINISH,
            WIZPAGE_FULL_PAGE_WATERMARK | WIZPAGE_SEPARATOR_CREATED
        }
    },

    {
        NULL,NULL,
        IDD_CLEANING,
        {
            CleaningWizPage,
            BBSTEP_NONE
        }
    },

    {
        NULL,NULL,
        IDD_NOTDONE,
        {
            NotDoneWizPage,
            BBSTEP_NONE,
            PSWIZB_FINISH,
            WIZPAGE_FULL_PAGE_WATERMARK | WIZPAGE_SEPARATOR_CREATED
        }
    }
};


//
// LTR/RTL layout
//

typedef DWORD(WINAPI * PSETLAYOUT)(HDC, DWORD);
#define _LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008

PSETLAYOUT g_SetLayout;
DWORD g_OldLayout;



VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    )
{
    static HFONT BigBoldFont = NULL;
    static HFONT BoldFont = NULL;
    static HFONT StartFont = NULL;
    HFONT Font;
    LOGFONT LogFont;
    TCHAR FontSizeString[24];
    int FontSize;
    HDC hdc;

    switch(WhichFont) {

    case DlgFontStart:
        if (!StartFont)
        {
            if(Font = (HFONT)SendDlgItemMessage(hdlg,ControlId,WM_GETFONT,0,0))
            {
                if(GetObject(Font,sizeof(LOGFONT),&LogFont))
                {
                    if(hdc = GetDC(hdlg))
                    {

                        LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * 10 / 72);

                        StartFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = StartFont;
        break;

    case DlgFontTitle:

        if(!BigBoldFont) {

            if(Font = (HFONT)SendDlgItemMessage(hdlg,ControlId,WM_GETFONT,0,0)) {

                if(GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                    //
                    // Now we're using the Arial Black font, so we don't need
                    // to make it bold.
                    //
                    // LogFont.lfWeight = FW_BOLD;

                    //
                    // Load size and name from resources, since these may change
                    // from locale to locale based on the size of the system font, etc.
                    //
                    if(!LoadString(hInst,IDS_LARGEFONTNAME,LogFont.lfFaceName,LF_FACESIZE)) {
                        lstrcpy(LogFont.lfFaceName,TEXT("MS Serif"));
                    }

                    if(LoadString(hInst,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) {
                        FontSize = _tcstoul(FontSizeString,NULL,10);
                    } else {
                        FontSize = 18;
                    }

                    if(hdc = GetDC(hdlg)) {

                        LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                        BigBoldFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BigBoldFont;
        break;

    case DlgFontSupertitle:

        if(!BoldFont) {

            if(Font = (HFONT)SendDlgItemMessage(hdlg,ControlId,WM_GETFONT,0,0)) {

                if(GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                    LogFont.lfWeight = FW_BOLD;

                    if(hdc = GetDC(hdlg)) {
                        BoldFont = CreateFontIndirect(&LogFont);
                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BoldFont;
        break;

    case DlgFontSubtitle:
    default:
        //
        // Nothing to do here.
        //
        Font = NULL;
        break;
    }

    if(Font) {
        SendDlgItemMessage(hdlg,ControlId,WM_SETFONT,(WPARAM)Font,0);
    }
}

VOID
pMoveButtons(
    HWND WizardHandle,
    UINT Id,
    LONG cx,
    LONG cy
    )

/*++

Routine Description:

  pMoveButtons moves a window by a delta, to reposition a control when the
  wizard changes size.

Arguments:

  WizardHandle - Specifies the main wizard window
  Id           - Specifies the child control ID that exists in the main
                 wizard window
  cx           - Specifies the horizontal delta
  cy           - Specifies the vertical delta

Return Value:

  None.

--*/

{
    HWND Button;
    RECT Rect;

    Button = GetDlgItem(WizardHandle,Id);

    if( !Button )
        return;

    GetClientRect( Button, &Rect );
    MapWindowPoints(Button, WizardHandle, (LPPOINT)&Rect,2);

    Rect.left += cx;
    Rect.top += cy;

    SetWindowPos( Button, NULL, Rect.left, Rect.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW );

    return;

}


BOOL
CALLBACK
pVerifyChildText (
    HWND WizardPage,
    HWND HiddenPage,
    INT Id
    )
{
    TCHAR text1[512];
    TCHAR text2[512];
    HWND hwnd1;
    HWND hwnd2;

    hwnd1 = GetDlgItem (WizardPage, Id);
    hwnd2 = GetDlgItem (HiddenPage, Id);

    if (!hwnd1 && !hwnd2) {
        return TRUE;
    }

    if (!hwnd1 || !hwnd2) {
        return FALSE;
    }

    text1[0] = 0;
    GetWindowText (hwnd1, text1, ARRAYSIZE(text1));

    text2[0] = 0;
    GetWindowText (hwnd2, text2, ARRAYSIZE(text2));

    if (lstrcmp (text1, text2)) {
        return FALSE;
    }

    return TRUE;
}

INT_PTR
CALLBACK
HiddenDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HWND wizardPage;
    HRSRC dlgResInfo;
    HGLOBAL dlgRes;
    PVOID dlgTemplate;
    INT_PTR result = 0;
    static BOOL recursiveCall;

    switch (uMsg) {

    case WM_INITDIALOG:
        //
        // Verify text in this dialog is the same as the parent. If it is not
        // the same, then the code pages differ because of an OS bug,
        // and we have to force the English page dimensions.
        //

        wizardPage = *((HWND *) lParam);

        if (!recursiveCall) {

            if (!pVerifyChildText (wizardPage, hwndDlg, IDT_SUPERTITLE) ||
                !pVerifyChildText (wizardPage, hwndDlg, IDT_SUBTITLE) ||
                !pVerifyChildText (wizardPage, hwndDlg, IDT_TITLE)
                ) {

                //
                // Load the English resource if possible, then recursively call
                // ourselves to get the correct rect
                //

                __try {
                    //
                    // Find the resource
                    //

                    dlgResInfo = FindResourceEx (
                                    hInst,
                                    RT_DIALOG,
                                    MAKEINTRESOURCE(IDD_WELCOME),
                                    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)
                                    );

                    if (!dlgResInfo) {
                        __leave;
                    }

                    dlgRes = LoadResource (hInst, dlgResInfo);

                    if (!dlgRes) {
                        __leave;
                    }

                    dlgTemplate = LockResource (dlgRes);
                    if (!dlgTemplate) {
                        __leave;
                    }

                    //
                    // Create another hidden dialog (indirectly)
                    //

                    recursiveCall = TRUE;

                    result = DialogBoxIndirectParam (
                                hInst,
                                (LPCDLGTEMPLATE) dlgTemplate,
                                GetParent (hwndDlg),
                                HiddenDlgProc,
                                lParam
                                );

                    recursiveCall = FALSE;
                }
                __finally {
                    MYASSERT (result);
                }

                EndDialog (hwndDlg, result);
                break;
            }
        }

        //
        // If we get here it is because we need to use this dialog's size
        //

        GetClientRect (hwndDlg, (RECT *) lParam);
        EndDialog (hwndDlg, 1);
        break;

    }

    return 0;
}

VOID
pGetTrueClientRect(
    HWND hdlg,
    PRECT rc
    )

/*++

Routine Description:

  pGetTrueClientRect creates a hidden dialog box to retreive the proper
  dimensions of a dialog template. These dimensions are used to drive wizard
  resizing for when the system Wizard font does not match the property sheet
  font.

Arguments:

  hdlg - Specifies the wizard page

  rc - Receives the wizard page rectangle coordinates (window coordinates)

Return Value:

  None.

--*/

{

    HWND WizardHandle;
    static RECT pageRect;
    static BOOL initialized;

    if (initialized) {
        CopyMemory (rc, &pageRect, sizeof (RECT));
        return;
    }

    //
    // Initialize by creating a hidden window
    //

    WizardHandle = GetParent(hdlg);

    // send the wizard page handle to the HiddenDlgProc
    MYASSERT (sizeof (HWND *) <= sizeof (RECT));
    *((HWND *) rc) = hdlg;

    if (!DialogBoxParam (
            hInst,
            MAKEINTRESOURCE(IDD_WELCOME),
            WizardHandle,
            HiddenDlgProc,
            (LPARAM) rc
            )){

        //
        // On failure, do not alter the size of the page -- use current
        // rectangle for resizing
        //

        GetClientRect( hdlg, rc );
    }

    CopyMemory (&pageRect, rc, sizeof (RECT));
    initialized = TRUE;

    return;

}


VOID
ResizeWindowForFont(
    HWND hdlg
    )

/*++

Routine Description:

  ResizeWindowForFont takes a wizard page and makes sure that the page and
  its parent is sized properly.

Arguments:

  hdlg - Specifies the wizard page (a window within the main wizard)

Return Value:

  None.

--*/

{

    RECT WizardRect;
    RECT PageRect;
    RECT NewWizardRect;
    RECT NewWizardClientRect;
    RECT WizardClientRect;
    RECT BorderRect;
    RECT NewPageRect;
    RECT Sep;
    HWND Seperator, WizardHandle;
    LONG MarginX, MarginY, ButtonSpace, LineThickness;
    LONG x, y, cx, cy;
    static BOOL ParentResized = FALSE;

    WizardHandle = GetParent (hdlg);

    Seperator = GetDlgItem(WizardHandle,0x3026);
    if(!Seperator) {
        return;
    }

    //
    // Save original page dimensions, compute new page width/height
    //

    GetWindowRect (hdlg, &PageRect);
    pGetTrueClientRect (hdlg, &NewPageRect);

    //
    // Move page
    //

    SetWindowPos (
        hdlg,
        NULL,
        0,
        0,
        NewPageRect.right,
        NewPageRect.bottom,
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW
        );

    //
    // Has the parent already been resized? If so, we're done.
    //

    if (ParentResized) {
        return;
    }

    //
    // Is this wizard hidden? It might be width or height of zero.
    // Delay parent resizing until the next page.
    //

    GetWindowRect (WizardHandle, &WizardRect);
    if (((WizardRect.right - WizardRect.left) < 1) ||
        ((WizardRect.bottom - WizardRect.top) < 1)
        ) {
        return;
    }

    ParentResized = TRUE;

    //
    // Adjust width/height into coordinates. Resize the main wizard if we haven't done so yet.
    //

    MapWindowPoints (hdlg, NULL, (LPPOINT)&NewPageRect, 2);

    //
    // Get window rects (in window coordinates) of:
    //
    //  - the whole wizard
    //  - the wizard's client area
    //  - the page rectangle
    //  - the separator bar rectangle

    GetWindowRect (WizardHandle, &WizardRect);
    GetClientRect (WizardHandle, &WizardClientRect);
    MapWindowPoints (WizardHandle, NULL, (LPPOINT)&WizardClientRect, 2);
    GetWindowRect (Seperator, &Sep);

    //
    // Calculate various margins, thickness and borders
    //

    MarginX = WizardClientRect.right - PageRect.right;
    MarginY = Sep.top - PageRect.bottom;

    ButtonSpace = WizardClientRect.bottom - Sep.bottom;
    LineThickness = Sep.bottom - Sep.top;
    BorderRect.right = (WizardRect.right - WizardClientRect.right);
    BorderRect.bottom = (WizardRect.bottom - WizardClientRect.bottom);
    BorderRect.left = (WizardClientRect.left - WizardRect.left);
    BorderRect.top = (WizardClientRect.top - WizardRect.top);

    //
    // Find the new bottom right corner
    //

    x = (NewPageRect.right + MarginX + BorderRect.right);
    y = (NewPageRect.bottom + MarginY + ButtonSpace + LineThickness + BorderRect.bottom);

    //
    // Compute the new window coordinates
    //

    NewWizardRect.top = WizardRect.top;
    NewWizardRect.left =  WizardRect.left;
    NewWizardRect.right = x;
    NewWizardRect.bottom = y;

    //
    // Manually calculate client coordinates
    //

    NewWizardClientRect.left = NewWizardRect.left + BorderRect.left;
    NewWizardClientRect.right = NewWizardRect.right - BorderRect.right;
    NewWizardClientRect.top = NewWizardRect.top + BorderRect.top;
    NewWizardClientRect.bottom = NewWizardRect.bottom - BorderRect.bottom;

    //
    // Calculate new seperator position
    //

    x = Sep.left - WizardClientRect.left;
    y = NewWizardClientRect.bottom - NewWizardClientRect.top;
    y -= ButtonSpace - LineThickness;
    cx = (NewWizardClientRect.right - NewWizardClientRect.left);
    cx -= 2*(Sep.left - WizardClientRect.left);
    cy = Sep.bottom-Sep.top;

    //
    // Move/resize the seperator
    //

    SetWindowPos( Seperator, NULL, x, y, cx, cy, SWP_NOZORDER | SWP_NOREDRAW );

    //
    // Compute the new button coordinates
    //

    cx = NewWizardRect.right - WizardRect.right;
    cy = NewWizardRect.bottom - WizardRect.bottom;

    pMoveButtons( WizardHandle, 0x3023, cx, cy );
    pMoveButtons( WizardHandle, 0x3024, cx, cy );
    pMoveButtons( WizardHandle, 0x3025, cx, cy );
    pMoveButtons( WizardHandle, IDCANCEL, cx, cy );
    pMoveButtons( WizardHandle, IDHELP, cx, cy );

    //
    // Resize the wizard window
    //

    cx = (NewWizardRect.right - NewWizardRect.left);
    cy = (NewWizardRect.bottom-NewWizardRect.top);

    SetWindowPos( WizardHandle, NULL, 0, 0, cx, cy, SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);


    return;

}

VOID
CenterWindowRelativeToWindow(
    HWND hwndtocenter,
    HWND hwndcenteron
    )

/*++

Routine Description:

    Centers a dialog on the desktop.

Arguments:

    hwnd - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,
          y,
          w,
          h;
    POINT point;
    HWND Parent;
    UINT uiHeight = 0;

    GetWindowRect(GetDesktopWindow(), &rcWindow);
    uiHeight = rcWindow.bottom - rcWindow.top;

    if (hwndcenteron == NULL)
        Parent = GetDesktopWindow();
    else
        Parent = hwndcenteron;

    point.x = point.y = 0;
    ClientToScreen(Parent,&point);
    GetWindowRect(hwndtocenter,&rcWindow);
    GetClientRect(Parent,&rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    if (uiHeight > 480)
        x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    else
    {
        RECT rcParentWindow;

        GetWindowRect(Parent, &rcParentWindow);
        x = point.x + rcParentWindow.right - rcParentWindow.left + 1 - w;
    }
    MoveWindow(hwndtocenter,x,y,w,h,FALSE);
}


int
CALLBACK
Winnt32SheetCallback(
    IN HWND   DialogHandle,
    IN UINT   Message,
    IN LPARAM lParam
    )
{
    HMENU menu;
    DLGTEMPLATE *DlgTemplate;
    LPDLGTEMPLATEEX pDlgTemplateEx;

    switch(Message) {

    case PSCB_PRECREATE:
        //
        // Make sure we get into the foreground.
        //
        DlgTemplate = (DLGTEMPLATE *)lParam;
        pDlgTemplateEx = (LPDLGTEMPLATEEX)DlgTemplate;
        if (pDlgTemplateEx->wSignature == 0xFFFF) {
            pDlgTemplateEx->dwStyle &= ~DS_CONTEXTHELP;
            pDlgTemplateEx->dwStyle |= DS_SETFOREGROUND;

        } else {

            DlgTemplate->style &= ~DS_CONTEXTHELP;
            DlgTemplate->style |= DS_SETFOREGROUND;
        }


        break;



    case PSCB_INITIALIZED:
        //
        // Load the watermark bitmap and override the dialog procedure for the wizard.
        //

        GetBitmapDataAndPalette(
            hInst,
            MAKEINTRESOURCE(IDB_WELCOME),
            &Watermark.Palette,
            &Watermark.PaletteColorCount,
            &Watermark.BitmapInfoHeader
            );

        Watermark.BitmapBits = (LPBYTE)Watermark.BitmapInfoHeader
                            + Watermark.BitmapInfoHeader->biSize + (Watermark.PaletteColorCount * sizeof(RGBQUAD));
        Watermark.Adjusted = FALSE;

        GetBitmapDataAndPalette(
            hInst,
            MAKEINTRESOURCE(IDB_HEADER),
            &Header.Palette,
            &Header.PaletteColorCount,
            &Header.BitmapInfoHeader
            );

        Header.BitmapBits = (LPBYTE)Header.BitmapInfoHeader
                            + Header.BitmapInfoHeader->biSize + (Header.PaletteColorCount * sizeof(RGBQUAD));
        Header.Adjusted = FALSE;

        GetBitmapDataAndPalette(
            hInst,
            MAKEINTRESOURCE(IDB_HEADER2),
            &Header2.Palette,
            &Header2.PaletteColorCount,
            &Header2.BitmapInfoHeader
            );

        Header2.BitmapBits = (LPBYTE)Header2.BitmapInfoHeader
                            + Header2.BitmapInfoHeader->biSize + (Header2.PaletteColorCount * sizeof(RGBQUAD));
        Header2.Adjusted = FALSE;

        // innitialize WHH so we know that it is invalid, and will not draw the separator
        // until WHH is non-zero
        WatermarkHeaderHeight = 0;

        //
        // Get rid of close item on system menu.
        // Also need to process WM_SYSCOMMAND to eliminate use
        // of Alt+F4.
        //
        if(menu = GetSystemMenu(DialogHandle,FALSE)) {
            EnableMenuItem(menu,SC_CLOSE,MF_BYCOMMAND|MF_GRAYED);
        }

        OldWizardProc = (WNDPROC)SetWindowLongPtr(DialogHandle,DWLP_DLGPROC,(LONG_PTR)WizardDlgProc);
        break;
    }

    return(0);
}


VOID
pSetDisplayOrientation (
    IN      HDC hdc
    )

/*++

Routine Description:

  pSetDisplayOrientation sets the OS to treat BitBlts in left-to-right and
  top-to-bottom and no bitmap flip orientation. We expect our bitmaps to be
  localized to the proper orientation.

  This function loads the SetLayout API dynamically, so that winnt32 can run
  on very old OSes (such as Win95 gold). The resources are not cleaned up,
  because the LoadLibrary is to gdi32.dll, which is held until the process
  dies anyhow.

Arguments:

  hdc - Specifies the device context that will be used for the BitBlt (or
        equivalent) operation.

Return Value:

  None.

Remarks:

  The current orientation is saved to g_OldLayout, so don't call this function
  again until pRestoreDisplayOrientation is called.

--*/

{
    DWORD flags;
    HINSTANCE lib;
    static BOOL initialized;

    if (!initialized) {
        lib = LoadLibrary (TEXT("gdi32.dll"));
        MYASSERT (lib);

        if (lib) {
            (FARPROC) g_SetLayout = GetProcAddress (lib, "SetLayout");
        }

        initialized = TRUE;
    }

    if (g_SetLayout) {
        g_OldLayout = g_SetLayout (hdc, _LAYOUT_BITMAPORIENTATIONPRESERVED);
    }
}


VOID
pRestoreDisplayOrientation (
    IN      HDC hdc
    )

/*++

Routine Description:

  pRestoreDisplayOrientation returns the render layout to whatever the OS
  wants it to be.

Arguments:

  hdc - Specifies the device context that was passed to
        pSetDisplayOrientation.

Return Value:

  None.

--*/

{
    if (g_SetLayout) {
        g_SetLayout (hdc, g_OldLayout);
    }
}


BOOL
PaintWatermark(
    IN HWND hdlg,
    IN HDC  DialogDC,
    IN UINT XOffset,
    IN UINT YOffset,
    IN UINT FullPage
    )
{
    PBITMAP_DATA BitmapData;
    HPALETTE OldPalette;
    RECT rect;
    int Height,Width;

    //
    // Don't show watermark on NT3.51. It looks awful.
    // Returning FALSE causes the system to do its standard
    // background erasing.
    //
#if 0
    if(OsVersion.dwMajorVersion < 4) {
        return(FALSE);
    }
#endif

    if (FullPage & WIZPAGE_FULL_PAGE_WATERMARK)
    {
        BitmapData = &Watermark;
    }
    else if (FullPage & WIZPAGE_NEW_HEADER)
    {
        BitmapData = &Header2;
    }
    else
    {
        BitmapData = &Header;
    }


    //
    // The correct palette is already realized in foreground from
    // WM_xxxPALETTExxx processing in dialog procs.
    //
#if 0 // fix palette problem
    OldPalette = SelectPalette(DialogDC,BitmapData->Palette,TRUE);
#endif

    Width = BitmapData->BitmapInfoHeader->biWidth - (2*XOffset);


    //
    // For full-page watermarks, the height is the height of the bitmap.
    // For header watermarks, the height is the header area's height.
    // Also account for the y offset within the source bitmap.
    //
    Height = (FullPage ? BitmapData->BitmapInfoHeader->biHeight : WatermarkHeaderHeight) - YOffset;

    //
    // Set the display orientation to left-to-right
    //

    pSetDisplayOrientation (DialogDC);

    //
    // Display the bitmap
    //

    SetDIBitsToDevice(
        DialogDC,
        0,                                          // top
        0,                                          // left
        Width,                                      // width
        Height,                                     // height
        XOffset,                                    // X origin (lower left)
        0,                                          // Y origin (lower left)
        0,                                          // start scan line
        BitmapData->BitmapInfoHeader->biHeight,     // # of scan lines
        BitmapData->BitmapBits,                     // bitmap image
        (BITMAPINFO *)BitmapData->BitmapInfoHeader, // bitmap header
        DIB_RGB_COLORS                              // bitmap type
        );

    //
    // Return to normal display orientation
    //

    pRestoreDisplayOrientation (DialogDC);

    //
    // Fill in area below the watermark if needed. We do this by removing the area
    // we filled with watermark from the clipping area, and passing a return code
    // back from WM_ERASEBKGND indicating that we didn't erase the background.
    // The dialog manager will do its default thing, which is to fill the background
    // in the correct color, but won't touch what we just painted.
    //
    GetClientRect (hdlg, &rect);

    if((Height < rect.bottom) || (Width+(int)XOffset < rect.right)) {
        ExcludeClipRect(DialogDC,0,0,Width+XOffset,Height);
        return(FALSE);
    }

    return(TRUE);
}


VOID
AdjustWatermarkBitmap(
    IN HANDLE hdlg,
    IN HDC    hdc,
    IN OUT PBITMAP_DATA  BitmapData,
    IN BOOL FullPage
    )
{
    RECT rect;
    RECT rect2;
    HWND Separator;
    PVOID Bits;
    HBITMAP hDib;
    HBITMAP hOldBitmap;
    BITMAPINFO *BitmapInfo;
    HDC MemDC;
    int i;
    BOOL b;
    INT Scale;

    if(BitmapData->Adjusted) {
        return;
    }

    //
    // Determine whether the bitmap needs to be stretched.
    // If the width is within 10 pixels and the height is within 5
    // then we don't worry about stretching.
    //
    // Note that 0x3026 is the identifier of the bottom divider in
    // the template. This is kind of slimy but it works.
    //
    Separator = GetDlgItem(hdlg,0x3026);
    if(!Separator) {
        goto c0;
    }

    // NOTE: The bitmap resoures is about the size of the dialog.
    // That is the only reason why the below GetClientRect makes sence.
    // This should be changed to have only the relevant part of the bitmap.
    // Or we have to find something in the case where a none DBCS setup runs
    // on a DBCS system. Here the wizard page are sized incorrect. They are wider
    // then needed and smaller (adjusted when adding the pages).
    GetClientRect(Separator,&rect2);
    MapWindowPoints(Separator,hdlg,(LPPOINT)&rect2,2);
    GetClientRect(hdlg,&rect);

    b = TRUE;
    i = rect.right - BitmapData->BitmapInfoHeader->biWidth;
    if((i < -5) || (i > 5)) {
        b = FALSE;
    }
    i = rect2.top - BitmapData->BitmapInfoHeader->biHeight;
    if((i < -3) || (i > 0)) {
        b = FALSE;
    }

    if(b) {
        goto c0;
    }

    //
    // Create a copy of the existing bitmap's header structure.
    // We then modify the width and height and leave everything else alone.
    //
    BitmapInfo = MALLOC(BitmapData->BitmapInfoHeader->biSize + (BitmapData->PaletteColorCount * sizeof(RGBQUAD)));
    if(!BitmapInfo) {
        goto c0;
    }

    CopyMemory(
        BitmapInfo,
        BitmapData->BitmapInfoHeader,
        BitmapData->BitmapInfoHeader->biSize + (BitmapData->PaletteColorCount * sizeof(RGBQUAD))
        );

    if (!FullPage) {
        Scale = (rect.right + 1) * 100 / BitmapInfo->bmiHeader.biWidth;
        rect2.top = BitmapInfo->bmiHeader.biHeight * Scale / 100;
    }

    BitmapInfo->bmiHeader.biHeight = rect2.top;
    BitmapInfo->bmiHeader.biWidth = rect.right + 1;

    hDib = CreateDIBSection(NULL,BitmapInfo,DIB_RGB_COLORS,&Bits,NULL,0);
    if(!hDib) {
        goto c1;
    }

    //
    // Create a "template" memory DC and select the DIB we created
    // into it. Passing NULL to CreateCompatibleDC creates a DC into which
    // any format bitmap can be selected. We don't want to use the dialog's
    // DC because if the pixel depth of the watermark bitmap differs from
    // the screen, we wouldn't be able to select the dib into the mem dc.
    //
    MemDC = CreateCompatibleDC(NULL);
    if(!MemDC) {
        goto c2;
    }

    hOldBitmap = SelectObject(MemDC,hDib);
    if(!hOldBitmap) {
        goto c3;
    }

    //
    // Do the stretch operation from the source bitmap onto
    // the dib.
    //
    SetStretchBltMode(MemDC,COLORONCOLOR);
    i = StretchDIBits(
            MemDC,
            0,0,
            rect.right+1,
            rect2.top,
            0,0,
            BitmapData->BitmapInfoHeader->biWidth,
            BitmapData->BitmapInfoHeader->biHeight,
            BitmapData->BitmapBits,
            (BITMAPINFO *)BitmapData->BitmapInfoHeader,
            DIB_RGB_COLORS,
            SRCCOPY
            );

    if(i == GDI_ERROR) {
        goto c4;
    }

    //
    // Got everything we need, set up pointers to use new bitmap data.
    //
    BitmapData->BitmapBits = Bits;
    BitmapData->BitmapInfoHeader = (BITMAPINFOHEADER *)BitmapInfo;

    b = TRUE;

c4:
    SelectObject(MemDC,hOldBitmap);
c3:
    DeleteDC(MemDC);
c2:
    if(!b) {
        DeleteObject(hDib);
    }
c1:
    if(!b) {
        FREE(BitmapInfo);
    }
c0:
    BitmapData->Adjusted = TRUE;

    if (!FullPage){
    WatermarkHeaderHeight = BitmapData->BitmapInfoHeader->biHeight;
    }
    return;
}

// NOTE: Need to add this, since it is only defined for _WIN32_IE >= 0x0400
// And if we do that, the propertysheet structure changes, which we cannot do
// or the upgrade DLLs need to change too. And I don't know what other side
// effects that will have.
// So I copied this define from commctrl.h
#define PBM_SETBARCOLOR         (WM_USER+9)             // lParam = bar color


BOOL
WizardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    HWND CurrentPage;
    PPAGE_RUNTIME_DATA WizPage;
    static RECT rect;
    static BOOL Visible = TRUE;
    static BOOL First = TRUE;       // used to keep bitmap from being painted twice
    static DWORD MsecPerProcessTick;
    static DWORD PreviousRemainingTime = 0;
    static DWORD RemainungTimeMsecInThisPhase = 0;
    static UINT  StepSize;

    switch(msg) {
    case WM_CHAR:
        if (wParam == VK_ESCAPE)
        {
            // Make this a Cancel button message, so that the wizard can do its work.
            b = (BOOL)CallWindowProc(OldWizardProc,hdlg,WM_COMMAND,IDCANCEL,0);
        }
        else {
        b = FALSE;
        }
        break;

#if 0 // fix palette problem
    case WM_PALETTECHANGED:
        //
        // If this is our window we need to avoid selecting and realizing
        // because doing so would cause an infinite loop between WM_QUERYNEWPALETTE
        // and WM_PALETTECHANGED.
        //
        if((HWND)wParam == hdlg) {
            return(FALSE);
        }
        //
        // FALL THROUGH
        //
    case WM_QUERYNEWPALETTE:
        {
            HDC hdc;
            HPALETTE pal;

            hdc = GetDC(hdlg);

            if((CurrentPage = PropSheet_GetCurrentPageHwnd(hdlg))
               &&  (WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(CurrentPage,DWLP_USER))
               && WizPage->CommonData.Flags & WIZPAGE_FULL_PAGE_WATERMARK) {
                pal = SelectPalette(hdc,Watermark.Palette,(msg == WM_PALETTECHANGED));
            } else
            {
                if (WizPage->CommonData.Flags & WIZPAGE_NEW_HEADER)
                    pal = SelectPalette(hdc,Header2.Palette,(msg == WM_PALETTECHANGED));
                else
                    pal = SelectPalette(hdc,Header.Palette,(msg == WM_PALETTECHANGED));
            }
            RealizePalette(hdc);
            InvalidateRect(hdlg,NULL,TRUE);
            if(pal) {
                SelectPalette(hdc,pal,TRUE);
            }
            ReleaseDC(hdlg,hdc);
        }
        return(TRUE);
#endif
        case WM_ERASEBKGND:
        {
            if((CurrentPage = PropSheet_GetCurrentPageHwnd(hdlg))
            &&  (WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(CurrentPage,DWLP_USER))) {

                if(WizPage->CommonData.Flags & WIZPAGE_FULL_PAGE_WATERMARK) {
                    AdjustWatermarkBitmap(hdlg,(HDC)wParam,&Watermark, TRUE);
                }
                else if (WizPage->CommonData.Flags & WIZPAGE_NEW_HEADER)
                {
                    AdjustWatermarkBitmap(hdlg,(HDC)wParam,&Header2, FALSE);
                }
                else
                {
                    AdjustWatermarkBitmap(hdlg,(HDC)wParam,&Header, FALSE);
                }
                b = PaintWatermark(
                        hdlg,
                        (HDC)wParam,
                        0,0,
                        WizPage->CommonData.Flags
                        );

            } else {
                b = FALSE;
            }
        }
        break;

        // Set the progress text
        // Indicates what setup is doing.
    case WMX_SETPROGRESSTEXT:
        BB_SetProgressText((PTSTR)lParam);
        b = TRUE;
        break;

    case WMX_BB_SETINFOTEXT:
        BB_SetInfoText((PTSTR)lParam);
        b = TRUE;
        break;

        // The next messages are private progess messages, which get translated to the
        // Windows progress messages, Could not use the windows messages direct, because
        // for some reason this get send by the wizard too and would confuse the
        // progress on the billboard.
    case WMX_PBM_SETRANGE:
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_SETRANGE, wParam, lParam));

            StepSize = 10; // default for StepIt if SetStep is not called.

            RemainingTime = CalcTimeRemaining(CurrentPhase); // In seconds
            SetRemainingTime(RemainingTime);

            //
            // Time per tick is in milli seconds
            // make sure we do not divide by 0 (NTBUG9: 381151)
            //
            if (HIWORD(lParam) > LOWORD(lParam)) {
                MsecPerProcessTick = ((SetupPhase[CurrentPhase].Time*1000)/(HIWORD(lParam)-LOWORD(lParam)) ) + 1;
            }
            RemainungTimeMsecInThisPhase = (SetupPhase[CurrentPhase].Time * 1000);
            PreviousRemainingTime = RemainungTimeMsecInThisPhase;
            b= TRUE;
            break;
    case WMX_PBM_SETPOS:
            if (wParam != 0)
            {
                DWORD Delta = (MsecPerProcessTick * (DWORD)wParam);
                DWORD TimeInPhase = (SetupPhase[CurrentPhase].Time * 1000);
                // position on progress bar changes to wParam ticks.
                if (Delta > TimeInPhase)
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
                else
                {
                    RemainungTimeMsecInThisPhase = TimeInPhase - Delta;
                }
                UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
            }
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_SETPOS, wParam, lParam));
            b= TRUE;
            break;
    case WMX_PBM_DELTAPOS:
            if (wParam != 0)
            {
                // position on progress bar changes by wParam ticks.
                DWORD Delta = (MsecPerProcessTick * (DWORD)wParam);
                if (RemainungTimeMsecInThisPhase > Delta)
                {
                    RemainungTimeMsecInThisPhase -= Delta;
                }
                else
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
                UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
            }
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_DELTAPOS, wParam, lParam));
            b= TRUE;
            break;
    case WMX_PBM_SETSTEP:
            StepSize = (UINT)wParam;
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_SETSTEP, wParam, lParam));
            b= TRUE;
            break;
    case WMX_PBM_STEPIT:
            // position on progress bar changes by StepSize ticks.
            {
                DWORD Delta = (MsecPerProcessTick * StepSize);
                if (RemainungTimeMsecInThisPhase > Delta)
                {
                    RemainungTimeMsecInThisPhase -= Delta;
                }
                else
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
            }
            UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);

            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_STEPIT, wParam, lParam));
            b= TRUE;
            break;

    case WMX_PBM_SETBARCOLOR:
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ProgressGaugeMsg(PBM_SETBARCOLOR, wParam, lParam));
            b= TRUE;
            break;

            // Enabled, disable, show, hide the progress gauge on the billboard
            // wParam should be SW_SHOW or SW_HIDE
    case WMX_BBPROGRESSGAUGE:
        SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ShowProgressGaugeWnd((UINT)wParam));
        b= TRUE;
        break;

        // Advance the setup phase.
    case WMX_BB_ADVANCE_SETUPPHASE:
        if (CurrentPhase < Phase_RestOfSetup)
        {
            CurrentPhase++;
        }
        SetRemainingTime(CalcTimeRemaining(CurrentPhase));
        b = TRUE;
        break;

        // Start, stop the billboard text.
        // This start, stops the billboard text and shows, hides the wizard pages
    case WMX_BBTEXT:
        if (hinstBB)
        {

            if (wParam != 0)
            {
                if (Visible)
                {
                    // Get the current position of the wizard
                    // We restore this position when we need to show it.
                    GetWindowRect(hdlg, &rect);

                    if (!SetWindowPos(hdlg,
                                        GetBBhwnd(),
                                        0,0,0,0,
                                        SWP_NOZORDER))
                    {
                        DebugLog(Winnt32LogWarning,
                                 TEXT("Warning: Wizard, SetWindowPos to 0,0,0,0 failed with GetLastError=%d"),
                                 0,
                                 GetLastError());
                    }

                    SetActiveWindow(GetBBhwnd());

                    Visible = FALSE;
                }
            }
            else
            {
                if (!Visible)
                {
                    SetWindowPos(hdlg,
                        HWND_TOP,
                        rect.left,
                        rect.top,
                        rect.right-rect.left,
                        rect.bottom-rect.top,
                        SWP_SHOWWINDOW);
                }
                Visible = TRUE;
            }

            if (!StartStopBB((wParam != 0)))
            {
                if (!Visible)
                {
                    DebugLog(Winnt32LogWarning,
                             TEXT("Warning: Could not start the billboard text, make Wizard visible"),
                             0);
                    SetWindowPos(hdlg,
                        HWND_TOP,
                        rect.left,
                        rect.top,
                        rect.right-rect.left,
                        rect.bottom-rect.top,
                        SWP_SHOWWINDOW);
                }
                Visible = TRUE;
            }
        }
        else
        {
            if (!Visible)
            {
                SetWindowPos(hdlg,
                    HWND_TOP,
                    rect.left,
                    rect.top,
                    rect.right-rect.left,
                    rect.bottom-rect.top,
                    SWP_SHOWWINDOW);
            }
            Visible = TRUE;
        }
        return TRUE;

    case WM_SYSCOMMAND:
        if (!ISNT()) {
            switch (wParam & 0xFFF0) {
            case SC_MINIMIZE:
                ShowWindow (WizardHandle, SW_HIDE);
                PostMessage (BackgroundWnd, msg, wParam, lParam);
                return 0;

            case SC_RESTORE:
                ShowWindow (WizardHandle, SW_SHOW);
                return 0;
            }
        }

        b = (BOOL)CallWindowProc(OldWizardProc,hdlg,msg,wParam,lParam);
        break;

    case WMX_ACTIVATEPAGE:
        if (!First) {
            InvalidateRect(hdlg,NULL,TRUE);
        } else {
            First = FALSE;
        }

        b = TRUE;
        break;

    case WM_ACTIVATE:
            // If someone wants to active (set the focus to our hiden window) don't
            if ((LOWORD(wParam)== WA_ACTIVE) || (LOWORD(wParam)== WA_CLICKACTIVE))
            {
                if (!Visible)
                {
                    InvalidateRect(GetBBhwnd(),NULL, TRUE);
                    return 0;
                }
            }
            b = (BOOL)CallWindowProc(OldWizardProc,hdlg,msg,wParam,lParam);
        break;

    default:
        b = (BOOL)CallWindowProc(OldWizardProc,hdlg,msg,wParam,lParam);
        break;
    }

    return(b);
}


//
// This DlgProc gets called for all wizard pages.  It may then call a DlgProc
// for the specific page we're on.
//
INT_PTR
WizardCommonDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LONG NextPageOverrideId=0;
    static UINT AdvanceDirection = 0;
    PPAGE_RUNTIME_DATA WizPage;
    NMHDR *Notify;
    BOOL b;
    int i;
    RECT rc1,rc2;
    static BOOL PreviouslyCancelled = FALSE;
    static BOOL center = TRUE;

    WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    b = FALSE;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // lParam points at the PROPSHEETPAGE used for this page.
        //
        WizPage = (PPAGE_RUNTIME_DATA)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hdlg,DWLP_USER,(LPARAM)WizPage);

#if (IDT_TITLE != ID_TITLE_TEXT) || (IDT_SUBTITLE != ID_SUBTITLE_TEXT)
#error Title and Subtitle text control IDs are out of sync!
#endif

        //
        // Set large font for the title string in the dialog.
        // Set bold font for subtitle in the dialog.
        //
        SetDialogFont(hdlg,IDT_TITLE,DlgFontTitle);
        SetDialogFont(hdlg,IDT_SUBTITLE,DlgFontSubtitle);
        SetDialogFont(hdlg,IDT_SUPERTITLE,DlgFontSupertitle);
        break;

    case WM_ERASEBKGND:

        GetClientRect(GetParent(hdlg),&rc1);
        MapWindowPoints(GetParent(hdlg),NULL,(POINT *)&rc1,2);
        GetClientRect(hdlg,&rc2);
        MapWindowPoints(hdlg,NULL,(POINT *)&rc2,2);

        b = PaintWatermark(
                hdlg,
                (HDC)wParam,
                rc2.left-rc1.left,
                rc2.top-rc1.top,
                WizPage->CommonData.Flags
                );

        return(b);

    case WM_CTLCOLORSTATIC:
        //
        // We want to let text that is over the background bitmap paint
        // transparently. Other text should not be painted transparently,
        // because there are static text fields that we update to indicate
        // progress, and if it's drawn transparently we end up with text
        // piling up on top of other text, which is messy and unreadable.
        //
        if(WizPage->CommonData.Flags & WIZPAGE_FULL_PAGE_WATERMARK) {
            b = TRUE;
        } else {
            GetWindowRect((HWND)lParam,&rc1);
            ScreenToClient(hdlg,(POINT *)&rc1);
            b = (rc1.top < (LONG)WatermarkHeaderHeight);
        }

        // B320610: In some languages the background on the icon on the EULA page is
        // not drawn correct. If we exclude the icon from here, everythign is fine.
        if(b && (GetDlgCtrlID((HWND) lParam) != (int)IDC_DIALOG_ICON)) {
            SetBkMode((HDC)wParam,TRANSPARENT);
            SetBkColor((HDC)wParam,GetSysColor(COLOR_3DFACE));
            return((BOOL)PtrToUlong(GetStockObject(HOLLOW_BRUSH)));
        }
        else {
            return(0);
        }

    case WM_NOTIFY:

        Notify = (NMHDR *)lParam;
        switch(Notify->code) {

        case PSN_QUERYCANCEL:
            //
            // We want to ask the user whether he's sure he wants to cancel.
            //
            // If there's presently a file copy error being displayed, then
            // in general the user can't get to the cancel button on the
            // wizard, since the wizard is used as the parent/owner for the
            // error dialog. So we should be guaranteed to be able to grab the
            // UI mutex without contention.
            //
            // But, there could be a race condition. If the user hits
            // the cancel button on the wizard just as a copy error occurrs,
            // then the copy thread could get there first and grab the
            // ui mutex. This would cause us to block here waiting for the user
            // to dismiss the file error dialog -- but the file error dialog
            // wants to use the wizard as its parent/owner, and blammo,
            // we have a deadlock.
            //
            // To get around this, we use a 0 timeout on the wait for
            // the ui mutex. We either get ownership of the mutex or
            // we know that there's already an error dialog up already.
            // In the latter case we just ignore the cancel request.
            //
            // If a file copy error occurs then the error path code simulates
            // a press of the cancel button. In that case when we get here the
            // Cancelled flag has already been set, no no need for additional
            // confirmation now.
            //

            AdvanceDirection = 0;
            if(Cancelled) {
                i = IDYES;
            } else {
                i = WaitForSingleObject(UiMutex,0);
                if((i == WAIT_OBJECT_0) && !Cancelled) {
                    BOOL bCancel = TRUE;
                    BOOL bHandled;
                    //
                    // Got the ui mutex, it's safe to diaplay ui.  But first,
                    // signal not to pass through dialog boxes anymore just
                    // because we're unattended (e.g. the finish dialog).
                    //
                    // Ask the page first if it wants to treat this cancel message
                    //
                    bHandled = (BOOL) CallWindowProc (
                                        (WNDPROC)WizPage->CommonData.DialogProcedure,
                                        hdlg,
                                        WMX_QUERYCANCEL,
                                        0,
                                        (LPARAM)&bCancel
                                        );
                    if (!bHandled || bCancel) {
                        CancelPending = TRUE;
                        if( CheckUpgradeOnly ) {
                            //
                            // If we're running the upgrade checker, just
                            // cancel.
                            //
                            i = IDYES;
                        } else {
                            i = MessageBoxFromMessage(
                                    hdlg,
                                    MSG_SURE_EXIT,
                                    FALSE,
                                    AppTitleStringId,
                                    MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL | MB_DEFBUTTON2
                                    );
                        }


                        if(i == IDYES) {
                            Cancelled = TRUE;
                        }
                        CancelPending = FALSE;
                    }
                    ReleaseMutex(UiMutex);
                } else {
                    //
                    // Can't get ui mutex or user already cancelled,
                    // ignore the cancel request.
                    //
                    i = IDNO;
                }
            }

            //
            // Set DWLP_MSGRESULT to TRUE to prevent the cancel operation.
            // If we're going to allow the cancel operation, don't actually
            // do it here, but instead jump to our special clean-up/cancel
            // page, which does some work before actually exiting.
            //
            // Note: we need to avoid jumping to the cleanup page more than
            // once, which can happen if the user cancels on a page with a
            // worker thread. When the user cancels, we run through this code,
            // which sets the Cancelled flag and jumps to the cleanup page.
            // Some time later the worker thread, which is still hanging around,
            // posts a message to its page when it's done. The page sees the
            // Cancelled flag set and turns around and posts a cancel message,
            // which puts us here again. See WMX_INSPECTRESULT in the
            // Working1WizPage dialog proc.
            //
            if((i == IDYES) && !PreviouslyCancelled) {
                PreviouslyCancelled = TRUE;
                PropSheet_SetCurSelByID(GetParent(hdlg),IDD_CLEANING);
            }
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,TRUE);
            return(TRUE);

        case PSN_SETACTIVE:
/*
            //
            // Add separator at top of page if not there already.
            // Can't do this at WM_INITDIALOG time because positions aren't
            // set up properly yet and the mapping fails.
            //
            if(!(WizPage->CommonData.Flags & WIZPAGE_SEPARATOR_CREATED)) {


        if (WatermarkHeaderHeight != 0){
            GetClientRect(hdlg,&rc1);

                    MapWindowPoints(hdlg,GetParent(hdlg),(POINT *)&rc1,2);

                    CreateWindowEx(
            WS_EX_STATICEDGE | WS_EX_NOPARENTNOTIFY,
            TEXT("Static"),
            TEXT("HeaderSeparator"),
            WS_CHILD | WS_VISIBLE | ((OsVersion.dwMajorVersion < 4) ? SS_BLACKRECT : SS_SUNKEN),
            0,
            WatermarkHeaderHeight - rc1.top,
            rc1.right-rc1.left,2,
            hdlg,
            (HMENU)IDC_HEADER_BOTTOM,
            hInst,
            0
            );

            WizPage->CommonData.Flags |= WIZPAGE_SEPARATOR_CREATED;

//      } else {
//          PostMessage(GetParent(hdlg),PSN_SETACTIVE,wParam,lParam);
        }
            }
*/
            //
            // Scale windows to proper size, then set up buttons and ask real
            // dialog whether it wants to be activated.
            //
            ResizeWindowForFont (hdlg);

            if (center) {
                CenterWindowRelativeToWindow (GetParent (hdlg), GetBBhwnd());
                center = FALSE;
            }

            if(WizPage->CommonData.Buttons != (DWORD)(-1)) {
                PropSheet_SetWizButtons(GetParent(hdlg),WizPage->CommonData.Buttons);
            }
            SetWindowLongPtr(
                hdlg,
                DWLP_MSGRESULT,
                CallWindowProc((WNDPROC)WizPage->CommonData.DialogProcedure,hdlg,WMX_ACTIVATEPAGE,TRUE,AdvanceDirection) ? 0 : -1
                );
            //
            // update billboard step
            //
            if (WizPage->CommonData.BillboardStep) {
                SetBBStep (WizPage->CommonData.BillboardStep);
            }
            PostMessage(GetParent(hdlg),WMX_ACTIVATEPAGE,0,0);
            PostMessage(GetParent(hdlg),WMX_I_AM_VISIBLE,0,0);
            return(TRUE);

        case PSN_KILLACTIVE:
            //
            // Page is being deactivated. Ask real dlg proc.
            //
            SetWindowLongPtr(
                hdlg,
                DWLP_MSGRESULT,
                CallWindowProc((WNDPROC)WizPage->CommonData.DialogProcedure,hdlg,WMX_ACTIVATEPAGE,FALSE,AdvanceDirection) ? 0 : -1
                );

            return(TRUE);

        case PSN_WIZFINISH:
        case PSN_WIZBACK:
        case PSN_WIZNEXT:

            //
            // set the button id
            //
            switch(Notify->code) {
                case PSN_WIZFINISH:
                    i = WMX_FINISHBUTTON;
                    break;

                case PSN_WIZBACK:
                    i = WMX_BACKBUTTON;
                    break;

                case PSN_WIZNEXT:

                    i = WMX_NEXTBUTTON;
                    break;
            }
            //
            // Tell the page-specific dialog proc about it.
            //
            CallWindowProc((WNDPROC)WizPage->CommonData.DialogProcedure,hdlg,i,0,(LPARAM)&NextPageOverrideId);
            //
            // Allow user to use these buttons.  Remember which button was chosen.
            //
            AdvanceDirection = Notify->code;
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,NextPageOverrideId);
            return(TRUE);

        default:
            //
            // Unknown code, pass it on.
            //
            break;
        }
        break;

    case WMX_UNATTENDED:

        PropSheet_PressButton(GetParent(hdlg),wParam);
        break;

    case WM_NCPAINT:
    //
    // we delay drawing the separator until here in some cases, because
    // we must make sure that the header bitmap has been adjusted correctly,
    // and then we can place the separator relative to the header bitmap
    //
/*
        if(!(WizPage->CommonData.Flags & WIZPAGE_SEPARATOR_CREATED)) {
        if (WatermarkHeaderHeight){
                GetClientRect(hdlg,&rc1);

                MapWindowPoints(hdlg,GetParent(hdlg),(POINT *)&rc1,2);

                CreateWindowEx(
                    WS_EX_STATICEDGE | WS_EX_NOPARENTNOTIFY,
                    TEXT("Static"),
                    TEXT("HeaderSeparator"),
                    WS_CHILD | WS_VISIBLE | ((OsVersion.dwMajorVersion < 4) ? SS_BLACKRECT : SS_SUNKEN),
                    0,
                    WatermarkHeaderHeight - rc1.top,
                    rc1.right-rc1.left,2,
                    hdlg,
                    (HMENU)IDC_HEADER_BOTTOM,
                    hInst,
                    0
                    );

                WizPage->CommonData.Flags |= WIZPAGE_SEPARATOR_CREATED;
        }
    }
*/
    default:

        break;
    }

    if(WizPage) {
        return((BOOL)CallWindowProc((WNDPROC)WizPage->CommonData.DialogProcedure,hdlg,msg,wParam,lParam));
    } else {
        return(b);
    }
}


BOOL
GrowWizardArray(
    IN OUT PUINT               ArraySize,
    IN     UINT                PageCount,
    IN OUT LPPROPSHEETPAGE    *PagesArray,
    IN OUT PPAGE_RUNTIME_DATA *DataArray
    )
{
    PVOID p;
    BOOL b;
    #define _INCR 3

    if(*ArraySize == PageCount) {

        b = FALSE;

        if(p = REALLOC(*PagesArray,(*ArraySize+_INCR) * sizeof(PROPSHEETPAGE))) {
            *PagesArray = p;
            if(p = REALLOC(*DataArray,(*ArraySize+_INCR) * sizeof(PAGE_RUNTIME_DATA))) {
                *DataArray = p;

                *ArraySize += _INCR;
                b = TRUE;
            }
        }

        #undef _INCR

        if(!b) {
            FREE(*PagesArray);
            FREE(*DataArray);

            MessageBoxFromMessage(
                NULL,
                MSG_OUT_OF_MEMORY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );
        }

    } else {
        b = TRUE;
    }

    return(b);
}


VOID
FixUpWizardTitle(
    IN HWND Wizard
    )
{
    HWND TabControl;
    int Count,i;
    TCHAR Title[250];
    TC_ITEM ItemData;

    LoadString(hInst,AppTitleStringId,Title,sizeof(Title)/sizeof(Title[0]));

    TabControl = PropSheet_GetTabControl(Wizard);
    Count = TabCtrl_GetItemCount(TabControl);

    ItemData.mask = TCIF_TEXT;
    ItemData.pszText = Title;

    for(i=0; i<Count; i++) {
        TabCtrl_SetItem(TabControl,i,&ItemData);
    }
}

#if ASSERTS_ON

VOID
EnsureCorrectPageSize(
    PROPSHEETPAGE PropSheetPage
    )
{
    LPDLGTEMPLATE pDlgTemplate;
    LPDLGTEMPLATEEX pDlgTemplateEx;
    HRSRC hRes;
    HGLOBAL hDlgTemplate;

    pDlgTemplate = NULL;

    if (PropSheetPage.dwFlags & PSP_DLGINDIRECT) {
        pDlgTemplate = (LPDLGTEMPLATE) PropSheetPage.pResource;
        goto UseTemplate;
    } else {
        hRes = FindResource(PropSheetPage.hInstance, PropSheetPage.pszTemplate, RT_DIALOG);
        if (hRes) {
            hDlgTemplate = LoadResource(PropSheetPage.hInstance, hRes);
            if (hDlgTemplate) {
                pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
                if (pDlgTemplate) {
UseTemplate:
                    pDlgTemplateEx = (LPDLGTEMPLATEEX)pDlgTemplate;
                    if (pDlgTemplateEx->wSignature == 0xFFFF) {
                        MYASSERT(pDlgTemplateEx->cx == WIZ_PAGE_SIZE_X && pDlgTemplateEx->cy==WIZ_PAGE_SIZE_Y);
                    } else {
                        MYASSERT(pDlgTemplate->cx == WIZ_PAGE_SIZE_X && pDlgTemplate->cy == WIZ_PAGE_SIZE_Y);
                    }
                    if (PropSheetPage.dwFlags & PSP_DLGINDIRECT)
                        return;
                    UnlockResource(hDlgTemplate);
                }

            }
        }
    }
}

#endif

LRESULT
CALLBACK
BackgroundWndProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    HBRUSH Brush, OldBrush;
    INT i;
    INT y1, y2;
    INT Height;

    switch (uMsg) {

    case WM_ACTIVATE:
        if (LOWORD (wParam) == WA_ACTIVE) {
            InvalidateRect (hwnd, NULL, FALSE);
        }
        break;

    case WM_SYSCOMMAND:
        switch (wParam & 0xFFF0) {

        case SC_MINIMIZE:
            ShowWindow (hwnd, SW_MINIMIZE);
            return 0;

        case SC_RESTORE:
        case SC_CLOSE:
            ShowWindow (hwnd, SW_RESTORE);
            PostMessage (WizardHandle, uMsg, wParam, lParam);
            return 0;

        default:
            MYASSERT (FALSE);
        }

        break;

    case WM_PAINT:
        hdc = BeginPaint (hwnd, &ps);

        //SelectObject (hdc, GetStockObject (BLACK_BRUSH));
        SelectObject (hdc, GetStockObject (NULL_PEN));

        GetClientRect (hwnd, &rect);
        Height = rect.bottom - rect.top;

        for (i = 0 ; i < 256 ; i++) {
            Brush = CreateSolidBrush (RGB(0, 0, i));

            if (Brush != NULL) {
                OldBrush = (HBRUSH) SelectObject (hdc, Brush);

                y1 = rect.top + Height * i / 256;
                y2 = rect.top + Height * (i + 1) / 256;
                Rectangle (hdc, rect.left, y1, rect.right + 1, y2 + 1);

                SelectObject (hdc, OldBrush);
                DeleteObject (Brush);
            }
        }

        EndPaint (hwnd, &ps);
        break;
    }

    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}

typedef HWND (CALLBACK* GETBBHWND)(void);
typedef BOOL (CALLBACK* SETSTEP)(int);
typedef BOOL (CALLBACK *STOPBILLBOARD)();
typedef BOOL (CALLBACK *STARTBILLBOARD)();
typedef BOOL (WINAPI* SETPROGRESSTEXT)(LPCTSTR szText);
typedef BOOL (WINAPI* SETTIMEESTIMATE)(LPCTSTR szText);
typedef BOOL (WINAPI* SETINFOTEXT)(LPCTSTR szText);
typedef LRESULT (WINAPI* PROGRESSGAUGEMSG)(UINT msg, WPARAM wparam, LPARAM lparam);
typedef BOOL (WINAPI* SHOWPROGRESSGAUGEWINDOW)(UINT uiShow);

BOOL BB_ShowProgressGaugeWnd(UINT nCmdShow)
{
    static SHOWPROGRESSGAUGEWINDOW fpShowGauge = NULL;
    BOOL bRet = FALSE;;

    if (fpShowGauge == NULL)
    {
        if (hinstBB)
        {
            fpShowGauge = (SHOWPROGRESSGAUGEWINDOW )GetProcAddress(hinstBB, "ShowProgressGaugeWindow");
        }
    }
    if (fpShowGauge != NULL)
    {
        bRet = fpShowGauge(nCmdShow);
    }
    return bRet;
}
LRESULT BB_ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam)
{
    static PROGRESSGAUGEMSG fpProgressGaugeMsg = NULL;
    LRESULT lresult = 0;

    if (fpProgressGaugeMsg == NULL)
    {
        if (hinstBB)
        {
            fpProgressGaugeMsg = (PROGRESSGAUGEMSG )GetProcAddress(hinstBB, "ProgressGaugeMsg");
        }
    }
    if (fpProgressGaugeMsg != NULL)
    {
        lresult = fpProgressGaugeMsg(msg, wparam, lparam);
    }
    return lresult;
}
void BB_SetProgressText(LPTSTR szText)
{
    static SETPROGRESSTEXT fpSetProgressText = NULL;
    if (fpSetProgressText == NULL)
    {
        if (hinstBB)
        {
            fpSetProgressText = (SETPROGRESSTEXT )GetProcAddress(hinstBB, "SetProgressText");
        }
    }
    if (fpSetProgressText != NULL)
    {
        fpSetProgressText(szText);
    }
}
void BB_SetTimeEstimateText(LPTSTR szText)
{
    static SETTIMEESTIMATE fpSetTimeEstimate = NULL;
    if (fpSetTimeEstimate == NULL)
    {
        if (hinstBB)
        {
            fpSetTimeEstimate = (SETTIMEESTIMATE)GetProcAddress(hinstBB, "SetTimeEstimate");
        }
    }
    if (fpSetTimeEstimate != NULL)
    {
        fpSetTimeEstimate(szText);
    }
}
void BB_SetInfoText(LPTSTR szText)
{
    static SETINFOTEXT fpSetInfoText = NULL;
    if (fpSetInfoText == NULL)
    {
        if (hinstBB)
        {
            fpSetInfoText = (SETINFOTEXT )GetProcAddress(hinstBB, "SetInfoText");
        }
    }
    if (fpSetInfoText != NULL)
    {
        fpSetInfoText(szText);
    }
}

BOOL StartStopBB(BOOL bStart)
{
    static STARTBILLBOARD fpStart = NULL;
    static STOPBILLBOARD fpStop = NULL;
    BOOL bRet = FALSE;

    if ((fpStart == NULL) || (fpStop == NULL))
    {
        if (hinstBB)
        {
            fpStop = (STARTBILLBOARD )GetProcAddress(hinstBB, "StopBillBoard");
            fpStart = (STOPBILLBOARD )GetProcAddress(hinstBB, "StartBillBoard");
        }
    }
    if ((fpStart != NULL) && (fpStop != NULL))
    {
        if (bStart)
            bRet = fpStart();
        else
            bRet = fpStop();

    }
    return bRet;
}

HWND GetBBhwnd()
{
    GETBBHWND pgetbbhwnd;
    static HWND      retHWND = NULL;

    if (retHWND == NULL)
    {
        if (hinstBB)
        {
            if (pgetbbhwnd = (GETBBHWND )GetProcAddress(hinstBB, "GetBBHwnd"))
                retHWND = pgetbbhwnd();
        }
    }
    return retHWND;
}

HWND GetBBMainHwnd()
{
    GETBBHWND pgetbbhwnd;
    static HWND      retHWND = NULL;

    if (retHWND == NULL)
    {
        if (hinstBB)
        {
            if (pgetbbhwnd = (GETBBHWND )GetProcAddress(hinstBB, "GetBBMainHwnd"))
                retHWND = pgetbbhwnd();
        }
    }
    return retHWND;
}


void SetBBStep(int iStep)
{
    static SETSTEP psetstep = NULL;
    if (psetstep == NULL)
    {
        if (hinstBB)
        {
            psetstep = (SETSTEP )GetProcAddress(hinstBB, "SetStep");
        }
    }
    if (psetstep)
        psetstep(iStep);
}


VOID
Wizard(
    VOID
    )
{
    UINT ArraySize;
    LPPROPSHEETPAGE PropSheetPages;
    PPAGE_RUNTIME_DATA PageData;
    UINT u;
    UINT i;
    UINT PageCount;
    PROPSHEETHEADER Sheet;
    WNDCLASSEX wcx;
    RECT rect;
    TCHAR Caption[512];
    LONG l;

    ArraySize = 5;
    PropSheetPages = MALLOC(ArraySize * sizeof(PROPSHEETPAGE));
    if(!PropSheetPages) {
        MessageBoxFromMessage(
            NULL,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return;
    }

    PageData = MALLOC(ArraySize * sizeof(PAGE_RUNTIME_DATA));
    if(!PageData) {
        FREE(PropSheetPages);

        MessageBoxFromMessage(
            NULL,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return;
    }

    PageCount = 0;

    //
    // Now loop through the array of protopages, adding ones we supply, and
    // ranges of pages supplied externally.
    //
    for(u=0; u<(sizeof(ProtoPages)/sizeof(ProtoPages[0])); u++) {

        if(ProtoPages[u].ExternalPages) {
            //
            // Supplied externally. If there are any pages, add them now.
            //
            for(i=0; i<*ProtoPages[u].ExternalPageCount; i++) {

                if(!GrowWizardArray(&ArraySize,PageCount,&PropSheetPages,&PageData)) {
                    return;
                }

                PropSheetPages[PageCount] = (*ProtoPages[u].ExternalPages)[i];

                ZeroMemory(&PageData[PageCount],sizeof(PAGE_RUNTIME_DATA));
                PageData[PageCount].CommonData.DialogProcedure = PropSheetPages[PageCount].pfnDlgProc;
                PropSheetPages[PageCount].pfnDlgProc = WizardCommonDlgProc;

                PageData[PageCount].CommonData.Buttons = (DWORD)(-1);

                PageCount++;
            }
        } else {
            //
            // Supplied internally. Add now.
            //
            if(!GrowWizardArray(&ArraySize,PageCount,&PropSheetPages,&PageData)) {
                return;
            }

            ZeroMemory(&PropSheetPages[PageCount],sizeof(PROPSHEETPAGE));
            ZeroMemory(&PageData[PageCount],sizeof(PAGE_RUNTIME_DATA));

            PageData[PageCount].CommonData = ProtoPages[u].CommonData;

            PropSheetPages[PageCount].dwSize = sizeof(PROPSHEETPAGE);
            PropSheetPages[PageCount].dwFlags = PSP_USETITLE;
            PropSheetPages[PageCount].hInstance = hInst;
            PropSheetPages[PageCount].pszTemplate = MAKEINTRESOURCE(ProtoPages[u].Template);
            PropSheetPages[PageCount].pszTitle = MAKEINTRESOURCE(AppTitleStringId);
            PropSheetPages[PageCount].pfnDlgProc = WizardCommonDlgProc;

            PageCount++;
        }

    }

    for(u=0; u<PageCount; u++) {

#if ASSERTS_ON
        //
        // Make sure that the page size is correct
        //
        // PW: Why??? Localization should be able to resize this.
        // This would also prevent us from resizing the pages
        // in the case where we are running an none DBCS setup
        // on a DBCS system.
        // We need to resize the pages, because the fonts for the
        // page and the frame are different. When comctrl calcs
        // the size of the frame it comes up short for the font
        // used in the page.
        //
        EnsureCorrectPageSize(PropSheetPages[u]);
#endif

        //
        // Set pointers to runtime page data.
        //
        PropSheetPages[u].lParam = (LPARAM)&PageData[u];
    }

    //
    // Set up the property sheet header structure.
    //
    ZeroMemory(&Sheet,sizeof(PROPSHEETHEADER));

    Sheet.dwSize = sizeof(PROPSHEETHEADER);
    Sheet.dwFlags = PSH_WIZARD | PSH_PROPSHEETPAGE | PSH_USECALLBACK;
    Sheet.hInstance = hInst;
    Sheet.nPages = PageCount;
    Sheet.ppsp = PropSheetPages;
    Sheet.pfnCallback = Winnt32SheetCallback;
#if 0
    //
    // Create background (for Win9x only currently)
    //
    if (!ISNT()) {
        GetWindowRect (GetDesktopWindow(), &rect);

        ZeroMemory (&wcx, sizeof (wcx));
        wcx.cbSize = sizeof (wcx);
        wcx.style = CS_NOCLOSE;
        wcx.lpfnWndProc = BackgroundWndProc;
        wcx.hInstance = hInst;
        wcx.lpszClassName = TEXT("Winnt32Background");

        RegisterClassEx (&wcx);

        if (!LoadString (
                hInst,
                AppTitleStringId,
                Caption,
                sizeof(Caption)/sizeof(TCHAR)
                )) {
            Caption[0] = 0;
        }

        BackgroundWnd = CreateWindowEx (
                              WS_EX_APPWINDOW,
                              TEXT("Winnt32Background"),
                              Caption,
                              WS_DISABLED|WS_CLIPCHILDREN|WS_POPUP|WS_VISIBLE,
                              rect.left,
                              rect.top,
                              rect.right,
                              rect.bottom,
                              NULL,
                              NULL,
                              hInst,
                              0
                              );

        Sheet.hwndParent = BackgroundWnd;

        UpdateWindow (BackgroundWnd);
    }
#else
    Sheet.hwndParent = GetBBhwnd();
#endif
    //
    // Do it.
    //
    __try{
        i = (UINT)PropertySheet(&Sheet);
    }
    __except(EXCEPTION_EXECUTE_HANDLER){
        i = 0;
        MessageBoxFromMessage(
            NULL,
            MSG_RESTART_TO_RUN_AGAIN,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
    }

    if (BackgroundWnd) {
        DestroyWindow (BackgroundWnd);
        BackgroundWnd = NULL;
    }

    if(i == (UINT)(-1)) {

        MessageBoxFromMessage(
            NULL,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
    }

    FREE(PageData);
    FREE(PropSheetPages);
}

BOOL
GetComplianceIds(
    DWORD SourceSku,
    DWORD DestinationType,
    DWORD DestinationVersion,
    PDWORD pSourceId,
    PDWORD pDestId
    )
{

    BOOL bError = FALSE;

    switch (SourceSku) {
        case COMPLIANCE_SKU_NTSDTC:
            *pSourceId = MSG_TYPE_NTSDTC51;
            break;
        case COMPLIANCE_SKU_NTSFULL:
        case COMPLIANCE_SKU_NTSU:
            *pSourceId = MSG_TYPE_NTS51;
            break;
        case COMPLIANCE_SKU_NTSEFULL:
        case COMPLIANCE_SKU_NTSEU:
            *pSourceId = MSG_TYPE_NTAS51;
            break;
        case COMPLIANCE_SKU_NTWFULL:
        case COMPLIANCE_SKU_NTW32U:
            *pSourceId = MSG_TYPE_NTPRO51;
            break;
        case COMPLIANCE_SKU_NTWPFULL:
        case COMPLIANCE_SKU_NTWPU:
            *pSourceId = MSG_TYPE_NTPER51;
            break;
        case COMPLIANCE_SKU_NTSB:
        case COMPLIANCE_SKU_NTSBU:
            *pSourceId = MSG_TYPE_NTBLA51;
            break;
        default:
            bError = TRUE;
    };

    switch (DestinationType) {
        case COMPLIANCE_INSTALLTYPE_WIN31:
            *pDestId = MSG_TYPE_WIN31;
            break;
        case COMPLIANCE_INSTALLTYPE_WIN9X:
            switch (OsVersionNumber) {
                case 410:
                    *pDestId = MSG_TYPE_WIN98;
                    break;
                case 490:
                    *pDestId = MSG_TYPE_WINME;
                    break;
                default:
                    *pDestId = MSG_TYPE_WIN95;
                    break;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTW:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTPROPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTPRO;
                } else {
                    *pDestId = MSG_TYPE_NTPRO51;
                }
            } else {
                *pDestId = MSG_TYPE_NTW;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTS:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTSPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTS2;
                } else {
                    *pDestId = MSG_TYPE_NTS51;
                }
            } else {
                *pDestId = MSG_TYPE_NTS;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSE:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTASPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTAS;
                } else {
                    *pDestId = MSG_TYPE_NTAS51;
                }
            } else {
                *pDestId = MSG_TYPE_NTSE;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
            if (DestinationVersion < 1381) {
                *pDestId = MSG_TYPE_NTSCITRIX;
            } else {
                *pDestId = MSG_TYPE_NTSTSE;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSDTC:
            if (DestinationVersion <= 2195) {
                *pDestId = MSG_TYPE_NTSDTC;
            } else {
                *pDestId = MSG_TYPE_NTSDTC51;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTWP:
            if (DestinationVersion <= 2195) {
                bError = TRUE;
            } else {
                *pDestId = MSG_TYPE_NTPER51;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSB:
            if (DestinationVersion <= 2195) {
                bError = TRUE;
            } else {
                *pDestId = MSG_TYPE_NTBLA51;
            }
            break;
        default:
            bError = TRUE;

    };

    return (!bError);

}


INT_PTR
WelcomeWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    LONG l;
    static BOOL WantToUpgrade; // need to remember if "Upgrade" is in the listbox
    BOOL noupgradeallowed = FALSE;
    UINT srcsku,reason,desttype,destversion;
    TCHAR reasontxt[200];
    PTSTR p;
    TCHAR buffer[MAX_PATH];
    TCHAR win9xInf[MAX_PATH];
    BOOL    CompliantInstallation = FALSE;
    BOOLEAN CleanInstall = FALSE;

    UINT skuerr[] = {
        0,               // COMPLIANCE_SKU_NONE
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTWFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTW32U
        0,               // COMPLIANCE_SKU_NTWU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSEFULL
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSEU
        0,               // COMPLIANCE_SKU_NTSSEU
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSDTC
        0,               // COMPLIANCE_SKU_NTSDTCU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTWPFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTWPU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSB
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSBU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSBS
        MSG_SKU_UPGRADE  // COMPLIANCE_SKU_NTSBSU
    } ;


    UINT skureason[] = {
        0, //MSG_SKU_REASON_NONE;
        MSG_SKU_VERSION, //COMPLIANCEERR_VERSION;
        MSG_SKU_SUITE, //COMPLIANCEERR_SUITE;
        MSG_SKU_TYPE, // COMPLIANCEERR_TYPE;
        MSG_SKU_VARIATION, //COMPLIANCEERR_VARIATION;
        MSG_SKU_UNKNOWNTARGET, //COMPLIANCEERR_UNKNOWNTARGET
        MSG_SKU_UNKNOWNSOURCE, //COMPLIANCEERR_UNKNOWNSOURCE
        MSG_CANT_UPGRADE_FROM_BUILD_NUMBER //COMPLIANCEERR_VERSION (Old on New Builds)
    } ;

    switch(msg) {

    case WM_COMMAND:

        b = FALSE;
        //
        // Check for buttons.
        //
        if(HIWORD(wParam) == CBN_SELCHANGE)
        {
            TCHAR szLoadText[MAX_STRING];
            if (0 == SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_GETCURSEL, 0, 0) && WantToUpgrade)
            {
                dwSetupFlags |= UPG_FLAG_TYPICAL;
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_CLEAN), SW_HIDE);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_CLEAN), SW_HIDE);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_UPG), SW_SHOW);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_UPG), SW_SHOW);
                if(LoadString(hInst,IDS_INSTALLTYPE_EXPRESS,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDT_INSTALLTYPE), WM_SETTEXT, 0, (LPARAM)szLoadText);
                }
                InvalidateRect(hdlg,NULL,TRUE);
            }
            else
            {
                dwSetupFlags &= (~UPG_FLAG_TYPICAL);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_CLEAN), SW_SHOW);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_CLEAN), SW_SHOW);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_UPG), SW_HIDE);
                ShowWindow(GetDlgItem(hdlg, IDC_NOTE_UPG), SW_HIDE);
                if(LoadString(hInst,IDS_INSTALLTYPE_CUSTOM,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDT_INSTALLTYPE), WM_SETTEXT, 0, (LPARAM)szLoadText);
                }
                InvalidateRect(hdlg,NULL,TRUE);
            }
            b = TRUE;
        }
        break;

    case WM_INITDIALOG:
        //
        // Center the wizard
        //

        WizardHandle = GetParent (hdlg);

#ifdef _X86_

        if (!ISNT()) {
            //
            // NOTE: Win98, Win98 SE and WinME don't work properly with a wizard
            //       that can minimize.  So while the minimize functionality is
            //       useful, we can't allow it on anything other than Win95,
            //       OSR1 or OSR2.
            //

            if (BUILDNUM() <= 1080) {
                l = GetWindowLong (WizardHandle, GWL_STYLE);
                l |= WS_MINIMIZEBOX|WS_SYSMENU;
                SetWindowLong (WizardHandle, GWL_STYLE, l);
            }

            ProtectAllModules();        // protects modules from 0xC0000006
        }
#endif

        //
        // We're about to check if upgrades are allowed.
        // Remember if the user wants an upgrade (this would be via an unattend
        // mechanism).
        //
        WantToUpgrade = Upgrade;

        if (ISNT()) AdjustPrivilege((PWSTR)SE_RESTORE_NAME);

        if (!NoCompliance) {
            TCHAR SourceName[200];
            UINT srcid, destid;
            TCHAR DestName[200];

            CompliantInstallation = IsCompliant(
                        &UpgradeOnly,
                        &noupgradeallowed,
                        &srcsku,
                        &desttype,
                        &destversion,
                        &reason);

            DebugLog(Winnt32LogInformation, TEXT("Upgrade only = %1"), 0, UpgradeOnly?TEXT("Yes"):TEXT("No"));
            DebugLog(Winnt32LogInformation, TEXT("Upgrade allowed = %1"), 0, noupgradeallowed?TEXT("No"):TEXT("Yes"));
            if (GetComplianceIds(
                    srcsku,
                    desttype,
                    destversion,
                    &srcid,
                    &destid))
            {
                  FormatMessage(
                      FORMAT_MESSAGE_FROM_HMODULE,
                      hInst,
                      srcid,
                      0,
                      SourceName,
                      sizeof(SourceName) / sizeof(TCHAR),
                      NULL
                      );
                DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1!ld!"), 0, srcsku);
                DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1"), 0, SourceName);

                  FormatMessage(
                      FORMAT_MESSAGE_FROM_HMODULE,
                      hInst,
                      destid,
                      0,
                      DestName,
                      sizeof(DestName) / sizeof(TCHAR),
                      NULL
                      );
                DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1!ld!"), 0, desttype);
                DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1"), 0, DestName);
            }
            else
            {
                DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1!ld!"), 0, srcsku);
                DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1!ld!"), 0, desttype);
            }
            DebugLog(Winnt32LogInformation, TEXT("Current Version = %1!ld!"), 0, destversion);
            if (!CompliantInstallation)
            {
                DebugLog(Winnt32LogInformation, TEXT("Reason = %1!ld!"), 0, reason);
            }
            //
            // Do only clean installs in WinPE mode & don't
            // shut down automatically once Winnt32.exe completes
            //
            if (IsWinPEMode()) {
                noupgradeallowed = TRUE;
                AutomaticallyShutDown = FALSE;
            }

            CleanInstall = CompliantInstallation ? TRUE : FALSE;

            if (!CompliantInstallation) {
                //
                // if they aren't compliant, we won't let them upgrade.
                // we also won't let them do a clean install from winnt32
                //


                switch(reason) {
                    case COMPLIANCEERR_UNKNOWNTARGET:
                        MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_SKU_UNKNOWNTARGET,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONERROR | MB_TASKMODAL
                              );
                        Cancelled = TRUE;
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                        return(FALSE);
                        break;

                    case COMPLIANCEERR_UNKNOWNSOURCE:
                        MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_SKU_UNKNOWNSOURCE,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONERROR | MB_TASKMODAL
                              );
                        Cancelled = TRUE;
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                        return(FALSE);
                        break;
                    case COMPLIANCEERR_SERVICEPACK5:
                        MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_SKU_SERVICEPACK,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONWARNING | MB_TASKMODAL
                              );
                        Cancelled = TRUE;
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                        return(FALSE);
                        break;

                    default:
                        break;
                };

                // If we add this part to the message, it sound bad and is not needed.
                if (reason == COMPLIANCEERR_VERSION)
                {
                    reasontxt[0] = TEXT('\0');
                }
                else
                {
                    FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        hInst,
                        skureason[reason],
                        0,
                        reasontxt,
                        sizeof(reasontxt) / sizeof(TCHAR),
                        NULL
                        );
                }

                //
                // don't warn again if winnt32 just restarted
                //
                if (!Winnt32Restarted ()) {
                    MessageBoxFromMessage(
                                          GetBBhwnd(),
                                          skuerr[srcsku],
                                          FALSE,
                                          AppTitleStringId,
                                          MB_OK | MB_ICONERROR | MB_TASKMODAL,
                                          reasontxt
                                          );
                }

                if (UpgradeOnly) {
                    Cancelled = TRUE;
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    return(FALSE);
                }
                Upgrade = FALSE;
            } else if (Upgrade && noupgradeallowed) {
                Upgrade = FALSE;
                if (!UnattendedOperation && !BuildCmdcons && !IsWinPEMode() &&
                    //
                    // don't warn again if winnt32 just restarted
                    //
                    !Winnt32Restarted ()) {

                    //
                    // put up an error message for the user.
                    //

                    if (GetComplianceIds(
                            srcsku,
                            desttype,
                            destversion,
                            &srcid,
                            &destid)) {

                        if (srcid != destid) {
#ifdef UNICODE
                              //
                              // for Win9x upgrades, the message is already displayed
                              // by the upgrade module; no need to repeat it here
                              //
                              FormatMessage(
                                  FORMAT_MESSAGE_FROM_HMODULE,
                                  hInst,
                                  srcid,
                                  0,
                                  SourceName,
                                  sizeof(SourceName) / sizeof(TCHAR),
                                  NULL
                                  );

                              FormatMessage(
                                  FORMAT_MESSAGE_FROM_HMODULE,
                                  hInst,
                                  destid,
                                  0,
                                  DestName,
                                  sizeof(DestName) / sizeof(TCHAR),
                                  NULL
                                  );

                            MessageBoxFromMessage(
                                        GetBBhwnd(),
                                        MSG_NO_UPGRADE_ALLOWED,
                                        FALSE,
                                        AppTitleStringId,
                                        MB_OK | MB_ICONWARNING | MB_TASKMODAL,
                                        DestName,
                                        SourceName
                                        );
#endif
                        } else {

                            MessageBoxFromMessage(
                                  GetBBhwnd(),
                                  MSG_CANT_UPGRADE_FROM_BUILD_NUMBER,
                                  FALSE,
                                  AppTitleStringId,
                                  MB_OK | MB_ICONWARNING | MB_TASKMODAL
                                  );
                        }
                    } else {
                        MessageBoxFromMessage(
                                      GetBBhwnd(),
                                      MSG_NO_UPGRADE_ALLOWED_GENERIC,
                                      FALSE,
                                      AppTitleStringId,
                                      MB_OKCANCEL | MB_ICONWARNING | MB_TASKMODAL
                                      );
                    }
                }
            }
        } else {
                CleanInstall = !UpgradeOnly;
        }

        //
        // Set install type combo box.
        //
        if (!UpgradeSupport.DllModuleHandle) {
            MYASSERT(!Upgrade);
        }

        //
        // Upgrade defaults to TRUE.  If it's set to FALSE, then assume
        // something has gone wrong, so disable the user's ability to
        // upgrade.
        //


        if (UpgradeOnly && !Upgrade) {
            //
            // in this case upgrade isn't possible, but neither is clean install
            // post an error message and bail.
            //

            MessageBoxFromMessage(
                                  GetBBhwnd(),
                                  MSG_NO_UPGRADE_OR_CLEAN,
                                  FALSE,
                                  AppTitleStringId,
                                  MB_OK | MB_ICONERROR | MB_TASKMODAL
                                  );
            Cancelled = TRUE;
            PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
            break;

        } else if (!Upgrade && WantToUpgrade && UnattendedOperation && !BuildCmdcons) {
            //
            // we can't do an upgrade and they wanted unattended upgrade.
            // let the user know and then bail out
            //
            //
            // don't warn again if winnt32 just restarted
            //
            if (!Winnt32Restarted ()) {
                TCHAR SourceName[200];
                UINT srcid, destid;
                TCHAR DestName[200];

                if (GetComplianceIds(
                        srcsku,
                        desttype,
                        destversion,
                        &srcid,
                        &destid) && (srcid != destid)) {
                    FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        hInst,
                        srcid,
                        0,
                        SourceName,
                        sizeof(SourceName) / sizeof(TCHAR),
                        NULL
                        );

                    FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        hInst,
                        destid,
                        0,
                        DestName,
                        sizeof(DestName) / sizeof(TCHAR),
                        NULL
                        );


                    MessageBoxFromMessage(
                                  GetBBhwnd(),
                                  MSG_NO_UNATTENDED_UPGRADE_SPECIFIC,
                                  FALSE,
                                  AppTitleStringId,
                                  MB_OK | MB_ICONWARNING | MB_TASKMODAL,
                                  DestName,
                                  SourceName
                                  );
                } else {
                    MessageBoxFromMessage(
                                      GetBBhwnd(),
                                      MSG_NO_UNATTENDED_UPGRADE,
                                      FALSE,
                                      AppTitleStringId,
                                      MB_OK | MB_ICONERROR | MB_TASKMODAL
                                      );
                }
            }

            //
            // let setup go if they did /CheckUpgradeOnly
            // so they can see the message in the report
            //
            if (!CheckUpgradeOnly) {
                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                break;
            }
        }

        MYASSERT(Upgrade || CleanInstall);
        {
            TCHAR szLoadText[MAX_STRING]; // need enclosing braces for this b/c of switch statement

            if (Upgrade)
            {
                if(LoadString(hInst,IDS_INSTALL_EXPRESS,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_INSERTSTRING, -1, (LPARAM)szLoadText);
                }
                else
                {
                    SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_INSERTSTRING, -1, (LPARAM)TEXT("Express Upgrade"));
                }
            } else {
                WantToUpgrade = FALSE;
            }

            if (CleanInstall)
            {
                if(LoadString(hInst,IDS_INSTALL_CUSTOM,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_INSERTSTRING, -1, (LPARAM)szLoadText);
                }
                else
                {
                    SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_INSERTSTRING, -1, (LPARAM)TEXT("Custom"));
                }
            }

            SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_SETCURSEL, 0, 0);


            ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_CLEAN), Upgrade?SW_HIDE:SW_SHOW);
            ShowWindow(GetDlgItem(hdlg, IDC_NOTE_CLEAN), Upgrade?SW_HIDE:SW_SHOW);
            ShowWindow(GetDlgItem(hdlg, IDC_NOTE_TEXT_UPG), Upgrade?SW_SHOW:SW_HIDE);
            ShowWindow(GetDlgItem(hdlg, IDC_NOTE_UPG), Upgrade?SW_SHOW:SW_HIDE);
            if (Upgrade)
            {
                dwSetupFlags |= UPG_FLAG_TYPICAL;
                if(LoadString(hInst,IDS_INSTALLTYPE_EXPRESS,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDT_INSTALLTYPE), WM_SETTEXT, 0, (LPARAM)szLoadText);
                }
            }
            else
            {
                dwSetupFlags &= (~UPG_FLAG_TYPICAL);
                if(LoadString(hInst,IDS_INSTALLTYPE_CUSTOM,szLoadText,sizeof(szLoadText) / sizeof(TCHAR)))
                {
                    SendMessage(GetDlgItem(hdlg, IDT_INSTALLTYPE), WM_SETTEXT, 0, (LPARAM)szLoadText);
                }
            }
        }


        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();

        if(wParam) {

            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                if (GetPrivateProfileString(
                        WINNT_UNATTENDED,
                        ISNT() ? WINNT_D_NTUPGRADE : WINNT_D_WIN95UPGRADE,
                        TEXT(""),
                        buffer,
                        sizeof(buffer) / sizeof(TCHAR),
                        g_DynUpdtStatus->RestartAnswerFile
                        )) {
                    Upgrade = !lstrcmpi (buffer, WINNT_A_YES);
                    if (!Upgrade) {
                        dwSetupFlags &= (~UPG_FLAG_TYPICAL);
                    }
                    return FALSE;
                }
            }
            //
            // Nothing to do. Advance page in unattended case.
            //
            if(UnattendedOperation && !CancelPending) {
                PostMessage (hdlg, WMX_UNATTENDED, PSBTN_NEXT, 0);
            }
            else
            {
                PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);
            }
        } else {
            //
            // Deactivation. Set state of upgrade based on radio buttons.
            //
            Upgrade = (0 == SendMessage(GetDlgItem(hdlg, IDC_INSTALLCOMBO), CB_GETCURSEL, 0, 0)) && WantToUpgrade;

            //
            // On upgrade, delete the setup log files.
            //
            if (Upgrade) {
                TCHAR   FilePath[MAX_PATH];

                MyGetWindowsDirectory( FilePath, MAX_PATH );
                ConcatenatePaths( FilePath, TEXT("setupact.log"), MAX_PATH);
                DeleteFile( FilePath );
                MyGetWindowsDirectory( FilePath, MAX_PATH );
                ConcatenatePaths( FilePath, TEXT("setuperr.log"), MAX_PATH);
                DeleteFile( FilePath );
            }
        }
        b = TRUE;
        break;

    case WMX_I_AM_VISIBLE:
        // Force repainting first to make sure the page is visible.
        //
        // Set the focus on the NEXT button, people were unintentionally 
        // changing the install type from upgrade to clean with wheel mouse
        SetFocus (GetDlgItem (GetParent(hdlg), 0x3024));
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


typedef BOOL (WINAPI *EnumProcessesFn)(DWORD * lpidProcess,
                                       DWORD   cb,
                                       DWORD * cbNeeded);

typedef BOOL (WINAPI *EnumProcessModulesFn)(HANDLE hProcess,
                                            HMODULE *lphModule,
                                            DWORD cb,
                                            LPDWORD lpcbNeeded);
#ifdef UNICODE
typedef DWORD (WINAPI *GetModuleBaseNameFn)(HANDLE hProcess,
                                            HMODULE hModule,
                                            LPWSTR lpBaseName,
                                            DWORD nSize);
#else
typedef DWORD (WINAPI *GetModuleBaseNameFn)(HANDLE hProcess,
                                            HMODULE hModule,
                                            LPSTR lpBaseName,
                                            DWORD nSize);
#endif // !UNICODE


#define DEF_PROCESSES_SIZE 1000
BOOL
pDoesProcessExist(
    IN LPCTSTR pProcessName
    )
{
    HMODULE hPSLib = NULL;
    EnumProcessesFn EnumProcesses;
    EnumProcessModulesFn EnumProcessModules;
    GetModuleBaseNameFn GetModuleBaseName;
    HANDLE  hProcess;
    HMODULE hModule;
    TCHAR   ProcessName[MAX_PATH];
    DWORD * pdwProcessesID = NULL;
    DWORD   dwBytesExist = 0;
    DWORD   dwBytesNeeded = 0;
    BOOL    bResult = FALSE;
    UINT    i;
    UINT    iLen;



    __try{
        hPSLib = LoadLibrary(TEXT("psapi.dll"));
        if(!hPSLib){
            __leave;
        }

        EnumProcesses = (EnumProcessesFn)GetProcAddress(hPSLib, "EnumProcesses");
        EnumProcessModules = (EnumProcessModulesFn)GetProcAddress(hPSLib, "EnumProcessModules");
        GetModuleBaseName = (GetModuleBaseNameFn)GetProcAddress(hPSLib,
                                                                "GetModuleBaseName"
#ifdef UNICODE
                                                                "W"
#else
                                                                "A"
#endif
                                                                );
        if(!EnumProcesses || !EnumProcessModules || !GetModuleBaseName){
            __leave;
        }

        do{
            if(pdwProcessesID){
                FREE(pdwProcessesID);
            }

            dwBytesExist += DEF_PROCESSES_SIZE;
            pdwProcessesID = (DWORD*)MALLOC(dwBytesExist);
            if(!pdwProcessesID){
                __leave;
            }

            if(!EnumProcesses(pdwProcessesID, dwBytesExist, &dwBytesNeeded)){
                __leave;
            }
        }while(dwBytesNeeded >= dwBytesExist);


        for(i = 0, iLen = dwBytesNeeded / sizeof(DWORD); i < iLen; i++){
            hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pdwProcessesID[i]);
            if(hProcess &&
               EnumProcessModules(hProcess, &hModule, sizeof(hModule), &dwBytesNeeded) &&
               GetModuleBaseName(hProcess, hModule, ProcessName, ARRAYSIZE(ProcessName)) &&
               !_tcsicmp(pProcessName, ProcessName)){
                CloseHandle(hProcess);
                bResult = TRUE;
                break;
            }
            CloseHandle(hProcess);
        }
    }
    __finally{
        if(pdwProcessesID){
            FREE(pdwProcessesID);
        }
        FreeLibrary(hPSLib);
    }

    return bResult;
}

INT_PTR
OptionsWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static BOOL bCopyFarEast = FALSE;
    static BOOL bUserSelectedCopyFarEast = FALSE;
    BOOL b;
    BOOL MultipleSource;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    TCHAR Buffer[4];
#ifdef RUN_SYSPARSE
    static BOOL FirstTime = TRUE;
#endif


    int status;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Enable autopartition picking feature only on personal and professional
        // when the user has not specified a /tempdrive and its not unattened mode
        //
        if (!Server && !UserSpecifiedLocalSourceDrive && !Upgrade && !UnattendedOperation) {
            ChoosePartition = FALSE;
        }

        b = FALSE;
        AccessibleMagnifier = pDoesProcessExist(TEXT("magnify.exe"));
        break;

    case WM_COMMAND:

        b = FALSE;
        //
        // Check for buttons.
        //
        if(HIWORD(wParam) == BN_CLICKED) {

            switch(LOWORD(wParam)) {

            case IDB_ACCESSIBILITY:

                DoAccessibility(hdlg);
                b = TRUE;
                break;

            case IDB_ADVANCED:

                DoOptions(hdlg);
                b = TRUE;
                break;
            case IDC_FAREAST_LANG:
                // Remember if the user put the check mark in it
                // If the control gets checked because a FE langauge was selected
                // windows does not send a BN_CLICKED message, so this does not get executed.
                bUserSelectedCopyFarEast = (IsDlgButtonChecked(hdlg,IDC_FAREAST_LANG) == BST_CHECKED);
                break;
            }
        }
        if(HIWORD(wParam) == CBN_SELCHANGE)
        {
            PrimaryLocale = (DWORD)SendDlgItemMessage( hdlg, IDC_COMBO1, CB_GETCURSEL, 0, 0 );
            // Only if we did not hide the window.
            // The window would be hidden if the current OS or the to be install language is
            // a FarEast Language.
            if (IsWindowVisible(GetDlgItem(hdlg,IDC_FAREAST_LANG)))
            {
                if (IsFarEastLanguage(PrimaryLocale))
                {
                    // User seleted a FarEast Language,
                    // Select the check box and diable it.
                    CheckDlgButton(hdlg,IDC_FAREAST_LANG,BST_CHECKED);
                    EnableWindow(GetDlgItem(hdlg,IDC_FAREAST_LANG), FALSE);
                }
                else
                {
                    // Don't change the check mark, if the user checked it.
                    if (!bUserSelectedCopyFarEast)
                    {
                        // User seleted a non FarEast Language,
                        // Unselect the check box and enable it.
                        CheckDlgButton(hdlg,IDC_FAREAST_LANG,BST_UNCHECKED);
                    }
                    EnableWindow(GetDlgItem(hdlg,IDC_FAREAST_LANG), TRUE);
                }
            }
        }
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();
#if defined PRERELEASE || defined PRERELEASE_IDWLOG
        if (wParam ){ // START IDWLOG. remove before ship

         TCHAR                 szDllPath[MAX_PATH];
         TCHAR                 szCommandString[MAX_PATH + 120];
         LPTSTR                lpDllPath;
         LPTSTR                lp;
         STARTUPINFO           si;
         PROCESS_INFORMATION   pi;
#ifdef PRERELEASE_IDWLOG
         BOOL RunFromSP = TRUE;
#else
         BOOL RunFromSP = FALSE;
#endif

         //Initialize for Prefix

         szDllPath[0]=0;

         //
         // Launch idwlog.exe from the same directory as winnt32.exe.
         // INTERNAL: Tool to track the health of the build.
         // Ignore errors, NOT INCLUDED IN THE RETAIL release.
         // Remove this code before shipping
         //
         if ( FALSE == BuildCmdcons ) {
            if ( GetModuleFileName (NULL, szDllPath, MAX_PATH)) {

               for (lp=NULL,lpDllPath=szDllPath; *lpDllPath; lpDllPath=CharNext(lpDllPath)) {
                  // the char '\' is never a lead byte
                  if (*lpDllPath == TEXT('\\')) {
                     lp = lpDllPath;
                  }
               }


               _tcscpy(lp ? lp+1 : szDllPath , TEXT("IDWLOG.EXE -1"));

               _tcscpy(szCommandString, szDllPath);

               // If this is an Upgrade.
               _tcscat(szCommandString, Upgrade ? TEXT(" upgrade") : TEXT(""));

               // If this is from a CD
               _tcscat(szCommandString, RunFromCD ? TEXT(" cdrom") : TEXT(""));

               // If this is a MSI install
               _tcscat(szCommandString, RunFromMSI? TEXT(" MSI") : TEXT(""));

               // If this is a SP install
               _tcscat(szCommandString, RunFromSP? TEXT(" sp_full") : TEXT(""));

               // Start new JoeHol code.
               _tcscat(szCommandString, TEXT(" Path="));
               _tcscat(szCommandString, NativeSourcePaths[0] );


               ZeroMemory(&si,sizeof(si));
               si.cb = sizeof(si);
               if (CreateProcess( NULL,
                                  szCommandString,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  0,
                                  NULL,
                                  NULL,
                                  &si,
                                  &pi)
                  ) {
                  CloseHandle(pi.hProcess);
                  CloseHandle(pi.hThread);
               }
            }
         }
      } // END IDWLOG
#endif // PRERELEASE

#ifdef RUN_SYSPARSE
        if (FirstTime && wParam && !NoSysparse && (FALSE == BuildCmdcons) && !IsWinPEMode()) { // START sysparse. remove before RTM

            TCHAR                 szCommandString[MAX_PATH + 125];
            LPTSTR                lpDllPath;
            LPTSTR                lp;
            STARTUPINFO           si;
            //
            // Launch sysparse.exe from the same directory as winnt32.exe.
            //
            FirstTime = FALSE;
            if ( GetModuleFileName (NULL, szCommandString, MAX_PATH+125)) {
               for (lp=NULL,lpDllPath=szCommandString; *lpDllPath; lpDllPath=CharNext(lpDllPath)) {
                  // the char '\' is never a lead byte
                  if (*lpDllPath == TEXT('\\')) {
                     lp = lpDllPath;
                  }
               }

               _tcscpy(lp ? lp+1 : szCommandString , TEXT("SYSPARSE.EXE /donotrun1 /donotrun2 /n sysparse /w c:\\ /x /l /o /1 NA /2 NA /3 NA /4 NA /5 NA /6 NA /7 NA /8 NA /9 1 /m /a"));

               ZeroMemory(&si,sizeof(si));
               si.cb = sizeof(si);
               if (CreateProcess( NULL,
                                  szCommandString,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  0,
                                  NULL,
                                  NULL,
                                  &si,
                                  &piSysparse)
                  ) {
               } else {
                   piSysparse.hProcess = NULL;
                   DebugLog(Winnt32LogInformation, TEXT("Warning: Could not start sysparse.exe"), 0 );
               }
            } else {
                DebugLog(Winnt32LogInformation, TEXT("Warning: Could not find sysparse.exe - make sure it exists along with winnt32.exe"), 0 );
            }

        }
#endif

        //
        // Read intl.inf for the language options dialog.  We only do this if
        // it's the first activation and there's not a regional settings section
        // in the answer file.
        //
        if (wParam && !IntlInfProcessed &&
            !GetPrivateProfileString(
                WINNT_REGIONALSETTINGS,
                NULL,
                TEXT(""),
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR),
                UnattendedScriptFile)) {

            if (ReadIntlInf( hdlg ))
            {
                InitLangControl(hdlg, bCopyFarEast);
            }
        }

        if( Upgrade || TYPICAL()) {

            return( FALSE );
        }

        b = TRUE;

        if(wParam) {

            if (Winnt32RestartedWithAF ()) {
                if (LoadAdvancedOptions (g_DynUpdtStatus->RestartAnswerFile) &&
                    LoadLanguageOptions (g_DynUpdtStatus->RestartAnswerFile) &&
                    LoadAccessibilityOptions (g_DynUpdtStatus->RestartAnswerFile)
                    ) {
                    return FALSE;
                }
            }

            //
            // Activation.
            //
            PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);
            ShowWindow( GetDlgItem(hdlg,IDC_ACCESS_ICON),   Upgrade ? SW_HIDE : SW_SHOW );
            ShowWindow( GetDlgItem(hdlg,IDT_LABEL1),        Upgrade ? SW_HIDE : SW_SHOW );
            ShowWindow( GetDlgItem(hdlg,IDB_ACCESSIBILITY), Upgrade ? SW_HIDE : SW_SHOW );

        } else {
            //
            // Deactivation.
            // Verify source if not canceling or backing up.  Stay here if the source
            // dir does not exist.
            //
            // Save so that we can init the checkbox to whatever this is.
            if (IsWindowVisible(GetDlgItem(hdlg,IDC_FAREAST_LANG)))
            {
                bCopyFarEast = (IsDlgButtonChecked(hdlg,IDC_FAREAST_LANG) == BST_CHECKED);
                SelectFarEastLangGroup(bCopyFarEast );
            }

            if (!Cancelled && lParam != PSN_WIZBACK) {
                //
                // Determine if source edit control is disabled.  If it is disabled
                // and the multiple source dirs are invalid, reset the wizard page.
                //

                MultipleSource = !(SourceCount == 1);
                b = InspectSources (hdlg);

                if (!b && MultipleSource) {
                   // Reset the wizard page
                    CallWindowProc ((WNDPROC)OptionsWizPage, hdlg, WM_INITDIALOG, 0, 0);
                }

            }
        }

        break;

    case WMX_I_AM_VISIBLE:
        //
        // In the unattended case, this page might get reactivated because of an error,
        // in which case we don't want to automatically continue because we could
        // get into an infinite loop.
        //
        if(!WizPage->PerPageData) {
            WizPage->PerPageData = 1;
            UNATTENDED(PSBTN_NEXT);
        }
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


INT_PTR
Working1WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    HWND Animation = GetDlgItem(hdlg,IDA_COMP_MAGNIFY);
    int status;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Load the avi resource for the animation.
        //
        Animate_Open(Animation,MAKEINTRESOURCE(IDA_COMP_MAGNIFY));

        //
        // Set the subtitle correctly if we're only inspecting.
        //
        if( CheckUpgradeOnly ) {
            SetDlgItemText(hdlg,IDT_SUBTITLE,(PTSTR)TEXT("") );
        }

        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:
        //
        // Start/stop the animation. In the activate case, also
        // start doing some meaningful work.
        //
        if(wParam) {
            DWORD ThreadId;

            Animate_Play(Animation,0,-1,-1);

            InspectionThreadHandle = CreateThread( NULL,
                                                   0,
                                                   InspectAndLoadThread,
                                                   hdlg,
                                                   0,
                                                   &ThreadId );

            if(InspectionThreadHandle) {
                b = TRUE;
                //
                // enable the billboard text if we can.
                // This will hide the wizard if the billboard text was enabled
                //
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
            } else {

                MessageBoxFromMessage(
                    hdlg,
                    MSG_OUT_OF_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                b = FALSE;
            }
        } else {
            Animate_Stop(Animation);
            b = TRUE;

            // Do schema version check for NT5 DCs
            // Do only if not already cancelled
            if (!Cancelled) {
                 // For NT5 DC upgrades, check for schema version match
                 if (Upgrade && ISNT() && IsNT5DC()) {
                     status  = CheckSchemaVersionForNT5DCs(hdlg);
                     if (status != DSCHECK_ERR_SUCCESS) {
                         // error in checking schema version for NT5 DCs.
                         // Setup cannot proceed, go to unsuccessful
                         // completion. all necessary message has already
                         // been raised
                         Cancelled = TRUE;
                         PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                         return( FALSE );
                     }
                 }
           }
        }
        break;

    case WMX_ERRORMESSAGEUP:
        //
        // Start/stop the animation control.
        //
        if(wParam) {
            Animate_Stop(Animation);
        } else {
            Animate_Play(Animation,0,-1,-1);
        }
        b = TRUE;
        break;

    case WMX_SETPROGRESSTEXT:
        //
        // lParam is the progress text.
        //
        SetDlgItemText(hdlg,IDT_WORKING,(PTSTR)lParam);
        b = TRUE;
        break;

    case WMX_INSPECTRESULT:

        //
        // We get here when the InspectionThread
        // sends us this message, so it's done.
        //
        if(InspectionThreadHandle) {
            CloseHandle(InspectionThreadHandle);
            InspectionThreadHandle = NULL;
        }

        if(Cancelled) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
        } else {

            if( !wParam ) {
                Cancelled = TRUE;
            }
            //
            // Advance or retreat.
            //
            PropSheet_SetWizButtons(
                GetParent(hdlg),
                wParam ? PSWIZB_NEXT : PSBTN_CANCEL
                );

            PropSheet_PressButton(
                GetParent(hdlg),
                wParam ? PSBTN_NEXT : PSBTN_CANCEL
                );
        }

        b = TRUE;
        break;

    default:

        b = FALSE;
        break;
    }

    return(b);
}


#ifdef _X86_
INT_PTR
FloppyWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    HWND Gauge = GetDlgItem(hdlg,IDC_PROGRESS);
    HANDLE ThreadHandle;
    DWORD ThreadId;

    b = FALSE;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Make sure the gas gauge is cleared out.
        //
        SendMessage(Gauge,PBM_SETPOS,0,0);

        //
        // Add border on NT3.51
        //
        if(OsVersion.dwMajorVersion < 4) {
            SetWindowLong(
                Gauge,
                GWL_STYLE,
                GetWindowLong(Gauge,GWL_STYLE) | WS_BORDER
                );
        }
        break;

    case WMX_ACTIVATEPAGE:
        if(wParam)
        {
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
            //
            // Activating. Only activate if we are supposed to create
            // boot floppies. Ask the floppy creation stuff how many total files
            // are to be copied and initialize the progress indicator.
            //
            if(!Floppyless) {

                if(!AddExternalParams(hdlg)) {
                    Cancelled = TRUE;
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    b = FALSE;
                    break;
                }

                SendMessage(hdlg,WMX_COPYPROGRESS,FloppyGetTotalFileCount(),0);

                ThreadHandle = CreateThread(
                                    NULL,
                                    0,
                                    FloppyWorkerThread,
                                    (PVOID)hdlg,
                                    0,
                                    &ThreadId
                                    );

                if(ThreadHandle) {
                    b = TRUE;
                } else {
                    //
                    // Can't get the copy thread going.
                    //
                    MessageBoxFromMessageAndSystemError(
                        hdlg,
                        MSG_CANT_START_COPYING,
                        GetLastError(),
                        AppTitleStringId,
                        MB_OK | MB_ICONWARNING
                        );

                    Cancelled = TRUE;
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                }
            }
        } else {
            //
            // Deactivating.
            //
            // No progress bar not progress text on the billboard
            SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
            b = TRUE;
        }
        break;

    case WMX_COPYPROGRESS:

        if(lParam) {
            //
            // Done copying. Advance to next page.
            //
            PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_NEXT);
            PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);

            // No progress bar not progress text on the billboard
            SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
        } else {
            if(wParam) {
                TCHAR buffer[MAX_PATH];
                //
                // This tells us how many files are to be copied.
                // Use it as an initialization message.
                //
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_SETRANGE,0,MAKELPARAM(0,wParam));
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_SETPOS,0,0);

                // Show progress text on the billboard
                if (!LoadString (
                        hInst,
                        IDS_BB_COPYING,
                        buffer,
                        sizeof(buffer)/sizeof(TCHAR)
                        )) {
                    buffer[0] = 0;
                }
                SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)buffer);
                // Show the progress gauge on the billboard
                SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);
                // forward the progress messages to the billboard progress bar
                SendMessage(GetParent(hdlg),WMX_PBM_SETRANGE,0,MAKELPARAM(0,wParam));
                SendMessage(GetParent(hdlg),WMX_PBM_SETPOS,0,0);

            } else {
                //
                // This is a simple tick.
                //
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_DELTAPOS,1,0);
                // Do the same to the billoard progress
                SendMessage(GetParent(hdlg),WMX_PBM_DELTAPOS,1,0);
            }
        }
        b = TRUE;
        break;
    }

    return(b);
}
#endif

// Then nummber below are actually a little different for each SKU.
#if DBG
#define ALWAYS_COPY (13419*1024)
#define LOCALSOURCE_COPY (655322 *1024)
#else
#define ALWAYS_COPY (5020*1024)
#define LOCALSOURCE_COPY (209507 *1024)
#endif

INT_PTR
CopyingWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    HWND Gauge = GetDlgItem(hdlg,IDC_PROGRESS);
    HANDLE ThreadHandle;
    DWORD ThreadId;
    static DWORD StartCopyTime;
    static DWORD NumFile = 0;

    switch(msg) {

    case WM_INITDIALOG:

        //
        // Make sure the gas gauge is cleared out.
        //
        SendMessage(Gauge,PBM_SETPOS,0,0);

        //
        // Add border on NT3.51
        //
        if(OsVersion.dwMajorVersion < 4) {
            SetWindowLong(
                Gauge,
                GWL_STYLE,
                GetWindowLong(Gauge,GWL_STYLE) | WS_BORDER
                );
        }

        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();

        if(wParam) {
            //
            // Activating -- initialize the source progress indicators and
            // start the copy thread. We do the source progress indicators here
            // to guarantee that the source count is right (it may fluctuate).
            //
            UINT i;

#ifdef _X86_
            //
            // Make sure we actually have something to copy.
            // Note that we'll always be copying for RISC.
            //
            if( (!MakeLocalSource) &&   // don't copy ~LS
                (!Floppyless) ) {       // don't copy ~BT

                DoPostCopyingStuff(hdlg);
                b = TRUE;
                break;
            }
#endif

//#ifdef _X86_
            //
            // Before copying, allow extensions to write changes to the
            // textmode params file.
            //
            // It's legal for them to set a cancelled flag during
            // this call, so we'll need to check for that too.  This
            // looks a little odd, but info.CancelledFlag points to
            // Cancelled.  So we need to execute this block if his
            // function returns FALSE, or if he's set the Cancelled
            // flag.  In either case, we behave the same, we set
            // the Cancelled flag and proceed with a cancel.
            //
            //
            if ( (!AddExternalParams(hdlg)) ||
                 (Cancelled == TRUE) ) {
                //
                // Failed... cancel!
                //
                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);

                b = FALSE;
                break;
            }
//#endif
            if(SourceCount == 1) {
                //
                // Single-source case gets no details or anything.
                //
                for(i=0; i<MAX_SOURCE_COUNT; i++) {
                    ShowWindow(GetDlgItem(hdlg,IDT_LABEL1+i),SW_HIDE);
                    ShowWindow(GetDlgItem(hdlg,IDT_SOURCE1+i),SW_HIDE);
                }
                ShowWindow(GetDlgItem(hdlg,IDS_DETAILS),SW_HIDE);

            } else {
                //
                // Show label and file for each source we're using.
                // Disable the others.
                //
                for(i=0; i<MAX_SOURCE_COUNT; i++) {

                    ShowWindow(GetDlgItem(hdlg,IDT_LABEL1+i),SW_SHOW);
                    EnableWindow(GetDlgItem(hdlg,IDT_LABEL1+i),(i < SourceCount));

                    ShowWindow(GetDlgItem(hdlg,IDT_SOURCE1+i),SW_SHOW);
                    SetDlgItemText(hdlg,IDT_SOURCE1+i,TEXT(""));
                }
                ShowWindow(GetDlgItem(hdlg,IDS_DETAILS),SW_SHOW);
            }

            //
            // Show more detailed copy progress gauge.
            //
            StartCopyTime = GetTickCount();
            if( DetailedCopyProgress ) {
                //
                // How much have we copied?
                //
                ShowWindow( GetDlgItem(hdlg,IDT_SIZE),SW_SHOW );
                EnableWindow( GetDlgItem(hdlg,IDT_SIZE), TRUE );
                ShowWindow( GetDlgItem(hdlg,IDT_SIZE2),SW_SHOW );
                SetDlgItemText(hdlg,IDT_SIZE2,TEXT("0"));

                //
                // How long have we been at this?
                //
                ShowWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME),SW_SHOW );
                EnableWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME), TRUE );
                ShowWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME2),SW_SHOW );
                SetDlgItemText(hdlg,IDT_ELAPSED_TIME2,TEXT("00:00:00") );

            } else {
                //
                // Hide the details.
                //
               ShowWindow( GetDlgItem(hdlg,IDT_SIZE),SW_HIDE);
               ShowWindow( GetDlgItem(hdlg,IDT_SIZE2),SW_HIDE);
               ShowWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME),SW_HIDE);
               ShowWindow( GetDlgItem(hdlg,IDT_ELAPSED_TIME2),SW_HIDE);
            }

            SendMessage(hdlg,WMX_COPYPROGRESS,GetTotalFileCount(),0);

            ThreadHandle = CreateThread(
                                NULL,
                                0,
                                StartCopyingThread,
                                (PVOID)hdlg,
                                0,
                                &ThreadId
                                );

            if(ThreadHandle) {
                b = TRUE;
            } else {
                //
                // Can't get the copy thread going.
                //
                MessageBoxFromMessageAndSystemError(
                    hdlg,
                    MSG_CANT_START_COPYING,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONWARNING
                    );

                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);

                b = FALSE;
            }
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);

        } else {
            //
            // Deactivating.
            //
            // No progress bar not progress text on the billboard
            SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
            b = TRUE;
        }
        break;

    case WMX_COPYPROGRESS:

        if(lParam) {
            //
            // Done copying. On x86, set up boot.ini (etc).
            // Also save NTFT stuff.
            // Advance to next page.
            //
            ThreadHandle = CreateThread(NULL,0,DoPostCopyingStuff,hdlg,0,&ThreadId);
            if(ThreadHandle) {
                CloseHandle(ThreadHandle);
            } else {
                //
                // Just do it synchronously. Might look a little ugly but at least
                // it will get done.
                //
                DoPostCopyingStuff(hdlg);
            }
        } else {
            if(wParam) {
                TCHAR buffer[MAX_PATH];
                //
                // This tells us how many files are to be copied.
                // Use it as an initialization message.
                //
                CurrentPhase = Phase_FileCopy;
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_SETRANGE,0,MAKELPARAM(0,wParam));
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_SETPOS,0,0);

                // Show progress text on the billboard
                if (!LoadString (
                        hInst,
                        IDS_BB_COPYING,
                        buffer,
                        sizeof(buffer)/sizeof(TCHAR)
                        )) {
                    buffer[0] = 0;
                }
                SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)buffer);
                // Show the progress gauge on the billboard
                SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);
                // forward the progress messages to the billboard progress bar
                SendMessage(GetParent(hdlg),WMX_PBM_SETRANGE,0,MAKELPARAM(0,wParam));
                SendMessage(GetParent(hdlg),WMX_PBM_SETPOS,0,0);
            } else {
                //
                // This is a simple tick.
                //
                SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_DELTAPOS,1,0);
                // forward the progress messages to the billboard progress bar
                SendMessage(GetParent(hdlg),WMX_PBM_DELTAPOS,1,0);
                //
                NumFile++;

                // Are giving the user detailed timings?
                //
                if( DetailedCopyProgress ) {
                TCHAR   MyString[256];
                DWORD   ElapsedTime = ((GetTickCount() - StartCopyTime) / 1000);

                    //
                    // Figure out elapsed time.
                    //
                    wsprintf( MyString, TEXT( "%02d:%02d:%02d" ),
                              (ElapsedTime / 3600),         // hours
                              ((ElapsedTime % 3600) / 60),  // minutes
                              (ElapsedTime % 60) );         // seconds
                    SetDlgItemText( hdlg, IDT_ELAPSED_TIME2, MyString );

                    //
                    // Figure out data throughput.
                    //
                    if (GetUserPrintableFileSizeString(
                                TotalDataCopied,
                                MyString,
                                sizeof(MyString)/sizeof(TCHAR))) {
                        SetDlgItemText( hdlg, IDT_SIZE2, MyString );
                    }
                }

            }
        }
        b = TRUE;
        break;

    case WMX_I_AM_DONE:
        //
        // Advance to next page or bail.
        //
        if(wParam) {
        TCHAR   MyString[256];
        TCHAR   Size[256];
        DWORD   ElapsedTime = ((GetTickCount() - StartCopyTime) / 1000);

            //
            // Figure out elapsed time.
            //
            if (GetUserPrintableFileSizeString(
                                        TotalDataCopied,
                                        Size,
                                        sizeof(Size)/sizeof(TCHAR))) {
                wsprintf( MyString, TEXT( "%s copied.  Elapsed time: %02d:%02d:%02d\r\n" ),
                          Size,                         // How much data did we copy?
                          (ElapsedTime / 3600),         // hours
                          ((ElapsedTime % 3600) / 60),  // minutes
                          (ElapsedTime % 60) );         // seconds

                //
                // Log our data throughput along with the time it took.
                //
                DebugLog( Winnt32LogInformation,
                      MyString,
                      0 );

            }

            PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_NEXT);
            PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        } else {
            Cancelled = TRUE;
            PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
        }

        // Set the remaining time to what ever is left for the other parts of setup.
        SetRemainingTime(CalcTimeRemaining(Phase_RestOfSetup));

        // Hide the billboard progress gauge.
        SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);

        b = TRUE;
        break;

    default:

        b = FALSE;
        break;
    }

    return(b);
}


INT_PTR
DoneWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
#define ID_REBOOT_TIMER         (10)

    BOOL        b = FALSE;
    PWSTR       p;
        static UINT Countdown;
    TCHAR Text[MAX_PATH];

    switch(msg) {

    case WM_INITDIALOG:

        Countdown = TIME_REBOOT * 10;
        SendDlgItemMessage( hdlg,
                            IDC_PROGRESS1,
                            PBM_SETRANGE,
                            0,
                            MAKELONG(0,Countdown) );
        SendDlgItemMessage( hdlg,
                            IDC_PROGRESS1,
                            PBM_SETSTEP,
                            1,
                            0 );
        SendDlgItemMessage( hdlg,
                            IDC_PROGRESS1,
                            PBM_SETPOS,
                            0,
                            0 );
        SetTimer( hdlg,
                  ID_REBOOT_TIMER,
                  100,
                  NULL );

        SetFocus(GetDlgItem(hdlg,IDNORESTART));

        return( FALSE );

    case WM_TIMER:

        if( Countdown )
            Countdown--;

        if( Cancelled == TRUE ) {

            //
            // Put a note in the debug log so that we know this was cancelled.
            //
            DebugLog (Winnt32LogInformation, NULL, MSG_WINNT32_CANCELLED);

            //
            // Clean up the timer.
            //
            KillTimer( hdlg, ID_REBOOT_TIMER );
            DeleteObject((HGDIOBJ)SendDlgItemMessage(hdlg,IDOK,BM_GETIMAGE,0,0));



        } else {
            if( Countdown ) {
                SendDlgItemMessage( hdlg,
                                    IDC_PROGRESS1,
                                    PBM_STEPIT,
                                    0,
                                    0 );
                SendMessage(GetParent(hdlg),WMX_PBM_STEPIT,0,0);
            } else {
                if( !CancelPending )
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
            }

        }

        b = TRUE;
        break;

    case WMX_ACTIVATEPAGE:
        if( BuildCmdcons ) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        }

        if( CheckUpgradeOnly ) {
            AutomaticallyShutDown = FALSE;
            return( FALSE );
        }

        DebugLog (Winnt32LogInformation,
            TEXT("AutomaticallyShutDown: <%1!u!>"), 0, AutomaticallyShutDown);

        if ( AutomaticallyShutDown ) {
            if(LoadString(hInst,IDS_BB_REBOOT_TXT,Text,sizeof(Text) / sizeof(TCHAR)))
            {
                COLORREF colGauge;
                HDC hdc = GetDC(hdlg);

                SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

                // See what color the grow bar should be for the reboot count down
                if ((UINT) GetDeviceCaps(hdc, BITSPIXEL) > 8)
                {
                    // High color
                    colGauge = RGB(255, 64, 0); // Orange
                }
                else
                {
                    // Low color
                    colGauge = RGB(255, 0, 0); // Red
                }
                ReleaseDC(hdlg, hdc);

                CurrentPhase = Phase_Reboot;
                if(!LoadString(hInst,IDS_ESC_TOCANCEL_REBOOT,Text,sizeof(Text) / sizeof(TCHAR)))
                {
                    *Text = TEXT('\0');
                }
                BB_SetInfoText(Text );   // Replace the ESC text
                StartStopBB(FALSE);         // Only stop the billoard text, don't make the wizard visibl

                // Show the grow bar on the billboard for the reboot count donw
                SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);
                // Set the color to some red
                SendMessage(GetParent(hdlg), WMX_PBM_SETBARCOLOR, 0, (LPARAM)colGauge);
                // Setup the growbar ont eh billboard for the reboot count down.
                SendMessage(GetParent(hdlg),WMX_PBM_SETRANGE,0,MAKELPARAM(0,Countdown));
                SendMessage(GetParent(hdlg),WMX_PBM_SETPOS,0,0);
                SendMessage(GetParent(hdlg),WMX_PBM_SETSTEP,1,0);
            }
        }
        //
        // Accept activation/deactivation.
        //
        b = TRUE;
        break;

    case WM_COMMAND:

        if((HIWORD(wParam) == BN_CLICKED) && (LOWORD(wParam) == IDNORESTART)) {
            AutomaticallyShutDown = FALSE;
            PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        } else {
            return(FALSE);
        }
        break;


    case WMX_QUERYCANCEL:
        AutomaticallyShutDown = FALSE;
        *(BOOL*)lParam = FALSE; // Don't cancel setup, just don't reboot.
        b = TRUE;
        PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        break;


    case WMX_FINISHBUTTON:
        //
        // If we get here then we have been successful.
        // No other case indicates overall success.
        //

        //
        // Clean up the timer.
        //
        KillTimer( hdlg, ID_REBOOT_TIMER );
        DeleteObject((HGDIOBJ)SendDlgItemMessage(hdlg,IDOK,BM_GETIMAGE,0,0));

        //
        // Let upgrade code do its cleanup.
        //
        if(UpgradeSupport.CleanupRoutine) {
            UpgradeSupport.CleanupRoutine();
        }

        GlobalResult = TRUE;
        b = TRUE;

        break;

    default:

        b = FALSE;
        break;
    }

    return(b);
}


INT_PTR
CleaningWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    HANDLE ThreadHandle;
    DWORD ThreadId;
    HWND Animation = GetDlgItem(hdlg,IDA_COMP_MAGNIFY);

    b = FALSE;
    switch(msg) {

    case WM_INITDIALOG:
        //
        // Load the avi resource for the animation.
        //
        Animate_Open(Animation,MAKEINTRESOURCE(IDA_COMP_MAGNIFY));
        break;

    case WMX_ACTIVATEPAGE:

        if(wParam) {
            //
            // Disable the wizard cancel button.
            //
            EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
            PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);

        } else {
            //
            // Kill the animation.
            //
            Animate_Stop(Animation);
        }
        b = TRUE;
        break;

    case WMX_I_AM_VISIBLE:

        Animate_Play(Animation,0,-1,-1);
        SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        //
        // Our inspection thread hasn't finished.  He'll be
        // looking for the 'Cancelled' flag and he'll stop processing
        // the infs (i.e. building the copylist) when he sees it.
        //
        // If we proceed before he exits though, winnt32.exe will unload
        // winnt32u.dll while our thread is running, causing an AV.  Let's
        // give him a reasonable amount of time to finish before we
        // proceed.
        //
        // On Alpha, we can also hit a race condition where we think we
        // need to clean up NVRAM but are still in the middle of writing
        // it (because it takes a really long time to write).  This
        // fixes that too.
        //
        if( InspectionThreadHandle ) {
            WaitForSingleObject( InspectionThreadHandle, 20 * (1000) );
            CloseHandle(InspectionThreadHandle);
            InspectionThreadHandle = NULL;
        }

        //
        // Start the restoration process.
        //
        ThreadHandle = CreateThread(
                            NULL,
                            0,
                            StartCleanup,
                            hdlg,
                            0,
                            &ThreadId
                            );

        if(ThreadHandle) {
            CloseHandle(ThreadHandle);
        } else {
            //
            // Just do it synchronously. It won't look pretty
            // but it will at least get done.
            //
            StartCleanup(hdlg);
        }

        b = TRUE;
        break;

    case WMX_I_AM_DONE:

        //
        // Cleanup is done. Press the next button to advance to
        // the next page.
        //
        PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_NEXT);
        PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        break;
    }

    return(b);
}


INT_PTR
NotDoneWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;

    b = FALSE;
    switch(msg) {

    case WMX_ACTIVATEPAGE:

        //
        // Accept activation/deactivation.
        //
        b = TRUE;

#if defined PRERELEASE || defined PRERELEASE_IDWLOG
        {
            TCHAR DllPath[MAX_PATH];
            TCHAR *p, *q;
            STARTUPINFO StartupInfo;
            PROCESS_INFORMATION ProcessInfo;
            TCHAR szCommand [MAX_PATH + 120];

         //
         // Cancel IDWLOG
         // Remove this code before shipping
         //
         if ( GetModuleFileName (NULL, DllPath, MAX_PATH)) {

            for (q=NULL,p=DllPath; *p; p=CharNext(p)) {
               // the char '\' is never a lead byte
               if (*p == TEXT('\\')) {
                  q = p;
               }
            }
              lstrcpy(q ? q+1 : DllPath,TEXT("IDWLOG.EXE -0"));
              lstrcpy(szCommand,DllPath);

              ZeroMemory(&StartupInfo,sizeof(StartupInfo));
              StartupInfo.cb = sizeof(StartupInfo);
              if(CreateProcess(NULL, szCommand,NULL,NULL,FALSE,0,NULL,NULL,&StartupInfo,&ProcessInfo)) {
                 CloseHandle(ProcessInfo.hProcess);
                 CloseHandle(ProcessInfo.hThread);
              }
            }

        }
#endif // PRERELEASE
#ifdef RUN_SYSPARSE
        if (!NoSysparse && (FALSE == BuildCmdcons)  && piSysparse.hProcess && !IsWinPEMode()) {
            DWORD ret;
            ret = WaitForSingleObject( piSysparse.hProcess, 0);
            if( ret != WAIT_OBJECT_0) {
                TerminateProcess( piSysparse.hProcess, ERROR_TIMEOUT);
                CloseHandle(piSysparse.hProcess);
                CloseHandle(piSysparse.hThread);
                piSysparse.hProcess = NULL;
                DebugLog(Winnt32LogInformation, TEXT("Warning: Sysparse.exe did not finish, killing process."), 0 );
            }
        }
#endif
        if (Aborted || CheckUpgradeOnly || BatchMode) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        }
        break;

    }

    return(b);
}


void SetRemainingTime(DWORD TimeInSeconds)
{
    DWORD Minutes;
    TCHAR MinuteString[MAX_PATH];
    TCHAR TimeLeft[MAX_PATH];
    Minutes = ((TimeInSeconds)/60) +1;
    if (Minutes > 1)
    {
        if(!LoadString(hInst,IDS_TIMEESTIMATE_MINUTES,MinuteString, MAX_PATH))
        {
            lstrcpy(MinuteString,TEXT("Installation will complete in %d minutes or less."));
        }
        wsprintf(TimeLeft, MinuteString, Minutes);
    }
    else
    {
        if(!LoadString(hInst,IDS_TIMEESTIMATE_LESSTHENONEMINUTE,TimeLeft, MAX_PATH))
        {
            lstrcpy(TimeLeft,TEXT("Installation will complete in less then 1 minute."));
        }
    }
    BB_SetTimeEstimateText(TimeLeft);
}

void SetTimeEstimates()
{

    SetupPhase[Phase_DynamicUpdate].Time = GetDynamicUpdateEstimate();
    if (CheckUpgradeOnly)
    {
        // In CheckUpgradeOnly, we don't copy files and do continue setup.
        // and it can only be set from the command line, so the user can not change.
        SetupPhase[Phase_FileCopy].Time = 0;
        SetupPhase[Phase_RestOfSetup].Time = 0;
    }
    else
    {
        SetupPhase[Phase_FileCopy].Time = GetFileCopyEstimate();

        if (!Upgrade)
        {
            SetupPhase[Phase_HwCompatDat].Time = 0;
            SetupPhase[Phase_UpgradeReport].Time = 0;
        }
        else
        {
            if (!ISNT())
            {
                // Is there a way to find out if we need to update the hwcomp.dat file?
                SetupPhase[Phase_HwCompatDat].Time = GetHwCompDatEstimate();

                SetupPhase[Phase_UpgradeReport].Time = GetUpgradeReportEstimate();
            }
        }
        // Calc the time for the rest of setup.
        // The Win9x migration varies depending on the registery size.
        // The GetRestOfSetupEstimate takes care of that.
        SetupPhase[Phase_RestOfSetup].Time = GetRestOfSetupEstimate();
    }
}

// Returns the time remaining starting with the current "Phase"
DWORD CalcTimeRemaining(UINT Phase)
{
    UINT i;
    DWORD Time = 0;
    for (i = Phase; i<= Phase_RestOfSetup; i++)
    {
        if (SetupPhase[i].OS & OsVersion.dwPlatformId)
        {
            Time += SetupPhase[i].Time;
        }
    }
    return Time;
}

INT_PTR TimeEstimateWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b = FALSE;
    switch(msg)
    {
        case WMX_ACTIVATEPAGE:
            if(wParam)
            {
                SetTimeEstimates();
                CurrentPhase = Phase_DynamicUpdate;
                RemainingTime = CalcTimeRemaining(CurrentPhase);
                SetRemainingTime(RemainingTime);
            }
            break;

        default:

            b = FALSE;
            break;
    }

    return(b);
}

INT_PTR SetNextPhaseWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b = FALSE;
    switch(msg)
    {
        case WMX_ACTIVATEPAGE:
            if(wParam)
            {
                CurrentPhase++;
                while ((!SetupPhase[CurrentPhase].Clean & !Upgrade) ||
                       !(SetupPhase[CurrentPhase].OS & OsVersion.dwPlatformId))
                {
                    CurrentPhase++;
                }
                RemainingTime = CalcTimeRemaining(CurrentPhase);
                SetRemainingTime(RemainingTime);
            }
            break;

        default:

            b = FALSE;
            break;
    }

    return(b);
}

void UpdateTimeString(DWORD RemainungTimeMsecInThisPhase,
                      DWORD *PreviousRemainingTime)
{
    // If the previous displayed time is 1 minute old, update the time remaining.
    if ((*PreviousRemainingTime >= 60000) && ((*PreviousRemainingTime - 60000) > RemainungTimeMsecInThisPhase))
    {
        // Substract one minute.
        RemainingTime -= 60;
        *PreviousRemainingTime = RemainungTimeMsecInThisPhase;
        SetRemainingTime(RemainingTime);
    }
}

DWORD GetHwCompDatEstimate()
{
    return TIME_HWCOMPDAT;
}

DWORD GetUpgradeReportEstimate()
{
    return TIME_UPGRADEREPORT ;
}

DWORD GetDynamicUpdateEstimate()
{
    return 0;
}

DWORD GetFileCopyEstimate()
{
    // dosnet.inf and the TempDirSpace512 numbers look ok.
    //
    DWORD TimeEstimate = 1;
    UINT u;
    TCHAR infPath[MAX_PATH];
    TCHAR CopyEstimate[100];
    TCHAR *p;
    BOOL bFound = FALSE;
    DWORD AlwaysCopy = 0;
    DWORD LocalCopy = 0;
    DWORD Time;
    //
    // Get the numbers from dosnet.inf
    //
    if (AlternateSourcePath[0])
    {
        lstrcpy(infPath,AlternateSourcePath);
        ConcatenatePaths(infPath,InfName,MAX_PATH);
        bFound = FileExists(infPath, NULL);
    }
    if (!bFound)
    {
        u = 0;
        do
        {
            lstrcpy(infPath,NativeSourcePaths[u]);
            ConcatenatePaths(infPath,InfName,MAX_PATH);
            bFound = FileExists(infPath, NULL);
            u++;
        } while ((u<=SourceCount) && !bFound);
    }

    if (bFound)
    {
        // Get the diskspace numbers. We use them to determine the copy size and
        // with that determine the time estimate.
        // We don't need to worry about the cluster size, we only want the byte
        // amount copied. Therefore the 512byte cluster is good enough.
        //
        GetPrivateProfileString(TEXT("DiskSpaceRequirements"), TEXT("TempDirSpace512"),
                                TEXT("0"),
                                CopyEstimate, sizeof(CopyEstimate)/sizeof(TCHAR),
                                infPath);
        //
        // Now get the separate diskspace numbers.
        // If we have a comma, then there are 2 values.
        p = _tcschr(CopyEstimate,TEXT(','));
        if (p)
        {
            // Get the second value
            p++;
            AlwaysCopy = _tcstoul(p,NULL,10);
        }
        LocalCopy = _tcstoul(CopyEstimate,NULL,10);

    }
    else
    {
        // If we could not find the file, use some value.
        // Setup should fail later when we need the file.
        //
        AlwaysCopy = ALWAYS_COPY;
        LocalCopy = LOCALSOURCE_COPY;
    }

    //
    // To avoid divide by zero exception, if we could not
    // calculate throughput, assume it to be the default.
    //
    if (!dwThroughPutSrcToDest) {
        dwThroughPutSrcToDest = DEFAULT_IO_THROUGHPUT;
    }

    if (AlwaysCopy >= dwThroughPutSrcToDest)
    {
        TimeEstimate = AlwaysCopy / dwThroughPutSrcToDest;
        if (TimeEstimate >= 1000)
        {
            TimeEstimate = (TimeEstimate / 1000) + 1;
        }
        else
        {
            TimeEstimate = 1;
        }
    }


    if (MakeLocalSource && (LocalCopy >= dwThroughPutSrcToDest))
    {
        Time = LocalCopy / dwThroughPutSrcToDest;
        if (Time >= 1000)
        {
            Time = (Time / 1000) + 1;
        }
        else
        {
            Time = 1;
        }
        TimeEstimate += Time;
    }
    TimeEstimate = TimeEstimate * 125/100; // Add 25% for other overhead

    wsprintf(infPath, TEXT("Throughput src - dest is %d bytes per msec\r\n"), dwThroughPutSrcToDest);
    DebugLog(Winnt32LogInformation,infPath,0 );
    wsprintf(infPath, TEXT("Throughput HD - HD is %d bytes per msec\r\n"), dwThroughPutHDToHD);
    DebugLog(Winnt32LogInformation,infPath,0 );
    wsprintf(infPath, TEXT("%d bytes copied, should take %d Sec\r\n"), AlwaysCopy+LocalCopy, TimeEstimate);
    DebugLog(Winnt32LogInformation,infPath,0 );
    return TimeEstimate;
}

LPTSTR WinRegisteries[] = { TEXT("system.dat"),
                            TEXT("User.dat"),
                            TEXT("classes.dat"),
                            TEXT("")};

DWORD GetRestOfSetupEstimate()
{
    DWORD dwTime = TIME_RESTOFSETUP;
    DWORD dwSize = 0;
    TCHAR szRegPath[MAX_PATH];
    TCHAR szRegName[MAX_PATH];
    LPTSTR pRegName = NULL;
    UINT    index = 0;
    HANDLE          hFind;
    WIN32_FIND_DATA FindData;

    if (!ISNT() && Upgrade)
    {
        DebugLog(Winnt32LogInformation, TEXT("Calculating registery size"), 0 );
        if (GetWindowsDirectory(szRegPath, MAX_PATH))
        {
            dwTime = 0; // We calculate the time from the registery size.
            while (*WinRegisteries[index])
            {
                lstrcpy(szRegName, szRegPath);
                ConcatenatePaths( szRegName, WinRegisteries[index], MAX_PATH);
                hFind = FindFirstFile(szRegName, &FindData);
                if (hFind != INVALID_HANDLE_VALUE)
                {
                    DebugLog (Winnt32LogInformation,
                              TEXT("%1 size is: %2!ld!"),
                              0,
                              szRegName,
                              FindData.nFileSizeLow
                              );
                    // Don't worry about the nFileSizeHigh,
                    // if that is used the registery is over 4GB
                    dwSize += FindData.nFileSizeLow;
                    FindClose(hFind);
                }
                index++;
            }
            if (dwSize > 3000000)
            {
                dwSize -= 3000000;
                dwTime += (dwSize/9000);
            }
            DebugLog (Winnt32LogInformation,
                      TEXT("Calculated time for Win9x migration = %1!ld! seconds"),
                      0,
                      dwTime + 120); // 120 = base time for Win9x migration
            // Now add the rest of time needed for setup.
            // This includes the base time we estimate for the Win9x migration (120 seconds)
            dwTime+= TIME_RESTOFSETUP;
        }
    }

    return dwTime;
}

#ifdef _X86_

ULONGLONG
pSystemTimeToFileTime64 (
    IN      PSYSTEMTIME SystemTime
    )
{
    FILETIME ft;
    ULARGE_INTEGER result;

    SystemTimeToFileTime (SystemTime, &ft);
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;

    return result.QuadPart;
}


INT_PTR
Win9xUpgradeReportPage (
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b = FALSE;
    INT mode;
    static BOOL getFromUi = FALSE;
    HKEY key;
    LONG rc;
    SYSTEMTIME lastReport;
    SYSTEMTIME currentTime;
    ULONGLONG lastReportIn100Ns;
    ULONGLONG currentTimeIn100Ns;
    ULONGLONG difference;
    DWORD size;

    switch(msg) {

    case WM_INITDIALOG:
        break;

    case WMX_ACTIVATEPAGE:

        if(wParam) {
            //
            // Activation case
            //

            if (ISNT() || !Upgrade) {
                return FALSE;
            }

            if (CheckUpgradeOnly || UnattendedOperation) {
                g_UpgradeReportMode = IDC_ALL_ISSUES;
                return FALSE;
            }

            //
            // Dynamic update -- fetch caller's selection from answer file
            //

            if (Winnt32RestartedWithAF ()) {
                g_UpgradeReportMode = GetPrivateProfileInt (
                                            WINNT_UNATTENDED,
                                            WINNT_D_REPORTMODE,
                                            0,
                                            g_DynUpdtStatus->RestartAnswerFile
                                            );

                if (g_UpgradeReportMode == IDC_CRITICAL_ISSUES ||
                    g_UpgradeReportMode == IDC_ALL_ISSUES ||
                    g_UpgradeReportMode == IDC_NO_REPORT
                    ) {
                    //
                    // We got our answer -- skip page
                    //

                    return FALSE;
                }
            }

            //
            // Check the registry to see if the report has been
            // generated recently.
            //

            rc = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                    0,
                    KEY_READ,
                    &key
                    );

            if (rc == ERROR_SUCCESS) {
                size = sizeof (lastReport);
                rc = RegQueryValueEx (
                        key,
                        TEXT("LastReportTime"),
                        NULL,
                        NULL,
                        (PBYTE) (&lastReport),
                        &size
                        );

                RegCloseKey (key);

                if (rc == ERROR_SUCCESS) {
                    //
                    // Compare current time to report time
                    //

                    GetSystemTime (&currentTime);

                    lastReportIn100Ns = pSystemTimeToFileTime64 (&lastReport);
                    currentTimeIn100Ns = pSystemTimeToFileTime64 (&currentTime);

                    if (currentTimeIn100Ns > lastReportIn100Ns) {
                        //
                        // Compute difference in seconds
                        //

                        difference = currentTimeIn100Ns - lastReportIn100Ns;
                        difference /= (10 * 1000 * 1000);

                        if (difference < (30 * 60)) {
                            //
                            // Report was saved less than 30 minutes ago
                            // from compatibility checker; don't show it again.
                            //

                            DebugLog (
                                Winnt32LogInformation,
                                TEXT("Not showing report because /checkupgradeonly ran %1!i! seconds ago"),
                                0,
                                (INT) difference
                                );

                            g_UpgradeReportMode = IDC_NO_REPORT;
                            return FALSE;
                        }
                    }
                }
            }

            //
            // Validate the selection
            //

            if (g_UpgradeReportMode != IDC_CRITICAL_ISSUES &&
                g_UpgradeReportMode != IDC_ALL_ISSUES &&
                g_UpgradeReportMode != IDC_NO_REPORT
                ) {
                g_UpgradeReportMode = IDC_CRITICAL_ISSUES;
            }

            //
            // Update the UI
            //

            CheckDlgButton (
                hdlg,
                IDC_CRITICAL_ISSUES,
                g_UpgradeReportMode == IDC_CRITICAL_ISSUES ? BST_CHECKED : BST_UNCHECKED
                );

            CheckDlgButton (
                hdlg,
                IDC_ALL_ISSUES,
                g_UpgradeReportMode == IDC_ALL_ISSUES ? BST_CHECKED : BST_UNCHECKED
                );

            CheckDlgButton (
                hdlg,
                IDC_NO_REPORT,
                g_UpgradeReportMode == IDC_NO_REPORT ? BST_CHECKED : BST_UNCHECKED
                );

            SetFocus (GetDlgItem (hdlg, g_UpgradeReportMode));
            getFromUi = TRUE;

        } else {
            //
            // Deactivation case
            //

            if (!getFromUi) {
                return TRUE;
            }

            //
            // Get selection from UI
            //

            if (IsDlgButtonChecked (hdlg, IDC_CRITICAL_ISSUES) == BST_CHECKED) {
                g_UpgradeReportMode = IDC_CRITICAL_ISSUES;
            } else if (IsDlgButtonChecked (hdlg, IDC_ALL_ISSUES) == BST_CHECKED) {
                g_UpgradeReportMode = IDC_ALL_ISSUES;
            } else if (IsDlgButtonChecked (hdlg, IDC_NO_REPORT) == BST_CHECKED) {
                g_UpgradeReportMode = IDC_NO_REPORT;
            }

            getFromUi = FALSE;
        }

        b = TRUE;
        break;
    }

    return(b);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\amd64\bootflop.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bootflop.c

Abstract:

    Routines to create setup boot floppies.

Author:

    Ted Miller (tedm) 21 November 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define bpb structure.
//
#include <pshpack1.h>
typedef struct _MY_BPB {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  FatCount;
    USHORT RootDirectoryEntries;
    USHORT SectorCountSmall;
    UCHAR  MediaDescriptor;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT HeadCount;
} MY_BPB, *PMY_BPB;
#include <poppack.h>



BOOL
pFloppyGetDiskInDrive(
    IN HWND    ParentWindow,
    IN LPCTSTR FloppyName,
    IN BOOL    SpecialFirstPrompt,
    IN BOOL    WriteNtBootSector,
    IN BOOL    MoveParamsFileToFloppy
    );



UINT
FloppyGetTotalFileCount(
    VOID
    )

/*++

Routine Description:

    Determine how many files total are to be copied to all boot floppies,
    based on count of lines in [FloppyFiles.x] sections in dosnet.inf.

Arguments:

    None.

Return Value:

    Count of files.

--*/

{
    TCHAR SectionName[100];
    UINT u;
    UINT Count;
    LONG l;

    Count = 0;
    for(u=0; u<FLOPPY_COUNT; u++) {

        wsprintf(SectionName,TEXT("FloppyFiles.%u"),u);

        l = InfGetSectionLineCount(MainInf,SectionName);
        if(l != -1) {
            Count += (UINT)l;
        }
    }

    return(Count);
}


DWORD
FloppyWorkerThread(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    Create setup boot floppies.

Arguments:

    Standard thread routine arguments.

Return Value:

    Nothing meaningful.

--*/

{
    TCHAR SectionName[100];
    TCHAR FloppyName[200];
    TCHAR Buffer[150];
    TCHAR SourceName[MAX_PATH];
    TCHAR TargetName[MAX_PATH];
    TCHAR CompressedSourceName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    LPCTSTR Directory;
    LPCTSTR p,q;
    LPTSTR r;
    UINT Floppy;
    LONG Count;
    LONG Line;
    DWORD d;
    HWND ParentWindow;
    BOOL FirstPrompt;
    BOOL TryCompressedFirst;

    ParentWindow = (HWND)ThreadParameter;
    FirstPrompt = TRUE;
    TryCompressedFirst = FALSE;

    //
    // Do the floppies backwards so the boot floppy is in the drive
    // when we're done.
    //
    for(Floppy=FLOPPY_COUNT; Floppy>0; Floppy--) {

        wsprintf(SectionName,TEXT("FloppyFiles.%u"),Floppy-1);

        //
        // Special case the name of the first floppy.
        //
        if(Floppy>1) {
            LoadString(
                hInst,
                Server ? IDS_FLOPPY_N_SRV : IDS_FLOPPY_N_WKS,
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR)
                );

            wsprintf(FloppyName,Buffer,Floppy);

        } else {
            LoadString(
                hInst,
                Server ? IDS_BOOTFLOP_SRV : IDS_BOOTFLOP_WKS,
                FloppyName,
                sizeof(FloppyName)/sizeof(TCHAR)
                );
        }

        //
        // Get the floppy in the drive.
        //
        if(!pFloppyGetDiskInDrive(ParentWindow,FloppyName,FirstPrompt,Floppy==1,Floppy==1)) {
            PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
            return(FALSE);
        }

        //
        //  Create the file that contains drive letter information (migrate.inf)
        //
        if((Floppy == 1) && ISNT()){
            if(!GetAndSaveNTFTInfo(ParentWindow)) {
                PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
                return(FALSE);
            }
        }

        FirstPrompt = FALSE;

        Count = InfGetSectionLineCount(MainInf,SectionName);
        if(Count == -1) {
            continue;
        }

        //
        // Do each file in the list for this floppy.
        // Since the target is a floppy, we don't bother with multithread copies,
        // all files come from source 0.
        //
        for(Line=0; Line<Count; Line++) {

            Directory = InfGetFieldByIndex(MainInf,SectionName,Line,0);
            p = InfGetFieldByIndex(MainInf,SectionName,Line,1);
            if(p && (Directory = InfGetFieldByKey(MainInf,TEXT("Directories"),Directory,0))) {

                lstrcpy(SourceName,SourcePaths[0]);
                ConcatenatePaths(SourceName,Directory,MAX_PATH);
                ConcatenatePaths(SourceName,p,MAX_PATH);

                q = InfGetFieldByIndex(MainInf,SectionName,Line,2);

                TargetName[0] = FirstFloppyDriveLetter;
                TargetName[1] = TEXT(':');
                TargetName[2] = 0;
                ConcatenatePaths(TargetName,q ? q : p,MAX_PATH);

                //
                // Create any subdirectory if necessary
                //
                if((r = _tcsrchr(TargetName,TEXT('\\'))) && ((r-TargetName) > 3)) {
                    *r = 0;
                    d = CreateMultiLevelDirectory(TargetName);
                    *r = TEXT('\\');
                } else {
                    d = NO_ERROR;
                }

                if(d == NO_ERROR) {

                    if(TryCompressedFirst) {

                        GenerateCompressedName(SourceName,CompressedSourceName);

                        FindHandle = FindFirstFile(CompressedSourceName,&FindData);

                        if(FindHandle != INVALID_HANDLE_VALUE) {
                            FindClose(FindHandle);
                            lstrcpy(SourceName,CompressedSourceName);
                            GenerateCompressedName(TargetName,FindData.cFileName);
                            lstrcpy(TargetName,FindData.cFileName);
                        } else {
                            FindHandle = FindFirstFile(SourceName,&FindData);
                            if(FindHandle != INVALID_HANDLE_VALUE) {
                                FindClose(FindHandle);
                                TryCompressedFirst = FALSE;
                            }
                        }
                    } else {

                        FindHandle = FindFirstFile(SourceName,&FindData);

                        if(FindHandle != INVALID_HANDLE_VALUE) {
                            FindClose(FindHandle);
                        } else {
                            GenerateCompressedName(SourceName,CompressedSourceName);
                            FindHandle = FindFirstFile(CompressedSourceName,&FindData);
                            if(FindHandle != INVALID_HANDLE_VALUE) {

                                FindClose(FindHandle);
                                lstrcpy(SourceName,CompressedSourceName);
                                GenerateCompressedName(TargetName,FindData.cFileName);
                                lstrcpy(TargetName,FindData.cFileName);
                            }
                        }
                    }

                    d = CopyFile(SourceName,TargetName,FALSE) ? NO_ERROR : GetLastError();

                    //
                    // Retry once to overcome transient net glitches.
                    //
                    if((d != NO_ERROR) && (d != ERROR_FILE_NOT_FOUND)
                    && (d != ERROR_PATH_NOT_FOUND) && (d != ERROR_WRITE_PROTECT)) {

                        Sleep(350);
                        d = CopyFile(SourceName,TargetName,FALSE) ? NO_ERROR : GetLastError();
                    }
                }

                if(d == NO_ERROR) {
                    //
                    // Tell main thread that another file is done.
                    //
                    SendMessage(ParentWindow,WMX_COPYPROGRESS,0,0);

                } else {

                    switch(FileCopyError(ParentWindow,SourceName,TargetName,d,FALSE)) {

                    case COPYERR_SKIP:
                        //
                        // Tell main thread that another file is done.
                        //
                        SendMessage(ParentWindow,WMX_COPYPROGRESS,0,0);
                        break;

                    case COPYERR_EXIT:
                        //
                        // We're outta here.
                        //
                        PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
                        return(FALSE);
                        break;

                    case COPYERR_RETRY:
                        //
                        // Little hack to retry the current line.
                        //
                        Line--;
                        break;
                    }
                }
            }
        }

    }

    //
    // Send message indicating completion.
    //
    SendMessage(ParentWindow,WMX_COPYPROGRESS,0,1);
    return(TRUE);
}


BOOL
pFloppyGetDiskInDrive(
    IN HWND    ParentWindow,
    IN LPCTSTR FloppyName,
    IN BOOL    SpecialFirstPrompt,
    IN BOOL    WriteNtBootSector,
    IN BOOL    MoveParamsFileToFloppy
    )

/*++

Routine Description:

    This routine prompts the user to insert a floppy disk and verifies that
    the disk is blank, etc.

Arguments:

    ParentWindow - supplies the window handle of the window to be the
        owner/parent for ui that this routine will display.

    FloppyName - supplies human-readable name of the floppy, used in prompting.

    SpecialFirstPrompt - if TRUE then this routine assumes that a special prompt
        should be used, that is suitable to be the first prompt the user sees
        for any floppies.

    WriteNtBootSector - if TRUE then an NT boot sector is written to the disk.

Return Value:

    TRUE if the disk is in the drive. FALSE means the program should exit.

--*/

{
    int i;
    BOOL b;
    BYTE BootSector[512];
    BYTE NewBootSector[512];
    TCHAR SourceName[MAX_PATH];
    TCHAR TargetName[MAX_PATH];
    DWORD d;
    PMY_BPB p;
    DWORD spc,bps,freeclus,totclus;

    //
    // Issue the prompt.
    //
    reprompt:
    i = MessageBoxFromMessage(
            ParentWindow,
            SpecialFirstPrompt ? MSG_FIRST_FLOPPY_PROMPT : MSG_GENERIC_FLOPPY_PROMPT,
            FALSE,
            AppTitleStringId,
            MB_OKCANCEL | MB_ICONEXCLAMATION,
            FloppyName,
            FLOPPY_COUNT
            );

    if(i == IDCANCEL) {
        //
        // Confirm.
        //
        i = MessageBoxFromMessage(
                ParentWindow,
                MSG_SURE_EXIT,
                FALSE,
                AppTitleStringId,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2
                );

        if(i == IDYES) {
            Cancelled = TRUE;
            return(FALSE);
        }
        goto reprompt;
    }

    //
    // Inspect the floppy. Start by reading the boot sector off the disk.
    //
    b = ReadDiskSectors(FirstFloppyDriveLetter,0,1,512,BootSector);
    if(!b) {
        d = GetLastError();
        if((d == ERROR_SHARING_VIOLATION) || (d == ERROR_ACCESS_DENIED)) {
            //
            // Another app is using the drive.
            //
            MessageBoxFromMessage(
                ParentWindow,
                MSG_FLOPPY_BUSY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );
        } else {
            //
            // Read error -- assume no floppy is inserted or it's unformatted
            //
            MessageBoxFromMessage(
                ParentWindow,
                MSG_FLOPPY_BAD_FORMAT,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );
        }

        goto reprompt;
    }

    //
    // Sanity check on the boot sector. Note that on PC98 there is no
    // 55aa sig on a disk formatted by DOS5.0.
    //
    p = (PMY_BPB)&BootSector[11];
    if((BootSector[0] != 0xeb) || (BootSector[2] != 0x90)
    || (!IsNEC98() && ((BootSector[510] != 0x55) || (BootSector[511] != 0xaa)))
    || (p->BytesPerSector != 512)
    || ((p->SectorsPerCluster != 1) && (p->SectorsPerCluster != 2))     // 2.88M disks have 2 spc
    || (p->ReservedSectors != 1)
    || (p->FatCount != 2)
    || !p->SectorCountSmall                                             // <32M uses the 16-bit count
    || (p->MediaDescriptor != 0xf0)
    || (p->HeadCount != 2)
    || !p->RootDirectoryEntries) {

        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_BAD_FORMAT,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    //
    // Get the free space on the disk. Make sure it's blank, by which we mean
    // that is has as much free space on it as a 1.44MB floppy would usually have
    // immediately after formatting.
    //
    SourceName[0] = FirstFloppyDriveLetter;
    SourceName[1] = TEXT(':');
    SourceName[2] = TEXT('\\');
    SourceName[3] = 0;
    if(!GetDiskFreeSpace(SourceName,&spc,&bps,&freeclus,&totclus)) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_CANT_GET_SPACE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    if((freeclus * spc * bps) < 1457664) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_NOT_BLANK,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    if(WriteNtBootSector) {
        extern BYTE FatBootCode[512];
        extern BYTE PC98FatBootCode[512];

        CopyMemory(NewBootSector,IsNEC98() ? PC98FatBootCode : FatBootCode,512);

        //
        // Copy the BPB we retreived for the disk into the bootcode template.
        // We only care about the original BPB fields, through the head count
        // field.  We will fill in the other fields ourselves.
        //
        strncpy(NewBootSector+3,"MSDOS5.0",8);
        CopyMemory(NewBootSector+11,BootSector+11,sizeof(MY_BPB));

        //
        // Set up other fields in the bootsector/BPB/xBPB.
        //
        // Large sector count (4 bytes)
        // Hidden sector count (4 bytes)
        // current head (1 byte, not necessary to set this, but what the heck)
        // physical disk# (1 byte)
        //
        ZeroMemory(NewBootSector+28,10);

        //
        // Extended BPB signature
        //
        NewBootSector[38] = 41;

        //
        // Serial number
        //
        *(DWORD UNALIGNED *)(NewBootSector+39) = ((GetTickCount() << 12)
                                               | ((GetTickCount() >> 4) & 0xfff));

        //
        // volume label/system id
        //
        strncpy(NewBootSector+43,"NO NAME    ",11);
        strncpy(NewBootSector+54,"FAT12   ",8);

        //
        // Overwrite the 'ntldr' string with 'setupldr.bin' so the right file gets
        // loaded when the floppy is booted.
        //
        for(i=499; i>0; --i) {
            if(!memcmp("NTLDR      ",NewBootSector+i,11)) {
                strncpy(NewBootSector+i,"SETUPLDRBIN",11);
                break;
            }
        }

        //
        // Write it out.
        //
        b = WriteDiskSectors(FirstFloppyDriveLetter,0,1,512,NewBootSector);
        if(!b) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_CANT_WRITE_FLOPPY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );

            goto reprompt;
        }
    }

    if(MoveParamsFileToFloppy) {

        wsprintf(SourceName,TEXT("%c:\\%s"),SystemPartitionDriveLetter,WINNT_SIF_FILE);
        wsprintf(TargetName,TEXT("%c:\\%s"),FirstFloppyDriveLetter,WINNT_SIF_FILE);

        SetFileAttributes(TargetName,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(TargetName);
        if(!MoveFile(SourceName,TargetName)) {

            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_CANT_MOVE_FILE_TO_FLOPPY,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR,
                SystemPartitionDriveLetter,
                WINNT_SIF_FILE
                );

            goto reprompt;
        }
    }

    //
    // Floppy seems OK.
    //
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\winnt32.c ===
#include "precomp.h"
#pragma hdrstop
#if defined(_X86_) //NEC98 I970721
#include <stdlib.h>
#include <stdio.h>
#include <winbase.h>
#include <n98boot.h>
#endif // PC98

#include <pencrypt.h>
#include <winsta.h>
#include <ntverp.h>
#include <undo.h>
#include "errorrep.h"
#include "faulth.h"

void PrepareBillBoard(HWND hwnd);
void TerminateBillBoard();
void CreateMainWindow();
UINT GetMediaProductBuildNumber (VOID);
void CopyExtraBVTDirs();

HWND BackgroundWnd2 = NULL;

//
// Misc globals.
//
HINSTANCE hInst;
DWORD TlsIndex;

//
// Upgrade information block
//

WINNT32_PLUGIN_INIT_INFORMATION_BLOCK info;



#ifdef _X86_
PWINNT32_PLUGIN_SETAUTOBOOT_ROUTINE W95SetAutoBootFlag;
WINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK Win9xInfo;
#endif

//
// This is the title of the application. It changes dynamically depending on
// whether we're on server or workstation, etc.
//
UINT AppTitleStringId = IDS_APPTITLE;

//
// Flag indicating whether we are initiating an MSI-install.
//
BOOL RunFromMSI = FALSE;

//
// Flag indicating whether we are initiating an Typical install
// Initialize to Typical install.
DWORD dwSetupFlags = UPG_FLAG_TYPICAL;
//
// Flag indicating whether we are initiating an upgrade.
//
BOOL Upgrade = TRUE;

//
// Flag to say if we need to write the AcpiHAL value to the winnt.sif file
//
BOOL WriteAcpiHalValue = FALSE;

//
// What should we write as the value for the AcpiHalValue
//
BOOL AcpiHalValue = FALSE;

//
// Flag indicating whether we're installing/upgrading to NT Server
//
BOOL Server;

//
// Flag to indicate if we are running BVT's
//
BOOL RunningBVTs = FALSE;

//
// When running BVT's, what baudrate should we set the debugger to?
//
LONG lDebugBaudRate = 115200;

//
// When running BVT's, what comport should we set the debugger to?
//
LONG lDebugComPort = 0;

//
// When running BVT's, should we copy the symbols locally?
//
BOOL CopySymbols = TRUE;

//
// Flag to indicate if we are running ASR tests
//
DWORD AsrQuickTest = 0;

//
// Flags for product type and flavor for upgrade modules
//

PRODUCTTYPE UpgradeProductType = UNKNOWN;
UINT ProductFlavor = UNKNOWN_PRODUCTTYPE;

//
// Global flag indicating whether the entire overall program operation
// was successful. Also a flag indicating whether to shut down automatically
// when the wizard is done in the non-unattended case.
//
BOOL GlobalResult = FALSE;
BOOL AutomaticallyShutDown = TRUE;

//
// Global OS version info.
//
OSVERSIONINFO OsVersion;
DWORD OsVersionNumber = 0;


//
// Flags indicating how we were run and whether to create
// a local source.
//
BOOL RunFromCD;
BOOL MakeLocalSource;
BOOL UserSpecifiedMakeLocalSource = FALSE;
BOOL NoLs = FALSE;
TCHAR UserSpecifiedLocalSourceDrive;
//
// the default for MLS is CD1 only
//
DWORD MLSDiskID = 1;

//
// advanced install options
//
BOOL ChoosePartition = TRUE;
BOOL UseSignatures = TRUE;
TCHAR InstallDir[MAX_PATH];

//
// SMS support
//
typedef DWORD (*SMSPROC) (char *, char*, char*, char*, char *, char *, char *, BOOL);
PSTR LastMessage = NULL;

#if defined(REMOTE_BOOT)
//
// Flag indicating whether we're running on a remote boot client.
//
BOOL RemoteBoot;

//
// Path to the machine directory for a remote boot client.
//
TCHAR MachineDirectory[MAX_PATH];
#endif // defined(REMOTE_BOOT)

//
// Flags indicating which Accessibility utilities to use
//
BOOL AccessibleMagnifier;
BOOL AccessibleKeyboard;
BOOL AccessibleVoice;
BOOL AccessibleReader;

//
// Build number we're upgrading from
//
DWORD BuildNumber = 0;

//
// Are any of the Accesssibility utilities enabled?
//
BOOL AccessibleSetup;

//
// Name of unattended script file to be used for Accessible Setup
//
TCHAR AccessibleScriptFile[MAX_PATH] = TEXT("setupacc.txt");

//
// Flags and values relating to unattended operation.
//
BOOL UnattendedOperation;
BOOL UnattendSwitchSpecified = FALSE;
PTSTR UnattendedScriptFile;
UINT UnattendedShutdownTimeout;
BOOL BatchMode;

//
// Source paths and count of paths.
//
TCHAR SourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
UINT SourceCount;

//
// source paths to current architecture's files
//
TCHAR NativeSourcePaths[MAX_SOURCE_COUNT][MAX_PATH];

TCHAR *UserSpecifiedOEMShare = NULL;

//
// Local source information.
//
TCHAR LocalSourceDrive;
DWORD LocalSourceDriveOffset;
TCHAR LocalSourceDirectory[MAX_PATH];
TCHAR LocalSourceWithPlatform[MAX_PATH];
TCHAR LocalBootDirectory[MAX_PATH];
#ifdef _X86_
TCHAR LocalBackupDirectory[MAX_PATH];
TCHAR FirstFloppyDriveLetter;
#endif



LONGLONG LocalSourceSpaceRequired;
LONGLONG WinDirSpaceFor9x = 0l;
BOOL BlockOnNotEnoughSpace = TRUE;
UINT UpgRequiredMb;
UINT UpgAvailableMb;
BOOL UpginfsUpdated = FALSE;

//
// Optional directory stuff.
//
UINT OptionalDirectoryCount;
TCHAR OptionalDirectories[MAX_OPTIONALDIRS][MAX_PATH];
UINT OptionalDirectoryFlags[MAX_OPTIONALDIRS];

//
// Name of INF. Constructed so we don't have to realloc anything.
// Note the default.
// Also, handles to dosnet.inf and txtsetup.sif.
//
TCHAR InfName[] = TEXT("DOSNET.INF");
PVOID MainInf;
TCHAR FullInfName[MAX_PATH];
PVOID TxtsetupSif;
PVOID NtcompatInf;

//
// Array of drive letters for all system partitions.
// Note that on x86 there will always be exactly one.
// The list is 0-terminated.
//
TCHAR SystemPartitionDriveLetters[27];
TCHAR SystemPartitionDriveLetter;

#ifdef UNICODE
UINT SystemPartitionCount;
PWSTR* SystemPartitionNtNames;
PWSTR SystemPartitionNtName;
#else
//
// if running on Win9x, there may be a LocalSourcePath passed as parameter
//
PCSTR g_LocalSourcePath;
#endif

//
// UDF stuff
//
LPCTSTR UniquenessId;
LPCTSTR UniquenessDatabaseFile;

//
// Variables relating to the multi string of options that are passed
// to plugin DLLs (Like Win9xUpg)
//
LPTSTR  UpgradeOptions;
DWORD   UpgradeOptionsLength;
DWORD   UpgradeOptionsSize;


//
// Compliance related variables
//
BOOL    NoCompliance = FALSE;

//
// Variables to hold messages concerning reason that the upgrade cannot be completed.
//
#define MSG_UPGRADE_OK 0
#define MSG_LAST_REASON 0
#define FAILREASON(x) MSG_##x,
DWORD UpgradeFailureMessages[] = {
    UPGRADEFAILURES /*,*/ MSG_UPGRADE_INIT_ERROR
};
#undef FAILREASON

UINT UpgradeFailureReason = 0;


TCHAR UpgradeSourcePath[MAX_PATH];



//
// Internal override to version checking. Useful for making quick
// privates for foreign language versions.
//
BOOL SkipLocaleCheck = FALSE;

//
// override for the win9x virus scanner check.
//
BOOL SkipVirusScannerCheck = FALSE;

BOOL UseBIOSToBoot = FALSE;

//
// Preinstall stuff
//
BOOL OemPreinstall;
#ifdef _X86_
POEM_BOOT_FILE OemBootFiles;
#endif

//
// Miscellaneous other command line parameters.
//
LPCTSTR CmdToExecuteAtEndOfGui;
BOOL AutoSkipMissingFiles;
BOOL HideWinDir;
TCHAR ProductId[64] = TEXT("\0");
UINT  PIDDays = 0;
LPTSTR g_EncryptedPID = NULL;
BOOL g_bDeferPIDValidation = FALSE;

//
// Flag indicating that the user cancelled.
// Handle for mutex used to guarantee that only one error dialog
// is on the screen at once.
//
BOOL Cancelled;
HANDLE UiMutex;

//
// Flag indicating user is aborting. This flag suppresses the final screen in
// cancel mode. I.E. The unsuccssessful completion page.
// win9xupg ReportOnly mode.
//
BOOL Aborted;

//
// Floppy-related stuff.
// Defined, but not used for ARC based machines.
//
BOOL MakeBootMedia = TRUE;
BOOL Floppyless = TRUE;

//
// Upgrade extension DLL.
//
UPGRADE_SUPPORT UpgradeSupport;

//
// Only check to see if we can upgrade or not.
//
BOOL CheckUpgradeOnly;
BOOL CheckUpgradeOnlyQ;
//
// Specifies that winnt32 runs as an "Upgrade Advisor"
// and not all installation files are available
//
BOOL UpgradeAdvisorMode;

//
// Build the command console.
//
BOOL BuildCmdcons;

//
// Are we doing the PID encyption?
//
BOOL PIDEncryption = FALSE;
BOOL g_Quiet      = FALSE;
#define WINNT_U_ENCRYPT  TEXT("ENCRYPT")

#ifdef RUN_SYSPARSE
// Remove this before RTM.
// Be default run sysparse
BOOL NoSysparse = FALSE;
PROCESS_INFORMATION piSysparse = { NULL, NULL, 0, 0};
LRESULT SysParseDlgProc( IN HWND hdlg, IN UINT msg, IN WPARAM wParam, IN LPARAM lParam);
HWND GetBBhwnd();
#endif

//
// Log Functions
//

SETUPOPENLOG fnSetupOpenLog = NULL;
SETUPLOGERROR fnSetupLogError = NULL;
SETUPCLOSELOG fnSetupCloseLog = NULL;

//
//  Unsupported driver list
//  This list contains the information about the unsupported drivers that needs
//  to be migrated on a clean install or upgrade.
//
// PUNSUPORTED_DRIVER_INFO UnsupportedDriverList = NULL;

//
// When Winnt32.exe is launched over a network, these two parameters have valid
// values and need to be taken into consideration before displaying any dialog box
//

HWND Winnt32Dlg = NULL;
HANDLE WinNT32StubEvent = NULL;
HINSTANCE hinstBB = NULL;


//
// Definition for dynamically-loaded InitiateSystemShutdownEx API
//

typedef
(WINAPI *PFNINITIATESYSTEMSHUTDOWNEX)(LPTSTR,
                                      LPTSTR,
                                      DWORD,
                                      BOOL,
                                      BOOL,
                                      DWORD);


//
// Routines from Setupapi.dll
//
BOOL
(*SetupapiCabinetRoutine)(
    IN LPCTSTR CabinetFile,
    IN DWORD Flags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID Context
    );

DWORD
(*SetupapiDecompressOrCopyFile)(
    IN  PCTSTR  SourceFileName,
    OUT PCTSTR  TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    );

HINF
(*SetupapiOpenInfFile)(
    IN  LPCTSTR FileName,
    IN  LPCTSTR InfClass,    OPTIONAL
    IN  DWORD   InfStyle,
    OUT PUINT   ErrorLine    OPTIONAL
    );

VOID
(*SetupapiCloseInfFile)(
    IN HINF InfHandle
    );

BOOL
(*SetupapiFindFirstLine)(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  PCTSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

BOOL
(*SetupapiFindNextLine)(
    IN  PINFCONTEXT Context1,
    OUT PINFCONTEXT Context2
    );

BOOL
(*SetupapiFindNextMatchLine)(
    IN  PINFCONTEXT Context1,
    IN  PCTSTR Key,
    OUT PINFCONTEXT Context2
    );

LONG
(*SetupapiGetLineCount)(
    IN HINF   InfHandle,
    IN LPCTSTR Section
    );

DWORD
(*SetupapiGetFieldCount)(
    IN  PINFCONTEXT Context
    );

BOOL
(*SetupapiGetStringField)(
    IN  PINFCONTEXT Context,
    DWORD FieldIndex,
    PTSTR ReturnBuffer,
    DWORD ReturnBufferSize,
    PDWORD RequiredSize
    );

BOOL
(*SetupapiGetLineByIndex)(
    IN  HINF        InfHandle,
    IN  LPCTSTR     Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

HSPFILEQ
(*SetupapiOpenFileQueue) (
    VOID
    );

BOOL
(*SetupapiCloseFileQueue) (
    IN HSPFILEQ QueueHandle
    );

BOOL
(*SetupapiQueueCopy) (
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN PCTSTR   SourcePath,         OPTIONAL
    IN PCTSTR   SourceFilename,
    IN PCTSTR   SourceDescription,  OPTIONAL
    IN PCTSTR   SourceTagfile,      OPTIONAL
    IN PCTSTR   TargetDirectory,
    IN PCTSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

BOOL
(*SetupapiCommitFileQueue) (
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    );

UINT
(*SetupapiDefaultQueueCallback) (
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

PVOID
(*SetupapiInitDefaultQueueCallback) (
    HWND OwnerWindow
);

VOID
(*SetupapiTermDefaultQueueCallback) (
    PVOID Context
);

BOOL
(*SetupapiGetSourceFileLocation) (
    HINF InfHandle,          // handle of an INF file
    PINFCONTEXT InfContext,  // optional, context of an INF file
    PCTSTR FileName,         // optional, source file to locate
    PUINT SourceId,          // receives the source media ID
    PTSTR ReturnBuffer,      // optional, receives the location
    DWORD ReturnBufferSize,  // size of the supplied buffer
    PDWORD RequiredSize      // optional, buffer size needed
);


//
//srclient.dll (SystemRestore) functions
//
DWORD
(*SRClientDisableSR) (
    LPCWSTR pszDrive
    );



//
// NEC98 Specific local function
//

VOID
DeleteNEC98DriveAssignFlag(
    VOID
    );

BOOLEAN
AdjustPrivilege(
    PWSTR   Privilege
    );

VOID
LocateFirstFloppyDrive(
    VOID
    );

VOID
W95SetABFwFresh(
    int bBootDrvLtr
    );

BOOL
NEC98CheckDMI(
    VOID
    );

VOID
DisableSystemRestore( void );

//
//
//

BOOL
GetArgsFromUnattendFile(
    VOID
    )
/*++

Routine Description:

    This routine read relevent arguments from any specified unattended file.
    Specifically we are concerned here with oem preinstall stuff and whether
    to upgrade.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the unattend file the user specified is
    valid. If not, the user will have been told about why.

    If the user specified no unattend file on the command line, then the
    return value is TRUE.

--*/

{
    DWORD d;
    TCHAR Buffer[2*MAX_PATH];
    BOOL b = TRUE;
    PVOID InfHandle;
    LPCTSTR p;
    BOOL userDDU = FALSE;
#ifdef _X86_
    POEM_BOOT_FILE FileStruct,Previous;
#endif

    if(UnattendedScriptFile) {

        d = GetFileAttributes(UnattendedScriptFile);
        if(d == (DWORD)(-1)) {

            MessageBoxFromMessage(
                NULL,
                MSG_UNATTEND_FILE_INVALID,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                UnattendedScriptFile
                );

            return(FALSE);
        }

        //
        // Before we do much else, we should make sure the user has given
        // us a valid answer file.  We can't check everything, but a quick
        // and dirty sanity check would be to go ahead and call LoadInfFile
        // and see what he says about it.
        //

        switch(LoadInfFile(UnattendedScriptFile,FALSE,&InfHandle)) {
            case NO_ERROR:
                break;
            case ERROR_NOT_ENOUGH_MEMORY:

                MessageBoxFromMessage(
                    NULL,
                    MSG_OUT_OF_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                return(FALSE);
                break;

            default:

                MessageBoxFromMessage(
                    NULL,
                    MSG_UNATTEND_FILE_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    UnattendedScriptFile
                    );

                return(FALSE);
                break;
        }

        //
        // Check upgrade.
        //
        // In previous versions of NT the default was not to upgrade if
        // the value wasn't present at all. In addition there was an upgrade
        // type of "single" which meant to upgrade only if there was only one
        // NT build on the machine.
        //
        // We preserve the original default behavior but don't bother with
        // dealing with the "single" semantics -- just accept "single" as
        // a synonym for "yes".
        //

        GetPrivateProfileString(
            WINNT_UNATTENDED,
            ISNT() ? WINNT_U_NTUPGRADE : WINNT_U_WIN95UPGRADE,
            WINNT_A_NO,
            Buffer,
            sizeof(Buffer)/sizeof(TCHAR),
            UnattendedScriptFile
            );

        Upgrade = ((lstrcmpi(Buffer,WINNT_A_YES) == 0) || (lstrcmpi(Buffer,TEXT("single")) == 0));

#if defined(REMOTE_BOOT)
        //
        // Remote boot machines MUST upgrade.
        //

        if (RemoteBoot) {
            Upgrade = TRUE;
        }
#endif // defined(REMOTE_BOOT)

        GetPrivateProfileString(
            WINNT_UNATTENDED,
            WINNT_OEMPREINSTALL,
            WINNT_A_NO,
            Buffer,
            sizeof(Buffer)/sizeof(TCHAR),
            UnattendedScriptFile
            );

        if(!lstrcmpi(Buffer,WINNT_A_YES)) {
            OemPreinstall = TRUE;

            //
            // Add oem system directory to the list of optional directories.
            //
            // The user may have specified a different location for the $OEM$
            // directory, so we need to look in the unattend file for that.
            //
            GetPrivateProfileString(
                WINNT_UNATTENDED,
                WINNT_OEM_DIRLOCATION,
                WINNT_A_NO,
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR),
                UnattendedScriptFile
                );
            if( lstrcmpi( Buffer, WINNT_A_NO ) ) {
                //
                // make sure the location ends with "\$oem$".  If it
                // doesn't, then append it ourselves.
                //
                _tcsupr( Buffer );
                if( !_tcsstr(Buffer, TEXT("$OEM$")) ) {
                    ConcatenatePaths( Buffer, TEXT("$OEM$"), MAX_PATH );
                }
                UserSpecifiedOEMShare = DupString( Buffer );

                RememberOptionalDir( UserSpecifiedOEMShare, OPTDIR_OEMSYS );
            } else {
                RememberOptionalDir(WINNT_OEM_DIR,OPTDIR_OEMSYS | OPTDIR_ADDSRCARCH);
            }

            if (!IsArc()) {
#ifdef _X86_
                //
                // Remember all oem boot files and then unload the inf.
                //
                Previous = NULL;
                for(d=0; b && (p=InfGetFieldByIndex(InfHandle,WINNT_OEMBOOTFILES,d,0)); d++) {
                    if(FileStruct = MALLOC(sizeof(OEM_BOOT_FILE))) {
                        FileStruct->Next = NULL;
                        if(FileStruct->Filename = DupString(p)) {
                            if(Previous) {
                                Previous->Next = FileStruct;
                            } else {
                                OemBootFiles = FileStruct;
                            }
                            Previous = FileStruct;
                        } else {
                            b = FALSE;
                        }
                    } else {
                        b = FALSE;
                    }
                }

                if(!b) {
                    MessageBoxFromMessage(
                        NULL,
                        MSG_OUT_OF_MEMORY,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL
                        );
                }
#endif // _X86_
            }  // if (!IsArc())

        }

        GetPrivateProfileString(
            WINNT_USERDATA,
            WINNT_US_PRODUCTID,
            WINNT_A_NO,
            Buffer,
            sizeof(Buffer)/sizeof(TCHAR),
            UnattendedScriptFile
            );

        if( lstrcmpi( Buffer, WINNT_A_NO ) == 0 ) 
        {
            GetPrivateProfileString(
                WINNT_USERDATA,
                WINNT_US_PRODUCTKEY,
                WINNT_A_NO,
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR),
                UnattendedScriptFile
                );
        }

        // Buffer contains the Product ID or WINNT_A_NO if none in the unattend file
        // Is the PID encrypted?
        // We would only need to check for the exact length, but since we can defer
        // the decryption of an encrypted PID until GUI mode, 2 time the length should be saver
        if (lstrlen(Buffer) > (4 + MAX_PID30_EDIT*5)*2)
        {
            LPTSTR szDecryptedPID = NULL;
            HRESULT hr = ValidateEncryptedPID(Buffer, &szDecryptedPID);
            DebugLog (Winnt32LogInformation, TEXT("ValidateEncryptedPID returned: <hr=0x%1!lx!>"), 0, hr);
            if (FAILED(hr) || (hr == S_OK))
            {
                // if FAILED(hr) assume Crypto is not installed correct.
                // If we encrypted the data, but the encrypted data did not contain valid data
                // the function does not return a FAILED(hr) and does not return S_OK;
                // It returns 0x01 to 0x04, depending on what failure.
                // In the case we get a failure from Crypto ( it returns FAILED(hr))
                // we want to defer the checking of the PID until GUI mode
                // for that we need to save the encrypted PID

                // First assume we defer PID validation.
                g_bDeferPIDValidation = TRUE;
                g_EncryptedPID = GlobalAlloc(GPTR, (lstrlen(Buffer) + 1) *sizeof(TCHAR));
                if (g_EncryptedPID)
                {
                    // Save the decrypted PID we need to write it to winnt.sif
                    lstrcpy(g_EncryptedPID, Buffer);
                }
                // Only if the PID could be decrypted and falls in to the time interval
                // do we save the decrypted PID.
                if (hr == S_OK)
                {
                    lstrcpyn(ProductId, szDecryptedPID, sizeof(ProductId)/sizeof(TCHAR));
                    g_bDeferPIDValidation = FALSE;
                }
            }
            // else we could encrypt the data, but something is wrong
            // 
            if (szDecryptedPID)
            {
                GlobalFree(szDecryptedPID);
            }
        }
        else if (lstrcmpi(Buffer, WINNT_A_NO))
        {
            lstrcpyn(ProductId, Buffer, sizeof(ProductId)/sizeof(TCHAR));
        }
        else
        {
            *ProductId = TEXT('\0');
        }

        GetPrivateProfileString(
            WINNT_UNATTENDED,
            TEXT("FileSystem"),
            TEXT(""),
            Buffer,
            sizeof(Buffer)/sizeof(TCHAR),
            UnattendedScriptFile
            );

        ForceNTFSConversion = !lstrcmpi(Buffer, TEXT("ConvertNTFS"));

        if (!g_DynUpdtStatus->Disabled && !g_DynUpdtStatus->DynamicUpdatesSource[0]) {
            //
            // will Setup do the Dynamic Updates step at all?
            //
            if (GetPrivateProfileString(
                    WINNT_UNATTENDED,
                    WINNT_U_DYNAMICUPDATESDISABLE,
                    TEXT(""),
                    Buffer,
                    sizeof(Buffer)/sizeof(TCHAR),
                    UnattendedScriptFile
                    )
#ifdef PRERELEASE
                || GetPrivateProfileString(
                        WINNT_UNATTENDED,
                        TEXT("disabledynamicupdates"),
                        TEXT(""),
                        Buffer,
                        sizeof(Buffer)/sizeof(TCHAR),
                        UnattendedScriptFile
                        )
#endif
                    ) {
                userDDU = TRUE;
                if( !lstrcmpi( Buffer, WINNT_A_YES ) ) {
                    g_DynUpdtStatus->Disabled = TRUE;
                }
            }
        }
        if (!g_DynUpdtStatus->Disabled && !g_DynUpdtStatus->DynamicUpdatesSource[0]) {
            //
            // get location of previously downloaded files (if any)
            //
            if (GetPrivateProfileString(
                    WINNT_UNATTENDED,
                    WINNT_U_DYNAMICUPDATESHARE,
                    TEXT(""),
                    g_DynUpdtStatus->DynamicUpdatesSource,
                    sizeof(g_DynUpdtStatus->DynamicUpdatesSource) / sizeof(TCHAR),
                    UnattendedScriptFile
                    )) {
                RemoveTrailingWack (g_DynUpdtStatus->DynamicUpdatesSource);
                if (DoesDirectoryExist (g_DynUpdtStatus->DynamicUpdatesSource)) {
                    g_DynUpdtStatus->UserSpecifiedUpdates = TRUE;
                } else {
                    b = FALSE;
                }
            } else {
                if (!userDDU) {
                    g_DynUpdtStatus->Disabled = TRUE;
                }
            }
        }

        UnloadInfFile(InfHandle);
    }

    return(b);
}


BOOL
ParseArguments(
    VOID
    )

/*++

Routine Description:

    Parse arguments passed to the program.  Perform syntactic validation
    and fill in defaults where necessary.

    Valid arguments:

    /batch                      suppress message boxes

    /cmd:command_line           command to execute at end of gui setup

    /copydir:dirname            tree copy directory from source into %systemroot%
                                Note that this supports ".." syntax to backtrack
                                one directory

    /copysource:dirname         copy directory for use as source

    /debug[level][:filename]    maintain debug log at level, defaults to warning level 2
                                and file c:\winnt32.log

    /DynamicUpdatesDisable      disable dynamic setup

    /s:source                   specify source

    /syspart:letter             force a drive to be considered the system partition

    /tempdrive:letter           manually specify drive for local source

    /udf:id[,file]              uniqueness id and optional udf

    /unattend[num][:file]       unattended mode with optional countdown
                                and unattend file. (The countdown is ignored
                                on Win95.) 'Unattended' is also accepted.

    /nodownload                 not documented; on Win9x installs over the net,
                                do NOT download program files to a temporary directory and restart
                                from there. Effective in winnt32.exe only; here it's ignored

    /local                      not documented; used by winnt32.exe only; ignored in winnt32a|u.dll

    /#                          introduces undoc'ed/internal switches. Handed off
                                to internal switch handler in internal.c.

    /restart                    specified when winnt32.exe was restarted as a result
                                of updating one of the underlying modules; internal only

    /nosysparse                 suppress running sysparse.

    /E:"PID:days"               To encrypt the PID and add a delta of days, 
                                needs to have /Unattend:file specified.

Arguments:

    None. Arguments are retreived via GetCommandLine().

Return Value:

    None.

--*/

{
    LPTSTR Arg;
    LPTSTR BadParam = NULL;
    LPTSTR Colon;
    LPTSTR p;
    BOOL Valid;
    LPCTSTR DebugFileLog;
    LONG DebugLevel;
    BOOL b;
    unsigned u;
    int argc;
    LPTSTR *argv;
    DWORD d;
    WIN32_FIND_DATA fd;
    DWORD attr;

    argv = CommandLineToArgv(&argc);

    //
    // Skip program name. We should always get back argc as at least 1,
    // but be robust anyway.
    //
    if(argc) {
        argc--;
        argv++;
    }

    DebugFileLog = NULL;
    DebugLevel = 0;
    Valid = TRUE;

    while(argc--) {

        Arg = *argv++;

        if((*Arg == TEXT('/')) || (*Arg == TEXT('-'))) {

            switch(_totupper(Arg[1])) {

            case TEXT('B'):

                if(!_tcsnicmp(Arg+1,TEXT("batch"),5)) {
                    BatchMode = TRUE;
                } else {
                    Valid = FALSE;
                }
                break;

            case TEXT('C'):

                if(!_tcsnicmp(Arg+1,TEXT("copydir:"),8)) {
                    if(Arg[9]) {
                        RememberOptionalDir(Arg+9, OPTDIR_PLATFORM_SPECIFIC_FIRST);
                    } else {
                        Valid = FALSE;
                    }
                } else if(!_tcsnicmp(Arg+1,TEXT("copysource:"),11)) {
                    if(Arg[12]) {
                        TCHAR TempString[MAX_PATH];
                        
                        RememberOptionalDir(Arg+12, OPTDIR_TEMPONLY| OPTDIR_ADDSRCARCH);
#ifdef _IA64_
                        //
                        // Add the i386\<optional dir> folder if it exists. This helps in the lang folder case where
                        // we advocate in the network install case to explicitly specify /copysource:lang
        
                        lstrcpy( TempString, TEXT("..\\I386\\"));
                        lstrcat( TempString, Arg+12 );
                        
                        
                        //Also check if an I386 equivalent WOW directory exists

                        AddCopydirIfExists( TempString, OPTDIR_TEMPONLY | OPTDIR_PLATFORM_INDEP );

#endif

                    } else {
                        Valid = FALSE;
                    }
                } else if(!_tcsnicmp(Arg+1,TEXT("cmd:"),4)) {
                    if(CmdToExecuteAtEndOfGui) {
                        Valid = FALSE;
                    } else {
                        CmdToExecuteAtEndOfGui = Arg+5;
                    }
                } else if(!_tcsnicmp(Arg+1,TEXT("checkupgradeonly"),16)) {
                    CheckUpgradeOnly = TRUE;
                    UnattendedOperation = TRUE;

                    //
                    // Tell the win9X upgrade dll to generate a
                    // report.
                    //
                    InternalProcessCmdLineArg( TEXT("/#U:ReportOnly") );
                    InternalProcessCmdLineArg( TEXT("/#U:PR") );


                    //
                    // See if the user wants this to run *really*
                    // quietly...
                    //
                    if(!_tcsnicmp(Arg+1,TEXT("checkupgradeonlyq"),17)) {
                        //
                        // Yep.  Tell everyone to go through quietly...
                        //
                        CheckUpgradeOnlyQ = TRUE;
                        InternalProcessCmdLineArg( TEXT("/#U:CheckUpgradeOnlyQ") );
                    }

                } else if(!_tcsnicmp(Arg+1,TEXT("cmdcons"),4)) {
                    BuildCmdcons = TRUE;
                    NoCompliance = TRUE;    // disable the compliance checking
                } else {
                    Valid = FALSE;
                }
                break;

            case TEXT('D'):

                if (_tcsicmp(Arg+1,WINNT_U_DYNAMICUPDATESDISABLE) == 0
#ifdef PRERELEASE
                    || _tcsicmp(Arg+1,TEXT("disabledynamicupdates")) == 0
#endif
                    ) {
                    g_DynUpdtStatus->Disabled = TRUE;
                    break;
                }

                if (!_tcsnicmp (Arg + 1, WINNT_U_DYNAMICUPDATESHARE, sizeof (WINNT_U_DYNAMICUPDATESHARE_A) - 1) &&
                    Arg[sizeof (WINNT_U_DYNAMICUPDATESHARE_A)] == TEXT(':')) {
                    //
                    // Updated files specified on the command line
                    //
                    if (g_DynUpdtStatus->DynamicUpdatesSource[0]) {
                        Valid = FALSE;
                        break;
                    }
                    _tcsncpy (
                        g_DynUpdtStatus->DynamicUpdatesSource,
                        Arg + 1 + sizeof (WINNT_U_DYNAMICUPDATESHARE_A),
                        MAX_PATH
                        );
                    RemoveTrailingWack (g_DynUpdtStatus->DynamicUpdatesSource);
                    if (DoesDirectoryExist (g_DynUpdtStatus->DynamicUpdatesSource)) {
                        g_DynUpdtStatus->UserSpecifiedUpdates = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                    break;
                }

                if (!_tcsnicmp (Arg + 1, WINNT_U_DYNAMICUPDATESPREPARE, sizeof (WINNT_U_DYNAMICUPDATESPREPARE_A) - 1) &&
                    Arg[sizeof (WINNT_U_DYNAMICUPDATESPREPARE_A)] == TEXT(':')) {
                    if (g_DynUpdtStatus->DynamicUpdatesSource[0]) {
                        Valid = FALSE;
                        break;
                    }
                    _tcsncpy (
                        g_DynUpdtStatus->DynamicUpdatesSource,
                        Arg + 1 + sizeof (WINNT_U_DYNAMICUPDATESPREPARE_A),
                        MAX_PATH
                        );
                    RemoveTrailingWack (g_DynUpdtStatus->DynamicUpdatesSource);
                    g_DynUpdtStatus->PrepareWinnt32 = TRUE;
                    if (DoesDirectoryExist (g_DynUpdtStatus->DynamicUpdatesSource)) {
                        g_DynUpdtStatus->UserSpecifiedUpdates = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                    break;
                }

                if(DebugFileLog || _tcsnicmp(Arg+1,TEXT("debug"),5)) {
                    Valid = FALSE;
                    break;
                }

                DebugLevel = _tcstol(Arg+6,&Colon,10);
                if((DebugLevel == -1) || (*Colon && (*Colon != TEXT(':')))) {
                    Valid = FALSE;
                    break;
                }

                if(Colon == Arg+6) {
                    //
                    // No debug level specified, use default
                    //
                    DebugLevel = Winnt32LogInformation;
                }

                if(*Colon) {
                    //
                    // Log file name was specified.
                    //
                    Colon++;
                    if(*Colon) {
                        DebugFileLog = Colon;
                    } else {
                        Valid = FALSE;
                        break;
                    }
                }
                break;

            case TEXT('E'):

                //
                // Take care of headless parameters.
                //
                if( !_tcsnicmp(Arg+1,WINNT_U_HEADLESS_REDIRECT,_tcslen(WINNT_U_HEADLESS_REDIRECT)) ) {
                    if( Arg[_tcslen(WINNT_U_HEADLESS_REDIRECT)+2] ) {
                        _tcscpy( HeadlessSelection, Arg+(_tcslen(WINNT_U_HEADLESS_REDIRECT)+2) );
                        Valid = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                } else if( !_tcsnicmp(Arg+1,WINNT_U_HEADLESS_REDIRECTBAUDRATE,_tcslen(WINNT_U_HEADLESS_REDIRECTBAUDRATE)) ) {
                    if( Arg[_tcslen(WINNT_U_HEADLESS_REDIRECTBAUDRATE)+2] ) {
                        HeadlessBaudRate = _tcstoul(Arg+(_tcslen(WINNT_U_HEADLESS_REDIRECTBAUDRATE)+2),NULL,10);
                    } else {
                        Valid = FALSE;
                    }
                }
                else if ( _tcsnicmp(Arg+1,WINNT_U_ENCRYPT,_tcslen(WINNT_U_ENCRYPT)) == 0 ) 
                {
                    LPTSTR pTmp;
                    pTmp = &Arg[lstrlen(WINNT_U_ENCRYPT)+1];
                    Valid = FALSE;
                    // Make sure we have /Encrypt:
                    if (*pTmp == TEXT(':'))
                    {
                        pTmp++;
                        while (*pTmp && (*pTmp != TEXT(':')))
                        {
                            pTmp = CharNext(pTmp);
                        }
                        if (*pTmp == TEXT(':'))
                        {
                            *pTmp = TEXT('\0');
                            ++pTmp;
                            PIDDays = _tcstoul(pTmp, NULL, 10);
                            Valid = ((PIDDays >= 5) && (PIDDays <= 60));
                        }
                        // Save the product ID.
                        lstrcpyn(ProductId, &Arg[lstrlen(WINNT_U_ENCRYPT)+2], sizeof(ProductId)/sizeof(TCHAR));
                        PIDEncryption = TRUE;
                    }
                }
                break;

            case TEXT('L'):
                if (_tcsicmp (Arg+1, TEXT("local"))) {
                    Valid = FALSE;
                }
                break;

            case TEXT('M'):
                //
                // Alternate source for missing files
                //
                if(Arg[2] == TEXT(':')) {
                    if (!DoesDirectoryExist (Arg+3)) {
                        Valid = FALSE;
                        break;
                    }
                    _tcscpy(AlternateSourcePath, Arg+3);

                    //
                    // If the user is using the /M switch, he's got privates
                    // that he wants to use.  It's possible that some of these
                    // privates will be in the driver cab, inwhich case, he'd
                    // have to make a copy of the cab with his private.  Unreasonable.
                    // We can get around this by simply copying all the files
                    // from the user-specified private directory (/M<foobar>)
                    // into the local source.  textmode and guimode will look
                    // for files before extractifi ming them from the CAB.  All we
                    // need to do here is add the user's directory to the master
                    // copy list.
                    //
                    RememberOptionalDir(AlternateSourcePath,OPTDIR_OVERLAY);

                    //
                    // If we're using privates, go ahead and copy the
                    // source local.
                    //
                    MakeLocalSource = TRUE;
                    UserSpecifiedMakeLocalSource = TRUE;
                } else if( !_tcsnicmp( Arg+1, TEXT("MakeLocalSource"), 15)) {
                    //

                    // check if there are any options for this switch
                    //
                    if (Arg[16] && Arg[16] != TEXT(':')) {
                        Valid = FALSE;
                        break;
                    }
                    MakeLocalSource = TRUE;
                    UserSpecifiedMakeLocalSource = TRUE;

                    if (!Arg[16]) {
                        break;
                    }
                    if (!Arg[17]) {
                        //
                        // add this for W2K backwards compatibility
                        //
                        break;
                    }
                    if (!_tcsicmp (Arg + 17, TEXT("all"))) {
                        //
                        // copy ALL CDs
                        //
                        MLSDiskID = 0;
                    } else {
                        DWORD chars;
                        if (!_stscanf (Arg + 17, TEXT("%u%n"), &MLSDiskID, &chars) || Arg[17 + chars] != 0) {
                            Valid = FALSE;
                        }
                    }

                } else {
                    Valid = FALSE;
                }
                break;

            case TEXT('N'):
                //
                // Possibly a /noreboot or /nosysparse?
                //
                if( !_tcsicmp( Arg+1, TEXT("noreboot")) ) {
                    AutomaticallyShutDown = FALSE;
                }
#ifdef RUN_SYSPARSE
                else if( !_tcsicmp( Arg+1, TEXT("nosysparse"))) {
                    NoSysparse = TRUE;
                }
#endif
                else if( _tcsicmp( Arg+1, TEXT("nodownload"))) {
                    Valid = FALSE;
                }
                break;

            case TEXT('Q'):
                g_Quiet = TRUE;
                break;

            case TEXT('R'):
                if (!_tcsnicmp (Arg + 1, TEXT("Restart"), 7)) {
                    g_DynUpdtStatus->Winnt32Restarted = TRUE;
                    if (Arg[8] == TEXT(':')) {
                        lstrcpy (g_DynUpdtStatus->RestartAnswerFile, Arg + 9);
                    } else if (Arg[8]) {
                        Valid = FALSE;
                    }
                } else {
                    Valid = FALSE;
                }

                break;

            case TEXT('S'):

                if((Arg[2] == TEXT(':')) && Arg[3]) {
                    //
                    // Ignore extraneous sources
                    //
                    if(SourceCount < MAX_SOURCE_COUNT) {
                        if (GetFullPathName (
                                Arg+3,
                                sizeof(NativeSourcePaths[SourceCount])/sizeof(TCHAR),
                                NativeSourcePaths[SourceCount],
                                NULL
                                )) {
                            SourceCount++;
                        } else {
                            Valid = FALSE;
                        }
                    }
                } else {
                    if(!_tcsnicmp(Arg+1,TEXT("syspart:"),8)
                    && Arg[9]
                    && (_totupper(Arg[9]) >= TEXT('A'))
                    && (_totupper(Arg[9]) <= TEXT('Z'))
                    && !ForcedSystemPartition) {
#ifdef _X86_
                        if (IsNEC98()){
                            if (!IsValidDrive(Arg[9])){
                                Valid = FALSE;
                               break;
                            }
                        }
#endif
                        ForcedSystemPartition = (TCHAR)_totupper(Arg[9]);

                    } else {
                        Valid = FALSE;
                    }
                }
                break;

            case TEXT('T'):

                if(_tcsnicmp(Arg+1,TEXT("tempdrive:"),10)
                || !(UserSpecifiedLocalSourceDrive = (TCHAR)_totupper(Arg[11]))
                || (UserSpecifiedLocalSourceDrive < TEXT('A'))
                || (UserSpecifiedLocalSourceDrive > TEXT('Z'))) {

                    Valid = FALSE;
                }
                break;

            case TEXT('U'):

                if (_tcsicmp (Arg+1, TEXT("UpgradeAdvisor")) == 0) {
                    UpgradeAdvisorMode = TRUE;
                    break;
                }

                //
                // Accept unattend and unattended as synonyms
                //
                b = FALSE;
                if(!_tcsnicmp(Arg+1,TEXT("unattended"),10)) {
                    b = TRUE;
                    u = 11;
                } else {
                    if(!_tcsnicmp(Arg+1,TEXT("unattend"),8)) {
                        b = TRUE;
                        u = 9;
                    }
                }

                if(b) {
                    if(!CheckUpgradeOnly && UnattendedOperation) {
                        Valid = FALSE;
                        break;
                    }

                    UnattendedOperation = TRUE;
                    UnattendSwitchSpecified = TRUE;

                    UnattendedShutdownTimeout = _tcstoul(Arg+u,&Colon,10);
                    if(UnattendedShutdownTimeout == (DWORD)(-1)) {
                        UnattendedShutdownTimeout = 0;
                    }

                    if(*Colon == 0) {
                        break;
                    }

                    if(*Colon++ != TEXT(':')) {
                        Valid = FALSE;
                        break;
                    }

                    if(*Colon) {
                        // UnattendedScriptFile = Colon;
                        //
                        // Get the name of the unattended script file
                        //
                        UnattendedScriptFile = MALLOC(MAX_PATH*sizeof(TCHAR));
                        if(UnattendedScriptFile) {
                            if(!GetFullPathName(
                                Colon,
                                MAX_PATH,
                                UnattendedScriptFile,
                                &p)) {

                                Valid = FALSE;
                            }
                        } else {
                            Valid = FALSE;
                        }

                    } else {
                        Valid = FALSE;
                    }

                } else if(!_tcsnicmp(Arg+1,TEXT("udf:"),4)) {

                    if(!Arg[5] || (Arg[5] == TEXT(',')) || UniquenessId) {
                        Valid = FALSE;
                        break;
                    }

                    //
                    // Get p to point to the filename if there is one specified,
                    // and terminate the ID part.
                    //
                    if(p = _tcschr(Arg+6,TEXT(','))) {
                        *p++ = 0;
                        if(*p == 0) {
                            Valid = FALSE;
                            break;
                        }
                    }

                    UniquenessId = Arg + 5;
                    UniquenessDatabaseFile = p;
                } else {
                    Valid = FALSE;
                }
                break;

            case TEXT('#'):

                InternalProcessCmdLineArg(Arg);
                break;

            default:

                Valid = FALSE;
                break;
            }
        } else {
            Valid = FALSE;
        }
        if(!Valid && !BadParam) {
            BadParam = Arg;
        }
    }

    if(Valid) {
        if( DebugLevel == 0 ) {
            DebugLevel = Winnt32LogInformation;
        }
        if( DebugFileLog == NULL ) {
        TCHAR   Buffer[MAX_PATH];
            MyGetWindowsDirectory( Buffer, MAX_PATH );
            ConcatenatePaths( Buffer, S_WINNT32LOGFILE, MAX_PATH );
            DebugFileLog = DupString( Buffer );
        }
        if( DebugFileLog )
            StartDebugLog(DebugFileLog,DebugLevel);

        // If we do PID encryption (/Encrypt on the command line)
        // we don't read the unattend file. We will write the encrypted PID to it later.
        if (!PIDEncryption)
        {
            Valid = GetArgsFromUnattendFile();
        }
    }
    else
    {
        if (PIDEncryption)
        {
            // Invalid encrypt command line, Time frame invalid
            DebugLog (Winnt32LogInformation, TEXT("Invalid encrypt command line, Time frame invalid."), 0);
        }
        else if(BatchMode) {
            //
            // Tell SMS about bad paramters
            //
            SaveMessageForSMS( MSG_INVALID_PARAMETER, BadParam );

        } else {
            //
            // Show user the valid command line parameters
            //
            MyWinHelp(NULL,HELP_CONTEXT,IDH_USAGE);
        }
    }

    return(Valid);
}


BOOL
RememberOptionalDir(
    IN LPCTSTR Directory,
    IN UINT    Flags
    )

/*++

Routine Description:

    This routine adds a directory to the list of optional directories
    to be copied. If the directory is already present it is not added
    again.

Arguments:

    Directory - supplies name of directory to be copied.

    Flags - supplies flags for the directory. If the directory already
        existed in the list, the current flags are NOT overwritten.

Return Value:

    Boolean value indicating outcome. If FALSE, the caller can assume that
    we've overflowed the number of allowed optional dirs.

--*/

{
    UINT u;

    //
    // See if we have room.
    //
    if(OptionalDirectoryCount == MAX_OPTIONALDIRS) {
        return(FALSE);
    }

    //
    // If already there, do nothing.
    //
    for(u=0; u<OptionalDirectoryCount; u++) {
        if(!lstrcmpi(OptionalDirectories[u],Directory)) {
            return(TRUE);
        }
    }

    //
    // OK, add it.
    //
    DebugLog (Winnt32LogInformation, TEXT("Optional Directory <%1> added"), 0, Directory);
    lstrcpy(OptionalDirectories[OptionalDirectoryCount],Directory);
    OptionalDirectoryFlags[OptionalDirectoryCount] = Flags;
    OptionalDirectoryCount++;
    return(TRUE);
}


BOOL
CheckBuildNumber(
    )

/*++

Routine Description:

    This routine checks the build number of the NT system we're currently
    running.  Note that the build number is stored in a global variable
    because we'll need it again later.

Arguments:

    None.

Return Value:

    Boolean value indicating whether to allow an upgrade from this build.

--*/

{
    return( BuildNumber <= NT40 || BuildNumber >= NT50B1 );
}


BOOL
LoadSetupapi(
    VOID
    )
{
    TCHAR Name[MAX_PATH], *p;
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    HMODULE Setupapi;
    BOOL WeLoadedLib = FALSE;
    BOOL    b;
    PCTSTR Header;


    //
    // Use the setupapi.dll that was loaded by an upgrade module
    //

    Setupapi = GetModuleHandle (TEXT("SETUPAPI.DLL"));

    if (!Setupapi) {

        //
        // Upgrade module did not load SETUPAPI.DLL, so we must load it.
        // If setupapi.dll is in the system directory, use the one that's there.
        //
        GetSystemDirectory(Name,MAX_PATH);
        ConcatenatePaths(Name,TEXT("SETUPAPI.DLL"),MAX_PATH);

        FindHandle = FindFirstFile(Name,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            //
            // Not there. Fetch the dll out of the win95 upgrade
            // support directory.
            //
            if(GetModuleFileName(NULL,Name,MAX_PATH) && (p = _tcsrchr(Name,TEXT('\\')))){
                *p= 0;
                ConcatenatePaths(Name,WINNT_WIN95UPG_95_DIR,MAX_PATH);
                ConcatenatePaths(Name,TEXT("SETUPAPI.DLL"),MAX_PATH);

                Setupapi = LoadLibraryEx(Name,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
            }



        } else {
            //
            // Already in system directory.
            //
            FindClose(FindHandle);
            Setupapi = LoadLibrary(TEXT("SETUPAPI.DLL"));
        }

        if (Setupapi) {
            WeLoadedLib = TRUE;
        } else {
            b = FALSE;
        }
    }

    if(Setupapi) {
#ifdef UNICODE
        b = (((FARPROC)SetupapiDecompressOrCopyFile = GetProcAddress(Setupapi,"SetupDecompressOrCopyFileW")) != NULL);
        b = b && ((FARPROC)SetupapiCabinetRoutine = GetProcAddress(Setupapi,"SetupIterateCabinetW"));
        b = b && ((FARPROC)SetupapiOpenInfFile = GetProcAddress(Setupapi,"SetupOpenInfFileW"));
        b = b && ((FARPROC)SetupapiGetLineCount = GetProcAddress(Setupapi,"SetupGetLineCountW"));
        b = b && ((FARPROC)SetupapiGetStringField = GetProcAddress(Setupapi,"SetupGetStringFieldW"));
        b = b && ((FARPROC)SetupapiGetLineByIndex = GetProcAddress(Setupapi,"SetupGetLineByIndexW"));
        b = b && ((FARPROC)SetupapiFindFirstLine = GetProcAddress(Setupapi,"SetupFindFirstLineW"));
        b = b && ((FARPROC)SetupapiFindNextMatchLine = GetProcAddress(Setupapi,"SetupFindNextMatchLineW"));
        //
        // needed for DU
        //
        b = b && ((FARPROC)SetupapiQueueCopy = GetProcAddress(Setupapi,"SetupQueueCopyW"));
        b = b && ((FARPROC)SetupapiCommitFileQueue = GetProcAddress(Setupapi,"SetupCommitFileQueueW"));
        b = b && ((FARPROC)SetupapiDefaultQueueCallback = GetProcAddress(Setupapi,"SetupDefaultQueueCallbackW"));
        //
        // needed in unsupdrv.c
        //
        (FARPROC)SetupapiGetSourceFileLocation = GetProcAddress(Setupapi,"SetupGetSourceFileLocationW");


#else
        b = (((FARPROC)SetupapiDecompressOrCopyFile = GetProcAddress(Setupapi,"SetupDecompressOrCopyFileA")) != NULL);
        b = b && ((FARPROC)SetupapiCabinetRoutine = GetProcAddress(Setupapi,"SetupIterateCabinetA"));
        b = b && ((FARPROC)SetupapiOpenInfFile = GetProcAddress(Setupapi,"SetupOpenInfFileA"));
        b = b && ((FARPROC)SetupapiGetLineCount = GetProcAddress(Setupapi,"SetupGetLineCountA"));
        b = b && ((FARPROC)SetupapiGetStringField = GetProcAddress(Setupapi,"SetupGetStringFieldA"));
        b = b && ((FARPROC)SetupapiGetLineByIndex = GetProcAddress(Setupapi,"SetupGetLineByIndexA"));
        b = b && ((FARPROC)SetupapiFindFirstLine = GetProcAddress(Setupapi,"SetupFindFirstLineA"));
        b = b && ((FARPROC)SetupapiFindNextMatchLine = GetProcAddress(Setupapi,"SetupFindNextMatchLineA"));
        //
        // needed for DU
        //
        b = b && ((FARPROC)SetupapiQueueCopy = GetProcAddress(Setupapi,"SetupQueueCopyA"));
        b = b && ((FARPROC)SetupapiCommitFileQueue = GetProcAddress(Setupapi,"SetupCommitFileQueueA"));
        b = b && ((FARPROC)SetupapiDefaultQueueCallback = GetProcAddress(Setupapi,"SetupDefaultQueueCallbackA"));
        //
        // needed in unsupdrv.c
        //
        (FARPROC)SetupapiGetSourceFileLocation = GetProcAddress(Setupapi,"SetupGetSourceFileLocationA");

#endif
        b = b && ((FARPROC)SetupapiCloseInfFile = GetProcAddress(Setupapi,"SetupCloseInfFile"));
        //
        // needed for DU
        //
        b = b && ((FARPROC)SetupapiOpenFileQueue = GetProcAddress(Setupapi,"SetupOpenFileQueue"));
        b = b && ((FARPROC)SetupapiCloseFileQueue = GetProcAddress(Setupapi,"SetupCloseFileQueue"));
        b = b && ((FARPROC)SetupapiInitDefaultQueueCallback = GetProcAddress(Setupapi,"SetupInitDefaultQueueCallback"));
        b = b && ((FARPROC)SetupapiTermDefaultQueueCallback = GetProcAddress(Setupapi,"SetupTermDefaultQueueCallback"));
        b = b && ((FARPROC)SetupapiGetFieldCount = GetProcAddress(Setupapi,"SetupGetFieldCount"));


        b = b && ((FARPROC)SetupapiFindNextLine = GetProcAddress(Setupapi,"SetupFindNextLine"));

        (FARPROC)fnSetupOpenLog  = GetProcAddress(Setupapi, "SetupOpenLog");

#ifdef UNICODE
        (FARPROC)fnSetupLogError = GetProcAddress(Setupapi, "SetupLogErrorW");
#else
        (FARPROC)fnSetupLogError = GetProcAddress(Setupapi, "SetupLogErrorA");
#endif

        (FARPROC)fnSetupCloseLog = GetProcAddress(Setupapi, "SetupCloseLog");
    }

    //
    // If the below if() fails, we must be on a platform that has
    // a setupapi.dll without the new log API.  In that case, neither
    // upgrade DLLs have loaded their own setupapi, so we don't care
    // about logging, and we eat the error.
    //

    if (fnSetupOpenLog && fnSetupLogError && fnSetupCloseLog) {
        if (!Winnt32Restarted ()) {
            //
            // Log APIs exist, so delete setupact.log and setuperr.log, write header
            //

            fnSetupOpenLog (TRUE);

            Header = GetStringResource (MSG_LOG_BEGIN);
            if (Header) {
                fnSetupLogError (Header, LogSevInformation);
                FreeStringResource (Header);
            }

            fnSetupCloseLog();
        }
    }



    if(!b) {

        if (WeLoadedLib) {
            FreeLibrary(Setupapi);
        }

        MessageBoxFromMessage(
            NULL,
            MSG_CANT_LOAD_SETUPAPI,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            TEXT("setupapi.dll")
            );
    }

    return b;
}


VOID
LoadUpgradeSupport(
    VOID
    )

/*++

Routine Description:

    This routine loads the Win95 upgrade dll or the NT upgrade dll and
    retreives its significant entry points.

Arguments:

    None.

Return Value:

--*/

{
    DWORD d;
    DWORD i;
    LPTSTR *sourceDirectories;
    HKEY hKey;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwSize;
    TCHAR buffer[MAX_PATH];
    PTSTR p;
    TCHAR dst[MAX_PATH];
    TCHAR src[MAX_PATH];

    ZeroMemory(&UpgradeSupport,sizeof(UpgradeSupport));

    if (!ISNT()) {
        //
        // Don't load on server
        //

        // assert that the Server global variable is accurate
        MYASSERT (UpgradeProductType != UNKNOWN);

        if (Server) {
            return;
        }

        //
        // Form full Win95 path of DLL.
        //
        BuildPath(buffer, WINNT_WIN95UPG_95_DIR, WINNT_WIN95UPG_95_DLL);
    } else {
        //
        // Form full NT path of DLL.
        //
        BuildPath(buffer, WINNT_WINNTUPG_DIR, WINNT_WINNTUPG_DLL);
    }

    if (FindPathToWinnt32File (buffer, UpgradeSupport.DllPath, MAX_PATH)) {
        //
        // Load the library. Use LoadLibraryEx to get the system to resolve DLL
        // references starting in the dir where w95upg.dll is, instead of the
        // directory where winnt32.exe is.
        //
        // If we're upgrading from NT5, use the system's setupapi.
        //
        //
        // HACK HACK HACK - see NTBUG9: 354926
        // some OEM machines have KnownDlls registered, but actually missing
        // this leads to a failure of LoadLibrary
        // we need a workaround for this
        //
        PSTRINGLIST missingKnownDlls = NULL;
        FixMissingKnownDlls (&missingKnownDlls, TEXT("imagehlp.dll\0"));
        if (!ISNT()) {
            UpgradeSupport.DllModuleHandle = LoadLibraryEx(
                                                    UpgradeSupport.DllPath,
                                                    NULL,
                                                    LOAD_WITH_ALTERED_SEARCH_PATH
                                                    );
        } else {
            UpgradeSupport.DllModuleHandle = LoadLibraryEx(
                                                    UpgradeSupport.DllPath,
                                                    NULL,
                                                    (BuildNumber > NT40) ? 0 : LOAD_WITH_ALTERED_SEARCH_PATH
                                                    );
        }
        if (missingKnownDlls) {
            DWORD rc = GetLastError ();
            UndoFixMissingKnownDlls (missingKnownDlls);
            SetLastError (rc);
        }
    } else {
        //
        // just for display purposes, use default path
        //
        GetModuleFileName (NULL, UpgradeSupport.DllPath, MAX_PATH);
        p = _tcsrchr (UpgradeSupport.DllPath, TEXT('\\'));
        if (p) {
            *p = 0;
        }
        ConcatenatePaths (UpgradeSupport.DllPath, buffer, MAX_PATH);
        SetLastError (ERROR_FILE_NOT_FOUND);
    }

    if(!UpgradeSupport.DllModuleHandle) {

        d = GetLastError();
        if(d == ERROR_DLL_NOT_FOUND) {
            d = ERROR_FILE_NOT_FOUND;
        }

        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_UPGRADE_DLL_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            UpgradeSupport.DllPath
            );

        goto c0;
    } else {
        DebugLog (Winnt32LogInformation, TEXT("Loaded upgrade module: <%1>"), 0, UpgradeSupport.DllPath);
    }

    //
    // Get entry points.
    //
    (FARPROC)UpgradeSupport.InitializeRoutine  = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_INIT_NAME
                                                        );

    (FARPROC)UpgradeSupport.GetPagesRoutine    = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_GETPAGES_NAME
                                                        );

    (FARPROC)UpgradeSupport.WriteParamsRoutine = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_WRITEPARAMS_NAME
                                                        );

    (FARPROC)UpgradeSupport.CleanupRoutine     = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_CLEANUP_NAME
                                                        );

#ifdef _X86_
    if (IsNEC98()){
    (FARPROC)W95SetAutoBootFlag                = GetProcAddress(
                                                        UpgradeSupport.DllModuleHandle,
                                                        WINNT32_PLUGIN_SETAUTOBOOT_NAME
                                                        );
    }
    info.Boot16 = &g_Boot16;


    if (!ISNT()) {

        (FARPROC)UpgradeSupport.OptionalDirsRoutine = GetProcAddress (
                                                            UpgradeSupport.DllModuleHandle,
                                                            WINNT32_PLUGIN_GETOPTIONALDIRS_NAME
                                                            );
    }
#endif

    if(!UpgradeSupport.InitializeRoutine
    || !UpgradeSupport.GetPagesRoutine
    || !UpgradeSupport.WriteParamsRoutine
    || !UpgradeSupport.CleanupRoutine) {

        //
        // Entry points couldn't be found. The upgrade dll is corrupt.
        //
        MessageBoxFromMessage(
            NULL,
            MSG_UPGRADE_DLL_CORRUPT,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            UpgradeSupport.DllPath
            );

        goto c1;
    }

    //
    // Fill in the info structure. This will be passed to the DLL's init routine.
    //
    info.Size                       = sizeof(info);
    info.UnattendedFlag             = &UnattendedOperation;
    info.CancelledFlag              = &Cancelled;
    info.AbortedFlag                = &Aborted;
    info.UpgradeFlag                = &Upgrade;
    info.LocalSourceModeFlag        = &MakeLocalSource;
    info.CdRomInstallFlag           = &RunFromCD;
    info.UnattendedScriptFile       = &UnattendedScriptFile;
    info.UpgradeOptions             = &UpgradeOptions;
    info.NotEnoughSpaceBlockFlag    = &BlockOnNotEnoughSpace;
    info.LocalSourceDrive           = &LocalSourceDriveOffset;
    info.LocalSourceSpaceRequired   = &LocalSourceSpaceRequired;
    info.ForceNTFSConversion        = &ForceNTFSConversion;
    info.ProductFlavor              = &ProductFlavor;
    info.SetupFlags                 = &dwSetupFlags;
    //
    // Version info fields
    //

    info.ProductType = &UpgradeProductType;
    info.BuildNumber = VER_PRODUCTBUILD;
    info.ProductVersion = VER_PRODUCTVERSION_W;

#if DBG
    info.Debug = TRUE;
#else
    info.Debug = FALSE;
#endif

#ifdef PRERELEASE
    info.PreRelease = TRUE;
#else
    info.PreRelease = FALSE;
#endif

    //
    // Source directories
    //

    sourceDirectories = (LPTSTR *) MALLOC(sizeof(LPTSTR) * MAX_SOURCE_COUNT);
    if (sourceDirectories) {
        for (i=0;i<MAX_SOURCE_COUNT;i++) {
            sourceDirectories[i] = NativeSourcePaths[i];
        }
    }

    info.SourceDirectories      = sourceDirectories;
    info.SourceDirectoryCount   = &SourceCount;

    info.UnattendSwitchSpecified = &UnattendSwitchSpecified;

    if (!IsArc()) {
#ifdef _X86_ // references_X86_-only stuff
        if (!ISNT()) {

            //
            // Fill in win9xupg specific information. This is done so that the win9xupg
            // team can add more parameters to the structure without disturbing other
            // upgrade dll writers. If a paramter is needed in both cases, it should
            // be placed in the info structure above.
            //

            Win9xInfo.Size = sizeof (Win9xInfo);
            Win9xInfo.BaseInfo = &info;
            Win9xInfo.WinDirSpace = &WinDirSpaceFor9x;
            Win9xInfo.RequiredMb = &UpgRequiredMb;
            Win9xInfo.AvailableMb = &UpgAvailableMb;
            Win9xInfo.DynamicUpdateLocalDir = g_DynUpdtStatus->WorkingDir;
            Win9xInfo.DynamicUpdateDrivers = g_DynUpdtStatus->SelectedDrivers;
            Win9xInfo.UpginfsUpdated = &UpginfsUpdated;

            //
            // Save the location of the original location of w95upg.dll. Because of dll
            // replacement, this may be different than the actual w95upg.dll location
            // used.
            //
            GetModuleFileName (NULL, UpgradeSourcePath, MAX_PATH);
            p = _tcsrchr (UpgradeSourcePath, TEXT('\\'));
            if (p) {
                *p = 0;
            }

            ConcatenatePaths (UpgradeSourcePath, WINNT_WIN95UPG_95_DIR, MAX_PATH);
            Win9xInfo.UpgradeSourcePath = UpgradeSourcePath;

            //
            // Copy over optional directories just as we did with source directories above.
            //
            sourceDirectories = (LPTSTR *) MALLOC(sizeof(LPTSTR) * MAX_OPTIONALDIRS);
            if (sourceDirectories) {
                for (i=0;i<MAX_OPTIONALDIRS;i++) {
                sourceDirectories[i] = OptionalDirectories[i];
                }
            }

            Win9xInfo.OptionalDirectories = sourceDirectories;
            Win9xInfo.OptionalDirectoryCount = &OptionalDirectoryCount;
            Win9xInfo.UpgradeFailureReason = &UpgradeFailureReason;

            //
            // Read disk sectors routine. Win9xUpg uses this when looking for other os installations.
            //
            Win9xInfo.ReadDiskSectors = ReadDiskSectors;

            d = UpgradeSupport.InitializeRoutine((PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK) &Win9xInfo);
        }
        else {
            d = UpgradeSupport.InitializeRoutine(&info);
        }
#endif // _X86_
    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        //
        // Call the DLL's init routine and get-pages routine. If either fails tell the user.
        //
        d = UpgradeSupport.InitializeRoutine(&info);
#endif // UNICODE
    } // if (!IsArc())

    if(d == NO_ERROR) {
        d = UpgradeSupport.GetPagesRoutine(
                &UpgradeSupport.AfterWelcomePageCount,
                &UpgradeSupport.Pages1,
                &UpgradeSupport.AfterOptionsPageCount,
                &UpgradeSupport.Pages2,
                &UpgradeSupport.BeforeCopyPageCount,
                &UpgradeSupport.Pages3
                );
    }


    //
    // By returning ERROR_REQUEST_ABORTED, an upgrade dll can refuse to upgrade the machine.
    // In this case, no message will be generated by this routine and the option to upgrade
    // will be grayed out on the wizard page. In the case of all other error messages, winnt32
    // will warn the user that the upgrade dll failed to initialize. The upgrade.dll is expected
    // to provide whatever UI is necessary before returning from its init routine.
    //
    if (UpgradeFailureReason > REASON_LAST_REASON) {
        UpgradeFailureReason = REASON_LAST_REASON;
    }

    if(d == NO_ERROR) {
        return;
    }

    if (d != ERROR_REQUEST_ABORTED) {
        SkipVirusScannerCheck = TRUE;
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_UPGRADE_INIT_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

c1:
        FreeLibrary(UpgradeSupport.DllModuleHandle);
        ZeroMemory (&UpgradeSupport, sizeof (UpgradeSupport));
    }

c0:
    Upgrade = FALSE;
    return;
}


#ifdef _X86_

BOOL
CheckVirusScanners (
    VOID
    )

/*++

Routine Description:

    This routine is used to check for virus scanners on win9x machines that can
    impeed setup (either in a clean install or upgrade case.) The function simply
    calls an entry point within the w95upg.dll and that module performs the
    actual check.

Arguments:

    None.

Return Value:

    TRUE if no virus scanners were detected that could cause problems. FALSE if a virus
    scanner was detected that could cause setup to fail. We rely on the w95upg.dll code
    to provide an appropriate message to the user before returning to us.

--*/

{
    HANDLE dllHandle;
    PWINNT32_PLUGIN_VIRUSSCANNER_CHECK_ROUTINE virusScanRoutine;

    //
    // This check is win9xupg specific.
    //
    if (ISNT()) {
        return TRUE;
    }
    dllHandle = GetModuleHandle (WINNT_WIN95UPG_95_DLL);
    //
    // If the module was not loaded, we'll skip this check.
    //
    if (!dllHandle) {
        return TRUE;
    }
    //
    // Get entry points.
    //
    (FARPROC) virusScanRoutine  = GetProcAddress(dllHandle, WINNT32_PLUGIN_VIRUSSCANCHECK_NAME);
    if (!virusScanRoutine) {
        //
        // corrupt dll or something
        //
        return FALSE;
    }

    //
    // Now, simply call the routine. It will handle the actuall checking as well as informing the user.
    //
    return virusScanRoutine ();
}

#endif


BOOL
ValidateSourceLocation(
    VOID
    )
/*++

Routine Description:

    This routine checks the initial source location to see if it's
    valid.  The first source location must be valid for setup to
    work, and this catches typos by the user.  It cannot detect
    transient network conditions, so this is not foolproof.

    We check this by looking for a required file, dosnet.inf, at
    the source location.

Arguments:

    None.

Return Value:

    TRUE if the source location appears valid

--*/
{
    TCHAR FileName[MAX_PATH];

    lstrcpy( FileName, NativeSourcePaths[0]);
    ConcatenatePaths(FileName, InfName, MAX_PATH);

    if (FileExists( FileName, NULL )) {
        //
        // also look for system32\ntdll.dll as a second check
        //
        lstrcpy( FileName, NativeSourcePaths[0]);
        ConcatenatePaths(FileName, TEXT("system32\\ntdll.dll"), MAX_PATH);
        return(FileExists( FileName, NULL ));
    }

    return(FALSE);
}


VOID
pRemoveOutdatedBackupImage (
    VOID
    )
{
    REMOVEUNINSTALLIMAGE removeFn;
    HMODULE lib;
    UINT build;

    //
    // Is this current build > build we plan to install?
    //

    if (!ISNT() || !Upgrade) {
        return;
    }

    build = GetMediaProductBuildNumber();

    if (!build) {
        return;
    }

    if (build == BuildNumber) {
        return;
    }

    //
    // Attempt to remove uninstall image
    //

    lib = LoadLibraryA ("osuninst.dll");
    if (!lib) {
        return;
    }

    removeFn = (REMOVEUNINSTALLIMAGE) GetProcAddress (lib, "RemoveUninstallImage");

    if (removeFn) {
        removeFn();
    }

    FreeLibrary (lib);
}


BOOL
GetProductType (
    VOID
    )
{
    TCHAR buffer[256];

    if (!FullInfName[0]) {
        if (!FindPathToWinnt32File (InfName, FullInfName, MAX_PATH)) {
            FullInfName[0] = 0;
            return FALSE;
        }
    }
    //
    // get some data from the main inf
    //
    if (!GetPrivateProfileString (
            TEXT("Miscellaneous"),
            TEXT("ProductType"),
            TEXT(""),
            buffer,
            256,
            FullInfName
            )) {
        DebugLog (
            Winnt32LogError,
            TEXT("%1 key in [%2] section is missing from %3; aborting operation"),
            0,
            TEXT("ProductType"),
            TEXT("Miscellaneous"),
            FullInfName
            );
        return FALSE;
    }
    // Test for valid product type (0 == pro, 6 == sbs)
    if (buffer[0] < TEXT('0') || buffer[0] > TEXT('6') || buffer[1]) {
        DebugLog (
            Winnt32LogError,
            TEXT("Invalid %1 value (%2) in %3"),
            0,
            TEXT("ProductType"),
            buffer,
            FullInfName
            );
        return FALSE;
    }

    ProductFlavor = buffer[0] - TEXT('0');
    Server = (ProductFlavor != PROFESSIONAL_PRODUCTTYPE && ProductFlavor != PERSONAL_PRODUCTTYPE);
    UpgradeProductType = Server ? NT_SERVER : NT_WORKSTATION;
    return TRUE;
}


UINT
GetMediaProductBuildNumber (
    VOID
    )
{
    TCHAR buffer[256];
    PCTSTR p;
    PTSTR q;
    UINT build;

    if (!FullInfName[0]) {
        if (!FindPathToWinnt32File (InfName, FullInfName, MAX_PATH)) {
            return 0;
        }
    }
    //
    // get some data from the main inf
    //
    if (!GetPrivateProfileString (
            TEXT("Version"),
            TEXT("DriverVer"),
            TEXT(""),
            buffer,
            256,
            FullInfName
            )) {
        DebugLog (
            Winnt32LogError,
            TEXT("Version key in [DriverVer] section is missing from %1; aborting operation"),
            0,
            FullInfName
            );
        return 0;
    }

    p = _tcschr (buffer, TEXT(','));
    if (p) {
        //
        // p should point to ",<major>.<minor>.<build>.0" -- extract <build>
        //

        p = _tcschr (p + 1, TEXT('.'));
        if (p) {
            p = _tcschr (p + 1, TEXT('.'));
            if (p) {
                p = _tcsinc (p);
                q = _tcschr (p, TEXT('.'));
                if (q) {
                    *q = 0;
                } else {
                    p = NULL;
                }
            }
        }
    }

    if (p) {
        build = _tcstoul (p, &q, 10);
        if (*q) {
            p = NULL;
        }
    }

    if (!p || build < NT51B2) {
        DebugLog (
            Winnt32LogError,
            TEXT("Unexpected data %1, found in Version key in [DriverVer] section of %2; aborting operation"),
            0,
            buffer,
            FullInfName
            );
        return 0;
    }

    return build;
}

typedef HANDLE (WINAPI * PWINSTATIONOPENSERVERW)(LPWSTR);
typedef BOOLEAN (WINAPI * PWINSTATIONCLOSESERVER)(HANDLE);


UINT GetLoggedOnUserCount()
{
    UINT iCount = 0;
    HMODULE hwinsta;
    PWINSTATIONOPENSERVERW pfnWinStationOpenServerW;
    PWINSTATIONENUMERATEW pfnWinStationEnumerateW;
    PWINSTATIONFREEMEMORY pfnWinStationFreeMemory;
    PWINSTATIONCLOSESERVER pfnWinStationCloseServer;

    /*
     *  Get handle to winsta.dll
     */
    hwinsta = LoadLibraryA("WINSTA");
    if (hwinsta != NULL)
    {
        pfnWinStationOpenServerW = (PWINSTATIONOPENSERVERW)GetProcAddress(hwinsta, "WinStationOpenServerW");
        pfnWinStationEnumerateW = (PWINSTATIONENUMERATEW)GetProcAddress(hwinsta, "WinStationEnumerateW");
        pfnWinStationFreeMemory = (PWINSTATIONFREEMEMORY)GetProcAddress(hwinsta, "WinStationFreeMemory");
        pfnWinStationCloseServer = (PWINSTATIONCLOSESERVER)GetProcAddress(hwinsta, "WinStationCloseServer");

        if (pfnWinStationOpenServerW    &&
            pfnWinStationEnumerateW     &&
            pfnWinStationFreeMemory     &&
            pfnWinStationCloseServer)
        {
            HANDLE hServer;

            //  Open a connection to terminal services and get the number of sessions.
            hServer = pfnWinStationOpenServerW((LPWSTR)SERVERNAME_CURRENT);
            if (hServer != NULL)
            {
                PLOGONIDW pLogonIDs;
                ULONG ulEntries;

                if (pfnWinStationEnumerateW(hServer, &pLogonIDs, &ulEntries))
                {
                    ULONG ul;
                    PLOGONIDW pLogonID;

                    /*
                     * Iterate the sessions looking for active and disconnected sessions only.
                     * Then match the user name and domain (case INsensitive) for a result.
                     */
                    for (ul = 0, pLogonID = pLogonIDs; ul < ulEntries; ul++, pLogonID++)
                    {
                        if ((pLogonID->State == State_Active)       ||
                            (pLogonID->State == State_Disconnected) ||
                            (pLogonID->State == State_Shadow))
                        {
                            iCount++;
                        }
                    }

                    /*
                     * Free any resources used.
                     */
                    pfnWinStationFreeMemory(pLogonIDs);
                }

                pfnWinStationCloseServer(hServer);
            }
        }

        FreeLibrary(hwinsta);
    }

    return iCount;
}

// From winuser.h, but since we cannot define WINVER >= 0x0500 I copied it here.
#define SM_REMOTESESSION        0x1000

BOOL DisplayExitWindowsWarnings(uExitWindowsFlags)
{
    BOOL bRet = TRUE;
    BOOL fIsRemote = GetSystemMetrics(SM_REMOTESESSION);
    UINT iNumUsers = GetLoggedOnUserCount();
    UINT uID = 0;

    switch (uExitWindowsFlags)
    {
        case EWX_POWEROFF:
        case EWX_SHUTDOWN:
        {
            if (fIsRemote)
            {
                // We are running as part of a terminal server session
                if (iNumUsers > 1)
                {
                    // Warn the user if remote shut down w/ active users
                    uID = IDS_SHUTDOWN_REMOTE_OTHERUSERS;
                }
                else
                {
                    // Warn the user if remote shut down (won't be able to restart via TS client!)
                    uID = IDS_SHUTDOWN_REMOTE;
                }
            }
            else
            {
                if (iNumUsers > 1)
                {
                    //  Warn the user if more than one user session active
                    uID = IDS_SHUTDOWN_OTHERUSERS;
                }
            }
        }
        break;

        case EWX_REBOOT:
        {
            //  Warn the user if more than one user session active.
            if (iNumUsers > 1)
            {
                uID = IDS_RESTART_OTHERUSERS;
            }
        }
        break;
    }

    if (uID != 0)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szMessage[MAX_PATH];

        LoadString(hInst, IDS_APPTITLE, szTitle, sizeof(szTitle)/sizeof(szTitle[0]));
        LoadString(hInst, uID, szMessage, sizeof(szMessage)/sizeof(szMessage[0]));

        if (MessageBox(NULL,
                       szMessage,
                       szTitle,
                       MB_ICONEXCLAMATION | MB_YESNO | MB_SYSTEMMODAL | MB_SETFOREGROUND) == IDNO)
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

#define SETUP_MEMORY_MIN_REQUIREMENT (50<<20) //50MB
#define SETUP_DISK_MIN_REQUIREMENT (70<<20) //70MB

BOOL
pIsEnoughVMAndDiskSpace(
    OUT     ULARGE_INTEGER * OutRemainFreeSpace,    OPTIONAL
    IN      BOOL bCheckOnlyRAM                      OPTIONAL
    )
{
    PVOID pMemory;
    TCHAR winDir[MAX_PATH];
    TCHAR winDrive[] = TEXT("?:\\");
    ULARGE_INTEGER RemainFreeSpace = {0, 0};
    DWORD sectorPerCluster;
    DWORD bytesPerSector;
    ULARGE_INTEGER numberOfFreeClusters = {0, 0};
    ULARGE_INTEGER totalNumberOfClusters = {0, 0};
    BOOL bResult = TRUE;


    if(OutRemainFreeSpace){
        OutRemainFreeSpace->QuadPart = 0;
    }



    pMemory = VirtualAlloc(NULL, SETUP_MEMORY_MIN_REQUIREMENT, MEM_COMMIT, PAGE_NOACCESS);
    if(!pMemory){
        return FALSE;
    }
    
    if(!bCheckOnlyRAM){
        MyGetWindowsDirectory(winDir, sizeof(winDir) / sizeof(winDir[0]));
        winDrive[0] = winDir[0];
        bCheckOnlyRAM = GetDriveType(winDrive) != DRIVE_FIXED;
    }
    if(!bCheckOnlyRAM){
        if(GetDiskFreeSpaceNew(winDrive, 
                               &sectorPerCluster, 
                               &bytesPerSector, 
                               &numberOfFreeClusters, 
                               &totalNumberOfClusters)){

            RemainFreeSpace.QuadPart = sectorPerCluster * bytesPerSector;
            RemainFreeSpace.QuadPart *= numberOfFreeClusters.QuadPart;

            if(OutRemainFreeSpace){
                OutRemainFreeSpace->QuadPart = RemainFreeSpace.QuadPart;
            }

            if(RemainFreeSpace.QuadPart < SETUP_DISK_MIN_REQUIREMENT){
                bResult = FALSE;
            }
        }
        else{
            MYASSERT(FALSE);
        }

    }

    VirtualFree(pMemory, SETUP_MEMORY_MIN_REQUIREMENT, MEM_DECOMMIT);


    return bResult;
}


LPTOP_LEVEL_EXCEPTION_FILTER pLastExceptionFilter = NULL;

LONG MyFilter(EXCEPTION_POINTERS *pep)
{
    static BOOL		fGotHere = FALSE;
    PSETUP_FAULT_HANDLER pSetupFH = NULL;
    HMODULE hmodFaultRep = NULL;
    PFAULTHCreate pfnCreate = NULL;
    PFAULTHDelete pfnDelete = NULL;
    DWORD dwRetRep = EXCEPTION_CONTINUE_SEARCH;
    DWORD dwLength;
    TCHAR faulthDllPath[MAX_PATH];
    TCHAR additionalFiles[DW_MAX_ADDFILES];
    TCHAR title[DW_MAX_ERROR_CWC];
    TCHAR errortext[DW_MAX_ERROR_CWC];
    TCHAR lcid[10];
    LCID  dwlcid;


    if( fGotHere) {
        goto c0;
    }

    fGotHere = TRUE;
    // No way to upload then quit
    if( !IsNetConnectivityAvailable()) {
        DebugLog (Winnt32LogWarning, TEXT("Warning: Faulthandler did not find netconnectivity."), 0);
        goto c0;
    }

    if( !FindPathToWinnt32File( TEXT(SETUP_FAULTH_APPNAME),faulthDllPath,MAX_PATH)) {
        DebugLog (Winnt32LogWarning, TEXT("Warning: Could not find faulthandler %1"), 0, TEXT(SETUP_FAULTH_APPNAME));
        goto c0;
    }

    additionalFiles[0] = TEXT('0');
    //The buffer size should be able to hold both files. Be careful when adding more!
    MYASSERT( 2*MAX_PATH < DW_MAX_ADDFILES);

    if (MyGetWindowsDirectory (additionalFiles, DW_MAX_ADDFILES)) {
        ConcatenatePaths (additionalFiles, S_WINNT32LOGFILE, DW_MAX_ADDFILES);
    }
    dwLength = lstrlen( additionalFiles);

    // Check for case where we could not get winnt32.log
    if( dwLength > 0) {
        dwLength++;   //Reserve space for pipe
    }

    if (MyGetWindowsDirectory (additionalFiles+dwLength, DW_MAX_ADDFILES-dwLength)) {
        ConcatenatePaths (additionalFiles+dwLength, S_DEFAULT_NT_COMPAT_FILENAME, DW_MAX_ADDFILES-dwLength);
        // If we at least got the first file then add the separator.
        if( dwLength) {
            additionalFiles[dwLength-1] = TEXT('|');
        }
    }

    hmodFaultRep = LoadLibrary(faulthDllPath);

    if (hmodFaultRep == NULL) {
        DebugLog (Winnt32LogError, TEXT("Error: Could not load faulthandler %1."), 0, TEXT(SETUP_FAULTH_APPNAME));
        goto c0;
    }

    pfnCreate = (PFAULTHCreate)GetProcAddress(hmodFaultRep, FAULTH_CREATE_NAME);
    pfnDelete = (PFAULTHDelete)GetProcAddress(hmodFaultRep, FAULTH_DELETE_NAME);
    if (pfnCreate == NULL || pfnDelete == NULL) {
        DebugLog (Winnt32LogError, TEXT("Error: Could not get faulthandler exports."), 0);
        goto c0;
    }

    pSetupFH = (*pfnCreate)();

    if( pSetupFH == NULL) {
        DebugLog (Winnt32LogError, TEXT("Error: Could not get faulthandler object."), 0);
        goto c0;
    }

    if( pSetupFH->IsSupported(pSetupFH) == FALSE) {
        DebugLog (Winnt32LogError, TEXT("Error: Dr Watson not supported."), 0);
        goto c0;
    }

    title[0] = TEXT('\0');
    lcid[0] = TEXT('\0');
    errortext[0] = TEXT('\0');
    LoadString(hInst, IDS_APPTITLE, title, sizeof(title)/sizeof(title[0]));
    LoadString(hInst, IDS_DRWATSON_ERRORTEXT, errortext, sizeof(errortext)/sizeof(errortext[0]));
    LoadString(hInst, IDS_DRWATSON_LCID, lcid, sizeof(lcid)/sizeof(lcid[0]));
    if( !StringToInt( lcid, &dwlcid)) {
        dwlcid = 1033;
    }

    pSetupFH->SetLCID(pSetupFH, dwlcid);
    pSetupFH->SetURLA(pSetupFH, SETUP_URL);
#ifdef UNICODE
    pSetupFH->SetAdditionalFilesW(pSetupFH, additionalFiles);
    pSetupFH->SetAppNameW(pSetupFH, title);
    pSetupFH->SetErrorTextW(pSetupFH, errortext);
#else
    pSetupFH->SetAdditionalFilesA(pSetupFH, additionalFiles);
    pSetupFH->SetAppNameA(pSetupFH, title);
    pSetupFH->SetErrorTextA(pSetupFH, errortext);
#endif
    CloseDebugLog(); //Close log file or else it cannot be uploaded.
    dwRetRep = pSetupFH->Report(pSetupFH, pep, 0);
    
    (*pfnDelete)(pSetupFH);

    // Pass the error to the default unhandled exception handler
    // which will terminate the process.

    dwRetRep = EXCEPTION_EXECUTE_HANDLER;

c0:
    if (hmodFaultRep != NULL) {
        FreeLibrary(hmodFaultRep);
    }
    SetUnhandledExceptionFilter( pLastExceptionFilter);
    return dwRetRep;
}

#ifdef TEST_EXCEPTION
struct {
    DWORD dwException;
    DWORD dwSetupArea;
} exceptionInfo;

void DoException( DWORD dwSetupArea)
{
    TCHAR _testBuffer[10];
    TCHAR *_ptestCh = 0;

    if( exceptionInfo.dwSetupArea == dwSetupArea) {
        switch( exceptionInfo.dwException) {
        case 1:
            *_ptestCh = TEXT('1');
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Access violation"),MB_OK);
            break;
        case 2:
            {
                DWORD i;
                for( i =0; i < 0xffffffff;i++) {
                    _testBuffer[i] = TEXT('1');

                }
            }
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Buffer Overflow"),MB_OK);
            break;
        case 3:
            {
                LPVOID  pv;
                DWORD   i;

                for (i = 0; i < 0xffffffff; i++) {
                    pv = MALLOC(2048);
                }
            }
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Stack Overflow"),MB_OK);
            break;
        case 4:
            {
typedef DWORD (*FAULT_FN)(void);
                FAULT_FN    pfn;
                BYTE        rgc[2048];

                FillMemory(rgc, sizeof(rgc), 0);
                pfn = (FAULT_FN)(DWORD_PTR)rgc;
                (*pfn)();
            }
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Invalid Instruction"),MB_OK);
            break;
        case 5:
            for(;dwSetupArea;dwSetupArea--) ;
            exceptionInfo.dwSetupArea = 4/dwSetupArea;
            MessageBox(NULL,TEXT("Exception not hit!"),TEXT("Divide by zero"),MB_OK);
            break;
        default:
            break;
        }
    }
}

void GetTestException( void)
{
    TCHAR exceptionType[32];
    TCHAR exceptionSetupArea[32];

    exceptionType[0] = TEXT('\0');
    exceptionSetupArea[0] = TEXT('\0');
    exceptionInfo.dwException = 0;
    exceptionInfo.dwSetupArea = 0;

    GetPrivateProfileString( TEXT("Exception"),
                             TEXT("ExceptionType"),
                             TEXT("none"),
                             exceptionType,
                             sizeof(exceptionType)/sizeof(exceptionType[0]),
                             TEXT("c:\\except.inf"));

    GetPrivateProfileString( TEXT("Exception"),
                             TEXT("ExceptionSetupArea"),
                             TEXT("none"),
                             exceptionSetupArea,
                             sizeof(exceptionSetupArea)/sizeof(exceptionSetupArea[0]),
                             TEXT("c:\\except.inf"));

    StringToInt( exceptionType, &exceptionInfo.dwException);
    StringToInt( exceptionSetupArea, &exceptionInfo.dwSetupArea);
}

#endif

HRESULT WriteEncryptedPIDtoUnattend(LPTSTR szPID)
{
    HRESULT hr = E_FAIL;
    LPTSTR szLine = NULL;
    HANDLE hFile;

    szLine = GlobalAlloc(GPTR, (lstrlen(szPID) + 3)*sizeof(TCHAR));   // + 3 for 2 " and \0
    if (szLine)
    {
        wsprintf(szLine, TEXT("\"%s\""), szPID);
        if (WritePrivateProfileString(WINNT_USERDATA, WINNT_US_PRODUCTKEY, szLine, UnattendedScriptFile) &&
            WritePrivateProfileString(WINNT_USERDATA, WINNT_US_PRODUCTID, NULL, UnattendedScriptFile))
        {
            hr = S_OK;
        }
        else
        {
            // Error message, Unable to write
            DebugLog (Winnt32LogInformation, TEXT("Unable to write to the unattend file."), 0);
        }
        GlobalFree(szLine);
        if (hr == S_OK)
        {
            hFile = CreateFile(UnattendedScriptFile,
                            GENERIC_READ | GENERIC_WRITE, 
                            0, 
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                SYSTEMTIME st;
                FILETIME   ft;
                ZeroMemory(&st, sizeof(st));
                st.wDay = 1;
                st.wMonth = 4;
                st.wYear = 2002;

                SystemTimeToFileTime(&st, &ft);  // converts to file time format
                LocalFileTimeToFileTime(&ft, &ft); // Make sure we get this as UTC
                SetFileTime(hFile, &ft, &ft, &ft);	// Set it.
                CloseHandle(hFile);
            }
        }
    }
    return hr;
}

DWORD
winnt32 (
    IN      PCSTR LocalSourcePath,      OPTIONAL
    IN      HWND Dlg,                   OPTIONAL
    IN      HANDLE WinNT32Stub,         OPTIONAL
    OUT     PCSTR* RestartCmdLine       OPTIONAL
    )

/*++

Routine Description:

  winnt32 is the main setup routine.

Arguments:

  LocalSourcePath - Specifies the local path of installation in case
                    this DLL is running from a local directory
                    after download; always ANSI if not NULL

  Dlg - Specifies the handle of the welcome dialog displayed by
        the stub; it will stay on screen untill the wizard dialog
        appears; may be NULL

  WinNT32Stub - Specifies the handle of an event that will be
                signaled before the Wizard appears on the screen;
                may be NULL

  RestartCmdLine - Receives a pointer to a command line to be executed
                   by the caller after this function returns;
                   always ANSI

Return Value:

  none

--*/

{
    HMODULE SMSHandle = NULL;
    SMSPROC InstallStatusMIF = NULL;
    HANDLE Mutex;
    BOOL b;
    TCHAR Text[MAX_PATH];
    PCTSTR Footer;
    DWORD i;
    BOOL rc = ERROR_SUCCESS;
    BOOL bScreenSaverOn = FALSE;
    PCTSTR skuPersonal;
#if !defined(UNICODE)
    ULARGE_INTEGER RemainFreeSpace;
#endif
    

#ifdef TEST_EXCEPTION
    GetTestException();
    DoException( 1);
#endif

// Initialize these variables because the exceptionfilter calls FindPathToWinnt32File
#ifndef UNICODE
        //
        // if running on Win9x, there may be a LocalSourcePath passed as parameter
        // use that
        //
    g_LocalSourcePath = LocalSourcePath;
#endif

    AlternateSourcePath[0] = 0;
    g_DynUpdtStatus = NULL;
    SourceCount = 0;
    pLastExceptionFilter = SetUnhandledExceptionFilter(MyFilter);


#ifdef TEST_EXCEPTION
    DoException( 2);
#endif

    SetErrorMode(SEM_FAILCRITICALERRORS);


    InitCommonControls();

#if !defined(UNICODE)
    //
    // Check virtual memory requirements (only for regular Win9x winnt32 execution)
    //
    if(!IsWinPEMode()){
        RemainFreeSpace.QuadPart = 0;
        if(!pIsEnoughVMAndDiskSpace(&RemainFreeSpace, FALSE)){
            if(!RemainFreeSpace.QuadPart){
                MessageBoxFromMessage(
                    NULL,
                    MSG_OUT_OF_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );
            }
            else{
                MessageBoxFromMessage(
                    NULL,
                    MSG_COPY_ERROR_DISKFULL,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );
            }
            rc = -1;
            goto EXITNOW;
        }
    }
#endif

    //
    // Init Dynamic update status
    //
    g_DynUpdtStatus = MALLOC (sizeof (*g_DynUpdtStatus));
    if (!g_DynUpdtStatus) {
        rc = -1;
        goto EXITNOW;
    }

    //
    // start with all defaults
    //
    ZeroMemory (g_DynUpdtStatus, sizeof (*g_DynUpdtStatus));
    g_DynUpdtStatus->Connection = INVALID_HANDLE_VALUE;

#if defined(REMOTE_BOOT)
    g_DynUpdtStatus->Disabled = TRUE;
#endif

    //
    // If we are running WINNT32 under WINPE we disable Dynamic Update as WINPE
    // is primarily for OEM's and Dynamic Update feature is not meant for OEM's
    //
    if (IsWinPEMode()){
        g_DynUpdtStatus->Disabled = TRUE;
    }

    // Save the screen saver state
    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &bScreenSaverOn ,0);
    // Disable the screen saver
    SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, NULL ,0);
    //
    // Gather os version info, before we parse arguments
    // since we use ISNT() function
    //
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersion);
    BuildNumber = OsVersion.dwBuildNumber;
    OsVersionNumber = OsVersion.dwMajorVersion*100 + OsVersion.dwMinorVersion;
    //
    // Parse/check arguments first.
    //
    if (!ParseArguments()) {
        rc = 1;
        goto c0;
    }

    // if we are running to encrypt the PID into an unattend file, don't log the command line.
    if (!PIDEncryption)
    {
        DebugLog (Winnt32LogInformation, TEXT("The command line is: <%1>"), 0, GetCommandLine ());
    }
    //
    // also log the location of the upgrade module
    //
    if (GetModuleFileName (hInst, Text, MAX_PATH)) {
        DebugLog (Winnt32LogInformation, TEXT("Main module path: <%1>"), 0, Text);
    }

    if (CheckUpgradeOnly)
    {
        AppTitleStringId = IDS_APPTITLE_CHECKUPGRADE;
    }

    //
    // If we didn't get any source paths on the command line,
    // make one up here. The path will be the path where we were run from.
    //
    if(!SourceCount) {

        PTSTR p;

        if (!GetModuleFileName (NULL, NativeSourcePaths[0],MAX_PATH) ||
            !(p = _tcsrchr (NativeSourcePaths[0], TEXT('\\')))) {

            rc = 1;
            MessageBoxFromMessage(
                NULL,
                GetLastError(),
                TRUE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );

            goto c1;
        }

        //
        // check if running from a private build
        //
        *p = 0;
        if ((p = _tcsrchr (NativeSourcePaths[0], TEXT('\\'))) != NULL &&
            lstrcmpi (p + 1, INTERNAL_WINNT32_DIR) == 0
            ) {
            *p = 0;
        }

        SourceCount = 1;
    }

    
    //
    // setup the SourcePaths array from the legacy source paths array
    //
    for (i = 0; i < MAX_SOURCE_COUNT; i++) {
        if (NativeSourcePaths[i]) {
            LPTSTR p;
            lstrcpy(SourcePaths[i], NativeSourcePaths[i]);
            p = _tcsrchr (SourcePaths[i], TEXT('\\'));
            if (p) {
                *++p = TEXT('\0');
            }
        }
    }

    //
    // Validate the source location
    //
    if (!ValidateSourceLocation()) {
            rc = 1;
            MessageBoxFromMessage(
                       NULL,
                       MSG_INVALID_SOURCEPATH,
                       FALSE,
                       IDS_APPTITLE,
                       MB_OK | MB_ICONERROR | MB_TASKMODAL,
                       NULL );
            goto c0;

    }

    //
    //At this point we have the NativeSourcePaths setup and it si safe for operations involving it to be called
    //
    if (PIDEncryption)
    {
        rc = 1;
        if (UnattendedScriptFile)
        {
            BOOL bDontCare, bSelect;
            GetSourceInstallType(0);
            if (ValidatePidEx(ProductId, &bDontCare, &bSelect) && bSelect)
            {
                LPTSTR szEncryptedPID = NULL;
                HRESULT hr = PrepareEncryptedPID(ProductId, PIDDays, &szEncryptedPID);
                if (hr != S_OK)
                {
                    DebugLog (Winnt32LogInformation, TEXT("PrepareEncryptedPID failed: <hr=0x%1!lX!>"), 0, hr);
                    // Error Excryption failed
                }
                else
                {
                    if (WriteEncryptedPIDtoUnattend(szEncryptedPID) == S_OK)
                    {
                        DebugLog (Winnt32LogInformation, TEXT("Encrypted PID succeeded"), 0);
                    }
                    if (szEncryptedPID)
                    {
                        GlobalFree(szEncryptedPID);
                    }
                    rc = 0;
                }
            }
            else
            {
                DebugLog (Winnt32LogInformation, TEXT("PID is not a valid or not a valid VL key."), 0);
            }
        }
        else
        {
            // No unattend switch specified
            DebugLog (Winnt32LogInformation, TEXT("No unattend file specified."), 0);
        }
        goto c0;
    }

    if( RunningBVTs ){
        CopyExtraBVTDirs();
    }

    if (!DynamicUpdateInitialize ()) {
        DebugLog (
            Winnt32LogError,
            TEXT("DynamicUpdateInitialize failed: no dynamic update processing will be done"),
            0
            );
        g_DynUpdtStatus->Disabled = TRUE;
    }

    if (!GetProductType()) {
        MessageBoxFromMessage(
            NULL,
            MSG_INVALID_INF_FILE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
            FullInfName[0] ? FullInfName : InfName
            );
        rc = 1;
        goto c0;
    }

    if (!g_DynUpdtStatus->Disabled) {
        if (Winnt32Restarted ()) {
            DebugLog (Winnt32LogWarning, TEXT("\r\n*** Winnt32 restarted ***\r\n"), 0);
            if (g_DynUpdtStatus->RestartAnswerFile[0]) {
#ifdef PRERELEASE
                TCHAR buf[MAX_PATH];
                if (MyGetWindowsDirectory (buf, sizeof (buf) / sizeof (TCHAR))) {
                    ConcatenatePaths (buf, S_RESTART_TXT, sizeof (buf) / sizeof (TCHAR));
                    if (CopyFile (g_DynUpdtStatus->RestartAnswerFile, buf, FALSE)) {
                        DebugLog (DynUpdtLogLevel, TEXT("Winnt32 restart file backed up to %1"), 0, buf);
                    }
                }
#endif
            } else {
                DebugLog (DynUpdtLogLevel, TEXT("No restart file is used"), 0);
            }
        }
    }

    //
    // Init support for SMS.
    //
    try {
        if( SMSHandle = LoadLibrary( TEXT("ISMIF32")) ) {
            InstallStatusMIF = (SMSPROC)GetProcAddress(SMSHandle,"InstallStatusMIF");
        }
        if(LastMessage = MALLOC(1))
            LastMessage[0] = '\0';
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    Winnt32Dlg = Dlg;
    WinNT32StubEvent = WinNT32Stub;

    // If the user specified /cmdcons (install the recovery consol) , don't show the
    // billboards.
    if (!BuildCmdcons && !CheckUpgradeOnly
#if 0
        //
        // BUGBUG - we should do this but we need to provide some other UI feedback
        //
        && g_DynUpdtStatus->WorkingDir
#endif
        )
    {
        CreateMainWindow();
        PrepareBillBoard(BackgroundWnd2);
        if (hinstBB)
        {
            if (!LoadString (
                    hInst,
                    IDS_ESC_TOCANCEL,
                    Text,
                    sizeof(Text)/sizeof(TCHAR)
                    )) {
                Text[0] = 0;
            }
            BB_SetInfoText(Text);

            UpdateWindow (BackgroundWnd2);
        }
        else
        {
            // If we could not load the billboard dll, destroy the backbround window
            // This window is currently only here to catch pressing ESC and forward
            // this to the wizard dialog proc. If the wizard is always visible, this
            // is not needed.
            DestroyWindow(BackgroundWnd2);
            BackgroundWnd2 = NULL;
        }
    }
    if (!LoadString (hInst, IDS_TIMEESTIMATE_UNKNOWN, Text,
                     sizeof(Text)/sizeof(TCHAR)))
    {
        Text[0] = 0;
    }
    // BB_SetTimeEstimateText does nothing if the billboard dll is not loaded.
    BB_SetTimeEstimateText((PTSTR)Text);

    //
    // Only let one of this guy run.
    // account for TS case (make the mutex global)
    //
#ifdef UNICODE
    wsprintf (Text, TEXT("Global\\%s"), TEXT("Winnt32 Is Running"));
    Mutex = CreateMutex(NULL,FALSE,Text);
    // NT4 without TS does not support the "Global\Mutex name", make sure that
    // if we could not create the Mutext that the error code is ERROR_PATH_NOT_FOUND
    // If that is the case fall back and use the name with out the Global prefix.
    if ((Mutex == NULL) && (GetLastError() == ERROR_PATH_NOT_FOUND)) {
#else
    Mutex = NULL;
    if(Mutex == NULL) {
#endif

        Mutex = CreateMutex(NULL,FALSE,TEXT("Winnt32 Is Running"));
        if(Mutex == NULL) {
            rc = 1;
            //
            // An error (like out of memory) has occurred.
            // Bail now.
            //
            MessageBoxFromMessage(
                NULL,
                MSG_OUT_OF_MEMORY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );

            goto c0;
        }
    }

    //
    // Make sure we are the only process with a handle to our named mutex.
    //
    if ((Mutex == NULL) || (GetLastError() == ERROR_ALREADY_EXISTS)) {

        rc = 1;
        MessageBoxFromMessage(
            NULL,
            MSG_ALREADY_RUNNING,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
            );

        goto c1;
    }

    //
    // Ensure that the user has privilege/access to run this app.
    //
    if(!IsUserAdmin()
    || !DoesUserHavePrivilege(SE_SHUTDOWN_NAME)
    || !DoesUserHavePrivilege(SE_BACKUP_NAME)
    || !DoesUserHavePrivilege(SE_RESTORE_NAME)
    || !DoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME)) {

        rc = 1;
        MessageBoxFromMessage(
           NULL,
           MSG_NOT_ADMIN,
           FALSE,
           AppTitleStringId,
           MB_OK | MB_ICONSTOP | MB_TASKMODAL
           );

        goto c1;
    }

#if 0
    //
    // Don't run if we're a TS client.
    //
    if( (ISNT()) &&
        (BuildNumber >= NT40) ) {

        //
        // From winuser.h
        //
        #define SM_REMOTESESSION        0x1000

        if( GetSystemMetrics(SM_REMOTESESSION) == TRUE ) {

            rc = 1;
            //
            // Someone is trying to run us inside of a TerminalServer client!!
            // Bail.
            //
            MessageBoxFromMessage(
               NULL,
               MSG_TS_CLIENT_FAIL,
               FALSE,
               IDS_APPTITLE,
               MB_OK | MB_ICONSTOP | MB_TASKMODAL
               );

            goto c1;
        }
    }
#endif


    //
    // inititialize com
    //

    CoInitialize(NULL);

#if defined(REMOTE_BOOT)
    //
    // Determine whether this is a remote boot client.
    //

    RemoteBoot = FALSE;
    *MachineDirectory = 0;
    if (ISNT()) {
        HMODULE hModuleKernel32 = LoadLibrary(TEXT("kernel32"));
        if (hModuleKernel32) {
            BOOL (*getSystemInfoEx)(
                    IN SYSTEMINFOCLASS dwSystemInfoClass,
                    OUT LPVOID lpSystemInfoBuffer,
                    IN OUT LPDWORD nSize);
            (FARPROC)getSystemInfoEx = GetProcAddress(
                                            hModuleKernel32,
#if defined(UNICODE)
                                            "GetSystemInfoExW"
#else
                                            "GetSystemInfoExA"
#endif
                                            );
            if (getSystemInfoEx != NULL) {
                BOOL flag;
                DWORD size = sizeof(BOOL);
                if (getSystemInfoEx(SystemInfoRemoteBoot, &flag, &size)) {
                    RemoteBoot = flag;
                    size = MAX_PATH * sizeof(TCHAR);
                    if (!getSystemInfoEx(
                            SystemInfoRemoteBootServerPath,
                            MachineDirectory,
                            &size)) {
                        DWORD error = GetLastError();
                        MYASSERT( !"GetSystemInfoExW failed!" );
                    } else {
                        PTCHAR p;
#if defined(UNICODE)
                        p = wcsrchr(MachineDirectory, L'\\');
#else
                        p = strrchr(MachineDirectory, '\\');
#endif
                        MYASSERT(p != NULL);
                        *p = 0;
                    }
                }
            }
            FreeLibrary(hModuleKernel32);
        }
    }
#endif // defined(REMOTE_BOOT)


#ifdef _X86_

    if (IsNEC98 ()) {
        //
        // don't install on NEC98 machines (#141004)
        //
        MessageBoxFromMessage(
            NULL,
            MSG_PLATFORM_NOT_SUPPORTED,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONSTOP | MB_TASKMODAL
            );
        rc = 1;
        goto c1;
    }

    //
    // Check setup sources and platform.
    // NEC98 NT5 have 98PNTN16.DLL.
    // I use this file for check platform NEC98 or x86.
    //
    {


#define WINNT_NEC98SPECIFIC_MODULE TEXT("98PTN16.DLL")

    TCHAR MyPath[MAX_PATH];
    int CheckNEC98Sources=FALSE;
    WIN32_FIND_DATA fdata;
    PTSTR p;

        if( !GetModuleFileName (NULL, MyPath, MAX_PATH) || !(p=_tcsrchr (MyPath, TEXT('\\')))) {
                rc = 1;
                goto c1;
        }
        p = 0;
        ConcatenatePaths (MyPath, WINNT_NEC98SPECIFIC_MODULE, MAX_PATH);
        if (FindFirstFile(MyPath, &fdata) != INVALID_HANDLE_VALUE){
            CheckNEC98Sources=TRUE;
        }
        if(CheckNEC98Sources){
            if (!IsNEC98()){
                rc = 1;
                MessageBoxFromMessage(
                    NULL,
                    MSG_INCORRECT_PLATFORM,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                    );

                goto c1;
            }
        } else {
            if (IsNEC98()){
                rc = 1;
                MessageBoxFromMessage(
                    NULL,
                    MSG_INCORRECT_PLATFORM,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                );
                goto c1;
            }
        }
    }

    //
    // Some NEC98 Windows NT4 system is installed DMITOOL
    // This AP block the CreateFile API
    // Setup need to check this AP
    //
    if (IsNEC98() && ISNT()){
        if (NEC98CheckDMI() == TRUE){
            rc = 1;
            MessageBoxFromMessage(
                NULL,
            MSG_NEC98_NEED_UNINSTALL_DMITOOL,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                );
            goto c1;
        }
    }

    LocateFirstFloppyDrive();

    //
    // Fix up boot messages.
    // NEC98 FAT16/FAT32 boot code does't have message area.
    //
    if (!IsNEC98())
    {
        if(!PatchTextIntoBootCode()) {
            rc = 1;
            MessageBoxFromMessage(
                NULL,
                MSG_BOOT_TEXT_TOO_LONG,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );
            goto c1;
        }
    }
    //
    // Disallow installing/upgrading on a 386 or 486
    // 3.51 and Win9x ran on 386's so this check is still necessary.
    //
    {
        SYSTEM_INFO SysInfo;
#ifdef UNICODE
        TCHAR buff[100];
#endif

        GetSystemInfo(&SysInfo);
        if (SysInfo.dwProcessorType == PROCESSOR_INTEL_386 ||
            SysInfo.dwProcessorType == PROCESSOR_INTEL_486) {
            rc = 1;
            MessageBoxFromMessage(
                NULL,
                MSG_REQUIRES_586,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                );

            goto c1;
        }

#ifdef UNICODE
        //
        // Disallow IA64 machines from running an x86
        // version of winnt32.exe.
        //
        {
            ULONG_PTR p;
            NTSTATUS status;

            status = NtQueryInformationProcess (
                        NtCurrentProcess (),
                        ProcessWow64Information,
                        &p,
                        sizeof (p),
                        NULL
                        );
            if (NT_SUCCESS (status) && p) {
                rc = 1;
                //
                // 32-bit code running on Win64
                //
                MessageBoxFromMessage(
                    NULL,
                    MSG_NO_CROSS_PLATFORM,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                    );

                goto c1;
            }
        }
#endif
    }

#endif // _X86_

    if (!g_DynUpdtStatus->Disabled) {
        if (g_DynUpdtStatus->PrepareWinnt32) {
            if (!g_DynUpdtStatus->DynamicUpdatesSource[0]) {
                //
                // no share to update was specified
                //
                MessageBoxFromMessage(
                   NULL,
                   MSG_NO_UPDATE_SHARE,
                   FALSE,
                   AppTitleStringId,
                   MB_OK | MB_ICONSTOP | MB_TASKMODAL
                   );
                rc = 1;
                goto c1;
            }
        } else {
            //
            // spec change: even if /unattend is specified, still do DU
            //
#if 0
            if (UnattendedOperation && !g_DynUpdtStatus->UserSpecifiedUpdates) {
                //
                // if unattended, disable Dynamic Setup page by default
                //
                g_DynUpdtStatus->Disabled = TRUE;
            }
#endif
        }
    }

    //
    // Load extension/downlevel DLLs.
    //

    // Don't load upgrade support if we're running in WinPE.
    //
    if (!IsWinPEMode()) {
        LoadUpgradeSupport();
    }
    else {
         ZeroMemory(&UpgradeSupport, sizeof(UpgradeSupport));
         Upgrade = FALSE;
    }

    //
    // Load setupapi. Do this *AFTER* we load upgrade support,
    // because one of the upgrade support dlls might link to or load
    // setupapi.dll. That dll might be picky but we can use any old
    // setupapi.dll for what we need.
    //
    if (!LoadSetupapi()) {
        rc = 1;
        goto c1;
    }


#ifdef _X86_

    //
    // If this is a win9x machine, check to ensure that there are no
    // virus scanners that could block a successful upgrade _or_
    // clean install.
    //
    if (!ISNT() && !SkipVirusScannerCheck && !CheckVirusScanners()) {

        rc = 1;
        goto c1;
    }

#endif

    if(!IsArc()) {
#ifdef _X86_
        if(!InitializeArcStuff(NULL)) {
            rc = 1;
            goto c1;
        }
#endif // _X86_
    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        if(!ArcInitializeArcStuff(NULL)) {
            rc = 1;
            goto c1;
        }
#endif // UNICODE
    } // if (!IsArc())

    //
    // Don't allow upgrades from early NT 5 builds.
    //
    if( !CheckBuildNumber() ) {

        MessageBoxFromMessage(
           NULL,
           MSG_CANT_UPGRADE_FROM_BUILD_NUMBER,
           FALSE,
           AppTitleStringId,
           MB_OK | MB_ICONSTOP | MB_TASKMODAL
           );

        Upgrade = FALSE;
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot client, it MUST upgrade. It cannot install a new
    // version of the OS. If upgrade has been disabled for some reason, stop now.
    //

    if (RemoteBoot && !Upgrade) {
        rc = 1;
        MessageBoxFromMessage(
            NULL,
            MSG_REQUIRES_UPGRADE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
            );
        goto c1;
    }
#endif // defined(REMOTE_BOOT)

    //if(UnattendedOperation && UnattendedScriptFile && !FetchArguments()) {
    //    rc = 1;
    //    goto c1;
    //}

    //
    // Set up various other option defaults.
    //
    InitVariousOptions();


    if (!g_DynUpdtStatus->PrepareWinnt32) {
        //
        // Make sure the Source files and target operating system
        // are of the same locale.  If they aren't, we'll disable
        // ability to upgrade.
        //
        // Init the locale engine.
        //
        //
        if( InitLanguageDetection( NativeSourcePaths[0], TEXT("intl.inf") ) ) {

            if( !SkipLocaleCheck && (Upgrade || UpgradeFailureReason) && !IsLanguageMatched) {

                //
                // Tell the user we can't upgrade then kill his ability to do so.
                //
                MessageBoxFromMessage( NULL,
                                       MSG_UPGRADE_LANG_ERROR,
                                       FALSE,
                                       IDS_APPTITLE,
                                       MB_OK | MB_ICONERROR | MB_TASKMODAL,
                                       NULL );

                Upgrade = FALSE;
            }
        }

        //
        // Now that we have done the language check, go ahead and see if we have a message
        // to give to the user about why they cannot upgrade.
        //
        if (IsLanguageMatched && UpgradeFailureReason && UpgradeFailureMessages[UpgradeFailureReason]) {

                //
                // Tell the user we can't upgrade then kill his ability to do so.
                //
                MessageBoxFromMessage( NULL,
                                       UpgradeFailureMessages[UpgradeFailureReason],
                                       FALSE,
                                       IDS_APPTITLE,
                                       MB_OK | MB_ICONERROR | MB_TASKMODAL,
                                       NULL );

                Upgrade = FALSE;
        }


        //
        // Check to see if we're on a cluster.  If so, and the user
        // didn't specify a tempdrive, then it's possible for us to
        // select a shared disk, which may not be available for us
        // when we come back up into textmode.  Warn the user.
        //
        // Note that we need to wait until now because RunFromCD
        // doesn't get set until InitVariousOptions().
        //
        if( ISNT() &&
            (RunFromCD == FALSE) &&
            (!UserSpecifiedLocalSourceDrive) ) {
        int         i;
        HMODULE     ClusApiHandle;
        FARPROC     MyProc;
        HANDLE      hCluster;
        BOOL        OnCluster = FALSE;

            try {
                if( ClusApiHandle = LoadLibrary( TEXT("clusapi") ) ) {

                    if( MyProc = GetProcAddress(ClusApiHandle,"OpenCluster")) {

                        hCluster = (HANDLE)MyProc(NULL);

                        if( hCluster != NULL ) {
                            //
                            // Fire.
                            //
                            OnCluster = TRUE;

                            if( MyProc = GetProcAddress( ClusApiHandle, "CloseCluster")) {
                                MyProc( hCluster );
                            }
                        }
                    }

                    FreeLibrary( ClusApiHandle );
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }

            if( OnCluster ) {
                i = MessageBoxFromMessage( NULL,
                                           MSG_CLUSTER_WARNING,
                                           FALSE,
                                           IDS_APPTITLE,
                                           MB_OKCANCEL | MB_ICONEXCLAMATION,
                                           NULL );
                if(i == IDCANCEL) {
                    rc = 1;
                    goto c1;
                }
            }
        }
    }

    //
    // setup source install type(retail,oem,or select)
    //
    GetSourceInstallType(0);

    _tcscpy( InstallDir, DEFAULT_INSTALL_DIR );

    //
    // Create a mutex to serialize error ui.
    //
    UiMutex = CreateMutex(NULL,FALSE,NULL);
    if(!UiMutex) {
        rc = 1;
        MessageBoxFromMessage(
            NULL,
            GetLastError(),
            TRUE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        goto c1;
    }

    //
    // Attempt to disable the PM engine from powering down
    // the machine while the wizard is going.  The API we're
    // going to call doesn't exist on all versions of Windows,
    // so manually try and load the entry point.  If we fail,
    // so be it.
    //
    {
    typedef     EXECUTION_STATE (WINAPI *PTHREADPROC) (IN EXECUTION_STATE esFlags);
    HMODULE     Kernel32Handle;
    PTHREADPROC MyProc;

        if( Kernel32Handle = LoadLibrary( TEXT("kernel32") ) ) {

            if( MyProc = (PTHREADPROC)GetProcAddress(Kernel32Handle,"SetThreadExecutionState")) {

                MyProc( ES_SYSTEM_REQUIRED |
                        ES_DISPLAY_REQUIRED |
                        ES_CONTINUOUS );
            }

            FreeLibrary( Kernel32Handle );
        }
    }

    //
    // Go off and do it.
    //

    if (Winnt32Dlg) {
        DestroyWindow (Winnt32Dlg);
        Winnt32Dlg = NULL;
    }
    if (WinNT32StubEvent) {
        SetEvent (WinNT32StubEvent);
        WinNT32StubEvent = NULL;
    }

    if( BuildCmdcons ) {
        // if we were told to build a cmdcons boot we do this instead
        if (!IsArc()) {
#ifdef _X86_
            if (ISNT()) {
                CalcThroughput();
                DoBuildCmdcons();
            } else {
                //
                // We don't support building a cmdcons from Win9x.
                //
                MessageBoxFromMessage( NULL,
                                   MSG_CMDCONS_WIN9X,
                                   FALSE,
                                   IDS_APPTITLE,
                                   MB_OK | MB_ICONEXCLAMATION,
                                   NULL );

                GlobalResult = FALSE;
            }
#endif
        } else {
#ifdef UNICODE
            //
            // We don't support building a cmdcons on Alpha platforms.
            //
            MessageBoxFromMessage( NULL,
                                   MSG_CMDCONS_RISC,
                                   FALSE,
                                   IDS_APPTITLE,
                                   MB_OK | MB_ICONEXCLAMATION,
                                   NULL );
            GlobalResult = FALSE;
#endif
        }

    } else if (g_DynUpdtStatus->PrepareWinnt32) {

        if (!DynamicUpdateProcessFiles (&b)) {
            MessageBoxFromMessage (
                NULL,
                MSG_PREPARE_SHARE_FAILED,
                FALSE,
                IDS_APPTITLE,
                MB_OK | MB_ICONEXCLAMATION,
                NULL
                );
            rc = 1;
        }
        //
        // clean up stuff
        //
        if (g_DynUpdtStatus->WorkingDir[0]) {
            MyDelnode (g_DynUpdtStatus->WorkingDir);
        }

    } else {
        if (g_DynUpdtStatus->Disabled) {
            DebugLog (Winnt32LogInformation, NULL, LOG_DYNUPDT_DISABLED);
        }
        CalcThroughput();
        Wizard();
    }

    //
    // Back from the wizard. Either clean up or shut down, as appropriate.
    //
    if(GlobalResult) {

#ifdef _X86_
        MYASSERT (SystemPartitionDriveLetter);
        MarkPartitionActive(SystemPartitionDriveLetter);

        if(IsNEC98()){
            // If System is NT and NEC98 Driver assign.
            // We need delete registry key "DriveLetter=C" in setupreg.hive
            if (ISNT() && (IsDriveAssignNEC98() == TRUE)){
                DeleteNEC98DriveAssignFlag();
            }

            //
            // If floppyless setup, set AUTO-BOOT flag in boot sector on NEC98
            //
            if((Floppyless || UnattendedOperation)) {
                SetAutomaticBootselector();
            }
        }
#endif

        //
        // Uninstall: blow away existing backup of OS, if we are upgrading to
        // a newer build.
        //

        pRemoveOutdatedBackupImage();

        //
        // SMS: report success
        //
        if(InstallStatusMIF) {

            PSTR    Buffer;

            FormatMessageA(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hInst,
                MSG_SMS_SUCCEED,
                0,
                (PSTR)&Buffer,
                0,
                NULL
                );

            InstallStatusMIF(
                "setupinf",
                "Microsoft",
                "Windows NT",
                "5.0",
                "",
                "",
                Buffer,
                TRUE
                );

            LocalFree( Buffer );
        }

        //
        // Close the log if it was open
        //

        if (fnSetupCloseLog) {
            Footer = GetStringResource (MSG_LOG_END);
            if (Footer) {
                fnSetupOpenLog (FALSE);
                fnSetupLogError (Footer, LogSevInformation);
                FreeStringResource (Footer);
                fnSetupCloseLog();
            }

        }

        //
        // Success. Attempt to shut down the system. On NT we have
        // a cool API that does this with a countdown. On Win95 we don't.
        // On NT5 and beyond, we have an even cooler API that takes
        // a reason for shutting down.  Don't statically link to it
        // or else this will fall over when run from an NT4 machine.
        //
        if(AutomaticallyShutDown) {

#ifdef RUN_SYSPARSE
            DWORD ret;
            // Wait up to 90 seconds for sysparse to finish
            if (!NoSysparse && piSysparse.hProcess) {
                ret = WaitForSingleObject( piSysparse.hProcess, 0);
                if( ret != WAIT_OBJECT_0) {
                    DialogBox(
                        hInst,
                        MAKEINTRESOURCE(IDD_SYSPARSE),
                        GetBBhwnd(),
                        SysParseDlgProc
                        );
                }
                CloseHandle(piSysparse.hProcess);
                CloseHandle(piSysparse.hThread);
                piSysparse.hProcess = NULL;
            }
#endif

            //
            // On upgrades we disable System Restore. This saves us space in GUI mode by cleaning out its cache.
            // We do this only at the point where we reboot. In the /noreboot case we decide to ignore this
            // Not many people would run into that as it is a commandline option. The routine chaecks for presence of
            // srclient.dll and only does this on the platforms it is present in.
            //

            DisableSystemRestore();

            // reset the screen saver to what we found when we entered winnt32
            // This is in the reboot case
            SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bScreenSaverOn, NULL,0);

            if(ISNT()) {

                HINSTANCE hAdvapi = GetModuleHandle(TEXT("advapi32.dll"));
                PFNINITIATESYSTEMSHUTDOWNEX pfnShutdownEx = NULL;
                LPCSTR lpProcName;

                if (UnattendedOperation || DisplayExitWindowsWarnings(EWX_REBOOT))
                {
#ifdef UNICODE
                    lpProcName = "InitiateSystemShutdownExW";
#else
                    lpProcName = "InitiateSystemShutdownExA";
#endif

                    LoadString(hInst,IDS_REBOOT_MESSAGE,Text,sizeof(Text)/sizeof(TCHAR));

                    if (hAdvapi) {
                        pfnShutdownEx = (PFNINITIATESYSTEMSHUTDOWNEX)
                            GetProcAddress(hAdvapi,
                            lpProcName);
                    }


                    //
                    // We checked up front whether we have the privilege,
                    // so getting it should be no problem. If we can't,
                    // then just let shutdown fail -- it will tell us why it failed.
                    //
                    EnablePrivilege(SE_SHUTDOWN_NAME,TRUE);

                    if (pfnShutdownEx) {
                        b = pfnShutdownEx(NULL,
                            Text,
                            UnattendedShutdownTimeout,
                            UnattendedShutdownTimeout != 0,
                            TRUE,
                                SHTDN_REASON_FLAG_PLANNED |
                                SHTDN_REASON_MAJOR_OPERATINGSYSTEM |
                                (Upgrade ? SHTDN_REASON_MINOR_UPGRADE : SHTDN_REASON_MINOR_INSTALLATION)
                            );
                        //
                        // on 5.1, force a shutdown even if the machine was locked
                        // to maintain W2K compatibility
                        // only do this if an unattended install was in progress
                        //
                        if (!b && (GetLastError () == ERROR_MACHINE_LOCKED) && UnattendSwitchSpecified) {
                            b = pfnShutdownEx (
                                    NULL,
                                    Text,
                                    0,
                                    TRUE,
                                    TRUE,
                                        SHTDN_REASON_FLAG_PLANNED |
                                        SHTDN_REASON_MAJOR_OPERATINGSYSTEM |
                                        (Upgrade ? SHTDN_REASON_MINOR_UPGRADE : SHTDN_REASON_MINOR_INSTALLATION)
                                    );
                        }
                    }
                    else {
                        b = InitiateSystemShutdown(NULL,
                            Text,
                            UnattendedShutdownTimeout,
                            UnattendedShutdownTimeout != 0,
                            TRUE);
                    }
                }
            } else {
                b = ExitWindowsEx(EWX_REBOOT,0);
                if(!b) {
                    b = ExitWindowsEx(EWX_REBOOT | EWX_FORCE,0);
                }
            }

            if(!b) {

                rc = 1;
                MessageBoxFromMessageAndSystemError(
                    NULL,
                    MSG_REBOOT_FAILED,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONWARNING | MB_TASKMODAL
                    );

                goto c2;
            }
        }
    } else {
        if (CheckUpgradeOnly) {
            //
            // perform some DU cleanup here since the cleanup routine
            // doesn't get called in /checkupgradeonly mode
            //
            if (g_DynUpdtStatus->ForceRemoveWorkingDir || !g_DynUpdtStatus->PreserveWorkingDir) {
                if (g_DynUpdtStatus->WorkingDir[0] && !g_DynUpdtStatus->RestartWinnt32) {
                    MyDelnode (g_DynUpdtStatus->WorkingDir);
                }

                GetCurrentWinnt32RegKey (Text, MAX_PATH);
                ConcatenatePaths (Text, WINNT_U_DYNAMICUPDATESHARE, MAX_PATH);
                RegDeleteKey (HKEY_LOCAL_MACHINE, Text);
            }

        } else {

            if (!g_DynUpdtStatus->RestartWinnt32 && !g_DynUpdtStatus->PrepareWinnt32) {
                rc = 1;
            }
        }
    }

c2:
    CloseHandle(UiMutex);
c1:
    //
    // Destroy the mutex.
    //
    CloseHandle(Mutex);
c0:

    // reset the screen saver to what we found when we entered winnt32
    // This is if we don't reboot. e.g.: user canceled
    SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bScreenSaverOn, NULL,0);
    //
    // destroy the welcome dialog if still active
    //
    if (Dlg) {
        DestroyWindow (Dlg);
        Dlg = NULL;
    }
    //
    // and release the original process if launched over a network
    //
    if (WinNT32Stub) {
        SetEvent (WinNT32Stub);
        WinNT32Stub = NULL;
    }

    if (g_EncryptedPID)
    {
        GlobalFree(g_EncryptedPID);
        g_EncryptedPID = NULL;
    }

    //
    // SMS: report failure
    //
    if(!GlobalResult && !g_DynUpdtStatus->RestartWinnt32 && InstallStatusMIF) {

        PSTR    Buffer;

        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            hInst,
            MSG_SMS_FAIL,
            0,
            (PSTR)&Buffer,
            0,
            (va_list *)&LastMessage
            );

        InstallStatusMIF(
            "setupinf",
            "Microsoft",
            "Windows NT",
            "5.1",
            "",
            "",
            Buffer,
            FALSE
            );
    }

    if(SMSHandle) {
        FreeLibrary( SMSHandle );
    }

    //
    // Now clean up our debug log if we're only checking
    // the upgrade scenario.
    //
    if( CheckUpgradeOnly ) {
        GatherOtherLogFiles();
    }

    //
    // Close the debug log.
    //
    CloseDebugLog();
    TerminateBillBoard();

    if (BackgroundWnd2)
    {
        DestroyWindow (BackgroundWnd2);
        BackgroundWnd2 = NULL;
    }
    if (hinstBB)
    {
        FreeLibrary(hinstBB);
        hinstBB = NULL;
    }

    if (RestartCmdLine) {
#ifdef UNICODE
        if (g_DynUpdtStatus->RestartCmdLine) {
            INT i = 0;
            INT size = (lstrlenW (g_DynUpdtStatus->RestartCmdLine) + 1) * 2;
            PSTR ansi = HeapAlloc (GetProcessHeap (), 0, size);
            if (ansi) {
                i = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        g_DynUpdtStatus->RestartCmdLine,
                        size / 2,
                        ansi,
                        size,
                        NULL,
                        NULL
                        );
            }
            HeapFree (GetProcessHeap (), 0, g_DynUpdtStatus->RestartCmdLine);

            if (i == 0 && ansi) {
                HeapFree (GetProcessHeap (), 0, ansi);
                ansi = NULL;
            }
            *RestartCmdLine = ansi;
        } else {
            *RestartCmdLine = NULL;
        }
#else
        *RestartCmdLine = g_DynUpdtStatus->RestartCmdLine;
#endif
        g_DynUpdtStatus->RestartCmdLine = NULL;
    } else {
        if (g_DynUpdtStatus->RestartCmdLine) {
            HeapFree (GetProcessHeap (), 0, g_DynUpdtStatus->RestartCmdLine);
        }
    }

    if (g_DynUpdtStatus) {
        FREE (g_DynUpdtStatus);
        g_DynUpdtStatus = NULL;
    }

EXITNOW:
    SetUnhandledExceptionFilter( pLastExceptionFilter);
    return rc;
}


BOOLEAN
AdjustPrivilege(
    PWSTR   Privilege
    )
/*++

Routine Description:

    This routine tries to adjust the priviliege of the current process.


Arguments:

    Privilege - String with the name of the privilege to be adjusted.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               (LPCTSTR)Privilege, // (LPWSTR)SE_SECURITY_NAME,
                               &( LuidAndAttributes.Luid ) ) ) {
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        return( FALSE );
    }

    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }
    return( TRUE );
}


#ifdef _X86_
//
// winnt32.exe Floppyless setup for PC-9800
// setting automatic bootselector main function
//
VOID
SetAutomaticBootselector(
    VOID
    )
{
//
// This function check System.
// If System is NT, call SetAutomaticBootselectorNT(),
// If System is 95, call SetAutomaticBootselector95(),
//

    if (ISNT()){
        SetAutomaticBootselectorNT();
    } else {
        // Now I run on Win95 or Memphis.
        SetAutomaticBootselector95();
    }
}

VOID
SetAutomaticBootselectorNT(
    VOID
    )
{
    // must use WIN32 function.
    ULONG i,bps;
    PUCHAR pBuffer,pUBuffer;
    WCHAR DevicePath[128];
    HANDLE hDisk;
    NTSTATUS Sts;
    DISK_GEOMETRY MediaInfo;
    DWORD DataSize;
            struct _NEC98_partition_table {
                BYTE BootableFlag;
                BYTE SystemType;
                BYTE Reserve[2];
                BYTE IPLStartSector;
                BYTE IPLStartHead;
                WORD IPLStartCylinder;
                BYTE StartSector;
                BYTE StartHead;
                WORD StartCylinder;
                BYTE EndSector;
                BYTE EndHead;
                WORD EndCylinder;
                CHAR SystemName[16];
            } *PartitionTable;
            LONG StartSector;
    LONG HiddenSector;
    BOOL b;

    //
    // Determine the number of hard disks attached to the system
    // and allocate space for an array of Disk Descriptors.
    //
    for(i=0; i<40; i++){
        swprintf(DevicePath,L"\\\\.\\PHYSICALDRIVE%u",i);
        hDisk =   CreateFileW( DevicePath,
                              0,
                              FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, 0, NULL);
        if(hDisk == INVALID_HANDLE_VALUE) {
            continue;
        }
        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(DISK_GEOMETRY),
                &DataSize,
                NULL
                );
        CloseHandle(hDisk);
        //
        // It's really a hard disk.
        //
        if(b == 0){
            continue;
        }
        if(MediaInfo.MediaType == RemovableMedia) {
            continue;
        }

        hDisk =   CreateFileW( DevicePath,
                              GENERIC_READ|GENERIC_WRITE,
                              FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, 0, NULL);
        if(hDisk == INVALID_HANDLE_VALUE) {
            continue;
        }

        if (CheckATACardonNT4(hDisk)){
            CloseHandle(hDisk);
            continue;
        }

        if ((bps = GetHDBps(hDisk)) == 0){
            CloseHandle(hDisk);
            continue;
        }
        pUBuffer = MALLOC(bps * 3);
        pBuffer = ALIGN(pUBuffer, bps);
        RtlZeroMemory(pBuffer, bps * 2);
        Sts = SpReadWriteDiskSectors(hDisk,0,1,bps,pBuffer, NEC_READSEC);
        if(!NT_SUCCESS(Sts)) {
            FREE(pUBuffer);
            CloseHandle(hDisk);
            continue;
        }

        //
        // If PC-AT HD, No action.
        //
        if (!(pBuffer[4] == 'I'
           && pBuffer[5] == 'P'
           && pBuffer[6] == 'L'
           && pBuffer[7] == '1')){
            FREE(pUBuffer);
            CloseHandle(hDisk);
            continue;
        }
        if ((pBuffer[bps - 5] == 0) && pBuffer[bps - 6] == 0){
            FREE(pUBuffer);
            CloseHandle(hDisk);
            continue;
        }

        //
        //  Clear BootRecord
        //
        pBuffer[bps - 5] = 0x00;
        pBuffer[bps - 6] = 0x00;

        SpReadWriteDiskSectors(hDisk,0,1,bps,pBuffer, NEC_WRITESEC);
        FREE(pUBuffer);
        CloseHandle(hDisk);
    }
    MYASSERT (SystemPartitionDriveLetter);
    HiddenSector = CalcHiddenSector((TCHAR)SystemPartitionDriveLetter, (SHORT)bps);
    if(GetSystemPosition(&hDisk, &MediaInfo ) != 0xff) {
        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(DISK_GEOMETRY),
                &DataSize,
                NULL
                );
        pUBuffer = MALLOC(bps * 3);
        pBuffer = ALIGN(pUBuffer, bps);
        RtlZeroMemory(pBuffer, bps * 2);
        bps = MediaInfo.BytesPerSector;
        Sts = SpReadWriteDiskSectors(hDisk,0,2,bps,pBuffer, NEC_READSEC);
        PartitionTable = (struct _NEC98_partition_table *)(pBuffer + 512);

        if(NT_SUCCESS(Sts)) {

            //
            // Update BootRecord
            //

            for (i = 0; i <16; i++, PartitionTable++){
                if (((PartitionTable->SystemType) & 0x7f) == 0)
                    break;
                StartSector =
                    (((PartitionTable->StartCylinder * MediaInfo.TracksPerCylinder)
                    + PartitionTable->StartHead) * MediaInfo.SectorsPerTrack)
                    + PartitionTable->StartSector;
                if (StartSector == HiddenSector){
                    pBuffer[bps - 5] = (UCHAR)i;
                    pBuffer[bps - 6] = 0x80;
                    PartitionTable->BootableFlag |= 0x80;
                    Sts = SpReadWriteDiskSectors(hDisk,0,2,bps,pBuffer, NEC_WRITESEC);
                }
            }
        }
        FREE(pUBuffer);
        CloseHandle(hDisk);
    }
}
// I970721
VOID
SetAutomaticBootselector95(
    VOID
    )
{

    int bBootDrvLtr;


    if(!W95SetAutoBootFlag) {

        //
        // Entry points couldn't be found. The upgrade dll is corrupt.
        //
        MessageBoxFromMessage(
            NULL,
            MSG_UPGRADE_DLL_CORRUPT,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            UpgradeSupport.DllPath
            );
    } else {
        MYASSERT (SystemPartitionDriveLetter);
        bBootDrvLtr = (int)SystemPartitionDriveLetter;
        if (Upgrade)
            W95SetAutoBootFlag(bBootDrvLtr);
        else {
            W95SetABFwFresh(bBootDrvLtr);
        }
    }

}


//
// disksectors read and write function
// I970721
//
NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOL    ReadWriteSec
    )

/*++

Routine Description:

    Reads or writes one or more disk sectors.

Arguments:

    Handle - supplies handle to open partition object from which
        sectors are to be read or written.  The handle must be
        opened for synchronous I/O.

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    DWORD IoSize, IoSize2;
    OVERLAPPED Offset;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // Calculate the large integer byte offset of the first sector
    // and the size of the I/O.
    //

    Offset.Offset = SectorNumber * BytesPerSector;
    Offset.OffsetHigh = 0;
    Offset.hEvent = NULL;
    IoSize = SectorCount * BytesPerSector;

    //
    // Perform the I/O.
    //
    if ( ReadWriteSec == NEC_READSEC){
        (NTSTATUS)Status = ReadFile(
                               Handle,
                               AlignedBuffer,
                               IoSize,
                               &IoSize2,
                               &Offset
                           );
        } else {
        (NTSTATUS)Status = WriteFile(
                               Handle,
                               AlignedBuffer,
                               IoSize,
                               &IoSize2,
                               &Offset
                           );
        }

    return(Status);
}

//
// Get WindowsNT System Position
// I970721
//
UCHAR
GetSystemPosition(
    PHANDLE phDisk,
    PDISK_GEOMETRY pSystemMediaInfo
    )
{

    HANDLE Handle;
    DWORD DataSize;
    TCHAR HardDiskName[] = TEXT("\\\\.\\?:");
    WCHAR Buffer[128];
    WCHAR DevicePath[128];
    WCHAR DriveName[3];
    WCHAR DiskNo;
    UCHAR Position = 0xff, i, errorpt=0;
    PWCHAR p, stop;
    STORAGE_DEVICE_NUMBER   number;
    DWORD ExtentSize, err_no;
    BOOL b;
    PVOLUME_DISK_EXTENTS Extent;


    MYASSERT (SystemPartitionDriveLetter);
    HardDiskName[4] = SystemPartitionDriveLetter;
    DriveName[0] = SystemPartitionDriveLetter;
    DriveName[1] = ':';
    DriveName[2] = 0;
    if(QueryDosDeviceW(DriveName,Buffer,sizeof(Buffer)/sizeof(WCHAR))) {

        //
        // Get SystemPartition Harddisk Geometry
        //
        Handle = CreateFile(
                    HardDiskName,
                    GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
                    );

        if(Handle != INVALID_HANDLE_VALUE) {
            DeviceIoControl(
                Handle,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                pSystemMediaInfo,
                sizeof(DISK_GEOMETRY),
                &DataSize,
                NULL
                );
        //
        // Get SystemPartition Potition
        //
            if (BuildNumber <= NT40){ //check NT Version
                p = wcsstr(Buffer,L"\\Partition");
                Position = (UCHAR)wcstol((p + 10) ,&stop ,10);
                //
                // QueryDosDevice in NT3.51 is buggy.
                // This API return "\\Harddisk\...." or
                // "\\harddisk\...."
                // We need work around.
                //
                p = wcsstr(Buffer,L"arddisk");
                DiskNo = (*(p + 7) - 0x30);
            } else {
                b = DeviceIoControl(Handle, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                            &number, sizeof(number), &DataSize, NULL);
                if (b) {
                    Position = (UCHAR) number.PartitionNumber;
                    DiskNo = (UCHAR) number.DeviceNumber;
                } else {
                    Extent = malloc(1024);
                    ExtentSize = 1024;
                    if(!Extent) {
                        CloseHandle( Handle );
                        return(Position);
                    }
                    b = DeviceIoControl(Handle, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                        NULL, 0,
                                        (PVOID)Extent, ExtentSize, &DataSize, NULL);
                    if (!b) {
                        free(Extent);
                        CloseHandle( Handle );
                        return(Position);
                    }
                    if (Extent->NumberOfDiskExtents != 1){
                        free(Extent);
                        CloseHandle( Handle );
                        return(Position);
                    }
                    DiskNo = (TCHAR)Extent->Extents->DiskNumber;
                    Position = 0;
                    free(Extent);
                }
            }
            CloseHandle(Handle);
            swprintf(DevicePath,L"\\\\.\\PHYSICALDRIVE%u",DiskNo);
            *phDisk = CreateFileW( DevicePath, GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL
                );
        }
    }
    return(Position);
}

BOOL
IsNEC98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}


VOID
LocateFirstFloppyDrive(
    VOID
    )
{
    UINT rc;
    TCHAR i;

    if(!IsNEC98()) {
        FirstFloppyDriveLetter = TEXT('A');
        return;
    }

    //
    // MyGetDriveType returns DRIVE_REMOVABLE, if drive is floppy.
    //
    for(i = TEXT('A'); i <= TEXT('Y'); i++) {

        if((rc = MyGetDriveType(i)) == DRIVE_REMOVABLE) {
            FirstFloppyDriveLetter = i;
            return;
        }
    }

    //
    // None found yet, set it to Z
    //
    FirstFloppyDriveLetter = TEXT('Z');
}

VOID
DeleteNEC98DriveAssignFlag(
    VOID
    )
{
    TCHAR HiveName[MAX_PATH];
    TCHAR tmp[256];
    LONG  res;
    HKEY hhive;

    lstrcpy(HiveName,LocalBootDirectory);
    ConcatenatePaths(HiveName,TEXT("setupreg.hiv"),MAX_PATH);
    AdjustPrivilege((unsigned short *)SE_RESTORE_NAME);
    res = RegLoadKey(HKEY_LOCAL_MACHINE, TEXT("$WINNT32"), HiveName);
    if (res != ERROR_SUCCESS){
        return;
    }
    res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("$WINNT32\\setup"), 0, KEY_ALL_ACCESS, &hhive);
    if (res != ERROR_SUCCESS){
        RegUnLoadKey(HKEY_LOCAL_MACHINE, TEXT("$WINNT32"));
        return;
    }
    res = RegDeleteValue(hhive, TEXT("DriveLetter"));
    res = RegCloseKey(hhive);
    res = RegUnLoadKey(HKEY_LOCAL_MACHINE, TEXT("$WINNT32"));

}

VOID
W95SetABFwFresh(
    int bBootDrvLtr
    )
{
//
// These items are used to call 98ptn32.dll.
//
//
// Almost below codes are copied from win95upg\w95upg\init9x\init9x.c
//


typedef BOOL (CALLBACK WIN95_PLUGIN_98PTN32_SETBOOTFLAG_PROTOTYPE)(int, WORD);
typedef WIN95_PLUGIN_98PTN32_SETBOOTFLAG_PROTOTYPE * PWIN95_PLUGIN_98PTN32_SETBOOTFLAG;

#define WIN95_98PTN32_SETBOOTFLAG_W   L"SetBootable95ptn32"
#define WIN95_98PTN32_SETBOOTFLAG_A   "SetBootable95ptn32"
#define NEC98_DLL_NAME_W            L"98PTN32.DLL"
#define NEC98_DLL_NAME_A            "98PTN32.DLL"
#ifdef UNICODE
#define WIN95_98PTN32_SETBOOTFLAG  WIN95_98PTN32_SETBOOTFLAG_W
#define NEC98_DLL_NAME  NEC98_DLL_NAME_W
#else
#define WIN95_98PTN32_SETBOOTFLAG  WIN95_98PTN32_SETBOOTFLAG_A
#define NEC98_DLL_NAME  NEC98_DLL_NAME_A
#endif
#define SB_BOOTABLE   0x0001
#define SB_UNBOOTABLE 0x0002
#define MSK_BOOTABLE  0x000f
#define SB_AUTO       0x0010
#define MSK_AUTO      0x00f0

    TCHAR MyPath[MAX_PATH], *p;
    HINSTANCE g_Pc98ModuleHandle = NULL;
    PWIN95_PLUGIN_98PTN32_SETBOOTFLAG   SetBootFlag16;


    //
    // Obtain PC-98 helper routine addresses
    // Generate directory of WINNT32
    //
    if( !GetModuleFileName (NULL, MyPath, MAX_PATH) || (!(p =_tcsrchr(MyPath, TEXT('\\')))))
        return;
    *p= 0;
    ConcatenatePaths (MyPath, NEC98_DLL_NAME, MAX_PATH);

    //
    // Load library
    //
    g_Pc98ModuleHandle = LoadLibraryEx(
                            MyPath,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH
                            );

    if(!g_Pc98ModuleHandle){
        return;
    }

    //
    // Get entry points
    //

    (FARPROC)SetBootFlag16 = GetProcAddress (g_Pc98ModuleHandle, (const char *)WIN95_98PTN32_SETBOOTFLAG);
    if(!SetBootFlag16){
        FreeLibrary(g_Pc98ModuleHandle);
        return;
    }

    //
    // Set auto boot flag on System drive use 16 bit DLL.
    //

   SetBootFlag16(bBootDrvLtr, SB_BOOTABLE | SB_AUTO);
   FreeLibrary(g_Pc98ModuleHandle);
}

//
// Some NEC98 Windows NT4 system is installed DMITOOL
// This AP block the CreateFile API
// Setup need to check this AP
//
// Return
//      TRUE ... DMITOOL is installed
//      False .. DMITOOL is not installed

BOOL
NEC98CheckDMI()
{
    HKEY hKey;
    LONG Error;
    TCHAR buf[100];
    DWORD bufsize = sizeof(buf)/sizeof(TCHAR);

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SOFTWARE\\NEC\\PcAssistant\\Common"),
                      0, KEY_READ, &hKey) != ERROR_SUCCESS ) {
        return(FALSE);
    }
    if (RegQueryValueEx(hKey, TEXT("Ver"), NULL,
                        NULL, (unsigned char *)buf,
                        &bufsize ) != ERROR_SUCCESS ) {
        RegCloseKey( hKey );
        return(FALSE);
    }
    RegCloseKey( hKey );
    //
    // We need check major Version is '2.
    //
    if ((TCHAR)*buf != (TCHAR)'2')
        return(FALSE);
    return(TRUE);

}
#endif


typedef BOOL (WINAPI* INITBILLBOARD)(HWND , LPCTSTR, DWORD);
typedef BOOL (WINAPI* TERMBILLBOARD)();

void PrepareBillBoard(HWND hwnd)
{
    TCHAR szPath[MAX_PATH];
    INITBILLBOARD pinitbb;
    BOOL bMagnifierRunning = FALSE;

    // Check if Magnifier is running.
    HANDLE hEvent = CreateEvent(NULL, TRUE, TRUE, TEXT("MSMagnifierAlreadyExistsEvent"));
    bMagnifierRunning = (!hEvent || GetLastError() == ERROR_ALREADY_EXISTS);
    if (hEvent)
    {
        CloseHandle(hEvent);
    }
    // If the Magnifier is not set yet, set it.
    if (!AccessibleMagnifier)
    {
        AccessibleMagnifier = bMagnifierRunning;
    }

    // If running on Win9x and Magnifier is running, don't use the billboard.
    if (ISNT())
    {
        bMagnifierRunning = FALSE;
    }

    if (!bMagnifierRunning && FindPathToWinnt32File (
#ifndef UNICODE
            TEXT("winntbba.dll"),
#else
            TEXT("winntbbu.dll"),
#endif
            szPath,
            MAX_PATH
            )) {
        hinstBB = LoadLibrary (szPath);
        if (hinstBB)
        {

            pinitbb = (INITBILLBOARD)GetProcAddress(hinstBB, "InitBillBoard");
            if (pinitbb)
            {
                // Set no billboard text, just the background
                if (!(*pinitbb)(hwnd, TEXT(""), ProductFlavor))
                {
                    FreeLibrary(hinstBB);
                    hinstBB = NULL;
                }
            }
        }
    }
}


void TerminateBillBoard()
{
    TERMBILLBOARD pTermBillBoard;
    if (hinstBB)
    {
        if (pTermBillBoard = (TERMBILLBOARD)GetProcAddress(hinstBB, "TermBillBoard"))
            pTermBillBoard ();
    }
}

//
// This function is here so that when the wizard is hidden and the users
// task switches between other apps and setup, that we can handle the
// ESC key and forward it to the wizard dialog proc.
LRESULT
CALLBACK
MainBackgroundWndProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {

        case WM_CHAR:
            if (wParam == VK_ESCAPE)
            {
                // Forward this to the wizard dlg proc.
                SendMessage(WizardHandle, uMsg, wParam, lParam);
                return 0;
            }
            break;
    }
    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}

void CreateMainWindow()
{
    RECT rect;
    WNDCLASSEX wcx;
    TCHAR Caption[512];

    GetWindowRect (GetDesktopWindow(), &rect);

    ZeroMemory (&wcx, sizeof (wcx));
    wcx.cbSize = sizeof (wcx);
    wcx.style = CS_HREDRAW | CS_VREDRAW| CS_NOCLOSE;
    wcx.lpfnWndProc = MainBackgroundWndProc;
    wcx.hInstance = hInst;
    wcx.lpszClassName = TEXT("Winnt32Background");

    RegisterClassEx (&wcx);

    if (!LoadString (
            hInst,
            AppTitleStringId,
            Caption,
            sizeof(Caption)/sizeof(TCHAR)
            )) {
        Caption[0] = 0;
    }

    BackgroundWnd2 = CreateWindowEx (
                          WS_EX_APPWINDOW,
                          TEXT("Winnt32Background"),
                          Caption,
                          WS_CLIPCHILDREN|WS_POPUP|WS_VISIBLE,
                          rect.left,
                          rect.top,
                          rect.right,
                          rect.bottom,
                          NULL,
                          NULL,
                          hInst,
                          0
                          );

}


VOID
DisableSystemRestore( void )
/*
    Description:
        Procedure to disable system restore on upgrades. This way we save a lot of space
        as disabling system restore will clear out the old files under
        System Volume Information\_restore.{guid}".

*/
{

    HMODULE SRClient = NULL;


    if( Upgrade ){

        SRClient = LoadLibrary(TEXT("SRCLIENT.DLL"));

        if( !SRClient )
            return;
        else{

            if( ((FARPROC)SRClientDisableSR = GetProcAddress( SRClient, "DisableSR")) != NULL){

                //Call the routine

                SRClientDisableSR( NULL );

                DebugLog(Winnt32LogInformation, TEXT("System Restore was disabled"), 0);


            }
        }

        FreeLibrary( SRClient );
    }
    return;
}

#ifdef RUN_SYSPARSE
VOID
pCenterWindowOnDesktop (
    HWND WndToCenter
    )

/*++

Routine Description:

    Centers a dialog relative to the 'work area' of the desktop.

Arguments:

    WndToCenter - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame, rcWindow;
    LONG  x, y, w, h;
    POINT point;
    HWND Desktop = GetDesktopWindow ();

    point.x = point.y = 0;
    ClientToScreen(Desktop, &point);
    GetWindowRect(WndToCenter, &rcWindow);
    GetClientRect(Desktop, &rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    //
    // Get the work area for the current desktop (i.e., the area that
    // the tray doesn't occupy).
    //
    if(!SystemParametersInfo (SPI_GETWORKAREA, 0, (PVOID)&rcFrame, 0)) {
        //
        // For some reason SPI failed, so use the full screen.
        //
        rcFrame.top = rcFrame.left = 0;
        rcFrame.right = GetSystemMetrics(SM_CXSCREEN);
        rcFrame.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    if(x + w > rcFrame.right) {
        x = rcFrame.right - w;
    } else if(x < rcFrame.left) {
        x = rcFrame.left;
    }
    if(y + h > rcFrame.bottom) {
        y = rcFrame.bottom - h;
    } else if(y < rcFrame.top) {
        y = rcFrame.top;
    }

    MoveWindow(WndToCenter, x, y, w, h, FALSE);
}


LRESULT
SysParseDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static DWORD ElapsedTime = 0;
    static UINT_PTR timer = 0;
    DWORD ret;

    switch(msg) {
    case WM_INITDIALOG:
        pCenterWindowOnDesktop( hdlg);
        timer = SetTimer( hdlg, WMX_SYSPARSE_DONE, 1000, NULL);
        if ( !timer) {
            EndDialog(hdlg,TRUE);
        }
        return( TRUE );
    case WM_TIMER:
        ElapsedTime++;
        ret = WaitForSingleObject( piSysparse.hProcess, 0);
        if ( ret == WAIT_OBJECT_0) {
            KillTimer (hdlg, timer);
            EndDialog(hdlg,TRUE);
        } else if ( ElapsedTime >= 90) {
            KillTimer (hdlg, timer);
            TerminateProcess( piSysparse.hProcess, ERROR_TIMEOUT);
            EndDialog(hdlg,TRUE);
        }
        return( TRUE );
    default:
        break;
    }

    return( FALSE );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\winnt32.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <winioctl.h>
#include <setupbat.h>
#include <setupapi.h>
#include <winnls.h>
#include <shlwapi.h>
#include <winspool.h>
#include <wininet.h>

#include <tchar.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>

#include <winnt32p.h>
#include <pidgen.h>
#include <locale.h>
#include <ntverp.h>
#include <patchapi.h>
#include <cfgmgr32.h>
#include <regstr.h>


#include "resource.h"

#include "util.h"
#include "hwdb.h"
#include "wsdu.h"
#include "dynupdt.h"
#include "diamond.h"

//
// moved to precomp.h
//
//#include "msg.h"
#include "helpids.h"

#include "comp.h"
#include "compliance.h"

#include "mgdlllib.h"


#ifdef PRERELEASE
#define TRY
#define EXCEPT(e)   goto __skip;
#define _exception_code() 0
#define END_EXCEPT  __skip:;
#else
#define TRY         __try
#define EXCEPT(e)   __except (e)
#define END_EXCEPT
#endif

#define SIZEOFARRAY(a)      (sizeof (a) / sizeof (a[0]))

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)
#define UNATTENDED(btn)     if((UnattendedOperation) && (!CancelPending)) PostMessage(hdlg,WMX_UNATTENDED,btn,0)
#define CHECKUPGRADEONLY()  if(CheckUpgradeOnly) return( FALSE )
#define CHECKUPGRADEONLY_Q()  if(CheckUpgradeOnlyQ) return( FALSE )
#define SetDialogFocus(_hwnd, _hwndchild) SendMessage(_hwnd, WM_NEXTDLGCTL, (WPARAM)_hwndchild, MAKELPARAM(TRUE, 0))
#define MAKEULONGLONG(low,high) ((ULONGLONG)(((DWORD)(low)) | ((ULONGLONG)((DWORD)(high))) << 32))
#define HIULONG(_val_)      ((ULONG)(_val_>>32))
#define LOULONG(_val_)      ((ULONG)_val_)
#define TYPICAL()     (dwSetupFlags & UPG_FLAG_TYPICAL)


extern HINSTANCE hInst;
extern UINT AppTitleStringId;
extern DWORD TlsIndex;
extern HINSTANCE hinstBB;
extern HWND WizardHandle;
extern BOOL g_DeleteRunOnceFlag;
HWND GetBBhwnd();
HWND GetBBMainHwnd();


#define S_WINNT32_WARNING               TEXT("Winnt32RunOnceWarning")
// #define RUN_SYSPARSE 1

//
// Flag indicating whether we are initiating an MSI-Install.
//
extern BOOL RunFromMSI;
//
// Flag indicating whether we are initiating an Typical install
//
extern DWORD dwSetupFlags;
//
// Flag indicating whether we are initiating an upgrade.
//
extern BOOL Upgrade;

//
// Flag to say if we need to write the AcpiHAL value to the winnt.sif file
//
extern BOOL WriteAcpiHalValue;

//
// What should we write as the value for the AcpiHalValue
//
extern BOOL AcpiHalValue;

//
// Flag indicating whether we're installing/upgrading to NT Server
//
extern BOOL Server;

//
// Flag to indicate if we are running BVT's
//
extern BOOL RunningBVTs;

//
// When running BVT's, what baudrate should we set the debugger to?
//
extern LONG lDebugBaudRate;

//
// When running BVT's, what comport should we set the debugger to?
//
extern LONG lDebugComPort;

//
// When running BVT's, should we copy the symbols locally?
//
extern BOOL CopySymbols;

//
// Flag to indicate if we are running ASR tests
//
extern DWORD AsrQuickTest;

//
// Product type and flavor for upgrade modules
//
extern PRODUCTTYPE UpgradeProductType;
extern UINT ProductFlavor;

//
// fat to ntfs conversion flag
//
extern BOOL ForceNTFSConversion;
extern BOOL NTFSConversionChanged;

//
// 16 bit environment boot (Win9x upgrade only)
//
typedef enum {
    BOOT16_AUTOMATIC,
    BOOT16_YES,
    BOOT16_NO
} BOOT16_OPTIONS;
extern UINT g_Boot16;

//
// Global flag indicating whether the entire overall program operation
// was successful. Also a flag indicating whether to shut down automatically
// when the wizard is done in the non-unattended case.
//
extern BOOL GlobalResult;
extern BOOL AutomaticallyShutDown;

//
// Global OS version info.
//
extern OSVERSIONINFO OsVersion;
extern DWORD OsVersionNumber;
#define BUILDNUM()  (OsVersion.dwBuildNumber)
#ifdef UNICODE
#define ISNT()      (TRUE)
#define ISOSR2()    (FALSE)
#else
#define ISNT()      (FALSE)
#define ISOSR2()    (LOWORD(OsVersion.dwBuildNumber) > 1080)
#endif

extern WINNT32_PLUGIN_INIT_INFORMATION_BLOCK info;

//
// Flags indicating how we were run and whether to create
// a local source.
//
extern BOOL RunFromCD;
extern BOOL MakeLocalSource;
extern BOOL UserSpecifiedMakeLocalSource;
extern BOOL NoLs;
extern TCHAR UserSpecifiedLocalSourceDrive;
extern LONG SourceInstallType; // uses InstallType enum
extern DWORD MLSDiskID;

//
// Used for win9xupg reporting (reportonly mode)
//
extern UINT UpgRequiredMb;
extern UINT UpgAvailableMb;

//
// advanced install options
//
extern BOOL ChoosePartition;
extern BOOL UseSignatures;
extern TCHAR InstallDir[MAX_PATH];
extern TCHAR HeadlessSelection[MAX_PATH];
extern ULONG HeadlessBaudRate;
#ifdef PRERELEASE
extern BOOL AppendDebugDataToBoot;
#endif

//
// SMS support
//
extern PSTR LastMessage;

#if defined(REMOTE_BOOT)
//
// Flag indicating whether we're running on a remote boot client.
//
extern BOOL RemoteBoot;

//
// Path to the machine directory for a remote boot client.
//
extern TCHAR MachineDirectory[MAX_PATH];
#endif // defined(REMOTE_BOOT)

//
// Flags indicating which Accessibility utilities to use
//
extern BOOL AccessibleMagnifier;
extern BOOL AccessibleKeyboard;
extern BOOL AccessibleVoice;
extern BOOL AccessibleReader;

//
// Build number we're upgrading from
//
extern DWORD BuildNumber;
#define     NT351   1057
#define     NT40    1381
#define     NT50B1  1671
#define     NT50B3  2031
#define     NT50    2195
#define     NT51B2  2462

//
// Are any of the Accesssibility utilities enabled?
//
extern BOOL AccessibleSetup;

//
// Flags and values relating to unattended operation.
//
extern BOOL UnattendedOperation;
extern BOOL UnattendSwitchSpecified;
extern PTSTR UnattendedScriptFile;
extern UINT UnattendedShutdownTimeout;
extern UINT UnattendedCountdown;
extern BOOL BatchMode;

//
// Name of unattended script file to be used for Accessible Setup
//
extern TCHAR AccessibleScriptFile[MAX_PATH];

//
// Name of inf file and handles to dosnet.inf and txtsetup.sif.
//
extern TCHAR InfName[MAX_PATH];
extern PVOID MainInf;
extern TCHAR FullInfName[MAX_PATH];
extern PVOID TxtsetupSif;
extern PVOID NtcompatInf;

BOOL
GetMainInfValue (
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      DWORD FieldNumber,
    OUT     PTSTR Buffer,
    IN      DWORD BufChars
    );

//
// Language options stuff
//
extern BOOL    IntlInfProcessed;
extern DWORD   PrimaryLocale;

// Global used in WriteParamsFile and AddExternalParams
extern TCHAR ActualParamFile[MAX_PATH];

BOOL InitLangControl(HWND hdlg, BOOL bFarEast);
BOOL IsFarEastLanguage(DWORD LangIdx);
BOOL SelectFarEastLangGroup(BOOL bSelect);

void BB_SetProgressText(LPTSTR szText);
void BB_SetTimeEstimateText(LPTSTR szText);
void BB_SetInfoText(LPTSTR szText);

extern
BOOL
ReadIntlInf(
    IN HWND   hdlg
    );

extern
VOID
SaveLanguageDirs(
    );

extern
BOOL
SaveLanguageParams(
    IN LPCTSTR FileName
    );

extern
VOID
FreeLanguageData(
    );

VOID
CleanUpOldLocalSources(
    IN HWND hdlg
    );

BOOL
InspectFilesystems(
    IN HWND hdlg
    );

BOOL
LoadInfWorker(
    IN  HWND     hdlg,
    IN  LPCTSTR  FilenamePart,
    OUT PVOID   *InfHandle,
    IN  BOOL     Winnt32File
    );

BOOL
FindLocalSourceAndCheckSpace(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    );

BOOL
EnoughMemory(
    IN HWND hdlg,
    IN BOOL QuickTest
    );

//
// Optional directory stuff.
//
#define MAX_OPTIONALDIRS    20
extern UINT OptionalDirectoryCount;
extern TCHAR OptionalDirectories[MAX_OPTIONALDIRS][MAX_PATH];
extern UINT OptionalDirectoryFlags[MAX_OPTIONALDIRS];

#define OPTDIR_TEMPONLY                 0x00000001
#define OPTDIR_OEMSYS                   0x00000002
#define OPTDIR_OVERLAY                  0x00000004
#define OPTDIR_ADDSRCARCH               0x00000008
#define OPTDIR_ABSOLUTE                 0x00000010
#define OPTDIR_DEBUGGEREXT              0x00000020  // speficies that this optional dir is to be copied to %windir%\system32\pri (for debugger extensions)
// OPTDIR_PLATFORM_INDEP becomes DIR_IS_PLATFORM_INDEPEND and FILE_IN_PLATFORM_INDEPEND_DIR
#define OPTDIR_PLATFORM_INDEP           0x00000040
#define OPTDIR_IN_LOCAL_BOOT            0x00000080
#define OPTDIR_SUPPORT_DYNAMIC_UPDATE   0x00000100
#define OPTDIR_USE_TAIL_FOLDER_NAME     0x00000200
#define OPTDIR_PLATFORM_SPECIFIC_FIRST  0x00000400
#define OPTDIR_DOESNT_SUPPORT_PRIVATES  0x00000800
#define OPTDIR_SIDE_BY_SIDE             0x00001000

//
// Source paths and count of paths.
//
extern TCHAR SourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
extern TCHAR NativeSourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
extern UINT SourceCount;
extern TCHAR *UserSpecifiedOEMShare;
//
// Local source information.
//
#define DEFAULT_INSTALL_DIR     TEXT("\\WINDOWS")
#define INTERNAL_WINNT32_DIR    TEXT("winnt32")

#define LOCAL_SOURCE_DIR_A      "$WIN_NT$.~LS"
#define LOCAL_SOURCE_DIR_W      L"$WIN_NT$.~LS"
#define TEXTMODE_INF_A          "TXTSETUP.SIF"
#define TEXTMODE_INF_W          L"TXTSETUP.SIF"
#define NTCOMPAT_INF_A          "COMPDATA\\NTCOMPAT.INF"
#define NTCOMPAT_INF_W          L"COMPDATA\\NTCOMPAT.INF"
#define DRVINDEX_INF_A          "DRVINDEX.INF"
#define DRVINDEX_INF_W          L"DRVINDEX.INF"
#define SETUPP_INI_A            "SETUPP.INI"
#define SETUPP_INI_W            L"SETUPP.INI"
#define PID_SECTION_A           "Pid"
#define PID_SECTION_W           L"Pid"
#define PID_KEY_A               "Pid"
#define PID_KEY_W               L"Pid"
#define OEM_INSTALL_RPC_A       "OEM"
#define OEM_INSTALL_RPC_W       L"OEM"
#define SELECT_INSTALL_RPC_A    "270"
#define SELECT_INSTALL_RPC_W    L"270"
#define MSDN_INSTALL_RPC_A      "335"
#define MSDN_INSTALL_RPC_W      L"335"
#define MSDN_PID30_A            "MD97J-QC7R7-TQJGD-3V2WM-W7PVM"
#define MSDN_PID30_W            L"MD97J-QC7R7-TQJGD-3V2WM-W7PVM"

#define INF_FILE_HEADER         "[Version]\r\nSignature = \"$Windows NT$\"\r\n\r\n"


#ifdef UNICODE
#define LOCAL_SOURCE_DIR        LOCAL_SOURCE_DIR_W
#define TEXTMODE_INF            TEXTMODE_INF_W
#define NTCOMPAT_INF            NTCOMPAT_INF_W
#define DRVINDEX_INF            DRVINDEX_INF_W
#define SETUPP_INI              SETUPP_INI_W
#define PID_SECTION             PID_SECTION_W
#define PID_KEY                 PID_KEY_W
#define OEM_INSTALL_RPC         OEM_INSTALL_RPC_W
#define SELECT_INSTALL_RPC      SELECT_INSTALL_RPC_W
#define MSDN_INSTALL_RPC        MSDN_INSTALL_RPC_W
#define MSDN_PID30              MSDN_PID30_W
#else
#define LOCAL_SOURCE_DIR        LOCAL_SOURCE_DIR_A
#define TEXTMODE_INF            TEXTMODE_INF_A
#define NTCOMPAT_INF            NTCOMPAT_INF_A
#define DRVINDEX_INF            DRVINDEX_INF_A
#define SETUPP_INI              SETUPP_INI_A
#define PID_SECTION             PID_SECTION_A
#define PID_KEY                 PID_KEY_A
#define OEM_INSTALL_RPC         OEM_INSTALL_RPC_A
#define SELECT_INSTALL_RPC      SELECT_INSTALL_RPC_A
#define MSDN_INSTALL_RPC        MSDN_INSTALL_RPC_A
#define MSDN_PID30              MSDN_PID30_A
#endif

#ifdef _X86_
#define LOCAL_BOOT_DIR_A        "$WIN_NT$.~BT"
#define LOCAL_BOOT_DIR_W        L"$WIN_NT$.~BT"
#define AUX_BS_NAME_A           "$LDR$"
#define AUX_BS_NAME_W           L"$LDR$"
#define FLOPPY_COUNT            4
//
// Local BACKUP information, on NEC98.
//
#define LOCAL_BACKUP_DIR_A      "$WIN_NT$.~BU"
#define LOCAL_BACKUP_DIR_W      L"$WIN_NT$.~BU"
#ifdef UNICODE
#define LOCAL_BOOT_DIR          LOCAL_BOOT_DIR_W
#define AUX_BS_NAME             AUX_BS_NAME_W
#define LOCAL_BACKUP_DIR        LOCAL_BACKUP_DIR_W
#else
#define LOCAL_BOOT_DIR          LOCAL_BOOT_DIR_A
#define AUX_BS_NAME             AUX_BS_NAME_A
#define LOCAL_BACKUP_DIR        LOCAL_BACKUP_DIR_A
#endif
extern TCHAR LocalBackupDirectory[MAX_PATH];
extern TCHAR FirstFloppyDriveLetter;
#endif

extern DWORD LocalSourceDriveOffset;

extern TCHAR LocalSourceDrive;
extern TCHAR LocalSourceDirectory[MAX_PATH];
extern TCHAR LocalSourceWithPlatform[MAX_PATH];
extern TCHAR LocalBootDirectory[MAX_PATH];
extern BOOL  BlockOnNotEnoughSpace;
extern LONGLONG LocalSourceSpaceRequired;
extern LONGLONG WinDirSpaceFor9x;
extern BOOL UpginfsUpdated;
extern BOOL Win95upgInfUpdated;

//
// wizard stuff
//

// wizard page size
#define WIZ_PAGE_SIZE_X 317
#define WIZ_PAGE_SIZE_Y 179

#define BBSTEP_NONE                         0
#define BBSTEP_COLLECTING_INFORMATION       1
#define BBSTEP_DYNAMIC_UPDATE               2
#define BBSTEP_PREPARING                    3

typedef struct _PAGE_COMMON_DATA {

    DLGPROC DialogProcedure;

    UINT BillboardStep;

    //
    // State to initialize buttons to.
    //
    DWORD Buttons;

    UINT Flags;

} PAGE_COMMON_DATA, *PPAGE_COMMON_DATA;


typedef struct _PAGE_CREATE_DATA {
    //
    // If these are specified, then a range of pages may come
    // from somewhere else. Otherwise, it's one page whose
    // resource id is given below.
    //
    LPPROPSHEETPAGE *ExternalPages;
    PUINT ExternalPageCount;

    UINT Template;

    PAGE_COMMON_DATA CommonData;

} PAGE_CREATE_DATA, *PPAGE_CREATE_DATA;


typedef struct _PAGE_RUNTIME_DATA {

    PAGE_COMMON_DATA CommonData;

    //
    // Per-page (private) data
    //
    DWORD PerPageData;

} PAGE_RUNTIME_DATA, *PPAGE_RUNTIME_DATA;


typedef struct _BITMAP_DATA {
    CONST BITMAPINFOHEADER *BitmapInfoHeader;
    PVOID                   BitmapBits;
    HPALETTE                Palette;
    UINT                    PaletteColorCount;
    BOOL                    Adjusted;
} BITMAP_DATA, *PBITMAP_DATA;


#define WIZPAGE_FULL_PAGE_WATERMARK 0x00000001
#define WIZPAGE_SEPARATOR_CREATED   0x00000002
#define WIZPAGE_NEW_HEADER          0x00000004


//
// compatibility data
//

typedef struct _COMPATIBILITY_DATA {
    //
    // general
    //
    LIST_ENTRY ListEntry;
    //
    // what type of entry
    //
    TCHAR    Type;
    //
    // service-driver data
    //
    LPCTSTR  ServiceName;
    //
    // registry data
    //
    LPCTSTR  RegKey;
    LPCTSTR  RegValue;
    LPCTSTR  RegValueExpect;
    //
    // file data
    //
    LPCTSTR  FileName;
    LPCTSTR  FileVer;
    //
    // common
    //
    LPCTSTR  Description;
    LPCTSTR  HtmlName;
    LPCTSTR  TextName;
    LPTSTR   RegKeyName;
    LPTSTR   RegValName;
    LPVOID   RegValData;
    DWORD    RegValDataSize;
    LPVOID   SaveValue;
    DWORD    Flags;
    LPCTSTR  InfName;
    LPCTSTR  InfSection;

    HMODULE                 hModDll;
    PCOMPAIBILITYHAVEDISK   CompHaveDisk;

} COMPATIBILITY_DATA, *PCOMPATIBILITY_DATA;

extern LIST_ENTRY CompatibilityData;
extern DWORD CompatibilityCount;
extern DWORD IncompatibilityStopsInstallation;
extern BOOL AnyNt5CompatDlls;

BOOL
AnyBlockingCompatibilityItems (
    VOID
    );

//
// Plug and Play device migration routines.
// (linked into winnt.dll from pnpsif.lib)
//
BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    );

//
// Array of drive letters for all system partitions.
// Note that on x86 there will always be exactly one.
// The list is 0-terminated.
//
extern TCHAR SystemPartitionDriveLetters[27];
extern TCHAR SystemPartitionDriveLetter;

#ifdef UNICODE
extern UINT SystemPartitionCount;
extern PWSTR* SystemPartitionNtNames;
extern PWSTR SystemPartitionNtName;
extern PWSTR SystemPartitionVolumeGuid;
#else
extern PCSTR g_LocalSourcePath;
#endif

//
// UDF stuff
//
extern LPCTSTR UniquenessId;
extern LPCTSTR UniquenessDatabaseFile;

//
// Preinstall stuff
//
extern BOOL OemPreinstall;

#ifdef _X86_
typedef struct _OEM_BOOT_FILE {
    struct _OEM_BOOT_FILE *Next;
    LPCTSTR Filename;
} OEM_BOOT_FILE, *POEM_BOOT_FILE;

extern POEM_BOOT_FILE OemBootFiles;
#endif

extern TCHAR ForcedSystemPartition;

//
// Miscellaneous other command line parameters.
//
extern LPCTSTR CmdToExecuteAtEndOfGui;
extern BOOL AutoSkipMissingFiles;
extern BOOL HideWinDir;
extern TCHAR ProductId[64];

//
// Flag indicating that the user cancelled.
// Flag indicating that a succssessful abort should be performed.
// Handle for mutex used to guarantee that only one error dialog
// is on the screen at once.
//
extern BOOL Cancelled;
extern BOOL CancelPending;
extern BOOL Aborted;
extern HANDLE UiMutex;

//
// This indicates that well give the user some detailed data-throughput
// info.
//
extern BOOL DetailedCopyProgress;
extern ULONGLONG TotalDataCopied;

//
// Upgrade Options variables. Used to pass a multistring of
// upgrade command line options to the plugin DLLs.
//
extern LPTSTR UpgradeOptions;
extern DWORD  UpgradeOptionsLength;
extern DWORD  UpgradeOptionsSize;

BOOL
AppendUpgradeOption (
    IN      PCTSTR String
    );

#ifdef _X86_
//
// Win9x upgrade report status
//

extern UINT g_UpgradeReportMode;
#endif

//
// Compliance variables
//
extern BOOL   NoCompliance;
extern BOOL   NoBuildCheck;

// UpgradeOnly is true is the media is CCP media and only valid
// to upgrade a system.  eula.c will use this to ensure that an
// FPP pid is not used with CCP media and vice-versa
extern BOOL   UpgradeOnly;

extern BOOL   SkipLocaleCheck;
extern BOOL   SkipVirusScannerCheck;

extern BOOL   UseBIOSToBoot;

//
// TargetNativeLangID : this is native language ID of running system
//
extern LANGID TargetNativeLangID;

//
// SourceNativeLangID : this is native language ID of new NT you want to install
//
extern LANGID SourceNativeLangID;

//
// IsLanguageMatched : if source and target language are matched (or compatible)
//
//                     1. if SourceNativeLangID == TargetNativeLangID
//
//                     2. if SourceNativeLangID's alternative ID == TargetNativeLangID
//
extern BOOL IsLanguageMatched;

BOOL
InitLanguageDetection(
    LPCTSTR SourcePath,
    LPCTSTR InfFile
    );



//
// Routines from Setupapi.dll
//
extern
BOOL
(*SetupapiCabinetRoutine)(
    IN LPCTSTR CabinetFile,
    IN DWORD Flags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID Context
    );

extern
DWORD
(*SetupapiDecompressOrCopyFile)(
    IN  PCTSTR  SourceFileName,
    OUT PCTSTR  TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    );

extern
HINF
(*SetupapiOpenInfFile)(
    IN  LPCTSTR FileName,
    IN  LPCTSTR InfClass,    OPTIONAL
    IN  DWORD   InfStyle,
    OUT PUINT   ErrorLine    OPTIONAL
    );

extern
VOID
(*SetupapiCloseInfFile)(
    IN HINF InfHandle
    );

extern
BOOL
(*SetupapiFindFirstLine)(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  PCTSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

extern
BOOL
(*SetupapiFindNextLine)(
    PINFCONTEXT ContextIn,
    PINFCONTEXT ContextOut
    );

extern
BOOL
(*SetupapiFindNextMatchLine)(
    PINFCONTEXT ContextIn,
    PCTSTR Key,
    PINFCONTEXT ContextOut
    );

extern
LONG
(*SetupapiGetLineCount)(
    IN HINF   InfHandle,
    IN LPCTSTR Section
    );

extern
DWORD
(*SetupapiGetFieldCount)(
    IN  PINFCONTEXT Context
    );

extern
BOOL
(*SetupapiGetStringField)(
    IN  PINFCONTEXT Context,
    DWORD FieldIndex,
    PTSTR ReturnBuffer,
    DWORD ReturnBufferSize,
    PDWORD RequiredSize
    );

extern
BOOL
(*SetupapiGetLineByIndex)(
    IN  HINF        InfHandle,
    IN  LPCTSTR     Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

extern
HSPFILEQ
(*SetupapiOpenFileQueue) (
    VOID
    );

extern
BOOL
(*SetupapiCloseFileQueue) (
    IN HSPFILEQ QueueHandle
    );

extern
BOOL
(*SetupapiQueueCopy) (
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN PCTSTR   SourcePath,         OPTIONAL
    IN PCTSTR   SourceFilename,
    IN PCTSTR   SourceDescription,  OPTIONAL
    IN PCTSTR   SourceTagfile,      OPTIONAL
    IN PCTSTR   TargetDirectory,
    IN PCTSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

extern
BOOL
(*SetupapiCommitFileQueue) (
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    );

extern
UINT
(*SetupapiDefaultQueueCallback) (
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

extern
PVOID
(*SetupapiInitDefaultQueueCallback) (
    HWND OwnerWindow
);

extern
VOID
(*SetupapiTermDefaultQueueCallback) (
    PVOID Context
);

extern
BOOL
(*SetupapiGetSourceFileLocation) (
    HINF InfHandle,          // handle of an INF file
    PINFCONTEXT InfContext,  // optional, context of an INF file
    PCTSTR FileName,         // optional, source file to locate
    PUINT SourceId,          // receives the source media ID
    PTSTR ReturnBuffer,      // optional, receives the location
    DWORD ReturnBufferSize,  // size of the supplied buffer
    PDWORD RequiredSize      // optional, buffer size needed
);

//
// Custom window messages. Define so they don't overlap with
// any being used by plug-in dll's.
//
#define WMX_EDITCONTROLSTATE    (WMX_PLUGIN_FIRST-1)
#define WMX_INSPECTRESULT       (WMX_PLUGIN_FIRST-2)
//#define WMX_SETPROGRESSTEXT     (WMX_PLUGIN_FIRST-3)
#define WMX_ERRORMESSAGEUP      (WMX_PLUGIN_FIRST-4)
#define WMX_I_AM_VISIBLE        (WMX_PLUGIN_FIRST-5)
#define WMX_COPYPROGRESS        (WMX_PLUGIN_FIRST-6)
#define WMX_I_AM_DONE           (WMX_PLUGIN_FIRST-7)
#define WMX_FINISHBUTTON        (WMX_PLUGIN_FIRST-8)
#define WMX_UNATTENDED          (WMX_PLUGIN_FIRST-9)
#define WMX_NEXTBUTTON          (WMX_PLUGIN_FIRST-10)
#define WMX_BACKBUTTON          (WMX_PLUGIN_FIRST-11)
#define WMX_VALIDATE            (WMX_PLUGIN_FIRST-12)
#define WMX_SETUPUPDATE_PREPARING       (WMX_PLUGIN_FIRST-13)
#define WMX_SETUPUPDATE_DOWNLOADING     (WMX_PLUGIN_FIRST-14)
#define WMX_SETUPUPDATE_PROCESSING      (WMX_PLUGIN_FIRST-15)
#define WMX_SETUPUPDATE_DONE            (WMX_PLUGIN_FIRST-16)
#define WMX_SETUPUPDATE_CANCEL          (WMX_PLUGIN_FIRST-17)
#define WMX_SETUPUPDATE_INIT_RETRY      (WMX_PLUGIN_FIRST-18)
#define WMX_SETUPUPDATE_THREAD_DONE     (WMX_PLUGIN_FIRST-19)
#ifdef RUN_SYSPARSE
#define WMX_SYSPARSE_DONE               (WMX_PLUGIN_FIRST-20)
#endif    
#define WMX_DYNAMIC_UPDATE_COMPLETE     (WMX_PLUGIN_FIRST-21)


//
// Helper macro for uppercasing
//
#define TOUPPER(x)  (TCHAR)CharUpper((LPTSTR)x)



//
// Routine that does everything by starting the wizard.
//
VOID
Wizard(
    VOID
    );


//
// Routine that builds a cmdcons installation.
//
VOID
DoBuildCmdcons(
    VOID
    );


VOID
FixUpWizardTitle(
    IN HWND Wizard
    );

//
// Cleanup routine and globals used by the cleanup stuff.
//
DWORD
StartCleanup(
    IN PVOID ThreadParameter
    );

#ifdef _X86_

BOOL
RestoreBootSector(
    VOID
    );

BOOL
RestoreBootIni(
    VOID
    );

BOOL
SaveRestoreBootFiles_NEC98(
    IN UCHAR Flag
    );
#define NEC98SAVEBOOTFILES      0
#define NEC98RESTOREBOOTFILES   1

BOOL
IsDriveAssignNEC98(
    VOID
    );

//
// Check ATA Drive
//

BOOLEAN
CheckATACardonNT4(
    HANDLE hDisk
    );


//
// Check formatted drive type
//
BOOLEAN
IsValidDrive(
    TCHAR Drive
    );

#endif //_X86_

BOOL
RestoreNvRam(
    VOID
    );


//
// Thread that inspects sources, loads infs, builds the copy list,
// checks disk space, etc. And some worker routines.
//

DWORD
InspectAndLoadThread(
    IN PVOID ThreadParam
    );

BOOL
InspectSources(
    IN HWND ParentWnd
    );


BOOL
BuildCopyListWorker(
    IN HWND hdlg
    );

BOOL
FindLocalSourceAndCheckSpaceWorker(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    );

UINT
GetTotalFileCount(
    VOID
    );

DWORD
StartCopyingThread(
    IN PVOID ThreadParameter
    );

VOID
CancelledMakeSureCopyThreadsAreDead(
    VOID
    );

DWORD
DoPostCopyingStuff(
    IN PVOID ThreadParam
    );

//
// File copy error routine and outcomes.
//
UINT
FileCopyError(
    IN HWND    ParentWindow,
    IN LPCTSTR SourceFilename,
    IN LPCTSTR TargetFilename,
    IN UINT    Win32Error,
    IN BOOL    MasterList
    );

#define COPYERR_SKIP    1
#define COPYERR_EXIT    2
#define COPYERR_RETRY   3


//
// Routine to add an optional directory to the list of dirs
// we copy.
//
BOOL
RememberOptionalDir(
    IN LPCTSTR Directory,
    IN UINT    Flags
    );

//
// Resource utility routines.
//

PCTSTR
GetStringResource (
    IN UINT Id              // ID or pointer to string name
    );

VOID
FreeStringResource (
    IN PCTSTR String
    );

VOID
SaveMessageForSMS(
    IN DWORD MessageId,
    ...
    );

VOID
SaveTextForSMS(
    IN PCTSTR Buffer
    );

int
MessageBoxFromMessage(
    IN HWND  Window,
    IN DWORD MessageId,
    IN BOOL  SystemMessage,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    );

int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN va_list *Args
    );

int
MessageBoxFromMessageWithSystem(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN HMODULE  hMod
    );

int
MessageBoxFromMessageAndSystemError(
    IN HWND  Window,
    IN DWORD MessageId,
    IN DWORD SystemMessageId,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    );

HBITMAP
LoadResourceBitmap(
    IN  HINSTANCE hInst,
    IN  LPCTSTR   Id,
    OUT HPALETTE *Palette
    );

BOOL
GetBitmapDataAndPalette(
    IN  HINSTANCE                hInst,
    IN  LPCTSTR                  Id,
    OUT HPALETTE                *Palette,
    OUT PUINT                    ColorCount,
    OUT CONST BITMAPINFOHEADER **BitmapData
    );

UINT
GetYPositionOfDialogItem(
    IN LPCTSTR Dialog,
    IN UINT    ControlId
    );

//
// Security routines.
//
BOOL
IsUserAdmin(
    VOID
    );

BOOL
DoesUserHavePrivilege(
    PTSTR PrivilegeName
    );

BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    );

//
// Inf routines.
//
DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle
   );

VOID
UnloadInfFile(
   IN PVOID InfHandle
   );

LONG
InfGetSectionLineCount(
   IN PVOID INFHandle,
   IN PTSTR SectionName
   );

LPCTSTR
InfGetFieldByIndex(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   );

LPCTSTR
InfGetFieldByKey(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN LPCTSTR  Key,
   IN unsigned ValueIndex
   );

BOOL
InfDoesLineExistInSection(
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Key
   );

BOOL
InfDoesEntryExistInSection (
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Entry
   );

LPCTSTR
InfGetLineKeyName(
    IN PVOID    INFHandle,
    IN LPCTSTR  SectionName,
    IN unsigned LineIndex
    );


typedef struct {
    // Caller members (read-only)
    PCTSTR FieldZeroData;
    unsigned LineIndex;

    // Internal members
    PVOID InfHandle;
    PCTSTR SectionName;
} INF_ENUM, *PINF_ENUM;

BOOL
EnumFirstInfLine (
    OUT     PINF_ENUM InfEnum,
    IN      PVOID InfHandle,
    IN      PCTSTR InfSection
    );

BOOL
EnumNextInfLine (
    IN OUT  PINF_ENUM InfEnum
    );

VOID
AbortInfLineEnum (
    IN      PINF_ENUM InfEnum           // ZEROED
    );

//
// Routines to manipulate parameters files like unattend.txt,
// the param file we pass to text mode setup, etc.
//
BOOL
WriteParametersFile(
    IN HWND ParentWindow
    );

BOOL
AddExternalParams(
    IN HWND ParentWindow
    );

//
// Miscellaenous utility routines.
//
LPTSTR *
CommandLineToArgv(
    OUT int *NumArgs
    );

VOID
MyWinHelp(
    IN HWND  Window,
    IN UINT  Command,
    IN ULONG_PTR Data
    );

VOID
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

LPTSTR
DupString(
    IN LPCTSTR String
    );

UINT
MyGetDriveType(
    IN TCHAR Drive
    );

#ifdef UNICODE
UINT
MyGetDriveType2 (
    IN      PCWSTR NtDeviceName
    );

BOOL
MyGetDiskFreeSpace (
    IN      PCWSTR NtVolumeName,
    IN      PDWORD SectorsPerCluster,
    IN      PDWORD BytesPerSector,
    IN      PDWORD NumberOfFreeClusters,
    IN      PDWORD TotalNumberOfClusters
    );

#endif

BOOL
GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    );

BOOL
IsDriveNTFT(
    IN TCHAR Drive,
    IN      PCTSTR NtVolumeName
    );

BOOL
IsDriveVeritas(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    );

#ifdef UNICODE

BOOL
IsSoftPartition(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    );
#else

#define IsSoftPartition(d,n)    (FALSE)

#endif

BOOL
IsDriveNTFS(
    IN TCHAR Drive
    );

BOOL
IsMachineSupported(
    OUT PCOMPATIBILITY_ENTRY CompEntry
    );

BOOL
GetAndSaveNTFTInfo(
    IN HWND ParentWindow
    );

VOID
ForceStickyDriveLetters(
    );

DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    );

VOID
GenerateCompressedName(
    IN  LPCTSTR Filename,
    OUT LPTSTR  CompressedName
    );

DWORD
CreateMultiLevelDirectory(
    IN LPCTSTR Directory
    );

VOID
MyDelnode(
    IN LPCTSTR Directory
    );

BOOL
ForceFileNoCompress(
    IN LPCTSTR Filename
    );

BOOL
IsCurrentOsServer(
    void
    );

BOOL
IsCurrentAdvancedServer(
    void
    );

BOOL
IsNTFSConversionRecommended(
    void
    );


BOOL
ForceBootFilesUncompressed(
    IN HWND ParentWindow,
    IN BOOL TellUserAboutError
    );

BOOLEAN
AdjustPrivilege(
    PWSTR   Privilege
    );

BOOL
GetUserPrintableFileSizeString(
    IN DWORDLONG Size,
    OUT LPTSTR Buffer,
    IN DWORD BufferSize
    );

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
DoesDirectoryExist (
    IN      PCTSTR DirSpec
    );

BOOL
InDriverCacheInf(
    IN      PVOID InfHandle,
    IN      PCTSTR FileName,
    OUT     PTSTR DriverCabName,        OPTIONAL
    IN      DWORD BufferChars           OPTIONAL
    );

BOOL
BuildSystemPartitionPathToFile (
    IN      PCTSTR FileName,
    OUT     PTSTR Path,
    IN      DWORD BufferSizeChars
    );

BOOL
FindPathToInstallationFileEx (
    IN      PCTSTR FileName,
    OUT     PTSTR PathToFile,
    IN      DWORD PathToFileBufferSize,
    OUT     PBOOL Compressed                OPTIONAL
    );

#define FindPathToInstallationFile(n,p,s)   FindPathToInstallationFileEx(n,p,s,NULL)


BOOL
FindPathToWinnt32File (
    IN      PCTSTR FileRelativePath,
    OUT     PTSTR PathToFile,
    IN      DWORD PathToFileBufferSize
    );

BOOL
GetFileVersion (
    IN      PCTSTR FilePath,
    OUT     PTSTR FileVersion
    );


//
// #define to use MyPrivateProfileString to get around virus checkers monitoring operations to C
// drive that cause us to fail WritePrivateProfileString
// The problem is that usually these s/w examine the files we touch and in somecases open it
// with exclusive access. We just need to wait for them to be done.
//


BOOL
MyWritePrivateProfileString(
    LPCTSTR lpAppName,  // pointer to section name
    LPCTSTR lpKeyName,  // pointer to key name
    LPCTSTR lpString,   // pointer to string to add
    LPCTSTR lpFileName  // pointer to initialization filename
    );


#ifdef UNICODE
    #define WritePrivateProfileStringW(w,x,y,z) MyWritePrivateProfileString(w,x,y,z)
#else
    #define WritePrivateProfileStringA(w,x,y,z) MyWritePrivateProfileString(w,x,y,z)
#endif

//
// Routines having to do with advanced program options
//
VOID
InitVariousOptions(
    VOID
    );

VOID
DoOptions(
    IN HWND Parent
    );

VOID
DoLanguage(
    IN HWND Parent
    );

VOID
DoAccessibility(
    IN HWND Parent
    );

BOOL
BrowseForDosnetInf(
    IN  HWND    hdlg,
    IN  LPCTSTR InitialPath,
    OUT TCHAR   NewPath[MAX_PATH]
    );

BOOL
IsValid8Dot3(
    IN LPCTSTR Path
    );

//
// Routines having to do with eula and pid
//

#define MAX_PID30_EDIT                       5
extern LPTSTR g_EncryptedPID;
extern BOOL g_bDeferPIDValidation;

extern BOOL EulaComplete;

typedef enum InstallType
{
   SelectInstall,
   OEMInstall,
   RetailInstall
};

VOID
GetSourceInstallType(
    OUT OPTIONAL PDWORD InstallVariation
    );

BOOL
SetPid30(
    HWND hdlg,
    LONG ExpectedPidType,
    LPTSTR pProductId
    );

#ifdef UNICODE
PCHAR
FindRealHalName(
    TCHAR *pHalFileName
    );
#endif

//
// Debugging and logging
//
typedef enum {
    Winnt32LogSevereError,
    Winnt32LogError,
    Winnt32LogWarning,
    Winnt32LogInformation,
    Winnt32LogDetailedInformation,
    Winnt32LogMax
#define WINNT32_HARDWARE_LOG 0x40000000
} Winnt32DebugLevel;

extern Winnt32DebugLevel DebugLevel;

BOOL
StartDebugLog(
    IN LPCTSTR           DebugFileLog,
    IN Winnt32DebugLevel Level
    );

VOID
CloseDebugLog(
    VOID
    );

BOOL
DebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    ...
    );

BOOL
DebugLog2(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    IN va_list           ArgList
    );

BOOL
DynUpdtDebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,
    IN UINT              MessageId,
    ...
    );

BOOL
ConcatenateFile(
    IN HANDLE   hOpenFile,
    IN  LPTSTR  FileName
    );

VOID
GatherOtherLogFiles(
    VOID
    );

//
// Memory allocation.
//
#define MALLOC(s)       malloc(s)
#define FREE(b)         free(b)
#define REALLOC(b,s)    realloc((b),(s))


//
// Floppy-related stuff.
//
extern BOOL MakeBootMedia;
extern BOOL Floppyless;

//
// boot loader timeout value, in string form
//
extern TCHAR Timeout[32];

#ifdef _X86_
UINT
FloppyGetTotalFileCount(
    VOID
    );

DWORD
FloppyWorkerThread(
    IN PVOID ThreadParameter
    );

//
// Routine to lay NT boot code, munge boot.ini, create aux boot sector, etc.
//
BOOL
DoX86BootStuff(
    IN HWND ParentWindow
    );

BOOL
PatchTextIntoBootCode(
    VOID
    );


VOID
MigrateBootIniData();

//
// Drive information abstraction
//
typedef struct _WINNT32_DRIVE_INFORMATION {
    DWORD       CylinderCount;
    DWORD       HeadCount;
    DWORD       SectorsPerTrack;
    ULONGLONG   SectorCount;
    WORD        BytesPerSector;
} WINNT32_DRIVE_INFORMATION, *PWINNT32_DRIVE_INFORMATION;

//
// Routine to get drive form-factor/type.
//
MEDIA_TYPE
GetMediaType(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo OPTIONAL
    );

//
// Disk sector I/O routines
//
BOOL
ReadDiskSectors(
    IN  TCHAR  Drive,
    IN  UINT   StartSector,
    IN  UINT   SectorCount,
    IN  UINT   SectorSize,
    OUT LPBYTE Buffer
    );

BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    );

BOOL
MarkPartitionActive(
    IN TCHAR DriveLetter
    );

//
// Enum for filesystems we recognize
//
typedef enum {
    Winnt32FsUnknown,
    Winnt32FsFat,
    Winnt32FsFat32,
    Winnt32FsNtfs
} WINNT32_SYSPART_FILESYSTEM;

//
// Hardcoded constant for sector size, and sizes
// of bootcode areas for various filesystems.
//
#define WINNT32_SECTOR_SIZE             512

#define WINNT32_FAT_BOOT_SECTOR_COUNT   1
#define WINNT32_NTFS_BOOT_SECTOR_COUNT  16

#define WINNT32_MAX_BOOT_SIZE           (16*WINNT32_SECTOR_SIZE)

BOOL
PatchBootCode(
    IN      WINNT32_SYSPART_FILESYSTEM  FileSystem,
    IN      TCHAR   Drive,
    IN OUT  PUCHAR  BootCode,
    IN      DWORD   BootCodeSize
    );

#endif //_X86_

//
// ARC/NV-RAM stuff
//

#if defined _IA64_
#define SETUPLDR_FILENAME L"SETUPLDR.EFI"

#elif defined _X86_
#define SETUPLDR_FILENAME L"arcsetup.exe"

#else
#define SETUPLDR_FILENAME L"SETUPLDR"

#endif

BOOL
SetUpNvRam(
    IN HWND ParentWindow
    );

DWORD
DriveLetterToArcPath(
    IN  WCHAR   DriveLetter,
    OUT LPWSTR *ArcPath
    );


//
// Implement a terminalserver-safe GetWindowsDirectory()
//
UINT
MyGetWindowsDirectory(
    LPTSTR  MyBuffer,
    UINT    Size
    );


//
// Upgrade stuff
//

typedef struct _UPGRADE_SUPPORT {
    TCHAR DllPath[MAX_PATH];
    HINSTANCE DllModuleHandle;

    UINT AfterWelcomePageCount;
    LPPROPSHEETPAGE Pages1;

    UINT AfterOptionsPageCount;
    LPPROPSHEETPAGE Pages2;

    UINT BeforeCopyPageCount;
    LPPROPSHEETPAGE Pages3;

    PWINNT32_PLUGIN_INIT_ROUTINE InitializeRoutine;
    PWINNT32_PLUGIN_GETPAGES_ROUTINE GetPagesRoutine;
    PWINNT32_PLUGIN_WRITEPARAMS_ROUTINE WriteParamsRoutine;
    PWINNT32_PLUGIN_CLEANUP_ROUTINE CleanupRoutine;
    PWINNT32_PLUGIN_OPTIONAL_DIRS_ROUTINE OptionalDirsRoutine;

} UPGRADE_SUPPORT, *PUPGRADE_SUPPORT;

extern UPGRADE_SUPPORT UpgradeSupport;

//
// Only check to see if we can upgrade or not.
//
extern BOOL CheckUpgradeOnly;
extern BOOL CheckUpgradeOnlyQ;
extern BOOL UpgradeAdvisorMode;

BOOL
InitializeArcStuff(
    IN HWND Parent
    );

BOOL
ArcInitializeArcStuff(
    IN HWND Parent
    );


//
// Test to see if we're on an ARC based machine

#ifdef UNICODE

#if defined(_X86_)
BOOL
IsArc(
    VOID
    );
#else
#define IsArc() TRUE
#endif

#if defined(EFI_NVRAM_ENABLED)
BOOL
IsEfi(
    VOID
    );
#else
#define IsEfi() FALSE
#endif

VOID
MigrateBootVarData(
    VOID
    );

#else

#define IsArc()                 (FALSE)
#define MigrateBootVarData()

#endif

//
// Build the command console.
//
extern BOOL BuildCmdcons;


#ifdef RUN_SYSPARSE
//
// NoSysparse. Set to true if we don't want to run sysparse.exe
// This hack should be removed before RTM.
//
extern BOOL NoSysparse;
extern PROCESS_INFORMATION piSysparse;
#endif

//
// Internal/undoc'ed stuff
//
extern UINT NumberOfLicensedProcessors;
extern BOOL IgnoreExceptionPackages;

//
// Where to get missing files.
//

extern TCHAR AlternateSourcePath[MAX_PATH];


VOID
InternalProcessCmdLineArg(
    IN LPCTSTR Arg
    );

//
// Get Harddisk BPS
//
ULONG
GetHDBps(
    HANDLE hDisk
    );

#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

#ifdef _X86_
//
// PC-98 stuff
//
VOID
SetAutomaticBootselector(
    VOID
    );

VOID
SetAutomaticBootselectorNT(
    VOID
    );
VOID
SetAutomaticBootselector95(
    VOID
    );

#define ALIGN(p,val)                                        \
                                                            \
    (PVOID)((((ULONG)(p) + (val) - 1)) & (~((val) - 1)))

//
// read/write disk sectors
//
NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOL    Write
    );

#define NEC_WRITESEC    TRUE
#define NEC_READSEC     FALSE

//
// Get WindowsNT System Position
//
UCHAR
GetSystemPosition(
    PHANDLE phDisk,
    PDISK_GEOMETRY SystemMediaInfo
    );

BOOL
IsNEC98(
    VOID
    );

LONG
CalcHiddenSector(
    IN TCHAR SystemPartitionDriveLetter,
    IN SHORT Bps
    );

#endif

//
//  Registry migration stuff
//

//
// Context structure used for generating inf files (infgen.c)
//
#define INFLINEBUFLEN   512

typedef struct _INFFILEGEN {

    TCHAR FileName[MAX_PATH];
    HANDLE FileHandle;

    BOOL SawBogusOp;

    TCHAR LineBuf[INFLINEBUFLEN];
    unsigned LineBufUsed;

} INFFILEGEN, *PINFFILEGEN;


DWORD
InfStart(
    IN  LPCTSTR       InfName,
    IN  LPCTSTR       Directory,
    OUT PINFFILEGEN   *Context
    );

DWORD
InfEnd(
    IN OUT PINFFILEGEN *Context
    );

DWORD
InfCreateSection(
    IN     LPCTSTR      SectionName,
    IN OUT PINFFILEGEN  *Context
    );

DWORD
InfRecordAddReg(
    IN OUT PINFFILEGEN Context,
    IN     HKEY        Key,
    IN     LPCTSTR     Subkey,
    IN     LPCTSTR     Value,       OPTIONAL
    IN     DWORD       DataType,
    IN     PVOID       Data,
    IN     DWORD       DataLength,
    IN     BOOL        SetNoClobberFlag
    );

ULONG
DumpRegKeyToInf(
    IN  PINFFILEGEN InfContext,
    IN  HKEY        PredefinedKey,
    IN  LPCTSTR     FullKeyPath,
    IN  BOOL        DumpIfEmpty,
    IN  BOOL        DumpSubKeys,
    IN  BOOL        SetNoClobberFlag,
    IN  BOOL        DumpNonVolatileKey
    );

DWORD
WriteText(
    IN HANDLE FileHandle,
    IN UINT   MessageId,
    ...
    );


//
//  Unsupported driver migration stuff
//


//
//  Structure used to build a list of files associated to and usupported
//  driver that was detected on the NT system to be upgraded.
//
typedef struct _UNSUPORTED_PNP_HARDWARE_ID {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_PNP_HARDWARE_ID *Next;

    //
    //  String that represents the hardware id of a PNP device.
    //
    LPTSTR Id;

    //
    // Service for the device
    //
    LPTSTR Service;

    //
    // GUID for this device, if any
    //
    LPTSTR ClassGuid;

} UNSUPORTED_PNP_HARDWARE_ID, *PUNSUPORTED_PNP_HARDWARE_ID;


typedef struct _UNSUPORTED_DRIVER_FILE_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_FILE_INFO *Next;

    //
    //  Pointer to the file name
    //
    LPTSTR FileName;

    //
    // Pointer to the path relative to %SystemRoot% where the file
    // should be installed.
    //
    LPTSTR TargetDirectory;

} UNSUPORTED_DRIVER_FILE_INFO, *PUNSUPORTED_DRIVER_FILE_INFO;


typedef struct _UNSUPORTED_DRIVER_REGKEY_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_REGKEY_INFO *Next;

    //
    //  A predefined key
    //
    HKEY PredefinedKey;

    //
    //  Path to the key to be migrated, relative to a predefined key.
    //
    LPTSTR KeyPath;

    //
    //  Undicates whether or not volatile keys should be migrated
    //
    BOOL MigrateVolatileKeys;

} UNSUPORTED_DRIVER_REGKEY_INFO, *PUNSUPORTED_DRIVER_REGKEY_INFO;


typedef struct _UNSUPORTED_DRIVER_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_INFO *Next;

    //
    //  A string that identifies the driver to be migrated (such as aic78xx)
    //
    LPTSTR DriverId;

    //
    //  Points to the list of files associated to the unsupported driver
    //
    PUNSUPORTED_DRIVER_REGKEY_INFO KeyList;

    //
    //  Points to the list of keys associated to the unsupported driver
    //
    PUNSUPORTED_DRIVER_FILE_INFO FileList;

    //
    //  Points to the list of hardware ids associated to the unsupported driver
    //
    PUNSUPORTED_PNP_HARDWARE_ID HardwareIdsList;


} UNSUPORTED_DRIVER_INFO, *PUNSUPORTED_DRIVER_INFO;


//
//  Unsupported driver list
//  This list contains the information about the unsupported drivers that needs
//  to be migrated on a clean install or upgrade.
//
// extern PUNSUPORTED_DRIVER_INFO UnsupportedDriverList;


BOOL
BuildUnsupportedDriverList(
    IN  PVOID                    TxtsetupSifHandle,
    OUT PUNSUPORTED_DRIVER_INFO* DriverList
    );

BOOL
SaveUnsupportedDriverInfo(
    IN HWND                    ParentWindow,
    IN LPTSTR                  FileName,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    );

BOOL
AddUnsupportedFilesToCopyList(
    IN HWND ParentWindow,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    );

BOOL
MigrateUnsupportedNTDrivers(
    IN HWND   ParentWindow,
    IN PVOID  TxtsetupSifHandle
    );


// Error codes and Function to check schema version for NT5 DC Upgrades

#define  DSCHECK_ERR_SUCCESS           0
#define  DSCHECK_ERR_FILE_NOT_FOUND    1
#define  DSCHECK_ERR_FILE_COPY         2
#define  DSCHECK_ERR_VERSION_MISMATCH  3

BOOL
ISDC(
    VOID
    );

BOOL
IsNT5DC();

int
CheckSchemaVersionForNT5DCs(
    IN HWND  ParentWnd
    );

//
// Diagnostic/debug functions in debug.c
//

//
// Allow assertion checking to be turned on independently
// of DBG, like by specifying C_DEFINES=-DASSERTS_ON=1 in sources file.
//
#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#if ASSERTS_ON

#ifndef MYASSERT

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#endif

#else

#define MYASSERT(x)

#endif


#ifdef _X86_

VOID
ProtectAllModules (
    VOID
    );

#endif


BOOL
WriteHeadlessParameters(
    IN LPCTSTR FileName
    );



//
// Setup Log prototypes in setupapi.dll
//

typedef BOOL(WINAPI * SETUPOPENLOG)(BOOL Erase);
typedef BOOL(WINAPI * SETUPLOGERROR)(PCTSTR MessageString, LogSeverity Severity);
typedef VOID(WINAPI * SETUPCLOSELOG)(VOID);

//
// Default throughput (5 KB/msec)
//
#define DEFAULT_IO_THROUGHPUT   (5 * 1024)

extern DWORD dwThroughPutSrcToDest;
extern DWORD dwThroughPutHDToHD;
void CalcThroughput();

// Should allow 1K for strings for localization
#define MAX_STRING 1024

BOOL
SaveAdvancedOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
SaveLanguageOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
SaveAccessibilityOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadAdvancedOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadLanguageOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadAccessibilityOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
AddCopydirIfExists(
    IN LPTSTR pszPathToCopy,
    IN UINT Flags
    );

BOOL
IsNetConnectivityAvailable (
    VOID
    );

BOOL
ValidatePidEx(LPTSTR PID, BOOL *pbStepup, BOOL *bSelect);


#ifdef PRERELEASE
#define TEST_EXCEPTION 1
#endif

#define SETUP_FAULTH_APPNAME "drw\\faulth.dll"
//#define SETUP_URL     "officewatson"
#define SETUP_URL       "watson.microsoft.com"

#define S_WINNT32LOGFILE                TEXT("WINNT32.LOG")
#define S_DEFAULT_NT_COMPAT_FILENAME    TEXT("UPGRADE.TXT")

#ifdef TEST_EXCEPTION
void DoException( DWORD dwSetupArea);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\amd64\bootini.c ===
#include "precomp.h"
#pragma hdrstop

#include <bootfat.h>
#include <bootf32.h>
#include <boot98f.h>
#include <boot98f2.h>
#include <patchbc.h>

//
// Define name of file we use to contain the auxiliary boot sector.
//
#define AUX_BOOT_SECTOR_NAME_A    "BOOTSECT.DAT"
#define AUX_BOOT_SECTOR_NAME_W    L"BOOTSECT.DAT"
#ifdef UNICODE
#define AUX_BOOT_SECTOR_NAME      AUX_BOOT_SECTOR_NAME_W
#else
#define AUX_BOOT_SECTOR_NAME      AUX_BOOT_SECTOR_NAME_A
#endif

//
// Enum for filesystems we recognize
//
typedef enum {
    Winnt32FsUnknown,
    Winnt32FsFat,
    Winnt32FsFat32,
    Winnt32FsNtfs
} WINNT32_SYSPART_FILESYSTEM;

//
// Hardcoded constant for sector size, and sizes
// of bootcode areas for various filesystems.
//
#define WINNT32_SECTOR_SIZE             512

#define WINNT32_FAT_BOOT_SECTOR_COUNT   1
#define WINNT32_NTFS_BOOT_SECTOR_COUNT  16

#define WINNT32_MAX_BOOT_SIZE           (16*WINNT32_SECTOR_SIZE)


BOOL CleanUpBootCode;
DWORD CleanUpBootIni;


BOOL
HandleBootFilesWorker_NEC98(
    IN TCHAR *SourceDir,
    IN TCHAR *DestDir,
    IN PTSTR  File,
    IN BOOL   Flag
    );

LONG
CalcHiddenSector95(
    IN TCHAR DriveLetter
    );

BOOL
LoadBootIniString(
  IN HINSTANCE ModuleHandle,
  IN DWORD MsgId,
  OUT PSTR Buffer,
  IN DWORD Size
  );

//
//


BOOL
CheckSysPartAndReadBootCode(
    IN  HWND                        ParentWindow,
    OUT WINNT32_SYSPART_FILESYSTEM *Filesystem,
    OUT BYTE                        BootCode[WINNT32_MAX_BOOT_SIZE],
    OUT PUINT                       BootCodeSectorCount
    )
/*++

Routine Description:

    This routine does some inspection on the x86 system partition
    to determine its filesystem and sector size. We only support
    512-byte sectors, and there are code depedencies all over the place
    based on this.

    If the sector size is wrong or there's a filesystem we don't recognize
    then the user is informed.

Arguments:

    ParentWindow - supplies window handle of window to be used as
        parent/owner in case this routine puts up UI.

    Filesystem - if successful, receives the filesystem of the system partition.

    BootCode - if successful, receives a copy of the boot code currently
        on the disk.

    BootCodeSectorCount - if successful, receives the size in 512-byte sectors
        of the boot code area for the filesystem on the system partition.

Return Value:

    Boolean value indicating whether the system partition is acceptable.
    If not, the user will have been informed as to why.

--*/

{
    TCHAR DrivePath[4];
    DWORD DontCare;
    DWORD SectorSize;
    TCHAR NameBuffer[100];
    BOOL b;

    //
    // Form root path
    //
    DrivePath[0] = SystemPartitionDriveLetter;
    DrivePath[1] = TEXT(':');
    DrivePath[2] = TEXT('\\');
    DrivePath[3] = 0;

    //
    // Check sector size
    //
    if(!GetDiskFreeSpace(DrivePath,&DontCare,&SectorSize,&DontCare,&DontCare)
    || (SectorSize != WINNT32_SECTOR_SIZE)) {
        if (!(IsNEC98() && (SectorSize > WINNT32_SECTOR_SIZE))) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UNSUPPORTED_SECTOR_SIZE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );
            return(FALSE);
        }
    }

    //
    // Determine file system.
    //
    b = GetVolumeInformation(
            DrivePath,
            NULL,0,                 // don't care about volume name
            NULL,                   // ...or serial #
            &DontCare,              // ...or max component length
            &DontCare,              // ... or flags
            NameBuffer,
            sizeof(NameBuffer)/sizeof(TCHAR)
            );

    if(!b) {

        MessageBoxFromMessage(
            ParentWindow,
            MSG_UNKNOWN_FS,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            SystemPartitionDriveLetter
            );

        return(FALSE);
    }

    if(!lstrcmpi(NameBuffer,TEXT("NTFS"))) {

         *Filesystem = Winnt32FsNtfs;
         *BootCodeSectorCount = WINNT32_NTFS_BOOT_SECTOR_COUNT;

         b = ReadDiskSectors(
                 SystemPartitionDriveLetter,
                 0,
                 WINNT32_NTFS_BOOT_SECTOR_COUNT,
                 WINNT32_SECTOR_SIZE,
                 BootCode
                 );

         if(!b) {
             MessageBoxFromMessage(
                 ParentWindow,
                 MSG_DASD_ACCESS_FAILURE,
                 FALSE,
                 AppTitleStringId,
                 MB_OK | MB_ICONERROR | MB_TASKMODAL,
                 SystemPartitionDriveLetter
                 );

             return(FALSE);
         }
    } else {
        if(!lstrcmpi(NameBuffer,TEXT("FAT")) || !lstrcmpi(NameBuffer,TEXT("FAT32"))) {
            //
            // Read 1 sector.
            //
            b = ReadDiskSectors(
                    SystemPartitionDriveLetter,
                    0,
                    WINNT32_FAT_BOOT_SECTOR_COUNT,
                    WINNT32_SECTOR_SIZE,
                    BootCode
                    );

            if(!b) {
                MessageBoxFromMessage(
                    ParentWindow,
                    MSG_DASD_ACCESS_FAILURE,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    SystemPartitionDriveLetter
                    );

                return(FALSE);
            }

            *Filesystem = NameBuffer[3] ? Winnt32FsFat32 : Winnt32FsFat;
            *BootCodeSectorCount = WINNT32_FAT_BOOT_SECTOR_COUNT;
        } else {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UNKNOWN_FS,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );

            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
IsNtBootCode(
    IN  WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN  LPBYTE                     BootCode
    )

/*++

Routine Description:

    Determine if boot code is for NT by examining the filesystem and
    the code itself, looking for the NTLDR string that must be present
    in all NT boot code.

    If the filesystem is NTFS then it's NT boot code.
    If not then we scan backwards in the boot sector looking for the
    NTLDR string.

Arguments:

    Filesystem - supplies the filesystem on the drive.

    BootCode - supplies the boot code read from the drive. Only the first
        sector (512 bytes) are examined.

Return Value:

    Boolean value indicating whether the boot code is for NT.
    There is no error return.

--*/

{
    UINT i;

    //
    // Because the last 2 bytes are the 55aa signature we can
    // skip them in the scan.
    //
    if(Filesystem == Winnt32FsNtfs) {
        return(TRUE);
    }

    for(i=WINNT32_SECTOR_SIZE-7; i>62; --i) {
        if(!memcmp("NTLDR",BootCode+i,5)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


BOOL
__inline
WriteToBootIni(
    IN HANDLE Handle,
    IN PCHAR  Line
    )
{
    DWORD bw,l;

    l = lstrlenA(Line);

    return(WriteFile(Handle,Line,l,&bw,NULL) && (bw == l));
}
  
BOOL
MungeBootIni(
    IN HWND ParentWindow,
    IN BOOL SetPreviousOs
    )
{
    TCHAR BootIniName[16];
    TCHAR BootIniBackup[16];
    UCHAR BootSectorImageSpec[29];
    CHAR HeadlessRedirectSwitches[160];
    TCHAR ParamsFile[MAX_PATH];
    HANDLE h;
    DWORD BootIniSize;
    PUCHAR Buffer;
    DWORD BytesRead;
    BOOL b;
    PUCHAR p,next;
    BOOL InOsSection;
    CHAR c;
    CHAR Text[256];
    DWORD OldAttributes;
    DWORD d;

    PUCHAR DefSwitches;
    PUCHAR DefSwEnd;
    UCHAR  temp;

    //
    // Determine the size of boot.ini, allocate a buffer,
    // and read it in. If it isn't there then it will be created.
    //
    wsprintf(BootIniName,TEXT("%c:\\BOOT.INI"),SystemPartitionDriveLetter);
    wsprintf(BootIniBackup,TEXT("%c:\\BOOT.BAK"),SystemPartitionDriveLetter);

    h = CreateFile(BootIniName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    if(h == INVALID_HANDLE_VALUE) {
        //
        // Assume the file does not exist. Allocate a buffer large enough
        // to hold a single terminating nul byte.
        //
        BootIniSize = 0;
        Buffer = MALLOC(1);
        if(!Buffer) {
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }
    } else {
        //
        // Figure out how big the file is.
        // Allocate 3 extra characters for final NUL we'll add to make
        // parsing easier, and a cr/lf in case the last line is incomplete.
        //
        BootIniSize = GetFileSize(h,NULL);
        if(BootIniSize == (DWORD)(-1)) {
            d = GetLastError();
            CloseHandle(h);
            b = FALSE;
            goto c0;
        }

        Buffer = MALLOC(BootIniSize+3);
        if(!Buffer) {
            CloseHandle(h);
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        b = ReadFile(h,Buffer,BootIniSize,&BytesRead,NULL);
        d = GetLastError();
        CloseHandle(h);
        if(!b) {
            goto c1;
        }
    }

    //
    // Make sure the last line is properly terminated, and add a terminating nul
    // to make parsing a little easier.
    //
    if(BootIniSize && (Buffer[BootIniSize-1] != '\n') && (Buffer[BootIniSize-1] != '\r')) {
        Buffer[BootIniSize++] = '\r';
        Buffer[BootIniSize++] = '\n';
    }
    Buffer[BootIniSize] = 0;

    //
    // Truncate at control-z if any.
    //
    if(p = strchr(Buffer,26)) {
        if((p > Buffer) && (*(p - 1) != '\n') && (*(p - 1) != '\r')) {
            *(p++) = '\r';
            *(p++) = '\n';
        }
        *p = 0;
        BootIniSize = p - Buffer;
    }

    //
    // Make sure we can write boot.ini, and make a backup copy.
    // (We do not procede unless we can make a backup copy.)
    // Then recreate boot.ini.
    //
    OldAttributes = GetFileAttributes(BootIniName);
    SetFileAttributes(BootIniBackup,FILE_ATTRIBUTE_NORMAL);
    if(OldAttributes == (DWORD)(-1)) {
        //
        // Boot.ini didn't exist before. Nothing to do.
        //
    } else {
        //
        // Make a backup copy.
        //
        if(CopyFile(BootIniName,BootIniBackup,FALSE)) {
            //
            // Attributes could be 0 but not -1. Adding 1 thus allows us to
            // use non-0 to mean that we have a backup file.
            //
            CleanUpBootIni = OldAttributes+1;
        } else {
            d = GetLastError();
            b = FALSE;
            goto c1;
        }
    }

    SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
    h = CreateFile(
            BootIniName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c2;
    }

    //
    // Regardless of the actual drive letter of the system partition,
    // the spec in boot.ini is always C:\...
    //
    wsprintfA(BootSectorImageSpec,"C:\\%hs\\%hs",LOCAL_BOOT_DIR_A,AUX_BOOT_SECTOR_NAME_A);

    //
    // Scan the Buffer to see if there is a DefSwitches line,
    // to move into new boot.ini in the  [boot loader] section.
    // If no DefSwitches, just point to a null string to be moved.
    // Only process boot.ini up to [operating systems].
    //

    temp = '\0';
    DefSwitches = &temp;
    DefSwEnd = NULL;
    for(p=Buffer; *p && (p < Buffer+BootIniSize - (sizeof("[operating systems]")-1)); p++) {
      if(!_strnicmp(p,"DefSwitches",sizeof("DefSwitches")-1)) {
        DefSwEnd = strstr(p, "\n");
        if(DefSwEnd){
          DefSwEnd++;
          if(*DefSwEnd == '\r'){
            DefSwEnd++;
          }
          DefSwitches = p;
          temp = *DefSwEnd;
          *DefSwEnd = '\0';
        }
        break;
      } else {
        if(!_strnicmp(p,"[operating systems]",sizeof("[operating systems]")-1)) {
            break;
        }
      }
    }




    //
    // Take care of the headless setings.
    //
    HeadlessRedirectSwitches[0] = '\0';

    if( HeadlessSelection[0] != TEXT('\0') ) {

        //
        // They told winnt32.exe some specific headless settings.
        // Use these.
        //


        //
        // Convert the user's request into ASCII.
        //
#ifdef UNICODE
        {
            CHAR tmp[80];

            WideCharToMultiByte( CP_ACP,
                                 0,
                                 HeadlessSelection,
                                 -1,
                                 tmp,
                                 sizeof(tmp),
                                 NULL,
                                 NULL );

            wsprintfA( HeadlessRedirectSwitches,
                       "redirect=%s\r\n",
                       tmp );
        }
#else
        wsprintfA( HeadlessRedirectSwitches,
                   "redirect=%s\r\n",
                   HeadlessSelection );
#endif

    } else {

        //
        // They didn't give us any settings, so see if we can pick
        // something up from boot.ini
        //


        //
        // Parse through boot.ini, looking for any 'redirect=' lines.
        //
        for( p = Buffer; *p && (p < Buffer+BootIniSize - (sizeof("redirect=")-1)); p++ ) {

            if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

                //
                // We're past the [Boot Loader] section.  Stop looking.
                //
                break;
            }

            if(!_strnicmp(p,"redirect=",sizeof("redirect=")-1)) {

                PUCHAR      q = p;
                UCHAR       temp;

                while ((*p != '\r') && (*p != '\n') && *p) {
                    p++;
                }
                temp = *p;
                *p = '\0';
                strcpy(HeadlessRedirectSwitches, q);

                //
                // We want to make sure that this setting gets put into
                // the unattend file too so that textmode will redirect.
                // We need to set the global 'HeadlessSelection' so that
                // he will get written to winnt.sif after this block.
                //
#ifdef UNICODE
                MultiByteToWideChar( CP_ACP,
                                     MB_ERR_INVALID_CHARS,
                                     strchr(HeadlessRedirectSwitches, '=')+1,
                                     -1,
                                     HeadlessSelection,
                                     MAX_PATH );
#else
                strcpy( HeadlessSelection, strchr(HeadlessRedirectSwitches, '=')+1 );
#endif

                strcat(HeadlessRedirectSwitches, "\r\n" );
                *p = temp;

            }

        }

    }




    //
    // Now take care of the 'redirectbaudrate=X' setting.
    //
    if( HeadlessRedirectSwitches[0] != TEXT('\0') ) {

        //
        // We got got a direction to redirect.  Now see about
        // the baudrate.
        //
        if( HeadlessBaudRate != 0 ) {

            CHAR MyHeadlessRedirectBaudRateLine[80] = {0};

            wsprintfA( MyHeadlessRedirectBaudRateLine,
                       "redirectbaudrate=%d\r\n",
                       HeadlessBaudRate );

            strcat( HeadlessRedirectSwitches, MyHeadlessRedirectBaudRateLine );

        } else {

            //
            // They didn't give us any settings, so see if we can pick
            // something up from boot.ini
            //

            //
            // Parse through boot.ini, looking for any 'redirectbaudrate=' lines.
            //
            for( p = Buffer; *p && (p < Buffer+BootIniSize - (sizeof("redirectbaudrate=")-1)); p++ ) {

                if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

                    //
                    // We're past the [Boot Loader] section.  Stop looking.
                    //
                    break;
                }

                if(!_strnicmp(p,"redirectbaudrate=",sizeof("redirectbaudrate=")-1)) {

                    PUCHAR      q = p;
                    UCHAR       temp;

                    while ((*p != '\r') && (*p != '\n') && *p) {
                        p++;
                    }
                    temp = *p;
                    *p = '\0';
                    strcat(HeadlessRedirectSwitches, q);
                    strcat(HeadlessRedirectSwitches, "\r\n" );
                    *p = temp;


                    //
                    // Now set the global HeadlessBaudRate variable so
                    // we'll know what to write in winnt.sif when the time
                    // comes.
                    //
                    p = strchr( q, '=' );
                    if( p ) {
                        p++;
                        HeadlessBaudRate = atoi( p );
                    }

                }

            }

        }
    }


    //
    // Now generate the name of the parameters file
    // and write our headless settings out.
    //
    BuildSystemPartitionPathToFile( LOCAL_BOOT_DIR,
                                    ParamsFile,
                                    MAX_PATH );
    ConcatenatePaths(ParamsFile,WINNT_SIF_FILE,MAX_PATH);
    WriteHeadlessParameters( ParamsFile );




    wsprintfA(
        Text,
        "[Boot Loader]\r\nTimeout=5\r\nDefault=%hs\r\n%hs[Operating Systems]\r\n",
        BootSectorImageSpec,
        HeadlessRedirectSwitches
    );


    //
    // If there were DefSwitches, set the Buffer back to original state
    //
    if(DefSwEnd){
         *DefSwEnd = temp;
    }

    if(!WriteToBootIni(h,Text)) {
        d = GetLastError();
        b = FALSE;
        goto c3;
    }

    //
    // Process each line in boot.ini.
    // If it's the setup boot sector line, we'll throw it out.
    // For comparison with lines in boot.ini, the drive letter
    // is always C even if the system partition is not actually C:.
    //
    InOsSection = FALSE;
    b = TRUE;
    for(p=Buffer; *p && b; p=next) {

        while((*p==' ') || (*p=='\t')) {
            p++;
        }

        if(*p) {

            //
            // Find first byte of next line.
            //
            for(next=p; *next && (*next++ != '\n'); );

            //
            // Look for start of [operating systems] section
            // or at each line in that section.
            //
            if(InOsSection) {

                switch(*p) {

                case '[':   // end of section.
                    *p=0;   // force break out of loop
                    break;

                case 'C':
                case 'c':   // potential start of c:\ line

                    //
                    // See if it's a line for setup boot.
                    // If so, ignore it.
                    //
                    if(!_strnicmp(p,BootSectorImageSpec,lstrlenA(BootSectorImageSpec))) {
                        break;
                    }

                    //
                    // If we're supposed to set the previous OS and this is
                    // a line for the previous OS, ignore it.
                    //
                    if(SetPreviousOs && (p[1] == ':') && (p[2] == '\\')
                    && ((p[3] == '=') || (p[3] == ' ') || (p[3] == '\t'))) {

                        break;
                    }

                    //
                    // Not a special line, FALL THROUGH to write it out as-is.
                    //

                default:

                    //
                    // Random line. write it out.
                    //
                    c = *next;
                    *next = 0;
                    b = WriteToBootIni(h,p);
                    *next = c;

                    break;

                }

            } else {
                if(!_strnicmp(p,"[operating systems]",19)) {
                    InOsSection = TRUE;
                }
            }
        }
    }

    //
    // Write out our line.
    //
    if(b) {
      CHAR  *AnsiStrs[] = {
              "Microsoft Windows XP Professional Setup",
              "Microsoft Windows 2002 Server Setup",
              "Microsoft Windows 2002 Advanced Server Setup",
              "Microsoft Windows 2002 DataCenter Setup",
              "Microsoft Windows XP Setup"
              };
            
      DWORD Index = -1;
      
      if (!LoadBootIniString(hInst, AppTitleStringId, Text, sizeof(Text))) {
        switch (AppTitleStringId) {
          case IDS_APPTITLE_WKS:
            Index = 0;
            break;
            
          case IDS_APPTITLE_SRV:
            Index = 1;
            break;
            
          case IDS_APPTITLE_ASRV:
            Index = 2;
            break;
            
          case IDS_APPTITLE_DAT:
            Index = 3;
          
          default:
            Index = 4;
            break;
        }

        strcpy(Text, AnsiStrs[Index]);
      }        
        

      if((b=WriteToBootIni(h,BootSectorImageSpec))
      && (b=WriteToBootIni(h,"=\""))
      && (b=WriteToBootIni(h,Text))) {
          b = WriteToBootIni(h,"\"\r\n");
      }
    }

    //
    // Write out previous OS line if directed to do so.
    //
    if(b && SetPreviousOs) {
        if(b = WriteToBootIni(h,"C:\\=\"")) {
            LoadStringA(hInst,IDS_MICROSOFT_WINDOWS,Text,sizeof(Text));
            if(b = WriteToBootIni(h,Text)) {
                b = WriteToBootIni(h,"\"\r\n");
            }
        }
    }

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    d = NO_ERROR;

c3:
    CloseHandle(h);
c2:
    //
    // Restore boot.ini.
    //
    if(!b && (OldAttributes != (DWORD)(-1))) {
        SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
        CopyFile(BootIniBackup,BootIniName,FALSE);
        SetFileAttributes(BootIniName,OldAttributes);
        SetFileAttributes(BootIniBackup,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(BootIniBackup);
    }
c1:
    FREE(Buffer);
c0:
    if(!b) {
        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            BootIniName
            );
    }

    return(b);
}


VOID
MigrateBootIniData(
    VOID
    )
{
    TCHAR BootIniName[16];

    //
    // Determine the size of boot.ini, allocate a buffer,
    // and read it in. If it isn't there then it will be created.
    //
    wsprintf(BootIniName,TEXT("%c:\\BOOT.INI"),SystemPartitionDriveLetter);
    
    GetPrivateProfileString(
                    TEXT("Boot Loader"),
                    TEXT("Timeout"),
                    TEXT(""),
                    Timeout,
                    sizeof(Timeout)/sizeof(TCHAR),
                    BootIniName);        
}


BOOL
LayNtBootCode(
    IN     HWND                       ParentWindow,
    IN     WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN OUT LPBYTE                     BootCode
    )

/*++

Routine Description:

    Copy existing boot sector into bootsect.dos and lay down NT boot code.

    THIS ROUTINE DOES NOT CHECK THE EXISTING BOOT CODE. The caller must
    do that, and not call this routine if the existing boot code is
    already for NT. This routine should never be called for an NTFS drive
    since by definition that's NT boot code.

Arguments:

    ParentWindow - supplies window handle of window to be used as
        owner/parent in case this routine puts up UI.

    Filesystem - supplies filesystem for system partition, as determined
        earlier by CheckSysPartAndReadBootCode(). Either Fat or Fat32.

    BootCode - on input, supplies copy of existing boot code read from
        the drive. On output, receives copy of new boot code that was
        was written to the drive.

Return Value:

    Boolean value indicating outcome. If FALSE then the user will have been
    informed as to why.

--*/

{
    UINT i;
    HANDLE h;
    TCHAR FileName[13];
    DWORD d;
    BOOL b;


    //
    // Nt 3.51 will bugcheck here if they have an adaptec
    // 2940 card.  Return if we're on 3.51.  Note that
    // if any of the APIs fail, or anything goes wrong
    // in here, we just continue, assuming we're not
    // on NT 3.51.
    //
    if(!IsNEC98() && ISNT() && (BuildNumber <= NT351)) {
        return TRUE;
    }

    //
    // We may want to update the boot sector even if it
    // is NT boot code.  In that case, we don't want to
    // go blast out a new bootsect.dos.  Check first.
    //
    // If this process is called during /cmdcons,
    // the BOOTSECT.DOS should not be created on NEC98
    //
    if((IsNEC98() && !(BuildCmdcons)) || !(ISNT() || IsNtBootCode(Filesystem,BootCode)) ) {

        //
        // Write out existing boot sector to bootsect.dos.
        // We only move a single sector, which is correct in Fat
        // and Fat32 cases. The NT Fat32 boot code looks in sector
        // 12 for its second sector, so no special casing is required.
        //
        FileName[0] = SystemPartitionDriveLetter;
        FileName[1] = TEXT(':');
        FileName[2] = TEXT('\\');
        lstrcpy(FileName+3,TEXT("BOOTSECT.DOS"));
        SetFileAttributes(FileName,FILE_ATTRIBUTE_NORMAL);

        h = CreateFile(
                FileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

        if(h == INVALID_HANDLE_VALUE) {

            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                FileName
                );

            return(FALSE);
        }

        b = WriteFile(h,BootCode,WINNT32_SECTOR_SIZE,&d,NULL);
        d = GetLastError();
        CloseHandle(h);

        if(!b) {
            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                d,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                FileName
                );

            return(FALSE);
        }

    }

    //
    // Now lay the NT code itself down onto the disk. We copy the non-BPB parts
    // of the appropriate template code into the caller's bootcode buffer.
    // Take advantage of the offset part of the jump instruction at the start
    // of the boot code (like eb 3c 90) to tell us where the BPB ends and
    // the code begins.
    //
    switch(Filesystem) {

    case Winnt32FsFat:
        {
        BYTE BootCodeBuffer[WINNT32_MAX_BOOT_SIZE];

            if (IsNEC98())
            {
                CopyMemory(BootCodeBuffer,PC98FatBootCode,sizeof(PC98FatBootCode));

                // NEC98 need set to HiddenSector(Bpb Index 0x011) value in BPB.
                // Hiddensector value is how many sectors from sector 0
                // This spec is NEC98 only.

                *(LONG *)&BootCodeBuffer[0x011 + 11]
                = CalcHiddenSector(SystemPartitionDriveLetter,
                                   *(SHORT *)&BootCodeBuffer[11]);

            } else {
                CopyMemory(BootCodeBuffer,FatBootCode,sizeof(FatBootCode));
            }
                CopyMemory(BootCode,BootCodeBuffer,3);
                CopyMemory(
                    BootCode + BootCodeBuffer[1] + 2,
                    BootCodeBuffer + BootCodeBuffer[1] + 2,
                    WINNT32_SECTOR_SIZE - (BootCodeBuffer[1] + 2)
                );
        }
        break;

    case Winnt32FsFat32:

        //
        // In the FAT32 case we also lay down NT's second sector at sector 12.
        //
        {
        BYTE BootCodeBuffer[WINNT32_MAX_BOOT_SIZE];

            if (IsNEC98())
            {
                CopyMemory(BootCodeBuffer,PC98Fat32BootCode,sizeof(PC98Fat32BootCode));
            } else {
                CopyMemory(BootCodeBuffer,Fat32BootCode,sizeof(Fat32BootCode));
            }

            b = WriteDiskSectors( SystemPartitionDriveLetter,
                                  12,
                                  1,
                                  WINNT32_SECTOR_SIZE,
                                  BootCodeBuffer+1024 );

            if(b) {
                CopyMemory(BootCode,BootCodeBuffer,3);

                CopyMemory( BootCode + BootCodeBuffer[1] + 2,
                            BootCodeBuffer + BootCodeBuffer[1] + 2,
                            WINNT32_SECTOR_SIZE - (BootCodeBuffer[1] + 2) );
            }
        }
        break;

    default:
        //
        // We should never get here.
        //
        b = FALSE;
        break;
    }

    if(b) {
        b = WriteDiskSectors(
                SystemPartitionDriveLetter,
                0,
                1,
                WINNT32_SECTOR_SIZE,
                BootCode
                );

        if(b) {
            CleanUpBootCode = TRUE;
        }
    }

    if(!b) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_DASD_ACCESS_FAILURE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            SystemPartitionDriveLetter
            );
    }

    return(b);
}


BOOL
CreateAuxiliaryBootSector(
    IN HWND                       ParentWindow,
    IN WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN LPBYTE                     BootCode,
    IN UINT                       BootCodeSectorCount
    )

/*++

Routine Description:

    When ntldr sees an entry in boot.ini that starts with the magic text "C:\"
    it will look to see if the item specifies a filename, and if so it will
    assume that the file is a boot sector, load it, and jump to it.

    We place an entry in boot.ini for C:\$WIN_NT$.~BT\BOOTSECT.DAT, and place
    our special boot sector(s) in that file. Our sector is special because it
    loads $LDR$ instead of NTLDR, allowing us to boot into setup without
    disturbing the "standard" ntldr-based boot.

    This routine exmaines the boot code on the disk, changes NTLDR to $LDR$
    and writes the result out to x:\$WIN_NT$.~BT\BOOTSECT.DAT.

    This code assumes a sector size of 512 bytes.

Arguments:

    ParentWindow - supplies a window handle for a window to act as parent/owner
        for any ui that gets displayed by this routine.

    Filesystem - supplies a value that indicates the filesystem on the
        system partition.

    BootCode - supplies a buffer containing a copy of the boot code that is
        actually on the disk.

    BootCodeSectorCount - supplies the number of sectors the boot code
        occupies on-disk (and thus indicates the size of the BootCode buffer).

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed about why".

--*/

{
    UINT i;
    TCHAR NameBuffer[MAX_PATH];
    HANDLE hFile;
    BOOL b;
    DWORD DontCare;

    //
    // Change NTLDR to $LDR$. NTFS stores it in unicode in its boot sector
    // so 2 separate algorithms are needed.
    //
    if(Filesystem == Winnt32FsNtfs) {
        for(i=1014; i>62; i-=2) {
            if(!memcmp("N\000T\000L\000D\000R\000",BootCode+i,10)) {
                //
                // Do NOT use _lstrcpynW here since there is no
                // way to get it to do the right thing without overwriting
                // the word after $LDR$ with a terminating 0. Doing that
                // breaks boot.
                //
                CopyMemory(BootCode+i,AUX_BS_NAME_W,10);
                break;
            }
        }
    } else {
        for(i=505; i>62; --i) {
            //
            // Scan for full name with spaces so we don't find a boot message
            // by accident.
            //
            if(!memcmp("NTLDR      ",BootCode+i,11)) {
                strncpy(BootCode+i,AUX_BS_NAME_A,5);
                break;
            }
        }
    }

    //
    // Form name of boot sector image file.
    //
    wsprintf(
        NameBuffer,
        TEXT("%c:\\%s\\%s"),
        SystemPartitionDriveLetter,
        LOCAL_BOOT_DIR,
        AUX_BOOT_SECTOR_NAME
        );

    //
    // Write boot sector image into file.
    //
    SetFileAttributes(NameBuffer,FILE_ATTRIBUTE_NORMAL);
    hFile = CreateFile(NameBuffer,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,0,NULL);
    if(hFile == INVALID_HANDLE_VALUE) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            NameBuffer
            );

        return(FALSE);
    }

    //
    // We have a timing bug that we're going to workaround for the
    // time being...
    //
    i = 0;
    b = FALSE;
    while( (i < 10) && (b == FALSE) ) {
        Sleep( 500 );
        b = WriteFile(hFile,BootCode,BootCodeSectorCount*WINNT32_SECTOR_SIZE,&DontCare,NULL);
        if( !b ) {
            DontCare = GetLastError();
        }
        i++;
    }

    if(!b) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            DontCare,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            NameBuffer
            );

//
// Set this back before we ship Beta2!
// -matth
//
#if 1
        //
        // Now try again.
        //
        b = WriteFile(hFile,BootCode,BootCodeSectorCount*WINNT32_SECTOR_SIZE,&DontCare,NULL);
#endif

    }

    CloseHandle(hFile);

    //
    // Success if we get here.
    //
    return(b);
}


BOOL
DoX86BootStuff(
    IN HWND ParentWindow
    )
{
    WINNT32_SYSPART_FILESYSTEM Filesystem;
    BYTE BootCode[WINNT32_MAX_BOOT_SIZE];
    UINT BootCodeSectorCount;
    BOOL AlreadyNtBoot;
    TCHAR Filename[13];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    BOOL b;

    //
    // On Win95, make sure we have NTLDR on the system partition,
    // otherwise it makes no sense to lay NT boot code. This is
    // a robustness thing to catch the case where an error occurred
    // copying that file and the user skipped, etc. Otherwise we could
    // end up getting the user into a situation where he can't boot.
    //
    if(!ISNT()) {
        wsprintf(Filename,TEXT("%c:\\NTLDR"),SystemPartitionDriveLetter);
        FindHandle = FindFirstFile(Filename,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            b = FALSE;
        } else {
            FindClose(FindHandle);
            if((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || !FindData.nFileSizeLow) {
                b = FALSE;
            } else {
                b = TRUE;
            }
        }

        if(!b) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_NTLDR_NOT_COPIED,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );

            return(FALSE);
        }
    }

    //
    // Check out C:. Sector size must be 512 bytes and it has to be
    // formatted in a filesystem we recognize -- FAT, FAT32, or NTFS
    // (NT 3.51 also supported HPFS, but we assume we would not have
    // gotten here if the drive is HPFS).
    //
    if(!CheckSysPartAndReadBootCode(ParentWindow,&Filesystem,BootCode,&BootCodeSectorCount)) {
        return(FALSE);
    }

    //
    // If we're running on Win95 check the existing boot code to see whether
    // it's already for NT. If on NT assume the boot code is correct.
    // That assumption could be bogus in some marginal cases (such as when
    // the user boots from a floppy with ntldr on it and C: is corrupt
    // or has been re-sys'ed, etc), but we ignore these issues.
    //
    AlreadyNtBoot = ISNT() ? TRUE : IsNtBootCode(Filesystem,BootCode);

    //
    // Munge boot.ini. We do this before laying NT boot code. If we did it
    // afterwards and it failed, then the user could have NT boot code but no
    // boot.ini, which would be bad news.
    //
    if(!MungeBootIni(ParentWindow,!AlreadyNtBoot)) {
        return(FALSE);
    }

    //
    // If BOOTSEC.DOS exist, We Need save BOOTSEC.DOS on NEC98 System.
    //Some case, It is different to Now boot sector. It is created by
    //NT4.
    // NEC970725
    // If this process is called during /cmdcons,
    // the BOOTSECT.DOS should not be renamed "BOOTSECT.NEC" on NEC98
    //

    if (IsNEC98() && !(BuildCmdcons)){
        TCHAR FileNameOld[16],FileNameNew[163];

        FileNameOld[0] = FileNameNew[0] = SystemPartitionDriveLetter;
        FileNameOld[1] = FileNameNew[1] = TEXT(':');
        FileNameOld[2] = FileNameNew[2] = TEXT('\\');
        lstrcpy(FileNameOld+3,TEXT("BOOTSECT.DOS"));
        lstrcpy(FileNameNew+3,TEXT("BOOTSECT.NEC"));
        SetFileAttributes(FileNameOld,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(FileNameNew);
        MoveFile(FileNameOld, FileNameNew);
    }

    //
    // If not already NT boot, copy existing boot code into bootsect.dos
    // and lay down NT boot code.
    //
    // We're going to start writing new boot code if we're on anything
    // but an NTFS drive.
    //
    if( (!AlreadyNtBoot) || (Filesystem != Winnt32FsNtfs) ) {
        if( !LayNtBootCode(ParentWindow,Filesystem,BootCode) ) {
            return(FALSE);
        }
    }

    //
    // Create the auxiliary boot code file, which is a copy of the NT
    // boot code for the drive, with NTLDR changed to $LDR$.
    //
    if( (ForcedSystemPartition) &&
        (UserSpecifiedLocalSourceDrive) &&
        (ForcedSystemPartition == UserSpecifiedLocalSourceDrive) ) {

        TCHAR FileNameOld[32],FileNameNew[32];
        //
        // The OEM is making a bootable disk with local source for a
        // preinstall scenario.  We can avoid any drive geometry dependence
        // by simply booting the setupldr instead of using the ntldr->
        // bootsect.dat->setupldr.  To do this, we'll simply copy setupldr
        // over ntldr.  Note that we're removing his ability to boot anything
        // other than textmode setup here, so be aware.
        //

        //
        // Unlock ntldr.
        //
        FileNameOld[0] = FileNameNew[0] = ForcedSystemPartition;
        FileNameOld[1] = FileNameNew[1] = TEXT(':');
        FileNameOld[2] = FileNameNew[2] = TEXT('\\');
        lstrcpy(FileNameOld+3,TEXT("$LDR$"));
        lstrcpy(FileNameNew+3,TEXT("NTLDR"));
        SetFileAttributes(FileNameNew,FILE_ATTRIBUTE_NORMAL);

        //
        // Move $LDR$ to NTLDR
        //
        DeleteFile(FileNameNew);
        MoveFile(FileNameOld, FileNameNew);

    } else {
        if(!CreateAuxiliaryBootSector(ParentWindow,Filesystem,BootCode,BootCodeSectorCount)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
RestoreBootSector(
    VOID
    )
{
    TCHAR Name[MAX_PATH];
    BYTE Buffer[WINNT32_MAX_BOOT_SIZE];
    DWORD BytesRead;
    BOOL b;
    HANDLE h;

    //
    // If we didn't get to the point of writing new boot code,
    // then there's nothing to do.
    //
    if(!CleanUpBootCode) {
        return(TRUE);
    }

    //
    // Try to put bootsect.dos back onto the boot sector.
    //
    wsprintf(
        Name,
        TEXT("%c:\\%s\\BOOTSECT.DOS"),
        SystemPartitionDriveLetter,
        LOCAL_BOOT_DIR
        );

    h = CreateFile(Name,GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL);
    if(h == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        b = ReadFile(h,Buffer,WINNT32_SECTOR_SIZE,&BytesRead,NULL);
        CloseHandle(h);

        if(b) {
            b = WriteDiskSectors(
                    SystemPartitionDriveLetter,
                    0,
                    1,
                    WINNT32_SECTOR_SIZE,
                    Buffer
                    );

            if(b) {
                //
                // If this worked then we don't need ntldr, ntdetect.com, or boot.ini.
                // If is possible that these files were there already before
                // and we're thus "overcleaning" but we shouldn't get here
                // unless we overwrote non-nt boot code with nt boot code.
                // Thus putting back bootsect.dos restores non-NT boot code,
                // so this shouldn't be too destructive.
                //
                Name[0] = SystemPartitionDriveLetter;
                Name[1] = TEXT(':');
                Name[2] = TEXT('\\');

                lstrcpy(Name+3,TEXT("NTLDR"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);

                lstrcpy(Name+3,TEXT("NTDETECT.COM"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);

                wsprintf(Name+3,TEXT("BOOT.INI"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);
            }
        }
    }

    return(b);
}


BOOL
RestoreBootIni(
    VOID
    )
{
    BOOL b = TRUE;
    TCHAR BootIniFile[12] = TEXT("X:\\BOOT.INI");
    TCHAR BackupFile[12] = TEXT("X:\\BOOT.BAK");

    if(CleanUpBootIni) {
        CleanUpBootIni--;

        BootIniFile[0] = SystemPartitionDriveLetter;
        BackupFile[0] = SystemPartitionDriveLetter;

        SetFileAttributes(BootIniFile,FILE_ATTRIBUTE_NORMAL);
        if(CopyFile(BackupFile,BootIniFile,FALSE)) {
            SetFileAttributes(BackupFile,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(BackupFile);
            SetFileAttributes(BootIniFile,CleanUpBootIni);
        } else {
            b = FALSE;
        }
    }

    return(b);
}


BOOL
SaveRestoreBootFiles_NEC98(
    IN UCHAR Flag
    )
{
    PTSTR BackupFiles[] = { TEXT("\\BOOT.INI"),
                            TEXT("\\NTDETECT.COM"),
                            TEXT("\\NTLDR"),
                            NULL
                          };

    PTSTR BackupFiles2[] = { TEXT("\\") AUX_BS_NAME, TEXT("\\") TEXTMODE_INF, NULL };

    UINT i;
    TCHAR SystemDir[3];

    SystemDir[0] = SystemPartitionDriveLetter;
    SystemDir[1] = TEXT(':');
    SystemDir[2] = 0;

    if (Flag == NEC98RESTOREBOOTFILES){
        //
        // Restore boot files.
        //
        for(i=0; BackupFiles[i] ; i++) {

        HandleBootFilesWorker_NEC98(
            LocalBackupDirectory,
            SystemDir,
            BackupFiles[i],
            TRUE
            );
        }

        //
        // Delete tmp files.
        //
        for(i=0; BackupFiles2[i] ; i++) {

            HandleBootFilesWorker_NEC98(
                NULL,
                SystemDir,
                BackupFiles2[i],
                FALSE
            );
        }
    } else {
        if (CreateDirectory(LocalBackupDirectory, NULL))
        for (i = 0; BackupFiles[i] ; i++) {
            HandleBootFilesWorker_NEC98(SystemDir,
                                        LocalBackupDirectory,
                                        BackupFiles[i],
                                        TRUE);
        }
    }
    return(TRUE);
}


BOOL
HandleBootFilesWorker_NEC98(
    IN TCHAR *SourceDir,
    IN TCHAR *DestDir,
    IN PTSTR  File,
    IN BOOL   Flag
    )
{
    TCHAR SourceFile[MAX_PATH];
    TCHAR TargetFile[MAX_PATH];
    DWORD OldAttributes;

    if ((!DestDir) || ((!SourceDir)&&Flag)) {
        return(FALSE);
    }

    lstrcpy(TargetFile, DestDir);
    lstrcat(TargetFile, File);

    if (SourceDir) {
        lstrcpy(SourceFile, SourceDir);
        lstrcat(SourceFile, File);
    }

    if (Flag) {
        OldAttributes = GetFileAttributes(TargetFile);
        SetFileAttributes(TargetFile,FILE_ATTRIBUTE_NORMAL);
        if (!CopyFile(SourceFile,TargetFile,FALSE)) {
            Sleep(500);
            if (!CopyFile(SourceFile,TargetFile,FALSE)) {
                return(FALSE);
            }
        }
        if (OldAttributes != (DWORD)(-1)) {
            SetFileAttributes(TargetFile,OldAttributes & ~FILE_ATTRIBUTE_COMPRESSED);
        }
    } else {
        SetFileAttributes(TargetFile,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(TargetFile);
    }

    return(TRUE);

}


BOOL
PatchTextIntoBootCode(
    VOID
    )
{
    BOOLEAN b;
    CHAR Missing[100];
    CHAR DiskErr[100];
    CHAR PressKey[100];

    if(LoadStringA(hInst,IDS_BOOTMSG_FAT_NTLDR_MISSING,Missing,sizeof(Missing))
    && LoadStringA(hInst,IDS_BOOTMSG_FAT_DISKERROR,DiskErr,sizeof(DiskErr))
    && LoadStringA(hInst,IDS_BOOTMSG_FAT_PRESSKEY,PressKey,sizeof(PressKey))) {

        CharToOemA(Missing,Missing);
        CharToOemA(DiskErr,DiskErr);
        CharToOemA(PressKey,PressKey);

        if(b = PatchMessagesIntoFatBootCode(FatBootCode,FALSE,Missing,DiskErr,PressKey)) {
            b = PatchMessagesIntoFatBootCode(Fat32BootCode,TRUE,Missing,DiskErr,PressKey);
        }
    } else {
        b = FALSE;
    }

    return((BOOL)b);
}

LONG
CalcHiddenSector(
    IN TCHAR DriveLetter,
    IN SHORT Bps
    )
{
    TCHAR HardDiskName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    PARTITION_INFORMATION partition_info;
    DWORD DataSize;

    if (!ISNT()){
        return(CalcHiddenSector95(DriveLetter));
    } else {
        HardDiskName[4] = DriveLetter;
        hDisk = CreateFileW((const unsigned short *)HardDiskName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
            );
        if(hDisk == INVALID_HANDLE_VALUE) {
            return 0L;
        }
        DeviceIoControl(hDisk,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL,
                        0,
                        &partition_info,
                        sizeof(PARTITION_INFORMATION),
                        &DataSize,
                        NULL);
        CloseHandle(hDisk);
        return(LONG)(partition_info.StartingOffset.QuadPart / Bps);
    }
}

LONG
CalcHiddenSector95(
    IN TCHAR DriveLetter
    )
{
#define WINNT_WIN95HLP_GET1STSECTOR_W L"GetFirstSectorNo32"
#define WINNT_WIN95HLP_GET1STSECTOR_A "GetFirstSectorNo32"
#define NEC98_DLL_NAME_W            L"98PTN32.DLL"
#define NEC98_DLL_NAME_A            "98PTN32.DLL"
#ifdef UNICODE
#define WINNT_WIN95HLP_GET1STSECTOR WINNT_WIN95HLP_GET1STSECTOR_W
#define NEC98_DLL_NAME  NEC98_DLL_NAME_W
#else
#define WINNT_WIN95HLP_GET1STSECTOR WINNT_WIN95HLP_GET1STSECTOR_A
#define NEC98_DLL_NAME  NEC98_DLL_NAME_A
#endif

typedef DWORD (CALLBACK WINNT32_PLUGIN_WIN95_GET1STSECTOR_PROTOTYPE)(int, WORD);
typedef WINNT32_PLUGIN_WIN95_GET1STSECTOR_PROTOTYPE * PWINNT32_PLUGIN_WIN95_GET1STSECTOR;


    TCHAR ModuleName[MAX_PATH], *p;
    HINSTANCE Pc98ModuleHandle;
    PWINNT32_PLUGIN_WIN95_GET1STSECTOR Get1stSector;
    LONG NumSectors = 0;    // indicates failure

    if(!GetModuleFileName (NULL, ModuleName, MAX_PATH) || 
        (!(p=_tcsrchr(ModuleName, TEXT('\\')))) ) {    
        
        return 0;
    }
    
    *p= 0;
    ConcatenatePaths (ModuleName, NEC98_DLL_NAME, MAX_PATH);

    //
    // Load library
    //
    Pc98ModuleHandle = LoadLibraryEx(
                            ModuleName,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH
                            );

    if (Pc98ModuleHandle) {
        //
        // Get entry point
        //
        Get1stSector= (PWINNT32_PLUGIN_WIN95_GET1STSECTOR)
                        GetProcAddress (Pc98ModuleHandle,
                            (const char *)WINNT_WIN95HLP_GET1STSECTOR);
                              
        if (Get1stSector) {
            //
            // the second parameter must be 0.
            // if 0 is returned, it indicates the function failed.
            //
            NumSectors = (LONG)Get1stSector((int)DriveLetter, (WORD)0);
        }
        
        FreeLibrary(Pc98ModuleHandle);
    }        
    
    return NumSectors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\amd64\drvlettr.c ===
#include "precomp.h"

#define NUMDRIVELETTERS      26

// drvletter struct.
typedef struct _DRIVELETTERS {

    BOOL    ExistsOnSystem[NUMDRIVELETTERS];
    DWORD   Type[NUMDRIVELETTERS];              // Returned from GetDriveType
    TCHAR   IdentifierString[NUMDRIVELETTERS][MAX_PATH];  // Varies by Drive type.

} DRIVELETTERS, *PDRIVELETTERS;

DRIVELETTERS g_DriveLetters;

PCTSTR DriveTypeAsString(
    IN UINT Type
    )
{
    static PCTSTR driveTypeStrings[] = {
        TEXT("DRIVE_UNKNOWN"),        //The drive type cannot be determined.
        TEXT("DRIVE_NO_ROOT_DIR"),    //The root directory does not exist.
        TEXT("DRIVE_REMOVABLE"),      //The disk can be removed from the drive.
        TEXT("DRIVE_FIXED"),          //The disk cannot be removed from the drive.
        TEXT("DRIVE_REMOTE"),         //The drive is a remote (network) drive.
        TEXT("DRIVE_CDROM"),          //The drive is a CD-ROM drive.
        TEXT("DRIVE_RAMDISK"),        //The drive is a RAM disk.
    };

    return driveTypeStrings[Type];
}

BOOL
InitializeDriveLetterStructure (
    VOID
    )
{
    DWORD DriveLettersOnSystem = GetLogicalDrives();
    BYTE  bitPosition;
    DWORD maxBitPosition = NUMDRIVELETTERS;
    TCHAR rootPath[4];
    BOOL  driveExists;
    UINT  type;
    BOOL  rf = TRUE;


    //
    //rootPath[0] will be set to the drive letter of interest.
    //
    rootPath[1] = TEXT(':');
    rootPath[2] = TEXT('\\');
    rootPath[3] = TEXT('\0');

    //
    // GetLogicalDrives returns a bitmask of all of the drive letters
    // in use on the system. (i.e. bit position 0 is turned on if there is
    // an 'A' drive, 1 is turned on if there is a 'B' drive, etc.
    // This loop will use this bitmask to fill in the global drive
    // letters structure with information about what drive letters
    // are available and what there drive types are.
    //

    for (bitPosition = 0; bitPosition < maxBitPosition; bitPosition++) {

        //
        // Initialize the entry to safe values.
        //
        g_DriveLetters.Type[bitPosition]                   = 0;
        g_DriveLetters.ExistsOnSystem[bitPosition]         = FALSE;
        *g_DriveLetters.IdentifierString[bitPosition]      = 0;

        //
        // Now, determine if there is a drive in this spot.
        //
        driveExists = DriveLettersOnSystem & (1 << bitPosition);

        if (driveExists) {

            //
            // There is. Now, see if it is one that we care about.
            //
            *rootPath = bitPosition + TEXT('A');
            type = GetDriveType(rootPath);

            if (type == DRIVE_FIXED     ||
                type == DRIVE_REMOVABLE ||
                type == DRIVE_CDROM) {

                //
                // This is a drive that we are interested in.
                //
                g_DriveLetters.ExistsOnSystem[bitPosition]  = driveExists;
                g_DriveLetters.Type[bitPosition]            = type;

                //
                // Identifier String is not filled in this function.
                //
            }
        }
    }


    return rf;
}

VOID
CleanUpHardDriveTags (
    VOID
    )
{
    //
    // User cancelled. We need to clean up the tag files
    // that were created for drive migration.
    //
    UINT i;
    TCHAR  path[MAX_PATH];

    lstrcpy(path,TEXT("*:\\"));
    lstrcat(path,TEXT(WINNT_WIN95UPG_DRVLTR_A));


    for (i = 0; i < NUMDRIVELETTERS; i++) {

        if (g_DriveLetters.ExistsOnSystem[i] &&
            g_DriveLetters.Type[i] == DRIVE_FIXED) {

            *path = (TCHAR) i + TEXT('A');
            DeleteFile (path);
        }
    }
}


BOOL
GatherHardDriveInformation (
    VOID
    )
{
    BOOL        rf = TRUE;
    DWORD       index;
    HANDLE      signatureFile;
    TCHAR       signatureFilePath[MAX_PATH * 2];
    DWORD       signatureFilePathLength;
    DWORD       bytesWritten;

    //
    // Hard drive information is actually written to a special signature file
    // on the root directory of each fixed hard drive. The information is nothing special --
    // just the drive number (0 = A, etc.)
    //

    lstrcpy(signatureFilePath,TEXT("*:\\"));
    lstrcat(signatureFilePath,TEXT(WINNT_WIN95UPG_DRVLTR_A));
    signatureFilePathLength = lstrlen(signatureFilePath);



    for (index = 0; index < NUMDRIVELETTERS; index++) {

        if (g_DriveLetters.ExistsOnSystem[index] &&
            g_DriveLetters.Type[index] == DRIVE_FIXED) {

            *signatureFilePath = (TCHAR) index + TEXT('A');

            signatureFile = CreateFile(
                signatureFilePath,
                GENERIC_WRITE | GENERIC_READ,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

            if (signatureFile != INVALID_HANDLE_VALUE) {

                WriteFile (signatureFile, &index, sizeof(DWORD), &bytesWritten, NULL);



                CloseHandle (signatureFile);
                SetFileAttributes (signatureFilePath, FILE_ATTRIBUTE_HIDDEN);


            }
        }
    }


    return rf;
}


BOOL
GatherCdRomDriveInformation (
    VOID
    )

{
    BOOL   rf = TRUE;
    HKEY   scsiKey = NULL;
    HKEY   deviceKey = NULL;

    TCHAR  classData[25];
    DWORD  classDataSize = 25;

    TCHAR  targetData[5];
    DWORD  targetDataSize = 5;

    TCHAR  lunData[5];
    DWORD  lunDataSize = 5;

    TCHAR  driveLetterData[5];
    DWORD  driveLetterSize = 5;

    TCHAR  buffer [4096];
    DWORD  subKeyLength;
    DWORD  tempLength;

    HKEY   locationKey = NULL;
    PTSTR  locationName;

    DWORD  outerIndex;
    DWORD  enumReturn;

    DWORD  port;
    DWORD  unusedType;
    DWORD  error;




    //
    // Walk the SCSI tree looking for CD rom devices.
    //
    error = RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("ENUM\\SCSI"), 0, KEY_READ, &scsiKey);

    if (error) {

        return TRUE;
    }

    //
    // Gather information about the key in preparation for enumerating
    // it.
    //
    error = RegQueryInfoKey (
        scsiKey,
        NULL,                   // Don't care about the class.
        NULL,                   // class size.
        NULL,                   // reserved.
        NULL,                   // Don't care about the number of subkeys.
        &subKeyLength,
        NULL,                   // Don't care about subclasses.
        NULL,                   // Don't care about values.
        NULL,                   // Don't care about max value name length.
        NULL,                   // Don't care about max component.
        NULL,                   // Don't care about the security descriptor.
        NULL                    // Don't care about the last write time.
        );

    if (error) {
        //
        // This should really not happen.
        //
        return FALSE;
    }



    //
    // Succssesfully opened a key to HKLM\Enum\SCSI. Enumerate it.
    //
    outerIndex = 0;
    do {

        if (locationKey) {

            RegCloseKey (locationKey);
            locationKey = NULL;
        }
        if (deviceKey) {

            RegCloseKey (deviceKey);
            deviceKey = NULL;
        }


        tempLength = sizeof(buffer) / sizeof(TCHAR);

        enumReturn = RegEnumKeyEx (
            scsiKey,
            outerIndex,
            buffer,
            &tempLength,
            0,                // Reserved
            NULL,             // Class name - not necessary.
            NULL,             // size of class name buffer.
            NULL
            );

        outerIndex++;

        //
        // For each returned key, look up the "Class" value.
        //
        error = RegOpenKeyEx (scsiKey,buffer,0,KEY_READ,&deviceKey);
        if (error) {

            //
            // Something is hosed. Give up on collecting SCSI data.
            //
            rf = FALSE;
            break;
        }


        //
        // The port has to be decoded from the key one level
        // below.
        //
        tempLength = sizeof (buffer);

        error = RegEnumKeyEx (
            deviceKey,
            0,
            buffer,
            &tempLength,
            0,                // Reserved
            NULL,             // Class name - not necessary.
            NULL,             // size of class name buffer.
            NULL
            );


        error = RegOpenKeyEx (deviceKey, buffer, 0, KEY_READ, &locationKey);

        if (error) {

            //
            // This should really never happen. However, guard against it.
            // Its not serious enough to abort the search. Just skip this
            // particular key and continue.
            //
            continue;
        }



        tempLength = classDataSize;
        error = RegQueryValueEx(
            locationKey,
            TEXT("CLASS"),
            0,
            &unusedType,
            (PBYTE) classData,
            &tempLength
            );

        if (error) {

            //
            // This isn't a serious enough error to bring down the whole
            // enumeration. Just note it in the logs and continue to the
            // next key.
            //
            continue;
        }

        if (!lstrcmpi(classData, TEXT("CDROM"))) {


            lstrcpy (targetData, TEXT("-1"));
            lstrcpy (lunData, TEXT("-1"));
            lstrcpy (driveLetterData, TEXT("%"));

            //
            // Found a CdRom. Get the information that will be used in
            // textmode setup to identify the drive.
            //
            tempLength = targetDataSize;
            RegQueryValueEx(
                locationKey,
                TEXT("ScsiTargetId"),
                0,
                &unusedType,
                (PBYTE) targetData,
                &tempLength
                );

            tempLength = lunDataSize;
            RegQueryValueEx(
                locationKey,
                TEXT("ScsiLun"),
                0,
                &unusedType,
                (PBYTE) lunData,
                &tempLength
                );

            tempLength = driveLetterSize;
            RegQueryValueEx(
                locationKey,
                TEXT("CurrentDriveLetterAssignment"),
                0,
                &unusedType,
                (PBYTE) driveLetterData,
                &tempLength
                );




            if (*driveLetterData != TEXT('%')) {

                //
                // At this point, we have all of the information
                // necessary to write a SCSI CdRom identifier
                // string.
                //

                wsprintf(g_DriveLetters.IdentifierString[*driveLetterData - TEXT('A')], TEXT("%u^%s^%s"), 0, targetData, lunData);


            }

        }

        if (locationKey) {

            RegCloseKey (locationKey);
            locationKey = NULL;
        }
        if (deviceKey) {

            RegCloseKey (deviceKey);
            deviceKey = NULL;
        }



    } while (rf && enumReturn == ERROR_SUCCESS);

    if (locationKey) {
        RegCloseKey(locationKey);
        locationKey = NULL;
    }
    if (deviceKey) {
        RegCloseKey(deviceKey);
        deviceKey = NULL;
    }
    if (scsiKey) {
        RegCloseKey(scsiKey);
        scsiKey = NULL;
    }



    return rf;
}




BOOL
WriteInfoToSifFile (
    IN PCTSTR FileName
    )
{
    BOOL    rSuccess = TRUE;
    DWORD   index;
    TCHAR   dataString[MAX_PATH * 2]; // Well over the size needed.
    TCHAR   driveString[20]; // Well over the size needed.
    PCTSTR  sectionString = WINNT_D_WIN9XDRIVES;




    for (index = 0; index < NUMDRIVELETTERS; index++) {

        if (g_DriveLetters.ExistsOnSystem[index]) {

            wsprintf(
                driveString,
                TEXT("%u"),
                index
                );

            wsprintf(
                dataString,
                TEXT("%u,%s"),
                g_DriveLetters.Type[index],
                g_DriveLetters.IdentifierString[index]
                );

            //
            // Ending string looks like <drive num>,<drive type>,<identifier string>
            //

            WritePrivateProfileString (sectionString, driveString, dataString, FileName);
        }

    }


    return rSuccess;
}



DWORD
SaveDriveLetterInformation (
    IN PCTSTR FileName
    )
{
    BOOL rf = TRUE;

    if (InitializeDriveLetterStructure ()) {

        GatherHardDriveInformation ();
        GatherCdRomDriveInformation ();
        WriteInfoToSifFile (FileName);

    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\amd64\sectorio.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sectorio.c

Abstract:

    Routines to perform low-level sector I/O on either Windows NT or
    Windows 95.

Author:

    Ted Miller (tedm) 1 Nov 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Define structures for use with Win9x VWIN32.
// Note: alignment must be on 1-byte boundaries for these structures.
//
#include <pshpack1.h>

typedef struct _DIOC_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS;

typedef struct _DIOC_DISKIO {
    DWORD  StartSector;
    WORD   SectorCount;
    LPBYTE Buffer;
} DIOC_DISKIO;

#include <poppack.h>

//
// Local prot type
//
BOOL
NEC98_SpecialReadOrWriteNT(
    IN     TCHAR  Drive,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    );


//
// Define codes we care about for use with VWIN32
//
#define VWIN32_DIOC_DOS_IOCTL           1
#define VWIN32_DIOC_DOS_INT25           2
#define VWIN32_DIOC_DOS_INT26           3
#define VWIN32_DIOC_DOS_DRIVEINFO       6       // new in OSR2


BOOL
ReadOrWriteSectorsWin9xOriginal(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    earlier than OSR2. Uses int25/26.

    This routine will fail on Windows NT.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = (DWORD)(TOUPPER(Drive) - TEXT('A'));
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            Write ? VWIN32_DIOC_DOS_INT26 : VWIN32_DIOC_DOS_INT25,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return(b);
}


BOOL
ReadOrWriteSectorsWin9xOsr2(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    OSR2 or later. Uses the new int21 function 7305 (Ext_ABSDiskReadWrite).

    This routine will fail on Windows NT and earlier versions of Windows 95.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = 0x7305;
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;
    RegistersIn.reg_EDX = (DWORD)(TOUPPER(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_ESI = Write ? 1 : 0;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_DRIVEINFO,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return(b);
}


BOOL
LockOrUnlockVolumeWin9x(
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive,
    IN UINT   Level,
    IN BOOL   Lock
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;
    BOOL Pass;

    Pass = 0;

retry:
    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440d;

    //
    // bl = 1-based drive number
    // bh = lock level
    //
    RegistersIn.reg_EBX = (DWORD)(TOUPPER(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_EBX |= (Level << 8);

    //
    // cl = lock or unlock volume code
    // ch = categoey, 8 on original Win95, 0x48 on OSR2
    //
    RegistersIn.reg_ECX = Lock ? 0x4a : 0x6a;
    RegistersIn.reg_ECX |= ((ISOSR2() && !Pass) ? 0x4800 : 0x800);

    //
    // dx = permissions
    //
    // bit 0 controls write operations (0 = disallowed)
    // bit 1 controls read operations  (0 = allowed)
    //
    RegistersIn.reg_EDX = 1;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    //
    // If OSR2, try form of call with 8 in ch instead of 48.
    //
    if(!b && ISOSR2() && !Pass) {
        Pass = 1;
        goto retry;
    }

    return(b);
}


BOOL
ReadOrWriteSectorsWin9x(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95.
    This routine will fail on Windows NT. After opening the VWIN32
    VxD, the routine determines whether to use the original algorithm
    or the OSR2 algorithm, and calls the appropriate worker routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set to something meaningful.

--*/

{
    HANDLE hVxd;
    BOOL b;
    DWORD d;

    //
    // Open VWIN32.VXD
    //
    hVxd = CreateFileA(
                "\\\\.\\VWIN32",
                Write ? GENERIC_WRITE : GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hVxd == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c0;
    }

    //
    // Take out locks. We'll be as unrestrictive as possible.
    // The locking stuff is really funky. You have to pass in all kinds of
    // different parameters in OSR2 for reasons unknown. Also the
    // permissions bits are strangely encoded.
    //
    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,1,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c1;
    }

    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,2,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c2;
    }

    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,3,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c3;
    }

    //
    // Go do it.
    //
    b = ISOSR2()
      ? ReadOrWriteSectorsWin9xOsr2(hVxd,Drive,StartSector,SectorCount,Buffer,Write)
      : ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);
      
    //
    // If it failed, and OSR2 routine is being used, fall back to Win95 API.  This is a workaround
    // for Compaq because they ship OSR2 without the new OSR2 sector API support!
    //
    
    if (!b && ISOSR2()) {
        b = ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);
    }

    d = GetLastError();

    LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
c3:
    LockOrUnlockVolumeWin9x(hVxd,Drive,2,FALSE);
c2:
    LockOrUnlockVolumeWin9x(hVxd,Drive,1,FALSE);
c1:
    CloseHandle(hVxd);
c0:                 

    SetLastError(d);
    return(b);
}


BOOL
ReadOrWriteSectorsWinNt(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN     UINT   SectorSize,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows NT.
    This routine will fail on Win9x.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. This buffer must be aligned on a sector boundary.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set.

--*/

{
    HANDLE h;
    BOOL b;
    DWORD BytesXferred;
    TCHAR DeviceName[7];
    LONGLONG Offset;
    LONG OffsetHigh;
    DWORD d;

    if (IsNEC98() && (StartSector == 0) && (SectorCount == 1)){
	return(NEC98_SpecialReadOrWriteNT(Drive, Buffer, Write));
    }

    //
    // Open the device
    //
    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);
    h = CreateFile(
            DeviceName,
            Write ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c0;
    }

    Offset = (LONGLONG)StartSector * (LONGLONG)SectorSize;
    OffsetHigh = (LONG)(Offset >> 32);

    //
    // We're passing in a 64-bit offset so we have to check last error
    // to distinguish the error case.
    //
    if((SetFilePointer(h,(DWORD)Offset,&OffsetHigh,FILE_BEGIN) == 0xffffffff)
    && (GetLastError() != NO_ERROR)) {

        d = GetLastError();
        b = FALSE;
        goto c1;
    }

    b = Write
      ? WriteFile(h,Buffer,SectorCount*SectorSize,&BytesXferred,NULL)
      : ReadFile(h,Buffer,SectorCount*SectorSize,&BytesXferred,NULL);

    d = GetLastError();

c1:
    CloseHandle(h);
c0:
    SetLastError(d);
    return(b);
}


BOOL
ReadOrWriteSectors(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN     UINT   SectorSize,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk. Allocates a properly
    aligned buffer and decides whether to call NT- or Win9x-specific
    i/o routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. There are no alignment requirements on ths buffer.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    Last error is undisturbed from the operation that caused any failure.

--*/

{
    LPBYTE AlignedBuffer;
    LPBYTE p;
    BOOL b;
    DWORD d;

    //
    // Allocate a buffer we will align on a sector boundary.
    //
    if(AlignedBuffer = MALLOC((SectorCount * SectorSize) + (SectorSize - 1))) {

        if(d = (DWORD)AlignedBuffer % SectorSize) {
            p = (PUCHAR)((DWORD)AlignedBuffer + (SectorSize - d));
        } else {
            p = AlignedBuffer;
        }

        if(Write) {
            CopyMemory(p,Buffer,SectorCount*SectorSize);
        }

        b = ISNT()
          ? ReadOrWriteSectorsWinNt(Drive,StartSector,SectorCount,SectorSize,p,Write)
          : ReadOrWriteSectorsWin9x(Drive,StartSector,SectorCount,p,Write);

        d = GetLastError();

        if(b && !Write) {
            CopyMemory(Buffer,p,SectorCount*SectorSize);
        }

        FREE(AlignedBuffer);

    } else {
        b = FALSE;
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(d);
    return(b);
}


BOOL
ReadDiskSectors(
    IN  TCHAR  Drive,
    IN  UINT   StartSector,
    IN  UINT   SectorCount,
    IN  UINT   SectorSize,
    OUT LPBYTE Buffer
    )

/*++

Routine Description:

    Read a set of disk sectors off a disk device.

Arguments:

    Drive - supplies drive letter of device to be read from.

    StartSector - supplies logical sector number of first sector to be read.

    SectorCount - supplies number of sectors to be read.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from.

    Buffer - if successful, receives data from the disk. There are no
        alignment requirements on ths buffer.

Return Value:

    Boolean value indicating whether the disk was read successfully.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,FALSE));
}


BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    )

/*++

Routine Description:

    Write data to a set of disk sectors.

Arguments:

    Drive - supplies drive letter of device to be written to.

    StartSector - supplies logical sector number of first sector to be written.

    SectorCount - supplies number of sectors to be written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be written to.

    Buffer - supplies data to be written. There are no alignment requirements
        on ths buffer.

Return Value:

    Boolean value indicating whether the disk was successfully written.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,TRUE));
}


MEDIA_TYPE
GetMediaTypeNt(
    IN TCHAR Drive
    )

/*++

Routine Description:

    Determine the type/form-factor of a given (floppy) drive.

    THIS ROUTINE WORKS ONLY ON WINDOWS NT.

Arguments:

    Drive - supplies drive letter of the drive in question.

Return Value:

    Value from the MEDIA_TYPE enum indicating the drive type, which is
    derived from the largest media that the device driver indicates the
    drive can support.

    LastError is not set or preserved.

--*/

{
    TCHAR DeviceName[7];
    HANDLE h;
    BOOL b;
    BYTE Buffer[5000];
    DWORD Size;
    DWORD d;
    UINT u;
    PDISK_GEOMETRY Geometry;
    MEDIA_TYPE MediaTypeOrder[] = { FixedMedia,             // Fixed hard disk media
                                    RemovableMedia,         // Removable media other than floppy
                                    F3_120M_512,            // 3.5", 120M Floppy
                                    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
                                    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
                                    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
                                    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
                                    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
                                    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
                                    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
                                    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
                                    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
                                    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
                                    Unknown,                // Format is unknown
                                    -1
                                  };



    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);

    h = CreateFile(
            DeviceName,
            FILE_READ_ATTRIBUTES,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        return(Unknown);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_MEDIA_TYPES,
            NULL,
            0,
            Buffer,
            sizeof(Buffer),
            &Size,
            NULL
            );

    CloseHandle(h);

    if(!b) {
        return(Unknown);
    }

    Geometry = (PDISK_GEOMETRY)Buffer;

    //
    // Inefficient, but it works.
    //
    for(u=0; MediaTypeOrder[u] != -1; u++) {
        for(d=0; d<Size/sizeof(DISK_GEOMETRY); d++) {
            if(Geometry[d].MediaType == MediaTypeOrder[u]) {
                return(Geometry[d].MediaType);
            }
        }
    }

    //
    // We don't know what it is; assume it's some hot new type.
    //
    return(Size ? Geometry[0].MediaType : Unknown);
}


MEDIA_TYPE
GetMediaTypeWin9x(
    IN TCHAR Drive
    )

/*++

Routine Description:

    Determine the type/form-factor of a given (floppy) drive.

    THIS ROUTINE WORKS ONLY ON WINDOWS 9x.

Arguments:

    Drive - supplies drive letter of the drive in question.

Return Value:

    Value from the MEDIA_TYPE enum indicating the drive type, which is
    derived from the device type in the recommended BPB returned by
    the device driver for the drive.

    LastError is not set or preserved.

--*/

{
    HANDLE hVxd;
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;
    MEDIA_TYPE type;

    #include <pshpack1.h>
    struct {
        BYTE SpecialFunctions;
        BYTE DeviceType;
        WORD DeviceAttributes;
        WORD CylinderCount;
        BYTE MediaType;
        WORD BytesPerSector;
        BYTE SectorsPerCluster;
        WORD ReservedSectors;
        BYTE FatCount;
        WORD RootDirEntries;
        WORD SectorCount;
        BYTE MediaDescriptor;
        WORD SectorsPerFat;
        WORD SectorsPerTrack;
        WORD Heads;
        DWORD HiddenSectors;
        DWORD LargeSectorCount;
    } DeviceParams;
    #include <poppack.h>

    //
    // Open VWIN32.VXD
    //
    hVxd = CreateFileA(
                "\\\\.\\VWIN32",
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hVxd == INVALID_HANDLE_VALUE) {
        return(Unknown);
    }

    //
    // Set up registers for IOCTL call.
    //
    RegistersIn.reg_EAX = 0x440d;                   // IOCTL
    RegistersIn.reg_EBX = (Drive - TEXT('A')) + 1;  // 1-based drive in bl
    RegistersIn.reg_ECX = 0x860;                    // category = 8, func = get device params
    RegistersIn.reg_EDX = (DWORD)&DeviceParams;

    DeviceParams.SpecialFunctions = 0;

    b = DeviceIoControl(
            hVxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    CloseHandle(hVxd);

    if(!b && !(RegistersOut.reg_Flags & 1)) {
        return(Unknown);
    }

    switch(DeviceParams.DeviceType) {
    case 0:
        type = F5_360_512;      // close enough
        break;

    case 1:
        type = F5_1Pt2_512;
        break;

    case 2:
        type = F3_720_512;
        break;

    case 5:
        type = FixedMedia;
        break;

    case 7:
        type = F3_1Pt44_512;
        break;

    case 8:
        type = RemovableMedia;
        break;

    case 9:
        type = F3_2Pt88_512;
        break;

    default:
        type = Unknown;
        break;
    }

    return(type);
}


MEDIA_TYPE
GetMediaType(
    IN TCHAR Drive
    )
{
    return(ISNT() ? GetMediaTypeNt(Drive) : GetMediaTypeWin9x(Drive));
}

BOOL
NEC98_SpecialReadOrWriteNT(
    IN     TCHAR  Drive,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )
/*++

Routine Description:

    NEC98 specialn routine to boot sctor read or write sectors on a disk
    under Windows NT.
    This routine will fail on Win9x.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. This buffer must be aligned on a sector boundary.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set.

--*/

{
    TCHAR DrivePath[4];
    DWORD DontCare;
    DWORD SectorSize;
    HANDLE h;
    BOOL b;
    DWORD BytesXferred;
    TCHAR DeviceName[7];
    LONG OffsetHigh = 0;
    DWORD d;
    LPBYTE AlignedBuffer;
    LPBYTE p;

    //
    // Form root path
    //
    DrivePath[0] = Drive;
    DrivePath[1] = TEXT(':');
    DrivePath[2] = TEXT('\\');
    DrivePath[3] = 0;

    GetDiskFreeSpace(DrivePath,&DontCare,&SectorSize,&DontCare,&DontCare);
    if(AlignedBuffer = MALLOC(SectorSize + SectorSize - 1)) {

        if(d = (DWORD)AlignedBuffer % SectorSize) {
            p = (PUCHAR)((DWORD)AlignedBuffer + (SectorSize - d));
        } else {
            p = AlignedBuffer;
        }
    } else {
        b = FALSE;
        d = ERROR_NOT_ENOUGH_MEMORY;
	    goto c0;
    }
    //
    // Open the device
    //
    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);
    h = CreateFile(
            DeviceName,
            Write ? (GENERIC_WRITE | GENERIC_READ) : GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c1;
    }
    if (b = ReadFile(h, p, SectorSize, &BytesXferred, NULL)){
    	if (Write){
    	    CopyMemory(p, Buffer, 512);
    	    SetFilePointer(h,(DWORD)0, &OffsetHigh,FILE_BEGIN);
    	    b = WriteFile(h, p, SectorSize, &BytesXferred,NULL);
    	} else { // read
    	    CopyMemory(Buffer, p, 512);
    	}
    }
    d = GetLastError();

    CloseHandle(h);
c1:  
    FREE(AlignedBuffer);
c0:
    SetLastError(d);
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\amd64\protect.c ===
#include "precomp.h"
#include <tlhelp32.h>

#ifndef MYASSERT
#define MYASSERT(x)
#endif


typedef HANDLE (WINAPI * CREATETOOLHELP32SNAPSHOT)(DWORD Flags, DWORD ProcessId);
typedef BOOL (WINAPI * MODULE32FIRST)(HANDLE Snapshot, LPMODULEENTRY32 lpme);
typedef BOOL (WINAPI * MODULE32NEXT)(HANDLE Snapshot, LPMODULEENTRY32 lpme);


BOOL
pIsLegalPage (
    IN      DWORD Protect
    )
{
    //
    // Page must be actually in memory to protect it, and it
    // cannot be any type of write-copy.
    //

    if ((Protect & PAGE_GUARD) ||
        (Protect == PAGE_NOACCESS) ||
        (Protect == PAGE_WRITECOPY) ||
        (Protect == PAGE_EXECUTE_WRITECOPY)
        ) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pIsKnownSection (
    IN      const IMAGE_SECTION_HEADER *Section,
    IN      const IMAGE_NT_HEADERS *NtHeaders
    )
{
    //
    // Return TRUE if section is code or code data
    //

    if (Section->Characteristics & (IMAGE_SCN_MEM_EXECUTE|
                                    IMAGE_SCN_MEM_DISCARDABLE|
                                    IMAGE_SCN_MEM_WRITE|
                                    IMAGE_SCN_MEM_READ)
        ) {
        return TRUE;
    }

    //
    // Return TRUE if section is resources
    //

    if (NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress ==
        Section->VirtualAddress
        ) {
        return TRUE;
    }

    //
    // Unknown section
    //

    return FALSE;
}


VOID
pPutRegionInSwapFile (
    IN      PVOID Address,
    IN      DWORD Size
    )
{
    MEMORY_BASIC_INFORMATION mbi;
    DWORD PageSize;
    PVOID EndPtr;
    PVOID RegionEnd;
    DWORD d;
    DWORD OldPermissions;
    volatile DWORD *v;
    SYSTEM_INFO si;

    //
    // Get system virtual page size
    //

    GetSystemInfo(&si);
    PageSize = si.dwPageSize;

    //
    // Compute the pointer to the end of the region
    //

    EndPtr = (PBYTE) Address + Size;

    //
    // For each page in the region, mark it as e/r/w, modify it, and restore the permissions
    //

    while (Address < EndPtr) {

        d = VirtualQuery (Address, &mbi, sizeof(mbi));

        if (d == sizeof(mbi)) {

            //
            // We assume the module wasn't loaded with one of the following
            // conditions (which break as a result of VirtualProtect)
            //

            RegionEnd = (PBYTE) mbi.BaseAddress + mbi.RegionSize;

            if (RegionEnd > EndPtr) {
                RegionEnd = EndPtr;
            }

            if (mbi.State == MEM_COMMIT && pIsLegalPage (mbi.Protect)) {

                //
                // Switch to e/r/w
                //

                if (VirtualProtect (
                        mbi.BaseAddress,
                        (PBYTE) RegionEnd - (PBYTE) mbi.BaseAddress,
                        PAGE_EXECUTE_READWRITE,
                        &OldPermissions
                        )) {

                    //
                    // Touch every page in the region.
                    //

                    for (Address = mbi.BaseAddress; Address < RegionEnd ; Address = (PBYTE) Address + PageSize) {
                        v = Address;
                        *v = *v;
                    }

                    //
                    // Switch back
                    //

                    VirtualProtect (
                        mbi.BaseAddress,
                        (PBYTE) RegionEnd - (PBYTE) mbi.BaseAddress,
                        OldPermissions,
                        &d
                        );
                }
            }

            Address = RegionEnd;

        } else {
            MYASSERT (FALSE);
            break;
        }
    }
}


VOID
pProtectModule (
    HANDLE Module
    )
{
    TCHAR Path[MAX_PATH];
    BOOL IsNetDrive;
    const IMAGE_DOS_HEADER *DosHeader;
    const IMAGE_NT_HEADERS *NtHeaders;
    const IMAGE_SECTION_HEADER *SectHeader;
    UINT u;

    
    IsNetDrive = FALSE;

    //
    // Get module info
    //

    if( GetModuleFileName (Module, Path, MAX_PATH) ){

        //
        // Determine if the module is running on the net
        //
    
        
        if (Path[0] == TEXT('\\')) {
            IsNetDrive = TRUE;
        } else if (GetDriveType (Path) == DRIVE_REMOTE) {
            IsNetDrive = TRUE;
        }

    }
    

    if (!IsNetDrive) {
        return;
    }

    //
    // Enumerate all sections in the PE header
    //

    DosHeader = (const IMAGE_DOS_HEADER *) Module;
    NtHeaders = (const IMAGE_NT_HEADERS *) ((PBYTE) Module + DosHeader->e_lfanew);

    for (u = 0 ; u < NtHeaders->FileHeader.NumberOfSections ; u++) {
        SectHeader = IMAGE_FIRST_SECTION (NtHeaders) + u;

        if (pIsKnownSection (SectHeader, NtHeaders)) {
            pPutRegionInSwapFile (
                (PBYTE) Module + SectHeader->VirtualAddress,
                SectHeader->Misc.VirtualSize
                );
        }
    }
}


VOID
ProtectAllModules (
    VOID
    )
{
    HANDLE Library;
    HANDLE Snapshot;
    MODULEENTRY32 me32;
    CREATETOOLHELP32SNAPSHOT fnCreateToolhelp32Snapshot;
    MODULE32FIRST fnModule32First;
    MODULE32NEXT fnModule32Next;

    //
    // Load toohelp dynamically (for NT 4, NT 3.51 compatibility)
    //

    Library = LoadLibrary (TEXT("toolhelp.dll"));
    if (!Library) {
        return;
    }

    (FARPROC) fnCreateToolhelp32Snapshot = GetProcAddress (Library, "CreateToolhelp32Snapshot");
    (FARPROC) fnModule32First = GetProcAddress (Library, "Module32First");
    (FARPROC) fnModule32Next = GetProcAddress (Library, "Module32Next");

    if (!fnCreateToolhelp32Snapshot || !fnModule32First || !fnModule32Next) {
        FreeLibrary (Library);
        return;
    }

    //
    // Protect each loaded module
    //

    Snapshot = fnCreateToolhelp32Snapshot (TH32CS_SNAPMODULE, 0);
    MYASSERT (Snapshot != INVALID_HANDLE_VALUE);

    if (Snapshot == INVALID_HANDLE_VALUE) {
        return;
    }

    me32.dwSize = sizeof (me32);
    if (fnModule32First (Snapshot, &me32)) {
        do {
            pProtectModule (me32.hModule);
        } while (fnModule32Next (Snapshot, &me32));
    }

    //
    // Done
    //

    CloseHandle (Snapshot);

    FreeLibrary (Library);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\ansi\precomp.h ===
#include "winnt32.h"
#include "msg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\i386\protect.c ===
#include "precomp.h"
#include <tlhelp32.h>

#ifndef MYASSERT
#define MYASSERT(x)
#endif


typedef HANDLE (WINAPI * CREATETOOLHELP32SNAPSHOT)(DWORD Flags, DWORD ProcessId);
typedef BOOL (WINAPI * MODULE32FIRST)(HANDLE Snapshot, LPMODULEENTRY32 lpme);
typedef BOOL (WINAPI * MODULE32NEXT)(HANDLE Snapshot, LPMODULEENTRY32 lpme);


BOOL
pIsLegalPage (
    IN      DWORD Protect
    )
{
    //
    // Page must be actually in memory to protect it, and it
    // cannot be any type of write-copy.
    //

    if ((Protect & PAGE_GUARD) ||
        (Protect == PAGE_NOACCESS) ||
        (Protect == PAGE_WRITECOPY) ||
        (Protect == PAGE_EXECUTE_WRITECOPY)
        ) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pIsKnownSection (
    IN      const IMAGE_SECTION_HEADER *Section,
    IN      const IMAGE_NT_HEADERS *NtHeaders
    )
{
    //
    // Return TRUE if section is code or code data
    //

    if (Section->Characteristics & (IMAGE_SCN_MEM_EXECUTE|
                                    IMAGE_SCN_MEM_DISCARDABLE|
                                    IMAGE_SCN_MEM_WRITE|
                                    IMAGE_SCN_MEM_READ)
        ) {
        return TRUE;
    }

    //
    // Return TRUE if section is resources
    //

    if (NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress ==
        Section->VirtualAddress
        ) {
        return TRUE;
    }

    //
    // Unknown section
    //

    return FALSE;
}


VOID
pPutRegionInSwapFile (
    IN      PVOID Address,
    IN      DWORD Size
    )
{
    MEMORY_BASIC_INFORMATION mbi;
    DWORD PageSize;
    PVOID EndPtr;
    PVOID RegionEnd;
    DWORD d;
    DWORD OldPermissions;
    volatile DWORD *v;
    SYSTEM_INFO si;

    //
    // Get system virtual page size
    //

    GetSystemInfo(&si);
    PageSize = si.dwPageSize;

    //
    // Compute the pointer to the end of the region
    //

    EndPtr = (PBYTE) Address + Size;

    //
    // For each page in the region, mark it as e/r/w, modify it, and restore the permissions
    //

    while (Address < EndPtr) {

        d = VirtualQuery (Address, &mbi, sizeof(mbi));

        if (d == sizeof(mbi)) {

            //
            // We assume the module wasn't loaded with one of the following
            // conditions (which break as a result of VirtualProtect)
            //

            RegionEnd = (PBYTE) mbi.BaseAddress + mbi.RegionSize;

            if (RegionEnd > EndPtr) {
                RegionEnd = EndPtr;
            }

            if (mbi.State == MEM_COMMIT && pIsLegalPage (mbi.Protect)) {

                //
                // Switch to e/r/w
                //

                if (VirtualProtect (
                        mbi.BaseAddress,
                        (PBYTE) RegionEnd - (PBYTE) mbi.BaseAddress,
                        PAGE_EXECUTE_READWRITE,
                        &OldPermissions
                        )) {

                    //
                    // Touch every page in the region.
                    //

                    for (Address = mbi.BaseAddress; Address < RegionEnd ; Address = (PBYTE) Address + PageSize) {
                        v = Address;
                        *v = *v;
                    }

                    //
                    // Switch back
                    //

                    VirtualProtect (
                        mbi.BaseAddress,
                        (PBYTE) RegionEnd - (PBYTE) mbi.BaseAddress,
                        OldPermissions,
                        &d
                        );
                }
            }

            Address = RegionEnd;

        } else {
            MYASSERT (FALSE);
            break;
        }
    }
}


VOID
pProtectModule (
    HANDLE Module
    )
{
    TCHAR Path[MAX_PATH];
    BOOL IsNetDrive;
    const IMAGE_DOS_HEADER *DosHeader;
    const IMAGE_NT_HEADERS *NtHeaders;
    const IMAGE_SECTION_HEADER *SectHeader;
    UINT u;

    
    IsNetDrive = FALSE;

    //
    // Get module info
    //

    if( GetModuleFileName (Module, Path, MAX_PATH) ){

        //
        // Determine if the module is running on the net
        //
    
        
        if (Path[0] == TEXT('\\')) {
            IsNetDrive = TRUE;
        } else if (GetDriveType (Path) == DRIVE_REMOTE) {
            IsNetDrive = TRUE;
        }

    }
    

    if (!IsNetDrive) {
        return;
    }

    //
    // Enumerate all sections in the PE header
    //

    DosHeader = (const IMAGE_DOS_HEADER *) Module;
    NtHeaders = (const IMAGE_NT_HEADERS *) ((PBYTE) Module + DosHeader->e_lfanew);

    for (u = 0 ; u < NtHeaders->FileHeader.NumberOfSections ; u++) {
        SectHeader = IMAGE_FIRST_SECTION (NtHeaders) + u;

        if (pIsKnownSection (SectHeader, NtHeaders)) {
            pPutRegionInSwapFile (
                (PBYTE) Module + SectHeader->VirtualAddress,
                SectHeader->Misc.VirtualSize
                );
        }
    }
}


VOID
ProtectAllModules (
    VOID
    )
{
    HANDLE Library;
    HANDLE Snapshot;
    MODULEENTRY32 me32;
    CREATETOOLHELP32SNAPSHOT fnCreateToolhelp32Snapshot;
    MODULE32FIRST fnModule32First;
    MODULE32NEXT fnModule32Next;

    //
    // Load toohelp dynamically (for NT 4, NT 3.51 compatibility)
    //

    Library = LoadLibrary (TEXT("toolhelp.dll"));
    if (!Library) {
        return;
    }

    (FARPROC) fnCreateToolhelp32Snapshot = GetProcAddress (Library, "CreateToolhelp32Snapshot");
    (FARPROC) fnModule32First = GetProcAddress (Library, "Module32First");
    (FARPROC) fnModule32Next = GetProcAddress (Library, "Module32Next");

    if (!fnCreateToolhelp32Snapshot || !fnModule32First || !fnModule32Next) {
        FreeLibrary (Library);
        return;
    }

    //
    // Protect each loaded module
    //

    Snapshot = fnCreateToolhelp32Snapshot (TH32CS_SNAPMODULE, 0);
    MYASSERT (Snapshot != INVALID_HANDLE_VALUE);

    if (Snapshot == INVALID_HANDLE_VALUE) {
        return;
    }

    me32.dwSize = sizeof (me32);
    if (fnModule32First (Snapshot, &me32)) {
        do {
            pProtectModule (me32.hModule);
        } while (fnModule32Next (Snapshot, &me32));
    }

    //
    // Done
    //

    CloseHandle (Snapshot);

    FreeLibrary (Library);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\amd64\syspart.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN  CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Command-line param that allows someone to force a particular drive
// to be the system partition. Useful in certain preinstall scenarios.
//
TCHAR ForcedSystemPartition;

#define WINNT_DONT_MATCH_PARTITION 0
#define WINNT_MATCH_PARTITION_NUMBER  1
#define WINNT_MATCH_PARTITION_STARTING_OFFSET  2

#define BUFFERSIZE 1024

//
// NT-specific routines we use from ntdll.dll and kernel32.dll
//
//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenSymLinkRoutine)(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerSymLinkRoutine)(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerDirRoutine) (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenDirRoutine) (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//WINBASEAPI
HANDLE
(WINAPI *FindFirstVolume) (
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

//WINBASEAPI
BOOL
(WINAPI *FindNextVolume)(
    HANDLE hFindVolume,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

//WINBASEAPI
BOOL
(WINAPI *FindVolumeClose)(
    HANDLE hFindVolume
    );

//WINBASEAPI
BOOL
(WINAPI *GetVolumeNameForVolumeMountPoint)(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
);

DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
);

BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
);


DWORD
GetNT4SystemPartition(
    IN  LPTSTR Signature,
    OUT LPTSTR SysPart
);










BOOL
ArcPathToNtPath(
    IN  LPCTSTR ArcPath,
    OUT LPTSTR  NtPath,
    IN  UINT    NtPathBufferLen
    )
{
    WCHAR arcPath[256];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    WCHAR Buffer[512];

    PWSTR ntPath;

    lstrcpyW(arcPath,L"\\ArcName\\");
#ifdef UNICODE
    lstrcpynW(arcPath+9,ArcPath,(sizeof(arcPath)/sizeof(WCHAR))-9);
#else
    MultiByteToWideChar(
        CP_ACP,
        0,
        ArcPath,
        -1,
        arcPath+9,
        (sizeof(arcPath)/sizeof(WCHAR))-9
        );
#endif

    UnicodeString.Buffer = arcPath;
    UnicodeString.Length = lstrlenW(arcPath)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = (*NtOpenSymLinkRoutine)(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer)-sizeof(WCHAR);

        Status = (*NtQuerSymLinkRoutine)(ObjectHandle,&UnicodeString,NULL);

        CloseHandle(ObjectHandle);

        if(NT_SUCCESS(Status)) {

            Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

#ifdef UNICODE
            lstrcpyn(NtPath,Buffer,NtPathBufferLen);
#else
            WideCharToMultiByte(CP_ACP,0,Buffer,-1,NtPath,NtPathBufferLen,NULL,NULL);
#endif

            return(TRUE);
        }
    }

    return(FALSE);
}


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN TCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    UINT i;
    DWORD d;

    LPTSTR BootFiles[] = { TEXT("BOOT.INI"),
                           TEXT("NTLDR"),
                           TEXT("NTDETECT.COM"),
                           NULL
                         };

    TCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether all NT boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,TEXT("%c:\\%s"),Drive,BootFiles[i]);

        d = GetFileAttributes(FileName);
        if(d == (DWORD)(-1)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


DWORD
QueryHardDiskNumber(
    IN  TCHAR   DriveLetter
    )

{
    TCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = DriveLetter;
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFile(driveName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return (DWORD) -1;
    }

    b = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);
    CloseHandle(h);

    if (!b) {
        return (DWORD) -1;
    }

    return number.DeviceNumber;
}


BOOL
MarkPartitionActive(
    IN TCHAR DriveLetter
    )
{
    DWORD       DriveNum;
    TCHAR       DosName[7];
    TCHAR       Name[MAX_PATH];
    DISK_GEOMETRY DiskGeom;
    PARTITION_INFORMATION PartitionInfo;
    HANDLE      h;
    BOOL        b;
    DWORD       Bytes;
    PUCHAR      UnalignedBuffer,Buffer;
    unsigned    i;
    BOOL Rewrite;
    BOOL FoundIt;

    //
    // This concept is n/a for PC98 and the stuff below
    // won't work on Win9x.
    //
    if(IsNEC98() || !ISNT()) {
        return(TRUE);
    }

    //
    // Get geometry info and partition info for this drive.
    // We get geometry info because we need the bytes per sector info.
    //
    wsprintf(DosName,TEXT("\\\\.\\%c:"),DriveLetter);

    h = CreateFile(
            DosName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_DRIVE_GEOMETRY,
            NULL,
            0,
            &DiskGeom,
            sizeof(DISK_GEOMETRY),
            &Bytes,
            NULL
            );

    if(!b || (DiskGeom.BytesPerSector < 512)) {
        CloseHandle(h);
        return(FALSE);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            &PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &Bytes,
            NULL
            );

    CloseHandle(h);
    if(!b) {
        return(FALSE);
    }

    //
    // Figure out which physical drive this partition is on.
    //
    DriveNum = QueryHardDiskNumber(DriveLetter);
    if(DriveNum == (DWORD)(-1)) {
        //
        // Have to do it the old-fashioned way. Convert to an NT path
        // and parse the result.
        //
        if(!QueryDosDevice(DosName+4,Name,MAX_PATH)) {
            return(FALSE);
        }

        if( _tcsnicmp( Name, TEXT("\\device\\harddisk"), 16 )) {
            //
            // We have no idea what this name represents. Punt.
            //
            return(FALSE);
        }

        DriveNum = _tcstoul(Name+16,NULL,10);
    }

    //
    // Allocate a buffer and align it.
    //
    UnalignedBuffer = MALLOC(2*DiskGeom.BytesPerSector);
    if(!UnalignedBuffer) {
        return(FALSE);
    }

    Buffer = (PVOID)(((DWORD)UnalignedBuffer + (DiskGeom.BytesPerSector - 1)) & ~(DiskGeom.BytesPerSector - 1));

    //
    // Now we open up the physical drive and read the partition table.
    // We try to locate the partition by matching start offsets.
    // Note that active status is only meaningful for primary partitions.
    //
    wsprintf(Name,TEXT("\\\\.\\PhysicalDrive%u"),DriveNum);

    h = CreateFile(
            Name,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        FREE(UnalignedBuffer);
        return(FALSE);
    }

    if(!ReadFile(h,Buffer,DiskGeom.BytesPerSector,&Bytes,NULL)) {
        FREE(UnalignedBuffer);
        CloseHandle(h);
        return(FALSE);
    }

    Rewrite = FALSE;
    FoundIt = FALSE;
    for(i=0; i<4; i++) {

        if(*(DWORD *)(Buffer + 0x1be + 8 + (i*16))
        == (DWORD)(PartitionInfo.StartingOffset.QuadPart / DiskGeom.BytesPerSector)) {

            FoundIt = TRUE;
            if(Buffer[0x1be+(i*16)] != 0x80) {
                //
                // Not already active, or active for some other bios unit #,
                // so we need to whack it.
                //
                Buffer[0x1be+(i*16)] = 0x80;
                Rewrite = TRUE;
            }
        } else {
            if(Buffer[0x1be+(i*16)]) {
                //
                // Not inactive, and needs to be, so whack it.
                //
                Buffer[0x1be+(i*16)] = 0;
                Rewrite = TRUE;
            }
        }
    }

    if(FoundIt) {
        if(Rewrite) {

            Bytes = 0;
            if(SetFilePointer(h,0,&Bytes,FILE_BEGIN) || Bytes) {
                b = FALSE;
            } else {
                b = WriteFile(h,Buffer,DiskGeom.BytesPerSector,&Bytes,NULL);
            }
        } else {
            b = TRUE;
        }
    } else {
        b = FALSE;
    }

    CloseHandle(h);
    FREE(UnalignedBuffer);
    return(b);
}


BOOL
x86DetermineSystemPartition(
    IN  HWND   ParentWindow,
    OUT PTCHAR SysPartDrive
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    On Win95, we always return C:. For NT, read on.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    With there being differences in the IO system mapping and introduction of Volumes for NT 50
    this has now become complicated. Listed below are the algorithms
    
    
    NT 5.0 Beta 2 and above :
    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Go Through all of the volumes in the system with FindFirstVolume/FindNextVolume/FindVolumeClose.
        3. Take off the trailing backslash to the name returne to get \\?\Volume{guid}.
        4. IOCTL_STORAGE_GET_DEVICE_NUMBER with \\?\Volume{guid} => Check for FILE_DEVICE_DISK. Remember the partition number. Goto 6
        5. If IOCTL_STORAGE_GET_DEVICE_NUMBER fails then use IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS which returns a list of harddisks.  
           For each harddisk remember the starting offset and goto 6.
        6. Check Harddisk # by using \\.\PhysicalDrive# with IOCTL_DISK_GET_DRIVE_LAYOUT.  If the signature matches then this is the disk we boot from.
        7. To find the partition that we boot from we look for boot indicator. If we used 2 we try to match the partition number stored in 6 
           else if 3 we try to match the starting offset.Then you have a \\?\Volume{guid}\ name for the SYSTEM volume. 
        8. Call GetVolumeNameForVolumeMountPoint with A:\, B:\, C:\, ... and check the result of the form \\?\Volume{guid}\ against your match 
           to see what the drive letter is.
           
           Important: Since the *Volume* APIs are post Beta2 we do dynamic loading of kernel32.dll based on the build number returned.

    Versions below NT 5.0 Beta 2
                                                                                                                                    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Enumerate the \?? directory and look for all entries that begin with PhysicalDrive#. 
	    3. For each of the Disks look for a match with the signature above and if they match then find out the partition number used to boot 
           using IOCTL_DISK_GET_DRIVE_LAYOUT and the BootIndicator bit.
	    4. On finding the Boot partition create a name of the form \Device\Harddisk#\Partition#
	    5. Then go through c:,d:...,z: calling QueryDosDeviceName and look for a match. That would be your system partition drive letter

    
    
Arguments:

    ParentWindow - supplies window handle for window to be the parent for
        any dialogs, etc.

    SysPartDrive - if successful, receives drive letter of system partition.

Return Value:

    Boolean value indicating whether SysPartDrive has been filled in.
    If FALSE, the user will have been infomred about why.

--*/

{
    TCHAR DriveName[4];
    BOOL  GotIt=FALSE;
    TCHAR Buffer[512];
    TCHAR Drive;
    BOOL b;
    TCHAR SysPartSig[20], PartitionNum[MAX_PATH], SysVolGuid[MAX_PATH];
    TCHAR DriveVolGuid[MAX_PATH];
    


    if(ForcedSystemPartition) {
        //
        // NT5 for NEC98 can't boot up from ATA Card and 
        // removable drive. We need check dive type.
        //
        if (IsNEC98() &&
            ((MyGetDriveType(ForcedSystemPartition) != DRIVE_FIXED) ||
             // Drive is not Fixed.
             !IsValidDrive(ForcedSystemPartition))){
            // HD format type is not NEC98.
            return(FALSE);
        }
        *SysPartDrive = ForcedSystemPartition;
        return(TRUE);
    }

    if(IsNEC98()) {
        if(!MyGetWindowsDirectory(Buffer,sizeof(Buffer)/sizeof(TCHAR)))
            return FALSE;
        *SysPartDrive = Buffer[0];
        return(TRUE);
    }

    if(!ISNT()) {
        *SysPartDrive = TEXT('C');
        return(TRUE);
    }


    // Code for NT starts here
        
    //Get signature from registry - Step 1 listed above
    
    if( (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\EisaAdapter"),SysPartSig) != ERROR_SUCCESS )
        && (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\MultiFunctionAdapter"),SysPartSig) != ERROR_SUCCESS ) ){  
        GotIt = FALSE;
        goto c0;
    }

    
    if( ISNT() && (BUILDNUM() >= 1877) ){
    
        //Get the SystemVolumeGUID - steps 2 through 7 listed above ( Beta 2 and after )

        if( GetSystemVolumeGUID( SysPartSig, SysVolGuid ) != ERROR_SUCCESS ){  
            GotIt = FALSE;
            goto c0;
        }


    
    
    }else{

        if( GetNT4SystemPartition( SysPartSig, PartitionNum )  != ERROR_SUCCESS){
            GotIt = FALSE;
            goto c0;
        }

    }


    DriveName[1] = TEXT(':');
    
    // 
    //  Enumerate all drive letters and compare their device names
    //

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {

        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

            DriveName[0] = Drive;

            if( BUILDNUM() >= 1877){ //Versions Beta2 and after
                DriveName[2] = '\\';
                DriveName[3] = 0;

                if((*GetVolumeNameForVolumeMountPoint)((LPWSTR)DriveName, (LPWSTR)DriveVolGuid, MAX_PATH*sizeof(TCHAR))){
                    if(!lstrcmp(DriveVolGuid, SysVolGuid) ){
                        GotIt = TRUE;       // Found it
                        break;
                    }


                }


            }else{
                DriveName[2] = 0;
                if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {
    
                    if( !lstrcmpi(Buffer, PartitionNum) ) {
                        GotIt = TRUE;       // Found it
                        break;
                    }
                }
            }//Versions earlier than Beta 2
        }
    }

    
    // This helps for some builds ~1500 < buildnum < 1877 that are in a tough spot

    if(!GotIt) {
        //
        // Strange case, just assume C:
        //
        GotIt = TRUE;
        Drive = TEXT('C');
    }


c0:
    if(GotIt) {
        *SysPartDrive = Drive;
#if defined(REMOTE_BOOT)
    } else if (RemoteBoot) {
        GotIt = TRUE;
        *SysPartDrive = TEXT('C');
#endif
    }
    return(GotIt);
}


DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
)

/*++

Routine Description:

    This routine enumerates all the volumes and if successful returns the \\?\Volume{guid} name for the system partition.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    SysVolGuid - If successful, will contain a name of form \\?\Volume{guid} for the System Partition (the one we use to boot)

Return Value:

    Returns NO_ERROR if successful, otherwise it contains the error code.
    

--*/
{

    HANDLE hVolume, h;
    TCHAR VolumeName[MAX_PATH];
    PTSTR q;
    TCHAR driveName[30];
    BOOL b,ret, DoExtent, MatchFound;
    STORAGE_DEVICE_NUMBER   number;
    DWORD Err,cnt;
    PVOLUME_DISK_EXTENTS Extent;
    PDISK_EXTENT Start, i;
    DWORD ExtentSize, bytes;
    PVOID p;
    ULONG PartitionNumToCompare;
    LARGE_INTEGER StartingOffToCompare;
    DWORD ioctlCode;

    Err = NO_ERROR;

    //Enuberate all volumes

    hVolume = (*FindFirstVolume)( (LPWSTR)VolumeName, MAX_PATH );
    if( hVolume == INVALID_HANDLE_VALUE ){
        return GetLastError();
    }

    MatchFound = FALSE;

    do{

        //Remove trailing backslash

        DoExtent = FALSE;
            
        if( q=_tcsrchr( VolumeName,TEXT('\\')) ){
            *q = 0;
        }else{
            continue;
        }


        //Open the volume

        h = CreateFile(VolumeName, GENERIC_READ, FILE_SHARE_READ |
                       FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            continue; // Move on to next volume
        }

        //Get the disk number

        ret = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);

        if( !ret ){
            
            // Try using IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS if the above failed

            Extent = MALLOC(1024);
            ExtentSize = 1024;
            if(!Extent) {
                CloseHandle( h );
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            
            

            ioctlCode = IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS;
retry:
        
            ret = DeviceIoControl( h, ioctlCode,
                    NULL,0,(PVOID)Extent,ExtentSize,&bytes,NULL);
        
            if(!ret) {
        
                if((Err=GetLastError()) == ERROR_MORE_DATA) {
        
                    ExtentSize += 1024;
                    if(p = REALLOC((PVOID)Extent, ExtentSize)) {
                        (PVOID)Extent = p;
                    } else {
                        CloseHandle( h );
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto cleanup;
                    }
                    goto retry;
                } else {
                    if (ioctlCode == IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS) {
                        ioctlCode = IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN;
                        goto retry;
                    }
                    CloseHandle( h );
                    continue;
                }
            }else{
                DoExtent = TRUE;
            }

        }
        
        // Done with the handle this time around

        CloseHandle( h );

        if( !DoExtent ){

             //
            //  Check to see if this is a disk and not CDROM etc.
            //

            if( number.DeviceType == FILE_DEVICE_DISK ){
                
                // Remember the partition number
                PartitionNumToCompare = number.PartitionNumber;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), number.DeviceNumber );


                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&PartitionNumToCompare, WINNT_MATCH_PARTITION_NUMBER  ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
                
            }
            // Move on ..
            continue;
            
        }else{
            // Go through all disks and try for match

            Start = Extent->Extents;
            cnt = 0;      
            for( i = Start; cnt < Extent->NumberOfDiskExtents; i++ ){
                cnt++;
                // Remember the starting offset
                StartingOffToCompare = i->StartingOffset;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), i->DiskNumber );
                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&StartingOffToCompare, WINNT_MATCH_PARTITION_STARTING_OFFSET ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
            }
            
        }
        
        if( MatchFound )
            break;
        

    }while( (*FindNextVolume)( hVolume, (LPWSTR)VolumeName, MAX_PATH ));


cleanup:

    if( hVolume != INVALID_HANDLE_VALUE )
        (*FindVolumeClose)( hVolume );

    return Err;



}



BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
)
/*++

Routine Description:

    This routine compares the given disk signature with the one for the specified physical disk.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    DriveName -  Physical Drive name of the form \\.\PhysicalDrive#
    
    Compare   -  A pointer to a storage variable. The type depends on the value of Action
    
    Action    -  Should be one of the following
                
                WINNT_DONT_MATCH_PARTITION - Once disk signatures match it returns the boot partition number in Compare. Compare should be a PULONG.
                       
                WINNT_MATCH_PARTITION_NUMBER - Once disk signatures match it tries to match the boot partition number with the number passed in
                                               through Compare. Compare should be PULONG.
                
                WINNT_MATCH_PARTITION_STARTING_OFFSET - Once disk signatures match it tries to match the boot partition starting offset with the 
                                                        starting offset number passed in through Compare. Compare should be PLARGE_INTEGER.

Return Value:

    Returns TRUE if successful in getting a match.
    

--*/

{

    TCHAR temp[30];
    BOOL b,Found = FALSE;
    PLARGE_INTEGER Starting_Off;
    PPARTITION_INFORMATION Start, i;
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    DWORD DriveLayoutSize;
    DWORD cnt;
    DWORD DataSize;
    LPTSTR p;
    PULONG Disk_Num;
    ULONG Sig;
    


    if(!Compare )
        return FALSE;

    if ((Action != WINNT_DONT_MATCH_PARTITION) &&
        (Action != WINNT_MATCH_PARTITION_NUMBER) &&
        (Action != WINNT_MATCH_PARTITION_STARTING_OFFSET))
        return FALSE;

    if( (Action==WINNT_MATCH_PARTITION_STARTING_OFFSET) && Compare )
        Starting_Off = (PLARGE_INTEGER) Compare;
    else
        Disk_Num = (PULONG) Compare;
    




    // On any failure return FALSE



    //
    // Get drive layout info for this physical disk.
    // If we can't do this something is very wrong.
    //
    hDisk = CreateFile(
                DriveName,
                FILE_READ_ATTRIBUTES | FILE_READ_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    
    if(hDisk == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    //
    // Get partition information.
    //
    DriveLayout = MALLOC(1024);
    DriveLayoutSize = 1024;
    if(!DriveLayout) {
        goto cleanexit;
    }
    
    
retry:

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT,
            NULL,
            0,
            (PVOID)DriveLayout,
            DriveLayoutSize,
            &DataSize,
            NULL
            );

    if(!b) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            DriveLayoutSize += 1024;
            if(p = REALLOC((PVOID)DriveLayout,DriveLayoutSize)) {
                (PVOID)DriveLayout = p;
            } else {
                goto cleanexit;
            }
            goto retry;
        } else {
            goto cleanexit;
        }
    }else{

        // Now walk the Drive_Layout to find the boot partition
        
        Start = DriveLayout->PartitionEntry;
        cnt = 0;

        /*
        _ultot( DriveLayout->Signature, temp, 16 );
        if( lstrcmpi( temp, Signature ) )
            goto cleanexit;
        */

        Sig = _tcstoul( Signature, NULL, 16 ); 
        if( Sig != DriveLayout->Signature )
            goto cleanexit;

        for( i = Start; cnt < DriveLayout->PartitionCount; i++ ){
            cnt++;
            
            
            if( i->BootIndicator == TRUE ){
                if( Action == WINNT_DONT_MATCH_PARTITION ){
                    *Disk_Num = i->PartitionNumber;
                    Found = TRUE;
                    goto cleanexit;

                }


                if( Action == WINNT_MATCH_PARTITION_NUMBER ){
                    if( *Disk_Num == i->PartitionNumber ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }else{
                    if( Starting_Off->QuadPart == i->StartingOffset.QuadPart ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }
                
                break;
            }
            
        }



    }

cleanexit:

    if( hDisk != INVALID_HANDLE_VALUE )
        CloseHandle( hDisk );


    return Found;
}












DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
)
/*++

Routine Description:

    This routine fetches the disk signature for the first disk that the BIOS sees. This has to be the disk that we boot from on x86s.
    It is at location <AdapterKeyName>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier

Arguments:

    Signature -  If successful will contain the signature of the disk we boot off from in Hex.

Return Value:

    Returns ERROR_SUCCESS if successful, otherwise it contains the error code.
    

--*/
{

    DWORD Err, dwSize;
    HKEY hkey, BusKey, Controller, SystemDiskKey;
    int busnumber;
    TCHAR BusString[20], Identifier[100];



    Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        AdapterKeyName,
                        0,
                        KEY_READ,
                        &hkey );

    if( Err != ERROR_SUCCESS )
        return Err;

    
    // Start enumerating the buses

    for( busnumber=0; ;busnumber++){

        wsprintf( BusString, TEXT("%d"), busnumber );

        Err = RegOpenKeyEx( hkey,
                        BusString,
                        0,
                        KEY_READ,
                        &BusKey );

        

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( hkey );
            return Err;
        }
        
        Err = RegOpenKeyEx( BusKey,
                        TEXT("DiskController"),
                        0,
                        KEY_READ,
                        &Controller );

        
        RegCloseKey(BusKey);        // Not needed anymore

        
        if( Err != ERROR_SUCCESS )  // Move on to next bus
            continue;

        RegCloseKey( hkey );        // Not needed anymore

        Err = RegOpenKeyEx( Controller,
                        TEXT("0\\DiskPeripheral\\0"),
                        0,
                        KEY_READ,
                        &SystemDiskKey );

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( Controller );
            return Err;
        }

        RegCloseKey( Controller );  // Not needed anymore


        dwSize = sizeof(Identifier);
        Err = RegQueryValueEx( SystemDiskKey,
                               TEXT("Identifier"),
                               NULL,
                               NULL,
                               (PBYTE) Identifier,
                               &dwSize);

        if( Err != ERROR_SUCCESS  ){
            RegCloseKey( SystemDiskKey );
            return Err;
        }

        if( Identifier && (lstrlen(Identifier) > 9 ) ){
            lstrcpy( Signature,Identifier+9);
            *_tcsrchr( Signature,TEXT('-') ) = 0;
            RegCloseKey( SystemDiskKey );
            return ERROR_SUCCESS;
        }
        else{
            RegCloseKey( SystemDiskKey );
            return Err;
        }


         
    }

    // Should never get here


    RegCloseKey( hkey );
    
    return ERROR_PATH_NOT_FOUND;
    

}




BOOL
InitializeArcStuff(
    IN HWND Parent
    )
{
    HMODULE NtdllLib, Kernel32Lib;

    if(ISNT()) {
        //
        // On NT ntdll.dll had better be already loaded.
        //
        NtdllLib = LoadLibrary(TEXT("NTDLL"));
        if(!NtdllLib) {

            MessageBoxFromMessage(
                Parent,
                MSG_UNKNOWN_SYSTEM_ERROR,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                GetLastError()
                );

            return(FALSE);

        }

        (FARPROC)NtOpenSymLinkRoutine = GetProcAddress(NtdllLib,"NtOpenSymbolicLinkObject");
        (FARPROC)NtQuerSymLinkRoutine = GetProcAddress(NtdllLib,"NtQuerySymbolicLinkObject");
        (FARPROC)NtOpenDirRoutine = GetProcAddress(NtdllLib,"NtOpenDirectoryObject");
        (FARPROC)NtQuerDirRoutine = GetProcAddress(NtdllLib,"NtQueryDirectoryObject");

        

        if(!NtOpenSymLinkRoutine || !NtQuerSymLinkRoutine || !NtOpenDirRoutine || !NtQuerDirRoutine) {

            MessageBoxFromMessage(
                Parent,
                MSG_UNKNOWN_SYSTEM_ERROR,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                GetLastError()
                );

            FreeLibrary(NtdllLib);

            return(FALSE);
        }

        //
        // We don't need the extraneous handle any more.
        //
        FreeLibrary(NtdllLib);


        if(BUILDNUM() >= 1877){
            
            //Load the kernel32.dll stuff too

            Kernel32Lib = LoadLibrary(TEXT("KERNEL32"));
            if(!Kernel32Lib) {
    
                MessageBoxFromMessage(
                    Parent,
                    MSG_UNKNOWN_SYSTEM_ERROR,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    GetLastError()
                    );
    
                return(FALSE);

            }

            (FARPROC)FindFirstVolume = GetProcAddress(Kernel32Lib,"FindFirstVolumeW");
            (FARPROC)FindNextVolume = GetProcAddress(Kernel32Lib,"FindNextVolumeW");
            (FARPROC)FindVolumeClose = GetProcAddress(Kernel32Lib,"FindVolumeClose");
            (FARPROC)GetVolumeNameForVolumeMountPoint = GetProcAddress(Kernel32Lib,"GetVolumeNameForVolumeMountPointW");

            if(!FindFirstVolume || !FindNextVolume ) {

                MessageBoxFromMessage(
                    Parent,
                    MSG_UNKNOWN_SYSTEM_ERROR,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    GetLastError()
                    );
    
                FreeLibrary(Kernel32Lib);
    
                return(FALSE);
            }

            FreeLibrary(Kernel32Lib);


        }


    }
                  
    if(!x86DetermineSystemPartition(Parent,&SystemPartitionDriveLetter)) {

        MessageBoxFromMessage(
            Parent,
            MSG_SYSTEM_PARTITION_INVALID,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    SystemPartitionDriveLetters[0] = SystemPartitionDriveLetter;
    SystemPartitionDriveLetters[1] = 0;

    LocalBootDirectory[0] = SystemPartitionDriveLetter;
    LocalBootDirectory[1] = TEXT(':');
    LocalBootDirectory[2] = TEXT('\\');
    lstrcpy(LocalBootDirectory+3,LOCAL_BOOT_DIR);
    if(IsNEC98()) {
        LocalBackupDirectory[0] = SystemPartitionDriveLetter;
        LocalBackupDirectory[1] = TEXT(':');
        LocalBackupDirectory[2] = TEXT('\\');
        lstrcpy(LocalBackupDirectory+3,LOCAL_BACKUP_DIR);
    }

    return(TRUE);
}






DWORD
GetNT4SystemPartition(
    IN  LPTSTR Signature,
    OUT LPTSTR SysPart
)
/*++

Routine Description:

    This routine enumerates all the volumes and if successful returns the \Device\Harddisk#\Partition# name of the system partition
    on systems prior to NT 5 Beta 2.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    SysPart -  If successful, will contain a name of form \Device\Harddisk#\Partition# for the System Partition (the one we use to boot)

Return Value:

    Returns NO_ERROR if successful, otherwise it contains the error code.
    

--*/
{

    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    UCHAR DirInfoBuffer[ BUFFERSIZE ];
    TCHAR DirName[20];
    TCHAR ObjName[1024];
    TCHAR Buffer[1024];
    WCHAR pSignature[512];
    ULONG Context = 0;
    ULONG ReturnedLength, PartNum;
    LPTSTR Num_Str;
    
    
    RtlZeroMemory( DirInfoBuffer, BUFFERSIZE );

#ifdef UNICODE
    lstrcpyW( pSignature,Signature);
#else
    MultiByteToWideChar(
        CP_ACP,
        0,
        Signature,
        -1,
        pSignature,
        (sizeof(pSignature)/sizeof(WCHAR))
        );
    
#endif

    //We open the \?? Directory
    
    lstrcpy( DirName, TEXT("\\DosDevices") );
    
    
    UnicodeString.Buffer = (PWSTR)DirName;
    UnicodeString.Length = lstrlenW(UnicodeString.Buffer)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = (*NtOpenDirRoutine)( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (!NT_SUCCESS( Status ))
        return(Status);

    DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer;
    
    // Go through the directory looking for all instances beginning with PhysicalDrive#

    for (Status = (*NtQuerDirRoutine)( DirectoryHandle,
                                          DirInfoBuffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          TRUE,
                                          &Context,
                                          &ReturnedLength );
         NT_SUCCESS( Status );
         Status = (*NtQuerDirRoutine)( DirectoryHandle,
                                          DirInfoBuffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength ) ) {
    
    
        
        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status ) && (Status != STATUS_NO_MORE_ENTRIES))
            break;
        

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer[0];
        
        
        while( TRUE ){

            //
            //  Check if there is another record.  If there isn't, then get out
            //  of the loop now
            //

            if (DirInfo->Name.Length == 0) {
                break;
            }


            memmove( ObjName, DirInfo->Name.Buffer, DirInfo->Name.Length );
            ObjName[DirInfo->Name.Length/(sizeof(WCHAR))] = 0;

            if( _tcsstr(ObjName, TEXT("PhysicalDrive") )){

                Num_Str = ObjName+13;

                wsprintf(Buffer,TEXT("\\\\.\\%s"),ObjName);
                if( DoDiskSignaturesCompare( (LPCTSTR)pSignature, Buffer, &PartNum, WINNT_DONT_MATCH_PARTITION ) ){
                    wsprintf(SysPart,TEXT("\\Device\\Harddisk%s\\Partition%lu"),Num_Str, PartNum);
                    Status = ERROR_SUCCESS;
                    goto cleanup;

                }
            }

            

            //
            //  There is another record so advance DirInfo to the next entry
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                          sizeof( OBJECT_DIRECTORY_INFORMATION ) );




        }
        


        RtlZeroMemory( DirInfoBuffer, BUFFERSIZE );

        
    
    }

cleanup:
    CloseHandle( DirectoryHandle );
    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\i386\bootflop.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bootflop.c

Abstract:

    Routines to create setup boot floppies.

Author:

    Ted Miller (tedm) 21 November 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define bpb structure.
//
#include <pshpack1.h>
typedef struct _MY_BPB {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  FatCount;
    USHORT RootDirectoryEntries;
    USHORT SectorCountSmall;
    UCHAR  MediaDescriptor;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT HeadCount;
} MY_BPB, *PMY_BPB;
#include <poppack.h>



BOOL
pFloppyGetDiskInDrive(
    IN HWND    ParentWindow,
    IN LPCTSTR FloppyName,
    IN BOOL    SpecialFirstPrompt,
    IN BOOL    WriteNtBootSector,
    IN BOOL    MoveParamsFileToFloppy
    );



UINT
FloppyGetTotalFileCount(
    VOID
    )

/*++

Routine Description:

    Determine how many files total are to be copied to all boot floppies,
    based on count of lines in [FloppyFiles.x] sections in dosnet.inf.

Arguments:

    None.

Return Value:

    Count of files.

--*/

{
    TCHAR SectionName[100];
    UINT u;
    UINT Count;
    LONG l;

    Count = 0;
    for(u=0; u<FLOPPY_COUNT; u++) {

        wsprintf(SectionName,TEXT("FloppyFiles.%u"),u);

        l = InfGetSectionLineCount(MainInf,SectionName);
        if(l != -1) {
            Count += (UINT)l;
        }
    }

    return(Count);
}


DWORD
FloppyWorkerThread(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    Create setup boot floppies.

Arguments:

    Standard thread routine arguments.

Return Value:

    Nothing meaningful.

--*/

{
    TCHAR SectionName[100];
    TCHAR FloppyName[200];
    TCHAR Buffer[150];
    TCHAR SourceName[MAX_PATH];
    TCHAR TargetName[MAX_PATH];
    TCHAR CompressedSourceName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    LPCTSTR Directory;
    LPCTSTR p,q;
    LPTSTR r;
    UINT Floppy;
    LONG Count;
    LONG Line;
    DWORD d;
    HWND ParentWindow;
    BOOL FirstPrompt;
    BOOL TryCompressedFirst;

    ParentWindow = (HWND)ThreadParameter;
    FirstPrompt = TRUE;
    TryCompressedFirst = FALSE;

    //
    // Do the floppies backwards so the boot floppy is in the drive
    // when we're done.
    //
    for(Floppy=FLOPPY_COUNT; Floppy>0; Floppy--) {

        wsprintf(SectionName,TEXT("FloppyFiles.%u"),Floppy-1);

        //
        // Special case the name of the first floppy.
        //
        if(Floppy>1) {
            LoadString(
                hInst,
                Server ? IDS_FLOPPY_N_SRV : IDS_FLOPPY_N_WKS,
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR)
                );

            wsprintf(FloppyName,Buffer,Floppy);

        } else {
            LoadString(
                hInst,
                Server ? IDS_BOOTFLOP_SRV : IDS_BOOTFLOP_WKS,
                FloppyName,
                sizeof(FloppyName)/sizeof(TCHAR)
                );
        }

        //
        // Get the floppy in the drive.
        //
        if(!pFloppyGetDiskInDrive(ParentWindow,FloppyName,FirstPrompt,Floppy==1,Floppy==1)) {
            PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
            return(FALSE);
        }

        //
        //  Create the file that contains drive letter information (migrate.inf)
        //
        if((Floppy == 1) && ISNT()){
            if(!GetAndSaveNTFTInfo(ParentWindow)) {
                PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
                return(FALSE);
            }
        }

        FirstPrompt = FALSE;

        Count = InfGetSectionLineCount(MainInf,SectionName);
        if(Count == -1) {
            continue;
        }

        //
        // Do each file in the list for this floppy.
        // Since the target is a floppy, we don't bother with multithread copies,
        // all files come from source 0.
        //
        for(Line=0; Line<Count; Line++) {

            Directory = InfGetFieldByIndex(MainInf,SectionName,Line,0);
            p = InfGetFieldByIndex(MainInf,SectionName,Line,1);
            if(p && (Directory = InfGetFieldByKey(MainInf,TEXT("Directories"),Directory,0))) {

                lstrcpy(SourceName,SourcePaths[0]);
                ConcatenatePaths(SourceName,Directory,MAX_PATH);
                ConcatenatePaths(SourceName,p,MAX_PATH);

                q = InfGetFieldByIndex(MainInf,SectionName,Line,2);

                TargetName[0] = FirstFloppyDriveLetter;
                TargetName[1] = TEXT(':');
                TargetName[2] = 0;
                ConcatenatePaths(TargetName,q ? q : p,MAX_PATH);

                //
                // Create any subdirectory if necessary
                //
                if((r = _tcsrchr(TargetName,TEXT('\\'))) && ((r-TargetName) > 3)) {
                    *r = 0;
                    d = CreateMultiLevelDirectory(TargetName);
                    *r = TEXT('\\');
                } else {
                    d = NO_ERROR;
                }

                if(d == NO_ERROR) {

                    if(TryCompressedFirst) {

                        GenerateCompressedName(SourceName,CompressedSourceName);

                        FindHandle = FindFirstFile(CompressedSourceName,&FindData);

                        if(FindHandle != INVALID_HANDLE_VALUE) {
                            FindClose(FindHandle);
                            lstrcpy(SourceName,CompressedSourceName);
                            GenerateCompressedName(TargetName,FindData.cFileName);
                            lstrcpy(TargetName,FindData.cFileName);
                        } else {
                            FindHandle = FindFirstFile(SourceName,&FindData);
                            if(FindHandle != INVALID_HANDLE_VALUE) {
                                FindClose(FindHandle);
                                TryCompressedFirst = FALSE;
                            }
                        }
                    } else {

                        FindHandle = FindFirstFile(SourceName,&FindData);

                        if(FindHandle != INVALID_HANDLE_VALUE) {
                            FindClose(FindHandle);
                        } else {
                            GenerateCompressedName(SourceName,CompressedSourceName);
                            FindHandle = FindFirstFile(CompressedSourceName,&FindData);
                            if(FindHandle != INVALID_HANDLE_VALUE) {

                                FindClose(FindHandle);
                                lstrcpy(SourceName,CompressedSourceName);
                                GenerateCompressedName(TargetName,FindData.cFileName);
                                lstrcpy(TargetName,FindData.cFileName);
                            }
                        }
                    }

                    d = CopyFile(SourceName,TargetName,FALSE) ? NO_ERROR : GetLastError();

                    //
                    // Retry once to overcome transient net glitches.
                    //
                    if((d != NO_ERROR) && (d != ERROR_FILE_NOT_FOUND)
                    && (d != ERROR_PATH_NOT_FOUND) && (d != ERROR_WRITE_PROTECT)) {

                        Sleep(350);
                        d = CopyFile(SourceName,TargetName,FALSE) ? NO_ERROR : GetLastError();
                    }
                }

                if(d == NO_ERROR) {
                    //
                    // Tell main thread that another file is done.
                    //
                    SendMessage(ParentWindow,WMX_COPYPROGRESS,0,0);

                } else {

                    switch(FileCopyError(ParentWindow,SourceName,TargetName,d,FALSE)) {

                    case COPYERR_SKIP:
                        //
                        // Tell main thread that another file is done.
                        //
                        SendMessage(ParentWindow,WMX_COPYPROGRESS,0,0);
                        break;

                    case COPYERR_EXIT:
                        //
                        // We're outta here.
                        //
                        PropSheet_PressButton(GetParent(ParentWindow),PSBTN_CANCEL);
                        return(FALSE);
                        break;

                    case COPYERR_RETRY:
                        //
                        // Little hack to retry the current line.
                        //
                        Line--;
                        break;
                    }
                }
            }
        }

    }

    //
    // Send message indicating completion.
    //
    SendMessage(ParentWindow,WMX_COPYPROGRESS,0,1);
    return(TRUE);
}


BOOL
pFloppyGetDiskInDrive(
    IN HWND    ParentWindow,
    IN LPCTSTR FloppyName,
    IN BOOL    SpecialFirstPrompt,
    IN BOOL    WriteNtBootSector,
    IN BOOL    MoveParamsFileToFloppy
    )

/*++

Routine Description:

    This routine prompts the user to insert a floppy disk and verifies that
    the disk is blank, etc.

Arguments:

    ParentWindow - supplies the window handle of the window to be the
        owner/parent for ui that this routine will display.

    FloppyName - supplies human-readable name of the floppy, used in prompting.

    SpecialFirstPrompt - if TRUE then this routine assumes that a special prompt
        should be used, that is suitable to be the first prompt the user sees
        for any floppies.

    WriteNtBootSector - if TRUE then an NT boot sector is written to the disk.

Return Value:

    TRUE if the disk is in the drive. FALSE means the program should exit.

--*/

{
    int i;
    BOOL b;
    BYTE BootSector[512];
    BYTE NewBootSector[512];
    TCHAR SourceName[MAX_PATH];
    TCHAR TargetName[MAX_PATH];
    DWORD d;
    PMY_BPB p;
    DWORD spc,bps,freeclus,totclus;

    //
    // Issue the prompt.
    //
    reprompt:
    i = MessageBoxFromMessage(
            ParentWindow,
            SpecialFirstPrompt ? MSG_FIRST_FLOPPY_PROMPT : MSG_GENERIC_FLOPPY_PROMPT,
            FALSE,
            AppTitleStringId,
            MB_OKCANCEL | MB_ICONEXCLAMATION,
            FloppyName,
            FLOPPY_COUNT
            );

    if(i == IDCANCEL) {
        //
        // Confirm.
        //
        i = MessageBoxFromMessage(
                ParentWindow,
                MSG_SURE_EXIT,
                FALSE,
                AppTitleStringId,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2
                );

        if(i == IDYES) {
            Cancelled = TRUE;
            return(FALSE);
        }
        goto reprompt;
    }

    //
    // Inspect the floppy. Start by reading the boot sector off the disk.
    //
    b = ReadDiskSectors(FirstFloppyDriveLetter,0,1,512,BootSector);
    if(!b) {
        d = GetLastError();
        if((d == ERROR_SHARING_VIOLATION) || (d == ERROR_ACCESS_DENIED)) {
            //
            // Another app is using the drive.
            //
            MessageBoxFromMessage(
                ParentWindow,
                MSG_FLOPPY_BUSY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );
        } else {
            //
            // Read error -- assume no floppy is inserted or it's unformatted
            //
            MessageBoxFromMessage(
                ParentWindow,
                MSG_FLOPPY_BAD_FORMAT,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );
        }

        goto reprompt;
    }

    //
    // Sanity check on the boot sector. Note that on PC98 there is no
    // 55aa sig on a disk formatted by DOS5.0.
    //
    p = (PMY_BPB)&BootSector[11];
    if((BootSector[0] != 0xeb) || (BootSector[2] != 0x90)
    || (!IsNEC98() && ((BootSector[510] != 0x55) || (BootSector[511] != 0xaa)))
    || (p->BytesPerSector != 512)
    || ((p->SectorsPerCluster != 1) && (p->SectorsPerCluster != 2))     // 2.88M disks have 2 spc
    || (p->ReservedSectors != 1)
    || (p->FatCount != 2)
    || !p->SectorCountSmall                                             // <32M uses the 16-bit count
    || (p->MediaDescriptor != 0xf0)
    || (p->HeadCount != 2)
    || !p->RootDirectoryEntries) {

        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_BAD_FORMAT,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    //
    // Get the free space on the disk. Make sure it's blank, by which we mean
    // that is has as much free space on it as a 1.44MB floppy would usually have
    // immediately after formatting.
    //
    SourceName[0] = FirstFloppyDriveLetter;
    SourceName[1] = TEXT(':');
    SourceName[2] = TEXT('\\');
    SourceName[3] = 0;
    if(!GetDiskFreeSpace(SourceName,&spc,&bps,&freeclus,&totclus)) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_CANT_GET_SPACE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    if((freeclus * spc * bps) < 1457664) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_FLOPPY_NOT_BLANK,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto reprompt;
    }

    if(WriteNtBootSector) {
        extern BYTE FatBootCode[512];
        extern BYTE PC98FatBootCode[512];

        CopyMemory(NewBootSector,IsNEC98() ? PC98FatBootCode : FatBootCode,512);

        //
        // Copy the BPB we retreived for the disk into the bootcode template.
        // We only care about the original BPB fields, through the head count
        // field.  We will fill in the other fields ourselves.
        //
        strncpy(NewBootSector+3,"MSDOS5.0",8);
        CopyMemory(NewBootSector+11,BootSector+11,sizeof(MY_BPB));

        //
        // Set up other fields in the bootsector/BPB/xBPB.
        //
        // Large sector count (4 bytes)
        // Hidden sector count (4 bytes)
        // current head (1 byte, not necessary to set this, but what the heck)
        // physical disk# (1 byte)
        //
        ZeroMemory(NewBootSector+28,10);

        //
        // Extended BPB signature
        //
        NewBootSector[38] = 41;

        //
        // Serial number
        //
        *(DWORD UNALIGNED *)(NewBootSector+39) = ((GetTickCount() << 12)
                                               | ((GetTickCount() >> 4) & 0xfff));

        //
        // volume label/system id
        //
        strncpy(NewBootSector+43,"NO NAME    ",11);
        strncpy(NewBootSector+54,"FAT12   ",8);

        //
        // Overwrite the 'ntldr' string with 'setupldr.bin' so the right file gets
        // loaded when the floppy is booted.
        //
        for(i=499; i>0; --i) {
            if(!memcmp("NTLDR      ",NewBootSector+i,11)) {
                strncpy(NewBootSector+i,"SETUPLDRBIN",11);
                break;
            }
        }

        //
        // Write it out.
        //
        b = WriteDiskSectors(FirstFloppyDriveLetter,0,1,512,NewBootSector);
        if(!b) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_CANT_WRITE_FLOPPY,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );

            goto reprompt;
        }
    }

    if(MoveParamsFileToFloppy) {

        wsprintf(SourceName,TEXT("%c:\\%s"),SystemPartitionDriveLetter,WINNT_SIF_FILE);
        wsprintf(TargetName,TEXT("%c:\\%s"),FirstFloppyDriveLetter,WINNT_SIF_FILE);

        SetFileAttributes(TargetName,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(TargetName);
        if(!MoveFile(SourceName,TargetName)) {

            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_CANT_MOVE_FILE_TO_FLOPPY,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR,
                SystemPartitionDriveLetter,
                WINNT_SIF_FILE
                );

            goto reprompt;
        }
    }

    //
    // Floppy seems OK.
    //
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\i386\bootini.c ===
#include "precomp.h"
#pragma hdrstop

#include <bootfat.h>
#include <bootf32.h>
#include <boot98f.h>
#include <boot98f2.h>
#include <patchbc.h>

//
// Define name of file we use to contain the auxiliary boot sector.
//
#define AUX_BOOT_SECTOR_NAME_A    "BOOTSECT.DAT"
#define AUX_BOOT_SECTOR_NAME_W    L"BOOTSECT.DAT"
#ifdef UNICODE
#define AUX_BOOT_SECTOR_NAME      AUX_BOOT_SECTOR_NAME_W
#else
#define AUX_BOOT_SECTOR_NAME      AUX_BOOT_SECTOR_NAME_A
#endif


BOOL CleanUpBootCode;
DWORD CleanUpBootIni;


BOOL
HandleBootFilesWorker_NEC98(
    IN TCHAR *SourceDir,
    IN TCHAR *DestDir,
    IN PTSTR  File,
    IN BOOL   Flag
    );

LONG
CalcHiddenSector95(
    IN TCHAR DriveLetter
    );

BOOL
LoadBootIniString(
  IN HINSTANCE ModuleHandle,
  IN DWORD MsgId,
  OUT PSTR Buffer,
  IN DWORD Size
  );

//
//


BOOL
CheckSysPartAndReadBootCode(
    IN  HWND                        ParentWindow,
    OUT WINNT32_SYSPART_FILESYSTEM *Filesystem,
    OUT BYTE                        BootCode[WINNT32_MAX_BOOT_SIZE],
    OUT PUINT                       BootCodeSectorCount
    )
/*++

Routine Description:

    This routine does some inspection on the x86 system partition
    to determine its filesystem and sector size. We only support
    512-byte sectors, and there are code depedencies all over the place
    based on this.

    If the sector size is wrong or there's a filesystem we don't recognize
    then the user is informed.

Arguments:

    ParentWindow - supplies window handle of window to be used as
        parent/owner in case this routine puts up UI.

    Filesystem - if successful, receives the filesystem of the system partition.

    BootCode - if successful, receives a copy of the boot code currently
        on the disk.

    BootCodeSectorCount - if successful, receives the size in 512-byte sectors
        of the boot code area for the filesystem on the system partition.

Return Value:

    Boolean value indicating whether the system partition is acceptable.
    If not, the user will have been informed as to why.

--*/

{
    TCHAR DrivePath[4];
    DWORD DontCare;
    DWORD SectorSize;
    TCHAR NameBuffer[100];
    BOOL b;

    //
    // Form root path
    //
    DrivePath[0] = SystemPartitionDriveLetter;
    DrivePath[1] = TEXT(':');
    DrivePath[2] = TEXT('\\');
    DrivePath[3] = 0;

    //
    // Check sector size
    //
    if(!GetDiskFreeSpace(DrivePath,&DontCare,&SectorSize,&DontCare,&DontCare)
    || (SectorSize != WINNT32_SECTOR_SIZE)) {
        if (!(IsNEC98() && (SectorSize > WINNT32_SECTOR_SIZE))) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UNSUPPORTED_SECTOR_SIZE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );
            return(FALSE);
        }
    }

    //
    // Determine file system.
    //
    b = GetVolumeInformation(
            DrivePath,
            NULL,0,                 // don't care about volume name
            NULL,                   // ...or serial #
            &DontCare,              // ...or max component length
            &DontCare,              // ... or flags
            NameBuffer,
            sizeof(NameBuffer)/sizeof(TCHAR)
            );

    if(!b) {

        MessageBoxFromMessage(
            ParentWindow,
            MSG_UNKNOWN_FS,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            SystemPartitionDriveLetter
            );

        return(FALSE);
    }

    if(!lstrcmpi(NameBuffer,TEXT("NTFS"))) {

         *Filesystem = Winnt32FsNtfs;
         *BootCodeSectorCount = WINNT32_NTFS_BOOT_SECTOR_COUNT;

         b = ReadDiskSectors(
                 SystemPartitionDriveLetter,
                 0,
                 WINNT32_NTFS_BOOT_SECTOR_COUNT,
                 WINNT32_SECTOR_SIZE,
                 BootCode
                 );

         if(!b) {
             MessageBoxFromMessage(
                 ParentWindow,
                 MSG_DASD_ACCESS_FAILURE,
                 FALSE,
                 AppTitleStringId,
                 MB_OK | MB_ICONERROR | MB_TASKMODAL,
                 SystemPartitionDriveLetter
                 );

             return(FALSE);
         }
    } else {
        if(!lstrcmpi(NameBuffer,TEXT("FAT")) || !lstrcmpi(NameBuffer,TEXT("FAT32"))) {
            //
            // Read 1 sector.
            //
            b = ReadDiskSectors(
                    SystemPartitionDriveLetter,
                    0,
                    WINNT32_FAT_BOOT_SECTOR_COUNT,
                    WINNT32_SECTOR_SIZE,
                    BootCode
                    );

            if(!b) {
                MessageBoxFromMessage(
                    ParentWindow,
                    MSG_DASD_ACCESS_FAILURE,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    SystemPartitionDriveLetter
                    );

                return(FALSE);
            }

            *Filesystem = NameBuffer[3] ? Winnt32FsFat32 : Winnt32FsFat;
            *BootCodeSectorCount = WINNT32_FAT_BOOT_SECTOR_COUNT;
        } else {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UNKNOWN_FS,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );

            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
IsNtBootCode(
    IN  WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN  LPBYTE                     BootCode
    )

/*++

Routine Description:

    Determine if boot code is for NT by examining the filesystem and
    the code itself, looking for the NTLDR string that must be present
    in all NT boot code.

    If the filesystem is NTFS then it's NT boot code.
    If not then we scan backwards in the boot sector looking for the
    NTLDR string.

Arguments:

    Filesystem - supplies the filesystem on the drive.

    BootCode - supplies the boot code read from the drive. Only the first
        sector (512 bytes) are examined.

Return Value:

    Boolean value indicating whether the boot code is for NT.
    There is no error return.

--*/

{
    UINT i;

    //
    // Because the last 2 bytes are the 55aa signature we can
    // skip them in the scan.
    //
    if(Filesystem == Winnt32FsNtfs) {
        return(TRUE);
    }

    for(i=WINNT32_SECTOR_SIZE-7; i>62; --i) {
        if(!memcmp("NTLDR",BootCode+i,5)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


BOOL
__inline
WriteToBootIni(
    IN HANDLE Handle,
    IN PCHAR  Line
    )
{
    DWORD bw,l;

    l = lstrlenA(Line);

    return(WriteFile(Handle,Line,l,&bw,NULL) && (bw == l));
}

BOOL
MungeBootIni(
    IN HWND ParentWindow,
    IN BOOL SetPreviousOs
    )
{
    TCHAR BootIniName[16];
    TCHAR BootIniBackup[16];
    UCHAR BootSectorImageSpec[29];
    CHAR HeadlessRedirectSwitches[160];
    TCHAR ParamsFile[MAX_PATH];
    HANDLE h;
    DWORD BootIniSize;
    PUCHAR Buffer;
    PTCHAR DebugLogBuffer=NULL;
    DWORD BytesRead = 0;
    BOOL b;
    PUCHAR p,next;
    BOOL InOsSection;
    CHAR c;
    CHAR Text[256];
    DWORD OldAttributes;
    DWORD d;
    BOOL UpgradeOSPresent = FALSE;
    DWORD attribs;

    PUCHAR DefSwitches;
    PUCHAR DefSwEnd;
    UCHAR  temp;

    //
    // Determine the size of boot.ini, allocate a buffer,
    // and read it in. If it isn't there then it will be created.
    //
    wsprintf(BootIniName,TEXT("%c:\\BOOT.INI"),SystemPartitionDriveLetter);
    wsprintf(BootIniBackup,TEXT("%c:\\BOOT.BAK"),SystemPartitionDriveLetter);

    h = CreateFile(BootIniName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    if(h == INVALID_HANDLE_VALUE) {
        if ( Upgrade && ISNT() ) {
            // This is an error that the setup team should probably want
            // to look at.  If we got this far, then there was a boot.ini
            // during pre-copy (look at InspectFileSystems for proof of
            // this), but one is missing after doing the copy.
#ifdef PRERELEASE
            MessageBox(
                ParentWindow,
                TEXT("You have encountered a problem the setup team would like to look at.\n\nYou are missing a boot.ini file after the copy step (during MungeBootIni), but there was one much earlier in setup.  Something happened between then and now that the setup team (mailto:setuphot) would like to know about."),
                TEXT("Winnt32"),
                MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UPGRADE_BOOT_INI_MUNGE_MISSING_BOOT_INI,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                BootIniName);
#endif
            b = FALSE;
            d = GetLastError();
            goto c0;
        }
        //
        // Assume the file does not exist. Allocate a buffer large enough
        // to hold a single terminating nul byte.
        //
        BootIniSize = 0;
        Buffer = MALLOC(1);
        if(!Buffer) {
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }
    } else {
        //
        // Figure out how big the file is.
        // Allocate 3 extra characters for final NUL we'll add to make
        // parsing easier, and a cr/lf in case the last line is incomplete.
        //
        BootIniSize = GetFileSize(h,NULL);
        if(BootIniSize == (DWORD)(-1)) {
            d = GetLastError();
            CloseHandle(h);
            b = FALSE;
            goto c0;
        }

        Buffer = MALLOC(BootIniSize+3);
        DebugLogBuffer = MALLOC( (BootIniSize+3) * sizeof(TCHAR));
        if(!Buffer) {
            CloseHandle(h);
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        b = ReadFile(h,Buffer,BootIniSize,&BytesRead,NULL);

        d = GetLastError();
        CloseHandle(h);

        if( b && (BootIniSize != BytesRead) ){

            // Code to check if due to certain randomness we don't read everything and as a result
            // endup overwriting boot.ini

            DebugLog( Winnt32LogError, TEXT("Error: BOOT.INI wasn't read properly expected %1: read %2"), 0, BootIniSize, BytesRead);
            b = FALSE;

        }


        if( b && DebugLogBuffer ){


        // Log what we read
#ifdef UNICODE

            MultiByteToWideChar(
                CP_ACP,
                0,
                Buffer,
                BootIniSize,
                DebugLogBuffer,
                BootIniSize
                );

#else
            memcpy( DebugLogBuffer, Buffer, BootIniSize*sizeof(TCHAR));

#endif
            DebugLogBuffer[BootIniSize] = 0;

            DebugLog( Winnt32LogInformation, TEXT("BOOT.INI record - \n\n%1"), 0, DebugLogBuffer);


        }


        if(!b) {
            goto c1;
        }
    }

    //
    // Make sure the last line is properly terminated, and add a terminating nul
    // to make parsing a little easier.
    //
    if(BootIniSize && (Buffer[BootIniSize-1] != '\n') && (Buffer[BootIniSize-1] != '\r')) {
        Buffer[BootIniSize++] = '\r';
        Buffer[BootIniSize++] = '\n';
    }
    Buffer[BootIniSize] = 0;

    //
    // Truncate at control-z if any.
    //
    if(p = strchr(Buffer,26)) {
        if((p > Buffer) && (*(p - 1) != '\n') && (*(p - 1) != '\r')) {
            *(p++) = '\r';
            *(p++) = '\n';
        }
        *p = 0;
        BootIniSize = p - Buffer;
    }

    //
    // Make sure we can write boot.ini, and make a backup copy.
    // (We do not procede unless we can make a backup copy.)
    // Then recreate boot.ini.
    //
    OldAttributes = GetFileAttributes(BootIniName);
    SetFileAttributes(BootIniBackup,FILE_ATTRIBUTE_NORMAL);
    if(OldAttributes == (DWORD)(-1)) {
        //
        // Boot.ini didn't exist before. Nothing to do.
        //
    } else {
        //
        // Make a backup copy.
        //
        if(CopyFile(BootIniName,BootIniBackup,FALSE)) {
            //
            // Attributes could be 0 but not -1. Adding 1 thus allows us to
            // use non-0 to mean that we have a backup file.
            //
            CleanUpBootIni = OldAttributes+1;
        } else {
            d = GetLastError();
            b = FALSE;
            goto c1;
        }
    }

    SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
    h = CreateFile(
            BootIniName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c2;
    }

    //
    // Regardless of the actual drive letter of the system partition,
    // the spec in boot.ini is always C:\...
    //
    wsprintfA(BootSectorImageSpec,"C:\\%hs\\%hs",LOCAL_BOOT_DIR_A,AUX_BOOT_SECTOR_NAME_A);

    //
    // Scan the Buffer to see if there is a DefSwitches line,
    // to move into new boot.ini in the  [boot loader] section.
    // If no DefSwitches, just point to a null string to be moved.
    // Only process boot.ini up to [operating systems].
    //

    temp = '\0';
    DefSwitches = &temp;
    DefSwEnd = NULL;
    for(p=Buffer; *p && (p < Buffer+BootIniSize - (sizeof("[operating systems]")-1)); p++) {
      if(!_strnicmp(p,"DefSwitches",sizeof("DefSwitches")-1)) {
        DefSwEnd = strstr(p, "\n");
        if(DefSwEnd){
          DefSwEnd++;
          if(*DefSwEnd == '\r'){
            DefSwEnd++;
          }
          DefSwitches = p;
          temp = *DefSwEnd;
          *DefSwEnd = '\0';
        }
        break;
      } else {
        if(!_strnicmp(p,"[operating systems]",sizeof("[operating systems]")-1)) {
            break;
        }
      }
    }




    //
    // Take care of the headless setings.
    //
    HeadlessRedirectSwitches[0] = '\0';

    if( HeadlessSelection[0] != TEXT('\0') ) {

        //
        // They told winnt32.exe some specific headless settings.
        // Use these.
        //


        //
        // Convert the user's request into ASCII.
        //
#ifdef UNICODE
        {
            CHAR tmp[80];

            WideCharToMultiByte( CP_ACP,
                                 0,
                                 HeadlessSelection,
                                 -1,
                                 tmp,
                                 sizeof(tmp),
                                 NULL,
                                 NULL );

            wsprintfA( HeadlessRedirectSwitches,
                       "redirect=%s\r\n",
                       tmp );
        }
#else
        wsprintfA( HeadlessRedirectSwitches,
                   "redirect=%s\r\n",
                   HeadlessSelection );
#endif

    } else {

        //
        // They didn't give us any settings, so see if we can pick
        // something up from boot.ini
        //


        //
        // Parse through boot.ini, looking for any 'redirect=' lines.
        //
        for( p = Buffer; *p && (p < Buffer+BootIniSize - (sizeof("redirect=")-1)); p++ ) {

            if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

                //
                // We're past the [Boot Loader] section.  Stop looking.
                //
                break;
            }

            if(!_strnicmp(p,"redirect=",sizeof("redirect=")-1)) {

                PUCHAR      q = p;
                UCHAR       temp;

                while ((*p != '\r') && (*p != '\n') && *p) {
                    p++;
                }
                temp = *p;
                *p = '\0';
                strcpy(HeadlessRedirectSwitches, q);

                //
                // We want to make sure that this setting gets put into
                // the unattend file too so that textmode will redirect.
                // We need to set the global 'HeadlessSelection' so that
                // he will get written to winnt.sif after this block.
                //
#ifdef UNICODE
                MultiByteToWideChar( CP_ACP,
                                     MB_ERR_INVALID_CHARS,
                                     strchr(HeadlessRedirectSwitches, '=')+1,
                                     -1,
                                     HeadlessSelection,
                                     MAX_PATH );
#else
                strcpy( HeadlessSelection, strchr(HeadlessRedirectSwitches, '=')+1 );
#endif

                strcat(HeadlessRedirectSwitches, "\r\n" );
                *p = temp;

            }

        }

    }




    //
    // Now take care of the 'redirectbaudrate=X' setting.
    //
    if( HeadlessRedirectSwitches[0] != TEXT('\0') ) {

        //
        // We got got a direction to redirect.  Now see about
        // the baudrate.
        //
        if( HeadlessBaudRate != 0 ) {

            CHAR MyHeadlessRedirectBaudRateLine[80] = {0};

            wsprintfA( MyHeadlessRedirectBaudRateLine,
                       "redirectbaudrate=%d\r\n",
                       HeadlessBaudRate );

            strcat( HeadlessRedirectSwitches, MyHeadlessRedirectBaudRateLine );

        } else {

            //
            // They didn't give us any settings, so see if we can pick
            // something up from boot.ini
            //

            //
            // Parse through boot.ini, looking for any 'redirectbaudrate=' lines.
            //
            for( p = Buffer; *p && (p < Buffer+BootIniSize - (sizeof("redirectbaudrate=")-1)); p++ ) {

                if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

                    //
                    // We're past the [Boot Loader] section.  Stop looking.
                    //
                    break;
                }

                if(!_strnicmp(p,"redirectbaudrate=",sizeof("redirectbaudrate=")-1)) {

                    PUCHAR      q = p;
                    UCHAR       temp;

                    while ((*p != '\r') && (*p != '\n') && *p) {
                        p++;
                    }
                    temp = *p;
                    *p = '\0';
                    strcat(HeadlessRedirectSwitches, q);
                    strcat(HeadlessRedirectSwitches, "\r\n" );
                    *p = temp;


                    //
                    // Now set the global HeadlessBaudRate variable so
                    // we'll know what to write in winnt.sif when the time
                    // comes.
                    //
                    p = strchr( q, '=' );
                    if( p ) {
                        p++;
                        HeadlessBaudRate = atoi( p );
                    }

                }

            }

        }
    }


    //
    // Now generate the name of the parameters file
    // and write our headless settings out.
    //
    BuildSystemPartitionPathToFile( LOCAL_BOOT_DIR,
                                    ParamsFile,
                                    MAX_PATH );
    ConcatenatePaths(ParamsFile,WINNT_SIF_FILE,MAX_PATH);
    WriteHeadlessParameters( ParamsFile );




    wsprintfA(
        Text,
        "[Boot Loader]\r\nTimeout=5\r\nDefault=%hs\r\n%hs[Operating Systems]\r\n",
        BootSectorImageSpec,
        HeadlessRedirectSwitches
    );


    //
    // If there were DefSwitches, set the Buffer back to original state
    //
    if(DefSwEnd){
         *DefSwEnd = temp;
    }

    if(!WriteToBootIni(h,Text)) {
        d = GetLastError();
        b = FALSE;
        DebugLog( Winnt32LogError, TEXT("Error: BOOT.INI wasn't written to properly : LastError - %1"), 0, d);
        goto c3;
    }

    //
    // Process each line in boot.ini.
    // If it's the setup boot sector line, we'll throw it out.
    // For comparison with lines in boot.ini, the drive letter
    // is always C even if the system partition is not actually C:.
    //
    InOsSection = FALSE;
    b = TRUE;
    for(p=Buffer; *p && b; p=next) {

        while((*p==' ') || (*p=='\t')) {
            p++;
        }

        if(*p) {

            //
            // Find first byte of next line.
            //
            for(next=p; *next && (*next++ != '\n'); );

            //
            // Look for start of [operating systems] section
            // or at each line in that section.
            //
            if(InOsSection) {

                switch(*p) {

                case '[':   // end of section.
                    *p=0;   // force break out of loop
                    break;

                case 'C':
                case 'c':   // potential start of c:\ line

                    //
                    // See if it's a line for setup boot.
                    // If so, ignore it.
                    //
                    if(!_strnicmp(p,BootSectorImageSpec,lstrlenA(BootSectorImageSpec))) {
                        break;
                    }

                    //
                    // If we're supposed to set the previous OS and this is
                    // a line for the previous OS, ignore it.
                    //
                    if(SetPreviousOs && (p[1] == ':') && (p[2] == '\\')
                    && ((p[3] == '=') || (p[3] == ' ') || (p[3] == '\t'))) {

                        break;
                    }

                    //
                    // Not a special line, FALL THROUGH to write it out as-is.
                    //

                default:

                    //
                    // Random line. write it out.
                    //

                    if( Upgrade && ISNT() ){

                        //
                        //Check to make sure that in the NT upgrade case we atleast have one valid line
                        //Using 4 chars as the check as at minimum a valid line should have x=y<CRLF>
                        //

                        if( (next - p ) > 4 )
                            UpgradeOSPresent = TRUE;
                    }

                    c = *next;
                    *next = 0;
                    b = WriteToBootIni(h,p);
                    *next = c;

                    break;

                }

            } else {
                if(!_strnicmp(p,"[operating systems]",19)) {
                    InOsSection = TRUE;
                }
            }
        }
    }

    if( ISNT() && Upgrade && !UpgradeOSPresent ){

#ifdef PRERELEASE

        //On internal builds we want setuphot to be informed
        //when we encounter this

        MessageBox(
            ParentWindow,
            TEXT("You have encountered an error the Setup Team needs to investigate. Send email to SetupHot.(Boot Ini Error)"),
            TEXT("Winnt32"),
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

#endif
        b = FALSE;
        SetLastError( ERROR_INVALID_PARAMETER );

    }

    //
    // Write out our line.
    //
    if(b) {
      CHAR  *AnsiStrs[] = {
              "Microsoft Windows XP Professional Setup",
              "Microsoft Windows 2002 Server Setup",
              "Microsoft Windows 2002 Advanced Server Setup",
              "Microsoft Windows 2002 Datacenter Server Setup",
              "Microsoft Windows 2002 Blade Setup",
	      "Microsoft Windows 2002 Small Business Server Setup",
              "Microsoft Windows XP Setup"
              };

      DWORD Index = -1;

      if (!LoadBootIniString(hInst, AppTitleStringId, Text, sizeof(Text))) {
        switch (AppTitleStringId) {
          case IDS_APPTITLE_WKS:
            Index = 0;
            break;

          case IDS_APPTITLE_SRV:
            Index = 1;
            break;

          case IDS_APPTITLE_ASRV:
            Index = 2;
            break;

          case IDS_APPTITLE_DAT:
            Index = 3;

          case IDS_APPTITLE_BLADE:
            Index = 4;

	  case IDS_APPTITLE_SBS:
	    Index = 5;
			
          default:
            Index = 6;
            break;
        }

        strcpy(Text, AnsiStrs[Index]);
      }


      if((b=WriteToBootIni(h,BootSectorImageSpec))
      && (b=WriteToBootIni(h,"=\""))
      && (b=WriteToBootIni(h,Text))) {
          b = WriteToBootIni(h,"\"\r\n");
      }else{
            DebugLog( Winnt32LogError, TEXT("Error: Textmode line was not written properly to BOOT.INI"), 0);
      }
    }

    //
    // Write out previous OS line if directed to do so.
    //
    if(b && SetPreviousOs) {
        if(b = WriteToBootIni(h,"C:\\=\"")) {
            LoadStringA(hInst, Upgrade ? IDS_CANCEL_SETUP:IDS_MICROSOFT_WINDOWS,Text,sizeof(Text));
            if(b = WriteToBootIni(h,Text)) {
                b = WriteToBootIni(h,"\"\r\n");
            }
        }
    }

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    d = NO_ERROR;

c3:
    CloseHandle(h);
c2:
    //
    // Restore boot.ini.
    //
    if(!b && (OldAttributes != (DWORD)(-1))) {
        SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
        CopyFile(BootIniBackup,BootIniName,FALSE);
        SetFileAttributes(BootIniName,OldAttributes);
        SetFileAttributes(BootIniBackup,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(BootIniBackup);
        DebugLog( Winnt32LogError, TEXT("Error processing boot.ini and restored"), 0);
    }
c1:
    FREE(Buffer);
c0:
    if(!b) {
        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            BootIniName
            );
    }

    return(b);
}


VOID
MigrateBootIniData(
    VOID
    )
{
    TCHAR BootIniName[16];

    //
    // Determine the size of boot.ini, allocate a buffer,
    // and read it in. If it isn't there then it will be created.
    //
    wsprintf(BootIniName,TEXT("%c:\\BOOT.INI"),SystemPartitionDriveLetter);

    GetPrivateProfileString(
                    TEXT("Boot Loader"),
                    TEXT("Timeout"),
                    TEXT(""),
                    Timeout,
                    sizeof(Timeout)/sizeof(TCHAR),
                    BootIniName);
}


BOOL
LayNtBootCode(
    IN     HWND                       ParentWindow,
    IN     WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN OUT LPBYTE                     BootCode
    )

/*++

Routine Description:

    Copy existing boot sector into bootsect.dos and lay down NT boot code.

    THIS ROUTINE DOES NOT CHECK THE EXISTING BOOT CODE. The caller must
    do that, and not call this routine if the existing boot code is
    already for NT. This routine should never be called for an NTFS drive
    since by definition that's NT boot code.

Arguments:

    ParentWindow - supplies window handle of window to be used as
        owner/parent in case this routine puts up UI.

    Filesystem - supplies filesystem for system partition, as determined
        earlier by CheckSysPartAndReadBootCode(). Either Fat or Fat32.

    BootCode - on input, supplies copy of existing boot code read from
        the drive. On output, receives copy of new boot code that was
        was written to the drive.

Return Value:

    Boolean value indicating outcome. If FALSE then the user will have been
    informed as to why.

--*/

{
    UINT i;
    HANDLE h;
    TCHAR FileName[] = TEXT("?:\\BOOTSECT.DOS");
    DWORD d;
    BOOL b;


    //
    // Nt 3.51 will bugcheck here if they have an adaptec
    // 2940 card.  Return if we're on 3.51.  Note that
    // if any of the APIs fail, or anything goes wrong
    // in here, we just continue, assuming we're not
    // on NT 3.51.
    //
    if(!IsNEC98() && ISNT() && (BuildNumber <= NT351)) {
        return TRUE;
    }

    //
    // We may want to update the boot sector even if it
    // is NT boot code.  In that case, we don't want to
    // go blast out a new bootsect.dos.  Check first.
    //
    // If this process is called during /cmdcons,
    // the BOOTSECT.DOS should not be created on NEC98
    //
    if((IsNEC98() && !(BuildCmdcons)) || !(ISNT() || IsNtBootCode(Filesystem,BootCode)) ) {

        //
        // Write out existing boot sector to bootsect.dos.
        // We only move a single sector, which is correct in Fat
        // and Fat32 cases. The NT Fat32 boot code looks in sector
        // 12 for its second sector, so no special casing is required.
        //
        FileName[0] = SystemPartitionDriveLetter;
        SetFileAttributes(FileName,FILE_ATTRIBUTE_NORMAL);

        h = CreateFile(
                FileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

        if(h == INVALID_HANDLE_VALUE) {

            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                FileName
                );

            return(FALSE);
        }

        b = WriteFile(h,BootCode,WINNT32_SECTOR_SIZE,&d,NULL);
        d = GetLastError();
        CloseHandle(h);

        if(!b) {
            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                d,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                FileName
                );

            return(FALSE);
        }

    }

    //
    // While upgrading Win9X with FAT32 system partition installations,
    // update the BPB's heads value to reflect the actual value
    //
    if (!ISNT() && (Filesystem == Winnt32FsFat32)) {
        if (!PatchBootCode(Filesystem,
                    SystemPartitionDriveLetter,
                    (PUCHAR)BootCode,
                    sizeof(Fat32BootCode))) {
            //
            // for failure case just log a winnt32.log error message
            // indicating the error
            //
            DebugLog(Winnt32LogError,
                TEXT("Could not update the FAT32 system partition's boot sector's\r\n")
                TEXT(" Bios Parameter Block's heads value"),
                0);

        }
    }

    //
    // Now lay the NT code itself down onto the disk. We copy the non-BPB parts
    // of the appropriate template code into the caller's bootcode buffer.
    // Take advantage of the offset part of the jump instruction at the start
    // of the boot code (like eb 3c 90) to tell us where the BPB ends and
    // the code begins.
    //
    switch(Filesystem) {

    case Winnt32FsFat:
        {
        BYTE BootCodeBuffer[WINNT32_MAX_BOOT_SIZE];

            if (IsNEC98())
            {
                CopyMemory(BootCodeBuffer,PC98FatBootCode,sizeof(PC98FatBootCode));

                // NEC98 need set to HiddenSector(Bpb Index 0x011) value in BPB.
                // Hiddensector value is how many sectors from sector 0
                // This spec is NEC98 only.

                *(LONG *)&BootCodeBuffer[0x011 + 11]
                = CalcHiddenSector(SystemPartitionDriveLetter,
                                   *(SHORT *)&BootCodeBuffer[11]);

            } else {
                CopyMemory(BootCodeBuffer,FatBootCode,sizeof(FatBootCode));
            }
                CopyMemory(BootCode,BootCodeBuffer,3);
                CopyMemory(
                    BootCode + BootCodeBuffer[1] + 2,
                    BootCodeBuffer + BootCodeBuffer[1] + 2,
                    WINNT32_SECTOR_SIZE - (BootCodeBuffer[1] + 2)
                );
        }
        break;

    case Winnt32FsFat32:

        //
        // In the FAT32 case we also lay down NT's second sector at sector 12.
        //
        {
        BYTE BootCodeBuffer[WINNT32_MAX_BOOT_SIZE];

            if (IsNEC98())
            {
                CopyMemory(BootCodeBuffer,PC98Fat32BootCode,sizeof(PC98Fat32BootCode));
            } else {
                CopyMemory(BootCodeBuffer,Fat32BootCode,sizeof(Fat32BootCode));
            }

            b = WriteDiskSectors( SystemPartitionDriveLetter,
                                  12,
                                  1,
                                  WINNT32_SECTOR_SIZE,
                                  BootCodeBuffer+1024 );

            if(b) {
                CopyMemory(BootCode,BootCodeBuffer,3);

                CopyMemory( BootCode + BootCodeBuffer[1] + 2,
                            BootCodeBuffer + BootCodeBuffer[1] + 2,
                            WINNT32_SECTOR_SIZE - (BootCodeBuffer[1] + 2) );
            }
        }
        break;

    default:
        //
        // We should never get here.
        //
        b = FALSE;
        break;
    }

    if(b) {
        b = WriteDiskSectors(
                SystemPartitionDriveLetter,
                0,
                1,
                WINNT32_SECTOR_SIZE,
                BootCode
                );

        if(b) {
            CleanUpBootCode = TRUE;
        }
    }

    if(!b) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_DASD_ACCESS_FAILURE,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            SystemPartitionDriveLetter
            );
    }

    return(b);
}


BOOL
CreateAuxiliaryBootSector(
    IN HWND                       ParentWindow,
    IN WINNT32_SYSPART_FILESYSTEM Filesystem,
    IN LPBYTE                     BootCode,
    IN UINT                       BootCodeSectorCount
    )

/*++

Routine Description:

    When ntldr sees an entry in boot.ini that starts with the magic text "C:\"
    it will look to see if the item specifies a filename, and if so it will
    assume that the file is a boot sector, load it, and jump to it.

    We place an entry in boot.ini for C:\$WIN_NT$.~BT\BOOTSECT.DAT, and place
    our special boot sector(s) in that file. Our sector is special because it
    loads $LDR$ instead of NTLDR, allowing us to boot into setup without
    disturbing the "standard" ntldr-based boot.

    This routine exmaines the boot code on the disk, changes NTLDR to $LDR$
    and writes the result out to x:\$WIN_NT$.~BT\BOOTSECT.DAT.

    This code assumes a sector size of 512 bytes.

Arguments:

    ParentWindow - supplies a window handle for a window to act as parent/owner
        for any ui that gets displayed by this routine.

    Filesystem - supplies a value that indicates the filesystem on the
        system partition.

    BootCode - supplies a buffer containing a copy of the boot code that is
        actually on the disk.

    BootCodeSectorCount - supplies the number of sectors the boot code
        occupies on-disk (and thus indicates the size of the BootCode buffer).

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed about why".

--*/

{
    UINT i;
    TCHAR NameBuffer[MAX_PATH];
    HANDLE hFile;
    BOOL b;
    DWORD DontCare;

    //
    // Change NTLDR to $LDR$. NTFS stores it in unicode in its boot sector
    // so 2 separate algorithms are needed.
    //
    if(Filesystem == Winnt32FsNtfs) {
        for(i=1014; i>62; i-=2) {
            if(!memcmp("N\000T\000L\000D\000R\000",BootCode+i,10)) {
                //
                // Do NOT use _lstrcpynW here since there is no
                // way to get it to do the right thing without overwriting
                // the word after $LDR$ with a terminating 0. Doing that
                // breaks boot.
                //
                CopyMemory(BootCode+i,AUX_BS_NAME_W,10);
                break;
            }
        }
    } else {
        for(i=505; i>62; --i) {
            //
            // Scan for full name with spaces so we don't find a boot message
            // by accident.
            //
            if(!memcmp("NTLDR      ",BootCode+i,11)) {
                strncpy(BootCode+i,AUX_BS_NAME_A,5);
                break;
            }
        }
    }

    //
    // Form name of boot sector image file.
    //
    wsprintf(
        NameBuffer,
        TEXT("%c:\\%s\\%s"),
        SystemPartitionDriveLetter,
        LOCAL_BOOT_DIR,
        AUX_BOOT_SECTOR_NAME
        );

    //
    // Write boot sector image into file.
    //
    SetFileAttributes(NameBuffer,FILE_ATTRIBUTE_NORMAL);
    hFile = CreateFile(NameBuffer,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,0,NULL);
    if(hFile == INVALID_HANDLE_VALUE) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            NameBuffer
            );

        return(FALSE);
    }

    //
    // We have a timing bug that we're going to workaround for the
    // time being...
    //
    i = 0;
    b = FALSE;
    while( (i < 10) && (b == FALSE) ) {
        Sleep( 500 );
        b = WriteFile(hFile,BootCode,BootCodeSectorCount*WINNT32_SECTOR_SIZE,&DontCare,NULL);
        if( !b ) {
            DontCare = GetLastError();
        }
        i++;
    }

    if(!b) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            DontCare,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            NameBuffer
            );

//
// Set this back before we ship Beta2!
// -matth
//
#if 1
        //
        // Now try again.
        //
        b = WriteFile(hFile,BootCode,BootCodeSectorCount*WINNT32_SECTOR_SIZE,&DontCare,NULL);
#endif

    }

    CloseHandle(hFile);

    //
    // Success if we get here.
    //
    return(b);
}


BOOL
DoX86BootStuff(
    IN HWND ParentWindow
    )
{
    WINNT32_SYSPART_FILESYSTEM Filesystem;
    BYTE BootCode[WINNT32_MAX_BOOT_SIZE];
    UINT BootCodeSectorCount;
    BOOL AlreadyNtBoot;
    TCHAR Filename[13];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    BOOL b;

    //
    // On Win95, make sure we have NTLDR on the system partition,
    // otherwise it makes no sense to lay NT boot code. This is
    // a robustness thing to catch the case where an error occurred
    // copying that file and the user skipped, etc. Otherwise we could
    // end up getting the user into a situation where he can't boot.
    //
    if(!ISNT()) {
        wsprintf(Filename,TEXT("%c:\\NTLDR"),SystemPartitionDriveLetter);
        FindHandle = FindFirstFile(Filename,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            b = FALSE;
        } else {
            FindClose(FindHandle);
            if((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || !FindData.nFileSizeLow) {
                b = FALSE;
            } else {
                b = TRUE;
            }
        }

        if(!b) {
            MessageBoxFromMessage(
                ParentWindow,
                MSG_NTLDR_NOT_COPIED,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );

            return(FALSE);
        }
    }

    //
    // Check out C:. Sector size must be 512 bytes and it has to be
    // formatted in a filesystem we recognize -- FAT, FAT32, or NTFS
    // (NT 3.51 also supported HPFS, but we assume we would not have
    // gotten here if the drive is HPFS).
    //
    if(!CheckSysPartAndReadBootCode(ParentWindow,&Filesystem,BootCode,&BootCodeSectorCount)) {
        return(FALSE);
    }

    //
    // If we're running on Win95 check the existing boot code to see whether
    // it's already for NT. If on NT assume the boot code is correct.
    // That assumption could be bogus in some marginal cases (such as when
    // the user boots from a floppy with ntldr on it and C: is corrupt
    // or has been re-sys'ed, etc), but we ignore these issues.
    //
    AlreadyNtBoot = ISNT() ? TRUE : IsNtBootCode(Filesystem,BootCode);

    //
    // Munge boot.ini. We do this before laying NT boot code. If we did it
    // afterwards and it failed, then the user could have NT boot code but no
    // boot.ini, which would be bad news.
    //
    if(!MungeBootIni(ParentWindow,!AlreadyNtBoot)) {
        return(FALSE);
    }

    //
    // If BOOTSEC.DOS exist, We Need save BOOTSEC.DOS on NEC98 System.
    //Some case, It is different to Now boot sector. It is created by
    //NT4.
    // NEC970725
    // If this process is called during /cmdcons,
    // the BOOTSECT.DOS should not be renamed "BOOTSECT.NEC" on NEC98
    //

    if (IsNEC98() && !(BuildCmdcons)){
        TCHAR FileNameOld[16],FileNameNew[163];

        FileNameOld[0] = FileNameNew[0] = SystemPartitionDriveLetter;
        FileNameOld[1] = FileNameNew[1] = TEXT(':');
        FileNameOld[2] = FileNameNew[2] = TEXT('\\');
        lstrcpy(FileNameOld+3,TEXT("BOOTSECT.DOS"));
        lstrcpy(FileNameNew+3,TEXT("BOOTSECT.NEC"));
        SetFileAttributes(FileNameOld,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(FileNameNew);
        MoveFile(FileNameOld, FileNameNew);
    }

    //
    // If not already NT boot, copy existing boot code into bootsect.dos
    // and lay down NT boot code.
    //
    // We're going to start writing new boot code if we're on anything
    // but an NTFS drive.
    //
    if( (!AlreadyNtBoot) || (Filesystem != Winnt32FsNtfs) ) {
        if( !LayNtBootCode(ParentWindow,Filesystem,BootCode) ) {
            return(FALSE);
        }
    }

    //
    // Create the auxiliary boot code file, which is a copy of the NT
    // boot code for the drive, with NTLDR changed to $LDR$.
    //
    if( (ForcedSystemPartition) &&
        (UserSpecifiedLocalSourceDrive) &&
        (ForcedSystemPartition == UserSpecifiedLocalSourceDrive) ) {

        TCHAR FileNameOld[32],FileNameNew[32];
        //
        // The OEM is making a bootable disk with local source for a
        // preinstall scenario.  We can avoid any drive geometry dependence
        // by simply booting the setupldr instead of using the ntldr->
        // bootsect.dat->setupldr.  To do this, we'll simply copy setupldr
        // over ntldr.  Note that we're removing his ability to boot anything
        // other than textmode setup here, so be aware.
        //

        //
        // Unlock ntldr.
        //
        FileNameOld[0] = FileNameNew[0] = ForcedSystemPartition;
        FileNameOld[1] = FileNameNew[1] = TEXT(':');
        FileNameOld[2] = FileNameNew[2] = TEXT('\\');
        lstrcpy(FileNameOld+3,TEXT("$LDR$"));
        lstrcpy(FileNameNew+3,TEXT("NTLDR"));
        SetFileAttributes(FileNameNew,FILE_ATTRIBUTE_NORMAL);

        //
        // Move $LDR$ to NTLDR
        //
        DeleteFile(FileNameNew);
        MoveFile(FileNameOld, FileNameNew);

    } else {
        if(!CreateAuxiliaryBootSector(ParentWindow,Filesystem,BootCode,BootCodeSectorCount)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
RestoreBootSector(
    VOID
    )
{
    TCHAR Name[MAX_PATH];
    BYTE Buffer[WINNT32_MAX_BOOT_SIZE];
    DWORD BytesRead;
    BOOL b;
    HANDLE h;

    //
    // If we didn't get to the point of writing new boot code,
    // then there's nothing to do.
    //
    if(!CleanUpBootCode) {
        return(TRUE);
    }

    //
    // Try to put bootsect.dos back onto the boot sector.
    //
    wsprintf(
        Name,
        TEXT("%c:\\%s\\BOOTSECT.DOS"),
        SystemPartitionDriveLetter,
        LOCAL_BOOT_DIR
        );

    h = CreateFile(Name,GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL);
    if(h == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        b = ReadFile(h,Buffer,WINNT32_SECTOR_SIZE,&BytesRead,NULL);
        CloseHandle(h);

        if(b) {
            b = WriteDiskSectors(
                    SystemPartitionDriveLetter,
                    0,
                    1,
                    WINNT32_SECTOR_SIZE,
                    Buffer
                    );

            if(b) {
                //
                // If this worked then we don't need ntldr, ntdetect.com, or boot.ini.
                // If is possible that these files were there already before
                // and we're thus "overcleaning" but we shouldn't get here
                // unless we overwrote non-nt boot code with nt boot code.
                // Thus putting back bootsect.dos restores non-NT boot code,
                // so this shouldn't be too destructive.
                //
                Name[0] = SystemPartitionDriveLetter;
                Name[1] = TEXT(':');
                Name[2] = TEXT('\\');

                lstrcpy(Name+3,TEXT("NTLDR"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);

                lstrcpy(Name+3,TEXT("NTDETECT.COM"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);

                wsprintf(Name+3,TEXT("BOOT.INI"));
                SetFileAttributes(Name,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Name);
            }
        }
    }

    return(b);
}


BOOL
RestoreBootIni(
    VOID
    )
{
    BOOL b = TRUE;
    TCHAR BootIniFile[12] = TEXT("X:\\BOOT.INI");
    TCHAR BackupFile[12] = TEXT("X:\\BOOT.BAK");

    if(CleanUpBootIni) {
        CleanUpBootIni--;

        BootIniFile[0] = SystemPartitionDriveLetter;
        BackupFile[0] = SystemPartitionDriveLetter;

        SetFileAttributes(BootIniFile,FILE_ATTRIBUTE_NORMAL);
        if(CopyFile(BackupFile,BootIniFile,FALSE)) {
            SetFileAttributes(BackupFile,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(BackupFile);
            SetFileAttributes(BootIniFile,CleanUpBootIni);
        } else {
            b = FALSE;
        }
    }

    return(b);
}


BOOL
SaveRestoreBootFiles_NEC98(
    IN UCHAR Flag
    )
{
    PTSTR BackupFiles[] = { TEXT("\\BOOT.INI"),
                            TEXT("\\NTDETECT.COM"),
                            TEXT("\\NTLDR"),
                            NULL
                          };

    PTSTR BackupFiles2[] = { TEXT("\\") AUX_BS_NAME, TEXT("\\") TEXTMODE_INF, NULL };

    UINT i;
    TCHAR SystemDir[3];

    SystemDir[0] = SystemPartitionDriveLetter;
    SystemDir[1] = TEXT(':');
    SystemDir[2] = 0;

    if (Flag == NEC98RESTOREBOOTFILES){
        //
        // Restore boot files.
        //
        for(i=0; BackupFiles[i] ; i++) {

        HandleBootFilesWorker_NEC98(
            LocalBackupDirectory,
            SystemDir,
            BackupFiles[i],
            TRUE
            );
        }

        //
        // Delete tmp files.
        //
        for(i=0; BackupFiles2[i] ; i++) {

            HandleBootFilesWorker_NEC98(
                NULL,
                SystemDir,
                BackupFiles2[i],
                FALSE
            );
        }
    } else {
        if (CreateDirectory(LocalBackupDirectory, NULL))
        for (i = 0; BackupFiles[i] ; i++) {
            HandleBootFilesWorker_NEC98(SystemDir,
                                        LocalBackupDirectory,
                                        BackupFiles[i],
                                        TRUE);
        }
    }
    return(TRUE);
}


BOOL
HandleBootFilesWorker_NEC98(
    IN TCHAR *SourceDir,
    IN TCHAR *DestDir,
    IN PTSTR  File,
    IN BOOL   Flag
    )
{
    TCHAR SourceFile[MAX_PATH];
    TCHAR TargetFile[MAX_PATH];
    DWORD OldAttributes;

    if ((!DestDir) || ((!SourceDir)&&Flag)) {
        return(FALSE);
    }

    lstrcpy(TargetFile, DestDir);
    lstrcat(TargetFile, File);

    if (SourceDir) {
        lstrcpy(SourceFile, SourceDir);
        lstrcat(SourceFile, File);
    }

    if (Flag) {
        OldAttributes = GetFileAttributes(TargetFile);
        SetFileAttributes(TargetFile,FILE_ATTRIBUTE_NORMAL);
        if (!CopyFile(SourceFile,TargetFile,FALSE)) {
            Sleep(500);
            if (!CopyFile(SourceFile,TargetFile,FALSE)) {
                return(FALSE);
            }
        }
        if (OldAttributes != (DWORD)(-1)) {
            SetFileAttributes(TargetFile,OldAttributes & ~FILE_ATTRIBUTE_COMPRESSED);
        }
    } else {
        SetFileAttributes(TargetFile,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(TargetFile);
    }

    return(TRUE);

}


BOOL
PatchTextIntoBootCode(
    VOID
    )
{
    BOOLEAN b;
    CHAR Missing[100];
    CHAR DiskErr[100];
    CHAR PressKey[100];

    if(LoadStringA(hInst,IDS_BOOTMSG_FAT_NTLDR_MISSING,Missing,sizeof(Missing))
    && LoadStringA(hInst,IDS_BOOTMSG_FAT_DISKERROR,DiskErr,sizeof(DiskErr))
    && LoadStringA(hInst,IDS_BOOTMSG_FAT_PRESSKEY,PressKey,sizeof(PressKey))) {

        CharToOemA(Missing,Missing);
        CharToOemA(DiskErr,DiskErr);
        CharToOemA(PressKey,PressKey);

        if(b = PatchMessagesIntoFatBootCode(FatBootCode,FALSE,Missing,DiskErr,PressKey)) {
            b = PatchMessagesIntoFatBootCode(Fat32BootCode,TRUE,Missing,DiskErr,PressKey);
        }
    } else {
        b = FALSE;
    }

    return((BOOL)b);
}

LONG
CalcHiddenSector(
    IN TCHAR DriveLetter,
    IN SHORT Bps
    )
{
    TCHAR HardDiskName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    PARTITION_INFORMATION partition_info;
    DWORD DataSize;

    if (!ISNT()){
        return(CalcHiddenSector95(DriveLetter));
    } else {
        HardDiskName[4] = DriveLetter;
        hDisk = CreateFileW((const unsigned short *)HardDiskName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
            );
        if(hDisk == INVALID_HANDLE_VALUE) {
            return 0L;
        }
        DeviceIoControl(hDisk,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL,
                        0,
                        &partition_info,
                        sizeof(PARTITION_INFORMATION),
                        &DataSize,
                        NULL);
        CloseHandle(hDisk);
        return(LONG)(partition_info.StartingOffset.QuadPart / Bps);
    }
}

LONG
CalcHiddenSector95(
    IN TCHAR DriveLetter
    )
{
#define WINNT_WIN95HLP_GET1STSECTOR_W L"GetFirstSectorNo32"
#define WINNT_WIN95HLP_GET1STSECTOR_A "GetFirstSectorNo32"
#define NEC98_DLL_NAME_W            L"98PTN32.DLL"
#define NEC98_DLL_NAME_A            "98PTN32.DLL"
#ifdef UNICODE
#define WINNT_WIN95HLP_GET1STSECTOR WINNT_WIN95HLP_GET1STSECTOR_W
#define NEC98_DLL_NAME  NEC98_DLL_NAME_W
#else
#define WINNT_WIN95HLP_GET1STSECTOR WINNT_WIN95HLP_GET1STSECTOR_A
#define NEC98_DLL_NAME  NEC98_DLL_NAME_A
#endif

typedef DWORD (CALLBACK WINNT32_PLUGIN_WIN95_GET1STSECTOR_PROTOTYPE)(int, WORD);
typedef WINNT32_PLUGIN_WIN95_GET1STSECTOR_PROTOTYPE * PWINNT32_PLUGIN_WIN95_GET1STSECTOR;


    TCHAR ModuleName[MAX_PATH], *p;
    HINSTANCE Pc98ModuleHandle;
    PWINNT32_PLUGIN_WIN95_GET1STSECTOR Get1stSector;
    LONG NumSectors = 0;    // indicates failure

    if(!GetModuleFileName (NULL, ModuleName, MAX_PATH) ||
        (!(p=_tcsrchr(ModuleName, TEXT('\\')))) ) {

        return 0;
    }

    *p= 0;
    ConcatenatePaths (ModuleName, NEC98_DLL_NAME, MAX_PATH);

    //
    // Load library
    //
    Pc98ModuleHandle = LoadLibraryEx(
                            ModuleName,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH
                            );

    if (Pc98ModuleHandle) {
        //
        // Get entry point
        //
        Get1stSector= (PWINNT32_PLUGIN_WIN95_GET1STSECTOR)
                        GetProcAddress (Pc98ModuleHandle,
                            (const char *)WINNT_WIN95HLP_GET1STSECTOR);

        if (Get1stSector) {
            //
            // the second parameter must be 0.
            // if 0 is returned, it indicates the function failed.
            //
            NumSectors = (LONG)Get1stSector((int)DriveLetter, (WORD)0);
        }

        FreeLibrary(Pc98ModuleHandle);
    }

    return NumSectors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\i386\devenum.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    devenum.c

Abstract:

    Code for enum IDE ans SCSI controllers and attached to them storage devices 
    and calculate for them SCSI Address.

Author:

    Souren Aghajanyan (sourenag)    05-June-2001

Revision History:

--*/

#include "precomp.h"
#include "devenum.h"

typedef struct tagIDEController
{
    PCTSTR pnpId;
    UINT   defaultSCSIPort;
}IDE_CONTROLLER, *PIDE_CONTROLLER;

#define DEVICE_CURRENT_DRIVE_LETTER_TEXT_ASSIGNMENT TEXT("CurrentDriveLetterAssignment")

IDE_CONTROLLER g_knownIDEControllers[] = 
{
    {TEXT("MF\\GOODPRIMARY"), 0}, 
    {TEXT("MF\\GOODSECONDARY"), 1}, 
    {TEXT("*PNP0600"), 1}
};

PCTSTR 
pRegQueryStringValue(
    IN  HKEY    hKey, 
    IN  PCTSTR  ValueName, 
    OUT PVOID   Buffer, 
    IN  UINT    BufferSize
    )
{
    static TCHAR defaultBuffer[MAX_REG_SIZE];
    DWORD valueType;

    MYASSERT((hKey && ValueName) && ((Buffer && BufferSize) || (!Buffer)));

    if(!Buffer){
        Buffer = (PVOID)defaultBuffer;
        BufferSize = sizeof(defaultBuffer);
    }

    if(ERROR_SUCCESS != RegQueryValueEx(hKey, 
                                        ValueName, 
                                        0, 
                                        &valueType, 
                                        (PBYTE)Buffer, 
                                        (PULONG)&BufferSize) || 
       REG_SZ != valueType){
        return NULL;
    }

    return (PCTSTR)Buffer;
}

BOOL 
pDoesDriveExist(
    IN  HKEY    hDevice, 
    OUT DWORD*  DriveType
    )
{
    DWORD driveType;
    PCTSTR pBufferKeyValue;
    TCHAR drivePath[] = TEXT("?:\\");
    BOOL bCDROMDevice = TRUE;

    if(!hDevice){
        return FALSE;
    }

    pBufferKeyValue = pRegQueryStringValue(hDevice, TEXT("Class"), NULL, 0);
    if(!pBufferKeyValue){
        return FALSE;
    }
    
    bCDROMDevice = !_tcsicmp(pBufferKeyValue, TEXT("CDROM"));

    pBufferKeyValue = pRegQueryStringValue(hDevice, DEVICE_CURRENT_DRIVE_LETTER_TEXT_ASSIGNMENT, NULL, 0);
    if(!pBufferKeyValue){
        return FALSE;
    }

    drivePath[0] = pBufferKeyValue[0];
    driveType = GetDriveType(drivePath);

    if(DriveType){
        *DriveType = driveType;
    }

    return bCDROMDevice? (DRIVE_CDROM == driveType): 
                         (DRIVE_NO_ROOT_DIR != driveType && DRIVE_UNKNOWN != driveType);
}

BOOL 
pGetDeviceType(
    IN  HKEY    hDevice, 
    OUT DWORD*  DriveType
    )
{

    if(!DriveType){
        return FALSE;
    }

    return pDoesDriveExist(hDevice, DriveType);
}

VOID 
pPreparePNPIDName(
    IN PTSTR deviceInfoRegKey
    )
{
    MYASSERT(deviceInfoRegKey);
    //
    // Replace '\\' with '&' in registry key to make PNPID
    //
    
    while(deviceInfoRegKey = _tcschr(deviceInfoRegKey, '\\')){
        *deviceInfoRegKey = '&';
    }
}

int __cdecl 
pControllerInfoCompare(
    IN const void * elem1, 
    IN const void * elem2
    )
{
    MYASSERT(elem1 && elem2);
    
    //
    // Sort controlers in next order: First IDE, after SCSI, 
    // inside each group(IDE and SCSI) sort by preliminary defined SCSIPortNumber
    //

#define PCONTROLLER_INFO_CAST(x) ((PCONTROLLER_INFO)x)

    if(PCONTROLLER_INFO_CAST(elem1)->ControllerType > PCONTROLLER_INFO_CAST(elem2)->ControllerType){
        return 1;
    }
    if(PCONTROLLER_INFO_CAST(elem1)->ControllerType < PCONTROLLER_INFO_CAST(elem2)->ControllerType){
        return -1;
    }
    if(PCONTROLLER_INFO_CAST(elem1)->SCSIPortNumber > PCONTROLLER_INFO_CAST(elem2)->SCSIPortNumber){
        return 1;
    }
    if(PCONTROLLER_INFO_CAST(elem1)->SCSIPortNumber < PCONTROLLER_INFO_CAST(elem2)->SCSIPortNumber){
        return -1;
    }
    MYASSERT(INVALID_SCSI_PORT == PCONTROLLER_INFO_CAST(elem1)->SCSIPortNumber);
    return 0;
}

BOOL 
pGatherControllersInfo(
    IN OUT  PCONTROLLER_INFO ActiveControllersOut, 
    IN OUT  PUINT NumberOfActiveControllersOut
    )
{
    TCHAR regkeyName[MAX_REG_SIZE];
    TCHAR deviceInfoRegKey[MAX_REG_SIZE];
    TCHAR deviceData[MAX_REG_SIZE];
    TCHAR ideHardwareID[MAX_PNPID_SIZE];
    HKEY hActiveDevicesRoot = NULL;
    HKEY hActiveDeviceRoot = NULL;
    HKEY hDevice = NULL;
    UINT itemIndexRoot;
    DWORD bufferLength;
    PTSTR pDelimeter;
    UINT indexAvailable = 0;
    UINT scsiPortNumber;
    UINT controllerStartIndex = 0;
    UINT controllersSubNumber;
    PCONTROLLER_INFO controllerInfo;
    UINT i;
    UINT j;
    CONTROLLER_TYPE deviceType;
    BOOL bROOTDevice;
    UINT ideCounter;
    DWORD rcResult;
    static CONTROLLER_TYPE controllerTypes[] = {CONTROLLER_ON_BOARD_IDE, CONTROLLER_EXTRA_IDE, CONTROLLER_SCSI};

    if(!NumberOfActiveControllersOut){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try{
        if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_DYN_DATA, TEXT("Config Manager\\Enum"), 0, KEY_READ, &hActiveDevicesRoot)){
            return FALSE;
        }
        
        //
        // Looking for IDE and SCSI controllers in list of active hardware
        // under "HKDD\Config Manager\Enum"
        //
        for(itemIndexRoot = 0; ;itemIndexRoot++){
            bufferLength = ARRAYSIZE(regkeyName);
            
            rcResult = RegEnumKeyEx(hActiveDevicesRoot, 
                                    itemIndexRoot, 
                                    regkeyName, 
                                    &bufferLength, 
                                    0, 
                                    NULL, 
                                    NULL, 
                                    NULL);
            if(ERROR_SUCCESS != rcResult){
                break;
            }
                
            if(ERROR_SUCCESS != RegOpenKeyEx(hActiveDevicesRoot, regkeyName, 0, KEY_READ, &hActiveDeviceRoot)){
                continue;
            }

            do{
                //
                // "HardWareKey" consist key path to real device
                //
                if(pRegQueryStringValue(hActiveDeviceRoot, 
                                        TEXT("HardWareKey"), 
                                        regkeyName, 
                                        sizeof(regkeyName))){
                    if(!_tcsnicmp(regkeyName, TEXT("ROOT"), 4)){
                        //
                        // Sometime on board IDE controllers has preserved PNPID under ROOT, 
                        // and is not represented in MF\CHILD000x.
                        //
                        bROOTDevice = TRUE;
                        deviceType = CONTROLLER_ON_BOARD_IDE;
                    }else
                    {
                        if(!_tcsnicmp(regkeyName, TEXT("MF\\CHILD"), 8)){
                            deviceType = CONTROLLER_ON_BOARD_IDE;
                        }else if(!_tcsnicmp(regkeyName, TEXT("PCI"), 3)){
                            deviceType = CONTROLLER_SCSI;
                        }else{
                            //deviceType = CONTROLLER_UNKNOWN;
                            break;
                        }
                        bROOTDevice = FALSE;
                    }

                    _tcscpy(deviceInfoRegKey, TEXT("Enum\\"));
                    _tcscat(deviceInfoRegKey, regkeyName);
                    //
                    // Open reg key where resides all device infomation
                    //
                    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, deviceInfoRegKey, 0, KEY_READ, &hDevice)){
                        controllerInfo = ActiveControllersOut + indexAvailable;
                        //
                        // Replace '\\' with '&' in registry key to make PNPID
                        //
                        pPreparePNPIDName(regkeyName);

                        switch(deviceType){
                        case CONTROLLER_ON_BOARD_IDE:
                            {
                                if(pRegQueryStringValue(hDevice, 
                                                        TEXT("HardwareID"), 
                                                        ideHardwareID, 
                                                        sizeof(deviceData))){
                                    scsiPortNumber = INVALID_SCSI_PORT;
                                    //
                                    // "MF\\GOODPRIMARY" and "MF\\GOODSECONDARY" are pnpid for 
                                    // on board IDE Primary and Secondary Channel controllers.
                                    // And they always has constant SCSIPortNumber 0 or 1 respectively
                                    // for NT enum and marked as CONTROLLER_ON_BOARD_IDE.
                                    // Leave INVALID_SCSI_PORT(SCSIPortNumber) for extra IDE controllers 
                                    // and mark them as CONTROLLER_EXTRA_IDE.
                                    //
                                    for(ideCounter = 0; ideCounter < ARRAYSIZE(g_knownIDEControllers); ideCounter++){
                                        if(!_tcsnicmp(ideHardwareID, 
                                                      g_knownIDEControllers[ideCounter].pnpId, 
                                                      _tcslen(g_knownIDEControllers[ideCounter].pnpId))){
                                            scsiPortNumber = g_knownIDEControllers[ideCounter].defaultSCSIPort;
                                            break;
                                        }
                                    }
                                
                                    if(bROOTDevice && INVALID_SCSI_PORT == scsiPortNumber){
                                        //
                                        // Ignore this case, devices is not IDE controller.
                                        //
                                        break;
                                    }

                                    if(ActiveControllersOut){
                                        MYASSERT(controllerInfo->SCSIPortNumber == INVALID_SCSI_PORT);
                                        _tcscpy(controllerInfo->PNPID, regkeyName);
                                        controllerInfo->SCSIPortNumber = scsiPortNumber;
                                        controllerInfo->ControllerType = scsiPortNumber != INVALID_SCSI_PORT? 
                                                                                        CONTROLLER_ON_BOARD_IDE: CONTROLLER_EXTRA_IDE;
                                    }

                                    indexAvailable++;
                                }
                            }
                            break;
                        case CONTROLLER_SCSI:
                            {
                                //
                                // For SCSI controllers SCSIPortNumber calaculated from 
                                // "Driver" value and have "SCSIAdapter\000x" where x 
                                // is SCSIPortNumber. For SCSI controllers SCSIPortNumber
                                // will be postprocessed after enum.
                                // Mark as CONTROLLER_SCSI.
                                //
                                if(pRegQueryStringValue(hDevice, 
                                                        TEXT("Driver"), 
                                                        deviceData, 
                                                        sizeof(deviceData))){
                                    pDelimeter = _tcschr(deviceData, '\\');
                                    if(pDelimeter){
                                        *pDelimeter = '\0';
                                        if(!_tcsicmp(deviceData, TEXT("SCSIAdapter"))){
                                            scsiPortNumber = _ttoi(++pDelimeter);
                                            if(ActiveControllersOut){
                                                MYASSERT(controllerInfo->SCSIPortNumber == INVALID_SCSI_PORT);
                                                _tcscpy(controllerInfo->PNPID, regkeyName);
                                                controllerInfo->SCSIPortNumber = scsiPortNumber;
                                                controllerInfo->ControllerType = CONTROLLER_SCSI;
                                            }
                                            indexAvailable++;
                                        }
                                    }
                                }
                            }
                            break;
                        default:
                            MYASSERT(FALSE);
                        }
                
                        RegCloseKey(hDevice);hDevice = NULL;
                    }
                }
            }while(FALSE);
            
            RegCloseKey(hActiveDeviceRoot);hActiveDeviceRoot = NULL;
        }

        *NumberOfActiveControllersOut = indexAvailable;

        if(ActiveControllersOut){
            //
            // Sort controlers in next order: First IDE, after SCSI, 
            // inside each group(IDE and SCSI) sort by preliminary defined SCSIPortNumber
            //
            qsort(ActiveControllersOut, indexAvailable, sizeof(ActiveControllersOut[0]), pControllerInfoCompare);
            //
            // Update port number for SCSI devices.
            // User could add new SCSIAdapter and after remove old SCSIAdapter, 
            // it cause that SCSIAdapterNumber will be not effective, 
            // because for NT it will be (SCSIAdapterNumber - 1)
            //
            for(i = 0, j = 0; j < indexAvailable; j++){
                if(CONTROLLER_SCSI != ActiveControllersOut[j].ControllerType){
                    continue;
                }
                //
                // Now SCSI controllers sorted, reassign PortNumber 
                // by right order, in order to recognize in NT.
                //
                ActiveControllersOut[j].SCSIPortNumber = i++;
            }
            
            //
            // Calculate effective SCSIPortNumber, 
            // 0 - IDE Primary, 1 - IDE Secondary, 2 and ... - SCSI
            //
            for(controllerStartIndex = 0, i = 0; 
                i < ARRAYSIZE(controllerTypes); 
                i++, controllerStartIndex += controllersSubNumber){
                for(controllersSubNumber = 0, j = 0; j < indexAvailable; j++){
                    if(controllerTypes[i] != ActiveControllersOut[j].ControllerType){
                        continue;
                    }
                    if(INVALID_SCSI_PORT != ActiveControllersOut[j].SCSIPortNumber){
                        ActiveControllersOut[j].SCSIPortNumber += controllerStartIndex;
                    }
                    controllersSubNumber++;
                }
            }
        }
    }
    __finally{
        if(hDevice){
            RegCloseKey(hDevice);
        }
        if(hActiveDeviceRoot){
            RegCloseKey(hActiveDeviceRoot);
        }
        if(hActiveDevicesRoot){
            RegCloseKey(hActiveDevicesRoot);
        }
    }

    return TRUE;
}

BOOL 
GatherControllersInfo(
    IN OUT  PCONTROLLERS_COLLECTION * ControllersCollectionOut
    )
{
    DWORD rcResult = ERROR_ACCESS_DENIED;
    UINT i;
    PCONTROLLERS_COLLECTION activeControllersCollection = NULL;
    BOOL bResult = FALSE;
    UINT activeControllersNumber;

    if(!ControllersCollectionOut){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try{
        activeControllersCollection = (PCONTROLLERS_COLLECTION)MALLOC(sizeof(CONTROLLERS_COLLECTION));
        if(!activeControllersCollection){
            rcResult = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        
        //
        // Acquiring number of controllers in system
        //
        if(!pGatherControllersInfo(NULL, &activeControllersCollection->NumberOfControllers)){
            rcResult = ERROR_ACCESS_DENIED;
            __leave;
        }

        //
        // Proceed only if we have positive controllers number
        //
        if(activeControllersCollection->NumberOfControllers){
            activeControllersCollection->ControllersInfo = (PCONTROLLER_INFO)
                MALLOC(activeControllersCollection->NumberOfControllers * sizeof(CONTROLLER_INFO));
            if(!activeControllersCollection->ControllersInfo){
                rcResult = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }

            //
            // Initialize array
            //
            memset(activeControllersCollection->ControllersInfo, 
                   0, 
                   activeControllersCollection->NumberOfControllers * sizeof(CONTROLLER_INFO));
            for(i = 0; i < activeControllersCollection->NumberOfControllers; i++){
                activeControllersCollection->ControllersInfo[i].SCSIPortNumber = INVALID_SCSI_PORT;
            }

            //
            // fill out controllers info array
            //
            activeControllersNumber = activeControllersCollection->NumberOfControllers;
            if(!pGatherControllersInfo(activeControllersCollection->ControllersInfo, 
                                       &activeControllersNumber)){
                rcResult = ERROR_ACCESS_DENIED;
                __leave;
            }
        }
        else{
            activeControllersCollection->ControllersInfo = NULL;
        }
        
        *ControllersCollectionOut = activeControllersCollection;

        rcResult = ERROR_SUCCESS;
    }
    __finally{
        if(ERROR_SUCCESS != rcResult){
            if(activeControllersCollection){
                ReleaseControllersInfo(activeControllersCollection);
            }
        }
    }

    SetLastError(rcResult);

    return ERROR_SUCCESS == rcResult;
}

BOOL 
ReleaseControllersInfo(
    IN PCONTROLLERS_COLLECTION ControllersCollection
    )
{
    if(!ControllersCollection){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if(ControllersCollection){
        if(ControllersCollection->ControllersInfo){
            FREE(ControllersCollection->ControllersInfo);
        }
        FREE(ControllersCollection);
    }
    
    return TRUE;
}

BOOL 
IsInControllerCollection(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  PCTSTR          PnPIdString, 
    OUT PUINT           Index
    )
{
    UINT i;
    
    if(!ControllersCollection || !PnPIdString || !Index){
        return FALSE;
    }

    for(i = 0; i < ControllersCollection->NumberOfControllers; i++){
        if(!_tcsnicmp(PnPIdString, 
                      ControllersCollection->ControllersInfo[i].PNPID, 
                      _tcslen(ControllersCollection->ControllersInfo[i].PNPID))){
            *Index = i;
            return TRUE;
        }
    }

    return FALSE;
}


BOOL 
GetSCSIAddressFromPnPId(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  HKEY            hDeviceRegKey, 
    IN  PCTSTR          PnPIdString, 
    OUT DRIVE_SCSI_ADDRESS *  ScsiAddressOut
    )
{
    UINT i;
    PCTSTR pBufferKeyValue;
    BOOL bResult;

    if(!ControllersCollection || !hDeviceRegKey || !PnPIdString || !ScsiAddressOut){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    bResult = FALSE;
    
    do{
        //
        // Check for presence in controllers list controller PNPID of device
        // After complete SCSI_ADDRESS structure with
        // DriveLetter, DriveType, TargetID, Lun.
        //
        if(IsInControllerCollection(ControllersCollection, PnPIdString, &i)){
            
            memset(ScsiAddressOut, 0, sizeof(*ScsiAddressOut));

            ScsiAddressOut->PortNumber = (UCHAR)ControllersCollection->ControllersInfo[i].SCSIPortNumber;
            bResult = pGetDeviceType(hDeviceRegKey, &ScsiAddressOut->DriveType);
            MYASSERT(bResult);
        
            pBufferKeyValue = pRegQueryStringValue(hDeviceRegKey, 
                                                   DEVICE_CURRENT_DRIVE_LETTER_TEXT_ASSIGNMENT, 
                                                   NULL, 
                                                   0);
            if(!pBufferKeyValue){
                break;
            }
            ScsiAddressOut->DriveLetter = pBufferKeyValue[0];

            pBufferKeyValue = pRegQueryStringValue(hDeviceRegKey, TEXT("ScsiTargetId"), NULL, 0);
            if(!pBufferKeyValue){
                break;
            }
            ScsiAddressOut->TargetId = (UCHAR)_ttoi(pBufferKeyValue);

            pBufferKeyValue = pRegQueryStringValue(hDeviceRegKey, TEXT("ScsiLun"), NULL, 0);
            if(pBufferKeyValue){
                //
                //For most cases ScsiLun is zero, so it is not fatal.
                //
                ScsiAddressOut->Lun = (UCHAR)_ttoi(pBufferKeyValue);
            }

            bResult = TRUE;
        }
    }while(FALSE);

    return bResult;
}

BOOL 
DeviceEnum(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  PCTSTR DeviceCategory, 
    IN  PDEVICE_ENUM_CALLBACK_FUNCTION  DeviceEnumCallbackFunction, 
    IN  PVOID   CallbackData
    )
{
    TCHAR deviceType[MAX_REG_SIZE];
    TCHAR regkeyName[MAX_PNPID_SIZE];
    TCHAR deviceInfoRegKey[MAX_REG_SIZE];
    HKEY hActiveDevicesRoot = NULL;
    HKEY hActiveDeviceRoot = NULL;
    HKEY hDevice = NULL;
    UINT itemIndexRoot;
    DWORD bufferLength;
    UINT controllerIndex;
    PTSTR pDevicePNPIDName;
    UINT deviceTypeLen;
    DWORD rcResult;

    if(!ControllersCollection || !DeviceCategory || !DeviceEnumCallbackFunction){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try{
        if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_DYN_DATA, TEXT("Config Manager\\Enum"), 0, KEY_READ, &hActiveDevicesRoot)){
            return FALSE;
        }
        
        _tcscpy(deviceType, DeviceCategory);
        _tcscat(deviceType, TEXT("\\"));
        deviceTypeLen = _tcslen(deviceType);

        //
        // Looking for devices that attached to controllers in our list
        //
        for(itemIndexRoot = 0; ;itemIndexRoot++){
            bufferLength = ARRAYSIZE(regkeyName);
            
            rcResult = RegEnumKeyEx(hActiveDevicesRoot, 
                                    itemIndexRoot, 
                                    regkeyName, 
                                    &bufferLength, 
                                    0, 
                                    NULL, 
                                    NULL, 
                                    NULL);
            if(ERROR_SUCCESS != rcResult){
                break;
            }
                
            if(ERROR_SUCCESS != RegOpenKeyEx(hActiveDevicesRoot, regkeyName, 0, KEY_READ, &hActiveDeviceRoot)){
                continue;
            }

            //
            // "HardWareKey" consist key path to real device
            //
            if(pRegQueryStringValue(hActiveDeviceRoot, 
                                    TEXT("HardWareKey"), 
                                    regkeyName, 
                                    sizeof(regkeyName))){
                
                if(!_tcsnicmp(regkeyName, deviceType, deviceTypeLen)){
                    _tcscpy(deviceInfoRegKey, TEXT("Enum\\"));
                    _tcscat(deviceInfoRegKey, regkeyName);

                    //
                    // Make a Controller PNPID from device PNPID
                    //
                    pDevicePNPIDName = _tcsrchr(regkeyName, '\\');
                    MYASSERT(pDevicePNPIDName);
                    pDevicePNPIDName++;
                    
                    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, deviceInfoRegKey, 0, KEY_READ, &hDevice)){
                        //
                        // Check for presence Controller PNPID in controllers list and 
                        // for device availability.
                        //
                        if(IsInControllerCollection(ControllersCollection, pDevicePNPIDName, &controllerIndex) && 
                           pDoesDriveExist(hDevice, NULL)){
                            //
                            // Call callback for every active device we found, 
                            // which controller in our list
                            // Stop enum, if user does not want to.
                            //
                            if(!DeviceEnumCallbackFunction(hDevice, ControllersCollection, controllerIndex, CallbackData)){
                                //
                                // Stop enum, if user does not want to.
                                //
                                __leave;
                            }
                        }
                        RegCloseKey(hDevice);hDevice = NULL;
                    }
                }
            }

            RegCloseKey(hActiveDeviceRoot);hActiveDeviceRoot = NULL;
        }
    }
    __finally{
        if(hDevice){
            RegCloseKey(hDevice);
        }
        if(hActiveDeviceRoot){
            RegCloseKey(hActiveDeviceRoot);
        }
        if(hActiveDevicesRoot){
            RegCloseKey(hActiveDevicesRoot);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\i386\devenum.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    devenum.h

Abstract:

    Code for enum IDE ans SCSI controllers and attached to them storage devices 
    and calculate for them SCSI Address.

Author:

    Souren Aghajanyan (sourenag)    05-June-2001

Revision History:

--*/

#pragma once

#define ARRAYSIZE(x)   (sizeof(x)/sizeof(x[0]))

#define MAX_PNPID_SIZE MAX_PATH+1
#define MAX_REG_SIZE   512
#define INVALID_SCSI_PORT       0xffffffff
#define REG_ENUM_INVALID_INDEX  0xffffffff

typedef enum tagCONTROLLER_TYPE{
    CONTROLLER_UNKNOWN      = 0, 
    CONTROLLER_ON_BOARD_IDE = 1, 
    CONTROLLER_EXTRA_IDE    = 2, 
    CONTROLLER_SCSI         = 3, 
}CONTROLLER_TYPE;

typedef struct tagCONTROLLER_INFO
{
    CONTROLLER_TYPE ControllerType;
    TCHAR   PNPID[MAX_PNPID_SIZE];
    UINT    SCSIPortNumber;
}CONTROLLER_INFO, *PCONTROLLER_INFO;


typedef struct tagCONTROLLERS_COLLECTION{
    UINT NumberOfControllers;
    PCONTROLLER_INFO ControllersInfo;
}CONTROLLERS_COLLECTION, *PCONTROLLERS_COLLECTION;

typedef struct tagDRIVE_SCSI_ADDRESS
{
    DWORD   DriveType;
    TCHAR   DriveLetter;
    UCHAR   PortNumber;
    UCHAR   TargetId;
    UCHAR   Lun;
}DRIVE_SCSI_ADDRESS, *PDRIVE_SCSI_ADDRESS;

typedef BOOL (*GATHERCONTROLLERINFO)(
    IN OUT  PCONTROLLER_INFO ActiveControllersOut, 
    IN OUT  PUINT NumberOfActiveControllersOut
    );
typedef BOOL (*PDEVICE_ENUM_CALLBACK_FUNCTION)(
    IN  HKEY    hDevice, 
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  UINT    ControllerIndex, 
    IN  PVOID   CallbackData);

BOOL 
GatherControllersInfo(
    IN OUT  PCONTROLLERS_COLLECTION * ControllersCollectionOut
    );

BOOL 
ReleaseControllersInfo(
    IN PCONTROLLERS_COLLECTION ControllersCollection
    );

BOOL 
GetSCSIAddressFromPnPId(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  HKEY            hDeviceRegKey, 
    IN  PCTSTR          PnPIdString, 
    OUT DRIVE_SCSI_ADDRESS *  ScsiAddressOut
    );

BOOL 
GetDeviceType(
    IN  HKEY    hDevice, 
    OUT DWORD*  DriveType
    );

BOOL 
DoesDriveExist(
    IN  HKEY    hDevice, 
    OUT DWORD*  DriveType
    );

BOOL 
DeviceEnum(
    IN  PCONTROLLERS_COLLECTION ControllersCollection, 
    IN  PCTSTR DeviceCategory, 
    IN  PDEVICE_ENUM_CALLBACK_FUNCTION  DeviceEnumCallbackFunction, 
    IN  PVOID   CallbackData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\i386\drvlettr.c ===
#include "precomp.h"
#include "devenum.h"

#define NUMDRIVELETTERS      26

// drvletter struct.
typedef struct _DRIVELETTERS {

    BOOL    ExistsOnSystem[NUMDRIVELETTERS];
    DWORD   Type[NUMDRIVELETTERS];              // Returned from GetDriveType
    TCHAR   IdentifierString[NUMDRIVELETTERS][MAX_PATH];  // Varies by Drive type.

} DRIVELETTERS, *PDRIVELETTERS;

DRIVELETTERS g_DriveLetters;

PCTSTR DriveTypeAsString(
    IN UINT Type
    )
{
    static PCTSTR driveTypeStrings[] = {
        TEXT("DRIVE_UNKNOWN"),        //The drive type cannot be determined.
        TEXT("DRIVE_NO_ROOT_DIR"),    //The root directory does not exist.
        TEXT("DRIVE_REMOVABLE"),      //The disk can be removed from the drive.
        TEXT("DRIVE_FIXED"),          //The disk cannot be removed from the drive.
        TEXT("DRIVE_REMOTE"),         //The drive is a remote (network) drive.
        TEXT("DRIVE_CDROM"),          //The drive is a CD-ROM drive.
        TEXT("DRIVE_RAMDISK"),        //The drive is a RAM disk.
    };

    return driveTypeStrings[Type];
}

BOOL
InitializeDriveLetterStructure (
    VOID
    )
{
    DWORD DriveLettersOnSystem = GetLogicalDrives();
    BYTE  bitPosition;
    DWORD maxBitPosition = NUMDRIVELETTERS;
    TCHAR rootPath[4];
    BOOL  driveExists;
    UINT  type;
    BOOL  rf = TRUE;


    //
    //rootPath[0] will be set to the drive letter of interest.
    //
    rootPath[1] = TEXT(':');
    rootPath[2] = TEXT('\\');
    rootPath[3] = TEXT('\0');

    //
    // GetLogicalDrives returns a bitmask of all of the drive letters
    // in use on the system. (i.e. bit position 0 is turned on if there is
    // an 'A' drive, 1 is turned on if there is a 'B' drive, etc.
    // This loop will use this bitmask to fill in the global drive
    // letters structure with information about what drive letters
    // are available and what there drive types are.
    //

    for (bitPosition = 0; bitPosition < maxBitPosition; bitPosition++) {

        //
        // Initialize the entry to safe values.
        //
        g_DriveLetters.Type[bitPosition]                   = 0;
        g_DriveLetters.ExistsOnSystem[bitPosition]         = FALSE;
        *g_DriveLetters.IdentifierString[bitPosition]      = 0;

        //
        // Now, determine if there is a drive in this spot.
        //
        driveExists = DriveLettersOnSystem & (1 << bitPosition);

        if (driveExists) {

            //
            // There is. Now, see if it is one that we care about.
            //
            *rootPath = bitPosition + TEXT('A');
            type = GetDriveType(rootPath);

            if (type == DRIVE_FIXED     ||
                type == DRIVE_REMOVABLE ||
                type == DRIVE_CDROM) {

                //
                // This is a drive that we are interested in.
                //
                g_DriveLetters.ExistsOnSystem[bitPosition]  = driveExists;
                g_DriveLetters.Type[bitPosition]            = type;

                //
                // Identifier String is not filled in this function.
                //
            }
        }
    }


    return rf;
}

VOID
CleanUpHardDriveTags (
    VOID
    )
{
    //
    // User cancelled. We need to clean up the tag files
    // that were created for drive migration.
    //
    UINT i;
    TCHAR  path[MAX_PATH];

    lstrcpy(path,TEXT("*:\\"));
    lstrcat(path,TEXT(WINNT_WIN95UPG_DRVLTR_A));


    for (i = 0; i < NUMDRIVELETTERS; i++) {

        if (g_DriveLetters.ExistsOnSystem[i] &&
            g_DriveLetters.Type[i] == DRIVE_FIXED) {

            *path = (TCHAR) i + TEXT('A');
            DeleteFile (path);
        }
    }
}


BOOL
GatherHardDriveInformation (
    VOID
    )
{
    BOOL        rf = TRUE;
    DWORD       index;
    HANDLE      signatureFile;
    TCHAR       signatureFilePath[sizeof (WINNT_WIN95UPG_DRVLTR_A) + 3];
    DWORD       signatureFilePathLength;
    DWORD       bytesWritten;

    //
    // Hard drive information is actually written to a special signature file
    // on the root directory of each fixed hard drive. The information is nothing special --
    // just the drive number (0 = A, etc.)
    //

    lstrcpy(signatureFilePath,TEXT("*:\\"));
    lstrcat(signatureFilePath,TEXT(WINNT_WIN95UPG_DRVLTR_A));
    signatureFilePathLength = lstrlen(signatureFilePath);



    for (index = 0; index < NUMDRIVELETTERS; index++) {

        if (g_DriveLetters.ExistsOnSystem[index] &&
            g_DriveLetters.Type[index] == DRIVE_FIXED) {

            *signatureFilePath = (TCHAR) index + TEXT('A');

            signatureFile = CreateFile(
                signatureFilePath,
                GENERIC_WRITE | GENERIC_READ,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

            if (signatureFile != INVALID_HANDLE_VALUE) {

                WriteFile (signatureFile, &index, sizeof(DWORD), &bytesWritten, NULL);



                CloseHandle (signatureFile);
                SetFileAttributes (signatureFilePath, FILE_ATTRIBUTE_HIDDEN);


            }
        }
    }


    return rf;
}

/*BOOL
GatherCdRomDriveInformation (
    VOID
    )

{
    BOOL   rf = TRUE;
    HKEY   scsiKey = NULL;
    HKEY   deviceKey = NULL;

    TCHAR  classData[25];
    DWORD  classDataSize = 25;

    TCHAR  targetData[5];
    DWORD  targetDataSize = 5;

    TCHAR  lunData[5];
    DWORD  lunDataSize = 5;

    TCHAR  driveLetterData[5];
    DWORD  driveLetterSize = 5;

    TCHAR  buffer [4096];
    DWORD  subKeyLength;
    DWORD  tempLength;

    HKEY   locationKey = NULL;
    PTSTR  locationName;

    DWORD  outerIndex;
    DWORD  enumReturn;

    DWORD  port;
    DWORD  unusedType;
    DWORD  error;
    
    
    //
    // Walk the SCSI tree looking for CD rom devices.
    //
    error = RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("ENUM\\SCSI"), 0, KEY_READ, &scsiKey);

    if (error) {

        return TRUE;
    }

    //
    // Gather information about the key in preparation for enumerating
    // it.
    //
    error = RegQueryInfoKey (
        scsiKey,
        NULL,                   // Don't care about the class.
        NULL,                   // class size.
        NULL,                   // reserved.
        NULL,                   // Don't care about the number of subkeys.
        &subKeyLength,
        NULL,                   // Don't care about subclasses.
        NULL,                   // Don't care about values.
        NULL,                   // Don't care about max value name length.
        NULL,                   // Don't care about max component.
        NULL,                   // Don't care about the security descriptor.
        NULL                    // Don't care about the last write time.
        );

    if (error) {
        //
        // This should really not happen.
        //
        return FALSE;
    }



    //
    // Succssesfully opened a key to HKLM\Enum\SCSI. Enumerate it.
    //
    outerIndex = 0;
    do {

        if (locationKey) {

            RegCloseKey (locationKey);
            locationKey = NULL;
        }
        if (deviceKey) {

            RegCloseKey (deviceKey);
            deviceKey = NULL;
        }


        tempLength = sizeof(buffer) / sizeof(TCHAR);

        enumReturn = RegEnumKeyEx (
            scsiKey,
            outerIndex,
            buffer,
            &tempLength,
            0,                // Reserved
            NULL,             // Class name - not necessary.
            NULL,             // size of class name buffer.
            NULL
            );

        outerIndex++;

        //
        // For each returned key, look up the "Class" value.
        //
        error = RegOpenKeyEx (scsiKey,buffer,0,KEY_READ,&deviceKey);
        if (error) {

            //
            // Something is hosed. Give up on collecting SCSI data.
            //
            rf = FALSE;
            break;
        }


        //
        // The port has to be decoded from the key one level
        // below.
        //
        tempLength = sizeof (buffer) / sizeof(TCHAR);

        error = RegEnumKeyEx (
            deviceKey,
            0,
            buffer,
            &tempLength,
            0,                // Reserved
            NULL,             // Class name - not necessary.
            NULL,             // size of class name buffer.
            NULL
            );

        error = RegOpenKeyEx (deviceKey, buffer, 0, KEY_READ, &locationKey);

        if (error) {

            //
            // This should really never happen. However, guard against it.
            // Its not serious enough to abort the search. Just skip this
            // particular key and continue.
            //
            continue;
        }



        tempLength = classDataSize;
        error = RegQueryValueEx(
            locationKey,
            TEXT("CLASS"),
            0,
            &unusedType,
            (PBYTE) classData,
            &tempLength
            );

        if (error) {

            //
            // This isn't a serious enough error to bring down the whole
            // enumeration. Just note it in the logs and continue to the
            // next key.
            //
            continue;
        }

        if (!lstrcmpi(classData, TEXT("CDROM"))) {


            lstrcpy (targetData, TEXT("-1"));
            lstrcpy (lunData, TEXT("-1"));
            lstrcpy (driveLetterData, TEXT("%"));

            //
            // Found a CdRom. Get the information that will be used in
            // textmode setup to identify the drive.
            //
            tempLength = targetDataSize;
            RegQueryValueEx(
                locationKey,
                TEXT("ScsiTargetId"),
                0,
                &unusedType,
                (PBYTE) targetData,
                &tempLength
                );

            tempLength = lunDataSize;
            RegQueryValueEx(
                locationKey,
                TEXT("ScsiLun"),
                0,
                &unusedType,
                (PBYTE) lunData,
                &tempLength
                );

            tempLength = driveLetterSize;
            RegQueryValueEx(
                locationKey,
                TEXT("CurrentDriveLetterAssignment"),
                0,
                &unusedType,
                (PBYTE) driveLetterData,
                &tempLength
                );




            if (*driveLetterData != TEXT('%')) {

                //
                // At this point, we have all of the information
                // necessary to write a SCSI CdRom identifier
                // string.
                //

                wsprintf(g_DriveLetters.IdentifierString[*driveLetterData - TEXT('A')], TEXT("%u^%s^%s"), 1, targetData, lunData);


            }

        }

        if (locationKey) {

            RegCloseKey (locationKey);
            locationKey = NULL;
        }
        if (deviceKey) {

            RegCloseKey (deviceKey);
            deviceKey = NULL;
        }



    } while (rf && enumReturn == ERROR_SUCCESS);

    if (locationKey) {
        RegCloseKey(locationKey);
        locationKey = NULL;
    }
    if (deviceKey) {
        RegCloseKey(deviceKey);
        deviceKey = NULL;
    }
    if (scsiKey) {
        RegCloseKey(scsiKey);
        scsiKey = NULL;
    }



    return rf;
}*/

BOOL pCDROMDeviceEnumCallback(
    IN  HKEY   hDevice, 
    IN  PCONTROLLERS_COLLECTION    ControllersCollection, 
    IN  UINT   ControllerIndex, 
    IN  PVOID  CallbackData
    )
{
    DRIVE_SCSI_ADDRESS scsiAddress;
    BOOL bResult;
    
    MYASSERT(hDevice && ControllersCollection);

    bResult = GetSCSIAddressFromPnPId(ControllersCollection, 
                                      hDevice, 
                                      ControllersCollection->ControllersInfo[ControllerIndex].PNPID, 
                                      &scsiAddress);
    
    MYASSERT(bResult);

    if(bResult && 
       ((UCHAR)INVALID_SCSI_PORT) != scsiAddress.PortNumber && 
       DRIVE_CDROM == scsiAddress.DriveType){
        wsprintf(g_DriveLetters.IdentifierString[scsiAddress.DriveLetter - TEXT('A')], 
                 TEXT("%u^%u^%u"), 
                 (UINT)scsiAddress.PortNumber, 
                 (UINT)scsiAddress.TargetId, 
                 (UINT)scsiAddress.Lun);
    }

    return TRUE;
}

BOOL
GatherCdRomDriveInformation (
    VOID
    )
{
    PCONTROLLERS_COLLECTION ControllersCollection;
    UINT i;
    BOOL bResult;
    BOOL bDetectedExtraIDEController = FALSE;
    UINT numberOfSCSIController = 0;

    //
    // Collect all active IDE and SCSI controllers
    //
    bResult = GatherControllersInfo(&ControllersCollection);
    if(!bResult){
        MYASSERT(FALSE);
        return FALSE;
    }

    MYASSERT(ControllersCollection->ControllersInfo);
    for(i = 0; i < ControllersCollection->NumberOfControllers; i++){
        switch(ControllersCollection->ControllersInfo[i].ControllerType){
        case CONTROLLER_EXTRA_IDE:
            bDetectedExtraIDEController = TRUE;
            break;
        case CONTROLLER_SCSI:
            numberOfSCSIController++;
            break;
        }
    }

    if(bDetectedExtraIDEController){
        DebugLog(Winnt32LogWarning, TEXT("Setup has detected that machine have extra IDE controller(s). Setup may not preserve drive letters."), 0);
    }

    if(numberOfSCSIController > 1){
        DebugLog(Winnt32LogWarning, TEXT("Setup has detected that machine have more than one SCSI controllers. Setup may not preserve drive letters only for SCSI devices."), 0);
    }
    
    //
    // If we found extra IDE controller(s) we can't ensure rigth device detection in this case.
    // If we found more than one SCSI controllers without extra IDE controller(s), 
    // at least we can guarantee correct IDE devices detection.
    //
    bResult = DeviceEnum(ControllersCollection, 
                         TEXT("SCSI"), 
                         (PDEVICE_ENUM_CALLBACK_FUNCTION)pCDROMDeviceEnumCallback, 
                         NULL);
    MYASSERT(bResult);

    ReleaseControllersInfo(ControllersCollection);

    return bResult;
}




BOOL
WriteInfoToSifFile (
    IN PCTSTR FileName
    )
{
    BOOL    rSuccess = TRUE;
    DWORD   index;
    TCHAR   dataString[MAX_PATH * 2]; // Well over the size needed.
    TCHAR   driveString[20]; // Well over the size needed.
    PCTSTR  sectionString = WINNT_D_WIN9XDRIVES;




    for (index = 0; index < NUMDRIVELETTERS; index++) {

        if (g_DriveLetters.ExistsOnSystem[index]) {

            wsprintf(
                driveString,
                TEXT("%u"),
                index
                );

            wsprintf(
                dataString,
                TEXT("%u,%s"),
                g_DriveLetters.Type[index],
                g_DriveLetters.IdentifierString[index]
                );

            //
            // Ending string looks like <drive num>,<drive type>,<identifier string>
            //

            WritePrivateProfileString (sectionString, driveString, dataString, FileName);
        }

    }


    return rSuccess;
}



DWORD
SaveDriveLetterInformation (
    IN PCTSTR FileName
    )
{
    BOOL rf = TRUE;

    if (InitializeDriveLetterStructure ()) {

        GatherHardDriveInformation ();
        GatherCdRomDriveInformation ();
        WriteInfoToSifFile (FileName);

    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\i386\sectorio.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sectorio.c

Abstract:

    Routines to perform low-level sector I/O on either Windows NT or
    Windows 95.

Author:

    Ted Miller (tedm) 1 Nov 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <tlhelp32.h>


//
// Define structures for use with Win9x VWIN32.
// Note: alignment must be on 1-byte boundaries for these structures.
//
#include <pshpack1.h>

typedef struct _DIOC_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS;

typedef struct _DIOC_DISKIO {
    DWORD  StartSector;
    WORD   SectorCount;
    LPBYTE Buffer;
} DIOC_DISKIO;

#include <poppack.h>

//
// Local prot type
//
BOOL
NEC98_SpecialReadOrWriteNT(
    IN     TCHAR  Drive,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    );


//
// Define codes we care about for use with VWIN32
//
#define VWIN32_DIOC_DOS_IOCTL           1
#define VWIN32_DIOC_DOS_INT25           2
#define VWIN32_DIOC_DOS_INT26           3
#define VWIN32_DIOC_DOS_DRIVEINFO       6       // new in OSR2


BOOL
pGetWin9xLockFlagState (
    IN      HANDLE VWin32Vxd,
    IN      TCHAR  Drive,
    OUT     PINT LockStatus
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;

    *LockStatus = 0;

    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440D;

    //
    // bx = 1-based drive number
    //
    RegistersIn.reg_EBX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;

    //
    // cx = 0x86C (get lock flag state)
    //
    RegistersIn.reg_ECX = 0x86C;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if (b) {
        if (RegistersOut.reg_Flags & 1) {
            b = FALSE;
        } else {
            *LockStatus = RegistersOut.reg_EAX;
        }
    }

    return b;
}


typedef HANDLE(WINAPI *OPENTHREAD)(DWORD, BOOL, DWORD);


BOOL
pMakeThreadExclusive (
    BOOL Lock
    )
{
    HANDLE h;
    THREADENTRY32 e;
    DWORD thisThread;
    HANDLE threadHandle;
    OPENTHREAD openThreadFn;
    HMODULE lib;
    BOOL result = FALSE;

    lib = LoadLibrary (TEXT("kernel32.dll"));
    if (!lib) {
        goto c0;
    }

    openThreadFn = (OPENTHREAD) GetProcAddress (lib, "OpenThread");
    if (!openThreadFn) {
        //
        // Must be Win98 or Win98SE -- change thread priority as workaround
        //

        if (Lock) {
            result = SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
            Sleep (0);
        } else {
            result = SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);
        }

        goto c1;
    }

    thisThread = GetCurrentThreadId();

    h = CreateToolhelp32Snapshot (TH32CS_SNAPTHREAD, 0);
    if (h == INVALID_HANDLE_VALUE) {
        goto c1;
    }

    e.dwSize = sizeof (e);

    if (Thread32First (h, &e)) {
        do {
            if (e.th32ThreadID != thisThread) {
                threadHandle = openThreadFn (THREAD_SUSPEND_RESUME, FALSE, e.th32ThreadID);
                if (threadHandle) {
                    if (Lock) {
                        SuspendThread (threadHandle);
                    } else {
                        ResumeThread (threadHandle);
                    }

                    CloseHandle (threadHandle);
                }
            }
        } while (Thread32Next (h, &e));
    }

    CloseHandle (h);
    result = TRUE;

c1:
    FreeLibrary (lib);

c0:
    return result;

}


BOOL
ReadOrWriteSectorsWin9xOriginal(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    earlier than OSR2. Uses int25/26.

    This routine will fail on Windows NT.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = (DWORD)(TOUPPER(Drive) - TEXT('A'));
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            Write ? VWIN32_DIOC_DOS_INT26 : VWIN32_DIOC_DOS_INT25,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return(b);
}


BOOL
ReadOrWriteSectorsWin9xOsr2(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    OSR2 or later. Uses the new int21 function 7305 (Ext_ABSDiskReadWrite).

    This routine will fail on Windows NT and earlier versions of Windows 95.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = 0x7305;
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;
    RegistersIn.reg_EDX = (DWORD)(TOUPPER(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_ESI = Write ? 1 : 0;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_DRIVEINFO,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return(b);
}


BOOL
LockOrUnlockVolumeWin9x(
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive,
    IN UINT   Level,
    IN BOOL   Lock
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;
    BOOL Pass;

    Pass = 0;

retry:
    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440d;

    //
    // bl = 1-based drive number
    // bh = lock level
    //
    RegistersIn.reg_EBX = (DWORD)(TOUPPER(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_EBX |= (Level << 8);

    //
    // cl = lock or unlock volume code
    // ch = categoey, 8 on original Win95, 0x48 on OSR2
    //
    RegistersIn.reg_ECX = Lock ? 0x4a : 0x6a;
    RegistersIn.reg_ECX |= ((ISOSR2() && !Pass) ? 0x4800 : 0x800);

    //
    // dx = permissions
    //
    // bit 0 controls write operations (0 = disallowed)
    // bit 1 controls read operations  (0 = allowed)
    //
    RegistersIn.reg_EDX = 1;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    //
    // If OSR2, try form of call with 8 in ch instead of 48.
    //
    if(!b && ISOSR2() && !Pass) {
        Pass = 1;
        goto retry;
    }

    return(b);
}


BOOL
ReadOrWriteSectorsWin9x(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95.
    This routine will fail on Windows NT. After opening the VWIN32
    VxD, the routine determines whether to use the original algorithm
    or the OSR2 algorithm, and calls the appropriate worker routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set to something meaningful.

--*/

{
    HANDLE hVxd;
    BOOL b;
    DWORD d;
    INT level;
    INT retry = 100;

    //
    // This thread must be the exclusive thread in our process
    //

    pMakeThreadExclusive (TRUE);

    //
    // Open VWIN32.VXD
    //
    hVxd = CreateFileA(
                "\\\\.\\VWIN32",
                Write ? GENERIC_WRITE : GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hVxd == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c0;
    }

    //
    // Take out locks. We'll be as unrestrictive as possible.
    // The locking stuff is really funky. You have to pass in all kinds of
    // different parameters in OSR2 for reasons unknown. Also the
    // permissions bits are strangely encoded.
    //
    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,1,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c1;
    }

    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,2,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c2;
    }

    //
    // Try to get the level 3 lock. Retry if something happened while
    // getting the lock. Fail after too many retries.
    //

    do {

        if(!LockOrUnlockVolumeWin9x(hVxd,Drive,3,TRUE)) {
            d = ERROR_SHARING_VIOLATION;
            b = FALSE;
            goto c3;
        }

        if (!pGetWin9xLockFlagState (hVxd, Drive, &level)) {
            // unexpected -- INT 21h call failed
            break;
        }

        if (!level) {
            // We successfully got a clean level 3 lock
            break;
        }

        LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
        retry--;

    } while (retry);

    if (!retry) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c3;
    }

    //
    // Go do it.
    //
    b = ISOSR2()
      ? ReadOrWriteSectorsWin9xOsr2(hVxd,Drive,StartSector,SectorCount,Buffer,Write)
      : ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);

    //
    // If it failed, and OSR2 routine is being used, fall back to Win95 API.  This is a workaround
    // for Compaq because they ship OSR2 without the new OSR2 sector API support!
    //

    if (!b && ISOSR2()) {
        b = ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);
    }

    d = GetLastError();

    LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
c3:
    LockOrUnlockVolumeWin9x(hVxd,Drive,2,FALSE);
c2:
    LockOrUnlockVolumeWin9x(hVxd,Drive,1,FALSE);
c1:
    CloseHandle(hVxd);
c0:

    //
    // Resume all threads
    //

    pMakeThreadExclusive (FALSE);

    SetLastError(d);
    return(b);
}


BOOL
ReadOrWriteSectorsWinNt(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN     UINT   SectorSize,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows NT.
    This routine will fail on Win9x.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. This buffer must be aligned on a sector boundary.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set.

--*/

{
    HANDLE h;
    BOOL b;
    DWORD BytesXferred;
    TCHAR DeviceName[7];
    LONGLONG Offset;
    LONG OffsetHigh;
    DWORD d;

    if (IsNEC98() && (StartSector == 0) && (SectorCount == 1)){
	return(NEC98_SpecialReadOrWriteNT(Drive, Buffer, Write));
    }

    //
    // Open the device
    //
    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);
    h = CreateFile(
            DeviceName,
            Write ? GENERIC_WRITE : GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c0;
    }

    Offset = (LONGLONG)StartSector * (LONGLONG)SectorSize;
    OffsetHigh = (LONG)(Offset >> 32);

    //
    // We're passing in a 64-bit offset so we have to check last error
    // to distinguish the error case.
    //
    if((SetFilePointer(h,(DWORD)Offset,&OffsetHigh,FILE_BEGIN) == 0xffffffff)
    && (GetLastError() != NO_ERROR)) {

        d = GetLastError();
        b = FALSE;
        goto c1;
    }

    b = Write
      ? WriteFile(h,Buffer,SectorCount*SectorSize,&BytesXferred,NULL)
      : ReadFile(h,Buffer,SectorCount*SectorSize,&BytesXferred,NULL);

    d = GetLastError();

c1:
    CloseHandle(h);
c0:
    SetLastError(d);
    return(b);
}


BOOL
ReadOrWriteSectors(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN     UINT   SectorSize,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk. Allocates a properly
    aligned buffer and decides whether to call NT- or Win9x-specific
    i/o routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. There are no alignment requirements on ths buffer.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    Last error is undisturbed from the operation that caused any failure.

--*/

{
    LPBYTE AlignedBuffer;
    LPBYTE p;
    BOOL b;
    DWORD d;

    //
    // Allocate a buffer we will align on a sector boundary.
    //
    if(AlignedBuffer = MALLOC((SectorCount * SectorSize) + (SectorSize - 1))) {

        if(d = (DWORD)AlignedBuffer % SectorSize) {
            p = (PUCHAR)((DWORD)AlignedBuffer + (SectorSize - d));
        } else {
            p = AlignedBuffer;
        }

        if(Write) {
            CopyMemory(p,Buffer,SectorCount*SectorSize);
        }

        b = ISNT()
          ? ReadOrWriteSectorsWinNt(Drive,StartSector,SectorCount,SectorSize,p,Write)
          : ReadOrWriteSectorsWin9x(Drive,StartSector,SectorCount,p,Write);

        d = GetLastError();

        if(b && !Write) {
            CopyMemory(Buffer,p,SectorCount*SectorSize);
        }

        FREE(AlignedBuffer);

    } else {
        b = FALSE;
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(d);
    return(b);
}


BOOL
ReadDiskSectors(
    IN  TCHAR  Drive,
    IN  UINT   StartSector,
    IN  UINT   SectorCount,
    IN  UINT   SectorSize,
    OUT LPBYTE Buffer
    )

/*++

Routine Description:

    Read a set of disk sectors off a disk device.

Arguments:

    Drive - supplies drive letter of device to be read from.

    StartSector - supplies logical sector number of first sector to be read.

    SectorCount - supplies number of sectors to be read.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from.

    Buffer - if successful, receives data from the disk. There are no
        alignment requirements on ths buffer.

Return Value:

    Boolean value indicating whether the disk was read successfully.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,FALSE));
}


BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    )

/*++

Routine Description:

    Write data to a set of disk sectors.

Arguments:

    Drive - supplies drive letter of device to be written to.

    StartSector - supplies logical sector number of first sector to be written.

    SectorCount - supplies number of sectors to be written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be written to.

    Buffer - supplies data to be written. There are no alignment requirements
        on ths buffer.

Return Value:

    Boolean value indicating whether the disk was successfully written.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,TRUE));
}


MEDIA_TYPE
GetMediaTypeNt(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo
    )

/*++

Routine Description:

    Determine the type/form-factor of a given (floppy) drive.

    THIS ROUTINE WORKS ONLY ON WINDOWS NT.

Arguments:

    Drive - supplies drive letter of the drive in question.

Return Value:

    Value from the MEDIA_TYPE enum indicating the drive type, which is
    derived from the largest media that the device driver indicates the
    drive can support.

    LastError is not set or preserved.

--*/

{
    TCHAR DeviceName[7];
    HANDLE h;
    BOOL b;
    BYTE Buffer[5000];
    DWORD Size;
    DWORD d;
    UINT u;
    PDISK_GEOMETRY Geometry;
    MEDIA_TYPE MediaTypeOrder[] = { FixedMedia,             // Fixed hard disk media
                                    RemovableMedia,         // Removable media other than floppy
                                    F3_120M_512,            // 3.5", 120M Floppy
                                    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
                                    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
                                    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
                                    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
                                    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
                                    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
                                    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
                                    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
                                    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
                                    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
                                    Unknown,                // Format is unknown
                                    -1
                                  };


    //
    // We don't return drive information for NT
    //
    if (DriveInfo) {
        memset(DriveInfo, 0, sizeof(WINNT32_DRIVE_INFORMATION));
    }

    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);

    h = CreateFile(
            DeviceName,
            FILE_READ_ATTRIBUTES,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        return(Unknown);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_MEDIA_TYPES,
            NULL,
            0,
            Buffer,
            sizeof(Buffer),
            &Size,
            NULL
            );

    CloseHandle(h);

    if(!b) {
        return(Unknown);
    }

    Geometry = (PDISK_GEOMETRY)Buffer;

    //
    // Inefficient, but it works.
    //
    for(u=0; MediaTypeOrder[u] != -1; u++) {
        for(d=0; d<Size/sizeof(DISK_GEOMETRY); d++) {
            if(Geometry[d].MediaType == MediaTypeOrder[u]) {
                return(Geometry[d].MediaType);
            }
        }
    }

    //
    // We don't know what it is; assume it's some hot new type.
    //
    return(Size ? Geometry[0].MediaType : Unknown);
}


MEDIA_TYPE
GetMediaTypeWin9x(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo
    )

/*++

Routine Description:

    Determine the type/form-factor of a given (floppy) drive.

    THIS ROUTINE WORKS ONLY ON WINDOWS 9x.

Arguments:

    Drive - supplies drive letter of the drive in question.

Return Value:

    Value from the MEDIA_TYPE enum indicating the drive type, which is
    derived from the device type in the recommended BPB returned by
    the device driver for the drive.

    LastError is not set or preserved.

--*/

{
    HANDLE hVxd;
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;
    MEDIA_TYPE type;

    #include <pshpack1.h>
    struct {
        BYTE SpecialFunctions;
        BYTE DeviceType;
        WORD DeviceAttributes;
        WORD CylinderCount;
        BYTE MediaType;
        WORD BytesPerSector;
        BYTE SectorsPerCluster;
        WORD ReservedSectors;
        BYTE FatCount;
        WORD RootDirEntries;
        WORD SectorCount;
        BYTE MediaDescriptor;
        WORD SectorsPerFat;
        WORD SectorsPerTrack;
        WORD Heads;
        DWORD HiddenSectors;
        DWORD LargeSectorCount;
    } DeviceParams;
    #include <poppack.h>

    //
    // Open VWIN32.VXD
    //
    hVxd = CreateFileA(
                "\\\\.\\VWIN32",
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hVxd == INVALID_HANDLE_VALUE) {
        return(Unknown);
    }

    memset(&DeviceParams, 0, sizeof(DeviceParams));

    //
    // Set up registers for IOCTL call.
    //
    RegistersIn.reg_EAX = 0x440d;                   // IOCTL
    RegistersIn.reg_EBX = (Drive - TEXT('A')) + 1;  // 1-based drive in bl
    RegistersIn.reg_ECX = 0x860;                    // category = 8, func = get device params
    RegistersIn.reg_EDX = (DWORD)&DeviceParams;

    DeviceParams.SpecialFunctions = 0;

    b = DeviceIoControl(
            hVxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    CloseHandle(hVxd);

    if(!b && !(RegistersOut.reg_Flags & 1)) {
        return(Unknown);
    }

    if (DriveInfo) {
        memset(DriveInfo, 0, sizeof(WINNT32_DRIVE_INFORMATION));

        DriveInfo->CylinderCount = (DWORD)(DeviceParams.CylinderCount);
        DriveInfo->HeadCount = (DWORD)(DeviceParams.Heads);
        DriveInfo->SectorsPerTrack = (DWORD)(DeviceParams.SectorsPerTrack);
        DriveInfo->BytesPerSector = DeviceParams.BytesPerSector;
        DriveInfo->SectorCount = (ULONGLONG)((DriveInfo->CylinderCount *
                                                DriveInfo->HeadCount * DriveInfo->SectorsPerTrack));
    }

    switch(DeviceParams.DeviceType) {
    case 0:
        type = F5_360_512;      // close enough
        break;

    case 1:
        type = F5_1Pt2_512;
        break;

    case 2:
        type = F3_720_512;
        break;

    case 5:
        type = FixedMedia;
        break;

    case 7:
        type = F3_1Pt44_512;
        break;

    case 8:
        type = RemovableMedia;
        break;

    case 9:
        type = F3_2Pt88_512;
        break;

    default:
        type = Unknown;
        break;
    }

    return(type);
}


MEDIA_TYPE
GetMediaType(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo
    )
{
    return(ISNT() ? GetMediaTypeNt(Drive, DriveInfo) : GetMediaTypeWin9x(Drive, DriveInfo));
}

BOOL
NEC98_SpecialReadOrWriteNT(
    IN     TCHAR  Drive,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )
/*++

Routine Description:

    NEC98 specialn routine to boot sctor read or write sectors on a disk
    under Windows NT.
    This routine will fail on Win9x.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. This buffer must be aligned on a sector boundary.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set.

--*/

{
    TCHAR DrivePath[4];
    DWORD DontCare;
    DWORD SectorSize;
    HANDLE h;
    BOOL b;
    DWORD BytesXferred;
    TCHAR DeviceName[7];
    LONG OffsetHigh = 0;
    DWORD d;
    LPBYTE AlignedBuffer;
    LPBYTE p;

    //
    // Form root path
    //
    DrivePath[0] = Drive;
    DrivePath[1] = TEXT(':');
    DrivePath[2] = TEXT('\\');
    DrivePath[3] = 0;

    GetDiskFreeSpace(DrivePath,&DontCare,&SectorSize,&DontCare,&DontCare);
    if(AlignedBuffer = MALLOC(SectorSize + SectorSize - 1)) {

        if(d = (DWORD)AlignedBuffer % SectorSize) {
            p = (PUCHAR)((DWORD)AlignedBuffer + (SectorSize - d));
        } else {
            p = AlignedBuffer;
        }
    } else {
        b = FALSE;
        d = ERROR_NOT_ENOUGH_MEMORY;
	    goto c0;
    }
    //
    // Open the device
    //
    wsprintf(DeviceName,TEXT("\\\\.\\%c:"),Drive);
    h = CreateFile(
            DeviceName,
            Write ? (GENERIC_WRITE | GENERIC_READ) : GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c1;
    }
    if (b = ReadFile(h, p, SectorSize, &BytesXferred, NULL)){
    	if (Write){
    	    CopyMemory(p, Buffer, 512);
    	    SetFilePointer(h,(DWORD)0, &OffsetHigh,FILE_BEGIN);
    	    b = WriteFile(h, p, SectorSize, &BytesXferred,NULL);
    	} else { // read
    	    CopyMemory(Buffer, p, 512);
    	}
    }
    d = GetLastError();

    CloseHandle(h);
c1:
    FREE(AlignedBuffer);
c0:
    SetLastError(d);
    return(b);
}

//
// Maximum partition size addressable by regular INT13
// Max capacity = sector size * cylinders (10 bits) * heads (8 bits) *
//                sectors / track (6 bits)
//
#define MAX_INT13_PARTITION_CAPACITY  8455716864L   //  (512 * 1024 * 256 * 63) = 7.8GB
#define FAT32_BPB_HEADS_FIELD_OFFSET  0x1A
#define FAT32_BPB_SECTORSPERTRACK_FIELD_OFFSET  0x18

typedef BOOL (*PGET_DISK_FREE_SPACE_EX) (
    LPCTSTR,
    PULONGLONG,
    PULONGLONG,
    PULONGLONG
    );


BOOL
GetDriveSize9x(
    TCHAR DriveLetter,
    PULONGLONG DriveSize
    )
/*++

Routine Description:

    Gets the total size of the given drive.

    NOTE : First tries GetDriveFreeSpaceEx(...) if available and if
        unsuccessful, tries to compute drive size using INT21h.

Arguments:

    DriveLetter :   Drive letter.

    DriveSize : Recieves the drive size in bytes.

Return Value:

    TRUE, if drive size was determined otherwise FALSE.

--*/
{
    BOOL Result = FALSE;

    if (DriveSize && !ISNT()) {
        ULONGLONG TotalDriveSize = 0;

        if (ISOSR2()) {
            HMODULE Kernel32Handle = GetModuleHandle(TEXT("kernel32.dll"));

            if (Kernel32Handle) {
                PGET_DISK_FREE_SPACE_EX GetDiskFreeSpaceExPtr;

                GetDiskFreeSpaceExPtr = (PGET_DISK_FREE_SPACE_EX)
                        GetProcAddress(Kernel32Handle, "GetDiskFreeSpaceEx");

                if (GetDiskFreeSpaceExPtr) {
                    TCHAR   DriveName[MAX_PATH];
                    ULONGLONG FreeBytes = 0, TotalSize = 0, ActualFreeBytes = 0;

                    DriveName[0] = DriveLetter;
                    DriveName[1] = TEXT(':');
                    DriveName[2] = TEXT('\\');
                    DriveName[3] = 0;

                    Result = GetDiskFreeSpaceExPtr(DriveName,
                                &FreeBytes,
                                &TotalSize,
                                &ActualFreeBytes);

                    if (Result) {
                        TotalDriveSize = TotalSize;
                    }
                }
            }
        }

        if (!Result) {
            WINNT32_DRIVE_INFORMATION   DriveInfo = {0};

            GetMediaType(DriveLetter, &DriveInfo);

            if (DriveInfo.SectorCount) {
                TotalDriveSize = DriveInfo.SectorCount * DriveInfo.BytesPerSector;
                Result = TRUE;
            }
        }

        if (Result) {
            *DriveSize = TotalDriveSize;
        }
    }

    return Result;
}

BOOL
PatchBootCode(
    IN      WINNT32_SYSPART_FILESYSTEM  FileSystem,
    IN      TCHAR   DriveLetter,
    IN OUT  PUCHAR  BootCode,
    IN      DWORD   BootCodeSize
    )
/*++

Routine Description:

    Patches the boot code if there is any inconsistent data
    with the correct data

    NOTE : Currently we update only FAT32 BPB for invalid head
           count.

Arguments:

    FileSystem  :   File system type to look into the buffer

    DriveLetter :   Drive letter.

    BootCode    :   The actual boot code

    BootCodeSize:   Size of the boot code in bytes

Return Value:

    TRUE, if boot code was patched successfully, otherwise FALSE.

--*/
{
    BOOL Result = FALSE;

    if (BootCode && (FileSystem != Winnt32FsUnknown)) {
        switch (FileSystem) {
            case Winnt32FsFat32:
                if (!ISNT() && (BootCodeSize >= (FAT32_BPB_HEADS_FIELD_OFFSET + sizeof(WORD)))) {
                    ULONGLONG DriveSize = 0;
                    PWORD NumberOfHeads = (PWORD)(BootCode + FAT32_BPB_HEADS_FIELD_OFFSET);
                    PWORD SectorsPerTrack = (PWORD)(BootCode + FAT32_BPB_SECTORSPERTRACK_FIELD_OFFSET);
                    TCHAR Buffer[MAX_PATH * 2];

                    Result = GetDriveSize9x(DriveLetter, &DriveSize);

                    if (Result) {
                        WINNT32_DRIVE_INFORMATION DriveInfo = {0};

                        //
                        // Get the drive information
                        //
                        GetMediaType(DriveLetter, &DriveInfo);

                        //
                        // dump the drive information
                        //
                        if (DriveInfo.BytesPerSector) {
                            _stprintf(Buffer,
                                TEXT("Drive Information (INT 21H):\r\nCylinders:%d,Heads:%d,Sectors/Track:%d,Sectors:%I64d,Bytes/Sector:%d"),
                                DriveInfo.CylinderCount,
                                DriveInfo.HeadCount,
                                DriveInfo.SectorsPerTrack,
                                DriveInfo.SectorCount,
                                DriveInfo.BytesPerSector);

                            DebugLog (Winnt32LogInformation, Buffer, 0);

                            //
                            // The heads value better match what we got from GetMediaType(...)
                            // If not, we patch it to the correct one.
                            //
                            if (DriveInfo.HeadCount && (((DWORD)(*NumberOfHeads)) != DriveInfo.HeadCount)) {

                                _stprintf(Buffer,
                                    TEXT("Drive Information (BPB): Size=%I64u, Heads=%u, Sectors/Track=%u"),
                                    DriveSize,
                                    (*NumberOfHeads),
                                    (*SectorsPerTrack));

                                DebugLog(Winnt32LogInformation,
                                    TEXT("PatchBootCode: Existing %1"),
                                    0,
                                    Buffer);

                                //
                                // update the heads value
                                //
                                *NumberOfHeads = (WORD)(DriveInfo.HeadCount);

                                _stprintf(Buffer,
                                    TEXT("Drive Information (BPB): Size=%I64u, Heads=%u, Sectors/Track=%u"),
                                    DriveSize,
                                    (*NumberOfHeads),
                                    (*SectorsPerTrack));

                                DebugLog(Winnt32LogInformation,
                                    TEXT("PatchBootCode: New %1"),
                                    0,
                                    Buffer);
                            }
                        } else {
                            DebugLog(Winnt32LogError,
                                TEXT("PatchBootCode:Failed to get the drive information"),
                                0);
                        }
                    } else {
                        DebugLog(Winnt32LogError,
                            TEXT("PatchBootCode:Failed to get the drive size"),
                            0);
                    }
                }

                break;

            default :
                break;
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\unicode\precomp.h ===
#include "winnt32.h"
#include "msg.h"
#include <mountmgr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\exe\winnt32.h ===
#define IDS_APPNAME             1
#define IDS_DLLERROR            2
#define IDS_VERERROR            3
#define IDS_PATHERROR           4
#define IDD_SETUPINIT         101
#define IDB_INIT_WIN2000      102
#define IDC_BITMAP           1001
#define IDC_TEXT             1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\exe\winnt32.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    winnt32.c

Abstract:

    Stub loader for WinNT Setup program files.

Author:


Revisions:

    Ovidiu Temereanca (ovidiut)  09-Dec-1998

--*/

#include <windows.h>
#include <winver.h>
#include <ntverp.h>
#include <setupbat.h>
#include "winnt32.h"
#include "winnt32p.h"

#ifdef _X86_

#include "i386\download.h"

#define INTERNAL_WINNT32_DIR  TEXT("\\WINNT32")
#define MAX_RETRY_INTERVAL_SECONDS  3600L

#endif

#define MAX_UPGCHK_ELAPSED_SECONDS  (30 * 60)
#define S_CHKSUM_FILE           TEXT("DOSNET.INF")

#define MAKEULONGLONG(low,high) ((ULONGLONG)(((DWORD)(low)) | ((ULONGLONG)((DWORD)(high))) << 32))

#define ALLOC_TEXT(chars)       ((PTSTR)HeapAlloc (GetProcessHeap (), 0, ((chars) + 1) * sizeof (TCHAR)))
#define FREE(p)                 HeapFree (GetProcessHeap (), 0, p)
#define CHARS(string)           (sizeof (string) / sizeof ((string)[0]) - 1)

#define pFindEOS(String) pFindChar(String, 0)


PTSTR
FindLastWack (
    IN      PTSTR String
    )

/*++

Routine Description:

  FindLastWack returns a pointer to the last backslash character
  in the String

Arguments:

  String - Specifies the string

Return Value:

  The position of the last '\\' in the string or NULL if not found.

--*/

{
    PTSTR p;
    PTSTR LastChar = NULL;

    for(p = String; *p; p = CharNext(p)) {
        if(*p == TEXT('\\')) {      // the char '\' is never a lead byte
            LastChar = p;
        }
    }

    return LastChar;
}


PTSTR
DuplicateText (
    IN      PCTSTR Text
    )

/*++

Routine Description:

  DuplicateText allocates memory and then copies a source string into that memory.
  Caller is responsible for freeing that memory.

Arguments:

  Text - Specifies the source text

Return Value:

  A pointer to the duplicate string; NULL if not enough memory.

--*/

{
    PTSTR Dup;

    Dup = ALLOC_TEXT(lstrlen (Text));
    if (Dup) {
        lstrcpy (Dup, Text);
    }

    return Dup;
}


PTSTR
pFindChar (
    IN      PTSTR String,
    IN      UINT Char
    )

/*++

Routine Description:

  pFindChar returns a pointer to the first occurence of the Char
  in the String

Arguments:

  String - Specifies the string

  Char - Specifies the char to look for; can be null

Return Value:

  A pointer to the first occurence of the char in this string
  or NULL if not found

--*/

{
    while (*String) {

        if ((UINT)*String == Char) {
            return String;
        }

        String = CharNext (String);
    }

    return Char ? NULL : String;
}


VOID
ConcatenatePaths (
    IN      PTSTR LeadingPath,
    IN      PCTSTR TrailingPath
    )

/*++

Routine Description:

  ConcatenatePaths concatenates the two given paths, taking care to
  insert only one backslash between them. The resulting path is stored
  in LeadingPath.

Arguments:

  LeadingPath - Specifies the leading path

  TrailingPath - Specifies the trailing path

Return Value:

  none

--*/

{
    PTSTR p;

    //
    // check for "\" at the end of leading dir
    //
    p = FindLastWack (LeadingPath);
    if (!p) {
        p = pFindEOS (LeadingPath);
        *p++ = TEXT('\\');
    } else {
        if (*(p + 1) == 0) {
            p++;
        } else {
            p = pFindEOS (p);
            *p++ = TEXT('\\');
        }
    }
    //
    // check for "\" at the beginning of trailing dir
    //
    if (*TrailingPath == TEXT('\\')) {
        TrailingPath++;
    }
    lstrcpy (p, TrailingPath);
}


BOOL
GetFileVersion (
    IN      PCTSTR FilePath,
    OUT     PDWORD FileVersionMS,       OPTIONAL
    OUT     PDWORD FileVersionLS        OPTIONAL
    )
{
    DWORD dwLength, dwTemp;
    LPVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    UINT DataLength;
    BOOL b = FALSE;

    if (GetFileAttributes (FilePath) != (DWORD)-1) {
        if (dwLength = GetFileVersionInfoSize ((PTSTR)FilePath, &dwTemp)) {
            if (lpData = LocalAlloc (LPTR, dwLength)) {
                if (GetFileVersionInfo ((PTSTR)FilePath, 0, dwLength, lpData)) {
                    if (VerQueryValue (lpData, TEXT("\\"), &VsInfo, &DataLength)) {
                        if (FileVersionMS) {
                            *FileVersionMS = VsInfo->dwFileVersionMS;
                        }
                        if (FileVersionLS) {
                            *FileVersionLS = VsInfo->dwFileVersionLS;
                        }
                        b = TRUE;
                    }
                }
                LocalFree (lpData);
            }
        }
    }

    return b;
}



#ifdef _X86_

BOOL
pReRun (
    IN      PCTSTR StartDir,
    IN      PCTSTR WackExeName,
    IN      PCTSTR CmdLineArguments,
    IN      PCTSTR DefSourcesDir        OPTIONAL
    )

/*++

Routine Description:

  pReRun tries to launch a instance of this exe from a local drive,
  specifing an additional command line parameter (/S:<Source_Dir>).

Arguments:

  StartDir - Specifies the starting directory from where the instance will be launched

  WackExeName - Specifies the file name only of the EXE to launch, preceded
                by a backslash

  CmdLineArguments - Specifies the command line arguments initially supplied

  DefSourcesDir - Specifies the default directory containing instalation files

Return Value:

  TRUE if the launch was successful

--*/

{
    PTSTR CmdLine;
    INT Chars;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION pi;
    BOOL b = FALSE;
    DWORD rc;

    Chars = lstrlen (StartDir) + lstrlen (WackExeName) + CHARS(" ") + lstrlen (CmdLineArguments);
    if (DefSourcesDir) {
        Chars += CHARS(" /S:") + lstrlen (DefSourcesDir);
    }

    CmdLine = ALLOC_TEXT(Chars);
    if (!CmdLine) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    lstrcpy (CmdLine, StartDir);
    lstrcat (CmdLine, WackExeName);
    lstrcat (CmdLine, TEXT(" "));
    lstrcat (CmdLine, CmdLineArguments);
    if (DefSourcesDir) {
        lstrcat (CmdLine, TEXT(" /S:"));
        lstrcat (CmdLine, DefSourcesDir);
    }

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    b = CreateProcess (
            NULL,
            CmdLine,
            NULL,
            NULL,
            FALSE,
            NORMAL_PRIORITY_CLASS,
            NULL,
            StartDir,
            &StartupInfo,
            &pi
            );

    rc = GetLastError ();

    FREE (CmdLine);

    SetLastError (rc);
    return b;
}


BOOL
pCleanup (
    VOID
    )

/*++

Routine Description:

  pCleanup deletes all locally installed files and marks current running
  instance for deletion the next time system will reboot.

Arguments:

  none

Return Value:

  TRUE if the operation completed successfully; the machine will need to
  reboot before actual complete delete will take place.

--*/

{
    CHAR RunningInstancePath[MAX_PATH];
    CHAR Buffer[MAX_PATH];
    BOOL b;
    DWORD StartingTime;
    PCTSTR p;

    if (!GetModuleFileNameA (NULL, RunningInstancePath, MAX_PATH)) {
        return FALSE;
    }

#if 0
    //
    // the following code doesn't work on Win9x (unfortunately)
    // the system returns a valid handle, but the exe is NOT deleted
    //
    CreateFile (
        RunningInstancePath,
        DELETE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_DELETE_ON_CLOSE,
        NULL
        );
#endif

    //
    // wait until WINNT32\WINNT32.EXE file can be deleted
    // or the retry interval of time elapses
    //
    if (!GetWindowsDirectoryA (Buffer, MAX_PATH)) {
        return FALSE;
    }
    lstrcatA (Buffer, INTERNAL_WINNT32_DIR);
    p = FindLastWack ((PTSTR)RunningInstancePath);
    if (!p) {
        return FALSE;
    }
    lstrcatA (Buffer, p);
    StartingTime = GetTickCount ();
    while (GetFileAttributes (Buffer) != (DWORD)-1) {
        //
        // try to delete it
        //
        if (DeleteNode (Buffer)) {
            break;
        }
        //
        // give up if time elapses
        //
        if (GetTickCount () - StartingTime > 1000L * MAX_RETRY_INTERVAL_SECONDS) {
            break;
        }
        //
        // nothing useful to do; let the other processes run
        //
        Sleep (0);
    }

    //
    // wait until WINNT32\SETUPLOG.EXE file can be deleted
    // or the retry interval of time elapses
    //
    if (!GetWindowsDirectoryA (Buffer, MAX_PATH)) {
        return FALSE;
    }
    lstrcatA (Buffer, INTERNAL_WINNT32_DIR);
    lstrcatA (Buffer, TEXT("\\SETUPLOG.EXE"));
    StartingTime = GetTickCount ();
    while (GetFileAttributes (Buffer) != (DWORD)-1) {
        if (DeleteNode (Buffer)) {
            break;
        }
        if (GetTickCount () - StartingTime > 1000L * MAX_RETRY_INTERVAL_SECONDS) {
            break;
        }
        Sleep (0);
    }

    if (!GetWindowsDirectoryA (Buffer, MAX_PATH)) {
        return FALSE;
    }
    lstrcatA (Buffer, INTERNAL_WINNT32_DIR);
    b = DeleteNode (Buffer);

    if (!GetWindowsDirectoryA (Buffer, MAX_PATH)) {
        return FALSE;
    }
    lstrcatA (Buffer, "\\WININIT.INI");

    return
        WritePrivateProfileString ("rename", "NUL", RunningInstancePath, Buffer) && b;
}


BOOL
pShouldDownloadToLocalDisk (
    IN      PTSTR Path
    )

/*++

Routine Description:

  pShouldDownloadToLocalDisk returns TRUE if winnt32 files should be
  downloaded to a local disk first (like in the case of sources on
  a remote disk or on a CD)

Arguments:

  Path - Specifies the path

Return Value:

  TRUE if the specified path is on an untrusted media

--*/

{
    TCHAR ch;
    BOOL Remote = TRUE;
    UINT type;

    if (Path[1] == TEXT(':') && Path[2] == TEXT('\\')) {
        ch = Path[3];
        Path[3] = 0;
        type = GetDriveType (Path);
        Remote = (type == DRIVE_REMOTE) || (type == DRIVE_CDROM);
        Path[3] = ch;
    }
    return Remote;
}


VOID
pCenterWindowOnDesktop (
    HWND WndToCenter
    )

/*++

Routine Description:

    Centers a dialog relative to the 'work area' of the desktop.

Arguments:

    WndToCenter - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame, rcWindow;
    LONG  x, y, w, h;
    POINT point;
    HWND Desktop = GetDesktopWindow ();

    point.x = point.y = 0;
    ClientToScreen(Desktop, &point);
    GetWindowRect(WndToCenter, &rcWindow);
    GetClientRect(Desktop, &rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    //
    // Get the work area for the current desktop (i.e., the area that
    // the tray doesn't occupy).
    //
    if(!SystemParametersInfo (SPI_GETWORKAREA, 0, (PVOID)&rcFrame, 0)) {
        //
        // For some reason SPI failed, so use the full screen.
        //
        rcFrame.top = rcFrame.left = 0;
        rcFrame.right = GetSystemMetrics(SM_CXSCREEN);
        rcFrame.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    if(x + w > rcFrame.right) {
        x = rcFrame.right - w;
    } else if(x < rcFrame.left) {
        x = rcFrame.left;
    }
    if(y + h > rcFrame.bottom) {
        y = rcFrame.bottom - h;
    } else if(y < rcFrame.top) {
        y = rcFrame.top;
    }

    MoveWindow(WndToCenter, x, y, w, h, FALSE);
}


BOOL CALLBACK DlgProc (
    HWND Dlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
)

/*++

Routine Description:

  This is the callback procedure for the dialog displayed while
  components are copied from the network

Arguments:

  Dlg - Specifies the dialog window handle

  Msg - Specifies the message

  wParam - Specifies the first param

  lParam - Specifies the second param

Return Value:

  Depends on the specific message.

--*/

{
    static HANDLE   Bitmap = NULL;
    static HCURSOR  Cursor = NULL;

    RECT rect;
    HWND Text;
    BITMAP bm;
    INT i;

    switch (Msg) {

    case WM_INITDIALOG:
        Cursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
        ShowCursor (TRUE);
        Bitmap = LoadBitmap (GetModuleHandle (NULL), MAKEINTRESOURCE(IDB_INIT_WIN2000));
        if (Bitmap) {
            if (GetObject (Bitmap, sizeof (bm), &bm)) {
                GetClientRect (Dlg, &rect);
                rect.right = bm.bmWidth;
                AdjustWindowRect (&rect, GetWindowLong (Dlg, GWL_STYLE), FALSE);
                SetWindowPos (
                    Dlg,
                    NULL,
                    0,
                    0,
                    rect.right - rect.left,
                    rect.bottom - rect.top,
                    SWP_NOMOVE | SWP_NOZORDER);
            }
            SendDlgItemMessage(Dlg, IDC_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)Bitmap);
        }
        GetClientRect (Dlg, &rect);
        i = rect.right - rect.left;
        Text = GetDlgItem (Dlg, IDC_TEXT);
        if (GetWindowRect (Text, &rect)) {
            i = (i - (rect.right - rect.left)) / 2;
            ScreenToClient (Dlg, (LPPOINT)&rect);
            SetWindowPos (
                Text,
                NULL,
                i,
                rect.top,
                0,
                0,
                SWP_NOSIZE | SWP_NOZORDER);
        }
        pCenterWindowOnDesktop (Dlg);
        return TRUE;

    case WM_DESTROY:
        ShowCursor (FALSE);
        if (Cursor) {
            SetCursor (Cursor);
            Cursor = NULL;
        }
        if (Bitmap) {
            DeleteObject (Bitmap);
            Bitmap = NULL;
        }
    }

    return FALSE;
}


#endif


INT
pStringICompareCharCount (
    IN      PCTSTR String1,
    IN      PCTSTR String2,
    IN      DWORD CharCount
    )

/*++

Routine Description:

  This routine behaves like _tcsnicmp.

Arguments:

  String1 - Specifies the first string

  String2 - Specifies the second string

  CharCount - Specifies the number of chars to compare at most

Return Value:

  0 if strings are equal; -1 if first string is lesser; 1 if first is greater

--*/

{
    TCHAR ch1, ch2;

    if (!CharCount) {
        return 0;
    }

    while (*String1) {
        ch1 = (TCHAR)CharUpper ((LPTSTR)*String1);
        ch2 = (TCHAR)CharUpper ((LPTSTR)*String2);
        if (ch1 - ch2) {
            return ch1 - ch2;
        }

        CharCount--;
        if (!CharCount) {
            return 0;
        }

        String1 = CharNext (String1);
        String2 = CharNext (String2);
    }

    return -(*String2);
}

VOID
pParseCmdLine (
    IN      PTSTR CmdStart,
    OUT     PTSTR* ArgValues,
    OUT     PTSTR pStr,
    OUT     INT *NumArgs,
    OUT     INT *NumBytes
    )

/*

Routine Description:

  pParseCmdLine parses the command line and sets up the ArgValues array.
  On entry, CmdStart should point to the command line,
  ArgValues should point to memory for the ArgValues array,
  pStr points to memory to place the text of the arguments.
  If these are NULL, then no storing (only counting)
  is done.  On exit, *NumArgs has the number of
  arguments (plus one for a final NULL argument),
  and *NumBytes has the number of bytes used in the buffer
  pointed to by args.

Arguments:

  CmdStart - Specifies the command line having the form:
             <progname><nul><args><nul>
  ArgValues - Receives the arguments array;
              NULL means don't build array
  pStr - Receives the argument text; NULL means don't store text

  NumArgs - Receives the number of ArgValues entries created

  NumBytes - Receives the number of bytes used in  buffer

Return Value:

  none

*/

{
    PTSTR p;
    TCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *NumBytes = 0;
    *NumArgs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = CmdStart;
    if (ArgValues)
        *ArgValues++ = pStr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to NumBytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *NumBytes += sizeof(TCHAR);
            if (pStr)
                *pStr++ = *p;
        }
        /* append the terminating null */
        *NumBytes += sizeof(TCHAR);
        if (pStr)
            *pStr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *NumBytes += sizeof(TCHAR);
            if (pStr)
                *pStr++ = *p;

            c = *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (pStr)
                *(pStr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (ArgValues)
            *ArgValues++ = pStr;         /* store ptr to arg */
        ++*NumArgs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (pStr)
                    *pStr++ = TEXT('\\');
                *NumBytes += sizeof(TCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (pStr)
                        *pStr++ = *p;
                *NumBytes += sizeof(TCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (pStr)
            *pStr++ = TEXT('\0');         /* terminate string */
        *NumBytes += sizeof(TCHAR);
    }

}


PTSTR*
pCommandLineToArgv (
    OUT     INT* NumArgs
    )

/*++

Routine Description:

  pCommandLineToArgv tokens the command line in an array of arguments
  created on the heap. The number of entries in this array of args is
  stored in *NumArgs. The caller is responsible for freeing this array.

Arguments:

  NumArgs - Receives the number of arguments in the array that is returned

Return Value:

  An array of pointer to individual arguments specified on the command line

--*/

{
    PTSTR CommandLine;
    TCHAR ModuleName[MAX_PATH];
    PTSTR Start;
    INT Size;
    PTSTR* Args;

    CommandLine = GetCommandLine();
    GetModuleFileName (NULL, ModuleName, MAX_PATH);

    //
    // If there's no command line at all (won't happen from cmd.exe, but
    // possibly another program), then we use pgmname as the command line
    // to parse, so that ArgValues[0] is initialized to the program name
    //
    Start = *CommandLine ? CommandLine : ModuleName;

    //
    // Find out how much space is needed to store args,
    // allocate space for ArgValues[] vector and strings,
    // and store args and ArgValues ptrs in block we allocate
    //

    pParseCmdLine (Start, NULL, NULL, NumArgs, &Size);

    Args = (PTSTR*) LocalAlloc (
                        LMEM_FIXED | LMEM_ZEROINIT,
                        ((*NumArgs + 1) * sizeof(PTSTR)) + Size
                        );
    if (!Args) {
        return NULL;
    }

    pParseCmdLine (Start, Args, (PTSTR)(Args + *NumArgs), NumArgs, &Size);

    return Args;
}


VOID
GetCmdLineArgs (
    IN      PCTSTR CommandLine,
    OUT     BOOL* Cleanup,
    OUT     BOOL* NoDownload,
    OUT     PCTSTR* UnattendPrefix,
    OUT     PCTSTR* UnattendFileName,
    OUT     BOOL* DisableDynamicUpdates,
    OUT     PCTSTR* DynamicUpdatesShare,
    OUT     PCTSTR* RestartAnswerFile,
    OUT     BOOL* LocalWinnt32,
    OUT     BOOL* CheckUpgradeOnly,
    OUT     PTSTR RemainingArgs
    )

/*++

Routine Description:

  GetCmdLineArgs retrieves download-specific commands
  from the specified command line and stores them in supplied buffers.

Arguments:

  CommandLine - Specifies the command line to interpret

  Cleanup - Receives a bool indicating if a cleanup option
            was specified

  NoDownload - Receives a bool indicating if a no-download option
               was specified

  UnattendPrefix - Receives a pointer to the unattend command-line option, as
                   specified by the user (including the terminating column)
                   or NULL if not specified; caller is responsible
                   for freeing the memory

  UnattendFileName - Receives a pointer to the unattended file name
                     or NULL if not specified; caller is responsible
                     for freeing the memory

  DisableDynamicUpdates - Receives a bool set if DU is to be disabled

  DynamicUpdatesShare - Receives a pointer to the dynamic updates share;
                        caller is responsible for freeing the memory

  RestartAnswerFile - Receives a pointer to the /Restart: answer file

  LocalWinnt32 - Receives a bool indicating if a winnt32 runs from a local  disk
                 (after an automatic download)

  CheckUpgradeOnly - Receives a bool indicating if winnt32 runs in CheckUpgradeOnly mode

  RemainingArgs - Receives all remaining arguments not related
                  to the download operation

Return Value:

  none

--*/

{
    INT ArgCount;
    PTSTR *ArgValues, *CrtArg;
    PTSTR CurrentArg, p;
    BOOL PassOn;

    *Cleanup = FALSE;
    *NoDownload = FALSE;
    *UnattendPrefix = NULL;
    *UnattendFileName = NULL;
    *DisableDynamicUpdates = FALSE;
    *DynamicUpdatesShare = NULL;
    *RemainingArgs = 0;
    *LocalWinnt32 = FALSE;
    *CheckUpgradeOnly = FALSE;
    *RestartAnswerFile = NULL;

    CrtArg = ArgValues = pCommandLineToArgv (&ArgCount);

    //
    // Skip program name. We should always get back ArgCount as at least 1,
    // but be robust anyway.
    //
    if (ArgCount) {
        ArgCount--;
        CrtArg++;
    }

    while (ArgCount--) {
        CurrentArg = *CrtArg++;
        PassOn = TRUE;

        if ((*CurrentArg == TEXT('/')) || (*CurrentArg == TEXT('-'))) {

            if (lstrcmpi (CurrentArg + 1, TEXT("LOCAL")) == 0) {
                *LocalWinnt32 = TRUE;
                PassOn = FALSE;
            } else if (lstrcmpi (CurrentArg + 1, TEXT("CLEANUP")) == 0) {
                *Cleanup = TRUE;
                PassOn = FALSE;
            } else if (lstrcmpi (CurrentArg + 1, TEXT("NODOWNLOAD")) == 0) {
                *NoDownload = TRUE;
                PassOn = FALSE;
            } else if (lstrcmpi (CurrentArg + 1, TEXT("CHECKUPGRADEONLY")) == 0) {
                *CheckUpgradeOnly = TRUE;
            } else if (pStringICompareCharCount (CurrentArg + 1, TEXT("UNATTEND"), 8) == 0) {
                p = pFindChar (CurrentArg + 1 + 8, TEXT(':'));
                if (p && *(p + 1)) {
                    p++;
                    *UnattendFileName = DuplicateText (p);
                    *p = 0;
                    *UnattendPrefix = DuplicateText (CurrentArg);
                    PassOn = FALSE;
                }
            } else if (pStringICompareCharCount (CurrentArg + 1, TEXT("UNATTENDED"), 10) == 0) {
                p = pFindChar (CurrentArg + 1 + 10, TEXT(':'));
                if (p && *(p + 1)) {
                    p++;
                    *UnattendFileName = DuplicateText (p);
                    *p = 0;
                    *UnattendPrefix = DuplicateText (CurrentArg);
                    PassOn = FALSE;
                }
            } else if (lstrcmpi (CurrentArg + 1, WINNT_U_DYNAMICUPDATESDISABLE) == 0) {
                *DisableDynamicUpdates = TRUE;
            } else if (pStringICompareCharCount (CurrentArg + 1, WINNT_U_DYNAMICUPDATESHARE, sizeof (WINNT_U_DYNAMICUPDATESHARE_A) - 1) == 0 &&
                       CurrentArg[sizeof (WINNT_U_DYNAMICUPDATESHARE_A)] == TEXT(':')) {
                *DynamicUpdatesShare = DuplicateText (CurrentArg + 1 + sizeof (WINNT_U_DYNAMICUPDATESHARE_A));
            } else if (pStringICompareCharCount (CurrentArg + 1, TEXT("RESTART:"), 8) == 0) {
                *RestartAnswerFile = DuplicateText (CurrentArg + 1 + 8);
            }
        }

        if (PassOn) {
            if (*RemainingArgs) {
                lstrcat(RemainingArgs, TEXT(" "));
            }
            lstrcat(RemainingArgs, CurrentArg);
        }
    }

    LocalFree ((HLOCAL) ArgValues);
}

BOOL
DoesDirExist (
    IN      PCTSTR Path
    )
{
    WIN32_FIND_DATA fd;
    TCHAR test[MAX_PATH];
    HANDLE h;
    BOOL b = FALSE;

    if (Path) {
        wsprintf (test, TEXT("%s\\*"), Path);
        h = FindFirstFile (test, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            FindClose (h);
            b = TRUE;
        }
    }
    return b;
}

ULONGLONG
SystemTimeToFileTime64 (
    IN      PSYSTEMTIME SystemTime
    )
{
    FILETIME ft;
    ULARGE_INTEGER result;

    SystemTimeToFileTime (SystemTime, &ft);
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;

    return result.QuadPart;
}


BOOL
pComputeChecksum (
    IN      PCTSTR FileName,
    OUT     PDWORD Chksum
    )
{
    DWORD chksum, size, dwords, bytes;
    HANDLE hFile, hMap = NULL;
    PVOID viewBase = NULL;
    PDWORD base, limit;
    PBYTE base2;
    DWORD rc;
    BOOL b = FALSE;

    hFile = CreateFile(
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if(hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    __try {
        size = GetFileSize (hFile, NULL);
        if (size == (DWORD)-1) {
            __leave;
        }
        hMap = CreateFileMapping (
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    size,
                    NULL
                    );
        if (!hMap) {
            __leave;
        }
        viewBase = MapViewOfFile (hMap, FILE_MAP_READ, 0, 0, size);
        if (!viewBase) {
            __leave;
        }

        dwords = size / sizeof (DWORD);
        base = (PDWORD)viewBase;
        limit = base + dwords;
        chksum = 0;
        while (base < limit) {
            chksum += *base;
            base++;
        }
        bytes = size % sizeof (DWORD);
        base2 = (PBYTE)base;
        while (bytes) {
            chksum += *base2;
            base2++;
            bytes--;
        }
        b = TRUE;
    }
    __finally {
        if (!b) {
            rc = GetLastError ();
        }
        if (viewBase) {
            UnmapViewOfFile (viewBase);
        }
        if (hMap) {
            CloseHandle (hMap);
        }
        CloseHandle (hFile);
        if (!b) {
            SetLastError (rc);
        }
    }

    if (b) {
        *Chksum = chksum;
    }
    return b;
}


BOOL
pGetFiletimeStamps (
    IN      PCTSTR FileName,
    OUT     PFILETIME CreationTime,
    OUT     PFILETIME LastWriteTime
    )
{
    WIN32_FIND_DATA fd;
    HANDLE h;

    h = FindFirstFile (FileName, &fd);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    FindClose (h);
    *CreationTime = fd.ftCreationTime;
    *LastWriteTime = fd.ftLastWriteTime;
    return TRUE;
}

PTSTR
pGetRecentDUShare (
    IN      DWORD MaxElapsedSeconds
    )
{
    SYSTEMTIME lastDownload, currentTime;
    ULONGLONG lastDownloadIn100Ns, currentTimeIn100Ns;
    ULONGLONG difference;
    DWORD rc, size, type;
    HKEY key = NULL;
    BOOL b = FALSE;
    PTSTR duShare = NULL;
    TCHAR filePath[MAX_PATH];
    PTSTR p;
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    ULONGLONG data[2], storedData[2];
    DWORD chksum, storedChksum;

    if (!GetModuleFileName (NULL, filePath, MAX_PATH)) {
        return NULL;
    }
    p = FindLastWack (filePath);
    if (!p) {
        return NULL;
    }
    lstrcpy (p + 1, S_CHKSUM_FILE);

    rc = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Winnt32\\5.1\\DUShare"),
            0,
            KEY_READ,
            &key
            );

    if (rc == ERROR_SUCCESS) {
        size = sizeof (lastDownload);
        rc = RegQueryValueEx (
                key,
                TEXT("LastDownloadTime"),
                NULL,
                &type,
                (PBYTE) (&lastDownload),
                &size
                );
    }

    if (rc == ERROR_SUCCESS && type == REG_BINARY && size == sizeof (lastDownload)) {
        //
        // Compare current time to report time
        //

        GetSystemTime (&currentTime);

        lastDownloadIn100Ns = SystemTimeToFileTime64 (&lastDownload);
        currentTimeIn100Ns = SystemTimeToFileTime64 (&currentTime);

        if (currentTimeIn100Ns > lastDownloadIn100Ns) {
            //
            // Compute difference in seconds
            //
            difference = currentTimeIn100Ns - lastDownloadIn100Ns;
            difference /= (10 * 1000 * 1000);

            if (difference < MaxElapsedSeconds) {
                b = TRUE;
            }
        }
    }

    if (b) {
        rc = RegQueryValueEx (
                key,
                TEXT(""),
                NULL,
                &type,
                NULL,
                &size
                );
        if (rc == ERROR_SUCCESS && type == REG_SZ && size > 0) {
            duShare = ALLOC_TEXT (size / sizeof (TCHAR));
            if (duShare) {
                rc = RegQueryValueEx (
                        key,
                        TEXT(""),
                        NULL,
                        NULL,
                        (LPBYTE)duShare,
                        &size
                        );
                if (rc != ERROR_SUCCESS || !DoesDirExist (duShare)) {
                    FREE (duShare);
                    duShare = NULL;
                }
            }
        }
    }

    if (duShare) {
        b = FALSE;
        if (pGetFiletimeStamps (filePath, &ftCreationTime, &ftLastWriteTime)) {
            rc = RegQueryValueEx (
                        key,
                        TEXT("TimeStamp"),
                        0,
                        &type,
                        (LPBYTE)storedData,
                        &size
                        );
            if (rc == ERROR_SUCCESS && type == REG_BINARY) {
                data[0] = ((ULONGLONG)ftCreationTime.dwHighDateTime << 32) | (ULONGLONG)ftCreationTime.dwLowDateTime;
                data[1] = ((ULONGLONG)ftLastWriteTime.dwHighDateTime << 32 ) | (ULONGLONG)ftLastWriteTime.dwLowDateTime;
                if (data[0] == storedData[0] && data[1] == storedData[1]) {
                    b = TRUE;
                }
            }
        }
        if (b) {
            b = FALSE;
            if (pComputeChecksum (filePath, &chksum)) {
                rc = RegQueryValueEx (
                        key,
                        TEXT("Checksum"),
                        NULL,
                        &type,
                        (LPBYTE)&storedChksum,
                        &size
                        );
                if (rc == ERROR_SUCCESS && type == REG_DWORD && storedChksum == chksum) {
                    b = TRUE;
                }
            }
        }
        if (!b) {
            FREE (duShare);
            duShare = NULL;
        }
    }

    if (key) {
        RegCloseKey (key);
    }

    return duShare;
}

void
_stdcall
ModuleEntry(
    VOID
    )

/*++

Routine Description:

  ModuleEntry is the stub program that loads Windows 2000 Setup DLLs.

Arguments:

  none

Return Value:

  none. ExitProcess will set the process' exit code.

--*/

{
    TCHAR RunningInstancePath[MAX_PATH];
    TCHAR Temp[MAX_PATH];
    TCHAR Text1[MAX_PATH];
    TCHAR Text2[MAX_PATH+MAX_PATH];
    TCHAR Text3[MAX_PATH];
    TCHAR *WackExeName, *p;
    TCHAR winnt32DllPath[MAX_PATH];
    HMODULE WinNT32;
    BOOL Downloaded;
    DWORD d;
    BOOL b;
    HWND Dlg = NULL;
    HANDLE WinNT32Stub = NULL;
    PWINNT32 winnt32;
    HKEY key;
    DWORD type;
    PCTSTR moduleName;
    PSTR restartCmdLine = NULL;
    PTSTR RemainingArgs, NewCmdLine, UnattendPrefix, UnattendFileName;
    PTSTR DynamicUpdatesShare;
    BOOL Cleanup, NoDownload, DisableDynamicUpdates, LocalWinnt32, CheckUpgradeOnly;
    PTSTR RestartAnswerFile;
    UINT CmdLineLen;
    PTSTR FileName;
    PCTSTR ExtraFiles[2];
    TCHAR cdFilePath[MAX_PATH];
    PTSTR duShare = NULL;

#ifdef _X86_

    TCHAR DownloadDest[MAX_PATH] = TEXT("");
    TCHAR DefSourcesDir[MAX_PATH];
    BOOL IsWin9x;

    //
    // Check OS version. Disallow Win32s and NT < 4.00
    //
    d = GetVersion();
    if((d & 0xff) < 4) {

        LoadString (GetModuleHandle (NULL), IDS_VERERROR, Text1, sizeof(Text1)/sizeof(TCHAR));
        LoadString (GetModuleHandle (NULL), IDS_APPNAME, Text2, sizeof(Text2)/sizeof(TCHAR));
        MessageBox (NULL, Text1, Text2, MB_ICONERROR | MB_OK | MB_SYSTEMMODAL);

        ExitProcess (ERROR_OLD_WIN_VERSION);
    }

    IsWin9x = (d & 0x80000000) != 0;

#else

#define IsWin9x ((BOOL)FALSE)

#endif

    //
    // get this instance's path
    //
    if (!GetModuleFileName(NULL, RunningInstancePath, MAX_PATH)) {
        ExitProcess (GetLastError ());
    }
    WackExeName = FindLastWack (RunningInstancePath);
    if (!WackExeName) { // shut up PREfix.  This case should never happen.
        ExitProcess (ERROR_BAD_PATHNAME);
    }

    //
    // Ansi version on Win95. Unicode on NT.
    //
    moduleName = IsWin9x ? TEXT("WINNT32A.DLL") : TEXT("WINNT32U.DLL");
    winnt32DllPath[0] = 0;

    //
    // get command line options
    // allocate a bigger buffer for safety
    //
    RemainingArgs = ALLOC_TEXT(lstrlen(GetCommandLine()) * 2);
    if (!RemainingArgs) {
        ExitProcess (GetLastError ());
    }

    GetCmdLineArgs (
        GetCommandLine (),
        &Cleanup,
        &NoDownload,
        &UnattendPrefix,
        &UnattendFileName,
        &DisableDynamicUpdates,
        &DynamicUpdatesShare,
        &RestartAnswerFile,
        &LocalWinnt32,
        &CheckUpgradeOnly,
        RemainingArgs
        );

#ifdef _X86_

    if (Cleanup) {
        pCleanup ();
        ExitProcess (0);
    }

    if (IsWin9x) {

        WinNT32Stub = CreateEvent (NULL, FALSE, FALSE, TEXT("_WinNT32_Stub_"));
        if (!WinNT32Stub) {
            ExitProcess (GetLastError ());
        }

        b = (GetLastError() == ERROR_SUCCESS);

        if (!NoDownload && !DynamicUpdatesShare && pShouldDownloadToLocalDisk (RunningInstancePath)) {

            Dlg = CreateDialog (GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SETUPINIT), NULL, DlgProc);

            GetWindowsDirectory (DownloadDest, MAX_PATH);
            lstrcat (DownloadDest, INTERNAL_WINNT32_DIR);
            *WackExeName = 0;

            if (UnattendFileName &&
                GetFullPathName (UnattendFileName, MAX_PATH, Temp, &FileName) &&
                lstrcmpi (UnattendFileName, Temp)
                ) {
                ExtraFiles[0] = Temp;
                ExtraFiles[1] = NULL;
            } else {
                ExtraFiles[0] = NULL;
                FileName = UnattendFileName;
            }

            Downloaded = DownloadProgramFiles (
                                RunningInstancePath,
                                DownloadDest,
                                ExtraFiles
                                );

            *WackExeName = TEXT('\\');

            if (Downloaded) {
                //
                // get default sources dir
                //
                lstrcpy (DefSourcesDir, RunningInstancePath);
                *FindLastWack (DefSourcesDir) = 0;
                p = FindLastWack (DefSourcesDir);
                if (p && lstrcmpi(p, INTERNAL_WINNT32_DIR) == 0) {
                    *p = 0;
                }

                if (FileName) {
                    CmdLineLen = lstrlen (RemainingArgs);
                    if (CmdLineLen > 0) {
                        //
                        // count the space between args
                        //
                        CmdLineLen += CHARS(" ");
                    }
                    CmdLineLen += lstrlen (UnattendPrefix);
                    CmdLineLen += lstrlen (FileName);
                    NewCmdLine = ALLOC_TEXT(CmdLineLen);
                    if (NewCmdLine) {
                        if (*RemainingArgs) {
                            lstrcpy (NewCmdLine, RemainingArgs);
                            lstrcat (NewCmdLine, TEXT(" "));
                        } else {
                            *NewCmdLine = 0;
                        }
                        lstrcat (NewCmdLine, UnattendPrefix);
                        lstrcat (NewCmdLine, FileName);

                        FREE (RemainingArgs);
                        RemainingArgs = NewCmdLine;
                        NewCmdLine = NULL;
                    }
                }
                //
                // append /LOCAL to the new processes command line
                // to let it know it's running from a local share
                //
                NewCmdLine = ALLOC_TEXT(lstrlen (RemainingArgs) + sizeof (" /local") - 1);
                if (NewCmdLine) {
                    wsprintf (NewCmdLine, TEXT("%s /%s"), RemainingArgs, TEXT("LOCAL"));
                    if (pReRun (DownloadDest, WackExeName, NewCmdLine, DefSourcesDir)) {
                        //
                        // the new process will do it; this one will just die
                        // but after the signal that the Setup Wizard is on
                        // anyway, if something goes very wrong,
                        // don't wait more than 10 sec.
                        // this should be enough for the wizard to appear
                        // (or any error message box) on any machine that installs W2K
                        //
                        WaitForSingleObject (WinNT32Stub, 10000);
                        CloseHandle (WinNT32Stub);
                        if (Dlg) {
                            DestroyWindow (Dlg);
                        }
                        d = 0;
                    } else {
                        d = GetLastError ();
                    }
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
                ExitProcess (d);
            }
        }

        if (!Dlg && WinNT32Stub) {
            CloseHandle (WinNT32Stub);
            WinNT32Stub = NULL;
        }
    }

#endif

    if (RemainingArgs) {
        FREE(RemainingArgs);
        RemainingArgs = NULL;
    }
    if (UnattendPrefix) {
        FREE(UnattendPrefix);
        UnattendPrefix = NULL;
    }

    if (!DisableDynamicUpdates && !DynamicUpdatesShare) {
        PCTSTR af = NULL;
        if (RestartAnswerFile) {
            af = RestartAnswerFile;
        } else if (UnattendFileName) {
            if (GetFullPathName (UnattendFileName, MAX_PATH, Temp, &FileName)) {
                af = Temp;
            }
        }
        //
        // get the path from this answer file
        //
        if (af) {
            GetPrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_DYNAMICUPDATESDISABLE,
                    TEXT(""),
                    Text2,
                    MAX_PATH,
                    af
                    );
            DisableDynamicUpdates = !lstrcmpi (Text2, WINNT_A_YES);

            if (!DisableDynamicUpdates) {
                if (GetPrivateProfileString (
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESHARE,
                        TEXT(""),
                        Text2,
                        MAX_PATH,
                        af
                        )) {
                    DynamicUpdatesShare = DuplicateText (Text2);
                }
            }
        }
    }

    if (UnattendFileName) {
        FREE(UnattendFileName);
        UnattendFileName = NULL;
    }

    b = FALSE;
    if (!CheckUpgradeOnly && !DisableDynamicUpdates && !DynamicUpdatesShare) {
        DynamicUpdatesShare = pGetRecentDUShare (MAX_UPGCHK_ELAPSED_SECONDS);
        if (DynamicUpdatesShare) {
            b = TRUE;
        }
    }

    d = ERROR_SUCCESS;

    if (!DisableDynamicUpdates && DynamicUpdatesShare) {
        DWORD regFileVersionMS, regFileVersionLS;
        DWORD cdFileVersionMS, cdFileVersionLS;
        //
        // check if there is a replacement module newer than the CD version
        //
        if (GetFileAttributes (DynamicUpdatesShare) == (DWORD)-1) {
            if (!b) {
                d = GetLastError ();
                LoadString (GetModuleHandle (NULL), IDS_APPNAME, Text3, sizeof(Text3)/sizeof(TCHAR));
                LoadString (GetModuleHandle (NULL), IDS_PATHERROR, Text1, sizeof(Text1)/sizeof(TCHAR));
                wsprintf (Text2, Text1, DynamicUpdatesShare);
                MessageBox (NULL, Text2, Text3, MB_ICONERROR | MB_OK | MB_SYSTEMMODAL);
            }
        } else {
            wsprintf (Text2, TEXT("%s%s\\%s"), DynamicUpdatesShare, TEXT("\\WINNT32"), moduleName);
            if (GetFileAttributes (Text2) != (DWORD)-1 &&
                GetFileVersion (Text2, &regFileVersionMS, &regFileVersionLS)) {
                lstrcpyn (cdFilePath, RunningInstancePath, (INT)(WackExeName - RunningInstancePath + 2));
                lstrcat (cdFilePath, moduleName);
                if (GetFileVersion (cdFilePath, &cdFileVersionMS, &cdFileVersionLS)) {
                    if (MAKEULONGLONG(regFileVersionLS, regFileVersionMS) >
                        MAKEULONGLONG(cdFileVersionLS, cdFileVersionMS)) {
                        lstrcpy (winnt32DllPath, Text2);
                    }
                }
            }
        }

        FREE (DynamicUpdatesShare);
        DynamicUpdatesShare = NULL;
    }

    if (d == ERROR_SUCCESS) {

#ifdef _X86_

        //
        // before attempting to load the main module, make sure msvcrt.dll is present in the system dir
        //
        if (!GetSystemDirectory (Text1, MAX_PATH)) {
            ExitProcess (GetLastError ());
        }
        ConcatenatePaths (Text1, TEXT("msvcrt.dll"));
        d = GetFileAttributes (Text1);
        if (d == (DWORD)-1) {
            //
            // no local msvcrt.dll; copy the private file from CD
            //
            lstrcpyn (cdFilePath, RunningInstancePath, WackExeName - RunningInstancePath + 2);
            ConcatenatePaths (cdFilePath, TEXT("win9xupg\\msvcrt.dll"));
            if (!CopyFile (cdFilePath, Text1, TRUE)) {
                ExitProcess (GetLastError ());
            }
        } else if (d & FILE_ATTRIBUTE_DIRECTORY) {
            ExitProcess (ERROR_DIRECTORY);
        }

#endif

        *WackExeName = 0;
        if (!winnt32DllPath[0]) {
            lstrcpy (winnt32DllPath, RunningInstancePath);
            ConcatenatePaths (winnt32DllPath, moduleName);
        }

        b = FALSE;
        WinNT32 = LoadLibrary (winnt32DllPath);
        if(WinNT32) {
            winnt32 = (PWINNT32) GetProcAddress(WinNT32, "winnt32");
            if (winnt32) {
                d = (*winnt32) (LocalWinnt32 ? RunningInstancePath : NULL, Dlg, WinNT32Stub, &restartCmdLine);
                b = TRUE;
            }
            FreeLibrary (WinNT32);
        }
        if (!b) {
            d = GetLastError ();
            LoadString (GetModuleHandle (NULL), IDS_APPNAME, Text3, sizeof(Text3)/sizeof(TCHAR));
            LoadString (GetModuleHandle (NULL), IDS_DLLERROR, Text1, sizeof(Text1)/sizeof(TCHAR));
            wsprintf (Text2, Text1, winnt32DllPath);
            MessageBox (NULL, Text2, Text3, MB_ICONERROR | MB_OK | MB_SYSTEMMODAL);
        }
    }

    //
    // remove downloaded files
    //

#ifdef _X86_
    if (IsWin9x) {
        //
        // check if our local directory exists and if so delete it
        //
        if (LocalWinnt32 && GetFileAttributes (RunningInstancePath) != (DWORD)-1) {
            //
            // copy Winnt32.Exe to temp dir and rerun it from there with /CLEANUP option
            //
            lstrcpy (DefSourcesDir, RunningInstancePath);

            CmdLineLen = GetTempPath (MAX_PATH, DownloadDest);
            if (!CmdLineLen) {
                //
                // an error occured; copy it to %windir% instead
                //
                GetWindowsDirectory (DownloadDest, MAX_PATH);
            }

            //
            // make sure temp path doesn't end in backslash
            //
            p = FindLastWack (DownloadDest);
            if (p && *(p + 1) == 0) {
                *p = 0;
            }

            *WackExeName = TEXT('\\');
            if (CopyNode (DefSourcesDir, DownloadDest, WackExeName, FALSE)) {
                if (!pReRun (DownloadDest, WackExeName, TEXT("/CLEANUP"), NULL)) {
                    lstrcatA (DownloadDest, WackExeName);
                    DeleteNode (DownloadDest);
                }
            }
        }
    }
#endif

    if (d == ERROR_SUCCESS) {
        //
        // check if a restart request was made
        //
        if (restartCmdLine) {
            STARTUPINFOA startupInfo;
            PROCESS_INFORMATION pi;

            ZeroMemory(&startupInfo, sizeof(startupInfo));
            startupInfo.cb = sizeof(startupInfo);
            if (!CreateProcessA (
                    NULL,
                    restartCmdLine,
                    NULL,
                    NULL,
                    FALSE,
                    NORMAL_PRIORITY_CLASS,
                    NULL,
                    NULL,
                    &startupInfo,
                    &pi
                    )) {
                d = GetLastError ();
            }

            FREE (restartCmdLine);
        }
    }

    ExitProcess(d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\i386\syspart.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN  CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Command-line param that allows someone to force a particular drive
// to be the system partition. Useful in certain preinstall scenarios.
//
TCHAR ForcedSystemPartition;

#define WINNT_DONT_MATCH_PARTITION 0
#define WINNT_MATCH_PARTITION_NUMBER  1
#define WINNT_MATCH_PARTITION_STARTING_OFFSET  2

#define BUFFERSIZE 1024

//
// NT-specific routines we use from ntdll.dll and kernel32.dll
//
//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenSymLinkRoutine)(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerSymLinkRoutine)(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerDirRoutine) (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenDirRoutine) (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//WINBASEAPI
HANDLE
(WINAPI *FindFirstVolume) (
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

//WINBASEAPI
BOOL
(WINAPI *FindNextVolume)(
    HANDLE hFindVolume,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

//WINBASEAPI
BOOL
(WINAPI *FindVolumeClose)(
    HANDLE hFindVolume
    );

//WINBASEAPI
BOOL
(WINAPI *GetVolumeNameForVolumeMountPoint)(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
);

DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
);

BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
);


DWORD
GetNT4SystemPartition(
    IN  LPTSTR Signature,
    OUT LPTSTR SysPart
);










BOOL
ArcPathToNtPath(
    IN  LPCTSTR ArcPath,
    OUT LPTSTR  NtPath,
    IN  UINT    NtPathBufferLen
    )
{
    WCHAR arcPath[256];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    WCHAR Buffer[512];

    PWSTR ntPath;

    lstrcpyW(arcPath,L"\\ArcName\\");
#ifdef UNICODE
    lstrcpynW(arcPath+9,ArcPath,(sizeof(arcPath)/sizeof(WCHAR))-9);
#else
    MultiByteToWideChar(
        CP_ACP,
        0,
        ArcPath,
        -1,
        arcPath+9,
        (sizeof(arcPath)/sizeof(WCHAR))-9
        );
#endif

    UnicodeString.Buffer = arcPath;
    UnicodeString.Length = lstrlenW(arcPath)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = (*NtOpenSymLinkRoutine)(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer)-sizeof(WCHAR);

        Status = (*NtQuerSymLinkRoutine)(ObjectHandle,&UnicodeString,NULL);

        CloseHandle(ObjectHandle);

        if(NT_SUCCESS(Status)) {

            Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

#ifdef UNICODE
            lstrcpyn(NtPath,Buffer,NtPathBufferLen);
#else
            WideCharToMultiByte(CP_ACP,0,Buffer,-1,NtPath,NtPathBufferLen,NULL,NULL);
#endif

            return(TRUE);
        }
    }

    return(FALSE);
}


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN TCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    UINT i;
    DWORD d;

    LPTSTR BootFiles[] = { TEXT("BOOT.INI"),
                           TEXT("NTLDR"),
                           TEXT("NTDETECT.COM"),
                           NULL
                         };

    TCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether all NT boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,TEXT("%c:\\%s"),Drive,BootFiles[i]);

        d = GetFileAttributes(FileName);
        if(d == (DWORD)(-1)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


DWORD
QueryHardDiskNumber(
    IN  TCHAR   DriveLetter
    )

{
    TCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = DriveLetter;
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFile(driveName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return (DWORD) -1;
    }

    b = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);
    CloseHandle(h);

    if (!b) {
        return (DWORD) -1;
    }

    return number.DeviceNumber;
}


BOOL
MarkPartitionActive(
    IN TCHAR DriveLetter
    )
{
    DWORD       DriveNum;
    TCHAR       DosName[7];
    TCHAR       Name[MAX_PATH];
    DISK_GEOMETRY DiskGeom;
    PARTITION_INFORMATION PartitionInfo;
    HANDLE      h;
    BOOL        b;
    DWORD       Bytes;
    PUCHAR      UnalignedBuffer,Buffer;
    unsigned    i;
    BOOL Rewrite;
    BOOL FoundIt;

    //
    // This concept is n/a for PC98 and the stuff below
    // won't work on Win9x.
    //
    if(IsNEC98() || !ISNT()) {
        return(TRUE);
    }

    //
    // Get geometry info and partition info for this drive.
    // We get geometry info because we need the bytes per sector info.
    //
    wsprintf(DosName,TEXT("\\\\.\\%c:"),DriveLetter);

    h = CreateFile(
            DosName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_DRIVE_GEOMETRY,
            NULL,
            0,
            &DiskGeom,
            sizeof(DISK_GEOMETRY),
            &Bytes,
            NULL
            );

    if(!b || (DiskGeom.BytesPerSector < 512)) {
        CloseHandle(h);
        return(FALSE);
    }

    b = DeviceIoControl(
            h,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            &PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &Bytes,
            NULL
            );

    CloseHandle(h);
    if(!b) {
        return(FALSE);
    }

    //
    // Figure out which physical drive this partition is on.
    //
    DriveNum = QueryHardDiskNumber(DriveLetter);
    if(DriveNum == (DWORD)(-1)) {
        //
        // Have to do it the old-fashioned way. Convert to an NT path
        // and parse the result.
        //
        if(!QueryDosDevice(DosName+4,Name,MAX_PATH)) {
            return(FALSE);
        }

        if( _tcsnicmp( Name, TEXT("\\device\\harddisk"), 16 )) {
            //
            // We have no idea what this name represents. Punt.
            //
            return(FALSE);
        }

        DriveNum = _tcstoul(Name+16,NULL,10);
    }

    //
    // Allocate a buffer and align it.
    //
    UnalignedBuffer = MALLOC(2*DiskGeom.BytesPerSector);
    if(!UnalignedBuffer) {
        return(FALSE);
    }

    Buffer = (PVOID)(((DWORD)UnalignedBuffer + (DiskGeom.BytesPerSector - 1)) & ~(DiskGeom.BytesPerSector - 1));

    //
    // Now we open up the physical drive and read the partition table.
    // We try to locate the partition by matching start offsets.
    // Note that active status is only meaningful for primary partitions.
    //
    wsprintf(Name,TEXT("\\\\.\\PhysicalDrive%u"),DriveNum);

    h = CreateFile(
            Name,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        FREE(UnalignedBuffer);
        return(FALSE);
    }

    if(!ReadFile(h,Buffer,DiskGeom.BytesPerSector,&Bytes,NULL)) {
        FREE(UnalignedBuffer);
        CloseHandle(h);
        return(FALSE);
    }

    Rewrite = FALSE;
    FoundIt = FALSE;
    for(i=0; i<4; i++) {

        if(*(DWORD *)(Buffer + 0x1be + 8 + (i*16))
        == (DWORD)(PartitionInfo.StartingOffset.QuadPart / DiskGeom.BytesPerSector)) {

            FoundIt = TRUE;
            if(Buffer[0x1be+(i*16)] != 0x80) {
                //
                // Not already active, or active for some other bios unit #,
                // so we need to whack it.
                //
                Buffer[0x1be+(i*16)] = 0x80;
                Rewrite = TRUE;
            }
        } else {
            if(Buffer[0x1be+(i*16)]) {
                //
                // Not inactive, and needs to be, so whack it.
                //
                Buffer[0x1be+(i*16)] = 0;
                Rewrite = TRUE;
            }
        }
    }

    if(FoundIt) {
        if(Rewrite) {

            Bytes = 0;
            if(SetFilePointer(h,0,&Bytes,FILE_BEGIN) || Bytes) {
                b = FALSE;
            } else {
                b = WriteFile(h,Buffer,DiskGeom.BytesPerSector,&Bytes,NULL);
            }
        } else {
            b = TRUE;
        }
    } else {
        b = FALSE;
    }

    CloseHandle(h);
    FREE(UnalignedBuffer);
    return(b);
}


BOOL
x86DetermineSystemPartition(
    IN  HWND   ParentWindow,
    OUT PTCHAR SysPartDrive
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    On Win95, we always return C:. For NT, read on.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    With there being differences in the IO system mapping and introduction of Volumes for NT 50
    this has now become complicated. Listed below are the algorithms
    
    
    NT 5.0 Beta 2 and above :
    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Go Through all of the volumes in the system with FindFirstVolume/FindNextVolume/FindVolumeClose.
        3. Take off the trailing backslash to the name returne to get \\?\Volume{guid}.
        4. IOCTL_STORAGE_GET_DEVICE_NUMBER with \\?\Volume{guid} => Check for FILE_DEVICE_DISK. Remember the partition number. Goto 6
        5. If IOCTL_STORAGE_GET_DEVICE_NUMBER fails then use IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS which returns a list of harddisks.  
           For each harddisk remember the starting offset and goto 6.
        6. Check Harddisk # by using \\.\PhysicalDrive# with IOCTL_DISK_GET_DRIVE_LAYOUT.  If the signature matches then this is the disk we boot from.
        7. To find the partition that we boot from we look for boot indicator. If we used 2 we try to match the partition number stored in 6 
           else if 3 we try to match the starting offset.Then you have a \\?\Volume{guid}\ name for the SYSTEM volume. 
        8. Call GetVolumeNameForVolumeMountPoint with A:\, B:\, C:\, ... and check the result of the form \\?\Volume{guid}\ against your match 
           to see what the drive letter is.
           
           Important: Since the *Volume* APIs are post Beta2 we do dynamic loading of kernel32.dll based on the build number returned.

    Versions below NT 5.0 Beta 2
                                                                                                                                    
        1. Get the signature from the registry. Located at 
           HKLM\Hardware\Description\System\<MultifunctionAdapter or EisaAdapter>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier
        2. Enumerate the \?? directory and look for all entries that begin with PhysicalDrive#. 
	    3. For each of the Disks look for a match with the signature above and if they match then find out the partition number used to boot 
           using IOCTL_DISK_GET_DRIVE_LAYOUT and the BootIndicator bit.
	    4. On finding the Boot partition create a name of the form \Device\Harddisk#\Partition#
	    5. Then go through c:,d:...,z: calling QueryDosDeviceName and look for a match. That would be your system partition drive letter

    
    
Arguments:

    ParentWindow - supplies window handle for window to be the parent for
        any dialogs, etc.

    SysPartDrive - if successful, receives drive letter of system partition.

Return Value:

    Boolean value indicating whether SysPartDrive has been filled in.
    If FALSE, the user will have been infomred about why.

--*/

{
    TCHAR DriveName[4];
    BOOL  GotIt=FALSE;
    TCHAR Buffer[512];
    TCHAR Drive;
    BOOL b;
    TCHAR SysPartSig[20], PartitionNum[MAX_PATH], SysVolGuid[MAX_PATH];
    TCHAR DriveVolGuid[MAX_PATH];
    


    if(ForcedSystemPartition) {
        //
        // NT5 for NEC98 can't boot up from ATA Card and 
        // removable drive. We need check dive type.
        //
        if (IsNEC98() &&
            ((MyGetDriveType(ForcedSystemPartition) != DRIVE_FIXED) ||
             // Drive is not Fixed.
             !IsValidDrive(ForcedSystemPartition))){
            // HD format type is not NEC98.
            return(FALSE);
        }
        *SysPartDrive = ForcedSystemPartition;
        return(TRUE);
    }

    if(IsNEC98()) {
        if(!MyGetWindowsDirectory(Buffer,sizeof(Buffer)/sizeof(TCHAR)))
            return FALSE;
        *SysPartDrive = Buffer[0];
        return(TRUE);
    }

    if(!ISNT()) {
        *SysPartDrive = TEXT('C');
        return(TRUE);
    }


    // Code for NT starts here
        
    //Get signature from registry - Step 1 listed above
    
    if( (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\EisaAdapter"),SysPartSig) != ERROR_SUCCESS )
        && (FindSystemPartitionSignature(TEXT("Hardware\\Description\\System\\MultiFunctionAdapter"),SysPartSig) != ERROR_SUCCESS ) ){  
        GotIt = FALSE;
        goto c0;
    }

    
    if( ISNT() && (BUILDNUM() >= 1877) ){
    
        //Get the SystemVolumeGUID - steps 2 through 7 listed above ( Beta 2 and after )

        if( GetSystemVolumeGUID( SysPartSig, SysVolGuid ) != ERROR_SUCCESS ){  
            GotIt = FALSE;
            goto c0;
        }


    
    
    }else{

        if( GetNT4SystemPartition( SysPartSig, PartitionNum )  != ERROR_SUCCESS){
            GotIt = FALSE;
            goto c0;
        }

    }


    DriveName[1] = TEXT(':');
    
    // 
    //  Enumerate all drive letters and compare their device names
    //

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {

        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

            DriveName[0] = Drive;

            if( BUILDNUM() >= 1877){ //Versions Beta2 and after
                DriveName[2] = '\\';
                DriveName[3] = 0;

                if((*GetVolumeNameForVolumeMountPoint)((LPWSTR)DriveName, (LPWSTR)DriveVolGuid, MAX_PATH*sizeof(TCHAR))){
                    if(!lstrcmp(DriveVolGuid, SysVolGuid) ){
                        GotIt = TRUE;       // Found it
                        break;
                    }


                }


            }else{
                DriveName[2] = 0;
                if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {
    
                    if( !lstrcmpi(Buffer, PartitionNum) ) {
                        GotIt = TRUE;       // Found it
                        break;
                    }
                }
            }//Versions earlier than Beta 2
        }
    }

    
    // This helps for some builds ~1500 < buildnum < 1877 that are in a tough spot

    if(!GotIt) {
        //
        // Strange case, just assume C:
        //
        GotIt = TRUE;
        Drive = TEXT('C');
    }


c0:
    if(GotIt) {
        *SysPartDrive = Drive;
#if defined(REMOTE_BOOT)
    } else if (RemoteBoot) {
        GotIt = TRUE;
        *SysPartDrive = TEXT('C');
#endif
    }
    return(GotIt);
}


DWORD
GetSystemVolumeGUID(
    IN  LPTSTR Signature,
    OUT LPTSTR SysVolGuid
)

/*++

Routine Description:

    This routine enumerates all the volumes and if successful returns the \\?\Volume{guid} name for the system partition.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    SysVolGuid - If successful, will contain a name of form \\?\Volume{guid} for the System Partition (the one we use to boot)

Return Value:

    Returns NO_ERROR if successful, otherwise it contains the error code.
    

--*/
{

    HANDLE hVolume, h;
    TCHAR VolumeName[MAX_PATH];
    PTSTR q;
    TCHAR driveName[30];
    BOOL b,ret, DoExtent, MatchFound;
    STORAGE_DEVICE_NUMBER   number;
    DWORD Err,cnt;
    PVOLUME_DISK_EXTENTS Extent;
    PDISK_EXTENT Start, i;
    DWORD ExtentSize, bytes;
    PVOID p;
    ULONG PartitionNumToCompare;
    LARGE_INTEGER StartingOffToCompare;
    DWORD ioctlCode;

    Err = NO_ERROR;

    //Enuberate all volumes

    hVolume = (*FindFirstVolume)( (LPWSTR)VolumeName, MAX_PATH );
    if( hVolume == INVALID_HANDLE_VALUE ){
        return GetLastError();
    }

    MatchFound = FALSE;

    do{

        //Remove trailing backslash

        DoExtent = FALSE;
            
        if( q=_tcsrchr( VolumeName,TEXT('\\')) ){
            *q = 0;
        }else{
            continue;
        }


        //Open the volume

        h = CreateFile(VolumeName, GENERIC_READ, FILE_SHARE_READ |
                       FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            continue; // Move on to next volume
        }

        //Get the disk number

        ret = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);

        if( !ret ){
            
            // Try using IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS if the above failed

            Extent = MALLOC(1024);
            ExtentSize = 1024;
            if(!Extent) {
                CloseHandle( h );
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            
            

            ioctlCode = IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS;
retry:
        
            ret = DeviceIoControl( h, ioctlCode,
                    NULL,0,(PVOID)Extent,ExtentSize,&bytes,NULL);
        
            if(!ret) {
        
                if((Err=GetLastError()) == ERROR_MORE_DATA) {
        
                    ExtentSize += 1024;
                    if(p = REALLOC((PVOID)Extent, ExtentSize)) {
                        (PVOID)Extent = p;
                    } else {
                        CloseHandle( h );
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto cleanup;
                    }
                    goto retry;
                } else {
                    if (ioctlCode == IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS) {
                        ioctlCode = IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN;
                        goto retry;
                    }
                    CloseHandle( h );
                    continue;
                }
            }else{
                DoExtent = TRUE;
            }

        }
        
        // Done with the handle this time around

        CloseHandle( h );

        if( !DoExtent ){

             //
            //  Check to see if this is a disk and not CDROM etc.
            //

            if( number.DeviceType == FILE_DEVICE_DISK ){
                
                // Remember the partition number
                PartitionNumToCompare = number.PartitionNumber;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), number.DeviceNumber );


                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&PartitionNumToCompare, WINNT_MATCH_PARTITION_NUMBER  ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
                
            }
            // Move on ..
            continue;
            
        }else{
            // Go through all disks and try for match

            Start = Extent->Extents;
            cnt = 0;      
            for( i = Start; cnt < Extent->NumberOfDiskExtents; i++ ){
                cnt++;
                // Remember the starting offset
                StartingOffToCompare = i->StartingOffset;
                wsprintf( driveName, TEXT("\\\\.\\PhysicalDrive%lu"), i->DiskNumber );
                if(DoDiskSignaturesCompare( Signature, driveName, (PVOID)&StartingOffToCompare, WINNT_MATCH_PARTITION_STARTING_OFFSET ) ){
                    MatchFound = TRUE;
                    Err = NO_ERROR;
                    lstrcpy( SysVolGuid, VolumeName );
                    SysVolGuid[lstrlen(VolumeName)]=TEXT('\\');
                    SysVolGuid[lstrlen(VolumeName)+1]=0;
                    break;
                }
            }
            
        }
        
        if( MatchFound )
            break;
        

    }while( (*FindNextVolume)( hVolume, (LPWSTR)VolumeName, MAX_PATH ));


cleanup:

    if( hVolume != INVALID_HANDLE_VALUE )
        (*FindVolumeClose)( hVolume );

    return Err;



}



BOOL
DoDiskSignaturesCompare(
    IN      LPCTSTR Signature,
    IN      LPCTSTR DriveName,
    IN OUT  PVOID   Compare,
    IN      DWORD   Action
)
/*++

Routine Description:

    This routine compares the given disk signature with the one for the specified physical disk.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    DriveName -  Physical Drive name of the form \\.\PhysicalDrive#
    
    Compare   -  A pointer to a storage variable. The type depends on the value of Action
    
    Action    -  Should be one of the following
                
                WINNT_DONT_MATCH_PARTITION - Once disk signatures match it returns the boot partition number in Compare. Compare should be a PULONG.
                       
                WINNT_MATCH_PARTITION_NUMBER - Once disk signatures match it tries to match the boot partition number with the number passed in
                                               through Compare. Compare should be PULONG.
                
                WINNT_MATCH_PARTITION_STARTING_OFFSET - Once disk signatures match it tries to match the boot partition starting offset with the 
                                                        starting offset number passed in through Compare. Compare should be PLARGE_INTEGER.

Return Value:

    Returns TRUE if successful in getting a match.
    

--*/

{

    TCHAR temp[30];
    BOOL b,Found = FALSE;
    PLARGE_INTEGER Starting_Off;
    PPARTITION_INFORMATION Start, i;
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    DWORD DriveLayoutSize;
    DWORD cnt;
    DWORD DataSize;
    LPTSTR p;
    PULONG Disk_Num;
    ULONG Sig;
    


    if(!Compare )
        return FALSE;

    if ((Action != WINNT_DONT_MATCH_PARTITION) &&
        (Action != WINNT_MATCH_PARTITION_NUMBER) &&
        (Action != WINNT_MATCH_PARTITION_STARTING_OFFSET))
        return FALSE;

    if( (Action==WINNT_MATCH_PARTITION_STARTING_OFFSET) && Compare )
        Starting_Off = (PLARGE_INTEGER) Compare;
    else
        Disk_Num = (PULONG) Compare;
    




    // On any failure return FALSE



    //
    // Get drive layout info for this physical disk.
    // If we can't do this something is very wrong.
    //
    hDisk = CreateFile(
                DriveName,
                FILE_READ_ATTRIBUTES | FILE_READ_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    
    if(hDisk == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    //
    // Get partition information.
    //
    DriveLayout = MALLOC(1024);
    DriveLayoutSize = 1024;
    if(!DriveLayout) {
        goto cleanexit;
    }
    
    
retry:

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT,
            NULL,
            0,
            (PVOID)DriveLayout,
            DriveLayoutSize,
            &DataSize,
            NULL
            );

    if(!b) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            DriveLayoutSize += 1024;
            if(p = REALLOC((PVOID)DriveLayout,DriveLayoutSize)) {
                (PVOID)DriveLayout = p;
            } else {
                goto cleanexit;
            }
            goto retry;
        } else {
            goto cleanexit;
        }
    }else{

        // Now walk the Drive_Layout to find the boot partition
        
        Start = DriveLayout->PartitionEntry;
        cnt = 0;

        /*
        _ultot( DriveLayout->Signature, temp, 16 );
        if( lstrcmpi( temp, Signature ) )
            goto cleanexit;
        */

        Sig = _tcstoul( Signature, NULL, 16 ); 
        if( Sig != DriveLayout->Signature )
            goto cleanexit;

        for( i = Start; cnt < DriveLayout->PartitionCount; i++ ){
            cnt++;
            
            
            if( i->BootIndicator == TRUE ){
                if( Action == WINNT_DONT_MATCH_PARTITION ){
                    *Disk_Num = i->PartitionNumber;
                    Found = TRUE;
                    goto cleanexit;

                }


                if( Action == WINNT_MATCH_PARTITION_NUMBER ){
                    if( *Disk_Num == i->PartitionNumber ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }else{
                    if( Starting_Off->QuadPart == i->StartingOffset.QuadPart ){
                        Found = TRUE;
                        goto cleanexit;
                    }

                }
                
                break;
            }
            
        }



    }

cleanexit:

    if( hDisk != INVALID_HANDLE_VALUE )
        CloseHandle( hDisk );


    return Found;
}












DWORD
FindSystemPartitionSignature(
    IN  LPCTSTR AdapterKeyName,
    OUT LPTSTR Signature
)
/*++

Routine Description:

    This routine fetches the disk signature for the first disk that the BIOS sees. This has to be the disk that we boot from on x86s.
    It is at location <AdapterKeyName>\<some Bus No.>\DiskController\0\DiskPeripheral\0\Identifier

Arguments:

    Signature -  If successful will contain the signature of the disk we boot off from in Hex.

Return Value:

    Returns ERROR_SUCCESS if successful, otherwise it contains the error code.
    

--*/
{

    DWORD Err, dwSize;
    HKEY hkey, BusKey, Controller, SystemDiskKey;
    int busnumber;
    TCHAR BusString[20], Identifier[100];



    Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        AdapterKeyName,
                        0,
                        KEY_READ,
                        &hkey );

    if( Err != ERROR_SUCCESS )
        return Err;

    
    // Start enumerating the buses

    for( busnumber=0; ;busnumber++){

        wsprintf( BusString, TEXT("%d"), busnumber );

        Err = RegOpenKeyEx( hkey,
                        BusString,
                        0,
                        KEY_READ,
                        &BusKey );

        

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( hkey );
            return Err;
        }
        
        Err = RegOpenKeyEx( BusKey,
                        TEXT("DiskController"),
                        0,
                        KEY_READ,
                        &Controller );

        
        RegCloseKey(BusKey);        // Not needed anymore

        
        if( Err != ERROR_SUCCESS )  // Move on to next bus
            continue;

        RegCloseKey( hkey );        // Not needed anymore

        Err = RegOpenKeyEx( Controller,
                        TEXT("0\\DiskPeripheral\\0"),
                        0,
                        KEY_READ,
                        &SystemDiskKey );

        if( Err != ERROR_SUCCESS ){
            RegCloseKey( Controller );
            return Err;
        }

        RegCloseKey( Controller );  // Not needed anymore


        dwSize = sizeof(Identifier);
        Err = RegQueryValueEx( SystemDiskKey,
                               TEXT("Identifier"),
                               NULL,
                               NULL,
                               (PBYTE) Identifier,
                               &dwSize);

        if( Err != ERROR_SUCCESS  ){
            RegCloseKey( SystemDiskKey );
            return Err;
        }

        if( Identifier && (lstrlen(Identifier) > 9 ) ){
            lstrcpy( Signature,Identifier+9);
            *_tcsrchr( Signature,TEXT('-') ) = 0;
            RegCloseKey( SystemDiskKey );
            return ERROR_SUCCESS;
        }
        else{
            RegCloseKey( SystemDiskKey );
            return Err;
        }


         
    }

    // Should never get here


    RegCloseKey( hkey );
    
    return ERROR_PATH_NOT_FOUND;
    

}

#if defined(UNICODE)

#define EMPTY_STRING L""
#define DEF_INF_BUFFER_SIZE 1024
#define MULTI_SZ_NEXT_STRING(x) ((x) + wcslen(x) + 1)
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))
#endif

BOOL
GetSystemRootNtPath(
    OUT LPWSTR  NtPath,
    IN  USHORT  NtPathBufferLen
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    WCHAR Buffer[512];

    PWSTR ntPath;

#define SYSTEM_ROOT_NAME        L"\\SystemRoot"
    UnicodeString.Buffer = SYSTEM_ROOT_NAME;
    UnicodeString.Length = (ARRAYSIZE(SYSTEM_ROOT_NAME) - 1) * sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = (*NtOpenSymLinkRoutine)(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = NtPath;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = NtPathBufferLen;

        Status = (*NtQuerSymLinkRoutine)(ObjectHandle,&UnicodeString,NULL);

        CloseHandle(ObjectHandle);

        if(NT_SUCCESS(Status)) {
            UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL 
DoesCurrentSystemHasThirdPartyKernel(
    VOID
    )
{
    WCHAR BootIniName[16];
    PWSTR pSectionsBuffer = NULL;
    PWSTR pKeysBuffer = NULL;
    PWSTR pString = NULL;
    PWSTR pNtPathString = NULL;
    PWSTR pNtPathSystemRoot = NULL;
    PWSTR pKey = NULL;
    PWSTR pDirectory;
    UINT  sizeOfSectionBuffer = 0;
    UINT  sizeOfBuffer = 0;
    UINT  directoryNameSize;
    BOOL  bResult = FALSE;

    wsprintfW(BootIniName, L"%c:\\BOOT.INI", SystemPartitionDriveLetter);

    __try{
        do{
            if(pKeysBuffer){
                FREE(pKeysBuffer);
            }
            sizeOfSectionBuffer += DEF_INF_BUFFER_SIZE;
            pKeysBuffer = (PWSTR)MALLOC(sizeOfSectionBuffer * sizeof (WCHAR));
            if(!pKeysBuffer){
                __leave;
            }
            pKeysBuffer[0] = '\0';
        }while((sizeOfSectionBuffer - 2) == 
                GetPrivateProfileStringW(L"operating systems",
                                         NULL,
                                         EMPTY_STRING,
                                         pKeysBuffer,
                                         sizeOfSectionBuffer,
                                         BootIniName));

        if(!pKeysBuffer[0]){
            __leave;
        }
        
        sizeOfBuffer = DEF_INF_BUFFER_SIZE;
        pString = (PWSTR)MALLOC(sizeOfBuffer * sizeof (WCHAR));
        if(!pString){
            __leave;
        }
        pNtPathString = (PWSTR)MALLOC(sizeOfBuffer * sizeof (WCHAR));
        if(!pNtPathString){
            __leave;
        }
        
        for(pKey = pKeysBuffer; pKey[0]; pKey = MULTI_SZ_NEXT_STRING(pKey))
        {
            GetPrivateProfileStringW(L"operating systems",
                                     pKey,
                                     EMPTY_STRING,
                                     pString,
                                     sizeOfBuffer,
                                     BootIniName);

            _wcslwr(pString);

            if(!wcsstr(pString, L"/kernel")){
                continue;
            }
            
            pDirectory = wcschr(pKey, '\\');
            MYASSERT(pDirectory);
            
            if(pDirectory){
                directoryNameSize = wcslen(pDirectory) * sizeof(WCHAR);
                pDirectory[0] = '\0';
            }
            else{
                directoryNameSize = 0;
            }

            if(!ArcPathToNtPath(pKey, pNtPathString, sizeOfBuffer - directoryNameSize)){
                MYASSERT(FALSE);
                continue;
            }
            
            if(pDirectory){
                pDirectory[0] = '\\';
                wcscat(pNtPathString, pDirectory);
            }
            
            if(!pNtPathSystemRoot){
                pNtPathSystemRoot = (PWSTR)MALLOC(sizeOfBuffer * sizeof (WCHAR));
                if(!pNtPathSystemRoot){
                    __leave;
                }
                if(!GetSystemRootNtPath(pNtPathSystemRoot, sizeOfBuffer * sizeof (WCHAR))){
                    MYASSERT(FALSE);
                }
            }
            
            if(!_wcsicmp(pNtPathString, pNtPathSystemRoot)){
                bResult = TRUE;
                __leave;
            }
        }
    }
    __finally{
        DWORD rc = GetLastError();

        if(pKeysBuffer){
            FREE(pKeysBuffer);
        }
        if(pString){
            FREE(pString);
        }
        if(pNtPathString){
            FREE(pNtPathString);
        }
        if(pNtPathSystemRoot){
            FREE(pNtPathSystemRoot);
        }
        
        SetLastError (rc);
    }

    return bResult;
}
#endif

BOOL
InitializeArcStuff(
    IN HWND Parent
    )
{
    HMODULE NtdllLib, Kernel32Lib;

    if(ISNT()) {
        //
        // On NT ntdll.dll had better be already loaded.
        //
        NtdllLib = LoadLibrary(TEXT("NTDLL"));
        if(!NtdllLib) {

            MessageBoxFromMessage(
                Parent,
                MSG_UNKNOWN_SYSTEM_ERROR,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                GetLastError()
                );

            return(FALSE);

        }

        (FARPROC)NtOpenSymLinkRoutine = GetProcAddress(NtdllLib,"NtOpenSymbolicLinkObject");
        (FARPROC)NtQuerSymLinkRoutine = GetProcAddress(NtdllLib,"NtQuerySymbolicLinkObject");
        (FARPROC)NtOpenDirRoutine = GetProcAddress(NtdllLib,"NtOpenDirectoryObject");
        (FARPROC)NtQuerDirRoutine = GetProcAddress(NtdllLib,"NtQueryDirectoryObject");

        

        if(!NtOpenSymLinkRoutine || !NtQuerSymLinkRoutine || !NtOpenDirRoutine || !NtQuerDirRoutine) {

            MessageBoxFromMessage(
                Parent,
                MSG_UNKNOWN_SYSTEM_ERROR,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                GetLastError()
                );

            FreeLibrary(NtdllLib);

            return(FALSE);
        }

        //
        // We don't need the extraneous handle any more.
        //
        FreeLibrary(NtdllLib);


        if(BUILDNUM() >= 1877){
            
            //Load the kernel32.dll stuff too

            Kernel32Lib = LoadLibrary(TEXT("KERNEL32"));
            if(!Kernel32Lib) {
    
                MessageBoxFromMessage(
                    Parent,
                    MSG_UNKNOWN_SYSTEM_ERROR,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    GetLastError()
                    );
    
                return(FALSE);

            }

            (FARPROC)FindFirstVolume = GetProcAddress(Kernel32Lib,"FindFirstVolumeW");
            (FARPROC)FindNextVolume = GetProcAddress(Kernel32Lib,"FindNextVolumeW");
            (FARPROC)FindVolumeClose = GetProcAddress(Kernel32Lib,"FindVolumeClose");
            (FARPROC)GetVolumeNameForVolumeMountPoint = GetProcAddress(Kernel32Lib,"GetVolumeNameForVolumeMountPointW");

            if(!FindFirstVolume || !FindNextVolume ) {

                MessageBoxFromMessage(
                    Parent,
                    MSG_UNKNOWN_SYSTEM_ERROR,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    GetLastError()
                    );
    
                FreeLibrary(Kernel32Lib);
    
                return(FALSE);
            }

            FreeLibrary(Kernel32Lib);


        }


    }
                  
    if(!x86DetermineSystemPartition(Parent,&SystemPartitionDriveLetter)) {

        MessageBoxFromMessage(
            Parent,
            MSG_SYSTEM_PARTITION_INVALID,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    SystemPartitionDriveLetters[0] = SystemPartitionDriveLetter;
    SystemPartitionDriveLetters[1] = 0;

    LocalBootDirectory[0] = SystemPartitionDriveLetter;
    LocalBootDirectory[1] = TEXT(':');
    LocalBootDirectory[2] = TEXT('\\');
    lstrcpy(LocalBootDirectory+3,LOCAL_BOOT_DIR);
    if(IsNEC98()) {
        LocalBackupDirectory[0] = SystemPartitionDriveLetter;
        LocalBackupDirectory[1] = TEXT(':');
        LocalBackupDirectory[2] = TEXT('\\');
        lstrcpy(LocalBackupDirectory+3,LOCAL_BACKUP_DIR);
    }

    return(TRUE);
}






DWORD
GetNT4SystemPartition(
    IN  LPTSTR Signature,
    OUT LPTSTR SysPart
)
/*++

Routine Description:

    This routine enumerates all the volumes and if successful returns the \Device\Harddisk#\Partition# name of the system partition
    on systems prior to NT 5 Beta 2.

Arguments:

    Signature -  supplies a disk signature of the Boot disk so that it can be compared against. The details
                 to getting this value are detailed in the comments for x86DetermineSystemPartition.

    SysPart -  If successful, will contain a name of form \Device\Harddisk#\Partition# for the System Partition (the one we use to boot)

Return Value:

    Returns NO_ERROR if successful, otherwise it contains the error code.
    

--*/
{

    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    UCHAR DirInfoBuffer[ BUFFERSIZE ];
    TCHAR DirName[20];
    TCHAR ObjName[1024];
    TCHAR Buffer[1024];
    WCHAR pSignature[512];
    ULONG Context = 0;
    ULONG ReturnedLength, PartNum;
    LPTSTR Num_Str;
    
    
    RtlZeroMemory( DirInfoBuffer, BUFFERSIZE );

#ifdef UNICODE
    lstrcpyW( pSignature,Signature);
#else
    MultiByteToWideChar(
        CP_ACP,
        0,
        Signature,
        -1,
        pSignature,
        (sizeof(pSignature)/sizeof(WCHAR))
        );
    
#endif

    //We open the \?? Directory
    
    lstrcpy( DirName, TEXT("\\DosDevices") );
    
    
    UnicodeString.Buffer = (PWSTR)DirName;
    UnicodeString.Length = lstrlenW(UnicodeString.Buffer)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = (*NtOpenDirRoutine)( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (!NT_SUCCESS( Status ))
        return(Status);

    DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer;
    
    // Go through the directory looking for all instances beginning with PhysicalDrive#

    for (Status = (*NtQuerDirRoutine)( DirectoryHandle,
                                          DirInfoBuffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          TRUE,
                                          &Context,
                                          &ReturnedLength );
         NT_SUCCESS( Status );
         Status = (*NtQuerDirRoutine)( DirectoryHandle,
                                          DirInfoBuffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength ) ) {
    
    
        
        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status ) && (Status != STATUS_NO_MORE_ENTRIES))
            break;
        

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer[0];
        
        
        while( TRUE ){

            //
            //  Check if there is another record.  If there isn't, then get out
            //  of the loop now
            //

            if (DirInfo->Name.Length == 0) {
                break;
            }


            memmove( ObjName, DirInfo->Name.Buffer, DirInfo->Name.Length );
            ObjName[DirInfo->Name.Length/(sizeof(WCHAR))] = 0;

            if( _tcsstr(ObjName, TEXT("PhysicalDrive") )){

                Num_Str = ObjName+13;

                wsprintf(Buffer,TEXT("\\\\.\\%s"),ObjName);
                if( DoDiskSignaturesCompare( (LPCTSTR)pSignature, Buffer, &PartNum, WINNT_DONT_MATCH_PARTITION ) ){
                    wsprintf(SysPart,TEXT("\\Device\\Harddisk%s\\Partition%lu"),Num_Str, PartNum);
                    Status = ERROR_SUCCESS;
                    goto cleanup;

                }
            }

            

            //
            //  There is another record so advance DirInfo to the next entry
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                          sizeof( OBJECT_DIRECTORY_INFORMATION ) );




        }
        


        RtlZeroMemory( DirInfoBuffer, BUFFERSIZE );

        
    
    }

cleanup:
    CloseHandle( DirectoryHandle );
    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\faulth\util.h ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    pfrutil.h

Abstract:
    PFR utility stuff

Revision History:
    DerekM  created  05/01/99

********************************************************************/

#ifndef PFRUTIL_H
#define PFRUTIL_H

// make sure both _DEBUG & DEBUG are defined if one is defined.  Otherwise
//  the ASSERT macro never does anything
#if defined(_DEBUG) && !defined(DEBUG)
#define DEBUG 1
#endif
#if defined(DEBUG) && !defined(_DEBUG)
#define _DEBUG 1
#endif

#define NOTRACE 1

////////////////////////////////////////////////////////////////////////////
// tracing wrappers

// can't call HRESULT_FROM_WIN32 with a fn as a parameter cuz it is a macro
//  and evaluates the expression 3 times.  This is a particularlly bad thing
//  when u don't look at macros first to see what they do.
_inline HRESULT ChangeErrToHR(DWORD dwErr) { return HRESULT_FROM_WIN32(dwErr); }

#if defined(NOTRACE)
    #define INIT_TRACING

    #define TERM_TRACING

    #define USE_TRACING(sz)

    #define TESTHR(hr, fn)                                                  \
            hr = (fn);

    #define TESTBOOL(hr, fn)                                                \
            hr = ((fn) ? NOERROR : HRESULT_FROM_WIN32(GetLastError()));

    #define TESTERR(hr, fn)                                                 \
            SetLastError((fn));                                             \
            hr = HRESULT_FROM_WIN32(GetLastError());

    #define VALIDATEPARM(hr, expr)                                          \
            hr = ((expr) ? E_INVALIDARG : NOERROR);

    #define VALIDATEEXPR(hr, expr, hrErr)                                   \
            hr = ((expr) ? (hrErr) : NOERROR);

#else
    #define INIT_TRACING                                                    \
            InitAsyncTrace();

    #define TERM_TRACING                                                    \
            TermAsyncTrace();

    #define USE_TRACING(sz)                                                 \
            TraceQuietEnter(sz);                                            \
            TraceFunctEntry(sz);                                            \
            DWORD __dwtraceGLE = GetLastError();                            \

    #define TESTHR(hr, fn)                                                  \
            if (FAILED(hr = (fn)))                                          \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                ErrorTrace(0, "%s failed.  Err: 0x%08x", #fn, hr);          \
                SetLastError(__dwtraceGLE);                                 \
            }                                                               \

    #define TESTBOOL(hr, fn)                                                \
            hr = NOERROR;                                                   \
            if ((fn) == FALSE)                                              \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                hr = HRESULT_FROM_WIN32(__dwtraceGLE);                      \
                ErrorTrace(0, "%s failed.  Err: 0x%08x", #fn, hr);          \
                SetLastError(__dwtraceGLE);                                 \
            }

    #define TESTERR(hr, fn)                                                 \
            SetLastError((fn));                                             \
            if (FAILED(hr = HRESULT_FROM_WIN32(GetLastError())))            \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                ErrorTrace(0, "%s failed.  Err: %d", #fn, hr);              \
                SetLastError(__dwtraceGLE);                                 \
            }

    #define VALIDATEPARM(hr, expr)                                          \
            if (expr)                                                       \
            {                                                               \
                ErrorTrace(0, "Invalid parameters passed to %s",            \
                           ___pszFunctionName);                             \
                SetLastError(ERROR_INVALID_PARAMETER);                      \
                hr = E_INVALIDARG;                                          \
            }                                                               \
            else hr = NOERROR;

    #define VALIDATEEXPR(hr, expr, hrErr)                                   \
            if (expr)                                                       \
            {                                                               \
                ErrorTrace(0, "Expression failure %s", #expr);              \
                hr = (hrErr);                                               \
            }                                                               \
            else hr = NOERROR;

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\faulth\faulth.h ===
#include "msodw.h"

#define FAULTH_CREATE_NAME  "FAULTHCreate"
#define FAULTH_DELETE_NAME  "FAULTHDelete"
#define FAULTH_WININET_NAME "WININET.DLL"

#define WININET_MIN_VERSION 4.72.2106.5
#define FAULTH_WININET_MIN_MS ((4<<16)+72)
#define FAULTH_WININET_MIN_LS ((2106<<16)+5)

#define DW_MAX_ADDFILES     1024

typedef struct _SETUP_FAULT_HANDLER *PSETUP_FAULT_HANDLER;

// Ascii Version of functions
typedef void (* PFAULTHSetURLMethodA)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCSTR                pszURL
                            );

typedef void (* PFAULTHSetAdditionalFilesMethodA)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCSTR                pszAdditionalFiles
                            );

typedef void (* PFAULTHSetAppNameMethodA)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCSTR                pszAppName
                            );

typedef void (* PFAULTHSetErrorTextA)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCSTR                pszErrorText
                            );


// Unicode Version of functions
typedef void (* PFAULTHSetURLMethodW)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCWSTR               pwszURL
                            );

typedef void (* PFAULTHSetAdditionalFilesMethodW)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCWSTR               pwszAdditionalFiles
                            );

typedef void (* PFAULTHSetAppNameMethodW)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCWSTR               pwszAppName
                            );

typedef void (* PFAULTHSetErrorTextW)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN PCWSTR               pwszErrorText
                            );


typedef void (* PFAULTHSetLCID)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN LCID                 lcid
                            );

typedef BOOL (* PFAULTHIsSupported)(
                            IN PSETUP_FAULT_HANDLER This
                            );

typedef EFaultRepRetVal (*PREPORTFAULTA_FN)(
                            IN PSETUP_FAULT_HANDLER This,
                            IN LPEXCEPTION_POINTERS pep,
                            IN DWORD dwReserved
                            );

typedef struct _SETUP_FAULT_HANDLER {
    //
    // Data members
    //
    CHAR                szURL[DW_MAX_SERVERNAME];
    WCHAR               wzAppName[DW_APPNAME_LENGTH];
    WCHAR               wzAdditionalFiles[DW_MAX_ADDFILES];
    WCHAR               wzErrorText[DW_MAX_ERROR_CWC];
    LCID                lcid;
    BOOL                bDebug;

    //
    // Methods
    //
    PFAULTHSetURLMethodA   SetURLA;
    PFAULTHSetAppNameMethodA   SetAppNameA;
    PFAULTHSetAdditionalFilesMethodA SetAdditionalFilesA;
    PFAULTHSetErrorTextA SetErrorTextA;

    PFAULTHSetURLMethodW   SetURLW;
    PFAULTHSetAppNameMethodW   SetAppNameW;
    PFAULTHSetAdditionalFilesMethodW SetAdditionalFilesW;
    PFAULTHSetErrorTextW SetErrorTextW;
    
    
    PFAULTHSetLCID SetLCID;
    PFAULTHIsSupported IsSupported;
    PREPORTFAULTA_FN      Report;

} SETUP_FAULT_HANDLER,*PSETUP_FAULT_HANDLER;

typedef PSETUP_FAULT_HANDLER (APIENTRY *PFAULTHCreate) (VOID);

typedef VOID (APIENTRY *PFAULTHDelete)(IN PSETUP_FAULT_HANDLER This);

PSETUP_FAULT_HANDLER
FAULTHCreate(
    VOID
    );

VOID
FAULTHDelete(
    IN PSETUP_FAULT_HANDLER This
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\exe\i386\download.c ===
#include <windows.h>
#include "download.h"
#include "setupbat.h"


//
// these are the critical files that must be copied locally if the
// upgrade of a Win9x system is performed over a network
//

static PCTSTR g_CriticalFiles[] = {
    TEXT("WINNT32.EXE"),
    TEXT("WINNT32A.DLL"),
    TEXT("WINNTBBA.DLL"),
    TEXT("PIDGEN.DLL"),
    TEXT("WSDU.DLL"),
    TEXT("WSDUENG.DLL"),
    TEXT("HWDB.DLL"),
    TEXT("WIN9XUPG"),
    TEXT("drw")
};

//
// these are the critical files for NEC98 plattform that must be copied
//  locally if the upgrade of a Win9x system is performed over a network
//

static PCTSTR g_NEC98_CriticalFiles[] = {
    TEXT("98PTN16.DLL"),
    TEXT("98PTN32.DLL")
};

//
// these are non-critical files that should be copied locally if the
// upgrade of a Win9x system is performed over a network
//

static PCTSTR g_NonCriticalFiles[] = {
    TEXT("IDWLOG.EXE"),
// #define RUN_SYSPARSE = 1
#ifdef RUN_SYSPARSE
    TEXT("SYSPARSE.EXE"),
#endif
    TEXT("WINNT32.HLP"),
    TEXT("DOSNET.INF"),
};

BOOL
pIsSpecialDir (
    IN      PCTSTR Dir
    )

/*++

Routine Description:

  pIsSpecialDir decides if the given dir is a special directory, like . or ..

Arguments:

  Dir - Specifies the directory name only (no path)

Return Value:

  TRUE if the specified dir name is a special name

--*/

{
    return
        *Dir == TEXT('.') &&
        (*(Dir + 1) == 0 || *(Dir + 1) == TEXT('.') && *(Dir + 2) == 0)
        ;
}


BOOL
CopyNode (
    IN      PCTSTR SrcBaseDir,
    IN      PCTSTR DestBaseDir,
    IN      PCTSTR NodeName,
    IN      BOOL FailIfExist
    )

/*++

Routine Description:

  CopyNode copies NodeName (file or subdir) from SrcBaseDir to DestBaseDir.

Arguments:

  SrcBaseDir - Specifies the source base directory name

  DestBaseDir - Specifies the destination base directory name

  NodeName - Specifies the file or subdirectory name to copy

  FailIfExist - Specifies if the operation should fail if there is
                already a node with the same name at destination

Return Value:

  TRUE if the copy operation was actually done

--*/

{
    DWORD FileAttr;
    TCHAR SrcDir[MAX_PATH];
    TCHAR DestDir[MAX_PATH];
    HANDLE h;
    WIN32_FIND_DATA fd;
    WIN32_FIND_DATA fdSrc;

    lstrcpy (SrcDir, SrcBaseDir);
    lstrcpy (DestDir, DestBaseDir);

    //
    // check for "\" at the end of dir name
    //
    ConcatenatePaths (SrcDir, NodeName);

    h = FindFirstFile (SrcDir, &fdSrc);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    CloseHandle (h);

    if (GetFileAttributes (DestDir) == -1) {
        if (!CreateDirectory (DestDir, NULL)) {
            return FALSE;
        }
    }

    if (fdSrc.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        //
        // skip to the end of dir name
        //
        ConcatenatePaths (DestDir, NodeName);

        ConcatenatePaths (SrcDir, TEXT("*"));

        h = FindFirstFile (SrcDir, &fd);

        *FindLastWack (SrcDir) = 0;

        //
        // recursively copy all files in that dir
        //
        if (h != INVALID_HANDLE_VALUE) {
            do {
                //
                // skip over special dirs
                //
                if (pIsSpecialDir (fd.cFileName)) {
                    continue;
                }

                if (!CopyNode (SrcDir, DestDir, fd.cFileName, FailIfExist)) {
                    return FALSE;
                }
            } while (FindNextFile (h, &fd));
        }
    } else {
        //
        // copy the file
        //
        ConcatenatePaths (DestDir, NodeName);
        if (!CopyFile (SrcDir, DestDir, FailIfExist)) {
            return FALSE;
        }
        //
        // set file timestamps to match exactly the ones of the original
        // ignore errors in this case
        //
        SetFileAttributes (DestDir, FILE_ATTRIBUTE_NORMAL);
        h = CreateFile (DestDir, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (h != INVALID_HANDLE_VALUE) {
            SetFileTime (h, &fdSrc.ftCreationTime, &fdSrc.ftLastAccessTime, &fdSrc.ftLastWriteTime);
            CloseHandle (h);
        }
    }

    return TRUE;
}


BOOL
DeleteNode (
    IN      PCTSTR NodeName
    )

/*++

Routine Description:

  DeleteNode deletes NodeName directory and all its subdirectories

Arguments:

  NodeName - Specifies the directory name to delete

Return Value:

  TRUE if the delete operation was successful; FALSE if only part
  of the files/subdirs were deleted

--*/

{
    DWORD FileAttr;
    TCHAR DestDir[MAX_PATH];
    PTSTR p;
    HANDLE h;
    WIN32_FIND_DATA fd;
	BOOL Success = TRUE;

    if (!NodeName || !*NodeName) {
        return FALSE;
    }

    FileAttr = GetFileAttributes (NodeName);
    if (FileAttr == -1)
        return TRUE;

    if (!SetFileAttributes (NodeName, FILE_ATTRIBUTE_NORMAL)) {
        return FALSE;
    }

    if (FileAttr & FILE_ATTRIBUTE_DIRECTORY) {

        lstrcpy (DestDir, NodeName);

        ConcatenatePaths (DestDir, TEXT("*"));

        h = FindFirstFile (DestDir, &fd);

        p = FindLastWack (DestDir);

        //
        // recursively copy all files in that dir
        //
        if (h != INVALID_HANDLE_VALUE) {
            do {
                //
                // skip over special dirs
                //
                if (pIsSpecialDir (fd.cFileName)) {
                    continue;
                }

                lstrcpy (p + 1, fd.cFileName);
                if (!DeleteNode (DestDir)) {
                    Success = FALSE;
                }
            } while (FindNextFile (h, &fd));
        }

        //
        // now delete the base dir
        //
        *p = 0;

        if (!RemoveDirectory (DestDir)) {
            Success = FALSE;
        }
    } else {
        //
        // delete the file
        //
        if (!DeleteFile (NodeName)) {
            Success = FALSE;
        }
    }

    return Success;
}


BOOL
DownloadProgramFiles (
    IN      PCTSTR SourceDir,
    IN      PCTSTR DownloadDest,
    IN      PCTSTR* ExtraFiles      OPTIONAL
    )

/*++

Routine Description:

  DownloadProgramFiles copies from SourceDir to DownloadDest
  all specific program files (specified in g_CriticalFiles,
  g_NEC98_CriticalFiles, and g_NonCriticalFiles arrays).

Arguments:

  SourceDir - Specifies the source directory

  DownloadDest - Specifies the destination directory

  ExtraFiles - Specifies an array of extra files (full paths)
               to be copied to the destination directory;
               the array must be NULL terminated

Return Value:

  TRUE if the download operation was successful and all critical
  files were copied locally; FALSE otherwise

--*/

{
    TCHAR SourcePath[MAX_PATH];
    TCHAR DestPath[MAX_PATH];
    INT i;
    PTSTR FileName;
    TCHAR FullPathName[MAX_PATH];

    //
    // first delete any old stuff to make place
    //
    DeleteNode (DownloadDest);

    //
    // copy there the new stuff
    //
    lstrcpy (SourcePath, SourceDir);
    lstrcpy (DestPath, DownloadDest);

    for (i = 0; i < sizeof (g_CriticalFiles) / sizeof (g_CriticalFiles[0]); i++) {
        //
        // download this one to the destination directory
        //
        if (!CopyNode (SourcePath, DestPath, g_CriticalFiles[i], FALSE)) {
            DeleteNode (DownloadDest);
            return FALSE;
        }
    }

    if (ExtraFiles) {
        while (*ExtraFiles) {
            FileName = FindLastWack ((PTSTR)*ExtraFiles);
            if (FileName) {
                lstrcpy (FullPathName, DownloadDest);
                lstrcat (FullPathName, FileName);
                CopyFile (*ExtraFiles, FullPathName, FALSE);
            }
            ExtraFiles++;
        }
    }

    for (i = 0; i < sizeof (g_CriticalFiles) / sizeof (g_CriticalFiles[0]); i++) {
        //
        // download this one to the destination directory
        //
        if (!CopyNode (SourcePath, DestPath, g_CriticalFiles[i], FALSE)) {
            DeleteNode (DownloadDest);
            return FALSE;
        }
    }

    for (i = 0; i < sizeof (g_NEC98_CriticalFiles) / sizeof (g_NEC98_CriticalFiles[0]); i++) {
	//
	// download this one to the destination directory
	//
	// Never check for error. Because winnt32a.dll check plattform and
        // sources with NEC98 specific file(98ptn16.dll).
        // See winnt32\dll\winnt32.c line 2316.
	//
        CopyNode (SourcePath, DestPath, g_NEC98_CriticalFiles[i], FALSE);
    }
    for (i = 0; i < sizeof (g_NonCriticalFiles) / sizeof (g_NonCriticalFiles[0]); i++) {
        //
        // download this one to the destination directory
        //
        CopyNode (SourcePath, DestPath, g_NonCriticalFiles[i], FALSE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\exe\i386\download.h ===
#pragma once



PTSTR
FindLastWack (
    IN      PTSTR String
    );


PTSTR
DuplicateText (
    IN      PCTSTR Text
    );

VOID
ConcatenatePaths (
    IN      PTSTR LeadingPath,
    IN      PCTSTR TrailingPath
    );

BOOL
DownloadProgramFiles (
    IN      PCTSTR SourceDir,
    IN      PCTSTR DownloadDest,
    IN      PCTSTR* ExtraFiles
    );

BOOL
CopyNode (
    IN      LPCTSTR SrcBaseDir,
    IN      LPCTSTR DestBaseDir,
    IN      LPCTSTR NodeName,
    IN      BOOL FailIfExist
    );

BOOL
DeleteNode (
    IN      LPCTSTR NodeName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\fsfilter\fsfilter.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This dll finds file system filters

Author:

    George Jenkins (georgeje) Aug-28-98

Environment:

    User Mode

--*/

#include <windows.h>
#include <wchar.h>
#include <comp.h>
#include <imagehlp.h>
#include "fsfilter.h"

STRING_LIST_ENTRY GoodFilterList;
STRING_LIST_ENTRY ImportPrefixList;

LPWSTR GoodFilterBuffer;
LPWSTR ImportPrefixBuffer;

HINSTANCE MyhInstance;

WCHAR TxtFileName[MAX_PATH];

WCHAR HtmlFileName[MAX_PATH];

VOID
InitializeStringLists(
    VOID
    );

VOID
FreeStringLists(
    VOID
    );

BOOL
IsBadFilter(
    LPWSTR DriverName,
    LPWSTR DriverDirectory
    );

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );


BOOL
WINAPI
FsFilterDllInit(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
/*++

Routine Description:

    Initializes the dll.

Arguments:

    hInstance   - dll instance handle
    Reason      - reason code
    Context     - context pointer

Return Value:

    TRUE
--*/
{
    if (Reason == DLL_PROCESS_ATTACH) {
        MyhInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );        
    }

    return TRUE;
}


BOOL
CheckForFsFilters(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
/*++

Routine Description:

    Looks for installed file system filter drivers that are enabled.  The algorithm is as follows:

    1) If the filter is listed in the [ServicesToDisable] or [ServicesToStopInstallation] sections
       of dosnet.inf, the winnt32 will handle that particular driver.  This dll is to catch drivers
       that aren't listed there.
    
    2) Read fsfilter.inf and build two string lists.  One list contains the name of known good filters.
       The other list contains the prefixes of names to look for in the import table of the driver.

    3) recurse through HKLM\system\currentcontrolset\services and look for drivers that have the Group
       "filter".  If the driver is a known good driver, ignore it.  Otherwise, load the image and grovel
       through the import table looking for imports that have prefixes that are in the import prefix list.
       If there are any hits, it is assumed that the driver is a file system filter and the upgrade will be
       stopped until the user deals with the problem.

Arguments:

    CompatibilityCallback   - pointer to call back function
    Context     - context pointer

Return Value:

    TRUE
--*/
{
    
    HKEY    ServicesKey = INVALID_HANDLE_VALUE;
    HKEY    DriverKey = INVALID_HANDLE_VALUE;
    LONG    Result;
    DWORD   SubKeyCount;
    DWORD   Size;
    DWORD   Index;
    LPWSTR  KeyNameBuffer = NULL;
    BYTE    ValueBuffer[SIZE_STRINGBUF];
    DWORD   Type;
    LPWSTR  DriverDirectory = NULL;
    DWORD   MaxKeyLen;
    COMPATIBILITY_ENTRY CompEntry;

    ZeroMemory((PVOID)&CompEntry, sizeof(COMPATIBILITY_ENTRY));
    
    CompEntry.TextName = TxtFileName;
    CompEntry.HtmlName = HtmlFileName;
    
    InitializeStringLists();
    
    Result = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REGKEY_SERVICES,
            0,
            KEY_READ,
            &ServicesKey
            );

    if (Result != ERROR_SUCCESS) {
        return TRUE;
    }
    
    // enumerate all of the services
    
    Result = RegQueryInfoKey(
        ServicesKey,
        NULL,
        NULL,
        NULL,
        &SubKeyCount,
        &MaxKeyLen,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

    if (Result != ERROR_SUCCESS) {
        goto exit;
    }
    
    KeyNameBuffer = (LPWSTR) LocalAlloc( LPTR, (MaxKeyLen + 1) * sizeof(WCHAR));

    if (KeyNameBuffer == NULL) {
        goto exit;
    }
    
    Size = ExpandEnvironmentStrings( DRIVER_DIRECTORY, NULL, 0 );

    DriverDirectory = LocalAlloc( LPTR, Size * sizeof(WCHAR) );

    if (DriverDirectory != NULL) {
        ExpandEnvironmentStrings( DRIVER_DIRECTORY, DriverDirectory, Size );
    } else {
        goto exit;
    }
    
    for (Index = 0; Index < SubKeyCount; Index++) {
        DWORD StartValue;
        DWORD SetupChecked;

        Size = MaxKeyLen;
        Result = RegEnumKeyEx(
            ServicesKey,
            Index,
            KeyNameBuffer,
            &Size,
            NULL,
            NULL,
            NULL,
            NULL
            );

        if (Result != ERROR_SUCCESS) {
            goto exit;
        }
        
        Result = RegOpenKeyEx(
                ServicesKey,
                KeyNameBuffer,
                0,
                KEY_READ,
                &DriverKey
                );
        if (Result != ERROR_SUCCESS) {
            continue;
        }
        
        Size = SIZE_STRINGBUF;
        
        Result = RegQueryValueEx(
                DriverKey,
                REGVAL_GROUP,
                0,
                &Type,
                ValueBuffer,
                &Size
                );
        if (Result != ERROR_SUCCESS || Type != REG_SZ) {
            RegCloseKey( DriverKey );
            continue;
        }
        
        
        //
        // if the driver is disabled, ignore it
        //
        Size = sizeof(StartValue);
        Result = RegQueryValueEx(
                DriverKey,
                REGVAL_START,
                0,
                &Type,
                (LPBYTE)&StartValue,
                &Size
                );

        if (Result != ERROR_SUCCESS || Type != REG_DWORD) {
            RegCloseKey( DriverKey );
            continue;
        }
        
        //
        // if winnt32 has checked this driver, skip it
        //
        Size = sizeof(SetupChecked);
        Result = RegQueryValueEx(
                DriverKey,
                REGVAL_SETUPCHECKED,
                0,
                &Type,
                (LPBYTE)&SetupChecked,
                &Size
                );

        if (Result == ERROR_SUCCESS && Type == REG_DWORD) {
            RegCloseKey( DriverKey );
            continue;
        }
        
        // 
        // if the group is not "filter" ignore it.
        //
        
        if (_wcsicmp( L"filter", (LPWSTR) ValueBuffer ) == 0 && 
            StartValue != SERVICE_DISABLED &&
            IsBadFilter(KeyNameBuffer, DriverDirectory)) {
                CompEntry.Description = (LPTSTR) KeyNameBuffer;
                if(!CompatibilityCallback(&CompEntry, Context)){
                    DWORD Error;
                    Error = GetLastError();
                }
        }
    
        RegCloseKey( DriverKey );
    }
    
exit:
    RegCloseKey( ServicesKey );
    
    LocalFree( KeyNameBuffer );
    LocalFree( DriverDirectory );
    
    FreeStringLists();

    return TRUE;
   
}

BOOL
IsBadFilter(
    LPWSTR FilterName,
    LPWSTR DriverDirectory
    )
/*++

Routine Description:

    Checks the driver name against the list of good drivers.  If it's not in the list, then scan the import
    table looking for certain imports.

Arguments:

    FilterName      - The services key name (driver name).
    DriverDirectory - Full path name to the driver.

Return Value:

    TRUE if the driver meets the above criteria, FALSE otherwise
--*/
{
    PLOADED_IMAGE Image;
    LPWSTR UnicodeImagePath;
    DWORD Size;
    LPSTR AnsiImagePath;
    BOOL RetVal = FALSE;
    PSTRING_LIST_ENTRY StringList;

    
    //
    // if the driver is in the known good list, ignore it
    //
    
    StringList = GoodFilterList.Next;

    while(StringList){
        if (_wcsicmp( (LPWSTR) StringList->String, FilterName) == 0) {
            return FALSE;
        }
        StringList = StringList->Next;
    }
    
    //
    // build up the path name to the driver
    //
    
    Size = wcslen( DriverDirectory );
    Size += wcslen( FilterName );
    Size += wcslen( DRIVER_SUFFIX );
    Size++;

    UnicodeImagePath = LocalAlloc( LPTR, Size * sizeof(WCHAR));
    
    if (UnicodeImagePath != NULL) {
        wcscpy( UnicodeImagePath, DriverDirectory );
        wcscat( UnicodeImagePath, FilterName );
        wcscat( UnicodeImagePath, DRIVER_SUFFIX );
    } else {
        return FALSE;
    }
    
    //
    // imagehlp wants ansi strings
    //
    AnsiImagePath = UnicodeStringToAnsiString( UnicodeImagePath );

    
    // 
    // The following code was transliterated from the linker.  Note
    // that the strings in the import table are ansi.
    //
    
    if (AnsiImagePath) {
        PIMAGE_IMPORT_DESCRIPTOR Imports;
        PIMAGE_NT_HEADERS NtHeader;
        PIMAGE_SECTION_HEADER FirstImageSectionHeader;
        DWORD ImportSize;

        Image = ImageLoad( AnsiImagePath, NULL );
        
        if (Image == NULL) {
            goto exit;
        }
        
        NtHeader = ImageNtHeader( (PVOID)Image->MappedAddress );
        
        Imports = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
                                        (PVOID)Image->MappedAddress,
                                        FALSE,
                                        IMAGE_DIRECTORY_ENTRY_IMPORT,
                                        &ImportSize
                                        );
        FirstImageSectionHeader = IMAGE_FIRST_SECTION( NtHeader );

        for (;!RetVal; Imports++) {
            WORD StringSection = 0;
            WORD IATSection;
            WORD i;
            DWORD Rva;
            DWORD RvaMax;
            DWORD IATRva;
            DWORD INTRva;
            DWORDLONG INTVa;
            PIMAGE_SECTION_HEADER ImageSectionHeader;
            LPSTR Name;

            if (Imports->Characteristics == 0 && Imports->Name == 0 && Imports->FirstThunk == 0) {
                break;
            }
            
            for (i = 0; i < NtHeader->FileHeader.NumberOfSections; i++) {
            
                ImageSectionHeader = &FirstImageSectionHeader[i];
                                        
                Rva = ImageSectionHeader->VirtualAddress;
                RvaMax = Rva + ImageSectionHeader->SizeOfRawData;
    
                if (Imports->Name >= Rva && Imports->Name < RvaMax) {
                    StringSection = i;
                }

                if (Imports->FirstThunk >= Rva && Imports->FirstThunk < RvaMax) {
                    IATSection = i;
                }
            }

            ImageSectionHeader = ImageRvaToSection( NtHeader, Image->MappedAddress, Imports->Name );

            IATRva = Imports->FirstThunk -
                FirstImageSectionHeader[IATSection].VirtualAddress + 
                FirstImageSectionHeader[IATSection].PointerToRawData;
            
            if (Imports->Characteristics == 0) {
                INTRva = IATRva;
                IATRva = 0;
                INTVa = 0;
            } else {

                INTRva = Imports->Characteristics -
                    ImageSectionHeader->VirtualAddress + 
                    ImageSectionHeader->PointerToRawData;
                
                if (Imports->TimeDateStamp == 0) {

                    IATRva = 0;
                }
            
                INTVa = (DWORDLONG) ImageRvaToVa( 
                            NtHeader, 
                            Image->MappedAddress,
                            Imports->OriginalFirstThunk, 
                            NULL 
                            );

                Name = (LPSTR) ImageRvaToVa(
                    NtHeader,
                    Image->MappedAddress,
                    Imports->Name - FirstImageSectionHeader->VirtualAddress + FirstImageSectionHeader->PointerToRawData,
                    NULL
                    );
            
                //
                // We only care about imports from ntoskrnl.exe
                //
                
                if (strcmp( Name, "ntoskrnl.exe" ) != 0) {
                    continue;
                }
                
                while(!RetVal){
                    PIMAGE_THUNK_DATA32 Thunk;
                    PIMAGE_THUNK_DATA32 IATThunk;

                    Thunk = (PIMAGE_THUNK_DATA32) INTVa;
                    
                    if (Thunk->u1.AddressOfData == 0) {
                        break;
                    }
                    
                    //
                    // Don't need to handle imports by ordinal
                    //
                    if (IMAGE_SNAP_BY_ORDINAL32(Thunk->u1.Ordinal)) {
                        break;
                    }
                    
                    INTVa += sizeof(IMAGE_THUNK_DATA32);

                    for (i = 0; i < NtHeader->FileHeader.NumberOfSections; i++ ) {
                        ImageSectionHeader = &FirstImageSectionHeader[i];
                                                
                        Rva = ImageSectionHeader->VirtualAddress;
                        RvaMax = Rva + ImageSectionHeader->SizeOfRawData;
        
                        if ((DWORD)Thunk->u1.AddressOfData >= Rva && (DWORD)Thunk->u1.AddressOfData < RvaMax) {
                            break;
                        }
                    }    
                    
                    Name = (LPSTR) ImageRvaToVa(
                        NtHeader,
                        Image->MappedAddress,
                        (DWORD)Thunk->u1.AddressOfData - FirstImageSectionHeader[i].VirtualAddress + FirstImageSectionHeader[i].PointerToRawData,
                        NULL
                        );
                    
                    Name += sizeof(WORD);
                        
                    //
                    // Compare the import name with prefixes in the prefix list.  If there is a substring match,
                    // then this driver will stop setup.
                    //
                    
                    StringList = ImportPrefixList.Next;
                    while (StringList) {
                        if (_strnicmp(Name, StringList->String, strlen(StringList->String)) == 0) {
                            RetVal = TRUE;
                            break;
                        }                    
                        StringList = StringList->Next;    
                    }
                }
                
            }
     
        }
            
    }     
exit:    
    
    if (Image != NULL) {
        ImageUnload( Image );
    }
    LocalFree( AnsiImagePath );    
    LocalFree( UnicodeImagePath );    
    
    return RetVal;
}

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    )
/*++

Routine Description:

    Allocates a buffer and converts a Unicode string into an ansi string and copies
    it into the buffer.

Arguments:

    UnicodeString   - The Unicode string to convert.

Return Value:

    A pointer to the buffer containing the ansi string.  Note that the caller must free this
    buffer.
--*/
{
    DWORD Count;
    LPSTR AnsiString;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    AnsiString = (LPSTR) LocalAlloc( LPTR, Count );
    if (!AnsiString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        LocalFree( AnsiString );
        return NULL;
    }

    return AnsiString;
}

LPWSTR
GetSection(
    LPCWSTR Name,
    LPWSTR FileName
    )
/*++

Routine Description:

    Reads the given section from the inf file.

Arguments:

    Name          - The section name.
    FileName      - Full path name of the inf file.

Return Value:

    A pointer to a buffer containing the entire section.  See docs on GetPrivateProfileSection.
--*/
{
    LPWSTR SectionBuffer;
    DWORD Size = SIZE_SECTIONBUF;
    DWORD ReturnedSize;

    SectionBuffer = LocalAlloc( LPTR, Size * sizeof(WCHAR) );

    if (SectionBuffer == NULL) {
        return NULL;
    }
    
    while(TRUE){
        
        ReturnedSize = GetPrivateProfileSection( Name, SectionBuffer, Size, FileName  );
        
        if (ReturnedSize == Size - 2) {
        
            LocalFree( SectionBuffer );
            
            Size *= 2;

            SectionBuffer = LocalAlloc( LPTR, Size * sizeof(WCHAR) );
        
            if (SectionBuffer == NULL) {
                return NULL;
            }
        } else if (ReturnedSize == 0){
            return NULL;
        } else {
            break;
        }

    }
    
    return SectionBuffer;
}


VOID
ReplaceExtension(
    LPWSTR Path,
    LPWSTR NewExt
    )
/*++

Routine Description:

    Replaces the file extension in Path with the one in NewExt.

Arguments:

    Path      - File name
    NewExt    - the new extension

Return Value:

    
--*/
{
    LPWSTR Temp;

    Temp = wcsrchr( Path, L'.' );

    if (Temp) {
        wcscpy( ++Temp, NewExt );
    } else {
        wcscat( Path, L"." );
        wcscat( Path, NewExt );
    }
}


VOID
InitializeStringLists(
    VOID
    )
/*++

Routine Description:

    Initialize the string lists and the file names.

Arguments:


Return Value:
--*/
{

    WCHAR InfFileName[MAX_PATH];
    DWORD Result;
    LPWSTR UStr;
    LPSTR AStr;
    PSTRING_LIST_ENTRY NewString;

    //
    // The GoodFilterList is Unicode.  Since the buffer returned by GetSection has
    // Unicode strings in it, we can keep it around and just point the string list
    // into that buffer.  Since the ImportPrefixList contains Ansi strings, we allocate
    // a new buffer and convert from Unicode to Ansi.  These strings have to be individually
    // freed.
    //

    InitializeList( &GoodFilterList );
    InitializeList( &ImportPrefixList );
    
    Result = GetModuleFileName( MyhInstance, InfFileName, MAX_PATH );

    if (Result == 0) {
        return;
    }
    
    wcscpy(HtmlFileName, InfFileName);

    wcscpy(TxtFileName, InfFileName);

    ReplaceExtension( HtmlFileName, L"htm" );
    ReplaceExtension( TxtFileName, L"txt" );
    ReplaceExtension( InfFileName, L"inf" );

    GoodFilterBuffer = GetSection( L"filters", InfFileName );
    ImportPrefixBuffer = GetSection( L"imports", InfFileName );
        
    //
    // Build the GoodFilterList (Unicode)
    //
    
    for (UStr = GoodFilterBuffer; UStr && *UStr; UStr++) {
        
        NewString = (PSTRING_LIST_ENTRY) LocalAlloc( LPTR, sizeof(STRING_LIST_ENTRY));
    
        if (NewString == NULL) {
            return;
        }

        NewString->String = (LPVOID)UStr;
        
        PushEntryList( &GoodFilterList, NewString );
        
        while(*++UStr){
            ;
        }
    }

    //
    // Build the ImportPrefixList.  Convert the Unicode strings to Ansi.
    //

    for (UStr = ImportPrefixBuffer; UStr && *UStr; UStr++) {
        
        NewString = (PSTRING_LIST_ENTRY) LocalAlloc( LPTR, sizeof(STRING_LIST_ENTRY));
    
        if (NewString == NULL) {
            return;
        }
    
        NewString->String = (LPVOID)UnicodeStringToAnsiString( UStr );
        
        PushEntryList( &ImportPrefixList, NewString );
        
        while(*++UStr){
            ;
        }
    }   
}

VOID
FreeStringLists(
    VOID
    )
/*++

Routine Description:

    Frees the string lists, ansi strings and buffers holding inf sections.

Arguments:

Return Value:

--*/
{
    PSTRING_LIST_ENTRY Temp;
    
    
    Temp = PopEntryList( &GoodFilterList );
    while(Temp) {
        LocalFree( Temp );
        Temp = PopEntryList( &GoodFilterList );
    }

    Temp = PopEntryList( &ImportPrefixList );
    while (Temp) {
        LocalFree( Temp->String );
        LocalFree( Temp );
        Temp = PopEntryList( &ImportPrefixList );
    }

    LocalFree( GoodFilterBuffer );
    LocalFree( ImportPrefixBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\faulth\faulth.c ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    faulth.c

Abstract:
    Implements fault reporting functions

Revision History:
    Much of this code taken from admin\pchealth\client\faultrep

******************************************************************************/

#include <windows.h>
#include <winver.h>
#include <ntverp.h>
#include <errorrep.h>
#include "util.h"
#include "faulth.h"

//#define TEST_WATSON 1

static LPWSTR
plstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR src,dst;

    __try {
        src = (LPWSTR)lpString2;
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
                }
            if ( iMaxLength ) {
                *dst = '\0';
                }
            else {
                dst--;
                *dst = '\0';
                }
            }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return lpString1;
}

#define sizeofSTRW(wsz) sizeof(wsz) / sizeof(wsz[0])
///////////////////////////////////////////////////////////////////////////////
// Global stuff

#ifdef TEST_WATSON
const CHAR  c_szDWDefServerI[]  = "officewatson";
#else
const CHAR  c_szDWDefServerI[]  = "watson.microsoft.com";
#endif
const CHAR  c_szDWBrand[]       = "WINDOWS";
const WCHAR c_wzDWDefAppName[]  = L"Application";
const CHAR  c_wszDWCmdLineU[]   = "%s\\dwwin.exe -x -s %lu";
#define c_DWDefaultLCID           1033

_inline DWORD RolloverSubtract(DWORD dwA, DWORD dwB)
{
    return (dwA >= dwB) ? (dwA - dwB) : (dwA + ((DWORD)-1 - dwB));
}

#ifdef TEST_WATSON
HANDLE hFaultLog = INVALID_HANDLE_VALUE;
char    *c_wszLogFileName = "faulth.log";

// Need to synchroize this?
static DebugLog(char *pszMessage, ...)
{
    va_list arglist;

    if( !pszMessage)
        return 0;

    va_start(arglist,pszMessage);
    
    if (hFaultLog != INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME  st;
        DWORD       cb, cbWritten;
        char        szMsg[512];

        GetSystemTime(&st);
        cb = wsprintf(szMsg, 
                      "%02d-%02d-%04d %02d:%02d:%02d ",
                      st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, st.wSecond
                      );
        WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
        /*cb = FormatMessageA(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                    pszMessage,
                    0,0,
                    szMsg,
                    0,
                    &arglist
                    );*/
        cb = wsprintf(szMsg, pszMessage, &arglist);
        WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
    }
    va_end(arglist);
    return 1;
}
#else

#define DebugLog(x)

#endif

HINSTANCE g_hInstance = NULL;

///////////////////////////////////////////////////////////////////////////////
// DllMain

// **************************************************************************

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
            //DisableThreadLibraryCalls(hInstance);
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}


static
EFaultRepRetVal
StartDWException( 
                  IN   PSETUP_FAULT_HANDLER This,
                  IN   LPEXCEPTION_POINTERS pep,
                  IN   DWORD dwOpt,
                  IN   DWORD dwFlags,
                  IN   DWORD dwTimeToWait)
{
    SECURITY_ATTRIBUTES sa;
    PROCESS_INFORMATION pi;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    DWSharedMem15       *pdwsm = NULL;
    STARTUPINFOA        si;
    HRESULT             hr = NOERROR;
    HANDLE              hevDone = NULL, hevAlive = NULL, hmut = NULL;
    HANDLE              hfmShared = NULL, hProc = NULL;
    HANDLE              rghWait[2];
    DWORD               dw, dwStart;
    BOOL                fDWRunning = TRUE;
    char                szCmdLine[MAX_PATH], szDir[MAX_PATH];
    char                szModuleFileName[DW_MAX_PATH];
    char                *pch;


    VALIDATEPARM(hr, (pep == NULL));
    if (FAILED(hr))
        goto done;

    // we need the following things to be inheritable, so create a SD that
    //  says it can be.
    ZeroMemory(&sa, sizeof(sa));
    sa.nLength        = sizeof(sa);
    sa.bInheritHandle = TRUE;

    // create the necessary events & mutexes
    hevDone = CreateEvent(&sa, FALSE, FALSE, NULL);
    TESTBOOL(hr, (hevDone != NULL));
    if (FAILED(hr))
        goto done;

    hevAlive = CreateEvent(&sa, FALSE, FALSE, NULL);
    TESTBOOL(hr, (hevAlive != NULL));
    if (FAILED(hr))
        goto done;

    hmut = CreateMutex(&sa, FALSE, NULL);
    TESTBOOL(hr, (hmut != NULL));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), 
                                 GetCurrentProcess(), &hProc, 
                                 PROCESS_ALL_ACCESS, TRUE, 0));
    if (FAILED(hr))
        goto done;

    // create the shared memory region & map it
    hfmShared = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE, 0,
                                  sizeof(DWSharedMem), NULL);
    TESTBOOL(hr, (hfmShared != NULL));
    if (FAILED(hr))
        goto done;

    pdwsm = (DWSharedMem *)MapViewOfFile(hfmShared, 
                                         FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 
                                         0);
    TESTBOOL(hr, (pdwsm != NULL));
    if (FAILED(hr))
        goto done;


    // populate all the stuff that DW needs
    ZeroMemory(pdwsm, sizeof(DWSharedMem15));

    pdwsm->dwSize            = sizeof(DWSharedMem15);
    pdwsm->pid               = GetCurrentProcessId();
    pdwsm->tid               = GetCurrentThreadId();
    pdwsm->eip               = (DWORD_PTR)pep->ExceptionRecord->ExceptionAddress;
    pdwsm->pep               = pep;
    pdwsm->hEventDone        = hevDone;
    pdwsm->hEventNotifyDone  = NULL;
    pdwsm->hEventAlive       = hevAlive;
    pdwsm->hMutex            = hmut;
    pdwsm->hProc             = hProc;
    pdwsm->bfDWBehaviorFlags = dwFlags;
    pdwsm->msoctdsResult     = msoctdsNull;
    pdwsm->fReportProblem    = FALSE;
    pdwsm->bfmsoctdsOffer    = msoctdsQuit;
    pdwsm->bfmsoctdsNotify   = 0;
    if (dwOpt == 1)
        pdwsm->bfmsoctdsOffer |= msoctdsDebug;
    pdwsm->bfmsoctdsLetRun   = pdwsm->bfmsoctdsOffer;
    pdwsm->iPingCurrent      = 0;
    pdwsm->iPingEnd          = 0;
    pdwsm->lcidUI            = 1033;

    lstrcpynA( pdwsm->szServer, This->szURL, DW_MAX_SERVERNAME);
    lstrcpynA( pdwsm->szBrand, c_szDWBrand, DW_APPNAME_LENGTH);
    GetModuleFileNameA( NULL, szModuleFileName, DW_MAX_PATH);
    MultiByteToWideChar( CP_ACP, 0, szModuleFileName, -1, pdwsm->wzModuleFileName, DW_MAX_PATH);

    plstrcpynW( pdwsm->wzFormalAppName, This->wzAppName, DW_APPNAME_LENGTH);
    plstrcpynW( pdwsm->wzAdditionalFile, This->wzAdditionalFiles, DW_MAX_ADDFILES);
    plstrcpynW( pdwsm->wzErrorText, This->wzErrorText, DW_MAX_ERROR_CWC);

    // create the process

    if (!GetModuleFileNameA( g_hInstance, szDir, MAX_PATH) ||
        !(pch = strrchr (szDir, '\\'))) {
        goto done;
    }
    *pch = '\0';
    wsprintf( szCmdLine, c_wszDWCmdLineU, szDir, hfmShared);
    DebugLog( "CommandLine ");
    DebugLog( szCmdLine);
    DebugLog( "CurrentDir ");
    DebugLog( szDir);
        
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    si.cb        = sizeof(si);
    si.lpDesktop = "Winsta0\\Default";

    TESTBOOL(hr, CreateProcessA(NULL, szCmdLine, NULL, NULL, TRUE, 
                                CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS,
                                NULL, szDir, &si, &pi));
    if (FAILED(hr))
        goto done;

    // don't need the thread handle & we gotta close it, so close it now
    CloseHandle(pi.hThread);
    
    // assume we succeed from here on...
    frrvRet = frrvOk;

    rghWait[0] = hevAlive;
    rghWait[1] = pi.hProcess;

    dwStart = GetTickCount();
    while(fDWRunning)
    {
        // gotta periodically get the Alive signal from DW.  
        switch(WaitForMultipleObjects(2, rghWait, FALSE, 120000))
        {
            case WAIT_OBJECT_0:
                if (WaitForSingleObject(hevDone, 0) == WAIT_OBJECT_0)
                    fDWRunning = FALSE;

                if (dwTimeToWait != (DWORD)-1 && 
                    RolloverSubtract(GetTickCount(), dwStart) > dwTimeToWait)
                {
                    frrvRet = frrvErrTimeout;
                    fDWRunning = FALSE;
                }

                continue;

            case WAIT_OBJECT_0 + 1:
                fDWRunning = FALSE;
                continue;
        }

        switch(WaitForSingleObject(hmut, DW_TIMEOUT_VALUE))
        {
            // yay!  we got the mutex.  Try to detemine if DW finally responded
            //  while we were grabbing the mutex.
            case WAIT_OBJECT_0:
                switch(WaitForMultipleObjects(2, rghWait, FALSE, 0))
                {
                    // If it hasn't responded, tell it to go away & fall thru 
                    //  into the 'it died' case.
                    case WAIT_TIMEOUT:
                        SetEvent(hevDone);

                    // It died.  Clean up.
                    case WAIT_OBJECT_0 + 1:
                        fDWRunning = FALSE;
                        frrvRet = frrvErrNoDW;
                        continue;
                }

                // ok, it responded.  Is it done?
                if (WaitForSingleObject(hevDone, 0) == WAIT_OBJECT_0)
                    fDWRunning = FALSE;

                ReleaseMutex(hmut);
                break;

            // if the wait was abandoned, it means DW has gone to the great bit
            //  bucket in the sky without cleaning up.  So release the mutex and
            //  fall into the default case
            case WAIT_ABANDONED:
                ReleaseMutex(hmut);
        
            // if we timed out or otherwise failed, just die.
            default:
                frrvRet    = frrvErrNoDW;
                fDWRunning = FALSE;
                break;
        }
    }
    if (frrvRet != frrvOk)
    {
        CloseHandle(pi.hProcess);
        goto done;
    }

    // if user told us to debug, return that back to the 
    if (pdwsm->msoctdsResult == msoctdsDebug)
        frrvRet = frrvLaunchDebugger;

    // if we're going to launch Dr. Watson, wait for the DW process to die.
    //  Give it 5 minutes.  If the user doesn't hit close by then, just return
    //  anyway...
    if (dwOpt == (DWORD)-1)
    {
        if (WaitForSingleObject(pi.hProcess, 300000) == WAIT_TIMEOUT)
            frrvRet = frrvErrTimeout;
    }

    CloseHandle(pi.hProcess);

done:
    // preserve the error code so that the following calls don't overwrite it
    dw = GetLastError();

    if (pdwsm != NULL)
        UnmapViewOfFile(pdwsm);
    if (hfmShared != NULL)
        CloseHandle(hfmShared);
    if (hevDone != NULL)
        CloseHandle(hevDone);
    if (hevAlive != NULL)
        CloseHandle(hevAlive);
    if (hmut != NULL)
        CloseHandle(hmut);
    if (hProc != NULL)
        CloseHandle(hProc);

    SetLastError(dw);

    return frrvRet;
}

static
EFaultRepRetVal
FaultHandler(
    IN   PSETUP_FAULT_HANDLER This,
    IN   EXCEPTION_POINTERS *pep,
    IN   DWORD dwOpt)
{
    
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    DWORD               dwFlags = 0;
    char                wszFile[MAX_PATH], *pwsz;

    DebugLog("Inside FaultHandler\r\n");
    GetModuleFileNameA(NULL, wszFile, sizeof(wszFile)/sizeof(wszFile[0]));

    // Find last backslash
    for(pwsz = wszFile + strlen(wszFile);
        pwsz >= wszFile && *pwsz != L'\\';
        pwsz--);

    // Should never happen
    if (pwsz < wszFile)
        goto done;

    if (*pwsz == L'\\')
        pwsz++;

    // Don't want to debug dwwin.exe itself.
    if (_stricmp(pwsz, "dwwin.exe") == 0 
        // || _stricmp(pwsz, "dumprep.exe") == 0
        )
        goto done;

    frrvRet = StartDWException(This, pep, dwOpt, dwFlags, -1);

done:
    return frrvRet;
}


static
BOOL
FAULTHIsSupported(
    IN   PSETUP_FAULT_HANDLER This
    )
{
    BOOL useExtendedInfo;
    DWORD dwServicePack;
    DWORD dwVersion,dwTemp,dwInfoSize;
    char *pInfo;
    VS_FIXEDFILEINFO *VsInfo;
    UINT DataLength;
    union {
        OSVERSIONINFO Normal;
        OSVERSIONINFOEX Ex;
    } Ovi;

    DebugLog("Inside FAULTHIsSupported\r\n");
    if ( !This) {
        return(FALSE);
    }

    useExtendedInfo = TRUE;
    Ovi.Ex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((OSVERSIONINFO *)&Ovi.Ex) ) {
        //
        // EX size not available; try the normal one
        //

        Ovi.Normal.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (!GetVersionEx((OSVERSIONINFO *)&Ovi.Normal) ) {
            DebugLog("Inside FAULTHIsSupported:Could not get os version!\r\n");
            return(FALSE);
        }
        useExtendedInfo = FALSE;
    }
    if (useExtendedInfo) {
        dwServicePack = Ovi.Ex.wServicePackMajor * 100 + Ovi.Ex.wServicePackMinor;
    } else {
        dwServicePack = 0;
    }
    dwVersion = Ovi.Normal.dwMajorVersion * 100 + Ovi.Normal.dwMinorVersion;
    switch (Ovi.Normal.dwPlatformId) {
        case VER_PLATFORM_WIN32s:
            DebugLog("Inside FAULTHIsSupported:Unsupported win32s!\r\n");
            return(FALSE);
            break;
        case VER_PLATFORM_WIN32_WINDOWS:
            if( dwVersion < 410) {
                DebugLog("Inside FAULTHIsSupported:Unsupported win9x!\r\n");
                return(FALSE);
            }
            break;
        case VER_PLATFORM_WIN32_NT:
            if( dwVersion < 400) {
                DebugLog("Inside FAULTHIsSupported:Unsupported winNT!\r\n");
                return(FALSE);
            }

            if( dwVersion == 400 && dwServicePack < 500) {
                DebugLog("Inside FAULTHIsSupported:Unsupported ServicePack!\r\n");
                return(FALSE);
            }
            break;
        default:
            return(FALSE);
    }

    // Test for wininet.dll from ie 4.01.
    dwInfoSize =  GetFileVersionInfoSize( FAULTH_WININET_NAME, &dwTemp );
    if( !dwInfoSize) {
        DebugLog("Inside FAULTHIsSupported:Could not find wininet.dll or determine version.");
        return( FALSE);
    }

    pInfo = HeapAlloc( GetProcessHeap(), 0, dwInfoSize);

    if( !pInfo || 
        !GetFileVersionInfo( FAULTH_WININET_NAME, dwTemp, dwInfoSize, pInfo) ||
        !VerQueryValue( pInfo, "\\", &VsInfo, &DataLength))
    {
        DebugLog("Inside FAULTHIsSupported:Could not find wininet.dll or get version.");
        HeapFree( GetProcessHeap(), 0, pInfo);
        return( FALSE);
    }
    if( VsInfo->dwFileVersionMS < FAULTH_WININET_MIN_MS ||
        ((VsInfo->dwFileVersionMS == FAULTH_WININET_MIN_MS) && (VsInfo->dwFileVersionLS < FAULTH_WININET_MIN_LS))) {
        DebugLog("Inside FAULTHIsSupported:Require a more recent wininet.dll.");
        HeapFree( GetProcessHeap(), 0, pInfo);
        return( FALSE);
    }
    HeapFree( GetProcessHeap(), 0, pInfo);
    return(TRUE);
}

static
void
FAULTHSetURLA(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCSTR pszURL
    )
{
    DebugLog("Inside FAULTHSetURLA\r\n");
    if (This && pszURL){
        lstrcpynA( This->szURL, pszURL, DW_MAX_SERVERNAME);
    }
}

static
void
FAULTHSetURLW(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCWSTR pwzURL
    )
{
    DebugLog("Inside FAULTHSetURLW\r\n");
    if (This && pwzURL){
        WideCharToMultiByte( CP_ACP, 0, pwzURL, -1, This->szURL, DW_MAX_SERVERNAME, NULL, NULL);
    }
}

static
void
FAULTHSetErrorTextA(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCSTR pszErrorText
    )
{
    DebugLog("Inside FAULTHSetErrorTextA\r\n");
    if (This && pszErrorText){
        MultiByteToWideChar( CP_ACP, 0, pszErrorText, -1, This->wzErrorText, DW_MAX_ERROR_CWC);
    }
}

static
void
FAULTHSetErrorTextW(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCWSTR pwzErrorText
    )
{
    DebugLog("Inside FAULTHSetErrorTextW\r\n");
    if (This && pwzErrorText){
        plstrcpynW( This->wzErrorText, pwzErrorText, DW_MAX_ERROR_CWC);
    }
}


static
void
FAULTHSetAdditionalFilesA(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCSTR pszAdditionalFiles
    )
{
    DebugLog("Inside FAULTHSetAdditionalFilesA\r\n");
    if (This && pszAdditionalFiles){
        MultiByteToWideChar( CP_ACP, 0, pszAdditionalFiles, -1, This->wzAdditionalFiles, DW_MAX_ADDFILES);
    }
}

static
void
FAULTHSetAdditionalFilesW(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCWSTR pwzAdditionalFiles
    )
{
    DebugLog("Inside FAULTHSetAdditionalFilesW\r\n");
    if (This && pwzAdditionalFiles){
        plstrcpynW( This->wzAdditionalFiles, pwzAdditionalFiles, DW_MAX_ADDFILES);
    }
}

static
void
FAULTHSetAppNameA(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCSTR pszAppName
    )
{
    DebugLog("Inside FAULTHAppNameA\r\n");
    if (This && pszAppName){
        MultiByteToWideChar( CP_ACP, 0, pszAppName, -1, This->wzAppName, DW_APPNAME_LENGTH);
    }
}

static
void
FAULTHSetAppNameW(
    IN   PSETUP_FAULT_HANDLER This,
    IN   PCWSTR pwzAppName
    )
{
    DebugLog("Inside FAULTHAppNameW\r\n");
    if (This && pwzAppName){
        plstrcpynW( This->wzAppName, pwzAppName, DW_APPNAME_LENGTH);
    }
}

static
void
FAULTHSetLCID(
    IN   PSETUP_FAULT_HANDLER This,
    IN   LCID lcid
    )
{
    DebugLog("Inside FAULTHSetLCID\r\n");
    if (This){
        This->lcid = lcid;
    }
}


static
VOID
FAULTHInit(
    IN   PSETUP_FAULT_HANDLER This
    )
{
    DebugLog("Inside FAULTHInit\r\n");
    if( This){
        This->SetURLA = FAULTHSetURLA;
        This->SetURLW = FAULTHSetURLW;
        This->SetAppNameA = FAULTHSetAppNameA;
        This->SetAppNameW = FAULTHSetAppNameW;
        This->SetErrorTextA = FAULTHSetErrorTextA;
        This->SetErrorTextW = FAULTHSetErrorTextW;
        This->SetAdditionalFilesA = FAULTHSetAdditionalFilesA;
        This->SetAdditionalFilesW = FAULTHSetAdditionalFilesW;
        This->SetLCID = FAULTHSetLCID;
        This->IsSupported = FAULTHIsSupported;
        This->Report = FaultHandler;
        This->bDebug = FALSE;
        FAULTHSetURLA(This, c_szDWDefServerI);
        FAULTHSetAppNameW(This, c_wzDWDefAppName);
        FAULTHSetAdditionalFilesW(This, L"");
        FAULTHSetErrorTextW(This,L"");
        FAULTHSetLCID(This,c_DWDefaultLCID);
    }
#ifdef TEST_WATSON
    {
        char szFile[MAX_PATH], *pwsz;

        GetSystemDirectoryA(szFile, sizeof(szFile)/sizeof(szFile[0]));
        szFile[3] = '\0';
        strcat(szFile, c_wszLogFileName);
        hFaultLog = CreateFileA(szFile, GENERIC_WRITE, 
                                        FILE_SHARE_WRITE | FILE_SHARE_READ, 
                                        NULL, OPEN_ALWAYS, 0, NULL);
    
        if (hFaultLog != INVALID_HANDLE_VALUE)
        {
            SYSTEMTIME  st;
            DWORD       cb, cbWritten;
            char        szMsg[512];
    
            GetSystemTime(&st);
            cb = wsprintf(szMsg, 
                          "%02d-%02d-%04d %02d:%02d:%02d Initalization\r\n", 
                          st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, 
                          st.wSecond);
            SetFilePointer(hFaultLog, 0, NULL, FILE_END);
            WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
        }
    }
    DebugLog("exiting FAULTHInit\r\n");
#endif
}

PSETUP_FAULT_HANDLER APIENTRY
FAULTHCreate( VOID)
{
    PSETUP_FAULT_HANDLER This = NULL;

    DebugLog("Inside FAULTHCreate\r\n");
    This = HeapAlloc( GetProcessHeap(), 0, sizeof(SETUP_FAULT_HANDLER));

    if( This) {
        FAULTHInit( This);
    }

    DebugLog("exiting FAULTCreate\r\n");
    return This;
}

VOID APIENTRY
FAULTHDelete(
    IN PSETUP_FAULT_HANDLER This
    )
{
    DebugLog("Inside FAULTHDelete\r\n");
    if( This) {
        HeapFree( GetProcessHeap(), 0, This);
    }
#ifdef TEST_WATSON
    if (hFaultLog != INVALID_HANDLE_VALUE) {
        CloseHandle(hFaultLog);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\fsfilter\fsfilter.h ===
#define REGKEY_SERVICES         L"System\\CurrentControlSet\\Services"
#define REGVAL_GROUP            L"Group"
#define DRIVER_DIRECTORY        L"%SystemRoot%\\system32\\drivers\\"
#define DRIVER_SUFFIX           L".sys"
#define REGVAL_START            L"Start"
#define REGVAL_SETUPCHECKED     L"SetupChecked"

#define SIZE_STRINGBUF          256
#define SIZE_SECTIONBUF         128


//
//
// Data structure used for storing lists of strings.  Note that
// some strings are in ansi and others in unicode (thus the VOID
// pointer to String).  It's up to the user to keep track of whether
// a list is ansi or Unicode
//
//

typedef struct _STRING_LIST_ENTRY
{
    LPVOID String;
    struct _STRING_LIST_ENTRY *Next;
} STRING_LIST_ENTRY, *PSTRING_LIST_ENTRY;



//
//
//  PSTRING_LIST_ENTRY
//  PopEntryList(
//      PSTRING_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSTRING_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }

//
//  VOID
//  PushEntryList(
//      PSTRING_LIST_ENTRY ListHead,
//      PSTRING_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#define InitializeList(ListHead)\
    (ListHead)->Next = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\ftcomp\ftcomprc.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomprc.h

Abstract:

    Resource ids definitions for ftcomp.rc

Author:

    Cristian Teodorescu   (cristiat)  6-July-2000
    
Notes:

Revision History:

--*/

#define FTCOMP_STR_ERROR50_DESCRIPTION    1000
#define FTCOMP_STR_ERROR40_DESCRIPTION    1001
#define FTCOMP_STR_WARNING40_DESCRIPTION  1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\ftcomp\ftcomp.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomp.h

Abstract:

    Header for the compatibility dll 

Author:

    Cristian Teodorescu   (cristiat)  6-July-2000
    
Notes:

Revision History:

--*/

#pragma once
#ifndef _FTCOMP_H
#define _FTCOMP_H

//
// Exports
//

BOOL WINAPI
FtCompatibilityCheckError(
    PCOMPAIBILITYCALLBACK   CompatibilityCallback,
    LPVOID                  Context
    );

BOOL WINAPI
FtCompatibilityCheckWarning(
    PCOMPAIBILITYCALLBACK   CompatibilityCallback,
    LPVOID                  Context
    );

//
// Variables
//

extern HINSTANCE g_hinst;
extern TCHAR g_FTCOMP50_ERROR_HTML_FILE[];
extern TCHAR g_FTCOMP50_ERROR_TEXT_FILE[];
extern TCHAR g_FTCOMP40_ERROR_HTML_FILE[];
extern TCHAR g_FTCOMP40_ERROR_TEXT_FILE[];
extern TCHAR g_FTCOMP40_WARNING_HTML_FILE[];
extern TCHAR g_FTCOMP40_WARNING_TEXT_FILE[];

//
//  Helpers
//

BOOL
FtPresent50(
    PBOOL   FtPresent
    );

BOOL
FtPresent40(
    PBOOL   FtPresent
    );

BOOL
FtBootSystemPagefilePresent40(
    PBOOL   FtPresent
    );

NTSTATUS 
OpenDevice(
    PWSTR   DeviceName,
    PHANDLE Handle
    );

BOOL
FtPresentOnDisk40(
    HANDLE          Handle,
    PDISK_REGISTRY  DiskRegistry,
    PBOOL           FtPresent
    );

BOOL
IsFtSet40(
    WCHAR           DriveLetter,
    PDISK_REGISTRY  DiskRegistry
    );

BOOL
GetDeviceDriveLetter(
    PWSTR   DeviceName, 
    PWCHAR  DriveLetter
    );

#endif // _FTCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\_winnt\rc_ids.h ===
#define INVALID_MODNAME     1
#define INVALID_CMDLINE     2
#define GETVER_FAILED       3
#define CREATEPROC_FAILED   4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\cmdat.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    cmdat.c

Abstract:

    This module contains global strings.

Author:

    Paula Tomlinson (paulat) 8-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"


//
// global strings
//
WCHAR pszRegPathClass[] =              REGSTR_PATH_CLASS_NT;
WCHAR pszRegPathDeviceClass[] =        REGSTR_PATH_DEVICE_CLASSES;
WCHAR pszRegPathIDConfigDB[] =         REGSTR_PATH_IDCONFIGDB;
WCHAR pszRegKeyKnownDockingStates[] =  REGSTR_KEY_KNOWNDOCKINGSTATES;
WCHAR pszRegValueClass[] =             REGSTR_VAL_CLASS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\cmdat.h ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    cmdat.h

Abstract:

    This module contains extern declarations for the global strings
    in cmdat.c

Author:

    Paula Tomlinson (paulat) 8-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include <windows.h>


//
// global strings
//

extern WCHAR pszRegPathClass[];
extern WCHAR pszRegPathDeviceClass[];
extern WCHAR pszRegPathIDConfigDB[];
extern WCHAR pszRegKeyKnownDockingStates[];
extern WCHAR pszRegValueClass[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\ftcomp\ftcomp.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ftcomp.cpp

Abstract:

    This compatibility dll is used by winnt32.exe in order to decide 
    whether the installation process should be aborted because of FT 
    sets present in the system.

Author:

    Cristian Teodorescu   (cristiat)  6-July-2000
    
Environment:

    compatibility dll for winnt32.exe

Notes:

Revision History:

--*/

#include <initguid.h>
#include <winnt32.h>
#include <ntddft.h>
#include <ntddft2.h>

#include "ftcomp.h"
#include "ftcomprc.h"


HINSTANCE g_hinst;
WCHAR g_FTCOMP50_ERROR_HTML_FILE[] = L"compdata\\ftcomp1.htm";
WCHAR g_FTCOMP50_ERROR_TEXT_FILE[] = L"compdata\\ftcomp1.txt";
WCHAR g_FTCOMP40_ERROR_HTML_FILE[] = L"compdata\\ftcomp2.htm";
WCHAR g_FTCOMP40_ERROR_TEXT_FILE[] = L"compdata\\ftcomp2.txt";
WCHAR g_FTCOMP40_WARNING_HTML_FILE[] = L"compdata\\ftcomp3.htm";
WCHAR g_FTCOMP40_WARNING_TEXT_FILE[] = L"compdata\\ftcomp3.txt";

extern "C"
BOOL WINAPI 
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReasonForCall,
    LPVOID      lpReserved
    )
{
    BOOL    status = TRUE;
    
    switch( dwReasonForCall )
    {
    case DLL_PROCESS_ATTACH:
        g_hinst = hInstance;
	    DisableThreadLibraryCalls(hInstance);       
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return status;
}

BOOL WINAPI 
FtCompatibilityCheckError(
    IN PCOMPAIBILITYCALLBACK    CompatibilityCallback,
    IN LPVOID                   Context
    )

/*++

Routine Description:

    This routine is called by winnt32.exe in order to decide whether 
    the installation process should be aborted because of FT sets present 
    in a Windows 2000 system or later. It also aborts the installation on
    NT 4.0 systems if the boot/system/pagefile volumes are FT sets

Arguments:

    CompatibilityCallback   - Supplies the winnt32 callback

    Context                 - Supplies the compatibility context

Return Value:

    FALSE   if the installation can continue
    TRUE    if the installation must be aborted

--*/

{   
    OSVERSIONINFO       osvi;
    BOOL                ftPresent;
    BOOL                result;
    COMPATIBILITY_ENTRY ce;
    WCHAR               description[100];
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi)) {
        return FALSE;
    }

    if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT ||
        osvi.dwMajorVersion < 4) {
        return FALSE;
    }

    if (osvi.dwMajorVersion == 4) {

        //
        // On NT 4.0 look for boot/system/pagefile FT sets
        //

        result = FtBootSystemPagefilePresent40(&ftPresent);

    } else {

        //
        //  On Windows 2000 or later look for any FT sets.
        //

        result = FtPresent50(&ftPresent);
    }
    
    if (result && !ftPresent) {

        // 
        // The setup can continue.
        //
        
        return FALSE;
    }    
    
    //
    // FT sets are present in the system or a fatal error occured. 
    // Queue the incompatibility error
    //
    
    ZeroMemory((PVOID) &ce, sizeof(COMPATIBILITY_ENTRY));
    if (osvi.dwMajorVersion == 4) {
        if (!LoadString(g_hinst, FTCOMP_STR_ERROR40_DESCRIPTION, description, 100)) {
            description[0] = 0;
        }
        ce.HtmlName = g_FTCOMP40_ERROR_HTML_FILE;
        ce.TextName = g_FTCOMP40_ERROR_TEXT_FILE; 
    } else {
        if (!LoadString(g_hinst, FTCOMP_STR_ERROR50_DESCRIPTION, description, 100)) {
            description[0] = 0;
        }
        ce.HtmlName = g_FTCOMP50_ERROR_HTML_FILE;
        ce.TextName = g_FTCOMP50_ERROR_TEXT_FILE; 
    }
    ce.Description = description;
    ce.RegKeyName = NULL;
    ce.RegValName = NULL;
    ce.RegValDataSize = 0;
    ce.RegValData = NULL;
    ce.SaveValue = NULL;
    ce.Flags = 0;
    CompatibilityCallback(&ce, Context);

    return TRUE;
}

BOOL WINAPI 
FtCompatibilityCheckWarning(
    IN PCOMPAIBILITYCALLBACK    CompatibilityCallback,
    IN LPVOID                   Context
    )

/*++

Routine Description:

    This routine is called by winnt32.exe in order to decide whether the user
    should be warned about the presence of FT sets in a Windows NT 4.0 system
    
Arguments:

    CompatibilityCallback   - Supplies the winnt32 callback

    Context                 - Supplies the compatibility context

Return Value:

    FALSE   if the installation can continue
    TRUE    if the installation must be aborted

--*/

{   
    OSVERSIONINFO       osvi;
    BOOL                ftPresent;
    BOOL                result;
    COMPATIBILITY_ENTRY ce;
    WCHAR               description[100];
    
    //
    //  This function is supposed to work only on Windows NT 4.0
    //
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi)) {
        return FALSE;
    }

    if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT ||
        osvi.dwMajorVersion != 4) {
        return FALSE;
    }
        
    result = FtPresent40(&ftPresent);
    if (result && !ftPresent) {

        // 
        // No FT sets are present in the system. The setup can continue.
        //
        
        return FALSE;
    }

    //
    // FT sets are present in the system or a fatal error occured. 
    // Queue the incompatibility warning
    //
    
    if (!LoadString(g_hinst, FTCOMP_STR_WARNING40_DESCRIPTION, description, 100)) {
        description[0] = 0;
    }

    ZeroMemory((PVOID) &ce, sizeof(COMPATIBILITY_ENTRY));
    ce.Description = description;
    ce.HtmlName = g_FTCOMP40_WARNING_HTML_FILE;
    ce.TextName = g_FTCOMP40_WARNING_TEXT_FILE; 
    ce.RegKeyName = NULL;
    ce.RegValName = NULL;
    ce.RegValDataSize = 0;
    ce.RegValData = NULL;
    ce.SaveValue = NULL;
    ce.Flags = 0;
    CompatibilityCallback(&ce, Context);

    return TRUE;
}

BOOL
FtPresent50(
    PBOOL   FtPresent
    )

/*++

Routine Description:

    This routine looks for FT volumes on a Window 2000 or later
    system.

Arguments:

    FtPresent   - is set to true if FT sets are detected in the system

Return Value:

    TRUE    if the function is successful
    FALSE   if some fatal error occured

--*/

{
    HANDLE                              handle;
    FT_ENUMERATE_LOGICAL_DISKS_OUTPUT   output;
    BOOL                                result;
    DWORD                               bytes;
    
    *FtPresent = FALSE;

    handle = CreateFile(L"\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    memset(&output, 0, sizeof(output));
    result = DeviceIoControl(handle, FT_ENUMERATE_LOGICAL_DISKS, NULL, 0, 
                             &output, sizeof(output), &bytes, NULL);
    CloseHandle(handle);

    if (!result && GetLastError() != ERROR_MORE_DATA) {
        return FALSE;
    }
        
    if (output.NumberOfRootLogicalDisks > 0) {
        *FtPresent = TRUE;
    }

    return TRUE;
}

BOOL
FtPresent40(
    PBOOL   FtPresent
    )

/*++

Routine Description:

    This routine looks for NTFT partitions on a Window NT 4.0 system

Arguments:

    FtPresent   - is set to true if FT sets are detected in the system

Return Value:

    TRUE    if the function is successful
    FALSE   if some fatal error occured

--*/

{
    HKEY                hkey;
    DWORD               registrySize;
    PDISK_CONFIG_HEADER registry;
    PDISK_REGISTRY      diskRegistry;
    ULONG               i;
    WCHAR               devicePath[50];    
    NTSTATUS            status;
    HANDLE              hdev;    

    *FtPresent = FALSE;

    //
    //  Get the ftdisk database from registry.
    //  Key:    HKLM\System\Disk
    //  Value:  Information
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Disk", 0, KEY_QUERY_VALUE, &hkey) !=
        ERROR_SUCCESS) {
        return TRUE;
    }

    if (RegQueryValueEx(hkey, L"Information", NULL, NULL, NULL, &registrySize) != 
        ERROR_SUCCESS) {
        RegCloseKey(hkey);
        return TRUE;
    }
  
    registry = (PDISK_CONFIG_HEADER) LocalAlloc(0, registrySize);
    if (!registry) {
        RegCloseKey(hkey);
        return FALSE;
    }
    
    if (RegQueryValueEx(hkey, L"Information", NULL, NULL, (LPBYTE) registry, &registrySize) != 
        ERROR_SUCCESS) {
        LocalFree(registry);
        RegCloseKey(hkey);
        return TRUE;
    }

    RegCloseKey(hkey);

    //
    //  If no FT volume info is present in the registry database we are done
    //

    if (registry->FtInformationSize == 0) {
        LocalFree(registry);
        return TRUE;
    }

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);
  
    
    //
    //  Enumerate all disks present in the system by opening \Device\HarddiskX\Partition0
    //  in sequence starting with disk 0. Stop when getting STATUS_OBJECT_PATH_NOT_FOUND
    //
    //

    for (i = 0;; i++) {
        
        //
        //  Open the device
        //
        
        swprintf(devicePath, L"\\Device\\Harddisk%lu\\Partition0", i);
        status = OpenDevice(devicePath, &hdev);
        
        if (status == STATUS_OBJECT_PATH_NOT_FOUND) {
            break;
        }

        if (!NT_SUCCESS(status) || hdev == NULL ||
            hdev == INVALID_HANDLE_VALUE) {
            // inaccessible device
            continue;
        }

        //
        //  Look for FT partitions on disk
        //
        
        if (!FtPresentOnDisk40(hdev, diskRegistry, FtPresent)) {
            CloseHandle(hdev);
            return FALSE;
        }
                
        CloseHandle(hdev);

        if (*FtPresent) {
            break;
        }
    }

    LocalFree(registry);
    return TRUE;
}

BOOL
FtBootSystemPagefilePresent40(
    PBOOL   FtPresent
    )

/*++

Routine Description:

    This routine looks for FT sets that are boot/system/pagefile volumes
    on a NT 4.0 system

Arguments:

    FtPresent   - is set to true if boot/system/pagefile FT sets are detected 
    in the system

Return Value:

    TRUE    if the function is successful
    FALSE   if some fatal error occured

--*/

{
    HKEY                            hkey;
    DWORD                           registrySize;
    PDISK_CONFIG_HEADER             registry;
    PDISK_REGISTRY                  diskRegistry;
    WCHAR                           buffer[MAX_PATH + 1];
    NTSTATUS                        status;
    UCHAR                           genericBuffer[0x10000];
    PSYSTEM_PAGEFILE_INFORMATION    pageFileInfo;
    PWCHAR                          p;
    WCHAR                           bootDL = 0, systemDL = 0;
    WCHAR                           dl;

    *FtPresent = FALSE;

    //
    //  Get the ftdisk database from registry.
    //  Key:    HKLM\System\Disk
    //  Value:  Information
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Disk", 0, KEY_QUERY_VALUE, &hkey) !=
        ERROR_SUCCESS) {
        return TRUE;
    }

    if (RegQueryValueEx(hkey, L"Information", NULL, NULL, NULL, &registrySize) != 
        ERROR_SUCCESS) {
        RegCloseKey(hkey);
        return TRUE;
    }
  
    registry = (PDISK_CONFIG_HEADER) LocalAlloc(0, registrySize);
    if (!registry) {
        RegCloseKey(hkey);
        return FALSE;
    }
    
    if (RegQueryValueEx(hkey, L"Information", NULL, NULL, (LPBYTE) registry, &registrySize) != 
        ERROR_SUCCESS) {
        LocalFree(registry);
        RegCloseKey(hkey);
        return TRUE;
    }

    RegCloseKey(hkey);

    //
    //  If no FT volume info is present in the registry database we are done
    //

    if (registry->FtInformationSize == 0) {
        LocalFree(registry);
        return TRUE;
    }

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);


    //
    //  Check the boot volume
    //
    
    if (!GetSystemDirectory(buffer, MAX_PATH)) {
        goto system;
    }

    if (buffer[1] != L':') {
        goto system;
    }
    
    bootDL = (WCHAR) tolower(buffer[0]);
    if (IsFtSet40(bootDL, diskRegistry)) {
        *FtPresent = TRUE;
        goto exit;
    }

system:
    
    //
    // Check the system volume
    //
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, KEY_QUERY_VALUE, &hkey) !=
        ERROR_SUCCESS) {
        goto paging;
    }

    registrySize = MAX_PATH * sizeof(WCHAR);
    if (RegQueryValueEx(hkey, L"SystemPartition", NULL, NULL, (LPBYTE) buffer, &registrySize) != 
        ERROR_SUCCESS) {
        RegCloseKey(hkey);
        goto paging;
    }

    RegCloseKey(hkey);
        
    if (!GetDeviceDriveLetter(buffer, &systemDL)) {
        goto paging;
    }

    systemDL = (WCHAR) tolower(systemDL);
    if (systemDL == bootDL) {
        // already checked this drive letter
        goto paging;
    }
    
    if (IsFtSet40(systemDL, diskRegistry)) {
        *FtPresent = TRUE;
        goto exit;
    }    
    
paging:
    
    //
    //  Check the paging volumes
    //

    if (!NT_SUCCESS(NtQuerySystemInformation(
                            SystemPageFileInformation,
                            genericBuffer, sizeof(genericBuffer),
                            NULL))) {
        goto exit;
    }

    pageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION) genericBuffer;

    while (TRUE) {

        //
        // Since the format of the pagefile name generally
        // looks something like "\DosDevices\x:\pagefile.sys",
        // just use the first character before the column
        // and assume that's the drive letter.
        //
            
        for (p = pageFileInfo->PageFileName.Buffer; 
             p < pageFileInfo->PageFileName.Buffer + pageFileInfo->PageFileName.Length 
             && *p != L':'; p++);
            
        if (p < pageFileInfo->PageFileName.Buffer + pageFileInfo->PageFileName.Length &&
            p > pageFileInfo->PageFileName.Buffer) {

            p--;
            dl = (WCHAR) tolower(*p);
            if (dl >= L'a' && dl <= L'z') {

                //
                //  Found the drive letter of a paging volume
                //

                if (dl != bootDL && dl != systemDL) {
                    if (IsFtSet40(dl, diskRegistry)) {
                        *FtPresent = TRUE;
                        goto exit;
                    }
                }
            }
        }

        if (!pageFileInfo->NextEntryOffset) {
            break;
        }

        pageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR) pageFileInfo + 
                                                      pageFileInfo->NextEntryOffset);
    }

exit:
    
    LocalFree(registry);
    return TRUE;
}

NTSTATUS 
OpenDevice(
    PWSTR   DeviceName,
    PHANDLE Handle
    )

/*++

Routine Description:

    This routine opens a device for read

Arguments:

    DeviceName  - supplies the device name

    Handle      - returns a handle to the open device

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    IO_STATUS_BLOCK     statusBlock;
    UNICODE_STRING      unicodeName;
    int                 i;
    
    status = RtlCreateUnicodeString(&unicodeName, DeviceName);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    memset(&statusBlock, 0, sizeof(IO_STATUS_BLOCK));
    memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.ObjectName = &unicodeName;
    oa.Attributes = OBJ_CASE_INSENSITIVE;

    //
    // If a sharing violation occurs, retry it for
    // max. 10 seconds
    //

    for (i = 0; i < 5; i++) {
        status = NtOpenFile(Handle, SYNCHRONIZE | GENERIC_READ,
                            &oa, &statusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_SYNCHRONOUS_IO_ALERT);
        if (status == STATUS_SHARING_VIOLATION) {
            Sleep(2000);
        } else {
            break;
        }
    }

    RtlFreeUnicodeString(&unicodeName);
    return status;
}

PDISK_PARTITION
FindPartitionInRegistry40(
    PDISK_REGISTRY  DiskRegistry,
    ULONG           Signature,
    LONGLONG        Offset
    )

/*++

Routine Description:

    This routine looks for a gicen partition into the NT 4.0 ftdisk registry
    database

Arguments:

    DiskRegistry    - supplies the ftdisk registry database

    Signature       - supplies the signature of the disk where the partition resides

    Offset          - supplies the offset of the partition

Return Value:

    The partition structure in the registry database.
    NULL if the partition is not there.

--*/

{
    PDISK_DESCRIPTION   diskDescription;
    USHORT              i, j;
    PDISK_PARTITION     diskPartition;
    LONGLONG            tmp;

    diskDescription = &DiskRegistry->Disks[0];
    for (i = 0; i < DiskRegistry->NumberOfDisks; i++) {
        if (diskDescription->Signature == Signature) {
            for (j = 0; j < diskDescription->NumberOfPartitions; j++) {
                diskPartition = &diskDescription->Partitions[j];
                memcpy(&tmp, &diskPartition->StartingOffset.QuadPart,
                       sizeof(LONGLONG));
                if (tmp == Offset) {
                    return diskPartition;
                }
            }
        }

        diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                          Partitions[diskDescription->NumberOfPartitions];
    }

    return NULL;
}

BOOL
FtPresentOnDisk40(
    HANDLE          Handle,
    PDISK_REGISTRY  DiskRegistry,
    PBOOL           FtPresent
    )

/*++

Routine Description:

    This routine looks for FT partitions on a disk

Arguments:

    Handle          - supplies a handle to the open disk

    DiskRegistry    - supplies the ftdisk registry database

    FtPresent       - is set to true if FT partitions are detected on the disk

Return Value:

    TRUE    if the function is successful
    FALSE   if some fatal error occured

--*/

{
    PDRIVE_LAYOUT_INFORMATION   layout;
    DWORD                       layoutSize;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             statusBlock;
    ULONG                       i;
    PPARTITION_INFORMATION      partInfo;
    PDISK_PARTITION             diskPartition;
    
    *FtPresent = FALSE;

    //
    // Allocate memory for IOCTL_GET_DRIVE_LAYOUT
    //

    layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry) +
                 32 * sizeof(PARTITION_INFORMATION);
    layout = (PDRIVE_LAYOUT_INFORMATION) LocalAlloc(0, layoutSize);
    if (!layout) {
        return FALSE;
    }
    
    //
    //  Read the drive layout
    //
        
    while (1) {

        status = NtDeviceIoControlFile(Handle, 0, NULL, NULL,
                                       &statusBlock,
                                       IOCTL_DISK_GET_DRIVE_LAYOUT,
                                       NULL, 0,
                                       layout, layoutSize);
        if (status != STATUS_BUFFER_TOO_SMALL) {
            break;
        }
            
        layoutSize += 32 * sizeof(PARTITION_INFORMATION);
        if (layout) {
            LocalFree(layout);
        }
        layout = (PDRIVE_LAYOUT_INFORMATION) LocalAlloc(0, layoutSize);
        if (!layout) {
            return FALSE;
        }            
    }

    if (!NT_SUCCESS(status)) {            
        // inaccessible device. Act like it has no FT volumes
        LocalFree(layout);
        return TRUE;
    }

    //
    // Look for FT partitions
    //

    for (i = 0; i < layout->PartitionCount; i++) {
        
        //
        //  We're looking after recognized partitions marked
        //  with the 0x80 flag
        //

        partInfo = &(layout->PartitionEntry[i]);
        if (!IsFTPartition(partInfo->PartitionType)) {
            continue;
        }
        
        //
        //  Check whether the partition is marked as a member
        //  of an FT volume in the registry database
        //
        
        diskPartition = FindPartitionInRegistry40(
                            DiskRegistry, layout->Signature,
                            partInfo->StartingOffset.QuadPart);
        if (!diskPartition) {
            continue;
        }
            
        if (diskPartition->FtType != NotAnFtMember) {
            *FtPresent = TRUE;
            break;
        }        
    }

    LocalFree(layout);
    return TRUE;
}

BOOL
IsFtSet40(
    WCHAR           DriveLetter,
    PDISK_REGISTRY  DiskRegistry
    )

/*++

Routine Description:

    This routine cheks whether the given drive letter belongs to
    an FT set

Arguments:

    DriveLetter     - supplies a drive letter

    DiskRegistry    - supplies the ftdisk registry database    

Return Value:

    TRUE    if the function is the drive letter belongs to an FT set    

--*/

{
    HANDLE                  handle;
    NTSTATUS                status;
    WCHAR                   deviceName[20];
    PARTITION_INFORMATION   partInfo;
    BOOL                    b;
    DWORD                   bytes;
    PDISK_DESCRIPTION       diskDescription;
    PDISK_PARTITION         diskPartition;
    USHORT                  i, j;

    //
    //  Open the volume and get its "partition" type
    //  If the NTFT flag is not set the volume is not an FT set
    //
    
    wsprintf(deviceName, L"\\DosDevices\\%c:", DriveLetter);    
    status = OpenDevice(deviceName, &handle);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    b = DeviceIoControl(handle, IOCTL_DISK_GET_PARTITION_INFO,
                        NULL, 0, &partInfo, sizeof(partInfo),
                        &bytes, NULL);
    CloseHandle(handle);

    if (!b) {
        return FALSE;
    }
    
    if (!IsFTPartition(partInfo.PartitionType)) {
        return FALSE;
    }

    //
    //  Look for the drive letter in the FT registry. See if it belongs
    //  to an FT set
    //

    diskDescription = &DiskRegistry->Disks[0];
    for (i = 0; i < DiskRegistry->NumberOfDisks; i++) {
        for (j = 0; j < diskDescription->NumberOfPartitions; j++) {
            diskPartition = &diskDescription->Partitions[j];
            if (diskPartition->AssignDriveLetter &&
                tolower(diskPartition->DriveLetter) == tolower(DriveLetter) &&
                diskPartition->FtType != NotAnFtMember) {
                return TRUE;
            }            
        }
        
        diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                          Partitions[diskDescription->NumberOfPartitions];
    }
    
    return FALSE;
}

BOOL
GetDeviceDriveLetter(
    PWSTR   DeviceName, 
    PWCHAR  DriveLetter
    )

/*++

Routine Description:

    This routine returns the drive letter (if any) of a device given
    the device name (like \Device\HarddiskVolume1)

Arguments:

    DeviceName      - supplies the device name

    DriveLetter     - returns the drive letter

Return Value:

    TRUE    if the device has a drive letter

--*/

{
    DWORD   cch;
    WCHAR   dosDevices[4096];
    WCHAR   target[4096];
    PWCHAR  dosDevice;

    *DriveLetter = 0;

    if (!QueryDosDevice(NULL, dosDevices, 4096)) {
        return FALSE;
    }
    
    dosDevice = dosDevices;
    while (*dosDevice) {

        if (wcslen(dosDevice) == 2 && dosDevice[1] == L':' &&
            QueryDosDevice(dosDevice, target, 4096)) {

            if (!wcscmp(target, DeviceName)) {
                *DriveLetter = (WCHAR) tolower(dosDevice[0]);
                return TRUE;
            }
        }

        while (*dosDevice++);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\cfgi.h ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    cfgi.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the Configuration Manager.

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _CFGI_H_
#define _CFGI_H_


//
// Client machine handle structure and signature
//

typedef struct PnP_Machine_s {
    PVOID hStringTable;
    PVOID hBindingHandle;
    WORD  wVersion;
    ULONG ulSignature;
    WCHAR szMachineName[MAX_PATH + 3];
} PNP_MACHINE, *PPNP_MACHINE;

#define MACHINE_HANDLE_SIGNATURE 'HMPP'


//
// Client context handle signature
//

#define CLIENT_CONTEXT_SIGNATURE 'HCPP'


//
// Client string table priming string
//

#define PRIMING_STRING           TEXT("PLT")


//
// Client side private utility routines
//

BOOL
INVALID_DEVINST(
    IN  PWSTR       pDeviceID
    );

VOID
CopyFixedUpDeviceId(
    OUT LPTSTR      DestinationString,
    IN  LPCTSTR     SourceString,
    IN  DWORD       SourceStringLen
    );

CONFIGRET
PnPUnicodeToMultiByte(
    IN     PWSTR   UnicodeString,
    IN     ULONG   UnicodeStringLen,
    OUT    PSTR    AnsiString           OPTIONAL,
    IN OUT PULONG  AnsiStringLen
    );

CONFIGRET
PnPMultiByteToUnicode(
    IN     PSTR    AnsiString,
    IN     ULONG   AnsiStringLen,
    OUT    PWSTR   UnicodeString        OPTIONAL,
    IN OUT PULONG  UnicodeStringLen
    );

BOOL
PnPGetGlobalHandles(
    IN  HMACHINE    hMachine,
    PVOID           *phStringTable      OPTIONAL,
    PVOID           *phBindingHandle    OPTIONAL
    );

BOOL
PnPRetrieveMachineName(
    IN  HMACHINE    hMachine,
    OUT LPWSTR      pszMachineName
    );

BOOL
PnPGetVersion(
    IN  HMACHINE    hMachine,
    IN  WORD*       pwVersion
    );


#endif // _CFGI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\devnode.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    devnode.c

Abstract:

    This module contains the API routines that operate directly on device
    instances (or DevNodes, in Win95 terminology).

               CM_Create_DevNode
               CM_Setup_DevNode
               CM_Disable_DevNode
               CM_Enable_DevNode
               CM_Get_DevNode_Status
               CM_Set_DevNode_Problem
               CM_Reenumerate_DevNode
               CM_Query_And_Remove_SubTree
               CM_Uninstall_DevNode
               CM_Request_Device_Eject
               CM_Add_ID
               CM_Register_Device_Driver

    This module also contains the following API routines which are
    not implemented.

               CM_Move_DevNode
               CM_Query_Remove_Subtree
               CM_Remove_SubTree

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"

#include "setupapi.h"
#include "spapip.h"
#include <pnpmgr.h>



CONFIGRET
CM_Create_DevNode_ExW(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_W pDeviceID,
    IN  DEVINST     dnParent,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine creates a new device instance in the hardware tree.

Parameters:

   pdnDevNode  Supplies the address of the variable that receives a handle
               to the new device instance.

   pDeviceID   Supplies a pointer to a NULL-terminated string specifying
               the device instance ID for this new device instance.  This
               is the registry path (relative to the Enum branch) where
               this device instance will be located (e.g., Root\*PNP0500\0000).
               In Windows NT, this parameter is not optional.

   dnParent    Supplies the handle of the device instance that is the parent
               of the device instance being created.

   ulFlags     Supplies flags specifying options for the creation of the
               device instance.  May be one of the following values:

               CM_CREATE_DEVNODE_NORMAL
                     Create the device instance now, and perform installation
                     for it at a later time.
               CM_CREATE_DEVNODE_NO_WAIT_INSTALL
                     Create the device instance, and perform installation for
                     it immediately.
               CM_CREATE_DEVNODE_PHANTOM
                     Create a phantom device instance (i.e., a handle to a
                     device instance that is not alive as far as the ConfigMgr
                     APIs are concerned).  This may be used for CM APIs that
                     require a devnode handle, but for which no real devnode
                     currently exists (e.g., registry property APIs).  This
                     flag may not be specified with CR_CREATE_DEVNODE_NORMAL
                     or CR_CREATE_DEVNODE_NO_WAIT_INSTALL.  A phantom devnode
                     created in this manner is not accessible to other callers
                     (i.e., CM_Locate_DevNode won't find it).  However, callers
                     attempting to create a devnode with the same name as this
                     phantom devnode will not be able to do so (they will get
                     CR_ALREADY_SUCH_DEVNODE).
               CM_CREATE_DEVNODE_GENERATE_ID
                     Create a Root-enumerated devnode using a unique device
                     instance ID generated from the supplied device ID in
                     pDeviceID.  If this flag is set, then pDeviceID is assumed
                     to contain simply a device ID (i.e., no enumerator key
                     prefix, and no device instance suffix).  A unique 4-digit,
                     base-10 identifier string will be created under
                     Enum\Root\<pDeviceID>, and the devnode will be created
                     based on that device instance ID.  For instance, to add a
                     new legacy COM port devnode, this API would be called with
                     a pDeviceID of *PNP0500.  Assuming there was already one
                     COM port instance in the registry (instance 0000), the new
                     device instance ID would be: Root\*PNP0500\0001
                     The caller may find out what device instance name was
                     generated by calling CM_Get_Device_ID with the devnode
                     returned from this API.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_ALREADY_SUCH_DEVNODE,
         CR_INVALID_DEVICE_ID,
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       ParentID[MAX_DEVICE_ID_LEN];
    WCHAR       szNewDeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen=MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (dnParent == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // the length of the supplied device id string must be shorter than
        // MAX_DEVICE_ID_LEN chars so that there is also room for the NULL term
        // char in a buffer of this size.  (many of the CM_ APIs make different
        // assumptions about the consideration of the NULL term char in
        // MAX_DEVICE_ID_LEN; account for the NULL term char to be safe)
        //
        if ((!ARGUMENT_PRESENT(pDeviceID)) ||
            (lstrlen(pDeviceID) >= MAX_DEVICE_ID_LEN)) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_CREATE_DEVNODE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Windows NT 5.0 does not support CM_CREATE_DEVNODE_NO_WAIT_INSTALL
        //
        if (ulFlags & CM_CREATE_DEVNODE_NO_WAIT_INSTALL) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Initialize the caller's devnode.  This will have the side effect of
        // generating an exception before we actually do anything if the caller
        // supplied a bogus address.
        //
        *pdnDevInst = 0;

        //
        // retreive device instance string that corresponds to dnParent
        // (note that this is not optional, even a first level device instance
        // has a parent (the root device instance)
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnParent,ParentID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(ParentID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // make sure the new device instance is properly formatted
        //
        CopyFixedUpDeviceId(szNewDeviceID, pDeviceID, lstrlen(pDeviceID));

        //
        // If not requesting instance generation, then it must be a
        // valid device instance path.
        //
        if (!(ulFlags & CM_CREATE_DEVINST_GENERATE_ID)) {
            if ((!*szNewDeviceID) ||
                (!IsLegalDeviceId(szNewDeviceID))) {
                Status = CR_INVALID_DEVINST;
                goto Clean0;
            }
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_CreateDevInst(
                hBinding,               // rpc binding handle
                szNewDeviceID,          // device instance to create
                ParentID,               // parent device instance
                MAX_DEVICE_ID_LEN,      // max length of szNewDeviceID
                ulFlags);               // flags
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_CreateDevInst caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // assign a unique device instance value to the newly created device
        // instance
        //

        ASSERT(*szNewDeviceID && IsLegalDeviceId(szNewDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable, szNewDeviceID,
                                           STRTAB_CASE_SENSITIVE);

        if (*pdnDevInst == 0) {
            Status = CR_NO_SUCH_DEVNODE;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Create_DevNode_ExW



CONFIGRET
CM_Move_DevNode_Ex(
    IN DEVINST  dnFromDevInst,
    IN DEVINST  dnToDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine replaces a root-enumerated device instance by the valid
   non-root-enumerated device instance.  The device installer uses this
   service when it detects that a non-root enumerated device instance is
   really the same as its root enumerated counterpart.  This API migrates
   the old device instance to the new location, and marks the old location
   as having a problem.

   ** THIS ROUTINE IS NOT IMPLEMENTED **

Parameters:

   dnFromDevNode  Supplies the handle of the device instance that has been
                  root enumerated.

   dnToDevNode    Supplies the handle of the device instance that is a
                  reenumeration (duplicate) of the root device instance.

   ulFlags        Must be zero.

Return Value:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_DEVNODE,
         CR_OUT_OF_MEMORY.
         (Windows 95 may also return CR_NOT_AT_APPY_TIME.)

--*/

{
    UNREFERENCED_PARAMETER(dnFromDevInst);
    UNREFERENCED_PARAMETER(dnToDevInst);
    UNREFERENCED_PARAMETER(ulFlags);
    UNREFERENCED_PARAMETER(hMachine);

    return CR_CALL_NOT_IMPLEMENTED;

} // CM_Move_DevNode_Ex



CONFIGRET
CM_Setup_DevNode_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine reenables and configures a specified device instance or
   retrieves information from its enumerator.

Parameters:

   dnDevNode   Supplies the handle of the device instance which may be
               reconfigured.

   ulFlags     Supplies a flag indicating the action to take.  Can be one
               of the following values:

               CM_SETUP_DEVNODE_READY
                     Reenable the device instance that had a problem.

               CM_SETUP_DOWNLOAD
                     Retrieve information about this device instance
                     from its enumerator.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_DEVNODE,
         CR_OUT_OF_MEMORY, or
         CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen=MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_SETUP_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DeviceInstanceAction(
                hBinding,               // rpc binding handle
                PNP_DEVINST_SETUP,      // requested major action - SETUP
                ulFlags,                // requested minor action
                DeviceID,               // device instance to create
                NULL);                  // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DeviceInstanceAction caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Setup_DevNode_Ex



CONFIGRET
CM_Disable_DevNode_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine disables a device instance.

Parameters:

   dnDevNode   Supplies the handle of the device instance to be disabled.

   ulFlags     May be one of CM_DISABLE_BITS.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_NOT_DISABLEABLE, or
         CR_INVALID_DEVNODE.
         (Note, Windows 95 also may return CR_NOT_AT_APPY_TIME.)

--*/

{
    CONFIGRET       Status = CR_SUCCESS;
    WCHAR           DeviceID[MAX_DEVICE_ID_LEN];
    ULONG           ulLen = MAX_DEVICE_ID_LEN;
    PVOID           hStringTable = NULL;
    handle_t        hBinding = NULL;
    BOOL            Success;
    PNP_VETO_TYPE   vetoType, *pVetoType;
    WCHAR           vetoName[MAX_DEVICE_ID_LEN], *pszVetoName;
    ULONG           ulNameLength;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_DISABLE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (ulFlags & CM_DISABLE_UI_NOT_OK) {
            vetoType = PNP_VetoTypeUnknown;
            pVetoType = &vetoType;
            vetoName[0] = L'\0';
            pszVetoName = &vetoName[0];
            ulNameLength = MAX_DEVICE_ID_LEN;
        } else {
            pVetoType = NULL;
            pszVetoName = NULL;
            ulNameLength = 0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DisableDevInst(
                hBinding,                // rpc binding handle
                DeviceID,                // device instance to create
                pVetoType,
                pszVetoName,
                ulNameLength,
                ulFlags);                // requested minor action (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DisableDevInst caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Disable_DevNode_Ex



CONFIGRET
CM_Enable_DevNode_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine enables a device instance.

Parameters:

   dnDevNode   Supplies the handle of the device instance to enable.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG or
         CR_INVALID_DEVNODE.
         (Note, Windows 95 also may return CR_NOT_AT_APPY_TIME.)

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DeviceInstanceAction(
                hBinding,               // rpc binding handle
                PNP_DEVINST_ENABLE,     // requested major action - ENABLE
                ulFlags,                // requested minor action (not used)
                DeviceID,               // device instance to create
                NULL);                  // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DeviceInstanceAction caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Enable_DevNode_Ex



CONFIGRET
CM_Get_DevNode_Status_Ex(
    OUT PULONG   pulStatus,
    OUT PULONG   pulProblemNumber,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the status of a device instance.

Parameters:

   pulStatus      Supplies the address of the variable that receives the
                  status flag of the device instance.  Can be a combination
                  of the DN_* values.

   pulProblemNumber  Supplies the address of the variable that receives an
                     identifier indicating the problem.  Can be one of the
                     CM_PROB_* values.


   dnDevNode         Supplies the handle of the device instance for which
                     to retrieve status.

   ulFlags           Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG, or
         CR_INVALID_POINTER.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pulStatus)) ||
            (!ARGUMENT_PRESENT(pulProblemNumber))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetDeviceStatus(
                hBinding,               // rpc binding handle
                DeviceID,               // device instance to get status for
                pulStatus,              // return StatusFlags here
                pulProblemNumber,       // return Problem here
                ulFlags);               // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetDeviceStatus caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_DevNode_Status_Ex



CONFIGRET
CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine clears or set the problem of a device instance.

Parameters:

   dnDevNode    Supplies the handle of the device instance for which
                to set the problem.

   ulProblem    Supplies the new problem value.  Can be one of the
                CM_PROB_* values. If zero, the problem is cleared.

   ulFlags      Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_SET_DEVNODE_PROBLEM_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_SetDeviceProblem(
                hBinding,   // rpc binding handle
                DeviceID,   // device instance
                ulProblem,  // specifies new Problem
                ulFlags);   // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_SetDeviceProblem caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Set_DevNode_Problem_Ex



CONFIGRET
CM_Reenumerate_DevNode_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine causes the specified device instance to be enumerated
   (if it is enumerable).

Parameters:

   dnDevNode   Supplies the handle of the device instance to be enumerated.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is CR_INVALID_FLAG (i.e., the
   function does not fail).  The device instance is not checked for validity.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_REENUMERATE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DeviceInstanceAction(
                hBinding,                  // rpc binding handle
                PNP_DEVINST_REENUMERATE,   // requested major action-REMOVESUBTREE
                ulFlags,                   // requested minor action
                DeviceID,                  // device instance subtree to remove
                NULL);                     // (not used)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DeviceInstanceAction caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Reenumerate_DevNode_Ex



CONFIGRET
CM_Query_And_Remove_SubTree_ExW(
    IN  DEVINST         dnAncestor,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags,
    IN  HMACHINE        hMachine
    )

/*++

Routine Description:

   This routine checks whether a device instance and its progeny can be
   removed.  If the query isn't vetoed then a remove is done.  The replaces
   the old CM_Query_Remove_SubTree followed by CM_Remove_SubTree.

Parameters:

   dnAncestor  Supplies the handle of the device instance at the root of
               the subtree to be removed.

   ulFlags     Specifies whether UI should be presented for
               this action.  Can be one of the following values:

               CM_REMOVE_UI_OK       - OK to present UI for query-removal.
               CM_REMOVE_UI_NOT_OK   - Don't present UI for query-removal.
               CM_REMOVE_NO_RESTART  - Don't attempt to restart the devnode.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_REMOVE_VETOED.  (Windows 95 may also return CR_NOT_AT_APPY_TIME.)

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;

    try {
        //
        // validate parameters
        //
        if (dnAncestor == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_REMOVE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        pSetupStringTableStringFromIdEx(hStringTable, dnAncestor,pDeviceID,&ulLen);

        ASSERT(pDeviceID && *pDeviceID && IsLegalDeviceId(pDeviceID));

        if (pDeviceID == NULL || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (ulNameLength == 0) {
            pszVetoName = NULL;
        }

        if (pszVetoName != NULL) {
            *pszVetoName = L'\0';
        }

        if (pVetoType != NULL) {
            *pVetoType = PNP_VetoTypeUnknown;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryRemove(
                hBinding,                   // rpc binding handle
                pDeviceID,                  // device instance subtree to remove
                pVetoType,
                pszVetoName,
                ulNameLength,
                ulFlags);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryRemove caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Query_And_Remove_SubTree_ExW



CONFIGRET
CM_Query_Remove_SubTree_Ex(
    IN DEVINST  dnAncestor,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine checks whether a device instance and its progeny can be
   removed.  This API must be called before calling CM_Remove_SubTree to
   make sure applications prepare for the removal of the device or to
   give the applications a chance to deny the request to remove the device.
   If the removal happens ?surprise style? (i.e., there?s no advanced
   warning or chance to veto), then this API should not be called before
   calling CM_Remove_SubTree.

Parameters:

   dnAncestor  Supplies the handle of the device instance at the root of
               the subtree to be removed.

   ulFlags     Specifies whether UI should be presented for
               this action.  Can be one of the following values:

               CM_QUERY_REMOVE_UI_OK  - OK to present UI for query-removal.
               CM_QUERY_REMOVE_UI_NOT_OK  -Don't present UI for query-removal.

Return Value:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_REMOVE_VETOED.  (Windows 95 may also return CR_NOT_AT_APPY_TIME.)

--*/

{
    UNREFERENCED_PARAMETER(dnAncestor);
    UNREFERENCED_PARAMETER(ulFlags);
    UNREFERENCED_PARAMETER(hMachine);

    return CR_CALL_NOT_IMPLEMENTED;

} // CM_Query_Remove_SubTree_Ex



CONFIGRET
CM_Remove_SubTree_Ex(
    IN DEVINST dnAncestor,
    IN ULONG   ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine removes a device instance and its children from the
   running system.  This API notifies each device instance in the subtree
   of the dnAncestor parameter of the device's removal.  (On Windows NT,
   this means that each driver/service controlling a device in this
   subtree receives a device removal notification.)

Parameters:

   dnAncestor  Supplies the handle of the device instance that is being removed.

   ulFlags     Must be either CM_REMOVE_UI_OK or CM_REMOVE_UI_NOT_OK.

Return Value:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE or
         CR_INVALID_FLAG.
         (Windows 95 may also return CR_NOT_AT_APPY_TIME.)

--*/

{
    UNREFERENCED_PARAMETER(dnAncestor);
    UNREFERENCED_PARAMETER(ulFlags);
    UNREFERENCED_PARAMETER(hMachine);

    return CR_CALL_NOT_IMPLEMENTED;

} // CM_Remove_SubTree_Ex



CONFIGRET
CM_Uninstall_DevNode_Ex(
    IN DEVNODE  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine uninstalls a device instance (i.e., deletes its registry
   key(s) in the Enum branch).  This API can only be called for phantom
   device instances, and the handle supplied is invalid after the call.
   This API does not attempt to delete all possible storage locations
   associated with the device instance.  It will do a recursive delete on
   the devnode key, so that any subkeys will be removed.  It will also
   delete the devnode key (and any subkeys) located in the Enum branch
   of each hardware profile.  It will not delete any software keys or user
   keys  (CM_Delete_DevNode_Key must be called to do that before calling
   this API).

Parameters:

   dnPhantom   Handle of a phantom device instance to uninstall.  This
               handle is typically retrieved by a call to CM_Locate_DevNode
               or CM_Create_DevNode.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG, or
      CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    WCHAR       szParentKey[MAX_CM_PATH], szChildKey[MAX_CM_PATH],
                DeviceID[MAX_DEVICE_ID_LEN];
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_UninstallDevInst(
                hBinding,                  // rpc binding handle
                DeviceID,                  // device instance to uninstall
                ulFlags);                  // (unused)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_UninstallDevInst caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        //------------------------------------------------------------------
        // after deleting the main hw key and the config specific hw keys,
        // cleanup the user hw key, which can only be done on the client
        // side.
        //------------------------------------------------------------------

        //
        // form the user hardware registry key path
        //
        Status = GetDevNodeKeyPath(hBinding, DeviceID,
                                   CM_REGISTRY_HARDWARE | CM_REGISTRY_USER,
                                   0, szParentKey, szChildKey);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // delete the specified private user key
        //
        Status = DeletePrivateKey(HKEY_CURRENT_USER, szParentKey, szChildKey);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Uninstall_DevNode_Ex



CONFIGRET
CM_Request_Device_Eject_ExW(
    IN DEVNODE          dnDevInst,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags,
    IN  HMACHINE        hMachine
    )

/*++

Routine Description:


Parameters:

   dnDevInst   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG, or
      CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (ulNameLength == 0) {
            pszVetoName = NULL;
        }

        if (pszVetoName != NULL) {
            *pszVetoName = L'\0';
        }

        if (pVetoType != NULL) {
            *pVetoType = PNP_VetoTypeUnknown;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // no flags are currently valid
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RequestDeviceEject(
                hBinding,                   // rpc binding handle
                DeviceID,                   // device instance subtree to remove
                pVetoType,
                pszVetoName,
                ulNameLength,
                ulFlags);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RequestDeviceEject caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Request_Device_Eject_ExW



CONFIGRET
CM_Add_ID_ExW(
    IN DEVINST  dnDevInst,
    IN PWSTR    pszID,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:


   This routine adds a device ID to a device instance's HardwareID or
   CompatibleIDs list.

Parameters:

   dnDevInst   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   pszID       Supplies a pointer to a NULL-terminated string specifying
               the ID to be added.

   ulFlags     Supplies flags for the ID.  May be one of the following values:

               ID Type Flags:
               CM_ADD_ID_HARDWARE   The specified ID is a hardware ID.  Add
                                    it to the device instance's HardwareID
                                    list.
               CM_ADD_ID_COMPATIBLE The specified ID is a compatible ID.
                                    Add it to the device instance's
                                    CompatibleIDs list.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.


--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pszID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_ADD_ID_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_AddID(
                hBinding,                  // rpc binding handle
                DeviceID,                 // device instance
                pszID,                     // id to add
                ulFlags);                  // hardware or compatible
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_AddID caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Add_ID_ExW



CMAPI
CONFIGRET
CM_Register_Device_Driver_Ex(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:


   This routine registers the device driver for the specified device.

Parameters:

   dnDevInst   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   ulFlags     Supplies flags for register the driver.  May be one of the
               following values:

                CM_REGISTER_DEVICE_DRIVER_STATIC
                CM_REGISTER_DEVICE_DRIVER_DISABLEABLE
                CM_REGISTER_DEVICE_DRIVER_REMOVABLE

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.


--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_REGISTER_DEVICE_DRIVER_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RegisterDriver(
                hBinding,                  // rpc binding handle
                DeviceID,                  // device instance
                ulFlags);                  // hardware or compatible
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RegisterDriver caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Register_Device_Driver_Ex



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Create_DevNodeW(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_W pDeviceID,
    IN  DEVINST     dnParent,
    IN  ULONG       ulFlags
    )
{
    return CM_Create_DevNode_ExW(pdnDevInst, pDeviceID, dnParent,
                                 ulFlags, NULL);
}


CONFIGRET
CM_Create_DevNodeA(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_A pDeviceID,
    IN  DEVINST     dnParent,
    IN  ULONG       ulFlags
    )
{
    return CM_Create_DevNode_ExA(pdnDevInst, pDeviceID, dnParent,
                                 ulFlags, NULL);
}


CONFIGRET
CM_Move_DevNode(
    IN DEVINST dnFromDevInst,
    IN DEVINST dnToDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Move_DevNode_Ex(dnFromDevInst, dnToDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Setup_DevNode(
    IN DEVINST dnDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Setup_DevNode_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Disable_DevNode(
    IN DEVINST dnDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Disable_DevNode_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Enable_DevNode(
    IN DEVINST dnDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Enable_DevNode_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_DevNode_Status(
    OUT PULONG  pulStatus,
    OUT PULONG  pulProblemNumber,
    IN  DEVINST dnDevInst,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_DevNode_Status_Ex(pulStatus, pulProblemNumber,
                                    dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Set_DevNode_Problem(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags
    )
{
    return CM_Set_DevNode_Problem_Ex(dnDevInst, ulProblem, ulFlags, NULL);
}


CONFIGRET
CM_Reenumerate_DevNode(
    IN DEVINST dnDevInst,
    IN ULONG   ulFlags
    )
{
    return CM_Reenumerate_DevNode_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Query_And_Remove_SubTree(
    IN  DEVINST         dnAncestor,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG                   ulNameLength,
    IN  ULONG           ulFlags
    )
{
    return CM_Query_And_Remove_SubTree_Ex( dnAncestor,
                                           pVetoType,
                                           pszVetoName,
                                           ulNameLength,
                                           ulFlags,
                                           NULL);
}


CONFIGRET
CM_Query_And_Remove_SubTreeA(
    IN  DEVINST         dnAncestor,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPSTR           pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags
    )
{
    return CM_Query_And_Remove_SubTree_ExA( dnAncestor,
                                            pVetoType,
                                            pszVetoName,
                                            ulNameLength,
                                            ulFlags,
                                            NULL);
}


CONFIGRET
CM_Remove_SubTree(
    IN DEVINST dnAncestor,
    IN ULONG   ulFlags
    )
{
    return CM_Remove_SubTree_Ex(dnAncestor, ulFlags, NULL);
}


CONFIGRET
CM_Uninstall_DevNode(
    IN DEVNODE dnPhantom,
    IN ULONG   ulFlags
    )
{
    return CM_Uninstall_DevNode_Ex(dnPhantom, ulFlags, NULL);
}


CONFIGRET
CM_Add_IDW(
    IN DEVINST dnDevInst,
    IN PWSTR   pszID,
    IN ULONG   ulFlags
    )
{
    return CM_Add_ID_ExW(dnDevInst, pszID, ulFlags, NULL);
}


CONFIGRET
CM_Add_IDA(
    IN DEVINST dnDevInst,
    IN PSTR    pszID,
    IN ULONG   ulFlags
    )
{
    return CM_Add_ID_ExA(dnDevInst, pszID, ulFlags, NULL);
}


CMAPI
CONFIGRET
CM_Register_Device_Driver(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags
    )
{
    return CM_Register_Device_Driver_Ex(dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Query_Remove_SubTree(
    IN DEVINST dnAncestor,
    IN ULONG   ulFlags
    )
{
    return CM_Query_Remove_SubTree_Ex(dnAncestor, ulFlags, NULL);
}


CONFIGRET
CM_Request_Device_EjectW(
    IN  DEVINST         dnDevInst,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags
    )
{
    return CM_Request_Device_Eject_ExW(dnDevInst,
                                       pVetoType,
                                       pszVetoName,
                                       ulNameLength,
                                       ulFlags,
                                       NULL);
}


CONFIGRET
CM_Request_Device_EjectA(
    IN  DEVNODE         dnDevInst,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPSTR           pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags
    )
{
    return CM_Request_Device_Eject_ExA( dnDevInst,
                                        pVetoType,
                                        pszVetoName,
                                        ulNameLength,
                                        ulFlags,
                                        NULL);
}



//-------------------------------------------------------------------
// ANSI STUBS
//-------------------------------------------------------------------


CONFIGRET
CM_Add_ID_ExA(
    IN DEVINST  dnDevInst,
    IN PSTR     pszID,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniID = NULL;


    if (pSetupCaptureAndConvertAnsiArg(pszID, &pUniID) == NO_ERROR) {

        Status = CM_Add_ID_ExW(dnDevInst,
                               pUniID,
                               ulFlags,
                               hMachine);
        pSetupFree(pUniID);

    } else {
        Status = CR_INVALID_POINTER;
    }

    return Status;

} // CM_Add_ID_ExA



CONFIGRET
CM_Create_DevNode_ExA(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_A pDeviceID,
    IN  DEVINST     dnParent,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniDeviceID = NULL;


    if (pSetupCaptureAndConvertAnsiArg(pDeviceID, &pUniDeviceID) == NO_ERROR) {

        Status = CM_Create_DevNode_ExW(pdnDevInst,
                                       pUniDeviceID,
                                       dnParent,
                                       ulFlags,
                                       hMachine);
        pSetupFree(pUniDeviceID);

    } else {
        Status = CR_INVALID_DEVICE_ID;
    }

    return Status;

} // CM_Create_DevNode_ExA



CONFIGRET
CM_Query_And_Remove_SubTree_ExA(
    IN  DEVINST         dnAncestor,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPSTR           pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags,
    IN  HMACHINE        hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniVetoName = NULL;
    ULONG     ulAnsiBufferLen;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(pszVetoName)) && (ulNameLength != 0)) {
        return CR_INVALID_POINTER;
    }

    if (ulNameLength != 0) {
        //
        // pass a Unicode buffer instead and convert back to caller's
        // ANSI buffer on return
        //
        pUniVetoName = pSetupMalloc(MAX_VETO_NAME_LENGTH*sizeof(WCHAR));
        if (pUniVetoName == NULL) {
            return CR_OUT_OF_MEMORY;
        }
    }

    //
    // call the wide version
    //
    Status = CM_Query_And_Remove_SubTree_ExW(dnAncestor,
                                             pVetoType,
                                             pUniVetoName,
                                             MAX_VETO_NAME_LENGTH,
                                             ulFlags,
                                             hMachine);

    //
    // We should never return a veto name longer than MAX_VETO_NAME_LENGTH.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_REMOVE_VETOED) {
        //
        // convert the unicode buffer to an ANSI string and copy to the caller's
        // buffer
        //
        ulAnsiBufferLen = ulNameLength;
        Status = PnPUnicodeToMultiByte(pUniVetoName,
                                       (lstrlenW(pUniVetoName)+1)*sizeof(WCHAR),
                                       pszVetoName,
                                       &ulAnsiBufferLen);
    }

    if (pUniVetoName != NULL) {
        pSetupFree(pUniVetoName);
    }

    return Status;

} // CM_Query_And_Remove_SubTree_ExA



CONFIGRET
CM_Request_Device_Eject_ExA(
    IN  DEVNODE         dnDevInst,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPSTR           pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags,
    IN  HMACHINE        hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniVetoName = NULL;
    ULONG     ulAnsiBufferLen;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(pszVetoName)) && (ulNameLength != 0)) {
        return CR_INVALID_POINTER;
    }

    if (ulNameLength != 0) {
        //
        // pass a Unicode buffer instead and convert back to caller's
        // ANSI buffer on return
        //
        pUniVetoName = pSetupMalloc(MAX_VETO_NAME_LENGTH*sizeof(WCHAR));
        if (pUniVetoName == NULL) {
            return CR_OUT_OF_MEMORY;
        }
    }

    //
    // call the wide version
    //
    Status = CM_Request_Device_Eject_ExW(dnDevInst,
                                         pVetoType,
                                         pUniVetoName,
                                         MAX_VETO_NAME_LENGTH,
                                         ulFlags,
                                         hMachine);

    //
    // We should never return a veto name longer than MAX_VETO_NAME_LENGTH.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_REMOVE_VETOED) {
        //
        // convert the unicode buffer to an ANSI string and copy to the caller's
        // buffer
        //
        ulAnsiBufferLen = ulNameLength;
        Status = PnPUnicodeToMultiByte(pUniVetoName,
                                       (lstrlenW(pUniVetoName)+1)*sizeof(WCHAR),
                                       pszVetoName,
                                       &ulAnsiBufferLen);
    }

    if (pUniVetoName != NULL) {
        pSetupFree(pUniVetoName);
    }

    return Status;

} // CM_Request_Device_Eject_ExA



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\conflist.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    conflist.c

Abstract:

    This module contains the API routines that manage conflict list reporting

               CM_Query_Resource_Conflict_List
               CM_Free_Resource_Conflict_Handle
               CM_Get_Resource_Conflict_Count
               CM_Get_Resource_Conflict_Details

Author:

    Jamie Hunter (jamiehun) 4-14-1998

Environment:

    User mode only.

Revision History:

    April-14-1998     jamiehun

        Addition of NT extended resource-conflict functions

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"

typedef struct _CONFLICT_LIST_HEADER {
    HMACHINE Machine;                               // indicates relevent machine
    PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictInfo;   // data obtained via UMPNPMGR
    ULONG    Signature;                             // marks this structure as a handle
} CONFLICT_LIST_HEADER, *PCONFLICT_LIST_HEADER;


//
// Private prototypes
//

BOOL
ValidateConfListHandle(
    PCONFLICT_LIST_HEADER pConfList
    );

VOID
FreeConfListHandle(
    PCONFLICT_LIST_HEADER pConfList
    );

//
// private prototypes from resdes.c
//

CONFIGRET
CreateResDesHandle(
    PRES_DES    prdResDes,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag,
    ULONG       ulResType,
    ULONG       ulResTag
    );

BOOL
ValidateResDesHandle(
    PPrivate_Res_Des_Handle    pResDes
    );

CONFIGRET
Get32bitResDesFrom64bitResDes(
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResData64,
    IN  ULONG      ResLen64,
    OUT PVOID    * ResData32,
    OUT ULONG    * ResLen32
    );


//
// private prototypes from logconf.c
//
CONFIGRET
CreateLogConfHandle(
    PLOG_CONF   plcLogConf,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag
    );

BOOL
ValidateLogConfHandle(
    PPrivate_Log_Conf_Handle   pLogConf
    );



//
// API functions
//

CMAPI
CONFIGRET
WINAPI
CM_Query_Resource_Conflict_List(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             )
/*++

Routine Description:

    Retrieves conflict list
    returns a handle for list

Arguments:

    pclConflictList - holds returned conflict list handle
    dnDevInst     Device we want to allocate a resource for
    ResourceID    Type of resource, ResType_xxxx
    ResourceData  Resource specific data
    ResourceLen   length of ResourceData

    ulFlags       Width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data supplied is assumed to be that native to the
                  platform of the caller.

    hMachine - optional machine to query

Return Value:

    CM status value

--*/
{

    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       DeviceID[MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    PPLUGPLAY_CONTROL_CONFLICT_LIST pConfList1 = NULL;
    PPLUGPLAY_CONTROL_CONFLICT_LIST pConfList2 = NULL;
    PCONFLICT_LIST_HEADER pConfListHeader = NULL;
    ULONG       ConfListSize1;
    ULONG       ConfListSize2;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;
    PVOID       ResourceData32 = NULL;
    ULONG       ResourceLen32 = 0;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        if (pclConflictList == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (ResourceData == NULL || ResourceLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        #if 0
        if (ResourceID > ResType_MAX) {     // ClassSpecific not allowed
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }
        #endif
        if (ResourceID == ResType_All) {
            Status = CR_INVALID_RESOURCEID;  // can't specify All on a detect
            goto Clean0;
        }
        //
        // Initialize parameters
        //
        *pclConflictList = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Server can only support 32-bit resdes.  Have the client
                // convert the caller's 64-bit resdes to a 32-bit resdes for the
                // server.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;

                Status = Get32bitResDesFrom64bitResDes(ResourceID,ResourceData,ResourceLen,&ResourceData32,&ResourceLen32);
                if(Status != CR_SUCCESS) {
                    goto Clean0;
                }
                if(ResourceData32) {
                    ResourceData = ResourceData32;
                    ResourceLen = ResourceLen32;
                }
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,DeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(DeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        pConfListHeader = (PCONFLICT_LIST_HEADER)pSetupMalloc(sizeof(CONFLICT_LIST_HEADER));
        if (pConfListHeader == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // estimate size required to hold one conflict
        //
        ConfListSize1 = sizeof(PLUGPLAY_CONTROL_CONFLICT_LIST)+          // header + one entry
                        sizeof(PLUGPLAY_CONTROL_CONFLICT_STRINGS)+      // strings marker
                        (sizeof(WCHAR)*MAX_DEVICE_ID_LEN);              // enough space for one string

        pConfList1 = (PPLUGPLAY_CONTROL_CONFLICT_LIST)pSetupMalloc(ConfListSize1);
        if (pConfList1 == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // first try
        //
        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryResConfList(
                        hBinding,               // rpc binding handle
                        DeviceID,               // device id string
                        ResourceID,             // resource type
                        (LPBYTE)ResourceData,   // actual res des data
                        ResourceLen,            // size in bytes of ResourceData
                        (LPBYTE)pConfList1,     // buffer
                        ConfListSize1,           // size of buffer
                        ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryResConfList (first pass) caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;       // quit for any error
        }

        if (pConfList1->ConflictsCounted > pConfList1->ConflictsListed) {
            //
            // need more space, multiple conflict
            //
            ConfListSize2 = pConfList1->RequiredBufferSize;
            pConfList2 = (PPLUGPLAY_CONTROL_CONFLICT_LIST)pSetupMalloc(ConfListSize2);

            if (pConfList2 != NULL) {
                //
                // Try to use this instead
                //
                RpcTryExcept {
                    //
                    // call rpc service entry point
                    //
                    Status = PNP_QueryResConfList(
                                  hBinding,               // rpc binding handle
                                  DeviceID,               // device id string
                                  ResourceID,             // resource type
                                  (LPBYTE)ResourceData,   // actual res des data
                                  ResourceLen,            // size in bytes of ResourceData
                                  (LPBYTE)pConfList2,     // buffer
                                  ConfListSize2,           // size of buffer
                                  ulFlags);               // currently zero
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "PNP_QueryResConfList (second pass) caused an exception (%d)\n",
                               RpcExceptionCode()));

                    Status = MapRpcExceptionToCR(RpcExceptionCode());
                }
                RpcEndExcept

                if (Status != CR_SUCCESS) {
                    //
                    // if we got error second time, but first time success
                    // use what we got on first attempt
                    // (I can't see this happening, but Murphey says it can)
                    //
                    pSetupFree(pConfList2);
                    Status = CR_SUCCESS;
                } else {
                    //
                    // use second attempt
                    //
                    pSetupFree(pConfList1);
                    pConfList1 = pConfList2;
                    ConfListSize1 = ConfListSize2;
                }
                //
                // either way, we've deleted a buffer
                //
                pConfList2 = NULL;
            }
        }

        if(ConfListSize1 > pConfList1->RequiredBufferSize) {
            //
            // we can release some of the buffer we requested
            //
            ConfListSize2 = pConfList1->RequiredBufferSize;
            pConfList2 = (PPLUGPLAY_CONTROL_CONFLICT_LIST)pSetupRealloc(pConfList1,ConfListSize2);
            if(pConfList2) {
                //
                // success, we managed to save space
                //
                pConfList1 = pConfList2;
                ConfListSize1 = ConfListSize2;
                pConfList2 = NULL;
            }
        }
        //
        // if we get here, we have a successfully valid handle
        //
        pConfListHeader->Signature = CM_PRIVATE_CONFLIST_SIGNATURE;
        pConfListHeader->Machine = hMachine;
        pConfListHeader->ConflictInfo = pConfList1;
        *pclConflictList = (ULONG_PTR)pConfListHeader;
        pConfList1 = NULL;
        pConfListHeader = NULL;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    //
    // cleanup
    //
    if (pConfListHeader != NULL) {
        pSetupFree(pConfListHeader);
    }
    if (pConfList1 != NULL) {
        pSetupFree(pConfList1);
    }
    if (pConfList2 != NULL) {
        pSetupFree(pConfList2);
    }

    if (ResourceData32) {
        pSetupFree(ResourceData32);
    }

    return Status;

} // CM_Query_Resource_Conflict_List



CMAPI
CONFIGRET
WINAPI
CM_Free_Resource_Conflict_Handle(
             IN CONFLICT_LIST   clConflictList
             )
/*++

Routine Description:

    Free's a conflict-list handle

Arguments:
    clConflictList - handle of conflict list to free

Return Value:

    CM status value

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    PCONFLICT_LIST_HEADER pConfList = NULL;

    try {
        //
        // Validate parameters
        //
        pConfList = (PCONFLICT_LIST_HEADER)clConflictList;
        if (!ValidateConfListHandle(pConfList)) {
            Status = CR_INVALID_CONFLICT_LIST;
            goto Clean0;
        }

        FreeConfListHandle(pConfList);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

}

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_Count(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             )
/*++

Routine Description:

    Retrieves number of conflicts from list

Arguments:
    clConflictList - handle of conflict list
    pulCount - filled with number of conflicts (0 if no conflicts)

Return Value:

    CM status value

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    PCONFLICT_LIST_HEADER pConfList;

    try {
        //
        // Validate parameters
        //
        pConfList = (PCONFLICT_LIST_HEADER)clConflictList;
        if (!ValidateConfListHandle(pConfList)) {
            Status = CR_INVALID_CONFLICT_LIST;
            goto Clean0;
        }

        if (pulCount == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // return count parameter
        // that can be used to iterate conflicts
        //

        *pulCount = pConfList->ConflictInfo->ConflictsListed;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Resource_Conflict_Handle



CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsW(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_W pConflictDetails
             )
/*++

Routine Description:

    Retrieves conflict details
    for a specific conflict

Arguments:
    clConflictList - handle of conflict list
    ulIndex - index of conflict to query, 0 to count-1
                where count is obtained from CM_Get_Resource_Conflict_Count
    pConflictDetails - structure to be filled with conflict details
            must have CD_ulSize & CD_ulFlags initialized before calling function
            eg: pConflictDetails->CD_ulSize = sizeof(CONFLICT_DETAILS)
                pConflictDetails->CD_ulFlags = CM_CDMASK_ALL

Return Value:

    CM status value

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    PCONFLICT_LIST_HEADER pConfList;
    PPLUGPLAY_CONTROL_CONFLICT_ENTRY pConfEntry;
    PWCHAR pString;
    ULONG ulFlags;
    PPLUGPLAY_CONTROL_CONFLICT_STRINGS ConfStrings;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    HMACHINE    hMachine = NULL;
    DEVINST dnDevInst;
    ULONG  ulSize;

    try {
        //
        // Validate parameters
        //
        pConfList = (PCONFLICT_LIST_HEADER)clConflictList;
        if (!ValidateConfListHandle(pConfList)) {
            Status = CR_INVALID_CONFLICT_LIST;
            goto Clean0;
        }

        if (pConflictDetails == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(pConflictDetails->CD_ulSize != sizeof(CONFLICT_DETAILS_W)) {
            //
            // currently only one structure size supported
            //
            Status = CR_INVALID_STRUCTURE_SIZE;
            goto Clean0;
        }

        if (INVALID_FLAGS(pConflictDetails->CD_ulMask, CM_CDMASK_VALID)) {
            //
            // CM_CDMASK_VALID describes the bits that are supported
            //
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (pConflictDetails->CD_ulMask == 0) {
            //
            // must want something
            //
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if(ulIndex >= pConfList->ConflictInfo->ConflictsListed) {
            //
            // validate index
            //
            Status = CR_INVALID_INDEX;
            goto Clean0;
        }

        hMachine = (HMACHINE)(pConfList->Machine);

        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            //
            // handles
            //
            Status = CR_FAILURE;
            goto Clean0;
        }


        ConfStrings = (PPLUGPLAY_CONTROL_CONFLICT_STRINGS)&(pConfList->ConflictInfo->ConflictEntry[pConfList->ConflictInfo->ConflictsListed]);
        pConfEntry = pConfList->ConflictInfo->ConflictEntry + ulIndex;
        pString = ConfStrings->DeviceInstanceStrings + pConfEntry->DeviceInstance; // the string for this entry

        //
        // init requested parameters
        //
        ulFlags = pConflictDetails->CD_ulMask;
        pConflictDetails->CD_ulMask = 0;
        if (IS_FLAG_SET(ulFlags , CM_CDMASK_DEVINST)) {
            pConflictDetails->CD_dnDevInst = 0;
        }
        if (IS_FLAG_SET(ulFlags , CM_CDMASK_RESDES)) {
            pConflictDetails->CD_rdResDes = 0;
        }

        if (IS_FLAG_SET(ulFlags , CM_CDMASK_FLAGS)) {
            pConflictDetails->CD_ulFlags = 0;
        }

        if (IS_FLAG_SET(ulFlags , CM_CDMASK_DESCRIPTION)) {
            pConflictDetails->CD_szDescription[0] = 0;
        }

        //
        // fill in requested parameters
        //
        if (IS_FLAG_SET(ulFlags , CM_CDMASK_DEVINST)) {

            if (pString[0] == 0 || IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_LEGACY_DRIVER)) {
                //
                // not a valid dev-instance
                //
                dnDevInst = -1;
            } else {
                //
                // lookup DeviceID
                //
                ASSERT(pString && *pString && IsLegalDeviceId(pString));

                dnDevInst = (DEVINST)pSetupStringTableAddString(hStringTable,
                                                   pString,
                                                   STRTAB_CASE_SENSITIVE);
                if (dnDevInst == (DEVINST)(-1)) {
                    Status = CR_OUT_OF_MEMORY;    // probably out of memory
                    goto Clean0;
                }
            }
            pConflictDetails->CD_dnDevInst = dnDevInst;
            pConflictDetails->CD_ulMask |= CM_CDMASK_DEVINST;
        }
        if (IS_FLAG_SET(ulFlags , CM_CDMASK_RESDES)) {
            //
            // not implemented yet
            //
            pConflictDetails->CD_rdResDes = 0;
        }

        if (IS_FLAG_SET(ulFlags , CM_CDMASK_FLAGS)) {
            //
            // convert flags
            //
            pConflictDetails->CD_ulFlags = 0;
            if(IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_LEGACY_DRIVER)) {
                //
                // description describes a driver, not a device
                //
                pConflictDetails->CD_ulFlags |= CM_CDFLAGS_DRIVER;
            }
            if(IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_ROOT_OWNED)) {
                //
                // resource is owned by root device
                //
                pConflictDetails->CD_ulFlags |= CM_CDFLAGS_ROOT_OWNED;
            }
            if(IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_TRANSLATE_FAILED) || IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_ROOT_OWNED)) {
                //
                // resource cannot be allocated, but no descriptive text
                //
                pConflictDetails->CD_ulFlags |= CM_CDFLAGS_RESERVED;
            }
        }

        if (IS_FLAG_SET(ulFlags , CM_CDMASK_DESCRIPTION)) {
            if (pString[0] == 0 || IS_FLAG_SET(pConfEntry->DeviceFlags,PNP_CE_LEGACY_DRIVER)) {
                //
                // copy string directly, specifies legacy driver (or nothing for unavailable)
                //
                lstrcpynW(pConflictDetails->CD_szDescription,pString,MAX_PATH);
            } else {
                //
                // copy a descriptive name for P&P device
                //
                ASSERT(pString && *pString && IsLegalDeviceId(pString));

                dnDevInst = (DEVINST)pSetupStringTableAddString(hStringTable,
                                                   pString,
                                                   STRTAB_CASE_SENSITIVE);
                if (dnDevInst == (DEVINST)(-1)) {
                    Status = CR_OUT_OF_MEMORY;    // probably out of memory
                    goto Clean0;
                }

                ulSize = sizeof(pConflictDetails->CD_szDescription);
                if (CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                     CM_DRP_FRIENDLYNAME,
                                                     NULL, (LPBYTE)(pConflictDetails->CD_szDescription),
                                                     &ulSize, 0,hMachine) != CR_SUCCESS) {

                    ulSize = sizeof(pConflictDetails->CD_szDescription);
                    if (CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                         CM_DRP_DEVICEDESC,
                                                         NULL, (LPBYTE)(pConflictDetails->CD_szDescription),
                                                         &ulSize, 0,hMachine) != CR_SUCCESS) {

                        //
                        // unknown
                        //
                        pConflictDetails->CD_szDescription[0] = 0;
                    }
                }
            }
            pConflictDetails->CD_ulMask |= CM_CDMASK_DESCRIPTION;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Resource_Conflict_DetailsW



BOOL
ValidateConfListHandle(
    PCONFLICT_LIST_HEADER pConfList
    )
/*++

Routine Description:

    Validates a conflict-list handle
    pConfList must not be null, and must
    contain a valid signature

Arguments:

    pConfList - handle to conflict list

Return Value:

    TRUE if valid, FALSE if not valid

--*/
{
    //
    // validate parameters
    //
    if (pConfList == NULL) {
        return FALSE;
    }

    //
    // check for the private conflict list signature
    //
    if (pConfList->Signature != CM_PRIVATE_CONFLIST_SIGNATURE) {
        return FALSE;
    }

    return TRUE;

} // ValidateConfListHandle



VOID
FreeConfListHandle(
    PCONFLICT_LIST_HEADER pConfList
    )
/*++

Routine Description:

    Releases memory allocated for Conflict List
    Makes sure Signature is invalid

Arguments:

    pConfList  - valid handle to conflict list

Return Value:

    none

--*/
{
    if(pConfList != NULL) {
        pConfList->Signature = 0;
        if(pConfList->ConflictInfo) {
            pSetupFree(pConfList->ConflictInfo);
        }
        pSetupFree(pConfList);
    }

    return;

} // FreeConfListHandle




//-------------------------------------------------------------------
// ANSI STUBS
//-------------------------------------------------------------------


CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsA(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             )
/*++

Routine Description:

    Ansi version of CM_Get_Resource_Conflict_DetailsW

--*/
{
    CONFLICT_DETAILS_W detailsW;
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulAnsiLength;

    try {
        //
        // Validate parameters we need for Ansi part
        // further validation occurs in Wide-char part
        //
        if (pConflictDetails == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(pConflictDetails->CD_ulSize != sizeof(CONFLICT_DETAILS_A)) {
            //
            // currently only one structure size supported
            //
            Status = CR_INVALID_STRUCTURE_SIZE;
            goto Clean0;
        }

        if (INVALID_FLAGS(pConflictDetails->CD_ulMask, CM_CDMASK_VALID)) {
            //
            // CM_CDMASK_VALID describes the bits that are supported
            //
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (pConflictDetails->CD_ulMask == 0) {
            //
            // must want something
            //
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        ZeroMemory(&detailsW,sizeof(detailsW));
        detailsW.CD_ulSize = sizeof(detailsW);
        detailsW.CD_ulMask = pConflictDetails->CD_ulMask;

        Status = CM_Get_Resource_Conflict_DetailsW(clConflictList,ulIndex,&detailsW);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // copy details
        //
        pConflictDetails->CD_ulMask = detailsW.CD_ulMask;

        if (IS_FLAG_SET(detailsW.CD_ulMask , CM_CDMASK_DEVINST)) {
            pConflictDetails->CD_dnDevInst = detailsW.CD_dnDevInst;
        }
        if (IS_FLAG_SET(detailsW.CD_ulMask , CM_CDMASK_RESDES)) {
            pConflictDetails->CD_rdResDes = detailsW.CD_rdResDes;
        }

        if (IS_FLAG_SET(detailsW.CD_ulMask , CM_CDMASK_FLAGS)) {
            pConflictDetails->CD_ulFlags = detailsW.CD_ulFlags;
        }

        if (IS_FLAG_SET(detailsW.CD_ulMask , CM_CDMASK_DESCRIPTION)) {
            pConflictDetails->CD_szDescription[0] = 0;
            //
            // need to convery from UNICODE to ANSI
            //
            ulAnsiLength = MAX_PATH;
            Status = PnPUnicodeToMultiByte(detailsW.CD_szDescription,
                                           MAX_PATH*sizeof(WCHAR),
                                           pConflictDetails->CD_szDescription,
                                           &ulAnsiLength);
            if (Status != CR_SUCCESS) {
                //
                // error occurred
                //
                Status = CR_FAILURE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Resource_Conflict_DetailsA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\event.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module contains miscellaneous Configuration Manager API routines.

               CMP_RegisterNotification
               CMP_UnregisterNotification

Author:

    Jim Cavalaris (jamesca) 05-05-2001

Environment:

    User mode only.

Revision History:

    05-May-2001     jamesca

        Creation and initial implementation (moved from cfgmgr32\misc.c).

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "winsvcp.h"


//
// global data
//
#ifndef _WIN64
extern BOOL     IsWow64;  // set if we're running under WOW64, externed from setupapi\dll.c
#endif // _WIN64


//
// GetModuleFileNameExW, dynamically loaded by CMP_RegisterNotification
//
typedef DWORD (WINAPI *PFN_GETMODULEFILENAMEEXW)(
    IN  HANDLE  hProcess,
    IN  HMODULE hModule,
    OUT LPWSTR  lpFilename,
    IN  DWORD   nSize
    );



CONFIGRET
CMP_RegisterNotification(
    IN  HANDLE   hRecipient,
    IN  LPBYTE   NotificationFilter,
    IN  DWORD    Flags,
    OUT PNP_NOTIFICATION_CONTEXT *Context
    )

/*++

Routine Description:

    This routine registers the specified handle for the type of Plug and Play
    device event notification specified by the NotificationFilter.

Parameters:

    hRecipient - Handle to register as the notification recipient.  May be a
                 window handle or service status handle, and must be specified
                 with the appropriate flags.

    NotificationFilter - Specifies a notification filter that specifies the type
                 of events to register for.  The Notification filter specifies a
                 pointer to a DEV_BROADCAST_HEADER structure, whose
                 dbch_devicetype member indicates the actual type of the
                 NotificationFilter.

                 Currently, may be one of the following:

                 DEV_BROADCAST_HANDLE  (DBT_DEVTYP_HANDLE type)

                 DEV_BROADCAST_DEVICEINTERFACE (DBT_DEVTYP_DEVICEINTERFACE type)

    Flags      - Specifies additional flags for the operation.  The following flags
                 are currently defined:

                 DEVICE_NOTIFY_WINDOW_HANDLE  -
                     hRecipient specifies a window handle.

                 DEVICE_NOTIFY_SERVICE_HANDLE -
                     hRecipient specifies a service status handle.

                 DEVICE_NOTIFY_COMPLETION_HANDLE -
                     Not currently implemented.

                 DEVICE_NOTIFY_ALL_INTERFACE_CLASSES - Specifies that the
                     notification request is for all device interface change
                     events.  Only valid with a DEV_BROADCAST_DEVICEINTERFACE
                     NotificationFilter.  If this flag is specified the
                     dbcc_classguid field is ignored.

    Context    - Receives a notification context.  This context is supplied to the
                 server via PNP_UnregisterNotification to unregister the
                 corresponding notification handle.

Return Value:

    Returns CR_SUCCESS if the component was successfully registered for
    notification. Returns CR_FAILURE otherwise.

Notes:

    This CM API does not allow the client to specify a server name because the
    RPC call is always made to the local server.  This routine will never call
    the corresponding RPC server interface (PNP_RegisterNotification)
    remotely.  Additionally, this routine is private, and should only be called
    via user32!RegisterDeviceNotification.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus;
    handle_t    hBinding = NULL;
    ULONG       ulSize;
    PPNP_CLIENT_CONTEXT ClientContext;
    ULONG64     ClientContext64;
    WCHAR       ClientName[MAX_SERVICE_NAME_LEN];


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(Context)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *Context = NULL;

        if ((!ARGUMENT_PRESENT(NotificationFilter)) ||
            (hRecipient == NULL)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // DEVICE_NOTIFY_BITS is a private mask, defined specifically for
        // validation by the client and server.  It contains the bitmask for all
        // handle types (DEVICE_NOTIFY_COMPLETION_HANDLE specifically excluded
        // by the server), and all other flags that are currently defined - both
        // public and reserved.
        //
        if (INVALID_FLAGS(Flags, DEVICE_NOTIFY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Make sure the caller didn't specify any private flags.  Flags in this
        // range are currently reserved for use by CFGMGR32 and UMPNPMGR only!!
        //
        if ((Flags & DEVICE_NOTIFY_RESERVED_MASK) != 0) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate the notification filter.  UlSize is used as an explicit
        // parameter to let RPC know how much data to marshall, though the
        // server validates the size in the structure against it as well.
        //
        ulSize = ((PDEV_BROADCAST_HDR)NotificationFilter)->dbch_size;

        if (ulSize < sizeof(DEV_BROADCAST_HDR)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

#ifndef _WIN64
        //
        // Determine if the 32 bit client is running on WOW64, and set the
        // reserved flags appropriately.
        //
        if (IsWow64) {
            Flags |= DEVICE_NOTIFY_WOW64_CLIENT;
        }
#endif // _WIN64

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(NULL, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Allocate client context handle from the local process heap.
        //
        ClientContext = LocalAlloc(0, sizeof(PNP_CLIENT_CONTEXT));

        if (ClientContext == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // Put a signature on the client context, to be checked (and
        // invalidated) at unregistration time.
        //
        ClientContext->PNP_CC_Signature = CLIENT_CONTEXT_SIGNATURE;
        ClientContext->PNP_CC_ContextHandle = 0;

        memset(ClientName, 0, sizeof(ClientName));

        if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) == DEVICE_NOTIFY_WINDOW_HANDLE) {

            DWORD  dwLength = 0;

            //
            // first, try to retrieve the window text of the window being
            // registered for device event notification.  we'll pass this into
            // UMPNPMGR for use as an identifier when the window vetoes device
            // event notifications.
            //
            dwLength = GetWindowText(hRecipient,
                                     ClientName,
                                     MAX_SERVICE_NAME_LEN);
            if (dwLength == 0) {
                //
                // GetWindowText did not return any text.  Attempt to retrieve
                // the process module name instead.
                //
                DWORD                    dwProcessId;
                HANDLE                   hProcess;
                HMODULE                  hPsApiDll;
                PFN_GETMODULEFILENAMEEXW pfnGetModuleFileNameExW;

                //
                // get the id of the process that this window handle is
                // associated with.
                //

                if (GetWindowThreadProcessId(hRecipient, &dwProcessId)) {

                    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                           FALSE,
                                           dwProcessId);

                    if (hProcess) {

                        //
                        // load the psapi.dll library and find the the
                        // GetModuleFileNameExW entry point.
                        //

                        hPsApiDll = LoadLibrary(TEXT("psapi.dll"));

                        if (hPsApiDll) {

                            pfnGetModuleFileNameExW =
                                (PFN_GETMODULEFILENAMEEXW)GetProcAddress(hPsApiDll,
                                                                         "GetModuleFileNameExW");

                            if (pfnGetModuleFileNameExW) {
                                //
                                // retrieve the module file name for the process
                                // this window handle is associated with.
                                //
                                dwLength = pfnGetModuleFileNameExW(hProcess,
                                                                   NULL,
                                                                   ClientName,
                                                                   MAX_SERVICE_NAME_LEN);
                            } else {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS | DBGF_EVENT,
                                           "CFGMGR32: CMP_RegisterNotification: GetProcAddress returned error = %d\n",
                                           GetLastError()));
                            }

                            FreeLibrary(hPsApiDll);
                        }
                        CloseHandle(hProcess);
                    } else {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS | DBGF_EVENT,
                                   "CFGMGR32: CMP_RegisterNotification: OpenProcess returned error = %d\n",
                                   GetLastError()));
                    }

                } else {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS | DBGF_EVENT,
                               "CFGMGR32: CMP_RegisterNotification: GetWindowThreadProcessId returned error = %d\n",
                               GetLastError()));
                }
            }

            if (dwLength == 0) {
                //
                // could not retrieve any identifier for this window.
                //
                ClientName[0] = UNICODE_NULL;

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS | DBGF_EVENT,
                           "CFGMGR32: CMP_RegisterNotification: Could not retieve any name for window %d!!\n",
                           hRecipient));
            }

        } else if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) == DEVICE_NOTIFY_SERVICE_HANDLE) {

            //
            // Get the name of the service corresponding to the service status
            // handle supplied.
            //
            if (NO_ERROR != I_ScPnPGetServiceName(hRecipient, ClientName, MAX_SERVICE_NAME_LEN)) {
                Status = CR_INVALID_DATA;
                LocalFree(ClientContext);
                goto Clean0;
            }

            //
            // Just set this to point to the buffer we use. PNP_RegisterNotification will unpack it.
            //
            hRecipient = ClientName;
        }

        //
        // The client context pointer is now always transmitted to the server as
        // a 64-bit value - which is large enough to hold the pointer in both
        // the 32-bit and 64-bit cases.  This standardizes the RPC interface for
        // all clients, since RPC will always marshall a 64-bit value.  The
        // server will also store the value internally as a 64-bit value, but
        // cast it to an HDEVNOTIFY of appropriate size for the client.
        //
        // Note that we have RPC transmit this parameter simply as a pointer to
        // a ULONG64 (which is actually a pointer itself).  We don't transmit it
        // as a pointer to a PPNP_CLIENT_CONTEXT (which is also a pointer)
        // because RPC would instead allocate the memory to marshall the
        // contents of the structure to the server.  The server would get a
        // pointer to RPC allocated memory, not the actual value of the client
        // pointer - which is all we really want to send in the first place.
        // The server does not actually use this value as a pointer to anything.
        //
        ClientContext64 = (ULONG64)ClientContext;

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RegisterNotification(
                hBinding,
                (ULONG_PTR)hRecipient,
                ClientName,
                NotificationFilter,
                ulSize,
                Flags,
                &((PNP_NOTIFICATION_CONTEXT)(ClientContext->PNP_CC_ContextHandle)),
                GetCurrentProcessId(),
                &((ULONG64)ClientContext64));

        } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS | DBGF_EVENT,
                       "PNP_RegisterNotification caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            //
            // Something went wrong. If we built a context handle
            // let it dangle; we can't tell RPC it's gone. (will get rundown)
            // If it's NULL, free the memory.
            // Don't tell the client we succeeded
            //
            if (ClientContext->PNP_CC_ContextHandle == 0) {
                LocalFree (ClientContext);
            }
            *Context = NULL;
        } else {
            *Context = (PNP_NOTIFICATION_CONTEXT)ClientContext;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_RegisterNotification



CONFIGRET
CMP_UnregisterNotification(
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    This routine unregisters the Plug and Play device event notification entry
    represented by the specified notification context.

Parameters:

    Context - Supplies a client notification context.

Return Value:

    Returns CR_SUCCESS if the component was successfully unregistered for
    notification. If the function fails, the return value is one of the
    following:

        CR_FAILURE,
        CR_INVALID_POINTER

Notes:

    This CM API does not allow the client to specify a server name because the
    RPC call is always made to the local server.  This routine will never call
    the corresponding RPC server interface (PNP_UnregisterNotification)
    remotely.  Additionally, this routine is private, and should only be called
    via user32!UnregisterDeviceNotification.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    PPNP_CLIENT_CONTEXT ClientContext = (PPNP_CLIENT_CONTEXT)Context;

    try {
        //
        // validate parameters
        //
        if (Context == 0 || Context == (ULONG_PTR)(-1)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // make sure the client context signature is valid
        //
        if (ClientContext->PNP_CC_Signature != CLIENT_CONTEXT_SIGNATURE) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "CMP_UnregisterNotification: bad signature on client handle\n"));
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(NULL, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_UnregisterNotification(
                hBinding,
                (PPNP_NOTIFICATION_CONTEXT)&(ClientContext->PNP_CC_ContextHandle));

        } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS | DBGF_EVENT,
                       "PNP_UnregisterNotification caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            //
            // invalidate the client context signature and free the client
            // context structure.
            //
            ClientContext->PNP_CC_Signature = 0;
            LocalFree((PVOID)Context);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_UnregisterNotification
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\_winnt\_winnt.c ===
#include <windows.h>
#include <stdio.h>
#include "rc_ids.h"

//
// This app is a very simple wrapper for autoplay functionality
// for x86. It invokes winnt.exe on Win95 and winnt32.exe on NT.
//

#define SUCCESS 0
#define FAILURE 1


VOID
Error(
    IN UINT  Id,
    IN PCSTR Parameter OPTIONAL
    )
{
    CHAR String[1024];
    CHAR Message[4096];

    LoadString(
        GetModuleHandle(NULL),
        Id,
        String,
        sizeof(String)
        );

    if(Parameter) {
        _snprintf(Message,sizeof(Message),String,Parameter);
    } else {
        lstrcpy(Message,String);
    }

    MessageBox(NULL,Message,NULL,MB_ICONERROR|MB_OK|MB_SYSTEMMODAL);
}


int
__cdecl
main(
    VOID
    )
{
    PCSTR CmdLine;
    CHAR cmdLine[4096];
    PCSTR CmdLineTail;
    unsigned TailOffset;
    CHAR ModuleName[MAX_PATH];
    PCHAR p;
    OSVERSIONINFO VersionInfo;
    BOOL b;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;


    //
    // Form name of app we want to invoke.
    //
    GetModuleFileName(GetModuleHandle(NULL),ModuleName,MAX_PATH);
    CharUpper(ModuleName);
    p = strstr(ModuleName,"\\_WINNT.EXE");
    if(!p) {
        Error(INVALID_MODNAME,ModuleName);
        return(FAILURE);
    }
    *(++p) = 0;

    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&VersionInfo)) {
        Error(GETVER_FAILED,NULL);
        return(FAILURE);
    }

    lstrcpy(
        p,
        (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? "WINNT32.EXE" : "WINNT.EXE"
        );

    //
    // Get the command line. We will assume that this app is in
    // some subdirectory, probably \i386, on the CD, and that it is
    // called _winnt.exe.
    //
    CmdLine = GetCommandLine();

    //
    // Uppercase the command line so we can locate the command tail.
    //
    lstrcpyn(cmdLine,CmdLine,sizeof(cmdLine));
    CharUpper(cmdLine);

    CmdLineTail = strstr(cmdLine,"\\_WINNT");
    if(CmdLineTail == NULL) {
        Error(INVALID_CMDLINE,CmdLine);
        return(FAILURE);
    }

    CmdLineTail += sizeof("\\_WINNT") - 1;

    if(*CmdLineTail == '\"') {
        CmdLineTail++;
    } else {

        //
        // The next characters better be .exe or a space.
        //
        if(strncmp(CmdLineTail," ",1) && strncmp(CmdLineTail,".EXE ",5)) {

            Error(INVALID_CMDLINE,CmdLine);
            return(FAILURE);
        }
    }

    CmdLineTail = strchr(CmdLineTail,' ');
    if(!CmdLineTail) {
        CmdLineTail += lstrlen(CmdLineTail);
    }

    //
    // Now we want to point to the non-lowercased cmd line tail
    //
    TailOffset = CmdLineTail - cmdLine;
    CmdLineTail = CmdLine + TailOffset;

    //
    // Build a full command line: appname + cmd tail
    //
    lstrcpy(cmdLine,ModuleName);
    lstrcat(cmdLine,CmdLineTail);

    //
    // Invoke the correct setup app.
    //
    ZeroMemory(&StartupInfo,sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    b = CreateProcess(
            ModuleName,
            cmdLine,
            NULL,
            NULL,
            FALSE,
            0,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInfo
            );

    if(!b) {
        Error(CREATEPROC_FAILED,cmdLine);
        return(FAILURE);
    }

    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);
    return(SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\pnp_c_stub.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    pnp_c_stub.c

Abstract:

    Stub file to allow pnp_c.c to work with precompiled headers.

Author:

    Jim Cavalaris (jamesca) 04-06-2001

Environment:

    User-mode only.

Revision History:

    06-April-2001     jamesca

        Creation and initial implementation.

Notes:

    The included file pnp_c.c contains the client side stubs for the PNP RPC
    interface.  The stubs are platform specific, and are included from
    ..\idl\$(O).  You must first build ..\idl for the current platform prior to
    building cfgmgr32.

--*/

#include "precomp.h"
#include "pnp_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\logconf.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    logconf.c

Abstract:

    This module contains the API routines that operate directly on logical
    configurations.

               CM_Add_Empty_Log_Conf
               CM_Free_Log_Conf
               CM_Get_First_Log_Conf
               CM_Get_Next_Log_Conf
               CM_Free_Log_Conf_Handle
               CM_Get_Log_Conf_Priority_Ex

Author:

    Paula Tomlinson (paulat) 9-26-1995

Environment:

    User mode only.

Revision History:

    26-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"

//
// Private prototypes
//
CONFIGRET
CreateLogConfHandle(
    PLOG_CONF   plcLogConf,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag
    );

BOOL
ValidateLogConfHandle(
    PPrivate_Log_Conf_Handle   pLogConf
    );



CONFIGRET
CM_Add_Empty_Log_Conf_Ex(
    OUT PLOG_CONF plcLogConf,
    IN  DEVINST   dnDevInst,
    IN  PRIORITY  Priority,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine creates an empty logical configuration.  This configuration
   has no resource descriptor.

Parameters:

   plcLogConf  Address of a variable that receives the handle of the logical
               configuration.

   dnDevNode   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   Priority    Specifies the priority of the logical configuration.

   ulFlags     Supplies flags relating to the logical configuration.  Must
               be either BASIC_LOG_CONF or FILTERED_LOG_CONF, combined with
               either PRIORITY_EQUAL_FIRST or PRIORITY_EQUAL_LAST.

               BASIC_LOG_CONF - Specifies the requirements list
               FILTERED_LOG_CONF - Specifies the filtered requirements list
               PRIORITY_EQUAL_FIRST - Same priority, new one is first
               PRIORITY_EQUAL_LAST - Same priority, new one is last

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_OUT_OF_MEMORY,
         CR_INVALID_PRIORITY,
         CR_INVALID_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulTag = 0;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (plcLogConf == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (Priority > MAX_LCPRI) {
            Status = CR_INVALID_PRIORITY;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, LOG_CONF_BITS | PRIORITY_BIT)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *plcLogConf = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_AddEmptyLogConf(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                Priority,         // priority for new log conf
                &ulTag,           // return tag of log conf
                ulFlags);         // type of log conf to add
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_AddEmptyLogConf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            //
            // allocate a new log conf handle, fill with log conf info
            //
            Status = CreateLogConfHandle(plcLogConf, dnDevInst,
                                         ulFlags & LOG_CONF_BITS,
                                         ulTag);
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Add_Empty_Log_Conf_Ex



CONFIGRET
CM_Free_Log_Conf_Ex(
    IN LOG_CONF lcLogConfToBeFreed,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine frees a logical configuration and all resource descriptors
   associated with it.   This API may invalidate the logical configuration
   handles returned by the CM_Get_First_Log_Conf and CM_Get_Next_Log_Conf
   APIs.  To continue enumerating logical configurations, always use the
   CM_Get_First_Log_Conf API to start again from the beginning.

Parameters:

   lcLogConfToBeFreed   Supplies the handle of the logical configuration to
               free.  This handle must have been previously returned from
               a call to CM_Add_Empty_Log_Conf.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    ULONG       ulTag, ulType,ulLen = MAX_DEVICE_ID_LEN;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConfToBeFreed)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // extract the devnode and log conf info from the log conf handle
        //
        dnDevInst = ((PPrivate_Log_Conf_Handle)lcLogConfToBeFreed)->LC_DevInst;
        ulTag     = ((PPrivate_Log_Conf_Handle)lcLogConfToBeFreed)->LC_LogConfTag;
        ulType    = ((PPrivate_Log_Conf_Handle)lcLogConfToBeFreed)->LC_LogConfType;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_REGISTRY,
                   "CM_Free_Log_Conf_Ex: Deleting LogConf (pDeviceID = %s, Type = %d\r\n",
                   pDeviceID,
                   ulType));

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_FreeLogConf(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                ulType,           // identifies which type of log conf
                ulTag,            // identifies which actual log conf
                ulFlags);         // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_FreeLogConf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_INVALID_LOG_CONF;    // probably a bad log conf got us here
    }

    return Status;

} // CM_Free_Log_Conf_Ex



CONFIGRET
CM_Get_First_Log_Conf_Ex(
    OUT PLOG_CONF plcLogConf,       OPTIONAL
    IN  DEVINST   dnDevInst,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine returns a handle to the first logical configuration of the
   specified type in a device instance.  The CM_Add_Empty_Log_Conf and
   CM_Free_Log_Conf APIs may invalidate the handle of the logical
   configuration returned by this API.  To enumerate logical configurations
   after adding or freeing a logical configuration, always call this API
   again to retrieve a valid handle.

Parameters:

   plcLogConf  Supplies the address of the variable that receives the handle
               of the logical configuration.

   dnDevNode   Supplies the handle of the device instance for which to
               retrieve the logical configuration.

   ulFlags     Configuration type.  Can be one of the following values:
               ALLOC_LOG_CONF - Retrieve the allocated configuration.
               BASIC_LOG_CONF - Retrieve the requirements list.
               BOOT_LOG_CONF  - Retrieve the boot configuration.

               The following additional configuration type is also defined
               for Windows 95:
               FILTERED_LOG_CONF - Retrieve the filtered requirements list.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_NO_MORE_LOF_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulTag = 0,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, LOG_CONF_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Initialize paramters (plcLogConf is optional)
        //
        if (plcLogConf != NULL) {
            *plcLogConf = 0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetFirstLogConf(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                ulFlags,          // type of long conf
                &ulTag,           // return tag of specific log conf
                ulFlags);         // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetFirstLogConf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS  && plcLogConf != NULL) {
            //
            // allocate a new log conf handle, fill with log conf info
            //
            Status = CreateLogConfHandle(plcLogConf, dnDevInst,
                                         ulFlags & LOG_CONF_BITS,
                                         ulTag);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_First_Log_Conf_Ex



CONFIGRET
CM_Get_Next_Log_Conf_Ex(
    OUT PLOG_CONF plcLogConf,     OPTIONAL
    IN  LOG_CONF  lcLogConf,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine returns a handle to the next logical configuration following
   the given configuration. This API returns CR_NO_MORE_LOG_CONF if the given
   handle was retrieved using the CM_Get_First_Log_Conf API with either the
   ALLOC_LOG_CONF or BOOT_LOG_CONF flag.  There is never more than one active
   boot logical configuration or currently-allocated logical configuration.
   The CM_Add_Empty_Log_Conf and CM_Free_Log_Conf APIs may invalidate the
   logical configuration handle returned by this API.  To continue enumerating
   logical configuration after addding or freeing a logical configuration,
   always use the CM_Get_First_Log_Conf API to start again from the beginning.

Parameters:

   plcLogConf  Supplies the address of the variable that receives the handle
               of the next logical configuration.

   lcLogConf   Supplies the handle of a logical configuration.  This handle
               must have been previously retrieved using either this API or
               the CM_Get_First_Log_Conf API.  Logical configurations are in
               priority order.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_LOG_CONF,
         CR_INVALID_POINTER,
         CR_NO_MORE_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulType = 0, ulCurrentTag = 0, ulNextTag = 0,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConf)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Initialize paramters (plcLogConf is optional)
        //
        if (plcLogConf != NULL) {
            *plcLogConf = 0;
        }

        //
        // extract devnode and log conf info from the current log conf handle
        //
        dnDevInst    = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_DevInst;
        ulType       = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfType;
        ulCurrentTag = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetNextLogConf(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                ulType,           // specifes which type of log conf
                ulCurrentTag,     // specifies current log conf tag
                &ulNextTag,       // return tag of next log conf
                ulFlags);         // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetNextLogConf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS  &&  plcLogConf != NULL) {
            //
            // allocate a new log conf handle, fill with log conf info
            //
            Status = CreateLogConfHandle(plcLogConf, dnDevInst,
                                         ulType, ulNextTag);
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Next_Log_Conf_Ex



CONFIGRET
CM_Free_Log_Conf_Handle(
    IN  LOG_CONF  lcLogConf
    )

/*++

Routine Description:

   This routine frees the handle to the specified log conf and frees and
   memory associated with that log conf handle.

Parameters:

   lcLogConf   Supplies the handle of a logical configuration.  This handle
               must have been previously retrieved using CM_Add_Empty_Log_Conf,
               CM_Get_First_Log_Conf or CM_Get_Next_Log_Conf.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;


    try {
        //
        // Validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConf)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // It's a valid log conf handle, which is a pointer to memory
        // allocated when the log conf was created or retrieved using
        // the first/next routines. Free the associated memory.
        //
        ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_Signature = 0;
        pSetupFree((PPrivate_Log_Conf_Handle)lcLogConf);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Log_Conf_Handle



CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority_Ex(
    IN  LOG_CONF  lcLogConf,
    OUT PPRIORITY pPriority,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine returns the priority value of the specified log conf.
   Only BASIC, FILTERED and OVERRIDE log confs (requirements lists) have
   a priority value associated with them. If a FORCED, BOOT, or ALLOC
   config is passed in, then CR_INVALID_LOG_CONF will be returned.

Parameters:

   lcLogConf   Supplies the handle of a logical configuration.  This handle
               must have been previously retrieved using either the
               CM_Add_Emptry_Log_Conf, CM_Get_First_Log_Conf, or
               CM_Get_Next_Log_Conf API.

   pPriority   Supplies the address of the variable that receives the
               priorty (if any) associated with this logical configuration.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_LOG_CONF,
         CR_INVALID_POINTER,
         CR_NO_MORE_LOG_CONF.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulType = 0, ulTag = 0,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConf)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (pPriority == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // extract devnode and log conf info from the current log conf handle
        //
        dnDevInst = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_DevInst;
        ulType    = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfType;
        ulTag     = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfTag;

        //
        // only "requirements list" style log confs have priorities and
        // are valid in this call.
        //
        if ((ulType != BASIC_LOG_CONF) &&
            (ulType != FILTERED_LOG_CONF) &&
            (ulType != OVERRIDE_LOG_CONF)) {

            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetLogConfPriority(
                hBinding,         // rpc binding handle
                pDeviceID,        // device id string
                ulType,           // specifes which type of log conf
                ulTag,            // specifies current log conf tag
                pPriority,        // return tag of next log conf
                ulFlags);         // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetLogConfPriority caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Log_Conf_Handle



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Add_Empty_Log_Conf(
    OUT PLOG_CONF plcLogConf,
    IN  DEVINST   dnDevInst,
    IN  PRIORITY  Priority,
    IN  ULONG     ulFlags
    )
{
    return CM_Add_Empty_Log_Conf_Ex(plcLogConf, dnDevInst, Priority,
                                    ulFlags, NULL);
}


CONFIGRET
CM_Free_Log_Conf(
    IN LOG_CONF lcLogConfToBeFreed,
    IN ULONG    ulFlags
    )
{
    return CM_Free_Log_Conf_Ex(lcLogConfToBeFreed, ulFlags, NULL);
}


CONFIGRET
CM_Get_First_Log_Conf(
    OUT PLOG_CONF plcLogConf,
    IN  DEVINST   dnDevInst,
    IN  ULONG     ulFlags
    )
{
    return CM_Get_First_Log_Conf_Ex(plcLogConf, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Next_Log_Conf(
    OUT PLOG_CONF plcLogConf,
    IN  LOG_CONF  lcLogConf,
    IN  ULONG     ulFlags
    )
{
    return CM_Get_Next_Log_Conf_Ex(plcLogConf, lcLogConf, ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority(
    IN  LOG_CONF  lcLogConf,
    OUT PPRIORITY pPriority,
    IN  ULONG     ulFlags
    )
{
    return CM_Get_Log_Conf_Priority_Ex(lcLogConf, pPriority, ulFlags, NULL);
}



//-------------------------------------------------------------------
// Local Utility Routines
//-------------------------------------------------------------------


CONFIGRET
CreateLogConfHandle(
    PLOG_CONF   plcLogConf,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag
    )
{
    PPrivate_Log_Conf_Handle   pLogConfHandle;

    //
    // allocate memory for the res des handle data
    //
    pLogConfHandle = (PPrivate_Log_Conf_Handle)pSetupMalloc(
                            sizeof(Private_Log_Conf_Handle));

    if (pLogConfHandle == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    //
    // fill in the private res des info and return as handle
    //
    pLogConfHandle->LC_Signature   = CM_PRIVATE_LOGCONF_SIGNATURE;
    pLogConfHandle->LC_DevInst     = dnDevInst;
    pLogConfHandle->LC_LogConfType = ulLogType;
    pLogConfHandle->LC_LogConfTag  = ulLogTag;

    *plcLogConf = (LOG_CONF)pLogConfHandle;

    return CR_SUCCESS;

} // CreateLogConfHandle



BOOL
ValidateLogConfHandle(
    PPrivate_Log_Conf_Handle   pLogConf
    )
{
    //
    // validate parameters
    //
    if (pLogConf == NULL  || pLogConf == 0) {
        return FALSE;
    }

    //
    // check for the private log conf signature
    //
    if (pLogConf->LC_Signature != CM_PRIVATE_LOGCONF_SIGNATURE) {
        return FALSE;
    }

    return TRUE;

} // ValidateLogConfHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\precomp.h ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for the Configuration Manager.

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpnpapi.h>

//
// Win32 Public Header Files
//
#include <windows.h>
#include <cfgmgr32.h>
#include <dbt.h>
#include <regstr.h>

//
// CRT Header Files
//
#include <stdlib.h>
#include <stddef.h>

//
// RPC Header Files
//
#include <ntrpcp.h>     // RpcpBindRpc, RpcpUnbindRpc
#include <rpcasync.h>   // I_RpcExceptionFilter

//
// Private Header Files
//
#include "pnp.h"        // midl generated, rpc interfaces
#include "cfgmgrp.h"    // private shared header, needs handle_t so must follow pnp.h
#include "umpnplib.h"   // private shared header, for routines in shared umpnplib
#include "ppmacros.h"   // private macros / debug header

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\misc.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains miscellaneous Configuration Manager API routines.

               CM_Get_Version
               CM_Is_Version_Available
               CM_Connect_Machine
               CM_Disconnect_Machine
               CM_Get_Global_State
               CM_Run_Detection
               CM_Query_Arbitrator_Free_Data
               CM_Query_Resource_Conflicts
               CM_Query_Arbitrator_Free_Size

               CMP_Report_LogOn
               CMP_Init_Detection
               CMP_WaitServicesAvailable
               CMP_WaitNoPendingInstallEvents
               CMP_GetBlockedDriverInfo

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    20-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"
#include "pnpipc.h"


//
// global data
//
extern PVOID    hLocalStringTable;                  // NOT MODIFIED BY THESE PROCEDURES
extern WCHAR    LocalMachineNameNetBIOS[];          // NOT MODIFIED BY THESE PROCEDURES
extern WCHAR    LocalMachineNameDnsFullyQualified[];// NOT MODIFIED BY THESE PROCEDURES

#define NUM_LOGON_RETRIES   30


//
// Private prototypes
//

BOOL
IsRemoteServiceRunning(
    IN  LPCWSTR   UNCServerName,
    IN  LPCWSTR   ServiceName
    );



WORD
CM_Get_Version_Ex(
    IN  HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine retrieves the version number of the Configuration Manager APIs.

Arguments:

   hMachine

Return value:

   The function returns the major revision number in the high byte and the
   minor revision number in the low byte.  For example, version 4.0 of
   Configuration Manager returns 0x0400.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WORD        wVersion = (WORD)CFGMGR32_VERSION;
    handle_t    hBinding = NULL;

    //
    // setup rpc binding handle
    //
    if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return wVersion = 0;
    }

    RpcTryExcept {
        //
        // call rpc service entry point
        //
        Status = PNP_GetVersion(
                hBinding,               // rpc machine name
                &wVersion);             // server size version
    }
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "PNP_GetVersion caused an exception (%d)\n",
                   RpcExceptionCode()));

        SetLastError(RpcExceptionCode());
        wVersion = 0;
    }
    RpcEndExcept

    return wVersion;

} // CM_Get_Version_Ex



BOOL
CM_Is_Version_Available_Ex(
    IN  WORD       wVersion,
    IN  HMACHINE   hMachine
    )
/*++

Routine Description:

   This routine returns whether a specific version of the Configuration Manager
   APIs are available.

Arguments:

   wVersion - Version to query.

   hMachine - Machine to connect to.

Return value:

   The function returns TRUE if the version of the Configuration Manager APIs is
   equal to or greater than the specified version.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    WORD        wVersionInternal;

    //
    // version 0x0400 is available on all servers, by definition.
    //
    if (wVersion <= (WORD)0x0400) {
        return TRUE;
    }

    //
    // setup rpc binding handle
    //
    if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
        return FALSE;
    }

    //
    // retrieve the internal server version.
    //
    if (!PnPGetVersion(hMachine, &wVersionInternal)) {
        return FALSE;
    }

    //
    // versions up to and including the internal server version are available.
    //
    return (wVersion <= wVersionInternal);

} // CM_Is_Version_Available_Ex



CONFIGRET
CM_Connect_MachineW(
    IN  PCWSTR    UNCServerName,
    OUT PHMACHINE phMachine
    )

/*++

Routine Description:

   This routine connects to the machine specified and returns a handle that
   is then passed to future calls to the Ex versions of the CM routines.
   This allows callers to get device information on remote machines.

Arguments:

   UNCServerName - Specifies the UNC name of the remote machine to connect to.

   phMachine     - Specifies the address of a variable to receive a handle to
                   the connected machine.

Return value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns one
   of the CR_* error codes.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    WORD           wVersion = 0, wVersionInternal;
    PPNP_MACHINE   pMachine = NULL;
    INT            MachineNameLen;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(phMachine)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *phMachine = NULL;

        //
        // if machine name specified, check for UNC format
        //
        if(UNCServerName && *UNCServerName) {

            MachineNameLen = lstrlen(UNCServerName);

            if((MachineNameLen < 3) || (MachineNameLen > (MAX_PATH + 2)) ||
                (UNCServerName[0] != L'\\') ||
                (UNCServerName[1] != L'\\')) {

                Status = CR_INVALID_MACHINENAME;
                goto Clean0;
            }
        }

        //
        // allocate memory for the machine structure and initialize it
        //
        pMachine = (PPNP_MACHINE)pSetupMalloc(sizeof(PNP_MACHINE));

        if(!pMachine) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }


        if (!UNCServerName  ||
            !*UNCServerName ||
            !lstrcmpi(UNCServerName, LocalMachineNameNetBIOS) ||
            !lstrcmpi(UNCServerName, LocalMachineNameDnsFullyQualified)) {

            //----------------------------------------------------------
            // If no machine name was passed in or the machine name
            // matches the local name, use local machine info rather
            // than creating a new binding.
            //----------------------------------------------------------

            PnPGetGlobalHandles(NULL,
                                &pMachine->hStringTable,
                                &pMachine->hBindingHandle);

            if (!UNCServerName) {

                lstrcpy(pMachine->szMachineName, LocalMachineNameNetBIOS);

            } else {

                lstrcpy(pMachine->szMachineName, UNCServerName);
            }

        } else {

            //
            // First, make sure that the RemoteRegistry service is running on
            // the remote machine, since RemoteRegistry is required for several
            // cfgmgr32/setupapi services.
            //
            if (!IsRemoteServiceRunning(UNCServerName, L"RemoteRegistry")) {
                Status = CR_NO_CM_SERVICES;
                goto Clean0;
            }

            //-------------------------------------------------------------
            // A remote machine name was specified so explicitly force a
            // new binding for this machine.
            //-------------------------------------------------------------

            pMachine->hBindingHandle =
                      (PVOID)PNP_HANDLE_bind((PNP_HANDLE)UNCServerName);

            if (pMachine->hBindingHandle == NULL) {

                if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
                    Status = CR_OUT_OF_MEMORY;
                } else if (GetLastError() == ERROR_INVALID_COMPUTERNAME) {
                    Status = CR_INVALID_MACHINENAME;
                } else {
                    Status = CR_FAILURE;
                }
                goto Clean0;
            }

            //
            // initialize a string table for use with this connection to
            // the remote machine
            //
            pMachine->hStringTable = pSetupStringTableInitialize();

            if (pMachine->hStringTable == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            //
            // Add a priming string (see dll entrypt in main.c for details)
            //
            pSetupStringTableAddString(pMachine->hStringTable,
                                 PRIMING_STRING,
                                 STRTAB_CASE_SENSITIVE);

            //
            // save the machine name
            //
            lstrcpy(pMachine->szMachineName, UNCServerName);
        }

        //
        // test the binding by calling the simplest RPC call (good way
        // for the caller to know whether the service is actually
        // running)
        //

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetVersion(
                pMachine->hBindingHandle,
                &wVersion);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS,
                       "PNP_GetVersion caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            //
            // we got the standard version alright, now try to determine the
            // internal version of the server.  initialize the version supplied
            // to the internal version of the client.
            //
            wVersionInternal = (WORD)CFGMGR32_VERSION_INTERNAL;

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetVersionInternal(pMachine->hBindingHandle,
                                                &wVersionInternal);
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                //
                // rpc exception may occur if the interface does not exist on
                // the server, indicating a server version prior to NT 5.1.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "PNP_GetVersionInternal caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

            if (Status == CR_SUCCESS) {
                //
                // PNP_GetVersionInternal exists on NT 5.1 and later.
                //
                ASSERT(wVersionInternal >= (WORD)0x0501);

                //
                // use the real internal version of the server instead of the
                // static version returned by PNP_GetVersion.
                //
                wVersion = wVersionInternal;
            }

            //
            // no matter what happened while trying to retrieve the internal
            // version of the server, we were successful before this.
            //
            Status = CR_SUCCESS;
        }

        if (Status == CR_SUCCESS) {
            pMachine->ulSignature = (ULONG)MACHINE_HANDLE_SIGNATURE;
            pMachine->wVersion = wVersion;
            *phMachine = (HMACHINE)pMachine;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (Status != CR_SUCCESS  &&  pMachine != NULL) {
       pSetupFree(pMachine);
    }

    return Status;

} // CM_Connect_MachineW




CONFIGRET
CM_Disconnect_Machine(
    IN HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine disconnects from a machine that was previously connected to
   with the CM_Connect_Machine call.

Arguments:

   hMachine - Specifies a machine handle previously returned by a call to
              CM_Connect_Machine.

Return value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns one
   of the CR_* error codes.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PPNP_MACHINE   pMachine = NULL;

    try {
        //
        // validate parameters
        //
        if (hMachine == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        pMachine = (PPNP_MACHINE)hMachine;

        if (pMachine->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // only free the machine info if it's not the local machine
        //
        if (pMachine->hStringTable != hLocalStringTable) {
            //
            // free the rpc binding for this remote machine
            //
            PNP_HANDLE_unbind((PNP_HANDLE)pMachine->szMachineName,
                              (handle_t)pMachine->hBindingHandle);

            //
            // release the string table
            //
            pSetupStringTableDestroy(pMachine->hStringTable);
        }

        //
        // invalidate the signature so we never try to free it again.
        //
        pMachine->ulSignature = 0;

        //
        // free the memory for the PNP_MACHINE struct
        //
        pSetupFree(pMachine);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Disconnect_Machine



CONFIGRET
CM_Get_Global_State_Ex(
    OUT PULONG   pulState,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the global state of the configuration manager.

Parameters:

   pulState Supplies the address of the variable that receives the
            Configuration Managers state.  May be a combination of the
            following values:

            Configuration Manager Global State Flags:
            CM_GLOBAL_STATE_CAN_DO_UI
                  Can UI be initiated? [TBD:  On NT, this may relate to
                  whether anyone is logged in]
            CM_GLOBAL_STATE_SERVICES_AVAILABLE
                  Are the CM APIs available? (on Windows NT this is always set)
            CM_GLOBAL_STATE_SHUTTING_DOWN
                  The Configuration Manager is shutting down.
                  [TBD:  Does this only happen at shutdown/restart time?]
            CM_GLOBAL_STATE_DETECTION_PENDING
                  The Configuration Manager is about to initiate some
                  sort of detection.

            Windows 95 also defines the following additional flag:
            CM_GLOBAL_STATE_ON_BIG_STACK
                  [TBD: What should this be defaulted to for NT?]

   ulFlags  Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pulState)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetGlobalState(
                hBinding,                  // rpc binding handle
                pulState,                  // returns global state
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetGlobalState caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Global_State_Ex



CONFIGRET
CM_Run_Detection_Ex(
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

   Routine Description:

      This routine loads and executes a detection module.

   Parameters:

      ulFlags - Specifies the reason for the detection. Can be one of the
                following values:

                Detection Flags:
                CM_DETECT_NEW_PROFILE  - Run detection for a new hardware
                                         profile.
                CM_DETECT_CRASHED      - Previously attempted detection crashed.

                (Windows 95 defines the following two unused flags as well:
                CM_DETECT_HWPROF_FIRST_BOOT and CM_DETECT_RUN.)

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is CR_INVALID_FLAG.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_DETECT_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RunDetection(
                hBinding,
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RunDetection caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Run_Detection_Ex



CONFIGRET
CM_Query_Arbitrator_Free_Data_Ex(
    OUT PVOID      pData,
    IN  ULONG      DataLen,
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )

/*++

   Routine Description:

      This routine returns information about available resources of a
      particular type. If the given size is not large enough, this API
      truncates the data and returns CR_BUFFER_SMALL.  To determine the
      buffer size needed to receive all the available resource information,
      use the CM_Query_Arbitrator_Free_Size API.

   Parameters:

      pData       Supplies the address of the buffer that receives information
                  on the available resources for the resource type specified
                  by ResourceID.

      DataLen     Supplies the size, in bytes, of the data buffer.

      dnDevNode   Supplies the handle of the device instance associated with
                  the arbitrator.  This is only meaningful for local
                  arbitrators--for global arbitrators, specify the root device
                  instance or NULL.  On Windows NT, this parameter must
                  specify either the Root device instance or NULL.

      ResourceID  Supplies the type of the resource. Can be one of the ResType
                  values listed in Section 2.1.2.1..  (This API returns
                  CR_INVALID_RESOURCEID if this value is ResType_All or
                  ResType_None.)

      ulFlags     Must be zero.

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is one of the following:
            CR_BUFFER_SMALL,
            CR_FAILURE,
            CR_INVALID_DEVNODE,
            CR_INVALID_FLAG,
            CR_INVALID_POINTER, or
            CR_INVALID_RESOURCEID.
            (Windows 95 may also return CR_NO_ARBITRATOR.)

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pData)) || (DataLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_QUERY_ARBITRATOR_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryArbitratorFreeData(
                hBinding,
                pData,
                DataLen,
                pDeviceID,
                ResourceID,
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryArbitratorFreeData caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Query_Arbitrator_Free_Data_Ex


#if 0

CONFIGRET
WINAPI
CM_Query_Resource_Conflicts_Ex(
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResourceData,
    IN  ULONG      ResourceLen,
    IN OUT PVOID   pData,
    IN OUT PULONG  pulDataLen,
    IN  ULONG      ulFlags
    )

/*++

   Routine Description:

      This routine returns a list of devnodes that own resources that would
      conflict with the specified resource. If there are no conflicts, the
      returned list is NULL. If the caller supplied buffer is not large enough,
      CR_BUFFER_SMALL is returned and pulDataLen contains the required buffer
      size.

   Parameters:

      dnDevInst   Supplies the handle of the device instance associated with
                  the arbitrator.  This is only meaningful for local
                  arbitrators--for global arbitrators, specify the root device
                  instance or NULL.  On Windows NT, this parameter must
                  specify either the Root device instance or NULL.  ???

      ResourceID  Supplies the type of the resource. Can be one of the ResType
                  values listed in Section 2.1.2.1..  (This API returns
                  CR_INVALID_RESOURCEID if this value is ResType_All or
                  ResType_None.)

      ResourceData Supplies the adress of an IO_DES, MEM_DES, DMA_DES, IRQ_DES,
                  etc, structure, depending on the given resource type.

      ResourceLen Supplies the size, in bytes, of the structure pointed to
                  by ResourceData.

      pData       Supplies the address of the buffer that receives information
                  on the available resources for the resource type specified
                  by ResourceID.

      pulDataLen  Supplies the size, in bytes, of the data buffer.

      ulFlags     Must be zero.

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is one of the following:
            CR_BUFFER_SMALL,
            CR_FAILURE,
            CR_INVALID_DEVNODE,
            CR_INVALID_FLAG,
            CR_INVALID_POINTER, or
            CR_INVALID_RESOURCEID.
            (Windows 95 may also return CR_NO_ARBITRATOR.)

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pData)) ||
            (!ARGUMENT_PRESENT(pulDataLen)) ||
            (*pulDataLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_QUERY_ARBITRATOR_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryArbitratorFreeData(
                hBinding,
                pData,
                DataLen,
                pDeviceID,
                ResourceID,
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryArbitratorFreeData caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Query_Resource_Conflicts_Ex
#endif



CONFIGRET
CM_Query_Arbitrator_Free_Size_Ex(
      OUT PULONG     pulSize,
      IN  DEVINST    dnDevInst,
      IN  RESOURCEID ResourceID,
      IN  ULONG      ulFlags,
      IN  HMACHINE   hMachine
      )
/*++

   Routine Description:


      This routine retrieves the size of the available resource information
      that would be returned in a call to the CM_Query_Arbitrator_Free_Data
      API.

   Parameters:

      pulSize     Supplies the address of the variable that receives the size,
                  in bytes, that is required to hold the available resource
                  information.

      dnDevNode   Supplies the handle of the device instance associated with
                  the arbitrator.  This is only meaningful for local
                  arbitrators--for global arbitrators, specify the root
                  device instance or NULL.  On Windows NT, this parameter
                  must specify either the Root device instance or NULL.

      ResourceID  Supplies the type of the resource.  Can be one of the
                  ResType values listed in Section 2.1.2.1..  (This API returns
                  CR_INVALID_RESOURCEID if this value is ResType_All or
                  ResType_None.)

      ulFlags     CM_QUERY_ARBITRATOR_BITS.

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is one of the following:
            CR_FAILURE,
            CR_INVALID_DEVNODE,
            CR_INVALID_FLAG,
            CR_INVALID_POINTER, or
            CR_INVALID_RESOURCEID.
            (Windows 95 may also return CR_NO_ARBITRATOR.)

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulSize)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_QUERY_ARBITRATOR_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_QueryArbitratorFreeSize(
                hBinding,
                pulSize,
                pDeviceID,
                ResourceID,
                ulFlags);                  // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_QueryArbitratorFreeSize caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Query_Arbitrator_Free_Size_Ex



//-------------------------------------------------------------------
// Private CM routines
//-------------------------------------------------------------------


CONFIGRET
CMP_Report_LogOn(
    IN ULONG    ulPrivateID,
    IN DWORD    ProcessID
    )
{
    CONFIGRET            Status = CR_SUCCESS;
    handle_t             hBinding = NULL;
    BOOL                 bAdmin = FALSE;
    DWORD                Retries = 0;

    //
    // This routine currently gets called by userinit.exe to let us know
    // that someone has just logged on.
    //

    try {

        //
        // validate parameters
        //
        if (ulPrivateID != 0x07020420) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // this is always to the local server, by definition
        //
        if (!PnPGetGlobalHandles(NULL, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // determine from the userinit process, whether the user
        // logged onto an account that is part of Administrators
        // local group
        //
        bAdmin = pSetupIsUserAdmin();

        for (Retries = 0; Retries < NUM_LOGON_RETRIES; Retries++) {

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_ReportLogOn(
                    hBinding,                  // rpc binding handle
                    bAdmin,                    // Is Admin?
                    ProcessID);                // userinit.exe process id
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_ReportLogOn caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

            if (Status == CR_NO_CM_SERVICES ||
                Status == CR_REMOTE_COMM_FAILURE) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PlugPlay services not available (%d), retrying...\n",
                           Status));

                Sleep(5000);        // wait and then retry
                continue;

            } else {

                goto Clean0;       // success or other non-rpc error
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_Report_LogOn



CONFIGRET
CMP_Init_Detection(
    IN ULONG    ulPrivateID
    )
{
    CONFIGRET            Status = CR_SUCCESS;
    handle_t             hBinding = NULL;

    try {
        //
        // validate parameters
        //
        if (ulPrivateID != 0x07020420) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // this is always to the local server, by definition
        //
        if (!PnPGetGlobalHandles(NULL, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_InitDetection(
                hBinding);                 // rpc binding handle
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_InitDetection caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_Init_Detection



CONFIGRET
CMP_WaitServicesAvailable(
    IN  HMACHINE   hMachine
    )

/*++

   Routine Description:

        This routine determines whether the user-mode pnp manager server side
        (umpnpmgr) is up and running yet (providing the PNP_Xxx side of the
        config manager apis).

   Parameters:

       hMachine - private (opaque) cm machine handle. If NULL, the call refers
            to the local machine.

   Return Value:

      If the service is avialable upon return then CR_SUCCESS is returned.
      If some other failure occurs, CR_FAILURE is returned.

--*/
{
    CONFIGRET   Status = CR_NO_CM_SERVICES;
    handle_t    hBinding = NULL;
    WORD        wVersion;

    try {

        //
        // setup rpc binding handle (don't need string table handle)
        //

        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        while ((Status == CR_NO_CM_SERVICES) ||
               (Status == CR_MACHINE_UNAVAILABLE) ||
               (Status == CR_REMOTE_COMM_FAILURE)) {

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetVersion(
                    hBinding,       // rpc machine name
                    &wVersion);     // server size version
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "PNP_GetVersion caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

            if (Status == CR_SUCCESS) {

                //
                // Service is avilable now, return success.
                //

                goto Clean0;
            }

            if ((Status == CR_NO_CM_SERVICES) ||
                (Status == CR_MACHINE_UNAVAILABLE) ||
                (Status == CR_REMOTE_COMM_FAILURE)) {

                //
                // This is some error related to the service not being
                // available, wait and try again.
                //

                Sleep(5000);

            } else {

                //
                // Some other error, the service may never be avaiable
                // so bail out now.
                //

                Status = CR_FAILURE;
                goto Clean0;
            }

        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_WaitServicesAvailable



DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    )

/*++

   Routine Description:

        This routine waits until there are no pending device install events.
        If a timeout value is specified then it will return either when no
        install events are pending or when the timeout period has expired,
        whichever comes first. This routine is intended to be called after
        user-logon, only.

        NOTE: New install events can occur at anytime, this routine just
        indicates that there are no install events at this moment.

   Parameters:

       dwTimeout - Specifies the time-out interval, in milliseconds. The function
            returns if the interval elapses, even if there are still pending
            install events. If dwTimeout is zero, the function just tests whether
            there are pending install events and returns immediately. If
            dwTimeout is INFINITE, the function's time-out interval never elapses.

   Return Value:

      If the function succeeds, the return value indicates the event that caused
      the function to return. If the function fails, the return value is
      WAIT_FAILED. To get extended error information, call GetLastError.
      The return value on success is one of the following values:

        WAIT_ABANDONED  The specified object is a mutex object that was not
                        released by the thread that owned the mutex object before
                        the owning thread terminated. Ownership of the mutex
                        object is granted to the calling thread, and the mutex is
                        set to nonsignaled.
        WAIT_OBJECT_0   The state of the specified object is signaled.
        WAIT_TIMEOUT    The time-out interval elapsed, and the object's state is
                        nonsignaled.

--*/
{
    DWORD Status = WAIT_FAILED;
    HANDLE hEvent = NULL;

    try {

        hEvent = OpenEvent(SYNCHRONIZE, FALSE, PNP_NO_INSTALL_EVENTS);

        if (hEvent == NULL) {
            Status = WAIT_FAILED;
        } else {
            Status = WaitForSingleObject(hEvent, dwTimeout);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = WAIT_FAILED;
    }

    if (hEvent) {
        CloseHandle(hEvent);
    }

    return Status;

} // CMP_WaitNoPendingInstallEvents



CONFIGRET
CMP_GetBlockedDriverInfo(
    OUT LPBYTE      Buffer,
    IN OUT PULONG   pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

    This routine retrieves the list of drivers that have been blocked from
    loading on the system since boot.

Arguments:

    Buffer    - Supplies the address of the buffer that receives the list of
                drivers that have been blocked from loading on the system.  Can
                be NULL when simply retrieving data size.

    pulLength - Supplies the address of the variable that contains the size, in
                bytes, of the buffer.  If the variable is initially zero, the
                API replaces it with the buffer size needed to receive all the
                data.  In this case, the Buffer parameter is ignored.

    ulFlags   - Must be zero.

    hMachine  - Machine handle returned from CM_Connect_Machine or NULL.

Return value:

    If the function succeeds, it returns CR_SUCCESS, otherwise it returns one of
    the CR_* error codes.

--*/

{
    CONFIGRET   Status;
    ULONG       ulTransferLen;
    BYTE        NullBuffer = 0;
    handle_t    hBinding = NULL;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // NOTE: The ulTransferLen variable is just used to control
        // how much data is marshalled via rpc between address spaces.
        // ulTransferLen should be set on entry to the size of the Buffer.
        // The last parameter should also be the size of the Buffer on entry
        // and on exit contains either the amount transferred (if a transfer
        // occured) or the amount required, this value should be passed back
        // in the callers pulLength parameter.
        //
        ulTransferLen = *pulLength;
        if (!ARGUMENT_PRESENT(Buffer)) {
            Buffer = &NullBuffer;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetBlockedDriverInfo(
                hBinding,       // rpc binding handle
                Buffer,         // receives blocked driver info
                &ulTransferLen, // input/output buffer size
                pulLength,      // bytes copied (or bytes required)
                ulFlags);       // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS,
                       "PNP_GetBlockedDriverInfo caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_GetBlockedDriverInfo



CONFIGRET
CMP_GetServerSideDeviceInstallFlags(
    IN  PULONG      pulSSDIFlags,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

    This routine retrieves the server side device install flags.                                

Arguments:

    pulSSDIFlags - Pointer to a ULONG that receives the server side device 
                   install flags.

    ulFlags   - Must be zero.

    hMachine  - Machine handle returned from CM_Connect_Machine or NULL.

Return value:

    If the function succeeds, it returns CR_SUCCESS, otherwise it returns one of
    the CR_* error codes.

--*/

{
    CONFIGRET   Status;
    handle_t    hBinding = NULL;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pulSSDIFlags)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle (don't need string table handle)
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetServerSideDeviceInstallFlags(
                hBinding,       // rpc binding handle
                pulSSDIFlags,   // receives server side device install flags
                ulFlags);       // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS,
                       "PNP_GetServerSideDeviceInstallFlags caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CMP_GetServerSideDeviceInstallFlags



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


WORD
CM_Get_Version(
    VOID
    )
{
    return CM_Get_Version_Ex(NULL);
}


BOOL
CM_Is_Version_Available(
    IN  WORD  wVersion
    )
{
    return CM_Is_Version_Available_Ex(wVersion, NULL);
}


CONFIGRET
CM_Get_Global_State(
    OUT PULONG pulState,
    IN  ULONG  ulFlags
    )
{
    return CM_Get_Global_State_Ex(pulState, ulFlags, NULL);
}


CONFIGRET
CM_Query_Arbitrator_Free_Data(
    OUT PVOID      pData,
    IN  ULONG      DataLen,
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags
    )
{
    return CM_Query_Arbitrator_Free_Data_Ex(pData, DataLen, dnDevInst,
                                            ResourceID, ulFlags, NULL);
}


CONFIGRET
CM_Query_Arbitrator_Free_Size(
    OUT PULONG     pulSize,
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags
    )
{
    return CM_Query_Arbitrator_Free_Size_Ex(pulSize, dnDevInst, ResourceID,
                                            ulFlags, NULL);
}


CONFIGRET
CM_Run_Detection(
    IN ULONG ulFlags
    )
{
    return CM_Run_Detection_Ex(ulFlags, NULL);
}



//-------------------------------------------------------------------
// ANSI Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Connect_MachineA(
    IN  PCSTR     UNCServerName,
    OUT PHMACHINE phMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    PWSTR       pUniName = NULL;

    if (UNCServerName == NULL  ||
        *UNCServerName == 0x0) {
        //
        // no explicit name specified, so assume local machine and
        // nothing to translate
        //
        Status = CM_Connect_MachineW(pUniName,
                                     phMachine);

    } else if (pSetupCaptureAndConvertAnsiArg(UNCServerName, &pUniName) == NO_ERROR) {

        Status = CM_Connect_MachineW(pUniName,
                                     phMachine);
        pSetupFree(pUniName);

    } else {
        Status = CR_INVALID_DATA;
    }

    return Status;

} // CM_Connect_MachineA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\hwprof.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    hwprof.c

Abstract:

    This module contains the API routines that operate directly on hardware
    profile configurations.

               CM_Is_Dock_Station_Present
               CM_Request_Eject_PC
               CM_Get_HW_Prof_Flags
               CM_Set_HW_Prof_Flags
               CM_Get_Hardware_Profile_Info
               CM_Set_HW_Prof

Author:

    Paula Tomlinson (paulat) 7-18-1995

Environment:

    User mode only.

Revision History:

    18-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"



CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present_Ex(
    OUT PBOOL pbPresent,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine determines whether a docking station is currently present.

Parameters:

   pbPresent         Supplies the address of a boolean variable that is set
                     upon successful return to indicate whether or not a
                     docking station is currently present.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR failure code.

--*/

{
    CONFIGRET   status = CR_SUCCESS;
    handle_t    hBinding = NULL;

    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pbPresent)) {
            status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Initialize output parameter
        //
        *pbPresent = FALSE;

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            status = PNP_IsDockStationPresent(
                hBinding,
                pbPresent);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_IsDockStationPresent caused an exception (%d)\n",
                       RpcExceptionCode()));

            status = MapRpcExceptionToCR(RpcExceptionCode());
            goto Clean0;
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = CR_FAILURE;
    }

    return status;

} // CM_Is_Dock_Station_Present_Ex



CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC_Ex(
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

    This routine requests that the PC be ejected (i.e., undocked).

Parameters:

    none.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR failure code.

--*/

{
    CONFIGRET   status = CR_SUCCESS;
    handle_t    hBinding = NULL;

    try {
        //
        // No input Parameters to validate.
        //

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            status = PNP_RequestEjectPC(hBinding);  // rpc binding handle
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RequestEjectPC caused an exception (%d)\n",
                       RpcExceptionCode()));

            status = MapRpcExceptionToCR(RpcExceptionCode());
            leave;
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = CR_FAILURE;
    }

    return status;

} // CM_Request_Eject_PC_Ex



CONFIGRET
CM_Get_HW_Prof_Flags_ExW(
    IN  DEVINSTID_W pDeviceID,
    IN  ULONG       ulHardwareProfile,
    OUT PULONG      pulValue,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the configuration-specific configuration flags
   for a device instance and hardware profile combination.

Parameters:

   pDeviceID         Supplies the address of a NULL-terminated string
                     specifying the name of the device instance to query.

   ulHardwareProfile Supplies the handle of the hardware profile to query.
                     If 0, the API queries the current hardware profile.

   pulValue          Supplies the address of the variable that receives the
                     configuration-specific configuration (CSCONFIGFLAG_)
                     flags.

   ulFlags           Must be zero.

   hMachine          Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_REGISTRY_ERROR,
         CR_REMOTE_COMM_FAILURE,
         CR_MACHINE_UNAVAILABLE,
         CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szFixedUpDeviceID[MAX_DEVICE_ID_LEN];
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(pDeviceID)) ||
            (!ARGUMENT_PRESENT(pulValue))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // check the format of the device id string
        //
        if ((!*pDeviceID) ||
            (!IsLegalDeviceId(pDeviceID))) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        //
        // fix up the device ID string for consistency (uppercase, etc)
        //
        CopyFixedUpDeviceId(szFixedUpDeviceID,
                            pDeviceID,
                            lstrlen(pDeviceID));

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
             Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_HwProfFlags(
                hBinding,               // rpc binding handle
                PNP_GET_HWPROFFLAGS,    // HW Prof Action flag
                szFixedUpDeviceID,      // device id string
                ulHardwareProfile,      // hw config id
                pulValue,               // config flags returned here
                NULL,                   // Buffer that receives VetoType
                NULL,                   // Buffer that receives VetoName
                0,                      // Size of VetoName buffer
                ulFlags);               // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_HwProfFlags caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_HW_Prof_Flags_ExW




CONFIGRET
CM_Set_HW_Prof_Flags_ExW(
    IN DEVINSTID_W pDeviceID,
    IN ULONG     ulConfig,
    IN ULONG     ulValue,
    IN ULONG     ulFlags,
    IN HMACHINE  hMachine
    )

/*++

Routine Description:

   This routine sets the configuration-specific configuration flags for a
   device instance and hardware profile combination.  If the
   CSCONFIGFLAG_DO_NOT_CREATE bit is set for an existing device instance
   in the current hardware profile, it will be removed.  If the
   CSCONFIGFLAG_DO_NOT_CREATE bit is cleared in the current hardware profile,
   the entire hardware tree will be reenumerated, so that the parent of the
   device instance has the chance to create the device instance if necessary.

Parameters:

   pDeviceID      Supplies the address of a null-terminated string that
                  specifies the name of a device instance to modify.

   ulConfig       Supplies the number of the hardware profile to modify.
                  If 0, the API modifies the current hardware profile.

   ulValue        Supplies the configuration flags value.  Can be a
                  combination of these values:

                  CSCONFIGFLAG_DISABLE    Disable the device instance in this
                                          hardware profile.

                  CSCONFIGFLAG_DO_NOT_CREATE    Do not allow this device
                        instance to be created in this hardware profile.

   ulFlags        CM_SET_HW_PROF_FLAGS_UI_NOT_OK
                    If this flag is specified then the OS will not display the
                    reason that the device failed to be disabled or removed.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_REGISTRY_ERROR,
         CR_REMOTE_COMM_FAILURE,
         CR_MACHINE_UNAVAILABLE,
         CR_FAILURE.

--*/

{
    CONFIGRET       Status = CR_SUCCESS;
    WCHAR           szFixedUpDeviceID[MAX_DEVICE_ID_LEN];
    ULONG           ulTempValue = 0;
    handle_t        hBinding = NULL;
    PNP_VETO_TYPE   vetoType, *pVetoType;
    WCHAR           vetoName[MAX_DEVICE_ID_LEN], *pszVetoName;
    ULONG           ulNameLength;


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pDeviceID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_SET_HW_PROF_FLAGS_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulValue, CSCONFIGFLAG_BITS)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // check the format of the device id string
        //
        if ((!*pDeviceID) ||
            (!IsLegalDeviceId(pDeviceID))) {
            Status = CR_INVALID_DEVICE_ID;
            goto Clean0;
        }

        //
        // fix up the device ID string for consistency (uppercase, etc)
        //
        CopyFixedUpDeviceId(szFixedUpDeviceID,
                            pDeviceID,
                            lstrlen(pDeviceID));

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (ulFlags & CM_SET_HW_PROF_FLAGS_UI_NOT_OK) {
            vetoType = PNP_VetoTypeUnknown;
            pVetoType = &vetoType;
            vetoName[0] = L'\0';
            pszVetoName = &vetoName[0];
            ulNameLength = MAX_DEVICE_ID_LEN;
        } else {
            pVetoType = NULL;
            pszVetoName = NULL;
            ulNameLength = 0;
        }

        ulTempValue = ulValue;

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_HwProfFlags(
                hBinding,               // rpc machine name
                PNP_SET_HWPROFFLAGS,    // HW Prof Action flag
                szFixedUpDeviceID,      // device id string
                ulConfig,               // hw config id
                &ulTempValue,           // specifies config flags
                pVetoType,              // Buffer that receives the VetoType
                pszVetoName,            // Buffer that receives the VetoName
                ulNameLength,           // size of the pszVetoName buffer
                ulFlags);               // specifies hwprof set flags
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_HwProfFlags caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Set_HW_Prof_Flags_ExW



CONFIGRET
CM_Get_Hardware_Profile_Info_ExW(
    IN  ULONG            ulIndex,
    OUT PHWPROFILEINFO_W pHWProfileInfo,
    IN  ULONG            ulFlags,
    IN  HMACHINE         hMachine
    )

/*++

Routine Description:

   This routine returns information about a hardware profile.

Parameters:

   ulIndex        Supplies the index of the hardware profile to retrieve
                  information for.  Specifying 0xFFFFFFFF references the
                  currently active hardware profile.

   pHWProfileInfo Supplies the address of a HWPROFILEINFO structure that
                  will receive information about the specified hardware
                  profile.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_DATA,
         CR_NO_SUCH_VALUE,
         CR_REGISTRY_ERROR,
         CR_REMOTE_COMM_FAILURE,
         CR_MACHINE_UNAVAILABLE,
         CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulSize = sizeof(HWPROFILEINFO);
    handle_t    hBinding = NULL;


    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pHWProfileInfo)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetHwProfInfo(
                hBinding,               // rpc machine name
                ulIndex,                // hw profile index
                pHWProfileInfo,         // returns profile info
                ulSize,                 // sizeof of profile info struct
                ulFlags);               // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetHwProfInfo caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Hardware_Profile_Info_ExW



CONFIGRET
CM_Set_HW_Prof_Ex(
    IN ULONG    ulHardwareProfile,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

   Routine Description:

      This routine sets the current hardware profile. This API updates the
      HKEY_CURRENT_CONFIG predefined key in the registry, broadcasts a
      DBT_CONFIGCHANGED message, and reenumerates the root device instance.
      It should only be called by the Configuration Manager and the control
      panel.

   Parameters:

      ulHardwareProfile Supplies the current hardware profile handle.

      ulFlags           Must be zero.

   Return Value:

      If the function succeeds, the return value is CR_SUCCESS.
      If the function fails, the return value is one of the following:
        CR_INVALID_FLAG or
        CR_REGISTRY_ERROR.  (Windows 95 may also return CR_NOT_AT_APPY_TIME.)

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_SetHwProf(
                hBinding,               // rpc machine name
                ulHardwareProfile,      // hw config id
                ulFlags);               // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_SetHwProf caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Set_HW_Prof_Ex



//-------------------------------------------------------------------
// ANSI Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Get_HW_Prof_Flags_ExA(
    IN  DEVINSTID_A szDevInstName,
    IN  ULONG       ulHardwareProfile,
    OUT PULONG      pulValue,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    PWSTR       pUniDeviceID = NULL;

    //
    // convert devinst string to UNICODE and pass to wide version
    //
    if (pSetupCaptureAndConvertAnsiArg(szDevInstName, &pUniDeviceID) == NO_ERROR) {

        Status = CM_Get_HW_Prof_Flags_ExW(pUniDeviceID,
                                          ulHardwareProfile,
                                          pulValue,
                                          ulFlags,
                                          hMachine);
        pSetupFree(pUniDeviceID);

    } else {
        Status = CR_INVALID_POINTER;
    }

    return Status;

} // CM_Get_HW_Prof_Flags_ExA



CONFIGRET
CM_Set_HW_Prof_Flags_ExA(
    IN DEVINSTID_A szDevInstName,
    IN ULONG       ulConfig,
    IN ULONG       ulValue,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    PWSTR       pUniDeviceID = NULL;

    //
    // convert devinst string to UNICODE and pass to wide version
    //
    if (pSetupCaptureAndConvertAnsiArg(szDevInstName, &pUniDeviceID) == NO_ERROR) {

        Status = CM_Set_HW_Prof_Flags_ExW(pUniDeviceID,
                                          ulConfig,
                                          ulValue,
                                          ulFlags,
                                          hMachine);
        pSetupFree(pUniDeviceID);

    } else {
        Status = CR_INVALID_POINTER;
    }

    return Status;

} // CM_Set_HW_Prof_Flags_ExA



CONFIGRET
CM_Get_Hardware_Profile_Info_ExA(
    IN  ULONG            ulIndex,
    OUT PHWPROFILEINFO_A pHWProfileInfo,
    IN  ULONG            ulFlags,
    IN  HMACHINE         hMachine
    )
{
    CONFIGRET           Status = CR_SUCCESS;
    HWPROFILEINFO_W     UniHwProfInfo;
    ULONG               ulLength;

    //
    // validate essential parameters only
    //
    if (!ARGUMENT_PRESENT(pHWProfileInfo)) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode struct as a parameter
    //
    Status = CM_Get_Hardware_Profile_Info_ExW(ulIndex,
                                              &UniHwProfInfo,
                                              ulFlags,
                                              hMachine);

    //
    // a HWPROFILEINFO_W structure should always be large enough.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    //
    // copy the info from the unicode structure to the ansi structure passed in
    // by the caller (converting the embedded strings to ansi in the process)
    //
    if (Status == CR_SUCCESS) {

        pHWProfileInfo->HWPI_ulHWProfile = UniHwProfInfo.HWPI_ulHWProfile;
        pHWProfileInfo->HWPI_dwFlags     = UniHwProfInfo.HWPI_dwFlags;

        //
        // convert the hardware profile friendly name string to ANSI.
        //
        ulLength = MAX_PROFILE_LEN;
        Status = PnPUnicodeToMultiByte(UniHwProfInfo.HWPI_szFriendlyName,
                                       (lstrlenW(UniHwProfInfo.HWPI_szFriendlyName)+1)*sizeof(WCHAR),
                                       pHWProfileInfo->HWPI_szFriendlyName,
                                       &ulLength);

        //
        // the ANSI representation of a hardware profile friendly name string
        // should not be longer than MAX_PROFILE_LEN bytes, because that's the
        // max size of the buffer in the structure.
        //
        ASSERT(Status != CR_BUFFER_SMALL);
    }

    return Status;

} // CM_Get_Hardware_Profile_Info_ExA




//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC (
    VOID
    )
{
    return CM_Request_Eject_PC_Ex (NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present (
    OUT PBOOL pbPresent
    )
{
    return CM_Is_Dock_Station_Present_Ex (pbPresent, NULL);
}


CONFIGRET
CM_Get_HW_Prof_FlagsW(
    IN  DEVINSTID_W pDeviceID,
    IN  ULONG       ulHardwareProfile,
    OUT PULONG      pulValue,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_HW_Prof_Flags_ExW(pDeviceID, ulHardwareProfile,
                                    pulValue, ulFlags, NULL);
}


CONFIGRET
CM_Get_HW_Prof_FlagsA(
    IN  DEVINSTID_A pDeviceID,
    IN  ULONG       ulHardwareProfile,
    OUT PULONG      pulValue,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_HW_Prof_Flags_ExA(pDeviceID, ulHardwareProfile,
                                    pulValue, ulFlags, NULL);
}


CONFIGRET
CM_Set_HW_Prof_FlagsW(
    IN DEVINSTID_W pDeviceID,
    IN ULONG       ulConfig,
    IN ULONG       ulValue,
    IN ULONG       ulFlags
    )
{
    return CM_Set_HW_Prof_Flags_ExW(pDeviceID, ulConfig, ulValue,
                                    ulFlags, NULL);
}


CONFIGRET
CM_Set_HW_Prof_FlagsA(
    IN DEVINSTID_A pDeviceID,
    IN ULONG       ulConfig,
    IN ULONG       ulValue,
    IN ULONG       ulFlags
    )
{
    return CM_Set_HW_Prof_Flags_ExA(pDeviceID, ulConfig, ulValue,
                                    ulFlags, NULL);
}


CONFIGRET
CM_Get_Hardware_Profile_InfoW(
    IN  ULONG            ulIndex,
    OUT PHWPROFILEINFO_W pHWProfileInfo,
    IN  ULONG            ulFlags
    )
{
    return CM_Get_Hardware_Profile_Info_ExW(ulIndex, pHWProfileInfo,
                                            ulFlags, NULL);
}


CONFIGRET
CM_Get_Hardware_Profile_InfoA(
    IN  ULONG            ulIndex,
    OUT PHWPROFILEINFO_A pHWProfileInfo,
    IN  ULONG            ulFlags
    )
{
    return CM_Get_Hardware_Profile_Info_ExA(ulIndex, pHWProfileInfo,
                                            ulFlags, NULL);
}


CONFIGRET
CM_Set_HW_Prof(
    IN ULONG ulHardwareProfile,
    IN ULONG ulFlags
    )
{
    return CM_Set_HW_Prof_Ex(ulHardwareProfile, ulFlags, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\main.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module contains the startup and termination code for the Configuration
    Manager (cfgmgr32).

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    3-Mar-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"

//
// global data
//
HANDLE   hInst;
PVOID    hLocalStringTable = NULL;     // handle to local string table
PVOID    hLocalBindingHandle = NULL;   // rpc binding handle to local machine
WORD     LocalServerVersion = 0;       // local machine internal server version
WCHAR    LocalMachineNameNetBIOS[MAX_PATH + 3];
WCHAR    LocalMachineNameDnsFullyQualified[MAX_PATH + 3];
CRITICAL_SECTION  BindingCriticalSection;
CRITICAL_SECTION  StringTableCriticalSection;



BOOL
CfgmgrEntry(
    PVOID hModule,
    ULONG Reason,
    PCONTEXT pContext
    )

/*++

Routine Description:

   This is the standard DLL entrypoint routine, called whenever a process
   or thread attaches or detaches.
   Arguments:

   hModule -   PVOID parameter that specifies the handle of the DLL

   Reason -    ULONG parameter that specifies the reason this entrypoint
               was called (either PROCESS_ATTACH, PROCESS_DETACH,
               THREAD_ATTACH, or THREAD_DETACH).

   pContext -  Not used.
               (when cfgmgr32 is initialized by setupapi - as should almost
               always be the case - this is the 'Reserved' argument supplied to
               setupapi's DllMain entrypoint)

Return value:

   Returns true if initialization compeleted successfully, false is not.

--*/

{
    UNREFERENCED_PARAMETER(pContext);

    hInst = (HANDLE)hModule;

    switch(Reason) {

        case DLL_PROCESS_ATTACH: {

            WCHAR    szTemp[MAX_PATH + 1];
            ULONG    ulSize = SIZECHARS(szTemp);

            try {
                InitializeCriticalSection(&BindingCriticalSection);
                InitializeCriticalSection(&StringTableCriticalSection);
            } except(EXCEPTION_EXECUTE_HANDLER) {
                //
                // InitializeCriticalSection may raise STATUS_NO_MEMORY
                // exception
                //
                return FALSE;
            }

            //
            // save the name of the local NetBIOS machine for later use
            //
            if(!GetComputerNameEx(ComputerNameNetBIOS, szTemp, &ulSize)) {
                //
                // ISSUE: (lonnym)--can we actually run w/o knowing the local
                // machine name???
                //
                *LocalMachineNameNetBIOS = L'\0';
            } else {
                //
                // always save local machine name in "\\name format"
                //
                if((lstrlen(szTemp) > 2) &&
                   (szTemp[0] == L'\\') && (szTemp[1] == L'\\')) {
                    //
                    // The name is already in the correct format.
                    //
                    lstrcpy(LocalMachineNameNetBIOS, szTemp);
                } else {
                    //
                    // Prepend UNC path prefix
                    //
                    lstrcpy(LocalMachineNameNetBIOS, L"\\\\");
                    lstrcat(LocalMachineNameNetBIOS, szTemp);
                }
            }

            //
            // save the name of the local Dns machine for later use
            //
            ulSize = SIZECHARS(szTemp);
            if(!GetComputerNameEx(ComputerNameDnsFullyQualified, szTemp, &ulSize)) {
                //
                // ISSUE: (lonnym)--can we actually run w/o knowing the local
                // machine name???
                //
                *LocalMachineNameDnsFullyQualified = L'\0';
            } else {
                //
                // always save local machine name in "\\name format"
                //
                if((lstrlen(szTemp) > 2) &&
                   (szTemp[0] == L'\\') && (szTemp[1] == L'\\')) {
                    //
                    // The name is already in the correct format.
                    //
                    lstrcpy(LocalMachineNameDnsFullyQualified, szTemp);
                } else {
                    //
                    // Prepend UNC path prefix
                    //
                    lstrcpy(LocalMachineNameDnsFullyQualified, L"\\\\");
                    lstrcat(LocalMachineNameDnsFullyQualified, szTemp);
                }
            }
            break;
        }

        case DLL_PROCESS_DETACH:
            //
            // release the rpc binding for the local machine
            //
            if (hLocalBindingHandle != NULL) {

                PNP_HANDLE_unbind(NULL, (handle_t)hLocalBindingHandle);
                hLocalBindingHandle = NULL;
            }

            //
            // release the string table for the local machine
            //
            if (hLocalStringTable != NULL) {
                pSetupStringTableDestroy(hLocalStringTable);
                hLocalStringTable = NULL;
            }

            DeleteCriticalSection(&BindingCriticalSection);
            DeleteCriticalSection(&StringTableCriticalSection);
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            break;
    }

    return TRUE;

} // CfgmgrEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\range.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    range.c

Abstract:

    This module contains the API routines that operate directly on ranges.

          CM_Add_Range
          CM_Create_Range_List
          CM_Delete_Range
          CM_Dup_Range_List
          CM_Find_Range
          CM_First_Range
          CM_Free_Range_List
          CM_Intersect_Range_List
          CM_Invert_Range_List
          CM_Merge_Range_List
          CM_Next_Range
          CM_Test_Range_Available

Author:

    Paula Tomlinson (paulat) 10-17-1995

Environment:

    User mode only.

Revision History:

    17-Oct-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"


//
// Private prototypes
//
BOOL
IsValidRangeList(
    IN RANGE_LIST rlh
    );

CONFIGRET
AddRange(
    IN PRange_Element  pParentElement,
    IN DWORDLONG       ullStartValue,
    IN DWORDLONG       ullEndValue,
    IN ULONG           ulFlags
    );

CONFIGRET
InsertRange(
    IN PRange_Element  pParentElement,
    IN DWORDLONG       ullStartValue,
    IN DWORDLONG       ullEndValue
    );

CONFIGRET
DeleteRange(
    IN PRange_Element  pParentElement
    );

CONFIGRET
JoinRange(
    IN PRange_Element  pParentElement,
    IN DWORDLONG       ullStartValue,
    IN DWORDLONG       ullEndValue
    );

CONFIGRET
CopyRanges(
    IN PRange_Element  pFromRange,
    IN PRange_Element  pToRange
    );

CONFIGRET
ClearRanges(
    IN PRange_Element  pRange
    );

CONFIGRET
TestRange(
    IN  PRange_Element   rlh,
    IN  DWORDLONG        ullStartValue,
    IN  DWORDLONG        ullEndValue,
    OUT PRange_Element   *pConflictingRange
    );


//
// global data
//





CONFIGRET
CM_Add_Range(
    IN DWORDLONG  ullStartValue,
    IN DWORDLONG  ullEndValue,
    IN RANGE_LIST rlh,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine adds a memory range to a range list.

Parameters:

   ullStartValue  Low end of the range.

   ullEndValue    High end of the range.

   rlh            Handle of a range list.

   ulFlags        Supplies flags specifying options for ranges that conflict
                  with ranges alread in the list.  May be one of the
                  following values:

                  CM_ADD_RANGE_ADDIFCONFLICT New range is merged with the
                                             ranges it conflicts with.
                  CM_ADD_RANGE_DONOTADDIFCONFLICT Returns CR_FAILURE if there
                                             is a conflict.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_RANGE,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY.
--*/

{
    CONFIGRET    Status = CR_SUCCESS;
    BOOL         bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_ADD_RANGE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ullStartValue > ullEndValue) {
            Status = CR_INVALID_RANGE;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        Status = AddRange((PRange_Element)rlh, ullStartValue,
                          ullEndValue, ulFlags);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Add_Range



CONFIGRET
CM_Create_Range_List(
    OUT PRANGE_LIST prlh,
    IN  ULONG  ulFlags
    )

/*++

Routine Description:

   This routine creates a list of ranges.

Parameters:

   prlh     Supplies the address of the variable that receives a
            handle to the new range list.

   ulFlags  Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET         Status = CR_SUCCESS;
    PRange_List_Hdr   pRangeHdr = NULL;


    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (prlh == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // allocate a buffer for the range list header struct
        //
        pRangeHdr = pSetupMalloc(sizeof(Range_List_Hdr));

        if (pRangeHdr == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // initialize the range list header buffer
        //
        pRangeHdr->RLH_Head = 0;
        pRangeHdr->RLH_Header = (ULONG_PTR)pRangeHdr;
        pRangeHdr->RLH_Signature = Range_List_Signature;

        //
        // initialize the private resource lock
        //
        InitPrivateResource(&(pRangeHdr->RLH_Lock));

        //
        // return a pointer to range list buffer to the caller
        //
        *prlh = (RANGE_LIST)pRangeHdr;


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Create_Range_List



CONFIGRET
CM_Delete_Range(
    IN DWORDLONG  ullStartValue,
    IN DWORDLONG  ullEndValue,
    IN RANGE_LIST rlh,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine deletes a range from a range list. If ullStartValue
   and ullEndValue are set to 0 and DWORD_MAX, this API carries out
   a special case, quickly emptying the lower 4 Gigabytes of the range.
   If ullEndValue is instead DWORDLONG_MAX, the entire range list is
   cleared, without having to process each element.

Parameters:

   ullStartValue  Low end of the range.

   ullEndValue    High end of the range.

   rlh            Handle of a range list.

   ulFlags        Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_RANGE,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRange = NULL, pPrevious = NULL, pCurrent = NULL;
    BOOL           bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ullStartValue > ullEndValue) {
            Status = CR_INVALID_RANGE;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        pPrevious = (PRange_Element)rlh;


        //-------------------------------------------------------------
        // first check the special case range values
        //-------------------------------------------------------------

        if (ullStartValue == 0) {

            if (ullEndValue == DWORDLONG_MAX) {
                //
                // quick clear of all ranges
                //
                ClearRanges(pPrevious);
            }

            else if (ullEndValue == DWORD_MAX) {
                //
                // quick clear of lower 4 GB ranges
                //
                while (pPrevious->RL_Next != 0) {
                    pCurrent = (PRange_Element)pPrevious->RL_Next;

                    if (pCurrent->RL_Start >= DWORD_MAX) {
                        goto Clean0;   // done
                    }

                    if (pCurrent->RL_End >= DWORD_MAX) {
                        pCurrent->RL_Start = DWORD_MAX;
                        goto Clean0;   // done
                    }

                    DeleteRange(pPrevious);    // pass the parent
                }
                goto Clean0;
            }
        }


        //-------------------------------------------------------------
        // search through each range in this list, if any part of the
        // specified range is contained in this range list, remove the
        // intersections
        //-------------------------------------------------------------

        while (pPrevious->RL_Next != 0) {
            pRange = (PRange_Element)pPrevious->RL_Next;

            //
            // if this range is completely before the current range, then
            // we can stop
            //
            if (ullEndValue < pRange->RL_Start) {
                break;
            }

            //
            // if this range is completely after the current range, then
            // skip to the next range
            //
            if (ullStartValue > pRange->RL_End) {
                goto NextRange;
            }

            //
            // if the range is completely contained, then delete the whole
            // thing
            //
            if (ullStartValue <= pRange->RL_Start  &&
                ullEndValue >= pRange->RL_End) {

                DeleteRange(pPrevious);    // pass the parent range

                //
                // don't goto next range because that would increment the
                // pPrevious counter. Since the current range was just deleted,
                // we need to process the current spot still.
                //
                continue;
            }

            //
            // if the start of the specified range intersects the current range,
            // adjust the current range to exclude it
            //
            if (ullStartValue > pRange->RL_Start  &&
                ullStartValue <= pRange->RL_End) {
                //
                // if the specified range is in the middle of this range, then
                // in addition to shrinking the first part of the range, I'll
                // have to create a range for the second part
                //       |  |<-- delete --->|  |
                //
                if (ullEndValue < pRange->RL_End) {
                    AddRange(pRange, ullEndValue+1, pRange->RL_End,
                             CM_ADD_RANGE_ADDIFCONFLICT);
                }

                pRange->RL_End = ullStartValue-1;

                //
                // reset the delete range for further processing
                //
                if (ullEndValue > pRange->RL_End) {
                    ullStartValue = pRange->RL_End+1;
                }
            }

            //
            // if the end of the specified range intersects the current range,
            // adjust the current range to exclude it
            //
            if (ullEndValue >= pRange->RL_Start  &&
                ullEndValue <= pRange->RL_End) {

                pRange->RL_Start = ullEndValue+1;

                //
                // reset the delete range for further processing
                //
                if (ullEndValue > pRange->RL_End) {
                    ullStartValue = pRange->RL_End+1;
                }
            }


            NextRange:

            pPrevious = (PRange_Element)pPrevious->RL_Next;
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Delete_Range



CONFIGRET
CM_Dup_Range_List(
    IN RANGE_LIST rlhOld,
    IN RANGE_LIST rlhNew,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine copies a range list.

Parameters:

   rlhOld   Supplies the handle of the range list to copy.

   rlhNew   Supplies the handle of a valid range list into which rlhOld
            is copied.  Anything contained in the rlhNew range list is
            removed by the copy operation.

   ulFlags  Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRangeNew = NULL, pRangeOld = NULL;
    BOOL           bLockOld = FALSE, bLockNew = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlhOld)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhNew)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlhOld)->RLH_Lock);
        bLockOld = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
        bLockNew = TRUE;

        pRangeNew = (PRange_Element)rlhNew;
        pRangeOld = (PRange_Element)rlhOld;

        //
        // If the new range list is not empty, then delete ranges
        //
        if (pRangeNew->RL_Next != 0) {
            ClearRanges(pRangeNew);
        }

        Status = CR_SUCCESS;    // reset status flag to okay


        //
        // duplicate each of the old ranges
        //
        pRangeOld = (PRange_Element)pRangeOld->RL_Next;
        CopyRanges(pRangeOld, pRangeNew);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLockOld = bLockOld;    // needed to prevent optimizing this flag away
        bLockNew = bLockNew;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLockOld) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld)->RLH_Lock);
    }
    if (bLockNew) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
    }

    return Status;

} // CM_Dup_Range_List



CONFIGRET
CM_Find_Range(
    OUT PDWORDLONG pullStart,
    IN  DWORDLONG  ullStart,
    IN  ULONG      ulLength,
    IN  DWORDLONG  ullAlignment,
    IN  DWORDLONG  ullEnd,
    IN  RANGE_LIST rlh,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

  This routine attempts to find a range in the supplied range list that
  will accommodate the range requirements specified.  [TBD:  Verify
  that this description is correct.]

Parameters:

   pullStart   Supplies the address of a variable that receives the
               starting value of the allocated range.

   ullStart    Supplies the starting address that the range can have.

   ulLength    Supplies the length needed for the allocated range.

   ullAlignment   Supplies the alignment bitmask that specifies where the
               allocated range can start. [TBD:  verify that this is indeed
               a bitmask]

   ullEnd      Supplies the ending address of the area from which the range
               may be allocated.

   rlh         Supplies a handle to a range list in which the specified
               range is to be found.

   ulFlags     TBD


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_FAILURE

--*/

{
    CONFIGRET         Status = CR_SUCCESS;
    PRange_Element    pRange = NULL;
    DWORDLONG         ullNewEnd;
    BOOL              bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (pullStart == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        //
        // Normalize aligment. Alignments are now like 0x00000FFF.
        //
        ullAlignment =~ ullAlignment;

        //
        // Test for impossible alignments (-1, not a power of 2 or start is
        // less than alignment away from wrapping). Also test for invalid
        // length.
        //
        if ((ullAlignment == DWORD_MAX) |
            (ulLength == 0) |
            ((ullAlignment & (ullAlignment + 1)) != 0) |
            (ullStart + ullAlignment < ullStart)) {

            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Align the base.
        //
        ullStart += ullAlignment;
        ullStart &= ~ullAlignment;

        //
        // Compute the new end.
        //
        ullNewEnd = ullStart + ulLength - 1;

        //
        // Make sure we do have space.
        //
        if ((ullNewEnd < ullStart) || (ullNewEnd > ullEnd)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Check if that range fits
        //
        if (TestRange((PRange_Element)rlh, ullStart, ullStart + ulLength - 1,
                      &pRange) == CR_SUCCESS) {
            //
            // We got it then, on the first try.
            //
            *pullStart = ullStart;
            goto Clean0;
        }

        //
        // Search for a spot where this range will fit.
        //
        while (TRUE) {
            //
            // Start at the end of the conflicting range.
            //
            ullStart = pRange->RL_End + 1;

            //
            // Check for wrapping.
            //
            if (!ullStart) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Make sure the alignment adjustment won't wrap.
            //
            if (ullStart + ullAlignment < ullStart) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Adjust the alignment.
            //
            ullStart += ullAlignment;
            ullStart &= ~ullAlignment;

            //
            // Compute the new end.
            //
            ullNewEnd = ullStart + ulLength - 1;

            //
            // Make sure the new end does not wrap and is still valid.
            //
            if ((ullNewEnd < ullStart) | (ullStart + ulLength - 1 > ullEnd))  {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Skip any prls which existed only below our new range
            // (because we moved ulStart upward of them).
            //
            while ((pRange = (PRange_Element)pRange->RL_Next) != NULL &&
                   ullStart > pRange->RL_End) {
            }

            //
            // If we don't have a prl or it's begining is after our end
            //
            if (pRange == NULL || ullNewEnd < pRange->RL_Start) {
                *pullStart = ullStart;
                goto Clean0;
            }

            //
            // Otherwise try with the new prl.
            //
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Find_Range



CONFIGRET
CM_First_Range(
    IN  RANGE_LIST     rlh,
    OUT PDWORDLONG     pullStart,
    OUT PDWORDLONG     pullEnd,
    OUT PRANGE_ELEMENT preElement,
    IN  ULONG          ulFlags
    )

/*++

Routine Description:

   This routine retrieves the first range element in a range list.

Parameters:

   rlh         Supplies the handle of a range list.

   pullStart   Supplies the address of a variable that receives the
               starting value of the first range element.

   pullEnd     Supplies the address of a variable that receives the
               ending value of the first range element.

   preElement  Supplies the address of a variable that receives the
               handle of the next range element.

   ulFlags     Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_INVALID_RANGE_LIST.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRange = NULL;
    BOOL           bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (pullEnd == NULL  ||  pullStart == NULL  ||  preElement == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        pRange = (PRange_Element)rlh;

        //
        // is the range list empty?
        //
        if (pRange->RL_Next == 0) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // skip over the header to the first element
        //
        pRange = (PRange_Element)pRange->RL_Next;

        *pullStart = pRange->RL_Start;
        *pullEnd = pRange->RL_End;
        *preElement = (RANGE_ELEMENT)pRange->RL_Next;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_First_Range



CONFIGRET
CM_Free_Range_List(
    IN RANGE_LIST rlh,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine frees the specified range list and the memory allocated
   for it.

Parameters:

   rlh      Supplies the handle of the range list to be freed.

   ulFlags  Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST.

--*/

{
    CONFIGRET      Status = CR_SUCCESS, Status1 = CR_SUCCESS;
    BOOL           bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        while (Status1 == CR_SUCCESS) {
            //
            // keep deleting the first range after the header (pass parent
            // of range to delete)
            //
            Status1 = DeleteRange((PRange_Element)rlh);
        }

        //
        // destroy the private resource lock
        //
        DestroyPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);

        //
        // delete the range header
        //
        ((PRange_List_Hdr)rlh)->RLH_Signature = 0;
        pSetupFree((PRange_Element)rlh);
        bLock = FALSE;


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Free_Range_List




CONFIGRET
CM_Intersect_Range_List(
    IN RANGE_LIST rlhOld1,
    IN RANGE_LIST rlhOld2,
    IN RANGE_LIST rlhNew,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine creates a range list from the intersection of two specified
   range lists. If this API returns CR_OUT_OF_MEMORY, rlhNew is the handle
   of a valid but empty range list.

Parameters:

   rlhOld1  Supplies the handle of a range list to be used as part of the
            intersection.

   rlhOld2  Supplies the handle of a range list to be used as part of the
            intersection.

   rlhNew   Supplies the handle of the range list that receives the
            intersection of rlhOld1 and rlhOld2.  Anything previously contained
            in the rlhNew ragne list is removed by this operation.

   ulFlags  Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    DWORDLONG      ulStart = 0, ulEnd = 0;
    PRange_Element pRangeNew = NULL, pRangeOld1 = NULL, pRangeOld2 = NULL;
    BOOL           bLock1 = FALSE, bLock2 = FALSE, bLockNew = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlhOld1)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhOld2)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhNew)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlhOld1)->RLH_Lock);
        bLock1 = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhOld2)->RLH_Lock);
        bLock2 = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
        bLockNew = TRUE;

        pRangeNew = (PRange_Element)rlhNew;
        pRangeOld1 = (PRange_Element)rlhOld1;
        pRangeOld2 = (PRange_Element)rlhOld2;

        //
        // If the new range list is not empty, then delete ranges
        //
        if (pRangeNew->RL_Next != 0) {
            ClearRanges(pRangeNew);
        }

        //
        // Special case: if either range is empty then there is no
        // intersection by definition
        //
        if (pRangeOld1->RL_Next == 0  || pRangeOld2->RL_Next == 0) {
            goto Clean0;
        }


        pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
        pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;

        while (TRUE) {
            //
            // skip over Old2 ranges until intersects with or exceeds
            // current Old1 range (or no more Old2 ranges left)
            //
            while (pRangeOld2->RL_End < pRangeOld1->RL_Start) {

                if (pRangeOld2->RL_Next == 0) {
                    goto Clean0;      // Old2 exhausted, we're done
                }
                pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
            }

            //
            // if this Old2 range exceeds Old1 range, then go to the
            // next Old1 range and go through the main loop again
            //
            if (pRangeOld2->RL_Start > pRangeOld1->RL_End) {

                if (pRangeOld1->RL_Next == 0) {
                    goto Clean0;      // Old1 exhausted, we're done
                }
                pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
                continue;
            }

            //
            // if we got here there must be an intersection so add
            // the intersected range to New
            //
            ulStart = max(pRangeOld1->RL_Start, pRangeOld2->RL_Start);
            ulEnd   = min(pRangeOld1->RL_End, pRangeOld2->RL_End);

            Status = InsertRange(pRangeNew, ulStart, ulEnd);
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
            pRangeNew = (PRange_Element)pRangeNew->RL_Next;

            //
            // after handling the intersection, skip to next ranges in
            // Old1 and Old2 as appropriate
            //
            if (pRangeOld1->RL_End <= ulEnd) {
                if (pRangeOld1->RL_Next == 0) {
                    goto Clean0;         // Old1 exhausted, we're done
                }
                pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
            }

            if (pRangeOld2->RL_End <= ulEnd) {
                if (pRangeOld2->RL_Next == 0) {
                    goto Clean0;         // Old1 exhausted, we're done
                }
                pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock1 = bLock1;     // needed to prevent optimizing this flag away
        bLock2 = bLock2;     // needed to prevent optimizing this flag away
        bLockNew = bLockNew; // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLock1) {
         UnlockPrivateResource(&((PRange_List_Hdr)rlhOld1)->RLH_Lock);
    }
    if (bLock2) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld2)->RLH_Lock);
    }
    if (bLockNew) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
    }

    return Status;

} // CM_Intersect_Range_List



CONFIGRET
CM_Invert_Range_List(
    IN RANGE_LIST rlhOld,
    IN RANGE_LIST rlhNew,
    IN DWORDLONG  ullMaxValue,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine creates a range list that is the inverse of a specified
   range list; all claimed ranges in the new list are specified as free
   in the old list, and vice-versa. For example, the inversion of
   {[2,4],[6,8]} when the ulMaxValue parameter is 15 is {[0,1],[5,5],[9,15]}.
   If this API returns CR_OUT_OF_MEMORY, rlhNew is the handle of a valid
   but empty range list.


Parameters:

   rlhOld      Supplies the handle of a range list to be inverted.

   rlhNew      Supplies the handle of the range list that receives the
               inverted copy of rlhOld.  Anything previously contained in
               the rlhNew range list is removed by this operation.

   ullMaxValue Uppermost value of the inverted range list.

   ulFlags     Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST,
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRangeNew = NULL, pRangeOld = NULL;
    DWORDLONG      ullStart = 0, ullEnd = 0;
    BOOL           bLockOld = FALSE, bLockNew = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlhOld)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhNew)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlhOld)->RLH_Lock);
        bLockOld = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
        bLockNew = TRUE;

        pRangeNew = (PRange_Element)rlhNew;
        pRangeOld = (PRange_Element)rlhOld;

        //
        // If the new range list is not empty, then delete ranges
        //
        if (pRangeNew->RL_Next != 0) {
            ClearRanges(pRangeNew);
        }

        //
        // special case: if the old range is empty, then the new range
        // is the entire range (up to max)
        //
        if (pRangeOld->RL_Next == 0) {
            Status = InsertRange(pRangeNew, 0, ullMaxValue);
            goto Clean0;
        }


        //
        // invert each of the old ranges
        //
        ullStart = ullEnd = 0;

        while (pRangeOld->RL_Next != 0) {

            pRangeOld = (PRange_Element)pRangeOld->RL_Next;

            //
            // Special start case: if range starts at 0, skip over it
            //
            if (pRangeOld->RL_Start != 0) {

                //
                // Special end case: check if we've hit the max for the new range
                //
                if (pRangeOld->RL_End >= ullMaxValue) {

                    ullEnd = min(ullMaxValue, pRangeOld->RL_Start - 1);
                    Status = InsertRange(pRangeNew, ullStart, ullEnd);
                    goto Clean0;      // we're done
                }

                Status = InsertRange(pRangeNew, ullStart, pRangeOld->RL_Start - 1);
                if (Status != CR_SUCCESS) {
                    goto Clean0;
                }

                pRangeNew = (PRange_Element)pRangeNew->RL_Next;
            }

            ullStart = pRangeOld->RL_End + 1;
        }

        //
        // add the range that incorporates the end of the old range up to
        // the max value specified
        //
        if (ullStart <= ullMaxValue) {
            Status = InsertRange(pRangeNew, ullStart, ullMaxValue);
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLockOld = bLockOld;    // needed to prevent optimizing this flag away
        bLockNew = bLockNew;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLockOld) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld)->RLH_Lock);
    }
    if (bLockNew) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
    }

    return Status;

} // CM_Invert_Range_List



CONFIGRET
CM_Merge_Range_List(
    IN RANGE_LIST rlhOld1,
    IN RANGE_LIST rlhOld2,
    IN RANGE_LIST rlhNew,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine creates a range list from the union of two specified range
   lists. If this API returns CR_OUT_OF_MEMORY, rlhNew is the handle of a
   valid but empty range list.

Parameters:

   rlhOld1  Supplies the handle of a range list to be used as part of the
            union.

   rlhOld2  Supplies the handle of a range list to be used as part of the
            union.

   rlhNew   Supplies the handle of the range list that receives the union
            of rlhOld1 and rlhOld2.  Anything previously contained in the
            rlhNew range list is removed by this operation.

   ulFlags  Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_RANGE_LIST, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    DWORDLONG      ullStart = 0, ullEnd = 0;
    BOOL           bOld1Empty = FALSE, bOld2Empty = FALSE;
    PRange_Element pRangeNew = NULL, pRangeOld1 = NULL, pRangeOld2 = NULL;
    BOOL           bLock1 = FALSE, bLock2 = FALSE, bLockNew = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlhOld1)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhOld2)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (!IsValidRangeList(rlhNew)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlhOld1)->RLH_Lock);
        bLock1 = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhOld2)->RLH_Lock);
        bLock2 = TRUE;

        LockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
        bLockNew = TRUE;

        pRangeNew = (PRange_Element)rlhNew;
        pRangeOld1 = (PRange_Element)rlhOld1;
        pRangeOld2 = (PRange_Element)rlhOld2;

        //
        // If the new range list is not empty, then clear it
        //
        if (pRangeNew->RL_Next != 0) {
            ClearRanges(pRangeNew);
        }

        //
        // Special case: if both ranges are empty then there is no
        // union by definition
        //
        if (pRangeOld1->RL_Next == 0  &&  pRangeOld2->RL_Next == 0) {
            goto Clean0;
        }

        //
        // Special case: if one range is empty, then the union is just the other
        //
        if (pRangeOld1->RL_Next == 0) {
            pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
            CopyRanges(pRangeOld2, pRangeNew);     // from -> to
            goto Clean0;
        }

        if (pRangeOld2->RL_Next == 0) {
            pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
            CopyRanges(pRangeOld1, pRangeNew);     // from -> to
            goto Clean0;
        }


        pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
        pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;


        while (TRUE) {
            //
            // Pick whichever range comes first between current Old1 range
            // and current Old2 range
            //
            if (pRangeOld1->RL_Start <= pRangeOld2->RL_Start) {

                ullStart = pRangeOld1->RL_Start;
                ullEnd   = pRangeOld1->RL_End;

                if (pRangeOld1->RL_Next == 0) {
                    bOld1Empty = TRUE;
                } else {
                    pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
                }

            } else {

                ullStart = pRangeOld2->RL_Start;
                ullEnd   = pRangeOld2->RL_End;

                if (pRangeOld2->RL_Next == 0) {
                    bOld2Empty = TRUE;
                } else {
                    pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
                }
            }

            //
            // gather any ranges in Old1 that intersect (ullStart,ullEnd)
            //
            while (pRangeOld1->RL_Start <= ullEnd) {

                ullEnd = max(ullEnd, pRangeOld1->RL_End);

                if (pRangeOld1->RL_Next == 0) {
                    bOld1Empty = TRUE;
                    break;
                }
                pRangeOld1 = (PRange_Element)pRangeOld1->RL_Next;
            }

            //
            // gather any ranges in Old2 that intersect (ullStart,ullEnd)
            //
            while (pRangeOld2->RL_Start <= ullEnd) {

                ullEnd = max(ullEnd, pRangeOld2->RL_End);

                if (pRangeOld2->RL_Next == 0) {
                    bOld2Empty = TRUE;
                    break;
                }
                pRangeOld2 = (PRange_Element)pRangeOld2->RL_Next;
            }

            //
            // add (ullStart,ullEnd) to the new range
            //
            Status = InsertRange(pRangeNew, ullStart, ullEnd);
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
            pRangeNew = (PRange_Element)pRangeNew->RL_Next;

            //
            // As an optimization, if either range is exhausted first,
            // then only need to duplicate the other remaining ranges.
            //
            if (bOld1Empty && bOld2Empty) {
                goto Clean0;   // both exhausted during last pass, we're done
            }

            if (bOld1Empty) {    // Old1 exhausted, copy remaining from Old2
                CopyRanges(pRangeOld2, pRangeNew);
                goto Clean0;
            }

            if (bOld2Empty) {    // Old2 exhausted, copy remaining from Old1
                CopyRanges(pRangeOld1, pRangeNew);
                goto Clean0;
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock1 = bLock1;     // needed to prevent optimizing this flag away
        bLock2 = bLock2;     // needed to prevent optimizing this flag away
        bLockNew = bLockNew; // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }


    if (bLock1) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld1)->RLH_Lock);
    }
    if (bLock2) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhOld2)->RLH_Lock);
    }
    if (bLockNew) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlhNew)->RLH_Lock);
    }

    return Status;

} // CM_Merge_Range_List



CONFIGRET
CM_Next_Range(
    IN OUT PRANGE_ELEMENT preElement,
    OUT PDWORDLONG        pullStart,
    OUT PDWORDLONG        pullEnd,
    IN  ULONG             ulFlags
    )

/*++

Routine Description:

    This routine returns the next range element in a range list. This
    API returns CR_FAILURE if there are no more elements in the range
    list.

Parameters:

   preElement  Supplies the address of the handle for the current range
               element.  Upon return, this variable receives the handle
               of the next range element.

   pullStart   Supplies the address of the variable that receives the
               starting value of the next range.

   pullEnd     Supplies the address of the variable that receives the
               ending value of the next range.

   ulFlags     Must be zero.


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_INVALID_RANGE.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRange = NULL;
    BOOL           bLock = FALSE;
    PRange_List_Hdr prlh = NULL;


    try {
        //
        // validate parameters
        //
        if (preElement == NULL  ||  *preElement == 0) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (pullEnd == NULL  ||  pullStart == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        prlh = (PRange_List_Hdr)((PRange_Element)(*preElement))->RL_Header;
        LockPrivateResource(&(prlh->RLH_Lock));
        bLock = TRUE;

        pRange = (PRange_Element)(*preElement);

        *pullStart = pRange->RL_Start;
        *pullEnd = pRange->RL_End;
        *preElement = (RANGE_ELEMENT)pRange->RL_Next;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&(prlh->RLH_Lock));
    }

    return Status;

} // CM_Next_Range



CONFIGRET
CM_Test_Range_Available(
    IN DWORDLONG  ullStartValue,
    IN DWORDLONG  ullEndValue,
    IN RANGE_LIST rlh,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

   This routine checks a range against a range list to ensure that no
   conflicts exist.

Parameters:

   ullStartValue  Supplies the low end of the range.

   ullEndValue    Supplies the high end of the range.

   rlh            Supplies the handle to a range list.

   ulFlags        Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_FAILURE,
         CR_INVALID_FLAG,
         CR_INVALID_RANGE, or
         CR_INVALID_RANGE_LIST.

--*/

{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pRange = NULL;
    BOOL           bLock = FALSE;

    try {
        //
        // validate parameters
        //
        if (!IsValidRangeList(rlh)) {
            Status = CR_INVALID_RANGE_LIST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ullEndValue < ullStartValue) {
            Status = CR_INVALID_RANGE;
            goto Clean0;
        }

        LockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
        bLock = TRUE;

        pRange = (PRange_Element)rlh;

        //
        // check each range for a conflict
        //
        while (pRange->RL_Next != 0) {

            pRange = (PRange_Element)pRange->RL_Next;

            //
            // If I've already passed the test range, then it's available
            //
            if (ullEndValue < pRange->RL_Start) {
                goto Clean0;
            }

            //
            // check if the start of the test range intersects the current range
            //
            if (ullStartValue >= pRange->RL_Start &&
                ullStartValue <= pRange->RL_End) {

                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // check if the end of the test range intersects the current range
            //
            if (ullEndValue >= pRange->RL_Start &&
               ullEndValue <= pRange->RL_End) {

                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // check if it's a complete overlap
            //
            if (ullStartValue <= pRange->RL_Start &&
               ullEndValue >= pRange->RL_End) {

                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        //
        // if we got this far, then we made it through the range list
        // without hitting a conflict
        //

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bLock = bLock;    // needed to prevent optimizing this flag away
        Status = CR_FAILURE;
    }

    if (bLock) {
        UnlockPrivateResource(&((PRange_List_Hdr)rlh)->RLH_Lock);
    }

    return Status;

} // CM_Test_Range_Available




//------------------------------------------------------------------------
// Private Utility Functions
//------------------------------------------------------------------------


BOOL
IsValidRangeList(
    IN RANGE_LIST rlh
    )
{
   BOOL             Status = TRUE;
   PRange_List_Hdr  pRangeHdr = NULL;

    try {

        if (rlh == 0  || rlh == (DWORD)-1) {
            return FALSE;
        }

        pRangeHdr = (PRange_List_Hdr)rlh;

        if (pRangeHdr->RLH_Signature != Range_List_Signature) {
            Status = FALSE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

} // IsValidRangeList




CONFIGRET
AddRange(
    IN PRange_Element   prlh,
    IN DWORDLONG        ullStartValue,
    IN DWORDLONG        ullEndValue,
    IN ULONG            ulFlags
    )
{
    CONFIGRET      Status = CR_SUCCESS;
    PRange_Element pPrevious = NULL, pCurrent = NULL;


    try {

        pPrevious = prlh;

        if (pPrevious->RL_Next == 0) {
            //
            // the range is empty
            //
            Status = InsertRange(pPrevious, ullStartValue, ullEndValue);
            goto Clean0;
        }


        while (pPrevious->RL_Next != 0) {

            pCurrent = (PRange_Element)pPrevious->RL_Next;


            if (ullStartValue < pCurrent->RL_Start) {

                if (ullEndValue < pCurrent->RL_Start) {
                    //
                    // new range completely contained before this one,
                    // add new range between previous and current range
                    //
                    Status = InsertRange(pPrevious, ullStartValue, ullEndValue);
                    goto Clean0;
                }

                if (ullEndValue <= pCurrent->RL_End) {
                    //
                    // new range intersects current range, on the low side,
                    // enlarge this range to include the new range
                    //
                    if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    pCurrent->RL_Start = ullStartValue;
                    goto Clean0;
                }

                if ((pCurrent->RL_Next == 0)  ||
                    (ullEndValue < ((PRange_Element)(pCurrent->RL_Next))->RL_Start)) {
                    //
                    // new range intersects current range on high and low
                    // side, extent range to include the new range
                    //
                    if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    pCurrent->RL_Start = ullStartValue;
                    pCurrent->RL_End = ullEndValue;
                    goto Clean0;
                }

                //
                // new range intersects more than one range, needs to be
                // merged
                //
                if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                Status = JoinRange(pPrevious, ullStartValue, ullEndValue);
                goto Clean0;
            }


            if (ullStartValue <= pCurrent->RL_End+1) {

                if (ullEndValue <= pCurrent->RL_End) {
                    //
                    // new range is completely contained inside the current
                    // range so nothing to do
                    //
                    if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    goto Clean0;
                }

                if ((pCurrent->RL_Next == 0)  ||
                    (ullEndValue < ((PRange_Element)(pCurrent->RL_Next))->RL_Start)) {
                    //
                    // new range intersects current range on high end only,
                    // extend range to include the new range
                    //
                    if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                    pCurrent->RL_End = ullEndValue;
                    goto Clean0;
                }

                //
                // new range intersects more than one range, needs to be
                // merged
                //
                if (ulFlags == CM_ADD_RANGE_DONOTADDIFCONFLICT) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                Status = JoinRange(pPrevious, ullStartValue, ullEndValue);
                goto Clean0;
            }

            //
            // step to the next range
            //
            pPrevious = pCurrent;
            pCurrent = (PRange_Element)pCurrent->RL_Next;
        }

        //
        // if we got here then we need to just insert this range to the end
        // of the range list
        //
        Status = InsertRange(pPrevious, ullStartValue, ullEndValue);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = 0;
    }

    return Status;

} // AddRange



CONFIGRET
InsertRange(
    IN PRange_Element pParentElement,
    IN DWORDLONG      ullStartValue,
    IN DWORDLONG      ullEndValue)
{
    PRange_Element  pNewElement = NULL;


    pNewElement = (PRange_Element)pSetupMalloc(sizeof(Range_Element));

    if (pNewElement == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    pNewElement->RL_Next   = pParentElement->RL_Next;   // rejoin the link
    pNewElement->RL_Start  = ullStartValue;
    pNewElement->RL_End    = ullEndValue;
    pNewElement->RL_Header = pParentElement->RL_Header;
    pParentElement->RL_Next = (ULONG_PTR)pNewElement;

    return CR_SUCCESS;

} // InsertRange



CONFIGRET
DeleteRange(
    IN PRange_Element  pParentElement
    )
{
    PRange_Element pTemp = NULL;

    //
    // must pass a valid parent of the range to delete (in otherwords,
    // can't pass the last range)
    //

    if (pParentElement == 0) {
        return CR_FAILURE;
    }

    pTemp = (PRange_Element)(pParentElement->RL_Next);
    if (pTemp == 0) {
        return CR_FAILURE;
    }

    pParentElement->RL_Next =
                ((PRange_Element)(pParentElement->RL_Next))->RL_Next;

    pSetupFree(pTemp);

    return CR_SUCCESS;

} // DeleteRange



CONFIGRET
JoinRange(
    IN PRange_Element  pParentElement,
    IN DWORDLONG       ullStartValue,
    IN DWORDLONG       ullEndValue
    )
{
    CONFIGRET       Status = CR_SUCCESS;
    PRange_Element  pCurrent = NULL, pNext = NULL;


    if (pParentElement->RL_Next == 0) {
        return CR_SUCCESS;      // at the end, nothing to join
    }

    //
    // pCurrent is the starting range of intersecting ranges that need
    // to be joined
    //
    pCurrent = (PRange_Element)pParentElement->RL_Next;

    //
    // set start of joined range
    //
    if (ullStartValue < pCurrent->RL_Start) {
        pCurrent->RL_Start = ullStartValue;
    }

    //
    // find the end of the joined range
    //
    while (pCurrent->RL_Next != 0) {
        pNext = (PRange_Element)pCurrent->RL_Next;

        //
        // I know this next range needs to be absorbed in all cases so
        // reset the end point to at least include the next range
        //
        pCurrent->RL_End = pNext->RL_End;

        if (ullEndValue <= pNext->RL_End) {
            DeleteRange(pCurrent);     // delete the range following current
            break;   // we're done
        }

        if ((pNext->RL_Next == 0)  ||
            (ullEndValue < ((PRange_Element)(pNext->RL_Next))->RL_Start)) {
            //
            // adjust the end point of the newly joined range and then we're done
            //
            pCurrent->RL_End = ullEndValue;
            DeleteRange(pCurrent);     // delete the range following current
            break;
        }

        DeleteRange(pCurrent);     // delete the range following current

        // if we got here, there are more ranges to join
    }

    return Status;

} // JoinRange



CONFIGRET
CopyRanges(
    IN PRange_Element  pFromRange,
    IN PRange_Element  pToRange
    )
{
    CONFIGRET       Status = CR_SUCCESS;

    //
    // copy each range in pFromRange to pToRange
    //
    while (TRUE) {

        Status = AddRange(pToRange,
                          pFromRange->RL_Start,
                          pFromRange->RL_End,
                          CM_ADD_RANGE_ADDIFCONFLICT);

        if (Status != CR_SUCCESS) {
            break;
        }

        pToRange = (PRange_Element)pToRange->RL_Next;

        if (pFromRange->RL_Next == 0) {
            break;
        }

        pFromRange = (PRange_Element)pFromRange->RL_Next;
    }

    return Status;

} // CopyRanges



CONFIGRET
ClearRanges(
    IN PRange_Element  pRange
    )
{
    CONFIGRET       Status = CR_SUCCESS;

    //
    // If the range list is not empty, then delete ranges
    //
    if (pRange->RL_Next != 0) {

        while (Status == CR_SUCCESS) {
            //
            // keep deleting the first range after the header (pass parent
            // of range to delete)
            //
            Status = DeleteRange(pRange);
        }
    }

    return CR_SUCCESS;  // Status is set to end deleting ranges, don't return it

} // ClearRanges



CONFIGRET
TestRange(
    IN  PRange_Element   rlh,
    IN  DWORDLONG        ullStartValue,
    IN  DWORDLONG        ullEndValue,
    OUT PRange_Element   *pConflictingRange
    )

{
    PRange_Element    pRange = (PRange_Element)rlh;

    //
    // check each range for a conflict
    //
    while (pRange->RL_Next != 0) {

        pRange = (PRange_Element)pRange->RL_Next;

        if (pRange->RL_Start > ullEndValue) {
            //
            // We've gone past the range in question so no conflict
            //
            return CR_SUCCESS;
        }

        if (pRange->RL_End < ullStartValue) {
            //
            // this range is still below the range in question, skip to next range
            //
            continue;
        }

        //
        // otherwise there's a conflict
        //
        *pConflictingRange = pRange;
        return CR_FAILURE;
    }

    return CR_SUCCESS;

} // TestRange
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\regprop.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    regprop.c

Abstract:

    This module contains the API routines that reg and set registry
    properties and operates on classes.

                  CM_Get_DevNode_Registry_Property
                  CM_Set_DevNode_Registry_Property
                  CM_Get_Class_Registry_Property
                  CM_Set_Class_Registry_Property
                  CM_Open_DevNode_Key
                  CM_Delete_DevNode_Key
                  CM_Open_Class_Key
                  CM_Enumerate_Classes
                  CM_Get_Class_Name
                  CM_Get_Class_Key_Name
                  CM_Delete_Class_Key
                  CM_Get_Device_Interface_Alias
                  CM_Get_Device_Interface_List
                  CM_Get_Device_Interface_List_Size
                  CM_Register_Device_Interface
                  CM_Unregister_Device_Interface

Author:

    Paula Tomlinson (paulat) 6-22-1995

Environment:

    User mode only.

Revision History:

    22-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"
#include "cmdat.h"

//
// Private prototypes
//

ULONG
GetPropertyDataType(
    IN ULONG ulProperty
    );

//
// use these from SetupAPI
//
PSECURITY_DESCRIPTOR
pSetupConvertTextToSD(
    IN PCWSTR SDS,
    OUT PULONG SecDescSize
    );

PWSTR
pSetupConvertSDToText(
    IN PSECURITY_DESCRIPTOR SD,
    OUT PULONG pSDSSize
    );


//
// global data
//
extern PVOID    hLocalBindingHandle;   // NOT MODIFIED BY THESE PROCEDURES



CONFIGRET
CM_Get_DevNode_Registry_Property_ExW(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the specified value from the device instance's
   registry storage key.

Parameters:

   dnDevInst   Supplies the handle of the device instance for which a
               property is to be retrieved.

   ulProperty  Supplies an ordinal specifying the property to be retrieved.
               (CM_DRP_*)

   pulRegDataType Optionally, supplies the address of a variable that
                  will receive the registry data type for this property
                  (i.e., the REG_* constants).

   Buffer      Supplies the address of the buffer that receives the
               registry data.  Can be NULL when simply retrieving data size.

   pulLength   Supplies the address of the variable that contains the size,
               in bytes, of the buffer.  The API replaces the initial size
               with the number of bytes of registry data copied to the buffer.
               If the variable is initially zero, the API replaces it with
               the buffer size needed to receive all the registry data.  In
               this case, the Buffer parameter is ignored.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVINST,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulSizeID = MAX_DEVICE_ID_LEN;
    ULONG       ulTempDataType=0, ulTransferLen=0;
    ULONG       ulGetProperty = ulProperty;
    BYTE        NullBuffer=0;
    handle_t    hBinding = NULL;
    PVOID       hStringTable = NULL;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ulProperty < CM_DRP_MIN || ulProperty > CM_DRP_MAX) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        if (ulProperty == CM_DRP_SECURITY_SDS) {
            //
            // translates operation
            //
            LPVOID tmpBuffer = NULL;
            ULONG tmpBufferSize = 0;
            ULONG datatype;
            LPWSTR sds = NULL;

            ulTempDataType = REG_SZ;

            try {
                Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                              CM_DRP_SECURITY,
                                                              &datatype,
                                                              NULL,
                                                              &tmpBufferSize,
                                                              ulFlags,
                                                              hMachine);
                if (Status != CR_SUCCESS && Status != CR_BUFFER_SMALL) {
                    leave;
                }
                tmpBuffer = pSetupMalloc(tmpBufferSize);
                if (tmpBuffer == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    leave;
                }
                Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                              CM_DRP_SECURITY,
                                                              &datatype,
                                                              tmpBuffer,
                                                              &tmpBufferSize,
                                                              ulFlags,
                                                              hMachine);
                if (Status != CR_SUCCESS) {
                    leave;
                }

                //
                // now translate
                //
                sds = pSetupConvertSDToText((PSECURITY_DESCRIPTOR)tmpBuffer,NULL);
                if (sds == NULL) {
                    Status = CR_FAILURE;
                    leave;
                }
                ulTransferLen = (lstrlen(sds)+1) * sizeof(WCHAR); // required size
                if (*pulLength == 0 || Buffer == NULL || *pulLength < ulTransferLen) {
                    //
                    // buffer too small, or buffer size wanted
                    // required buffer size
                    //
                    Status = CR_BUFFER_SMALL;
                    *pulLength = ulTransferLen;
                    ulTransferLen = 0;
                } else {
                    //
                    // copy data
                    //
                    memcpy(Buffer,sds,ulTransferLen);
                    *pulLength = ulTransferLen;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = CR_FAILURE;
            }
            if (tmpBuffer != NULL) {
                pSetupFree(tmpBuffer);
            }
            if (sds != NULL) {
                //
                // must use LocalFree
                //
                LocalFree(sds);
            }
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
        } else {
            //
            // setup rpc binding handle and string table handle
            //
            if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // retrieve the string form of the device id string
            //
            Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulSizeID);
            if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
                Status = CR_INVALID_DEVINST;
                goto Clean0;
            }

            //
            // NOTE: The ulTransferLen variable is just used to control
            // how much data is marshalled via rpc between address spaces.
            // ulTransferLen should be set on entry to the size of the Buffer.
            // The last parameter should also be the size of the Buffer on entry
            // and on exit contains either the amount transferred (if a transfer
            // occured) or the amount required, this value should be passed back
            // in the callers pulLength parameter.
            //
            ulTransferLen = *pulLength;
            if (Buffer == NULL) {
                Buffer = &NullBuffer;
            }

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetDeviceRegProp(
                    hBinding,               // rpc binding handle
                    pDeviceID,              // string representation of device instance
                    ulGetProperty,          // id for the property
                    &ulTempDataType,        // receives registry data type
                    Buffer,                 // receives registry data
                    &ulTransferLen,         // input/output buffer size
                    pulLength,              // bytes copied (or bytes required)
                    ulFlags);               // not used
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_GetDeviceRegProp caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept
        }

        if (pulRegDataType != NULL) {
            //
            // I pass a temp variable to the rpc stubs since they require the
            // output param to always be valid, then if user did pass in a valid
            // pointer to receive the info, do the assignment now
            //
            *pulRegDataType = ulTempDataType;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_DevNode_Registry_Property_ExW



CONFIGRET
CM_Set_DevNode_Registry_Property_ExW(
    IN DEVINST     dnDevInst,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer               OPTIONAL,
    IN OUT ULONG   ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine sets the specified value in the device instance's registry
   storage key.

Parameters:

   dnDevInst      Supplies the handle of the device instance for which a
                  property is to be retrieved.

   ulProperty     Supplies an ordinal specifying the property to be set.
                  (CM_DRP_*)

   Buffer         Supplies the address of the buffer that contains the
                  registry data.  This data must be of the proper type
                  for that property.

   ulLength       Supplies the number of bytes of registry data to write.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR,
      CR_OUT_OF_MEMORY,
      CR_INVALID_DATA, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulRegDataType = 0, ulLen = MAX_DEVICE_ID_LEN;
    BYTE        NullBuffer = 0x0;
    handle_t    hBinding = NULL;
    PVOID       hStringTable = NULL;
    BOOL        Success;
    PVOID       Buffer2 = NULL;
    PVOID       Buffer3 = NULL;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (ulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ulProperty < CM_DRP_MIN || ulProperty > CM_DRP_MAX) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the string form of the device id string
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // we need to specify what registry data to use for storing this data
        //
        ulRegDataType = GetPropertyDataType(ulProperty);

        //
        // if data type is REG_DWORD, make sure size is right
        //
        if((ulRegDataType == REG_DWORD) && ulLength && (ulLength != sizeof(DWORD))) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // if the register is CM_DRP_SECURITY_SDS, convert it
        //
        if (ulProperty == CM_DRP_SECURITY_SDS) {
            if (ulLength) {
                //
                // this form of CM_DRP_SECURITY provides a string that needs to be converted to binary
                //
                PCWSTR UnicodeSecDesc = (PCWSTR)Buffer;

                Buffer2 = pSetupConvertTextToSD(UnicodeSecDesc,&ulLength);
                if (Buffer2 == NULL) {
                    //
                    // If last error is ERROR_SCE_DISABLED, then the failure is
                    // due to SCE APIs being "turned off" on Embedded.  Treat
                    // this as a (successful) no-op...
                    //
                    if(GetLastError() == ERROR_SCE_DISABLED) {
                        Status = CR_SUCCESS;
                    } else {
                        Status = CR_INVALID_DATA;
                    }
                    goto Clean0;
                }
                Buffer = Buffer2;
            }
            ulProperty = CM_DRP_SECURITY;
            ulRegDataType = REG_BINARY;
        }

        //
        // if data type is REG_MULTI_SZ, make sure it is double-NULL terminated
        //
        if ((ulRegDataType == REG_MULTI_SZ) && (ulLength != 0)) {

            ULONG ulNewLength;
            PWSTR tmpBuffer, bufferEnd;

            ulLength &= ~(ULONG)1;
            tmpBuffer = (PWSTR)Buffer;
            bufferEnd = (PWSTR)((PUCHAR)tmpBuffer + ulLength);
            ulNewLength = ulLength;
            while (tmpBuffer < bufferEnd && *tmpBuffer != TEXT('\0')) {

                while (tmpBuffer < bufferEnd && *tmpBuffer != TEXT('\0')) {

                    tmpBuffer++;
                }
                if (tmpBuffer >= bufferEnd) {

                    ulNewLength += sizeof(TEXT('\0'));;
                } else {

                    tmpBuffer++;
                }
            }
            if (tmpBuffer >= bufferEnd) {

                ulNewLength += sizeof(TEXT('\0'));;
            } else {

                ulNewLength = ((ULONG)(tmpBuffer - (PWSTR)Buffer) + 1) * sizeof(WCHAR);
            }
            if (ulNewLength > ulLength) {

                Buffer3 = pSetupMalloc(ulNewLength);
                if (Buffer3 == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                memcpy(Buffer3, Buffer, ulLength);
                memset((PUCHAR)Buffer3 + ulLength, 0, ulNewLength - ulLength);
                Buffer = Buffer3;
            }
            ulLength = ulNewLength;
        }

        if (Buffer == NULL) {
            Buffer = &NullBuffer;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_SetDeviceRegProp(
                hBinding,               // rpc binding handle
                pDeviceID,              // string representation of devinst
                ulProperty,             // string name for property
                ulRegDataType,          // specify registry data type
                (LPBYTE)Buffer,         // receives registry data
                ulLength,               // amount to return in Buffer
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_SetDeviceRegProp caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (Buffer3) {

        pSetupFree(Buffer3);
    }

    if (Buffer2) {
        //
        // SceSvc requires LocalFree
        //
        LocalFree(Buffer2);
    }

    return Status;

} // CM_Set_DevNode_Registry_Property_ExW



CONFIGRET
CM_Get_Class_Registry_PropertyW(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the specified value from the classes's
   registry storage key.

Parameters:

   ClassGUID   Supplies the Class GUID.

   ulProperty  Supplies an ordinal specifying the property to be retrieved.
               (CM_DRP_*)

   pulRegDataType Optionally, supplies the address of a variable that
                  will receive the registry data type for this property
                  (i.e., the REG_* constants).

   Buffer      Supplies the address of the buffer that receives the
               registry data.  Can be NULL when simply retrieving data size.

   pulLength   Supplies the address of the variable that contains the size,
               in bytes, of the buffer.  The API replaces the initial size
               with the number of bytes of registry data copied to the buffer.
               If the variable is initially zero, the API replaces it with
               the buffer size needed to receive all the registry data.  In
               this case, the Buffer parameter is ignored.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVINST,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulTempDataType=0, ulTransferLen=0;
    BYTE        NullBuffer=0;
    handle_t    hBinding = NULL;
    BOOL        Success;
    WCHAR       szStringGuid[MAX_GUID_STRING_LEN];
    ULONG       ulGetProperty = ulProperty;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(ClassGUID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(ClassGUID, szStringGuid,MAX_GUID_STRING_LEN) != NO_ERROR) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (ulProperty < CM_CRP_MIN || ulProperty > CM_CRP_MAX) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        if (ulProperty == CM_CRP_SECURITY_SDS) {
            //
            // translates operation
            //
            LPVOID tmpBuffer = NULL;
            ULONG tmpBufferSize = 0;
            ULONG datatype;
            LPWSTR sds = NULL;

            ulTempDataType = REG_SZ;

            try {
                Status = CM_Get_Class_Registry_PropertyW(ClassGUID,CM_CRP_SECURITY,&datatype,NULL,&tmpBufferSize,ulFlags,hMachine);
                if (Status != CR_SUCCESS && Status != CR_BUFFER_SMALL) {
                    leave;
                }
                tmpBuffer = pSetupMalloc(tmpBufferSize);
                if (tmpBuffer == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    leave;
                }
                Status = CM_Get_Class_Registry_PropertyW(ClassGUID,CM_CRP_SECURITY,&datatype,tmpBuffer,&tmpBufferSize,ulFlags,hMachine);
                if (Status != CR_SUCCESS) {
                    leave;
                }

                //
                // now translate
                //
                sds = pSetupConvertSDToText((PSECURITY_DESCRIPTOR)tmpBuffer,NULL);
                if (sds == NULL) {
                    Status = CR_FAILURE;
                    leave;
                }
                ulTransferLen = (lstrlen(sds)+1) * sizeof(WCHAR); // required size
                if (*pulLength == 0 || Buffer == NULL || *pulLength < ulTransferLen) {
                    //
                    // buffer too small, or buffer size wanted
                    // required buffer size
                    //
                    Status = CR_BUFFER_SMALL;
                    *pulLength = ulTransferLen;
                    ulTransferLen = 0;
                } else {
                    //
                    // copy data
                    //
                    memcpy(Buffer,sds,ulTransferLen);
                    *pulLength = ulTransferLen;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = CR_FAILURE;
            }
            if (tmpBuffer != NULL) {
                pSetupFree(tmpBuffer);
            }
            if (sds != NULL) {
                //
                // must use LocalFree
                //
                LocalFree(sds);
            }
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
        } else {

            //
            // setup rpc binding handle and string table handle
            //
            if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // NOTE: The ulTransferLen variable is just used to control
            // how much data is marshalled via rpc between address spaces.
            // ulTransferLen should be set on entry to the size of the Buffer.
            // The last parameter should also be the size of the Buffer on entry
            // and on exit contains either the amount transferred (if a transfer
            // occured) or the amount required, this value should be passed back
            // in the callers pulLength parameter.
            //
            ulTransferLen = *pulLength;
            if (Buffer == NULL) {
                Buffer = &NullBuffer;
            }

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetClassRegProp(
                    hBinding,               // rpc binding handle
                    szStringGuid,           // string representation of class
                    ulGetProperty,          // id for the property
                    &ulTempDataType,        // receives registry data type
                    Buffer,                 // receives registry data
                    &ulTransferLen,         // input/output buffer size
                    pulLength,              // bytes copied (or bytes required)
                    ulFlags);               // not used
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_GetClassRegProp caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept

        }

        if (pulRegDataType != NULL) {
            //
            // I pass a temp variable to the rpc stubs since they require the
            // output param to always be valid, then if user did pass in a valid
            // pointer to receive the info, do the assignment now
            //
            *pulRegDataType = ulTempDataType;
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Class_Registry_PropertyW



CONFIGRET
CM_Set_Class_Registry_PropertyW(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer               OPTIONAL,
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine sets the specified value in the device instance's registry
   storage key.

Parameters:

   ClassGUID      Supplies the Class GUID.

   ulProperty     Supplies an ordinal specifying the property to be set.
                  (CM_DRP_*)

   Buffer         Supplies the address of the buffer that contains the
                  registry data.  This data must be of the proper type
                  for that property.

   ulLength       Supplies the number of bytes of registry data to write.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_NO_SUCH_REGISTRY_KEY,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR,
      CR_OUT_OF_MEMORY,
      CR_INVALID_DATA, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulRegDataType = 0, ulLen = MAX_DEVICE_ID_LEN;
    BYTE        NullBuffer = 0x0;
    handle_t    hBinding = NULL;
    BOOL        Success;
    WCHAR       szStringGuid[MAX_GUID_STRING_LEN];
    PVOID       Buffer2 = NULL;
    PVOID       Buffer3 = NULL;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(ClassGUID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (ulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(ClassGUID, szStringGuid,MAX_GUID_STRING_LEN) != NO_ERROR) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (ulProperty < CM_CRP_MIN || ulProperty > CM_CRP_MAX) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // we need to specify what registry data to use for storing this data
        //
        ulRegDataType = GetPropertyDataType(ulProperty);

        //
        // if data type is REG_DWORD, make sure size is right
        //
        if((ulRegDataType == REG_DWORD) && ulLength && (ulLength != sizeof(DWORD))) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // if the register is CM_CRP_SECURITY_SDS, convert it
        //
        if (ulProperty == CM_CRP_SECURITY_SDS) {
            if (ulLength) {
                //
                // this form of CM_CRP_SECURITY provides a string that needs to be converted to binary
                //
                PCWSTR UnicodeSecDesc = (PCWSTR)Buffer;

                Buffer2 = pSetupConvertTextToSD(UnicodeSecDesc,&ulLength);
                if (Buffer2 == NULL) {
                    //
                    // If last error is ERROR_SCE_DISABLED, then the failure is
                    // due to SCE APIs being "turned off" on Embedded.  Treat
                    // this as a (successful) no-op...
                    //
                    if(GetLastError() == ERROR_SCE_DISABLED) {
                        Status = CR_SUCCESS;
                    } else {
                        Status = CR_INVALID_DATA;
                    }
                    goto Clean0;
                }
                Buffer = Buffer2;
            }
            ulProperty = CM_CRP_SECURITY;
            ulRegDataType = REG_BINARY;
        }

        //
        // if data type is REG_MULTI_SZ, make sure it is double-NULL terminated
        //
        if ((ulRegDataType == REG_MULTI_SZ) && (ulLength != 0)) {

            ULONG ulNewLength;
            PWSTR tmpBuffer, bufferEnd;

            ulLength &= ~(ULONG)1;
            tmpBuffer = (PWSTR)Buffer;
            bufferEnd = (PWSTR)((PUCHAR)tmpBuffer + ulLength);
            ulNewLength = ulLength;
            while (tmpBuffer < bufferEnd && *tmpBuffer != TEXT('\0')) {

                while (tmpBuffer < bufferEnd && *tmpBuffer != TEXT('\0')) {

                    tmpBuffer++;
                }
                if (tmpBuffer >= bufferEnd) {

                    ulNewLength += sizeof(TEXT('\0'));;
                } else {

                    tmpBuffer++;
                }
            }
            if (tmpBuffer >= bufferEnd) {

                ulNewLength += sizeof(TEXT('\0'));;
            } else {

                ulNewLength = ((ULONG)(tmpBuffer - (PWSTR)Buffer) + 1) * sizeof(WCHAR);
            }
            if (ulNewLength > ulLength) {

                Buffer3 = pSetupMalloc(ulNewLength);
                if (Buffer3 == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                memcpy(Buffer3, Buffer, ulLength);
                memset((PUCHAR)Buffer3 + ulLength, 0, ulNewLength - ulLength);
                Buffer = Buffer3;
            }
            ulLength = ulNewLength;
        }

        if (Buffer == NULL) {
            Buffer = &NullBuffer;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_SetClassRegProp(
                hBinding,               // rpc binding handle
                szStringGuid,           // string representation of class
                ulProperty,             // string name for property
                ulRegDataType,          // specify registry data type
                (LPBYTE)Buffer,         // receives registry data
                ulLength,               // amount to return in Buffer
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_SetClassRegProp caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (Buffer2) {
        //
        // SceSvc requires LocalFree
        //
        LocalFree(Buffer2);
    }

    if (Buffer3) {
        pSetupFree(Buffer3);
    }

    return Status;

} // CM_Set_Class_Registry_Property_ExW



CONFIGRET
CM_Open_DevNode_Key_Ex(
    IN  DEVINST        dnDevNode,
    IN  REGSAM         samDesired,
    IN  ULONG          ulHardwareProfile,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkDevice,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    )

/*++

Routine Description:

   This routine opens the software storage registry key associated with a
   device instance.

   Parameters:

   dnDevNode         Handle of a device instance.  This handle is typically
                     retrieved by a call to CM_Locate_DevNode or
                     CM_Create_DevNode.

   samDesired        Specifies an access mask that describes the desired
                     security access for the key.  This parameter can be
                     a combination of the values used in calls to RegOpenKeyEx.

   ulHardwareProfile Supplies the handle of the hardware profile to open the
                     storage key under.  This parameter is only used if the
                     CM_REGISTRY_CONFIG flag is specified in ulFlags.  If
                     this parameter is 0, the API uses the current hardware
                     profile.

   Disposition       Specifies how the registry key is to be opened.  May be
                     one of the following values:

                     RegDisposition_OpenAlways - Open the key if it exists,
                         otherwise, create the key.
                     RegDisposition_OpenExisting - Open the key only if it
                         exists, otherwise fail with CR_NO_SUCH_REGISTRY_VALUE.

   phkDevice         Supplies the address of the variable that receives an
                     opened handle to the specified key.  When access to this
                     key is completed, it must be closed via RegCloseKey.

   ulFlags           Specifies what type of storage key should be opened.
                     Can be a combination of these values:

                     CM_REGISTRY_HARDWARE (0x00000000)
                        Open a key for storing driver-independent information
                        relating to the device instance.  On Windows NT, the
                        full path to such a storage key is of the form:

                        HKLM\System\CurrentControlSet\Enum\<enumerator>\
                            <DeviceID>\<InstanceID>\Device Parameters

                     CM_REGISTRY_SOFTWARE (0x00000001)
                        Open a key for storing driver-specific information
                        relating to the device instance.  On Windows NT, the
                        full path to such a storage key is of the form:

                        HKLM\System\CurrentControlSet\Control\Class\
                            <DevNodeClass>\<ClassInstanceOrdinal>

                     CM_REGISTRY_USER (0x00000100)
                        Open a key under HKEY_CURRENT_USER instead of
                        HKEY_LOCAL_MACHINE.  This flag may not be used with
                        CM_REGISTRY_CONFIG.  There is no analagous kernel-mode
                        API on NT to get a per-user device configuration
                        storage, since this concept does not apply to device
                        drivers (no user may be logged on, etc).  However,
                        this flag is provided for consistency with Win95, and
                        because it is foreseeable that it could be useful to
                        Win32 services that interact with Plug-and-Play model.

                     CM_REGISTRY_CONFIG (0x00000200)
                        Open the key under a hardware profile branch instead
                        of HKEY_LOCAL_MACHINE.  If this flag is specified,
                        then ulHardwareProfile supplies the handle of the
                        hardware profile to be used.  This flag may not be
                        used with CM_REGISTRY_USER.

   hMachine          Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVICE_ID,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    PWSTR       pszMachineName = NULL;
    WCHAR       pDeviceID[MAX_DEVICE_ID_LEN];
    HKEY        hKey=NULL, hRemoteKey=NULL, hBranchKey=NULL;
    PWSTR       pszKey = NULL, pszPrivateKey = NULL;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(phkDevice)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *phkDevice = NULL;

        if (dnDevNode == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_REGISTRY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (INVALID_FLAGS(Disposition, RegDisposition_Bits)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if ((ulFlags & CM_REGISTRY_CONFIG)  &&
            (ulHardwareProfile > MAX_CONFIG_VALUE)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if ((hBinding != hLocalBindingHandle) && (ulFlags & CM_REGISTRY_USER)) {
            Status = CR_ACCESS_DENIED;     // current user key can't be remoted
            goto Clean0;
        }

        //
        // retrieve the device id string and validate it
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevNode,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }


        //-------------------------------------------------------------
        // determine the branch key to use; either HKLM or HKCU
        //-------------------------------------------------------------

        if (hBinding == hLocalBindingHandle) {

            if (ulFlags & CM_REGISTRY_USER) {
                hBranchKey = HKEY_CURRENT_USER;
            }
            else {
                //
                // all other cases go to HKLM (validate permission first?)
                //
                hBranchKey = HKEY_LOCAL_MACHINE;
            }
        }
        else {
            //
            // retrieve machine name
            //
            pszMachineName = pSetupMalloc((MAX_PATH + 3)*sizeof(WCHAR));
            if (pszMachineName == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            PnPRetrieveMachineName(hMachine, pszMachineName);

            //
            // use remote HKLM branch (we only support connect to
            // HKEY_LOCAL_MACHINE on the remote machine, not HKEY_CURRENT_USER)
            //
            RegStatus = RegConnectRegistry(pszMachineName, HKEY_LOCAL_MACHINE,
                                           &hRemoteKey);

            pSetupFree(pszMachineName);
            pszMachineName = NULL;

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // hBranchKey is either a predefined key or assigned to by
            // another key, I never attempt to close it. If hRemoteKey is
            // non-NULL I will attempt to close it during cleanup since
            // it is explicitly opened.
            //
            hBranchKey = hRemoteKey;
        }

        //
        // allocate some buffer space to work with
        //
        pszKey = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszKey == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszPrivateKey = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszPrivateKey == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // form the registry path based on the device id and the flags.
        //
        Status = GetDevNodeKeyPath(hBinding, pDeviceID, ulFlags,
                                   ulHardwareProfile, pszKey, pszPrivateKey);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        lstrcat(pszKey, TEXT("\\"));
        lstrcat(pszKey, pszPrivateKey);

        pSetupFree(pszPrivateKey);
        pszPrivateKey = NULL;

        //
        // open the registry key (method of open is based on flags)
        //
        if (Disposition == RegDisposition_OpenAlways) {

            //-----------------------------------------------------
            // open the registry key always
            //-----------------------------------------------------

            //
            // Only the main Enum subtree under HKLM has strict security
            // that requires me to first create the key on the server
            // side and then open it here on the client side. This
            // condition currently only occurs if the flags have
            // CM_REGISTRY_HARDWARE set but no other flags set.
            //
            if (ulFlags == CM_REGISTRY_HARDWARE) {
                //
                // first try to open it (in case it already exists).  If it
                // doesn't exist, then I'll have to have the protected server
                // side create the key.  I still need to open it from here, the
                // client-side, so that the registry handle will be in the
                // caller's address space.
                //
                RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         pszKey,
                                         0,
                                         samDesired,
                                         phkDevice);

                if (RegStatus != ERROR_SUCCESS) {

                    //
                    // call server side to create the key
                    //

                    RpcTryExcept {
                        //
                        // call rpc service entry point
                        //
                        Status = PNP_CreateKey(
                            hBinding,
                            pDeviceID,
                            samDesired,
                            0);
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "PNP_CreateKey caused an exception (%d)\n",
                                   RpcExceptionCode()));

                        Status = MapRpcExceptionToCR(RpcExceptionCode());
                    }
                    RpcEndExcept

                    if (Status != CR_SUCCESS) {
                        *phkDevice = NULL;
                        goto Clean0;
                    }

                    //
                    // the key was created successfully, so open it now
                    //
                    RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                             pszKey,
                                             0,
                                             samDesired,
                                             phkDevice);

                    if (RegStatus == ERROR_ACCESS_DENIED) {
                        *phkDevice = NULL;
                        Status = CR_ACCESS_DENIED;
                        goto Clean0;
                    }
                    else if (RegStatus != ERROR_SUCCESS) {
                        //
                        // if we still can't open the key, I give up
                        //
                        *phkDevice = NULL;
                        Status = CR_REGISTRY_ERROR;
                        goto Clean0;
                    }
                }
            }

            else {
                //
                // these keys have admin-full privilege so try to open
                // from the client-side and just let the security of the
                // key judge whether the caller can access it.
                //
                RegStatus = RegCreateKeyEx(hBranchKey,
                                           pszKey,
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           samDesired,
                                           NULL,
                                           phkDevice,
                                           NULL);

                if (RegStatus == ERROR_ACCESS_DENIED) {
                    *phkDevice = NULL;
                    Status = CR_ACCESS_DENIED;
                    goto Clean0;
                }
                else if (RegStatus != ERROR_SUCCESS) {
                    *phkDevice = NULL;
                    Status = CR_REGISTRY_ERROR;
                    goto Clean0;
                }
            }
        }
        else {

            //-----------------------------------------------------
            // open only if it already exists
            //-----------------------------------------------------

            //
            // the actual open always occurs on the client side so I can
            // pass back a handle that's valid for the calling process.
            // Only creates need to happen on the server side
            //
            RegStatus = RegOpenKeyEx(hBranchKey,
                                     pszKey,
                                     0,
                                     samDesired,
                                     phkDevice);

            if (RegStatus == ERROR_ACCESS_DENIED) {
                *phkDevice = NULL;
                Status = CR_ACCESS_DENIED;
                goto Clean0;
            }
            else if (RegStatus != ERROR_SUCCESS) {
                *phkDevice = NULL;
                Status = CR_NO_SUCH_REGISTRY_KEY;
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pszMachineName = pszMachineName;
        pszPrivateKey = pszPrivateKey;
        pszKey = pszKey;
    }

    if (pszMachineName) {
        pSetupFree(pszMachineName);
    }

    if (pszPrivateKey) {
        pSetupFree(pszPrivateKey);
    }

    if (pszKey) {
        pSetupFree(pszKey);
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (hRemoteKey != NULL) {
        RegCloseKey(hRemoteKey);
    }

    return Status;

} // CM_Open_DevNode_Key_ExW



CONFIGRET
CM_Delete_DevNode_Key_Ex(
    IN DEVNODE dnDevNode,
    IN ULONG   ulHardwareProfile,
    IN ULONG   ulFlags,
    IN HANDLE  hMachine
    )

/*++

Routine Description:

   This routine deletes a registry storage key associated with a device
   instance.

   dnDevNode   Handle of a device instance.  This handle is typically
               retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode.

   ulHardwareProfile Supplies the handle of the hardware profile to delete
               the storage key under.  This parameter is only used if the
               CM_REGISTRY_CONFIG flag is specified in ulFlags.  If this
               parameter is 0, the API uses the current hardware profile.
               If this parameter is 0xFFFFFFFF, then the specified storage
               key(s) for all hardware profiles is (are) deleted.

   ulFlags     Specifies what type(s) of storage key(s) should be deleted.
               Can be a combination of these values:

               CM_REGISTRY_HARDWARE - Delete the key for storing driver-
                  independent information relating to the device instance.
                  This may be combined with CM_REGISTRY_SOFTWARE to delete
                  both device and driver keys simultaneously.
               CM_REGISTRY_SOFTWARE - Delete the key for storing driver-
                  specific information relating to the device instance.
                  This may be combined with CM_REGISTRY_HARDWARE to
                  delete both driver and device keys simultaneously.
               CM_REGISTRY_USER - Delete the specified key(s) under
                  HKEY_CURRENT_USER instead of HKEY_LOCAL_MACHINE.
                  This flag may not be used with CM_REGISTRY_CONFIG.
               CM_REGISTRY_CONFIG - Delete the specified keys(s) under a
                  hardware profile branch instead of HKEY_LOCAL_MACHINE.
                  If this flag is specified, then ulHardwareProfile
                  supplies the handle to the hardware profile to be used.
                  This flag may not be used with CM_REGISTRY_USER.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    HKEY        hKey = NULL;
    PWSTR       pszParentKey = NULL, pszChildKey = NULL, pszRegStr = NULL;
    WCHAR       pDeviceID[MAX_DEVICE_ID_LEN], szProfile[MAX_PROFILE_ID_LEN];
    ULONG       ulIndex = 0, ulSize = 0,ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevNode == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_REGISTRY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_REGISTRY_USER) && (ulFlags & CM_REGISTRY_CONFIG)) {
            Status = CR_INVALID_FLAG;      // can't specify both
            goto Clean0;
        }

        //
        // setup string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device id string and validate it
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevNode,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // allocate some buffer space to work with
        //
        pszParentKey = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszParentKey == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszChildKey = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszChildKey == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszRegStr = pSetupMalloc(MAX_CM_PATH*sizeof(WCHAR));
        if (pszRegStr == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // form the registry path based on the device id and the flags.
        //
        Status = GetDevNodeKeyPath(hBinding, pDeviceID, ulFlags,
                                   ulHardwareProfile, pszParentKey, pszChildKey);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }


        //------------------------------------------------------------------
        // For either hw and sw user keys, the client side is privileged
        // enough to do the delete (if the caller doesn't have admin, it
        // will be denied but that is the desired behaviour). Also, the
        // service-side cannot access the HKEY_CURRENT_USER key unless it
        // does some sort of impersonation.
        //------------------------------------------------------------------

        if (ulFlags & CM_REGISTRY_USER) {
            //
            // handle the special config-specific case when the profile
            // specified is -1, then need to delete the private key
            // for all profiles
            //
            if ((ulFlags & CM_REGISTRY_CONFIG) &&
                (ulHardwareProfile == 0xFFFFFFFF)) {

                wsprintf(pszRegStr, TEXT("%s\\%s"),
                         pszRegPathIDConfigDB,
                         pszRegKeyKnownDockingStates);

                RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         pszRegStr,
                                         0,
                                         KEY_ALL_ACCESS,
                                         &hKey);

                //
                // enumerate the hardware profile keys
                //
                for (ulIndex = 0; RegStatus == ERROR_SUCCESS; ulIndex++) {

                    ulSize = MAX_PROFILE_ID_LEN * sizeof(WCHAR);
                    RegStatus = RegEnumKeyEx(hKey, ulIndex, szProfile, &ulSize,
                                             NULL, NULL, NULL, NULL);

                    if (RegStatus == ERROR_SUCCESS) {
                        //
                        // pszParentKey contains replacement symbol for the
                        // profile id
                        //
                        wsprintf(pszRegStr, pszParentKey, szProfile);

                        Status = DeletePrivateKey(HKEY_CURRENT_USER,
                                                  pszRegStr,
                                                  pszChildKey);

                        if (Status != CR_SUCCESS) {
                            goto Clean0;
                        }
                    }
                }
            }

            else {
                //
                // not for all profiles, so just delete the specified key
                //
                Status = DeletePrivateKey(HKEY_CURRENT_USER,
                                          pszParentKey,
                                          pszChildKey);

                if (Status != CR_SUCCESS) {
                    goto Clean0;
                }
            }
        }


        //------------------------------------------------------------------
        // For the remaining cases (no user keys), do the work on the
        // server side, sense that side has the code to make the key
        // volatile if necessary instead of deleting. Also, access to
        // some of these registry keys requires system privilege.
        //------------------------------------------------------------------

        else {
            if (!(ulFlags & CM_REGISTRY_CONFIG)) {
                ulHardwareProfile = 0;
            }

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_DeleteRegistryKey(
                    hBinding,               // rpc binding handle
                    pDeviceID,              // device id
                    pszParentKey,           // parent of key to delete
                    pszChildKey,            // key to delete
                    ulHardwareProfile);     // flags, not used
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_DeleteRegistryKey caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pszRegStr = pszRegStr;
        pszChildKey = pszChildKey;
        pszParentKey = pszParentKey;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pszRegStr) {
        pSetupFree(pszRegStr);
    }

    if (pszChildKey) {
        pSetupFree(pszChildKey);
    }

    if (pszParentKey) {
        pSetupFree(pszParentKey);
    }

    return Status;

} // CM_Delete_DevNode_Key_Ex



CONFIGRET
CM_Open_Class_Key_ExW(
    IN  LPGUID         ClassGuid        OPTIONAL,
    IN  LPCWSTR        pszClassName     OPTIONAL,
    IN  REGSAM         samDesired,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkClass,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    )

/*++

Routine Description:

   This routine opens the class registry key, and optionally, a specific
   class's subkey.

Parameters:

   ClassGuid   Optionally, supplies the address of a class GUID representing
               the class subkey to be opened.

   pszClassName Specifies the string form of the class name for the class
                represented by ClassGuid.  This parameter is only valid if
                the CM_OPEN_CLASS_KEY_INSTALLER flag is set in the ulFlags
                parameter.  If specified, this string will replace any existing
                class name associated with this setup class GUID.

                This parameter must be set to NULL if the
                CM_OPEN_CLASS_KEY_INTERFACE bit is set in the ulFlags parameter.

   samDesired  Specifies an access mask that describes the desired security
               access for the new key. This parameter can be a combination
               of the values used in calls to RegOpenKeyEx.

   Disposition Specifies how the registry key is to be opened. May be one
               of the following values:
               RegDisposition_OpenAlways - Open the key if it exists,
                  otherwise, create the key.
               RegDisposition_OpenExisting - Open the key f it exists,
                  otherwise, fail with CR_NO_SUCH_REGISTRY_KEY.

   phkClass    Supplies the address of the variable that receives an opened
               handle to the specified key.  When access to this key is
               completed, it must be closed via RegCloseKey.

   ulFlags     May be one of the following values:

               CM_OPEN_CLASS_KEY_INSTALLER - open/create a setup class key for
                   the specified GUID under
                   HKLM\System\CurrentControlSet\Control\Class.

               CM_OPEN_CLASS_KEY_INTERFACE - open/create a device interface
                   class key for the specified GUID under
                   HKLM\System\CurrentControlSet\Control\DeviceClasses.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hRootKey = NULL, hRemoteKey = NULL;
    PWSTR       pszMachineName = NULL, pszRegStr = NULL;
    PVOID       hStringTable = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(phkClass)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *phkClass = NULL;

        if (INVALID_FLAGS(Disposition, RegDisposition_Bits)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_OPEN_CLASS_KEY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // If ulFlags == CM_OPEN_CLASS_KEY_INTERFACE then pszClassName had
        // better be NULL.
        //
        if((ulFlags == CM_OPEN_CLASS_KEY_INTERFACE) && pszClassName) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // get reg key for HKEY_LOCAL_MACHINE
        //
        if (hMachine == NULL) {
            //
            // local call
            //
            hRootKey = HKEY_LOCAL_MACHINE;
        }
        else {
            //
            // setup string table handle and retreive machine name
            //
            if (!PnPGetGlobalHandles(hMachine, &hStringTable, NULL)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            pszMachineName = pSetupMalloc((MAX_PATH + 3)*sizeof(WCHAR));
            if (pszMachineName == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            PnPRetrieveMachineName(hMachine, pszMachineName);

            //
            // connect to HKEY_LOCAL_MACHINE on remote machine
            //
            RegStatus = RegConnectRegistry(pszMachineName, HKEY_LOCAL_MACHINE,
                                           &hRemoteKey);

            pSetupFree(pszMachineName);
            pszMachineName = NULL;

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            hRootKey = hRemoteKey;
        }

        //
        // allocate some buffer space to work with
        //
        pszRegStr = pSetupMalloc(MAX_PATH*sizeof(WCHAR));
        if (pszRegStr == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // Form the registry path
        //
        if (ulFlags == CM_OPEN_CLASS_KEY_INTERFACE) {
            lstrcpy(pszRegStr, pszRegPathDeviceClass);
        } else {
            lstrcpy(pszRegStr, pszRegPathClass);
        }

        if (ClassGuid != NULL) {    // optional class guid was specified

            WCHAR szStringGuid[MAX_GUID_STRING_LEN];

            if (pSetupStringFromGuid(ClassGuid, szStringGuid,MAX_GUID_STRING_LEN) == NO_ERROR) {
                lstrcat(pszRegStr, TEXT("\\"));
                lstrcat(pszRegStr, szStringGuid);
            }
        }

        //
        // attempt to open/create that key
        //
        if (Disposition == RegDisposition_OpenAlways) {

            ULONG ulDisposition;

            RegStatus = RegCreateKeyEx(hRootKey, pszRegStr, 0, NULL,
                                       REG_OPTION_NON_VOLATILE, samDesired,
                                       NULL, phkClass, &ulDisposition);

        } else {
            RegStatus = RegOpenKeyEx(hRootKey, pszRegStr, 0, samDesired,
                                     phkClass);
        }

        if((pszClassName != NULL)  && (RegStatus == ERROR_SUCCESS)) {
            RegSetValueEx(*phkClass, pszRegValueClass, 0, REG_SZ,
                          (LPBYTE)pszClassName,
                          (lstrlen(pszClassName) + 1) * sizeof(WCHAR));
        }

        if (RegStatus != ERROR_SUCCESS) {
            *phkClass = NULL;
            Status = CR_NO_SUCH_REGISTRY_KEY;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pszMachineName = pszMachineName;
        pszRegStr = pszRegStr;
    }

    if (pszMachineName != NULL) {
        pSetupFree(pszMachineName);
    }

    if (pszRegStr != NULL) {
        pSetupFree(pszRegStr);
    }

    if (hRemoteKey != NULL) {
        RegCloseKey(hRemoteKey);
    }

    return Status;

} // CM_Open_Class_Key_ExW



CONFIGRET
CM_Enumerate_Classes_Ex(
    IN  ULONG      ulClassIndex,
    OUT LPGUID     ClassGuid,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine enumerates the installed classes in the system.  It
   retrieves the GUID string for a single class each time it is called.
   To enumerate installed classes, an application should initially call the
   CM_Enumerate_Classes function with the ulClassIndex parameter set to
   zero. The application should then increment the ulClassIndex parameter
   and call CM_Enumerate_Classes until there are no more classes (until the
   function returns CR_NO_SUCH_VALUE).

   It is possible to receive a CR_INVALID_DATA error while enumerating
   installed classes.  This may happen if the registry key represented by
   the specified index is determined to be an invalid class key.  Such keys
   should be ignored during enumeration.

Parameters:

   ulClassIndex   Supplies the index of the class to retrieve the class
                  GUID string for.

   ClassGuid      Supplies the address of a variable that receives the GUID
                  for the class whose index is specified by ulClassIndex.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szClassGuid[MAX_GUID_STRING_LEN];
    ULONG       ulLength = MAX_GUID_STRING_LEN;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(ClassGuid)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize guid struct
        //
        ZeroMemory(ClassGuid, sizeof(GUID));

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_EnumerateSubKeys(
                hBinding,            // rpc binding handle
                PNP_CLASS_SUBKEYS,   // subkeys of class branch
                ulClassIndex,        // index of class key to enumerate
                szClassGuid,         // will contain class name
                ulLength,            // length of Buffer in chars,
                &ulLength,           // size copied (or size required)
                ulFlags);            // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_EnumerateSubKeys caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            if (pSetupGuidFromString(szClassGuid, ClassGuid) != NO_ERROR) {
                Status = CR_FAILURE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Enumerate_Classes_Ex



CONFIGRET
CM_Get_Class_Name_ExW(
    IN  LPGUID     ClassGuid,
    OUT PTCHAR     Buffer,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )


/*++

Routine Description:

   This routine retrieves the class name associated with the specified
   class GUID string.

Parameters:

   ClassGuid      Supplies a pointer to the class GUID whose name
                  is to be retrieved.

   Buffer         Supplies the address of the character buffer that receives
                  the class name corresponding to the specified GUID.

   pulLength      Supplies the address of the variable that contains the
                  length, in characters, of the Buffer.  Upon return, this
                  variable will contain the number of characters (including
                  terminating NULL) written to Buffer (if the supplied buffer
                  isn't large enough, then the routine will fail with
                  CR_BUFFER_SMALL, and this value will indicate how large the
                  buffer needs to be in order to succeed).

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szStringGuid[MAX_GUID_STRING_LEN];
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(ClassGuid)) ||
            (!ARGUMENT_PRESENT(Buffer))    ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(ClassGuid, szStringGuid,MAX_GUID_STRING_LEN) != NO_ERROR) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetClassName(
                hBinding,            // rpc binding handle
                szStringGuid,
                Buffer,
                pulLength,           // returns count of keys under Class
                ulFlags);            // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetClassName caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Class_Name_ExW



CONFIGRET
CM_Get_Class_Key_Name_ExW(
    IN  LPGUID     ClassGuid,
    OUT LPWSTR     pszKeyName,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine retrieves the class name associated with the specified
   class GUID string.

Parameters:

   ClassGuid      Supplies a pointer to the class GUID whose name
                  is to be retrieved.

   pszKeyName     Returns the name of the class key in the registry that
                  corresponds to the specified ClassGuid. The returned key
                  name is relative to
                  HKLM\System\CurrentControlSet\Control\Class.

   pulLength      Supplies the address of the variable that contains the
                  length, in characters, of the Buffer.  Upon return, this
                  variable will contain the number of characters (including
                  terminating NULL) written to Buffer (if the supplied buffer
                  isn't large enough, then the routine will fail with
                  CR_BUFFER_SMALL, and this value will indicate how large the
                  buffer needs to be in order to succeed).

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;

    //
    // NOTE: the supplied machine handle is never referenced by this routine,
    // since it is known/assumed that the key name of the class key requested is
    // always just the string representation of the supplied class GUID.
    // there is no corresponding UMPNPMGR server-side routine.
    //
    UNREFERENCED_PARAMETER(hMachine);

    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(ClassGuid)) ||
            (!ARGUMENT_PRESENT(pszKeyName))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (*pulLength < MAX_GUID_STRING_LEN) {
            *pulLength = MAX_GUID_STRING_LEN;
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(ClassGuid, pszKeyName,MAX_GUID_STRING_LEN) == NO_ERROR) {
            *pulLength = MAX_GUID_STRING_LEN;
        } else {
            Status = CR_INVALID_DATA;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Class_Key_Name_ExW



CONFIGRET
CM_Delete_Class_Key_Ex(
    IN  LPGUID     ClassGuid,
    IN  ULONG      ulFlags,
    IN  HANDLE     hMachine
    )

/*++

Routine Description:

   This routine deletes the specified class key from the registry.

Parameters:

   ClassGuid      Supplies a pointer to the class GUID to delete.

   ulFlags        Must be one of the following values:
                  CM_DELETE_CLASS_ONLY - only deletes the class key if it
                                         doesn't have any subkeys.
                  CM_DELETE_CLASS_SUBKEYS - deletes the class key and any
                                            subkeys of the class key.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szStringGuid[MAX_GUID_STRING_LEN];
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(ClassGuid)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_DELETE_CLASS_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // convert from guid to string
        //
        if (pSetupStringFromGuid(ClassGuid, szStringGuid,MAX_GUID_STRING_LEN) != NO_ERROR) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_DeleteClassKey(
                hBinding,            // rpc binding handle
                szStringGuid,
                ulFlags);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_DeleteClassKey caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Delete_Class_Key_Ex



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExW(
    IN     LPCWSTR  pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPWSTR   pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;
    ULONG       ulTransferLen = 0;

    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(pszDeviceInterface)) ||
            (!ARGUMENT_PRESENT(AliasInterfaceGuid)) ||
            (!ARGUMENT_PRESENT(pszAliasDeviceInterface)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pszAliasDeviceInterface = '\0';
        ulTransferLen = *pulLength;

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetInterfaceDeviceAlias(
                hBinding,
                pszDeviceInterface,
                AliasInterfaceGuid,
                pszAliasDeviceInterface,
                pulLength,
                &ulTransferLen,
                ulFlags);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetInterfaceDeviceAlias caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_Interface_Alias_ExW



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExW(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_W pDeviceID           OPTIONAL,
    OUT PWCHAR      Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine returns a list of interface devices of the specified interface
   class. You can optionally filter the list of returned interface devices
   based on only those created by a particular devinst. Typically the
   CM_Get_Interface_Device_List routine is called first to determine how big
   a buffer must be allocated to hold the interface device list.

Parameters:

   InterfaceClassGuid    This GUID specifies which interface devices to return (only
                         those interface devices that belong to this interface class).

   pDeviceID        Optional devinst to filter the list of returned interface
                    devices (if non-zero, only the interfaces devices associated
                    with this devinst will be returned).

   Buffer           Supplies the buffer that will contain the returned multi_sz
                    list of interface devices.

   BufferLen        Specifies how big the Buffer parameter is in characters.

   ulFlags          Must be one of the following values:

                    CM_GET_DEVICE_INTERFACE_LIST_PRESENT -
                                only currently 'live' devices
                    CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES 0x00000001 -
                                all registered devices, live or not

   hMachine        Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_GET_DEVICE_INTERFACE_LIST_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *Buffer = '\0';

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetInterfaceDeviceList(
                hBinding,            // RPC Binding Handle
                InterfaceClassGuid,  // Device interface GUID
                pDeviceID,           // filter string, optional
                Buffer,              // will contain device list
                &BufferLen,          // in/out size of Buffer
                ulFlags);            // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetInterfaceDeviceList caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_Interface_List_ExW



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExW(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_W pDeviceID           OPTIONAL,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine returns the size (in characters) of buffer required to hold a
   multi_sz list of interface devices of the specified interface class. You
   can optionally filter the list of returned interface devices based on only
   those created by a particular devinst. This routine is typically called before
   a call to the CM_Get_Interface_Device_List routine.

Parameters:

   pulLen           On a successful return from this routine, this parameter
                    will contain the size (in characters) required to hold the
                    multi_sz list of returned interface devices.

   InterfaceClassGuid    This GUID specifies which interface devices to include (only
                         those interface devices that belong to this interface class).

   pDeviceID        Optional devinst to filter the list of returned interface
                    devices (if non-zero, only the interfaces devices associated
                    with this devinst will be returned).

   ulFlags          Must be one of the following values:

                    CM_GET_DEVICE_INTERFACE_LIST_PRESENT -
                                only currently 'live' devices
                    CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES -
                                all registered devices, live or not

   hMachine        Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pulLen)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_GET_DEVICE_INTERFACE_LIST_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pulLen = 0;

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetInterfaceDeviceListSize(
                hBinding,            // RPC Binding Handle
                pulLen,              // Size of buffer required (in chars)
                InterfaceClassGuid,  // Device interface GUID
                pDeviceID,           // filter string, optional
                ulFlags);            // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetInterfaceDeviceListSize caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_Interface_List_Size_Ex



CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExW(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  LPCWSTR   pszReference          OPTIONAL,
    OUT LPWSTR    pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )

/*++

Routine Description:

Parameters:


   hMachine        Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pszDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulTransferLen,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(pulLength)) ||
            (!ARGUMENT_PRESENT(pszDeviceInterface)) ||
            (!ARGUMENT_PRESENT(InterfaceClassGuid))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnParent
        // (note that this is not optional, even a first level device instance
        // has a parent (the root device instance)
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pszDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // ulTransferLen is just used to control how many bytes in the
        // pszInterfaceDevice buffer must be marshalled. We need two
        // length params, since pulLength may contained the required bytes
        // (if the passed in buffer was too small) which may differ from
        // how many types are actually available to marshall (in the buffer
        // too small case, we'll marshall zero so ulTransferLen will be zero
        // but pulLength will describe how many bytes are required to hold
        // the Interface Device string.
        //
        ulTransferLen = *pulLength;

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_RegisterDeviceClassAssociation(
                hBinding,            // RPC Binding Handle
                pszDeviceID,         // device instance
                InterfaceClassGuid,  // Device interface GUID
                pszReference,        // reference string, optional
                pszDeviceInterface,  // returns interface device name
                pulLength,           // pszInterfaceDevice buffer required in chars
                &ulTransferLen,      // how many chars to marshall back
                ulFlags);            // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_RegisterDeviceClassAssociation caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Register_Device_Interface



CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExW(
    IN LPCWSTR  pszDeviceInterface,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

Parameters:


   hMachine        Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_BUFFER_SMALL, or
         CR_REGISTRY_ERROR
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pszDeviceInterface)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_UnregisterDeviceClassAssociation(
                hBinding,            // RPC Binding Handle
                pszDeviceInterface,  // interface device
                ulFlags);            // unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_UnregisterDeviceClassAssociation caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Unregister_Device_Interface_ExW



CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExW(
    IN  DEVINST     dnDevInst,
    IN  PCWSTR      pszCustomPropertyName,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the specified property, either from the devnode's
   device (aka, hardware) key, or from the most-specific per-hardware-id
   storage key for that devnode.

Parameters:

   dnDevInst   Supplies the handle of the device instance for which a
               custom property is to be retrieved.

   pszCustomPropertyName  Supplies a string identifying the name of the
                          property (registry value entry name) to be retrieved.

   pulRegDataType Optionally, supplies the address of a variable that
                  will receive the registry data type for this property
                  (i.e., the REG_* constants).

   Buffer      Supplies the address of the buffer that receives the
               registry data.  Can be NULL when simply retrieving data size.

   pulLength   Supplies the address of the variable that contains the size,
               in bytes, of the buffer.  The API replaces the initial size
               with the number of bytes of registry data copied to the buffer.
               If the variable is initially zero, the API replaces it with
               the buffer size needed to receive all the registry data.  In
               this case, the Buffer parameter is ignored.

   ulFlags     May be a combination of the following values:

               CM_CUSTOMDEVPROP_MERGE_MULTISZ : merge the devnode-specific
                   REG_SZ or REG_MULTI_SZ property (if present) with the
                   per-hardware-id REG_SZ or REG_MULTI_SZ property (if
                   present).  The result will always be a REG_MULTI_SZ.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

    If the function succeeds, the return value is CR_SUCCESS.

    If the function fails, the return value indicates the cause of failure, and
    is typically one of the following:
       CR_INVALID_DEVNODE,
       CR_INVALID_FLAG,
       CR_INVALID_POINTER,
       CR_REGISTRY_ERROR,
       CR_BUFFER_SMALL,
       CR_NO_SUCH_VALUE, or
       CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulSizeID, ulTempDataType, ulTransferLen;
    BYTE        NullBuffer = 0;
    handle_t    hBinding;
    PVOID       hStringTable;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if(!dnDevInst) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if(!pszCustomPropertyName) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(!pulLength) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(!Buffer && *pulLength) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(INVALID_FLAGS(ulFlags, CM_CUSTOMDEVPROP_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if(!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the string form of the device id string
        //
        ulSizeID = SIZECHARS(pDeviceID);
        Success = pSetupStringTableStringFromIdEx(hStringTable,
                                                  dnDevInst,
                                                  pDeviceID,
                                                  &ulSizeID
                                                 );

        if(!Success || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if(!Buffer) {
            Buffer = &NullBuffer;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetCustomDevProp(
                hBinding,               // rpc binding handle
                pDeviceID,              // string representation of device instance
                pszCustomPropertyName,  // name of the property
                &ulTempDataType,        // receives registry data type
                Buffer,                 // receives registry data
                &ulTransferLen,         // input/output buffer size
                pulLength,              // bytes copied (or bytes required)
                ulFlags);               // flags (e.g., merge-multi-sz?)
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetCustomDevProp caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if(pulRegDataType) {
            //
            // I pass a temp variable to the rpc stubs since they require the
            // output param to always be valid, then if user did pass in a valid
            // pointer to receive the info, do the assignment now
            //
            *pulRegDataType = ulTempDataType;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_DevNode_Custom_Property_ExW



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Get_DevNode_Registry_PropertyW(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_DevNode_Registry_Property_ExW(dnDevInst, ulProperty,
                                                pulRegDataType, Buffer,
                                                pulLength, ulFlags, NULL);
}


CONFIGRET
CM_Get_DevNode_Registry_PropertyA(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_DevNode_Registry_Property_ExA(dnDevInst, ulProperty,
                                                pulRegDataType, Buffer,
                                                pulLength, ulFlags, NULL);
}


CONFIGRET
CM_Set_DevNode_Registry_PropertyW(
    IN DEVINST     dnDevInst,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer               OPTIONAL,
    IN OUT ULONG   ulLength,
    IN ULONG       ulFlags
    )
{
    return CM_Set_DevNode_Registry_Property_ExW(dnDevInst, ulProperty, Buffer,
                                                ulLength, ulFlags, NULL);
}


CONFIGRET
CM_Set_DevNode_Registry_PropertyA(
    IN DEVINST     dnDevInst,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer               OPTIONAL,
    IN OUT ULONG   ulLength,
    IN ULONG       ulFlags
    )
{
    return CM_Set_DevNode_Registry_Property_ExA(dnDevInst, ulProperty, Buffer,
                                                ulLength, ulFlags, NULL);
}


CONFIGRET
CM_Open_DevNode_Key(
    IN  DEVINST        dnDevNode,
    IN  REGSAM         samDesired,
    IN  ULONG          ulHardwareProfile,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkDevice,
    IN  ULONG          ulFlags
    )
{
    return CM_Open_DevNode_Key_Ex(dnDevNode, samDesired, ulHardwareProfile,
                                  Disposition, phkDevice, ulFlags, NULL);
}


CONFIGRET
CM_Delete_DevNode_Key(
    IN DEVNODE dnDevNode,
    IN ULONG   ulHardwareProfile,
    IN ULONG   ulFlags
    )

{
    return CM_Delete_DevNode_Key_Ex(dnDevNode, ulHardwareProfile,
                                    ulFlags, NULL);
}


CONFIGRET
CM_Open_Class_KeyW(
    IN  LPGUID         ClassGuid        OPTIONAL,
    IN  LPCWSTR        pszClassName     OPTIONAL,
    IN  REGSAM         samDesired,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkClass,
    IN  ULONG          ulFlags
    )
{
    return CM_Open_Class_Key_ExW(ClassGuid, pszClassName, samDesired,
                                 Disposition, phkClass, ulFlags, NULL);
}


CONFIGRET
CM_Open_Class_KeyA(
    IN  LPGUID         ClassGuid        OPTIONAL,
    IN  LPCSTR         pszClassName     OPTIONAL,
    IN  REGSAM         samDesired,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkClass,
    IN  ULONG          ulFlags
    )
{
    return CM_Open_Class_Key_ExA(ClassGuid, pszClassName, samDesired,
                                 Disposition, phkClass, ulFlags, NULL);
}


CONFIGRET
CM_Enumerate_Classes(
    IN ULONG      ulClassIndex,
    OUT LPGUID    ClassGuid,
    IN ULONG      ulFlags
    )
{
    return CM_Enumerate_Classes_Ex(ulClassIndex, ClassGuid, ulFlags, NULL);
}


CONFIGRET
CM_Get_Class_NameW(
    IN  LPGUID     ClassGuid,
    OUT PWCHAR     Buffer,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags
    )
{
    return CM_Get_Class_Name_ExW(ClassGuid, Buffer, pulLength, ulFlags, NULL);
}


CONFIGRET
CM_Get_Class_NameA(
    IN  LPGUID     ClassGuid,
    OUT PCHAR      Buffer,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags
    )
{
    return CM_Get_Class_Name_ExA(ClassGuid, Buffer, pulLength, ulFlags, NULL);
}


CONFIGRET
CM_Get_Class_Key_NameA(
    IN  LPGUID     ClassGuid,
    OUT LPSTR      pszKeyName,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags
    )
{
    return CM_Get_Class_Key_Name_ExA(ClassGuid, pszKeyName, pulLength,
                                     ulFlags, NULL);
}


CONFIGRET
CM_Get_Class_Key_NameW(
    IN  LPGUID     ClassGuid,
    OUT LPWSTR     pszKeyName,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags
    )
{
    return CM_Get_Class_Key_Name_ExW(ClassGuid, pszKeyName, pulLength,
                                     ulFlags, NULL);
}


CONFIGRET
CM_Delete_Class_Key(
    IN  LPGUID     ClassGuid,
    IN  ULONG      ulFlags
    )
{
    return CM_Delete_Class_Key_Ex(ClassGuid, ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasA(
    IN     LPCSTR  pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPSTR   pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    )
{
    return CM_Get_Device_Interface_Alias_ExA(pszDeviceInterface, AliasInterfaceGuid,
                                             pszAliasDeviceInterface, pulLength,
                                             ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasW(
    IN     LPCWSTR pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPWSTR  pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    )
{
    return CM_Get_Device_Interface_Alias_ExW(pszDeviceInterface, AliasInterfaceGuid,
                                             pszAliasDeviceInterface, pulLength,
                                             ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListA(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID           OPTIONAL,
    OUT PCHAR       Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_Device_Interface_List_ExA(InterfaceClassGuid, pDeviceID, Buffer,
                                            BufferLen, ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListW(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_W pDeviceID           OPTIONAL,
    OUT PWCHAR      Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_Device_Interface_List_ExW(InterfaceClassGuid, pDeviceID, Buffer,
                                            BufferLen, ulFlags, NULL);
}


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeA(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID           OPTIONAL,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_Device_Interface_List_Size_ExA(pulLen, InterfaceClassGuid,
                                                 pDeviceID, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeW(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_W pDeviceID           OPTIONAL,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_Device_Interface_List_Size_ExW(pulLen, InterfaceClassGuid,
                                                 pDeviceID, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceA(
    IN  DEVINST  dnDevInst,
    IN  LPGUID   InterfaceClassGuid,
    IN  LPCSTR   pszReference           OPTIONAL,
    OUT LPSTR    pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG    ulFlags
    )
{
    return CM_Register_Device_Interface_ExA(dnDevInst, InterfaceClassGuid,
                                            pszReference, pszDeviceInterface,
                                            pulLength, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceW(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  LPCWSTR   pszReference          OPTIONAL,
    OUT LPWSTR    pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags
    )
{
    return CM_Register_Device_Interface_ExW(dnDevInst, InterfaceClassGuid,
                                            pszReference, pszDeviceInterface,
                                            pulLength, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceA(
    IN LPCSTR  pszDeviceInterface,
    IN ULONG   ulFlags
    )
{
    return CM_Unregister_Device_Interface_ExA(pszDeviceInterface, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceW(
    IN LPCWSTR pszDeviceInterface,
    IN ULONG   ulFlags
    )
{
    return CM_Unregister_Device_Interface_ExW(pszDeviceInterface, ulFlags, NULL);
}

CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyW(
    IN  DEVINST     dnDevInst,
    IN  PCWSTR      pszCustomPropertyName,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_DevNode_Custom_Property_ExW(dnDevInst,
                                              pszCustomPropertyName,
                                              pulRegDataType,
                                              Buffer,
                                              pulLength,
                                              ulFlags,
                                              NULL
                                             );
}

CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyA(
    IN  DEVINST     dnDevInst,
    IN  PCSTR       pszCustomPropertyName,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CM_Get_DevNode_Custom_Property_ExA(dnDevInst,
                                              pszCustomPropertyName,
                                              pulRegDataType,
                                              Buffer,
                                              pulLength,
                                              ulFlags,
                                              NULL
                                             );
}



//-------------------------------------------------------------------
// ANSI STUBS
//-------------------------------------------------------------------


CONFIGRET
CM_Get_DevNode_Registry_Property_ExA(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulDataType, UniLen;
    PWSTR       pUniBuffer;

    //
    // validate essential parameters only
    //
    if (!ARGUMENT_PRESENT(pulLength)) {
        return CR_INVALID_POINTER;
    }

    //
    // examine datatype to see if need to convert return data
    //
    ulDataType = GetPropertyDataType(ulProperty);

    //
    // for all string type registry properties, we pass a Unicode buffer and
    // convert back to caller's ANSI buffer on return.  since the Unicode ->
    // ANSI conversion may involve DBCS chars, we can't make any assumptions
    // about the size of the required ANSI buffer relative to the size of the
    // require Unicode buffer, so we must always get the Unicode string buffer
    // and convert it whether a buffer was actually supplied by the caller or
    // not.
    //
    if (ulDataType == REG_SZ ||
        ulDataType == REG_MULTI_SZ ||
        ulDataType == REG_EXPAND_SZ) {

        //
        // first, call the Wide version with a zero-length buffer to retrieve
        // the size required for the Unicode property.
        //
        UniLen = 0;
        Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      pulRegDataType,
                                                      NULL,
                                                      &UniLen,
                                                      ulFlags,
                                                      hMachine);
        if (Status != CR_BUFFER_SMALL) {
            return Status;
        }

        //
        // allocate the required buffer.
        //
        pUniBuffer = pSetupMalloc(UniLen);
        if (pUniBuffer == NULL) {
            return CR_OUT_OF_MEMORY;
        }

        //
        // call the Wide version to retrieve the Unicode property.
        //
        Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      pulRegDataType,
                                                      pUniBuffer,
                                                      &UniLen,
                                                      ulFlags,
                                                      hMachine);

        //
        // We specifically allocated the buffer of the required size, so it
        // should always be large enough.
        //
        ASSERT(Status != CR_BUFFER_SMALL);

        if (Status == CR_SUCCESS) {
            //
            // do the ANSI conversion or retrieve the ANSI buffer size required.
            // this may be a single-sz or multi-sz string, so we pass in the
            // length, and let PnPUnicodeToMultiByte convert the entire buffer.
            //
            Status = PnPUnicodeToMultiByte(pUniBuffer,
                                           UniLen,
                                           Buffer,
                                           pulLength);

        }

        pSetupFree(pUniBuffer);

    } else {
        //
        // for the non-string registry data types, just pass call on through to
        // the Wide version
        //
        Status = CM_Get_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      pulRegDataType,
                                                      Buffer,
                                                      pulLength,
                                                      ulFlags,
                                                      hMachine);
    }

    return Status;

} // CM_Get_DevNode_Registry_Property_ExA



CONFIGRET
CM_Set_DevNode_Registry_Property_ExA(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    IN  PCVOID      Buffer              OPTIONAL,
    IN  ULONG       ulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulDataType = 0, UniSize = 0, UniBufferSize = 0;
    PWSTR       pUniBuffer = NULL, pUniString = NULL, pUniNext = NULL;
    PSTR        pAnsiString = NULL;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer)) && (ulLength != 0)) {
        return CR_INVALID_POINTER;
    }

    if (!ARGUMENT_PRESENT(Buffer)) {
        //
        // No need to convert the parameter
        //
        return CM_Set_DevNode_Registry_Property_ExW(dnDevInst,
                                                    ulProperty,
                                                    Buffer,
                                                    ulLength,
                                                    ulFlags,
                                                    hMachine);
    }

    //
    // examine datatype to see if need to convert input buffer
    //
    ulDataType = GetPropertyDataType(ulProperty);

    if (ulDataType == REG_SZ || ulDataType == REG_EXPAND_SZ) {
        //
        // convert buffer string data to unicode and pass to wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(Buffer, &pUniBuffer) == NO_ERROR) {

            UniSize = (lstrlen(pUniBuffer)+1) * sizeof(WCHAR);

            Status = CM_Set_DevNode_Registry_Property_ExW(dnDevInst,
                                                          ulProperty,
                                                          pUniBuffer,
                                                          UniSize,
                                                          ulFlags,
                                                          hMachine);
            pSetupFree(pUniBuffer);
        } else {
            Status = CR_INVALID_DATA;
        }

    } else if (ulDataType == REG_MULTI_SZ) {
        //
        // must convert the multi_sz list to unicode first
        //
        UniBufferSize = ulLength * sizeof(WCHAR);
        pUniBuffer = pSetupMalloc(UniBufferSize);
        if (pUniBuffer == NULL) {
            return CR_OUT_OF_MEMORY;
        }

        for (pAnsiString = (PSTR)Buffer, pUniNext = pUniBuffer;
             *pAnsiString;
             pAnsiString += lstrlenA(pAnsiString) + 1) {

            if (pSetupCaptureAndConvertAnsiArg(pAnsiString, &pUniString) == NO_ERROR) {

                UniSize += (lstrlen(pUniString)+1) * sizeof(WCHAR);

                if (UniSize >= UniBufferSize) {
                    pSetupFree(pUniString);
                    pSetupFree(pUniBuffer);
                    return CR_INVALID_DATA;
                }

                lstrcpy(pUniNext, pUniString);
                pUniNext += lstrlen(pUniNext) + 1;

                pSetupFree(pUniString);
            } else {
                pSetupFree(pUniBuffer);
                return CR_INVALID_DATA;
            }
        }
        *(pUniNext++) = L'\0';   // add second null term

        Status = CM_Set_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      pUniBuffer,
                                                      UniBufferSize,
                                                      ulFlags,
                                                      hMachine);
        pSetupFree(pUniBuffer);

    } else {

        Status = CM_Set_DevNode_Registry_Property_ExW(dnDevInst,
                                                      ulProperty,
                                                      Buffer,
                                                      ulLength,
                                                      ulFlags,
                                                      hMachine);
    }

    return Status;

} // CM_Set_DevNode_Registry_Property_ExA



CONFIGRET
CM_Get_Class_Registry_PropertyA(
    IN  LPGUID      pClassGuid,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulDataType, UniLen;
    PWSTR       pUniBuffer;

    //
    // validate essential parameters only
    //
    if (!ARGUMENT_PRESENT(pulLength)) {
        return CR_INVALID_POINTER;
    }

    //
    // examine datatype to see if need to convert return data
    //
    ulDataType = GetPropertyDataType(ulProperty);

    //
    // for all string type registry properties, we pass a Unicode buffer and
    // convert back to caller's ANSI buffer on return.  since the Unicode ->
    // ANSI conversion may involve DBCS chars, we can't make any assumptions
    // about the size of the required ANSI buffer relative to the size of the
    // require Unicode buffer, so we must always get the Unicode string buffer
    // and convert it whether a buffer was actually supplied by the caller or
    // not.
    //
    if (ulDataType == REG_SZ ||
        ulDataType == REG_MULTI_SZ ||
        ulDataType == REG_EXPAND_SZ) {

        //
        // first, call the Wide version with a zero-length buffer to retrieve
        // the size required for the Unicode property.
        //
        UniLen = 0;
        Status = CM_Get_Class_Registry_PropertyW(pClassGuid,
                                                 ulProperty,
                                                 pulRegDataType,
                                                 NULL,
                                                 &UniLen,
                                                 ulFlags,
                                                 hMachine);
        if (Status != CR_BUFFER_SMALL) {
            return Status;
        }

        //
        // allocate the required buffer.
        //
        pUniBuffer = pSetupMalloc(UniLen);
        if (pUniBuffer == NULL) {
            return CR_OUT_OF_MEMORY;
        }

        //
        // call the Wide version to retrieve the Unicode property.
        //
        Status = CM_Get_Class_Registry_PropertyW(pClassGuid,
                                                 ulProperty,
                                                 pulRegDataType,
                                                 pUniBuffer,
                                                 &UniLen,
                                                 ulFlags,
                                                 hMachine);

        //
        // We specifically allocated the buffer of the required size, so it
        // should always be large enough.
        //
        ASSERT(Status != CR_BUFFER_SMALL);

        if (Status == CR_SUCCESS) {
            //
            // do the ANSI conversion or retrieve the ANSI buffer size required.
            // this may be a single-sz or multi-sz string, so we pass in the
            // length, and let PnPUnicodeToMultiByte convert the entire buffer.
            //
            Status = PnPUnicodeToMultiByte(pUniBuffer,
                                           UniLen,
                                           Buffer,
                                           pulLength);
        }

        pSetupFree(pUniBuffer);

    } else {
        //
        // for the non-string registry data types, just pass call
        // on through to the Wide version
        //
        Status = CM_Get_Class_Registry_PropertyW(pClassGuid,
                                                 ulProperty,
                                                 pulRegDataType,
                                                 Buffer,
                                                 pulLength,
                                                 ulFlags,
                                                 hMachine);
    }

    return Status;

} // CM_Get_Class_Registry_PropertyA



CONFIGRET
CM_Set_Class_Registry_PropertyA(
    IN  LPGUID      pClassGuid,
    IN  ULONG       ulProperty,
    IN  PCVOID      Buffer              OPTIONAL,
    IN  ULONG       ulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulDataType = 0, UniSize = 0, UniBufferSize = 0;
    PWSTR       pUniBuffer = NULL, pUniString = NULL, pUniNext = NULL;
    PSTR        pAnsiString = NULL;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer)) && (ulLength != 0)) {
        return CR_INVALID_POINTER;
    }

    if (!ARGUMENT_PRESENT(Buffer)) {
        //
        // No need to convert the parameter
        //
        return CM_Set_Class_Registry_PropertyW(pClassGuid,
                                                    ulProperty,
                                                    Buffer,
                                                    ulLength,
                                                    ulFlags,
                                                    hMachine);
    }

    //
    // examine datatype to see if need to convert input buffer
    //
    ulDataType = GetPropertyDataType(ulProperty);

    if (ulDataType == REG_SZ || ulDataType == REG_EXPAND_SZ) {
        //
        // convert buffer string data to unicode and pass to wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(Buffer, &pUniBuffer) == NO_ERROR) {

            UniSize = (lstrlen(pUniBuffer)+1) * sizeof(WCHAR);

            Status = CM_Set_Class_Registry_PropertyW(pClassGuid,
                                                          ulProperty,
                                                          pUniBuffer,
                                                          UniSize,
                                                          ulFlags,
                                                          hMachine);
            pSetupFree(pUniBuffer);
        } else {
            Status = CR_INVALID_DATA;
        }

    } else if (ulDataType == REG_MULTI_SZ) {
        //
        // must convert the multi_sz list to unicode first
        //
        UniBufferSize = ulLength * sizeof(WCHAR);
        pUniBuffer = pSetupMalloc(UniBufferSize);
        if (pUniBuffer == NULL) {
            return CR_OUT_OF_MEMORY;
        }

        for (pAnsiString = (PSTR)Buffer, pUniNext = pUniBuffer;
             *pAnsiString;
             pAnsiString += lstrlenA(pAnsiString) + 1) {

            if (pSetupCaptureAndConvertAnsiArg(pAnsiString, &pUniString) == NO_ERROR) {

                UniSize += (lstrlen(pUniString)+1) * sizeof(WCHAR);

                if (UniSize >= UniBufferSize) {
                    pSetupFree(pUniString);
                    pSetupFree(pUniBuffer);
                    return CR_INVALID_DATA;
                }

                lstrcpy(pUniNext, pUniString);
                pUniNext += lstrlen(pUniNext) + 1;

                pSetupFree(pUniString);
            } else {
                pSetupFree(pUniBuffer);
                return CR_INVALID_DATA;
            }
        }
        *(pUniNext++) = L'\0';   // add second null term

        Status = CM_Set_Class_Registry_PropertyW(pClassGuid,
                                                      ulProperty,
                                                      pUniBuffer,
                                                      UniBufferSize,
                                                      ulFlags,
                                                      hMachine);
        pSetupFree(pUniBuffer);

    } else {

        Status = CM_Set_Class_Registry_PropertyW(pClassGuid,
                                                      ulProperty,
                                                      Buffer,
                                                      ulLength,
                                                      ulFlags,
                                                      hMachine);
    }

    return Status;

} // CM_Set_Class_Registry_Property_ExA



CONFIGRET
CM_Open_Class_Key_ExA(
    IN  LPGUID         ClassGuid        OPTIONAL,
    IN  LPCSTR         pszClassName     OPTIONAL,
    IN  REGSAM         samDesired,
    IN  REGDISPOSITION Disposition,
    OUT PHKEY          phkClass,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniClassName = NULL;

    if (ARGUMENT_PRESENT(pszClassName)) {
        if (pSetupCaptureAndConvertAnsiArg(pszClassName, &pUniClassName) != NO_ERROR) {
            return CR_INVALID_DATA;
        }
    }

    Status = CM_Open_Class_Key_ExW(ClassGuid,
                                   pUniClassName,
                                   samDesired,
                                   Disposition,
                                   phkClass,
                                   ulFlags,
                                   hMachine);

    if (pUniClassName) {
        pSetupFree(pUniClassName);
    }

    return Status;

} // CM_Open_Class_Key_ExA



CONFIGRET
CM_Get_Class_Name_ExA(
    IN  LPGUID     ClassGuid,
    OUT PCHAR      Buffer,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     UniBuffer[MAX_CLASS_NAME_LEN];
    ULONG     UniLen = MAX_CLASS_NAME_LEN;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer))    ||
        (!ARGUMENT_PRESENT(pulLength))) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode buffer as a parameter
    //
    Status = CM_Get_Class_Name_ExW(ClassGuid,
                                   UniBuffer,
                                   &UniLen,
                                   ulFlags,
                                   hMachine);

    //
    // We should never return a class name longer than MAX_CLASS_NAME_LEN.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    //
    // convert the unicode buffer to an ansi string and copy to the
    // caller's buffer
    //
    if (Status == CR_SUCCESS) {

        Status = PnPUnicodeToMultiByte(UniBuffer,
                                       (lstrlenW(UniBuffer)+1)*sizeof(WCHAR),
                                       Buffer,
                                       pulLength);
    }

    return Status;

} // CM_Get_Class_Name_ExA



CONFIGRET
CM_Get_Class_Key_Name_ExA(
    IN  LPGUID     ClassGuid,
    OUT LPSTR      pszKeyName,
    IN OUT PULONG  pulLength,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     UniBuffer[MAX_GUID_STRING_LEN];
    ULONG     UniLen = MAX_GUID_STRING_LEN;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(pszKeyName)) ||
        (!ARGUMENT_PRESENT(pulLength))) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode buffer as a parameter
    //
    Status = CM_Get_Class_Key_Name_ExW(ClassGuid,
                                       UniBuffer,
                                       &UniLen,
                                       ulFlags,
                                       hMachine);

    //
    // We should never return a class key name longer than MAX_GUID_STRING_LEN.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    //
    // convert the unicode buffer to an ansi string and copy to the
    // caller's buffer
    //
    if (Status == CR_SUCCESS) {

        Status = PnPUnicodeToMultiByte(UniBuffer,
                                       (lstrlenW(UniBuffer)+1)*sizeof(WCHAR),
                                       pszKeyName,
                                       pulLength);
    }

    return Status;

} // CM_Get_Class_Key_Name_ExA



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExA(
    IN     LPCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniDeviceInterface, pUniAliasDeviceInterface;
    ULONG     UniLen;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(pszDeviceInterface)) ||
        (!ARGUMENT_PRESENT(pszAliasDeviceInterface)) ||
        (!ARGUMENT_PRESENT(pulLength))) {
        return CR_INVALID_POINTER;
    }

    //
    // convert buffer string data to unicode to pass to wide version
    //
    if (pSetupCaptureAndConvertAnsiArg(pszDeviceInterface, &pUniDeviceInterface) != NO_ERROR) {
        return CR_INVALID_DATA;
    }

    //
    // first, call the Wide version with a zero-length buffer to retrieve
    // the size required for the Unicode property.
    //
    UniLen = 0;
    Status = CM_Get_Device_Interface_Alias_ExW(pUniDeviceInterface,
                                               AliasInterfaceGuid,
                                               NULL,
                                               &UniLen,
                                               ulFlags,
                                               hMachine);
    if (Status != CR_BUFFER_SMALL) {
        return Status;
        goto Clean0;
    }

    //
    // allocate the required buffer.
    //
    pUniAliasDeviceInterface = pSetupMalloc(UniLen);
    if (pUniAliasDeviceInterface == NULL) {
        Status = CR_OUT_OF_MEMORY;
        goto Clean0;
    }

    //
    // call the Wide version to retrieve the Unicode property.
    //
    Status = CM_Get_Device_Interface_Alias_ExW(pUniDeviceInterface,
                                               AliasInterfaceGuid,
                                               pUniAliasDeviceInterface,
                                               &UniLen,
                                               ulFlags,
                                               hMachine);

    //
    // We specifically allocated the buffer of the required size, so it should
    // always be large enough.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // do the ANSI conversion or retrieve the ANSI buffer size required.
        //
        Status = PnPUnicodeToMultiByte(pUniAliasDeviceInterface,
                                       (lstrlenW(pUniAliasDeviceInterface)+1)*sizeof(WCHAR),
                                       pszAliasDeviceInterface,
                                       pulLength);

    }

    pSetupFree(pUniAliasDeviceInterface);

 Clean0:

    pSetupFree(pUniDeviceInterface);

    return Status;

} // CM_Get_Device_Interface_Alias_ExA



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExA(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID           OPTIONAL,
    OUT PCHAR       Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniBuffer, pUniDeviceID = NULL;
    ULONG     ulAnsiBufferLen;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
        return CR_INVALID_POINTER;
    }

    if (ARGUMENT_PRESENT(pDeviceID)) {
        //
        // if a filter string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(pDeviceID, &pUniDeviceID) != NO_ERROR) {
            return CR_INVALID_DEVICE_ID;
        }
        ASSERT(pUniDeviceID != NULL);
    } else {
        ASSERT(pUniDeviceID == NULL);
    }

    //
    // prepare a larger buffer to hold the unicode formatted
    // multi_sz data returned by CM_Get_Device_Interface_List_ExW.
    //
    pUniBuffer = pSetupMalloc(BufferLen * sizeof(WCHAR));
    if (pUniBuffer == NULL) {
        Status = CR_OUT_OF_MEMORY;
        goto Clean0;
    }

    *pUniBuffer = L'\0';

    //
    // call the wide version
    //
    Status = CM_Get_Device_Interface_List_ExW(InterfaceClassGuid,
                                              pUniDeviceID,
                                              pUniBuffer,
                                              BufferLen,    // size in chars
                                              ulFlags,
                                              hMachine);

    //
    // convert the unicode buffer to an ansi string and copy to the
    // caller's buffer
    //
    if (Status == CR_SUCCESS) {

        ulAnsiBufferLen = BufferLen;
        Status = PnPUnicodeToMultiByte(pUniBuffer,
                                       BufferLen*sizeof(WCHAR),
                                       Buffer,
                                       &ulAnsiBufferLen);
    }

    pSetupFree(pUniBuffer);

 Clean0:

    if (pUniDeviceID) {
        pSetupFree(pUniDeviceID);
    }

    return Status;

} // CM_Get_Device_Interface_List_ExA



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExA(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID           OPTIONAL,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS, tmpStatus;
    PWSTR     pUniDeviceID = NULL, pUniDeviceInterfaceList;
    ULONG     UniLen;

    //
    // validate essential parameters only
    //
    if (!ARGUMENT_PRESENT(pulLen)) {
        return CR_INVALID_POINTER;
    }

    if (ARGUMENT_PRESENT(pDeviceID)) {
        //
        // if a device ID string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(pDeviceID, &pUniDeviceID) != NO_ERROR) {
            return CR_INVALID_DEVICE_ID;
        }
        ASSERT(pUniDeviceID != NULL);
    } else {
        ASSERT(pUniDeviceID == NULL);
    }

    //
    // first, call the Wide version to retrieve the size required for the
    // Unicode device interface list.
    //
    UniLen = 0;
    Status = CM_Get_Device_Interface_List_Size_ExW(&UniLen,
                                                   InterfaceClassGuid,
                                                   pUniDeviceID,
                                                   ulFlags,
                                                   hMachine);
    if (Status != CR_SUCCESS) {
        goto Clean0;
    }

    //
    // allocate the required buffer.
    //
    pUniDeviceInterfaceList = pSetupMalloc(UniLen*sizeof(WCHAR));
    if (pUniDeviceInterfaceList == NULL) {
        Status =  CR_OUT_OF_MEMORY;
        goto Clean0;
    }

    //
    // call the Wide version to retrieve the Unicode device interface list.
    //
    Status = CM_Get_Device_Interface_List_ExW(InterfaceClassGuid,
                                              pUniDeviceID,
                                              pUniDeviceInterfaceList,
                                              UniLen,
                                              ulFlags,
                                              hMachine);

    //
    // We specifically allocated the buffer of the required size, so it should
    // always be large enough.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // retrieve the size, in bytes, of the ANSI buffer size required to
        // convert this list.  since this is a multi-sz string, we pass in the
        // length and let PnPUnicodeToMultiByte convert the entire buffer.
        //
        tmpStatus = PnPUnicodeToMultiByte(pUniDeviceInterfaceList,
                                          UniLen*sizeof(WCHAR),
                                          NULL,
                                          pulLen);

        ASSERT(tmpStatus == CR_BUFFER_SMALL);
    }

    pSetupFree(pUniDeviceInterfaceList);

 Clean0:

    if (pUniDeviceID) {
        pSetupFree(pUniDeviceID);
    }

    return Status;

} // CM_Get_Device_Interface_List_Size_ExA



CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExA(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  LPCSTR    pszReference          OPTIONAL,
    OUT LPSTR     pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniReference = NULL, pUniDeviceInterface = NULL;
    ULONG     UniLen;

    try {
        //
        // validate essential parameters only
        //
        if ((!ARGUMENT_PRESENT(pulLength)) ||
            (!ARGUMENT_PRESENT(pszDeviceInterface))) {
            return CR_INVALID_POINTER;
        }

        //
        // if a device reference string was passed in, convert to Unicode before
        // passing on to the wide version
        //
        if (ARGUMENT_PRESENT(pszReference)) {
            if (pSetupCaptureAndConvertAnsiArg(pszReference, &pUniReference) != NO_ERROR) {
                return CR_INVALID_DATA;
            }
        }

        //
        // pass a Unicode buffer instead and convert back to caller's ANSI buffer on
        // return
        //
        UniLen = *pulLength;
        pUniDeviceInterface = pSetupMalloc(UniLen*sizeof(WCHAR));
        if (pUniDeviceInterface == NULL) {
            Status =  CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        Status = CM_Register_Device_Interface_ExW(dnDevInst,
                                                  InterfaceClassGuid,
                                                  pUniReference,
                                                  pUniDeviceInterface,
                                                  &UniLen,
                                                  ulFlags,
                                                  hMachine);

        if (Status == CR_SUCCESS) {
            //
            // if the call succeeded, convert the Unicode string to ANSI
            //
            Status = PnPUnicodeToMultiByte(pUniDeviceInterface,
                                           (lstrlenW(pUniDeviceInterface)+1)*sizeof(WCHAR),
                                           pszDeviceInterface,
                                           pulLength);

        } else if (Status == CR_BUFFER_SMALL) {
            //
            // returned size is in chars
            //
            *pulLength = UniLen;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (pUniDeviceInterface) {
        pSetupFree(pUniDeviceInterface);
    }

    if (pUniReference) {
        pSetupFree(pUniReference);
    }

    return Status;

} // CM_Register_Device_Interface_ExA



CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExA(
    IN LPCSTR   pszDeviceInterface,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniDeviceInterface = NULL;

    try {
        //
        // validate essential parameters only
        //
        if (!ARGUMENT_PRESENT(pszDeviceInterface)) {
            return CR_INVALID_POINTER;
        }

        //
        // convert buffer string data to unicode and pass to wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(pszDeviceInterface, &pUniDeviceInterface) == NO_ERROR) {

            Status = CM_Unregister_Device_Interface_ExW(pUniDeviceInterface,
                                                        ulFlags,
                                                        hMachine);
        } else {
            Status = CR_INVALID_DATA;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (pUniDeviceInterface) {
        pSetupFree(pUniDeviceInterface);
    }

    return Status;

} // CM_Unregister_Device_Interface_ExA



CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExA(
    IN  DEVINST     dnDevInst,
    IN  PCSTR       pszCustomPropertyName,
    OUT PULONG      pulRegDataType      OPTIONAL,
    OUT PVOID       Buffer              OPTIONAL,
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    DWORD       Win32Status;
    CONFIGRET   Status = CR_SUCCESS;
    PWSTR       UnicodeCustomPropName = NULL;
    DWORD       UniLen;
    PBYTE       pUniBuffer = NULL;
    PSTR        pAnsiBuffer = NULL;
    ULONG       ulDataType;
    ULONG       ulAnsiBufferLen;
    PWSTR       pUniString;

    try {
        //
        // Validate parameters not validated by upcoming call to Unicode API
        // (CM_Get_DevNode_Registry_Property_ExW).
        //
        if(!ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if(pszCustomPropertyName) {
            //
            // Convert property name to Unicode.
            //
            Win32Status = pSetupCaptureAndConvertAnsiArg(pszCustomPropertyName,
                                                         &UnicodeCustomPropName
                                                        );

            if(Win32Status != NO_ERROR) {
                //
                // This routine guarantees that the returned unicode string
                // pointer will be null upon failure, so we don't have to reset
                // it here--just bail.
                //
                if(Win32Status == ERROR_NOT_ENOUGH_MEMORY) {
                    Status = CR_OUT_OF_MEMORY;
                } else {
                    Status = CR_INVALID_POINTER;
                }
                goto Clean0;
            }

        } else {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Unfortunately, we have no clue as to whether or not the requested
        // property is a string (thus requiring conversion from Unicode to
        // ANSI).  Therefore, we'll retrieve the data (if any) in its entirety,
        // then convert to ANSI if necessary.  Only then can we determine the
        // data size (and whether it can be returned to the caller).
        //
        // Start out with a reasonable guess as to buffer size in an attempt to
        // avoid calling the Unicode get-property API twice...
        //
        UniLen = 1024;
        do {
            pUniBuffer = pSetupMalloc(UniLen);
            if(!pUniBuffer) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            Status = CM_Get_DevNode_Custom_Property_ExW(dnDevInst,
                                                        UnicodeCustomPropName,
                                                        &ulDataType,
                                                        pUniBuffer,
                                                        &UniLen,
                                                        ulFlags,
                                                        hMachine
                                                       );
            if(Status != CR_SUCCESS) {
                pSetupFree(pUniBuffer);
                pUniBuffer = NULL;
            }

        } while(Status == CR_BUFFER_SMALL);

        if(Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // If we get to here, we successfully retrieved the property.
        //
        if(pulRegDataType) {
            *pulRegDataType = ulDataType;
        }

        if(UniLen == 0) {
            //
            // We retrieved an empty buffer--no need to worry about
            // transferring any data into caller's buffer.
            //
            *pulLength = 0;
            goto Clean0;
        }

        switch(ulDataType) {

            case REG_MULTI_SZ :
            case REG_SZ :
            case REG_EXPAND_SZ :
                //
                // Worst case, an ANSI buffer large enough to hold the results
                // would be the same size as the Unicode results.
                //
                pAnsiBuffer = pSetupMalloc(UniLen);
                if(!pAnsiBuffer) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                //
                // do the ANSI conversion or retrieve the ANSI buffer size required.
                // this may be a single-sz or multi-sz string, so we pass in the
                // length, and let PnPUnicodeToMultiByte convert the entire buffer.
                //
                ulAnsiBufferLen = *pulLength;
                Status = PnPUnicodeToMultiByte((PWSTR)pUniBuffer,
                                               UniLen,
                                               pAnsiBuffer,
                                               &ulAnsiBufferLen);

                if(ulAnsiBufferLen > *pulLength) {
                    ASSERT(Status == CR_BUFFER_SMALL);
                    Status = CR_BUFFER_SMALL;
                } else {
                    //
                    // Copy ANSI string(s) into caller's buffer.
                    //
                    CopyMemory(Buffer, pAnsiBuffer, ulAnsiBufferLen);
                }

                *pulLength = ulAnsiBufferLen;

                break;

            default :
                //
                // buffer doesn't contain text, no conversion necessary.
                //
                if(UniLen > *pulLength) {
                    Status = CR_BUFFER_SMALL;
                } else {
                    CopyMemory(Buffer, pUniBuffer, UniLen);
                }

                *pulLength = UniLen;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        pUniBuffer = pUniBuffer;
        pAnsiBuffer = pAnsiBuffer;
    }

    if(UnicodeCustomPropName) {
        pSetupFree(UnicodeCustomPropName);
    }

    if(pUniBuffer) {
        pSetupFree(pUniBuffer);
    }

    if(pAnsiBuffer) {
        pSetupFree(pAnsiBuffer);
    }

    return Status;

} // CM_Get_DevNode_Custom_Property_ExA



//-------------------------------------------------------------------
// Private utility routines
//-------------------------------------------------------------------


ULONG
GetPropertyDataType(
    IN ULONG ulProperty)

/*++

Routine Description:

   This routine takes a property ID and returns the registry data type that
   is used to store this property data (i.e., REG_SZ, etc).
Parameters:

   ulProperty     Property ID (one of the CM_DRP_* defines)

Return Value:

   Returns one of the predefined registry data types, REG_BINARY is the default.

--*/

{
    switch(ulProperty) {

        case CM_DRP_DEVICEDESC:
        case CM_DRP_SERVICE:
        case CM_DRP_CLASS:
        case CM_DRP_CLASSGUID:
        case CM_DRP_DRIVER:
        case CM_DRP_MFG:
        case CM_DRP_FRIENDLYNAME:
        case CM_DRP_LOCATION_INFORMATION:
        case CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME:
        case CM_DRP_ENUMERATOR_NAME:
        case CM_DRP_SECURITY_SDS: // and CM_CRP_SECURITY_SDS
        case CM_DRP_UI_NUMBER_DESC_FORMAT:
            return REG_SZ;

        case CM_DRP_HARDWAREID:
        case CM_DRP_COMPATIBLEIDS:
        case CM_DRP_UPPERFILTERS:
        case CM_DRP_LOWERFILTERS:
            return REG_MULTI_SZ;

        case CM_DRP_CONFIGFLAGS:
        case CM_DRP_CAPABILITIES:
        case CM_DRP_UI_NUMBER:
        case CM_DRP_LEGACYBUSTYPE:
        case CM_DRP_BUSNUMBER:
        case CM_DRP_CHARACTERISTICS: // and CM_CRP_CHARACTERISTICS
        case CM_DRP_EXCLUSIVE: // and CM_CRP_EXCLUSIVE
        case CM_DRP_DEVTYPE: // and CM_CRP_DEVTYPE
        case CM_DRP_ADDRESS:
        case CM_DRP_REMOVAL_POLICY:
        case CM_DRP_REMOVAL_POLICY_HW_DEFAULT:
        case CM_DRP_REMOVAL_POLICY_OVERRIDE:
        case CM_DRP_INSTALL_STATE:
            return REG_DWORD;

        case CM_DRP_BUSTYPEGUID:
        case CM_DRP_SECURITY: // and CM_CRP_SECURITY

            return REG_BINARY;

        case CM_DRP_DEVICE_POWER_DATA:
            return REG_BINARY;

        default:
            //
            // We should never get here!
            //
            ASSERT(0);
            return REG_BINARY;
    }

} // GetPropertyDataType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\rpcbind.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    This module contains the RPC bind and un-bind routines for the
    Configuration Manager client-side APIs.

Author:

    Paula Tomlinson (paulat) 6-21-1995

Environment:

    User-mode only.

Revision History:

    21-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"



handle_t
PNP_HANDLE_bind (
    PNP_HANDLE   ServerName
    )

/*++

Routine Description:

    This routine calls a common bind routine that is shared by all
    services. This routine is called from the PNP API client stubs
    when it is necessary to bind to a server. The binding is done to
    allow impersonation by the server since that is necessary for the
    API calls.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/

{
    handle_t    BindingHandle;
    RPC_STATUS  Status;


    Status = RpcpBindRpc(
                ServerName,         // UNC Server Name
                L"ntsvcs",
                L"Security=Impersonation Dynamic True",
                &BindingHandle);

    //
    // the possible return codes from RpcpBindRpc are STATUS_SUCCESS,
    // STATUS_NO_MEMORY and STATUS_INVALID_COMPUTER_NAME.  Since the format
    // of the bind routine is fixed, set any errors encountered as the last
    // error and return NULL.
    //
    if (Status != STATUS_SUCCESS) {

       BindingHandle = NULL;

       if (Status == STATUS_NO_MEMORY) {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
       }
       else if (Status == STATUS_INVALID_COMPUTER_NAME) {
         SetLastError(ERROR_INVALID_COMPUTERNAME);
       }
       else SetLastError(ERROR_GEN_FAILURE);
    }

    return BindingHandle;

} // PNP_HANDLE_bind



void
PNP_HANDLE_unbind (
    PNP_HANDLE    ServerName,
    handle_t      BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services. It is called from the Browser service client stubs
    when it is necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS  status;

    UNREFERENCED_PARAMETER(ServerName);

    status = RpcpUnbindRpc(BindingHandle);

    return;

} // PNP_HANDLE_unbind
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\traverse.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    traverse.c

Abstract:

    This module contains the API routines that perform hardware tree
    traversal.
               CM_Locate_DevNode
               CM_Get_Parent
               CM_Get_Child
               CM_Get_Sibling
               CM_Get_Device_ID_Size
               CM_Get_Device_ID
               CM_Enumerate_Enumerators
               CM_Get_Device_ID_List
               CM_Get_Device_ID_List_Size
               CM_Get_Depth

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"



CONFIGRET
CM_Locate_DevNode_ExW(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_W pDeviceID,       OPTIONAL
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine retrieves the handle of the device instance that
   corresponds to a specified device identifier.

Parameters:

   pdnDevInst     Supplies the address of the variable that receives the
                  handle of a device instance.

   pDeviceID      Supplies the address of a null-terminated string specifying
                  a device identifier.  If this parameter is NULL, the API
                  retrieves a handle to the device instance at the root of
                  the hardware tree.

   ulFlags        Supplies flags specifying options for locating the device
                  instance.  May be a combination of the following values:

                  CM_LOCATE_DEVNODE_NORMAL  - Locate only device instances
                     that are currently alive from the ConfigMgr's point of
                     view.
                  CM_LOCATE_DEVNODE_PHANTOM - Allows a device instance handle
                     to be returned for a device instance that is not
                     currently alive, but that does exist in the registry.
                     This may be used with other CM APIs that require a
                     devnode handle, but for which there currently is none
                     for a particular device (e.g., you want to set a device
                     registry property for a device not currently present).
                     This flag does not allow you to locate phantom devnodes
                     created by using CM_Create_DevNode with the
                     CM_CREATE_DEVNODE_PHANTOM flag (such device instances
                     are only accessible by the caller who holds the devnode
                     handle returned from that API).

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVICE_ID,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_DEVNODE,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     szFixedUpDeviceID[MAX_DEVICE_ID_LEN];
    PVOID     hStringTable = NULL;
    handle_t  hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_LOCATE_DEVNODE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pdnDevInst = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }


        //------------------------------------------------------------------
        // if the device instance is NULL or it's a zero-length string, then
        // retreive the root device instance
        //------------------------------------------------------------------

        if ((!ARGUMENT_PRESENT(pDeviceID)) || (lstrlen(pDeviceID) == 0)) {

            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_GetRootDeviceInstance(
                    hBinding,              // rpc binding handle
                    szFixedUpDeviceID,     // return device instance string
                    MAX_DEVICE_ID_LEN);    // length of DeviceInstanceID
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_GetRootDeviceInstance caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept
        }

        //------------------------------------------------------------------
        // if the device instance was specified, validate the string
        //------------------------------------------------------------------

        else {
            //
            // first see if the format of the device id string is valid, this
            // can be done on the client side
            //
            if (!IsLegalDeviceId(pDeviceID)) {
                Status = CR_INVALID_DEVICE_ID;
                goto Clean0;
            }

            //
            // Next, fix up the device ID string for consistency (uppercase, etc)
            //
            CopyFixedUpDeviceId(szFixedUpDeviceID, pDeviceID,
                                lstrlen(pDeviceID));

            //
            // finally, validate the presense of the device ID string, this must
            // be done by the server
            //
            RpcTryExcept {
                //
                // call rpc service entry point
                //
                Status = PNP_ValidateDeviceInstance(
                    hBinding,               // rpc binding handle
                    szFixedUpDeviceID,      // device id
                    ulFlags);               // locate flag
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP_ValidateDeviceInstance caused an exception (%d)\n",
                           RpcExceptionCode()));

                Status = MapRpcExceptionToCR(RpcExceptionCode());
            }
            RpcEndExcept
        }

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }


        //------------------------------------------------------------------
        // In either case, if we're successful then we have a valid device
        // ID. Use the string table to assign a unique DevNode to this
        // device id (if it's already in the string table, it just retrieves
        // the existing unique value)
        //------------------------------------------------------------------

        ASSERT(*szFixedUpDeviceID && IsLegalDeviceId(szFixedUpDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable,
                                           szFixedUpDeviceID,
                                           STRTAB_CASE_SENSITIVE);
        if (*pdnDevInst == 0xFFFFFFFF) {
            Status = CR_FAILURE;    // probably out of memory
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Locate_DevNode_ExW



CONFIGRET
CM_Get_Parent_Ex(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the handle of the parent of a device instance.

Parameters:

   pdnDevInst     Supplies the address of the variable that receives a
                  handle to the parent device instance.

   dnDevInst      Supplies the handle of the child device instance string.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_DEVNODE,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szDeviceID[MAX_DEVICE_ID_LEN],
                pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulSize = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate input parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pdnDevInst = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulSize);
        if (Success == FALSE  ||  INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        ulSize = MAX_DEVICE_ID_LEN;

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetRelatedDeviceInstance(
                hBinding,               // rpc binding handle
                PNP_GET_PARENT_DEVICE_INSTANCE,    // requested action
                pDeviceID,              // base device instance
                szDeviceID,             // returns parent device instance
                &ulSize,
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetRelatedDeviceInstance caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // add the returned device id to the string table so I can get a
        // devnode id for it (if it's already in the string table, the
        // existing id will be returned)
        //
        CharUpper(szDeviceID);

        ASSERT(*szDeviceID && IsLegalDeviceId(szDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable,
                                           szDeviceID,
                                           STRTAB_CASE_SENSITIVE);
        if (*pdnDevInst == 0xFFFFFFFF) {
            Status = CR_FAILURE;    // probably out of memory
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Parent_Ex



CONFIGRET
CM_Get_Child_Ex(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the first child of a given device instance.

Parameters:

   pdnDevInst     Supplies the address of the variable that receives the
                  handle of the device instance.

   dnDevInst      Supplies the handle of the parent device instance.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_DEVNODE,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szDeviceID[MAX_DEVICE_ID_LEN],
                pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulSize = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate input parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pdnDevInst = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulSize);
        if (Success == FALSE  ||  INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        ulSize = MAX_DEVICE_ID_LEN;

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetRelatedDeviceInstance(
                hBinding,               // rpc binding handle
                PNP_GET_CHILD_DEVICE_INSTANCE,    // requested action
                pDeviceID,              // base device instance
                szDeviceID,             // child device instance
                &ulSize,
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetRelatedDeviceInstance caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // add the returned device id to the string table so I can get a
        // devnode id for it (if it's already in the string table, the
        // existing id will be returned)
        //
        CharUpper(szDeviceID);

        ASSERT(*szDeviceID && IsLegalDeviceId(szDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable,
                                           szDeviceID,
                                           STRTAB_CASE_SENSITIVE);
        if (*pdnDevInst == 0xFFFFFFFF) {
            Status = CR_FAILURE;             // probably out of memory
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Child_Ex



CONFIGRET
CM_Get_Sibling_Ex(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the sibling of a device instance.

   This API can be called in a loop to retrieve all the siblings of a
   device instance.  When the API returns CR_NO_SUCH_DEVNODE, there are no
   more siblings to enumerate.  In order to enumerate all children of a
   device instance, this loop must start with the device instance retrieved
   by calling CM_Get_Child to get the first sibling.

Parameters:

   pdnDevInst     Supplies the address of the variable that receives a
                  handle to the sibling device  instance.

   dnDevInst      Supplies the handle of a device instance.

   ulFlags        Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_DEVNODE,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szDeviceID[MAX_DEVICE_ID_LEN],
                pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulSize = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate input parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pdnDevInst)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pdnDevInst = 0;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulSize);
        if (Success == FALSE  ||  INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;     // "input" devinst doesn't exist
            goto Clean0;
        }

        ulSize = MAX_DEVICE_ID_LEN;

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetRelatedDeviceInstance(
                hBinding,               // rpc binding handle
                PNP_GET_SIBLING_DEVICE_INSTANCE,    // requested action
                pDeviceID,              // base device instance
                szDeviceID,             // sibling device instance
                &ulSize,
                ulFlags);               // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetRelatedDeviceInstance caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // add the returned device id to the string table so I can get a
        // devnode id for it (if it's already in the string table, the
        // existing id will be returned)
        //
        CharUpper(szDeviceID);

        ASSERT(*szDeviceID && IsLegalDeviceId(szDeviceID));

        *pdnDevInst = pSetupStringTableAddString(hStringTable,
                                           szDeviceID,
                                           STRTAB_CASE_SENSITIVE);
        if (*pdnDevInst == 0xFFFFFFFF) {
            Status = CR_FAILURE;                // probably out of memory
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Sibling_Ex



CONFIGRET
CM_Get_Device_ID_Size_Ex(
    OUT PULONG   pulLen,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the size of a device identifier from a
   device instance.

Parameters:

   pulLen      Supplies the address of the variable that receives the size
               in characters, not including the terminating NULL, of the
               device identifier.  The API sets the variable to 0 if no
               identifier exists.  The size is always less than or equal to
               MAX_DEVICE_ID_LEN.

   dnDevInst   Supplies the handle of the device instance.

   ulFlags     Must be zero.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.
--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    BOOL        Success;
    DWORD       ulLen;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulLen)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, NULL)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the string form of the device id string
        // use private ulLen, since we know this is valid
        //
        ulLen = MAX_DEVICE_ID_LEN;
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE  ||  INVALID_DEVINST(pDeviceID)) {
            *pulLen = 0;
            Status = CR_INVALID_DEVINST;
        }
        //
        // discount the terminating NULL char,
        // included in the size reported by pSetupStringTableStringFromIdEx
        //
        *pulLen = ulLen - 1;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_ID_Size_Ex



CONFIGRET
CM_Get_Device_ID_ExW(
    IN  DEVINST  dnDevInst,
    OUT PWCHAR   Buffer,
    IN  ULONG    BufferLen,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the device identifier for a device instance.

Parameters:

   dnDevNode   Supplies the handle of the device instance for which to
               retrieve the device identifier.

   Buffer      Supplies the address of the buffer that receives the device
               identifier.  If this buffer is larger than the device
               identifier, the API appends a null-terminating character to
               the data.  If it is smaller than the device identifier, the API
               fills it with as much of the device identifier as will fit
               and returns CR_BUFFER_SMALL.

   BufferLen   Supplies the size, in characters, of the buffer for the device
               identifier.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_BUFFER_SMALL,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLength = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(Buffer)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, NULL)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the string form of the device id string
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLength);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            *Buffer = '\0';
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // copy as much of the the device id string as possible to the user
        // buffer.  the length reported by pSetupStringTableStringFromIdEx accounts
        // for the NULL term char; include it as well, if there is room.
        //
        memcpy(Buffer,
               pDeviceID,
               min(ulLength * sizeof(WCHAR), BufferLen * sizeof(WCHAR)));

        //
        // if the length of device id string (without NULL termination) is
        // longer than the supplied buffer, report CR_BUFFER_SMALL.
        //
        if ((ulLength - 1) > BufferLen) {
            Status = CR_BUFFER_SMALL;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_ID_ExW



CONFIGRET
CM_Enumerate_Enumerators_ExW(
    IN ULONG      ulEnumIndex,
    OUT PWCHAR    Buffer,
    IN OUT PULONG pulLength,
    IN ULONG      ulFlags,
    IN HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine enumerates the enumerator subkeys under the Enum branch
   (e.g., Root, PCI, etc.).  These names should not be used to access the
   registry directly, but may be used as input to the CM_Get_Device_ID_List
   routine.  To enumerate enumerator subkey names, an application should
   initially call the CM_Enumerate_Enumerators function with the ulEnumIndex
   parameter set to zero. The application should then increment the
   ulEnumIndex parameter and call CM_Enumerate_Enumerators until there are
   no more subkeys (until the function returns CR_NO_SUCH_VALUE).

Parameters:

   ulEnumIndex Supplies the index of the enumerator subkey name to retrieve.

   Buffer      Supplies the address of the character buffer that receives
               the enumerator subkey name whose index is specified by
               ulEnumIndex.

   pulLength   Supplies the address of the variable that contains the length,
               in characters, of the Buffer.  Upon return, this variable
               will contain the number of characters (including terminating
               NULL) written to Buffer (if the supplied buffer is't large
               enough, then the routine will fail with CR_BUFFER_SMALL, and
               this value will indicate how large the buffer needs to be in
               order to succeed).

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_BUFFER_SMALL,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(Buffer)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *Buffer = L'\0';

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_EnumerateSubKeys(
                hBinding,               // rpc binding handle
                PNP_ENUMERATOR_SUBKEYS, // subkeys of enum branch
                ulEnumIndex,            // index of enumerator to enumerate
                Buffer,                 // will contain enumerator name
                *pulLength,             // max length of Buffer in chars
                pulLength,              // chars copied (or chars required)
                ulFlags);               // currently unused
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_EnumerateSubKeys caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Enumerate_Enumerators_ExW



CONFIGRET
CM_Get_Device_ID_List_ExW(
    IN PCWSTR   pszFilter,    OPTIONAL
    OUT PWCHAR  Buffer,
    IN ULONG    BufferLen,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:
   This routine retrieve a list of all device IDs (device instance names)
   stored in the system.

Parameters:

   pszFilter      This string filters the list of device IDs returned.  Its
                  interpretation is dependent on the ulFlags specified.   If
                  CM_GETDEVID_FILTER_ENUMERATORS is specified, then this
                  value can be either the name of an enumerator or the name
                  of an enumerator plus the device id.  If
                  CM_GETDEVID_FILTER_SERVICE is specified, then this value
                  is a service name.

   Buffer         Supplies the address of the character buffer that receives
                  the device ID list.  Each device ID is null-terminated, with
                  an extra NULL at the end.

   BufferLen      Supplies the size, in characters, of the Buffer.  This size
                  may be ascertained by calling CM_Get_Device_ID_List_Size.

   ulFlags        Must be either CM_GETDEVID_FILTER_ENUMERATOR or
                  CM_GETDEVID_FILTER_SERVICE.  The flags value controls how
                  the pszFilter string is used.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_BUFFER_SMALL,
      CR_REGISTRY_ERROR,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_GETIDLIST_FILTER_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *Buffer = L'\0';

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetDeviceList(
                hBinding,            // RPC Binding Handle
                pszFilter,           // filter string, optional
                Buffer,              // will contain device list
                &BufferLen,          // in/out size of Buffer
                ulFlags);            // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetDeviceList caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_ID_List_ExW



CONFIGRET
CM_Get_Device_ID_List_Size_ExW(
    OUT PULONG  pulLen,
    IN PCWSTR   pszFilter,   OPTIONAL
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the size, in characters, of a list of device
   identifiers.  It may be used to supply the buffer size necessary for a
   call to CM_Get_Device_ID_List.

Parameters:

   pulLen         Supplies the address of the variable that receives the
                  size, in characters, required to store a list of all device
                  identifiers (possibly limited to those existing under the
                  pszEnumerator subkey described below).  The size reflects
                  a list of null-terminated device identifiers, with an extra
                  null at the end.  For efficiency, this number represents an
                  upper bound on the size required, and the actual list size
                  may be slightly smaller.

   pszFilter      This string filters the list of device IDs returned.  Its
                  interpretation is dependent on the ulFlags specified.   If
                  CM_GETDEVID_FILTER_ENUMERATORS is specified, then this
                  value can be either the name of an enumerator or the name
                  of an enumerator plus the device id.  If
                  CM_GETDEVID_FILTER_SERVICE is specified, then this value
                  is a service name.

   ulFlags        Must be either CM_GETDEVID_FILTER_ENUMERATOR or
                  CM_GETDEVID_FILTER_SERVICE.  The flags value controls how
                  the pszFilter string is used.

   hMachine       Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_REGISTRY_ERROR,
      CR_REMOTE_COMM_FAILURE,
      CR_MACHINE_UNAVAILABLE,
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    handle_t    hBinding = NULL;


    try {
        //
        // validate input parameters
        //
        if (!ARGUMENT_PRESENT(pulLen)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_GETIDLIST_FILTER_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        *pulLen = 0;

        //
        // setup rpc binding handle
        //
        if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetDeviceListSize(
                hBinding,       // rpc binding handle
                pszFilter,      // Enumerator subkey, optional
                pulLen,         // length of device list in chars
                ulFlags);       // filter flag
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetDeviceListSize caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Device_ID_List_SizeW



CONFIGRET
CM_Get_Depth_Ex(
    OUT PULONG   pulDepth,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the depth of a device instance in the
   hardware tree.

Parameters:

   pulDepth    Supplies the address of the variable that receives the
               depth of the device instance.  This value is 0 to designate
               the root of the tree, 1 to designate a child of the root,
               and so on.

   dnDevNode   Supplies the handle of a device instance.

   ulFlags     Must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG, or
      CR_INVALID_POINTER.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    ULONG       ulLen = MAX_DEVICE_ID_LEN;
    BOOL        Success;

    try {
        //
        // validate parameters
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulDepth)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retrieve the device instance ID string associated with the devinst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetDepth(
                hBinding,     // rpc binding handle
                pDeviceID,    // device instance
                pulDepth,     // returns the depth
                ulFlags);     // not used
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetDepth caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Depth



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Locate_DevNodeW(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_W pDeviceID,       OPTIONAL
    IN  ULONG       ulFlags
    )
{
    return CM_Locate_DevNode_ExW(pdnDevInst, pDeviceID, ulFlags, NULL);
}


CONFIGRET
CM_Locate_DevNodeA(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_A pDeviceID,       OPTIONAL
    IN  ULONG       ulFlags
    )
{
    return CM_Locate_DevNode_ExA(pdnDevInst, pDeviceID, ulFlags, NULL);
}


CONFIGRET
CM_Get_Parent(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags
    )
{
    return CM_Get_Parent_Ex(pdnDevInst, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Child(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags
    )
{
    return CM_Get_Child_Ex(pdnDevInst, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Sibling(
    OUT PDEVINST pdnDevInst,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags
    )
{
    return CM_Get_Sibling_Ex(pdnDevInst, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_Size(
    OUT PULONG  pulLen,
    IN  DEVINST dnDevInst,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_Size_Ex(pulLen, dnDevInst, ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_IDW(
    IN  DEVINST dnDevInst,
    OUT PWCHAR  Buffer,
    IN  ULONG   BufferLen,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_ExW(dnDevInst, Buffer, BufferLen, ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_IDA(
    IN  DEVINST dnDevInst,
    OUT PCHAR   Buffer,
    IN  ULONG   BufferLen,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_ExA(dnDevInst, Buffer, BufferLen, ulFlags, NULL);
}


CONFIGRET
CM_Enumerate_EnumeratorsW(
    IN ULONG      ulEnumIndex,
    OUT PWCHAR    Buffer,
    IN OUT PULONG pulLength,
    IN ULONG      ulFlags
    )
{
    return CM_Enumerate_Enumerators_ExW(ulEnumIndex, Buffer, pulLength,
                                        ulFlags, NULL);
}


CONFIGRET
CM_Enumerate_EnumeratorsA(
    IN ULONG      ulEnumIndex,
    OUT PCHAR     Buffer,
    IN OUT PULONG pulLength,
    IN ULONG      ulFlags
    )
{
    return CM_Enumerate_Enumerators_ExA(ulEnumIndex, Buffer, pulLength,
                                        ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_ListW(
    IN PCWSTR  pszFilter,    OPTIONAL
    OUT PWCHAR Buffer,
    IN ULONG   BufferLen,
    IN ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_List_ExW(pszFilter, Buffer, BufferLen,
                                     ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_ListA(
    IN PCSTR   pszFilter,    OPTIONAL
    OUT PCHAR  Buffer,
    IN ULONG   BufferLen,
    IN ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_List_ExA(pszFilter, Buffer, BufferLen,
                                     ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_List_SizeW(
    OUT PULONG pulLen,
    IN PCWSTR  pszFilter,   OPTIONAL
    IN ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_List_Size_ExW(pulLen, pszFilter, ulFlags, NULL);
}


CONFIGRET
CM_Get_Device_ID_List_SizeA(
    OUT PULONG pulLen,
    IN PCSTR   pszFilter,   OPTIONAL
    IN ULONG   ulFlags
    )
{
    return CM_Get_Device_ID_List_Size_ExA(pulLen, pszFilter, ulFlags, NULL);
}


CONFIGRET
CM_Get_Depth(
    OUT PULONG   pulDepth,
    IN  DEVINST  dnDevInst,
    IN  ULONG    ulFlags
    )
{
    return CM_Get_Depth_Ex(pulDepth, dnDevInst, ulFlags, NULL);
}



//-------------------------------------------------------------------
// ANSI STUBS
//-------------------------------------------------------------------


CONFIGRET
CM_Locate_DevNode_ExA(
    OUT PDEVINST    pdnDevInst,
    IN  DEVINSTID_A pDeviceID,    OPTIONAL
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;


    if (!ARGUMENT_PRESENT(pDeviceID)) {
        //
        // If the DEVINSTID parameter is NULL, then no conversion is necessary,
        // just call the wide version
        //
        Status = CM_Locate_DevNode_ExW(pdnDevInst,
                                       NULL,
                                       ulFlags,
                                       hMachine);
    } else {
        //
        // if a device id string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        PWSTR pUniDeviceID = NULL;

        if (pSetupCaptureAndConvertAnsiArg(pDeviceID, &pUniDeviceID) == NO_ERROR) {

            Status = CM_Locate_DevNode_ExW(pdnDevInst,
                                           pUniDeviceID,
                                           ulFlags,
                                           hMachine);

            pSetupFree(pUniDeviceID);

        } else {
            Status = CR_INVALID_DEVICE_ID;
        }
    }

    return Status;

} // CM_Locate_DevNode_ExA



CONFIGRET
CM_Get_Device_ID_ExA(
    IN  DEVINST  dnDevInst,
    OUT PCHAR    Buffer,
    IN  ULONG    BufferLen,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     UniBuffer[MAX_DEVICE_ID_LEN];
    ULONG     ulAnsiBufferLen;

    //
    // validate essential parameters only
    //
    if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode buffer as a parameter
    //
    Status = CM_Get_Device_ID_ExW(dnDevInst,
                                  UniBuffer,
                                  MAX_DEVICE_ID_LEN,
                                  ulFlags,
                                  hMachine);

    //
    // We should never return a DeviceId longer than MAX_DEVICE_ID_LEN.
    //
    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // if the call succeeded, convert the device id to ansi before returning
        //
        ulAnsiBufferLen = BufferLen;
        Status = PnPUnicodeToMultiByte(UniBuffer,
                                       (lstrlenW(UniBuffer)+1)*sizeof(WCHAR),
                                       Buffer,
                                       &ulAnsiBufferLen);
    }

    return Status;

} // CM_Get_Device_ID_ExA




CONFIGRET
CM_Enumerate_Enumerators_ExA(
    IN ULONG      ulEnumIndex,
    OUT PCHAR     Buffer,
    IN OUT PULONG pulLength,
    IN ULONG      ulFlags,
    IN HMACHINE   hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    WCHAR     UniBuffer[MAX_DEVICE_ID_LEN];
    ULONG     UniLen = MAX_DEVICE_ID_LEN;

    //
    // validate parameters
    //
    if ((!ARGUMENT_PRESENT(Buffer)) ||
        (!ARGUMENT_PRESENT(pulLength))) {
        return CR_INVALID_POINTER;
    }

    //
    // call the wide version, passing a unicode buffer as a parameter
    //
    Status = CM_Enumerate_Enumerators_ExW(ulEnumIndex,
                                          UniBuffer,
                                          &UniLen,
                                          ulFlags,
                                          hMachine);

    ASSERT(Status != CR_BUFFER_SMALL);

    if (Status == CR_SUCCESS) {
        //
        // convert the unicode buffer to an ansi string and copy to the caller's
        // buffer
        //
        Status = PnPUnicodeToMultiByte(UniBuffer,
                                       (lstrlenW(UniBuffer)+1)*sizeof(WCHAR),
                                       Buffer,
                                       pulLength);
    }

    return Status;

} // CM_Enumerate_Enumerators_ExA



CONFIGRET
CM_Get_Device_ID_List_ExA(
      IN PCSTR    pszFilter,    OPTIONAL
      OUT PCHAR   Buffer,
      IN ULONG    BufferLen,
      IN ULONG    ulFlags,
      IN HMACHINE hMachine
      )
{
    CONFIGRET Status = CR_SUCCESS;
    PWSTR     pUniBuffer, pUniFilter = NULL;
    ULONG     ulAnsiBufferLen;

    //
    // validate input parameters
    //
    if ((!ARGUMENT_PRESENT(Buffer)) || (BufferLen == 0)) {
        return CR_INVALID_POINTER;
    }

    if (ARGUMENT_PRESENT(pszFilter)) {
        //
        // if a filter string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        if (pSetupCaptureAndConvertAnsiArg(pszFilter, &pUniFilter) != NO_ERROR) {
            return CR_INVALID_DATA;
        }
        ASSERT(pUniFilter != NULL);
    } else {
        ASSERT(pUniFilter == NULL);
    }

    //
    // prepare a larger buffer to hold the unicode formatted
    // multi_sz data returned by CM_Get_Device_ID_List.
    //
    pUniBuffer = pSetupMalloc(BufferLen*sizeof(WCHAR));
    if (pUniBuffer == NULL) {
        Status = CR_OUT_OF_MEMORY;
        goto Clean0;
    }

    *pUniBuffer = L'\0';

    //
    // call the wide version
    //
    Status = CM_Get_Device_ID_List_ExW(pUniFilter,
                                       pUniBuffer,
                                       BufferLen,   // size in chars
                                       ulFlags,
                                       hMachine);
    if (Status == CR_SUCCESS) {
        //
        // if the call succeeded, must convert the multi_sz list to ansi before
        // returning
        //
        ulAnsiBufferLen = BufferLen;
        Status = PnPUnicodeToMultiByte(pUniBuffer,
                                       BufferLen*sizeof(WCHAR),
                                       Buffer,
                                       &ulAnsiBufferLen);
    }

    pSetupFree(pUniBuffer);

 Clean0:

    if (pUniFilter) {
        pSetupFree(pUniFilter);
    }

    return Status;

} // CM_Get_Device_ID_List_ExA



CONFIGRET
CM_Get_Device_ID_List_Size_ExA(
    OUT PULONG  pulLen,
    IN PCSTR    pszFilter,   OPTIONAL
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )
{
    CONFIGRET Status = CR_SUCCESS;
    ULONG     UniLen = MAX_DEVICE_ID_LEN;


    if (!ARGUMENT_PRESENT(pszFilter)) {
        //
        // If the filter parameter is NULL, then no conversion is necessary,
        // just call the wide version
        //
        Status = CM_Get_Device_ID_List_Size_ExW(pulLen,
                                                NULL,
                                                ulFlags,
                                                hMachine);
    } else {
        //
        // if a filter string was passed in, convert to UNICODE before
        // passing on to the wide version
        //
        PWSTR pUniFilter = NULL;

        if (pSetupCaptureAndConvertAnsiArg(pszFilter, &pUniFilter) == NO_ERROR) {

            Status = CM_Get_Device_ID_List_Size_ExW(pulLen,
                                                    pUniFilter,
                                                    ulFlags,
                                                    hMachine);
            pSetupFree(pUniFilter);

        } else {
            Status = CR_INVALID_DATA;
        }
    }

    return Status;

} // CM_Get_Device_ID_List_Size_ExA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\resdes.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    resdes.c

Abstract:

    This module contains the API routines that operate directly on resource
    descriptions.

               CM_Add_Res_Des
               CM_Free_Res_Des
               CM_Get_Next_Res_Des
               CM_Get_Res_Des_Data
               CM_Get_Res_Des_Data_Size
               CM_Modify_Res_Des
               CM_Detect_Resource_Conflict
               CM_Free_Res_Des_Handle

Author:

    Paula Tomlinson (paulat) 9-26-1995

Environment:

    User mode only.

Revision History:

    26-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"

//
// Private prototypes
//
CONFIGRET
CreateResDesHandle(
    PRES_DES    prdResDes,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag,
    ULONG       ulResType,
    ULONG       ulResTag
    );

BOOL
ValidateResDesHandle(
    PPrivate_Res_Des_Handle    pResDes
    );

CONFIGRET
Get32bitResDesFrom64bitResDes(
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResData64,
    IN  ULONG      ResLen64,
    OUT PVOID    * ResData32,
    OUT ULONG    * ResLen32
    );

CONFIGRET
Convert32bitResDesTo64bitResDes(
    IN     RESOURCEID ResourceID,
    IN OUT PVOID      ResData,
    IN     ULONG      ResLen
    );

CONFIGRET
Convert32bitResDesSizeTo64bitResDesSize(
    IN     RESOURCEID ResourceID,
    IN OUT PULONG     ResLen
    );

//
// private prototypes from logconf.c
//
CONFIGRET
CreateLogConfHandle(
    PLOG_CONF   plcLogConf,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag
    );

BOOL
ValidateLogConfHandle(
    PPrivate_Log_Conf_Handle   pLogConf
    );




CONFIGRET
CM_Add_Res_Des_Ex(
    OUT PRES_DES  prdResDes,
    IN LOG_CONF   lcLogConf,
    IN RESOURCEID ResourceID,
    IN PCVOID     ResourceData,
    IN ULONG      ResourceLen,
    IN ULONG      ulFlags,
    IN HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine adds a resource descriptor to a logical configuration.

Parameters:

   prdResDes   Address of a variable that receives a handle for the new
               resource descriptor.

   lcLogConf   Supplies the handle of the logical configuration to which
               the resource descriptor is added.

   ResourceID  Specifies the type of the resource.  Can be one of the
               ResType values defined in Section 2.1..

   ResourceData Supplies the address of an IO_DES, MEM_DES, DMA_DES, or
               IRQ_DES structure, depending on the given resource type.

   ResourceLen Supplies the size, in bytes, of the structure pointed to
               by ResourceData.

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data supplied is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_LOG_CONF,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_RESOURCE_ID,
         CR_OUT_OF_MEMORY.

--*/


{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulResTag, ulLogTag, ulLogType,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    PVOID       ResourceData32 = NULL;
    ULONG       ResourceLen32 = 0;

    try {
        //
        // validate parameters
        //
        if (!ValidateLogConfHandle((PPrivate_Log_Conf_Handle)lcLogConf)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        if (ResourceData == NULL || ResourceLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        #if 0
        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }
        #endif

        if (ResourceID == ResType_All) {
            Status = CR_INVALID_RESOURCEID;  // can't specify All on an add
        }

        //
        // Initialize parameters
        //
        if (prdResDes != NULL) {   // prdResDes is optional param
            *prdResDes = 0;
        }

        //
        // extract info from the log conf handle
        //
        dnDevInst = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_DevInst;
        ulLogType = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfType;
        ulLogTag  = ((PPrivate_Log_Conf_Handle)lcLogConf)->LC_LogConfTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Server can only support 32-bit resdes.  Have the client
                // convert the caller's 64-bit resdes to a 32-bit resdes for the
                // server.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;

                Status = Get32bitResDesFrom64bitResDes(ResourceID,ResourceData,ResourceLen,&ResourceData32,&ResourceLen32);
                if(Status != CR_SUCCESS) {
                    goto Clean0;
                }
                if(ResourceData32) {
                    ResourceData = ResourceData32;
                    ResourceLen = ResourceLen32;
                }
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_AddResDes(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ResourceID,             // resource type
                &ulResTag,              // resource tag
                (LPBYTE)ResourceData,   // actual res des data
                ResourceLen,            // size in bytes of ResourceData
                ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_AddResDes caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS  &&  prdResDes != NULL) {

            Status = CreateResDesHandle(prdResDes,
                                        dnDevInst,
                                        ulLogType,
                                        ulLogTag,
                                        ResourceID,
                                        ulResTag);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if(ResourceData32) {
        pSetupFree(ResourceData32);
    }

    return Status;

} // CM_Add_Res_Des_Ex




CONFIGRET
CM_Free_Res_Des_Ex(
    OUT PRES_DES prdResDes,
    IN  RES_DES  rdResDes,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine destroys a resource descriptor. This API returns
   CR_NO_MORE_RES_DES if rdResDes specifies the last resource descriptor.

Parameters:

   prdResDes   Supplies the address of the variable that receives the
               handle of the previous resource descriptor.  If rdResDes
               is the handle of the first resource descriptor, this
               address receives the handle of the logical configuration.

   rdResDes    Supplies the handle of the resource descriptor to be destroyed.

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_RES_DES,
         CR_NO_MORE_RES_DES.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR      pDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulLogType, ulLogTag, ulResType, ulResTag,ulLen=MAX_DEVICE_ID_LEN;
    ULONG       ulPreviousResType = 0, ulPreviousResTag = 0;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Initialize parameters
        //
        if (prdResDes != NULL) {  // optional parameter
            *prdResDes = 0;
        }

        //
        // extract info from the res des handle
        //
        dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
        ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
        ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
        ulResType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResourceType;
        ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_FreeResDes(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ulResType,              // resource type
                ulResTag,               // resource tag
                &ulPreviousResType,     // resource type of previous res des
                &ulPreviousResTag,      // tag of previous res des
                ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_FreeResDes caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS && Status != CR_NO_MORE_RES_DES) {
            goto Clean0;       // quit for any other error
        }

        //
        // if prdResDes supplied, fill in with previous res des or
        // the log conf info
        //
        if (prdResDes != NULL) {
            //
            // if the previous tag value is set to 0xFFFFFFFF, then
            // there are no previous tages so return the log conf
            // info instead
            //
            if (Status == CR_NO_MORE_RES_DES) {

                CONFIGRET Status1;

                Status1 = CreateLogConfHandle(prdResDes, dnDevInst,
                                              ulLogType, ulLogTag);

                if (Status1 != CR_SUCCESS) {
                    Status = Status1;
                }
            }

            else {
                //
                // allocate a res des handle
                //
                Status = CreateResDesHandle(prdResDes, dnDevInst,
                                            ulLogType, ulLogTag,
                                            ulPreviousResType,
                                            ulPreviousResTag);
            }
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Res_Des_Ex



CONFIGRET
CM_Get_Next_Res_Des_Ex(
    OUT PRES_DES    prdResDes,
    IN  RES_DES     rdResDes,
    IN  RESOURCEID  ForResource,
    OUT PRESOURCEID pResourceID,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )

/*++

Routine Description:

   This routine returns the handle of the next resource descriptor in
   a logical configuration.

Parameters:

   prdResDes   Supplies the address of the variable that receives the
               handle of the next resource descriptor.

   rdResDes    Supplies the handle of the current resource
               descriptor or the handle of a logical configuration.
               (Both are 32-bit numbers--Configuration Manager must can
               distinguish between them.)

   ForResource Specifies the type of the resource to retrieve.  Can be
               one of the ResType values listed in Section 2.1..

   pResourceID Supplies the address of the variable that receives the
               resource type, when ForResource specifies ResType_All.
               (When ForResource is not ResType_All, this parameter can
               be NULL.)

   ulFlags     Must be zero.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_LOG_CONF,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_RES_DES,
         CR_NO_MORE_RES_DES.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLogTag, ulLogType, ulResTag,ulLen = MAX_DEVICE_ID_LEN;
    ULONG       ulNextResType = 0, ulNextResTag = 0;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;


    try {
        //
        // validate parameters
        //
        if (prdResDes == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        #if 0
        if (ForResource > ResType_MAX  &&
            ForResource != ResType_ClassSpecific) {

            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }
        #endif
        if (ForResource == ResType_All  &&  pResourceID == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // this handle could be a res des or a log conf, determine
        // which and extract info handle
        //
        if (ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            //
            // it was a valid res des handle
            //
            dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
            ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
            ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
            ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;
        }

        else if (ValidateLogConfHandle((PPrivate_Log_Conf_Handle)rdResDes)) {
            //
            // it was a valid log conf handle, so assume it's the first
            // res des we want
            //
            dnDevInst = ((PPrivate_Log_Conf_Handle)rdResDes)->LC_DevInst;
            ulLogType = ((PPrivate_Log_Conf_Handle)rdResDes)->LC_LogConfType;
            ulLogTag  = ((PPrivate_Log_Conf_Handle)rdResDes)->LC_LogConfTag;
            ulResTag  = MAX_RESDES_TAG;
        }

        else {
            //
            // it was neither a valid log conf nor a valid res des handle
            //
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetNextResDes(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ForResource,            // resource type
                ulResTag,               // resource tag
                &ulNextResTag,          // next res des of type ForResource
                &ulNextResType,         // type of next res des
                ulFlags);               // 32/64 bit data
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetNextResDes caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        if (ForResource == ResType_All) {
            *pResourceID = ulNextResType;
        }

        Status = CreateResDesHandle(prdResDes,
                                    dnDevInst,
                                    ulLogType,
                                    ulLogTag,
                                    ulNextResType,
                                    ulNextResTag);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Next_Res_Des_Ex



CONFIGRET
CM_Get_Res_Des_Data_Ex(
    IN  RES_DES  rdResDes,
    OUT PVOID    Buffer,
    IN  ULONG    BufferLen,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine copies the data from a specified resource descriptor
   into a buffer.  Use the CM_Get_Res_Des_Data_Size API to determine
   the buffer size needed to receive the data.  Alternately, set a
   size that is at least as large as the maximum possible size of the
   resource.  If the size given is too small, the data is truncated and
   the API returns CR_BUFFER_SMALL.

Parameters:

   rdResDes    Supplies the handle of the resource descriptor from which
               data is to be copied.

   Buffer      Supplies the address of the buffer that receives the data.

   BufferLen   Supplies the size of the buffer, in bytes.

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data expected is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_INVALID_RES_DES,
         CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLogType, ulLogTag, ulResType, ulResTag,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    BOOL        ConvertResDes = FALSE;

    try {
        //
        // validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        if (Buffer == NULL || BufferLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        //
        // extract info from the res des handle
        //
        dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
        ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
        ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
        ulResType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResourceType;
        ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Client will only give us 32-bit resdes.  Request a 32-bit
                // resdes from the server, and we'll convert it to 64-bit here
                // on the client.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;
                ConvertResDes = TRUE;
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetResDesData(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ulResType,              // resource type
                ulResTag,               // resource tag
                Buffer,                 // return res des data
                BufferLen,              // size in bytes of Buffer
                ulFlags);               // 32/64 bit data
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetResDesData caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if((Status == CR_SUCCESS) && ConvertResDes) {
            Status = Convert32bitResDesTo64bitResDes(ulResType,Buffer,BufferLen);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Res_Des_Data_Ex



CONFIGRET
CM_Get_Res_Des_Data_Size_Ex(
    OUT PULONG   pulSize,
    IN  RES_DES  rdResDes,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )

/*++

Routine Description:

   This routine retrieves the size of a resource descriptor, not
   including the resource descriptor header.

Parameters:

   pulSize     Supplies the address of the variable that receives the
               size, in bytes, of the resource descriptor data.

   rdResDes    Supplies the handle of the resource descriptor for which
               to retrieve the size.

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data expected is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_RES_DES,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLogType, ulLogTag, ulResType, ulResTag,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    BOOL        ConvertResDesSize = FALSE;


    try {
        //
        // validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        if (pulSize == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        //
        // Initialize output parameters
        //
        *pulSize = 0;

        //
        // extract info from the res des handle
        //
        dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
        ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
        ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
        ulResType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResourceType;
        ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Server only supports 32-bit resdes.  Request a 32-bit
                // resdes size from the server, and we'll convert it to 64-bit here
                // on the client.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;
                ConvertResDesSize = TRUE;
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_GetResDesDataSize(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ulResType,              // resource type
                ulResTag,               // resource tag
                pulSize,                // returns size of res des data
                ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetResDesDataSize caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if(Status == CR_SUCCESS) {
            Status = Convert32bitResDesSizeTo64bitResDesSize(ulResType,pulSize);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Get_Res_Des_Data_Size_Ex



CONFIGRET
CM_Modify_Res_Des_Ex(
    OUT PRES_DES   prdResDes,
    IN  RES_DES    rdResDes,
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResourceData,
    IN  ULONG      ResourceLen,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )

/*++

Routine Description:

   This routine modifies a resource descriptor. This API retrieves a
   handle to the new resource descriptor.  This may or may not be the
   handle of the original resource descriptor.  The original resource
   descriptor handle is invalid after calling this API.

Parameters:

   prdResDes   Supplies the address of the variable that receives the
               handle of the modified resource descriptor.

   rdResDes    Supplies the handle of the resource descriptor to be
               modified.

   ResourceID  Specifies the type of resource to modify.  Can be one
               of the ResType values described in Section 2.1..

   ResourceData  Supplies the address of a resource data structure.

   ResourceLen Supplies the size, in bytes, of the new resource data
               structure.  This size can be different from the size of
               the original resource data.

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data supplied is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_RES_DES,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    DEVINST     dnDevInst;
    WCHAR       pDeviceID [MAX_DEVICE_ID_LEN];
    ULONG       ulLogType, ulLogTag, ulResType, ulResTag,ulLen = MAX_DEVICE_ID_LEN;
    PVOID       hStringTable = NULL;
    handle_t    hBinding = NULL;
    BOOL        Success;
    PVOID       ResourceData32 = NULL;
    ULONG       ResourceLen32 = 0;

    try {
        //
        // validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        if (prdResDes == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        #if 0
        if (ResourceID > ResType_MAX  && ResourceID != ResType_ClassSpecific) {
            Status = CR_INVALID_RESOURCEID;
            goto Clean0;
        }
        #endif
        if (ResourceData == NULL  ||  ResourceLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

#ifdef _WIN64
        if ((ulFlags & CM_RESDES_WIDTH_BITS) == CM_RESDES_WIDTH_DEFAULT) {
            ulFlags |= CM_RESDES_WIDTH_64;
        }
#endif // _WIN64

        if (ulFlags & CM_RESDES_WIDTH_32) {
            ulFlags &= ~CM_RESDES_WIDTH_BITS;
        }

        //
        // initialize output parameters
        //
        *prdResDes = 0;

        //
        // extract info from the res des handle
        //
        dnDevInst = ((PPrivate_Res_Des_Handle)rdResDes)->RD_DevInst;
        ulLogType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfType;
        ulLogTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_LogConfTag;
        ulResType = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResourceType;
        ulResTag  = ((PPrivate_Res_Des_Handle)rdResDes)->RD_ResDesTag;

        //
        // setup rpc binding handle and string table handle
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Make sure the server can support the client's 64-bit resdes request.
        // Only server versions 0x0501 and greater support CM_RESDES_WIDTH_64.
        //
        if (ulFlags & CM_RESDES_WIDTH_64) {
            if (!CM_Is_Version_Available_Ex((WORD)0x0501,
                                            hMachine)) {
                //
                // Server can only support 32-bit resdes.  Have the client
                // convert the caller's 64-bit resdes to a 32-bit resdes for the
                // server.
                //
                ulFlags &= ~CM_RESDES_WIDTH_BITS;

                Status = Get32bitResDesFrom64bitResDes(ResourceID,ResourceData,ResourceLen,&ResourceData32,&ResourceLen32);
                if(Status != CR_SUCCESS) {
                    goto Clean0;
                }
                if(ResourceData32) {
                    ResourceData = ResourceData32;
                    ResourceLen = ResourceLen32;
                }
            }
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        //
        Success = pSetupStringTableStringFromIdEx(hStringTable, dnDevInst,pDeviceID,&ulLen);
        if (Success == FALSE || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        RpcTryExcept {
            //
            // call rpc service entry point
            //
            Status = PNP_ModifyResDes(
                hBinding,               // rpc binding handle
                pDeviceID,              // device id string
                ulLogTag,               // log conf tag
                ulLogType,              // log conf type
                ulResType,              // current resource type
                ResourceID,             // new resource type
                ulResTag,               // resource tag
                (LPBYTE)ResourceData,   // actual res des data
                ResourceLen,            // size in bytes of ResourceData
                ulFlags);               // currently zero
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_ModifyResDes caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
        }
        RpcEndExcept

        if (Status == CR_SUCCESS) {
            //
            // The resource type may change so a new handle is required and
            // returned to caller.
            //
            Status = CreateResDesHandle(prdResDes,
                                        dnDevInst,
                                        ulLogType,
                                        ulLogTag,
                                        ResourceID,
                                        ulResTag);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if(ResourceData32) {
        pSetupFree(ResourceData32);
    }
    return Status;

} // CM_Modify_Res_Des_Ex



CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict_Ex(
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,         OPTIONAL
    IN  PCVOID     ResourceData,       OPTIONAL
    IN  ULONG      ResourceLen,        OPTIONAL
    OUT PBOOL      pbConflictDetected,
    IN  ULONG      ulFlags,
    IN  HMACHINE   hMachine
    )
/*++

Routine Description:

   This depreciated routine calls CM_Query_Resource_Conflict_List to see if
   dnDevInst is conflicting with any other devices. It is used for a simple
   "has a conflict" check. CM_Query_Resource_Conflict_List returns more
   details of the conflicts.

Parameters:

   dnDevInst   DEVINST we're doing the test for (ie, that resource belongs to)

   ResourceID,ResourceData,ResourceLen
               See if this resource conflicts with a device other than dnDevInst

   pbConflictDetected
               Set to TRUE on conflict, FALSE if no conflict

   ulFlags     Specifies the width of certain variable-size resource
               descriptor structure fields, where applicable.

               Currently, the following flags are defined:

                 CM_RESDES_WIDTH_32 or
                 CM_RESDES_WIDTH_64

               If no flags are specified, the width of the variable-sized
               resource data supplied is assumed to be that native to the
               platform of the caller.

   hMachine    Machine handle returned from CM_Connect_Machine or NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_RES_DES,
         CR_INVALID_FLAG,
         CR_INVALID_POINTER,
         CR_OUT_OF_MEMORY.

--*/
{
    CONFIGRET     Status = CR_SUCCESS;
    CONFLICT_LIST ConflictList = 0;
    ULONG         ConflictCount = 0;
    WCHAR         pDeviceID [MAX_DEVICE_ID_LEN];  // )
    PVOID         hStringTable = NULL;            // > for validation only
    handle_t      hBinding = NULL;                // )
    ULONG         ulLen = MAX_DEVICE_ID_LEN;      // )

    try {
        //
        // validate parameters - must maintain compatability with original implementation
        // even though some of the error codes don't make sense
        // don't change any of the parameters here, as they are needed for
        // CM_Query_Resource_Conflict_List
        //
        if (dnDevInst == 0) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((ulFlags & CM_RESDES_WIDTH_32) && (ulFlags & CM_RESDES_WIDTH_64)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (pbConflictDetected == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        if (ResourceData == NULL || ResourceLen == 0) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }
        if (ResourceID == ResType_All) {
            Status = CR_INVALID_RESOURCEID;  // can't specify All on a detect
            goto Clean0;
        }
        //
        // setup rpc binding handle and string table handle - for validation only
        //
        if (!PnPGetGlobalHandles(hMachine, &hStringTable, &hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // retreive device instance string that corresponds to dnDevInst
        // stupid status code for this check, but someone may rely on it
        //
        if ((pSetupStringTableStringFromIdEx(hStringTable,dnDevInst,pDeviceID,&ulLen) == FALSE)
             || INVALID_DEVINST(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }
        //
        // now implement via CM_Query_Resource_Conflict_List
        // the only difference here is that this new implementation should return
        // only valid conflicts
        //
        Status = CM_Query_Resource_Conflict_List(&ConflictList,
                                                 dnDevInst,
                                                 ResourceID,
                                                 ResourceData,
                                                 ResourceLen,
                                                 ulFlags,
                                                 hMachine);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        Status = CM_Get_Resource_Conflict_Count(ConflictList,&ConflictCount);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        *pbConflictDetected = ConflictCount ? TRUE : FALSE;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (ConflictList) {
        CM_Free_Resource_Conflict_Handle(ConflictList);
    }

    return Status;

} // CM_Detect_Resource_Conflict



CONFIGRET
CM_Free_Res_Des_Handle(
    IN  RES_DES    rdResDes
    )

/*++

Routine Description:

   This routine frees the handle to the specified res des and frees and
   memory associated with that res des handle.

Parameters:


   rdResDes    Supplies the handle of the resource descriptor.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_RES_DES.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;


    try {
        //
        // Validate parameters
        //
        if (!ValidateResDesHandle((PPrivate_Res_Des_Handle)rdResDes)) {
            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //
        // It's a valid log conf handle, which is a pointer to memory
        // allocated when the log conf was created or retrieved using
        // the first/next routines. Free the associated memory.
        //
        ((PPrivate_Res_Des_Handle)rdResDes)->RD_Signature = 0;
        pSetupFree((PPrivate_Res_Des_Handle)rdResDes);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // CM_Free_Res_Des_Handle



//-------------------------------------------------------------------
// Local Stubs
//-------------------------------------------------------------------


CONFIGRET
CM_Add_Res_Des(
    OUT PRES_DES  prdResDes,
    IN LOG_CONF   lcLogConf,
    IN RESOURCEID ResourceID,
    IN PCVOID     ResourceData,
    IN ULONG     ResourceLen,
    IN ULONG     ulFlags
    )
{
    return CM_Add_Res_Des_Ex(prdResDes, lcLogConf, ResourceID, ResourceData,
                             ResourceLen, ulFlags, NULL);
}


CONFIGRET
CM_Free_Res_Des(
    OUT PRES_DES prdResDes,
    IN  RES_DES  rdResDes,
    IN  ULONG    ulFlags
    )
{
    return CM_Free_Res_Des_Ex(prdResDes, rdResDes, ulFlags, NULL);
}


CONFIGRET
CM_Get_Next_Res_Des(
    OUT PRES_DES    prdResDes,
    IN  RES_DES     rdResDes,
    IN  RESOURCEID  ForResource,
    OUT PRESOURCEID pResourceID,
    IN  ULONG       ulFlags
    )
{
   return CM_Get_Next_Res_Des_Ex(prdResDes, rdResDes, ForResource,
                                 pResourceID, ulFlags, NULL);
}


CONFIGRET
CM_Get_Res_Des_Data(
    IN  RES_DES rdResDes,
    OUT PVOID   Buffer,
    IN  ULONG   BufferLen,
    IN  ULONG   ulFlags
    )
{
    return CM_Get_Res_Des_Data_Ex(rdResDes, Buffer, BufferLen, ulFlags, NULL);
}


CONFIGRET
CM_Get_Res_Des_Data_Size(
    OUT PULONG  pulSize,
    IN  RES_DES rdResDes,
    IN  ULONG  ulFlags
    )
{
    return CM_Get_Res_Des_Data_Size_Ex(pulSize, rdResDes, ulFlags, NULL);
}


CONFIGRET
CM_Modify_Res_Des(
    OUT PRES_DES   prdResDes,
    IN  RES_DES    rdResDes,
    IN  RESOURCEID ResourceID,
    IN  PCVOID     ResourceData,
    IN  ULONG      ResourceLen,
    IN  ULONG      ulFlags
    )
{
   return CM_Modify_Res_Des_Ex(prdResDes, rdResDes, ResourceID, ResourceData,
                               ResourceLen, ulFlags, NULL);
}


CONFIGRET
WINAPI
CM_Detect_Resource_Conflict(
    IN  DEVINST    dnDevInst,
    IN  RESOURCEID ResourceID,         OPTIONAL
    IN  PCVOID     ResourceData,       OPTIONAL
    IN  ULONG      ResourceLen,        OPTIONAL
    OUT PBOOL      pbConflictDetected,
    IN  ULONG      ulFlags
    )
{
    return CM_Detect_Resource_Conflict_Ex(dnDevInst, ResourceID, ResourceData,
                                          ResourceLen, pbConflictDetected,
                                          ulFlags, NULL);
}



//-------------------------------------------------------------------
// Local Utility Routines
//-------------------------------------------------------------------


CONFIGRET
CreateResDesHandle(
    PRES_DES    prdResDes,
    DEVINST     dnDevInst,
    ULONG       ulLogType,
    ULONG       ulLogTag,
    ULONG       ulResType,
    ULONG       ulResTag
    )
{
    PPrivate_Res_Des_Handle pResDesHandle;

    //
    // allocate memory for the res des handle data
    //
    pResDesHandle = (PPrivate_Res_Des_Handle)pSetupMalloc(
                            sizeof(Private_Res_Des_Handle));

    if (pResDesHandle == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    //
    // fill in the private res des info and return as handle
    //
    pResDesHandle->RD_Signature    = CM_PRIVATE_RESDES_SIGNATURE;
    pResDesHandle->RD_DevInst      = dnDevInst;
    pResDesHandle->RD_LogConfType  = ulLogType;
    pResDesHandle->RD_LogConfTag   = ulLogTag;
    pResDesHandle->RD_ResourceType = ulResType;
    pResDesHandle->RD_ResDesTag    = ulResTag;

    *prdResDes = (RES_DES)pResDesHandle;

    return CR_SUCCESS;

} // CreateResDesHandle



BOOL
ValidateResDesHandle(
    PPrivate_Res_Des_Handle    pResDes
    )
{
    //
    // validate parameters
    //
    if (pResDes == NULL  || pResDes == 0) {
        return FALSE;
    }

    //
    // check for the private log conf signature
    //
    if (pResDes->RD_Signature != CM_PRIVATE_RESDES_SIGNATURE) {
        return FALSE;
    }

    return TRUE;

} // ValidateResDesHandle



CONFIGRET
Convert32bitResDesSizeTo64bitResDesSize(
    IN  RESOURCEID ResourceID,
    IN OUT PULONG ResLen
    )
/*++

Routine Description:

   This routine resizes ResLen for ResourceID
   old structure: [DES32][RANGE32][RANGE32]...
   new structure: [DES64 ][RANGE64 ][RANGE 64]...
   #elements = (len-sizeof(DES32))/sizeof(RANGE32)
   new len = sizeof(DES64)+#elements*sizeof(RANGE64)
   (+ allow for alignment issues)

Parameters:

   ResourceID - type of resource to adjust
   ResLen     - adjusted resource length

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.

--*/
{
    switch(ResourceID) {
    case ResType_All:
    case ResType_Mem:
    case ResType_IO:
    case ResType_DMA:
    case ResType_BusNumber:
        //
        // no change in resource size
        //
        return CR_SUCCESS;

    case ResType_IRQ:
        //
        // header only
        // use offsetof to handle non-obvious structure alignment padding
        //
        *ResLen += offsetof(IRQ_RESOURCE_64,IRQ_Data)-offsetof(IRQ_RESOURCE_32,IRQ_Data);
        return CR_SUCCESS;

    default:
        //
        // unknown resource
        // shouldn't be a problem as this is for downlevel platforms
        //
        ASSERT(ResourceID & ResType_Ignored_Bit);
        return CR_SUCCESS;
    }
}



CONFIGRET
Get32bitResDesFrom64bitResDes(
    IN  RESOURCEID ResourceID,
    IN  PCVOID ResData64,
    IN  ULONG ResLen64,
    OUT PVOID * ResData32,
    OUT ULONG * ResLen32
    )
/*++

Routine Description:

   This routine allocates ResData32 and converts ResData64 into ResData32 if needed
   In the cases where no conversion is required, CR_SUCCESS is returned and
   ResData32 is NULL.
   In the cases where conversion is required, ResData32 holds new data

   old structure: [DES64 ][RANGE64 ][RANGE 64]...
   new structure: [DES32][RANGE32][RANGE32]...
   #elements from 64-bit structure
   new len = sizeof(DES32)+#elements*sizeof(RANGE32)
   (+ allow for alignment issues)

Parameters:

   ResourceID - type of resource to adjust
   ResData64  - incoming data to convert (constant buffer)
   ResLen64   - incoming length of data
   ResData32  - converted data (if non-NULL)
   ResLen32   - converted length

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.

--*/
{
    *ResData32 = NULL;
    *ResLen32 = ResLen64;

    switch(ResourceID) {
    case ResType_All:
    case ResType_Mem:
    case ResType_IO:
    case ResType_DMA:
    case ResType_BusNumber:
        //
        // no change in resource structure
        //
        return CR_SUCCESS;

    case ResType_IRQ:
        {
            PIRQ_RESOURCE_64 pIrq64 = (PIRQ_RESOURCE_64)ResData64;
            ULONG HdrDiff = offsetof(IRQ_RESOURCE_64,IRQ_Data) - offsetof(IRQ_RESOURCE_32,IRQ_Data);
            ULONG DataSize = ResLen64-offsetof(IRQ_RESOURCE_64,IRQ_Data);
            ULONG NewResSize = DataSize+offsetof(IRQ_RESOURCE_32,IRQ_Data);
            PVOID NewResData = pSetupMalloc(NewResSize);
            PIRQ_RESOURCE_32 pIrq32 = (PIRQ_RESOURCE_32)NewResData;

            if(NewResData == NULL) {
                return CR_OUT_OF_MEMORY;
            }
            //
            // copy header
            //
            MoveMemory(pIrq32,pIrq64,offsetof(IRQ_RESOURCE_32,IRQ_Data));
            //
            // copy/truncate Affinity (to ensure it's correct)
            //
            pIrq32->IRQ_Header.IRQD_Affinity = (ULONG32)pIrq64->IRQ_Header.IRQD_Affinity;
            //
            // copy data (trivial in this case)
            //
            MoveMemory(pIrq32->IRQ_Data,pIrq64->IRQ_Data,DataSize);

            *ResLen32 = NewResSize;
            *ResData32 = NewResData;
        }
        return CR_SUCCESS;

    default:
        //
        // unknown resource
        // shouldn't be a problem as this is for downlevel platforms
        //
        ASSERT(ResourceID & ResType_Ignored_Bit);
        return CR_SUCCESS;
    }
}



CONFIGRET
Convert32bitResDesTo64bitResDes(
    IN     RESOURCEID ResourceID,
    IN OUT PVOID ResData,
    IN     ULONG ResLen
    )
/*++

Routine Description:

   This routine reuses ResData and ResLen converting the 32-bit data provided
   into 64-bit. Return error if buffer (reslen) isn't big enough

   old structure: [DES32][RANGE32][RANGE32]...
   new structure: [DES64 ][RANGE64 ][RANGE 64]...
   #elements from 32-bit structure
   (+ allow for alignment issues)

Parameters:

   ResourceID - type of resource to adjust
   ResData    - in, 32-bit, out, 64-bit
   ResData32  - size of ResData buffer

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.

--*/
{
    switch(ResourceID) {
    case ResType_All:
    case ResType_Mem:
    case ResType_IO:
    case ResType_DMA:
    case ResType_BusNumber:
        //
        // no change in resource structure
        //
        return CR_SUCCESS;

    case ResType_IRQ:
        {
            PIRQ_RESOURCE_64 pIrq64 = (PIRQ_RESOURCE_64)ResData;
            PIRQ_RESOURCE_32 pIrq32 = (PIRQ_RESOURCE_32)ResData;
            ULONG HdrDiff = offsetof(IRQ_RESOURCE_64,IRQ_Data) - offsetof(IRQ_RESOURCE_32,IRQ_Data);
            ULONG DataSize = pIrq32->IRQ_Header.IRQD_Count * sizeof(IRQ_RANGE);
            ULONG NewResSize = DataSize+offsetof(IRQ_RESOURCE_64,IRQ_Data);

            if(NewResSize > ResLen) {
                return CR_BUFFER_SMALL;
            }
            //
            // work top to bottom
            // copy data (trivial in this case)
            // MoveMemory handles overlap
            //
            MoveMemory(pIrq64->IRQ_Data,pIrq32->IRQ_Data,DataSize);

            //
            // header is in correct position
            // but we need to deal with affinity... copy only low 32-bits
            //
            pIrq64->IRQ_Header.IRQD_Affinity = pIrq32->IRQ_Header.IRQD_Affinity;
        }
        return CR_SUCCESS;

    default:
        //
        // unknown resource
        // shouldn't be a problem as this is for downlevel platforms
        //
        ASSERT(ResourceID & ResType_Ignored_Bit);
        return CR_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\analyze.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       analyze.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"
#include <infstr.h>

BOOL
DeviceHasForcedConfig(
   DEVINST DeviceInst
   )
/*++

    This function checks to see if a given DevInst has a forced config or
    not.
    
--*/
{
    CONFIGRET ConfigRet;

    ConfigRet = CM_Get_First_Log_Conf_Ex(NULL, DeviceInst, FORCED_LOG_CONF, NULL);
    if (ConfigRet == CR_SUCCESS) 
    {
        return TRUE;
    }

    return FALSE;
}

INT_PTR CALLBACK
InstallNewDeviceDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
        
    case WM_INITDIALOG: {
            
        HICON hIcon;
        HWND hwndParentDlg;
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

        hIcon = LoadIcon(hHdwWiz,MAKEINTRESOURCE(IDI_HDWWIZICON));
            
        if (hIcon) {

            hwndParentDlg = GetParent(hDlg);
            SendMessage(hwndParentDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
            SendMessage(hwndParentDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        }
        break;

    }

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
            
        switch (((NMHDR FAR *)lParam)->code) {
                
        case PSN_SETACTIVE: {

            int PrevPage;

            PrevPage = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_INSTALLNEWDEVICE;

            //
            // If we are coming back then this is effectively a Cancel
            // of the install.
            //

            if (PrevPage == IDD_ADDDEVICE_SELECTDEVICE ||
                PrevPage == IDD_ADDDEVICE_SELECTCLASS )
            {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                break;
            }


            //
            // If we have a class then jump into SelectDevice.
            // otherwise goto search pages.
            //

            if (HardwareWiz->ClassGuidSelected) {

                HardwareWiz->EnterInto = IDD_ADDDEVICE_SELECTDEVICE;
                HardwareWiz->EnterFrom = IDD_INSTALLNEWDEVICE;
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTDEVICE);

            } else {

                HardwareWiz->EnterInto = IDD_ADDDEVICE_SELECTCLASS;
                HardwareWiz->EnterFrom = IDD_INSTALLNEWDEVICE;
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTCLASS);
            }
        }
        break;
                                
        case PSN_WIZNEXT:
            break;

        case PSN_RESET:
            HardwareWiz->Cancelled = TRUE;
            break;
        }
        break;
            
    default:
        return(FALSE);
    }

    return(TRUE);
}

BOOL
CompareInfIdToHardwareIds(
    LPTSTR     HardwareId,
    LPTSTR     InfDeviceId
    )
/*++

    This function takes a pointer to the Hardware/Compatible Id list for a device and
    a DeviceId that we got from the INF.  It enumerates through all of the device's
    Hardware and Compatible Ids comparing them against the Device Id we got from the INF.
    If one of the device's Hardware or Compatible Ids match the API returns TRUE, otherwise
    it returns FALSE.
    
--*/
{
    while (*HardwareId) {
    
        if (_wcsicmp(HardwareId, InfDeviceId) == 0) {
        
            return TRUE;
        }

        HardwareId = HardwareId + lstrlen(HardwareId) + 1;
    }

    return(FALSE);
}

/*
 * RegisterDeviceNode
 *
 * Determines if device is a legacy or pnp style device,
 * Registers the device (phantomn devnode to real devnode).
 *
 */
DWORD
RegisterDeviceNode(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{

    DWORD FieldCount, Index, Len;
    DWORD AnalyzeResult;
    HINF hInf = INVALID_HANDLE_VALUE;
    LPTSTR HardwareId;
    SP_DRVINFO_DATA  DriverInfoData;
    PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData = NULL;
    INFCONTEXT InfContext;
    TCHAR InfDeviceID[MAX_DEVICE_ID_LEN];
    TCHAR SectionName[LINE_LEN*2];
    LONG LastError;
    HardwareWiz->PnpDevice= FALSE;

    //
    // Fetch the DriverInfoDetail, with enough space for lots of hardwareIDs.
    //

    Len = sizeof(SP_DRVINFO_DETAIL_DATA) + MAX_PATH*sizeof(TCHAR);
    DriverInfoDetailData = LocalAlloc(LPTR, Len);
    
    if (!DriverInfoDetailData) {

        goto AnalyzeExit;
    }
    
    DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (!SetupDiGetSelectedDriver(HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData,
                                  &DriverInfoData
                                  ))
    {
        goto AnalyzeExit;
    }


    if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                    &HardwareWiz->DeviceInfoData,
                                    &DriverInfoData,
                                    DriverInfoDetailData,
                                    Len,
                                    &Len
                                    ))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        
            LocalFree(DriverInfoDetailData);
            DriverInfoDetailData = LocalAlloc(LPTR, Len);

            if (!DriverInfoDetailData) {
            
                goto AnalyzeExit;
            }

            DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
            if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                            &HardwareWiz->DeviceInfoData,
                                            &DriverInfoData,
                                            DriverInfoDetailData,
                                            Len,
                                            NULL
                                            ))
            {
                goto AnalyzeExit;
            }

        } else {
        
            goto AnalyzeExit;
        }
    }


    //
    // Get a handle to the inf file.
    //


    hInf = SetupOpenInfFile(DriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {

        //
        // If this is an old style inf file, then we can't write out
        // the logconfigs for classes which allow old style infs this is Ok,
        // If its an invalid or missing inf, it will fail further
        // down the chain of execution
        //

        goto AnalyzeExit;
    }



    //
    // Check InfFile for ControlFlags section for INFSTR_KEY_COPYFILESONLY
    //
    if (SetupFindFirstLine(hInf,
                           INFSTR_CONTROLFLAGS_SECTION,
                           INFSTR_KEY_COPYFILESONLY,
                           &InfContext
                           ))
    {
        HardwareId = DriverInfoDetailData->HardwareID;

        do {

            FieldCount = SetupGetFieldCount(&InfContext);
            Index = 0;

            while (Index++ < FieldCount) {

                if (SetupGetStringField(&InfContext,
                                        Index,
                                        InfDeviceID,
                                        sizeof(InfDeviceID)/sizeof(TCHAR),
                                        NULL
                                        ))
                {
                   if (CompareInfIdToHardwareIds(HardwareId, InfDeviceID)) {
                   
                       HardwareWiz->PnpDevice= TRUE;
                       goto AnalyzeExit;
                   }
               }
            }

        } while (SetupFindNextMatchLine(&InfContext,
                                        INFSTR_KEY_COPYFILESONLY,
                                        &InfContext)
                                        );
    }


    //
    // If there are factdef logconfigs install them as a forced config.
    // These are the factory default jumper settings for the hw.
    //

    if (SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData->SectionName,
                                         SectionName,
                                         SIZECHARS(SectionName),
                                         NULL,
                                         NULL
                                         ))
    {
        lstrcat(SectionName, TEXT(".") INFSTR_SUBKEY_FACTDEF);

        if (SetupFindFirstLine(hInf, SectionName, NULL, &InfContext)) {
        
            SetupInstallFromInfSection(hDlg,
                                       hInf,
                                       SectionName,
                                       SPINST_LOGCONFIG | SPINST_SINGLESECTION | SPINST_LOGCONFIG_IS_FORCED,
                                       NULL,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       HardwareWiz->hDeviceInfo,
                                       &HardwareWiz->DeviceInfoData
                                       );
        }
    }



AnalyzeExit:

    if (DriverInfoDetailData) {
    
        LocalFree(DriverInfoDetailData);
    }


    if (hInf != INVALID_HANDLE_VALUE) {
    
        SetupCloseInfFile(hInf);
    }


    //
    // Register the phantom device in preparation for install.
    // Once this is registered we MUST remove it from the registry
    // if the device install is not completed.
    //
    if (SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
                                  HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData
                                  ))
    {
        LastError = ERROR_SUCCESS;

    } else {
    
        LastError = GetLastError();
    }


    HardwareWiz->Registered = LastError == ERROR_SUCCESS;

    return LastError;
}

DWORD
ProcessLogConfig(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{

    DWORD FieldCount, Index, Len;
    DWORD AnalyzeResult;
    HINF hInf = INVALID_HANDLE_VALUE;
    LPTSTR HardwareId;
    SP_DRVINFO_DATA  DriverInfoData;
    PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData = NULL;
    INFCONTEXT InfContext;
    TCHAR InfDeviceID[MAX_DEVICE_ID_LEN];
    TCHAR SectionName[LINE_LEN*2];
    LONG LastError = ERROR_SUCCESS;

    //
    // Fetch the DriverInfoDetail, with enough space for lots of hardwareIDs.
    //

    Len = sizeof(SP_DRVINFO_DETAIL_DATA) + MAX_PATH*sizeof(TCHAR);
    DriverInfoDetailData = LocalAlloc(LPTR, Len);
    
    if (!DriverInfoDetailData) {

        goto AnalyzeExit;
    }
    
    DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (!SetupDiGetSelectedDriver(HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData,
                                  &DriverInfoData
                                  ))
    {
        goto AnalyzeExit;
    }


    if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                    &HardwareWiz->DeviceInfoData,
                                    &DriverInfoData,
                                    DriverInfoDetailData,
                                    Len,
                                    &Len
                                    ))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        
            LocalFree(DriverInfoDetailData);
            DriverInfoDetailData = LocalAlloc(LPTR, Len);

            if (!DriverInfoDetailData) {
            
                goto AnalyzeExit;
            }

            DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
            if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                            &HardwareWiz->DeviceInfoData,
                                            &DriverInfoData,
                                            DriverInfoDetailData,
                                            Len,
                                            NULL
                                            ))
            {
                goto AnalyzeExit;
            }

        } else {
        
            goto AnalyzeExit;
        }
    }


    //
    // Get a handle to the inf file.
    //


    hInf = SetupOpenInfFile(DriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {

        //
        // If this is an old style inf file, then we can't write out
        // the logconfigs for classes which allow old style infs this is Ok,
        // If its an invalid or missing inf, it will fail further
        // down the chain of execution
        //

        goto AnalyzeExit;
    }

    //
    // Install any LogConfig entries in the install section.
    //
    if (SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData->SectionName,
                                         SectionName,
                                         SIZECHARS(SectionName),
                                         NULL,
                                         NULL
                                         ))
    {
        SetupInstallFromInfSection(hDlg,
                                   hInf,
                                   SectionName,
                                   SPINST_LOGCONFIG,
                                   NULL,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL,
                                   HardwareWiz->hDeviceInfo,
                                   &HardwareWiz->DeviceInfoData
                                   );
    }



AnalyzeExit:

    if (DriverInfoDetailData) {
    
        LocalFree(DriverInfoDetailData);
    }


    if (hInf != INVALID_HANDLE_VALUE) {
    
        SetupCloseInfFile(hInf);
    }

    return LastError;
}

INT_PTR CALLBACK
HdwAnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HICON hicon;
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz;
    PSP_INSTALLWIZARD_DATA  InstallWizard;

    if (wMsg == WM_INITDIALOG) {
    
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        HardwareWiz->AnalyzeResult = 0;
        return TRUE;
    }



    HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    InstallWizard = &HardwareWiz->InstallDynaWiz;

    switch (wMsg) {

    case WM_DESTROY:

        hicon = (HICON)LOWORD(SendDlgItemMessage(hDlg,IDC_CLASSICON,STM_GETICON,0,0));
        if (hicon) {
            
            DestroyIcon(hicon);
        }
        break;

    case WUM_RESOURCEPICKER:
    {
        TCHAR Title[MAX_PATH], Message[MAX_PATH];

        LoadString(hHdwWiz, IDS_HDWWIZNAME, Title, SIZECHARS(Title));
        LoadString(hHdwWiz, IDS_NEED_FORCED_CONFIG, Message, SIZECHARS(Message));

        MessageBox(hDlg, Message, Title, MB_OK | MB_ICONEXCLAMATION);

        DisplayResource(HardwareWiz, GetParent(hDlg), TRUE);
    }
        break;
    
    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {

            int PrevPage;
            DWORD RegisterError = ERROR_SUCCESS;
            SP_DRVINFO_DATA DriverInfoData;

            PrevPage = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_ADDDEVICE_ANALYZEDEV;

            if (PrevPage == IDD_WIZARDEXT_POSTANALYZE) {

                break;
            }

            //
            // Get info on currently selected device, since this could change
            // as the user move back and forth between wizard pages
            // we do this on each activate.
            //
            if (!SetupDiGetSelectedDevice(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData
                                          )) {

                RegisterError = GetLastError();

            } else {
                //
                // If wizard type is addnew, then we have a phantom devnode
                // and it needs to registered. All other wizard types, the
                // devnode is already registered.
                //
                RegisterError = RegisterDeviceNode(hDlg, HardwareWiz);
            }

            //
            // Set the class Icon
            //
            if (SetupDiLoadClassIcon(&HardwareWiz->DeviceInfoData.ClassGuid, &hicon, NULL)) {

                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                if (hicon) {

                    DestroyIcon(hicon);
                }
            }

            SetDriverDescription(hDlg, IDC_HDW_DESCRIPTION, HardwareWiz);
            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);

            //
            // need to determine conflict warning.
            //
            if (RegisterError != ERROR_SUCCESS) {
            
                //
                // Show the bullet text items.
                //
                ShowWindow(GetDlgItem(hDlg, IDC_BULLET_1), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_ANALYZE_INSTALL_TEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_BULLET_2), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_ANALYZE_EXIT_TEXT), SW_SHOW);
                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_ANALYZEERR1, IDS_HDW_ANALYZEERR1);

                //
                // Turn the 'i' character into a bullet.
                //
                SetWindowText(GetDlgItem(hDlg, IDC_BULLET_1), TEXT("i"));
                SetWindowFont(GetDlgItem(hDlg, IDC_BULLET_1), HardwareWiz->hfontTextMarlett, TRUE);
                SetWindowText(GetDlgItem(hDlg, IDC_BULLET_2), TEXT("i"));
                SetWindowFont(GetDlgItem(hDlg, IDC_BULLET_2), HardwareWiz->hfontTextMarlett, TRUE);

                if (RegisterError == ERROR_DUPLICATE_FOUND) {

                    SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_DUPLICATE1, IDS_HDW_DUPLICATE1);
                }

                //
                // Bold the error text.
                //
                SetWindowFont(GetDlgItem(hDlg, IDC_HDW_TEXT), HardwareWiz->hfontTextBold, TRUE);

            } else {

               SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_STDCFG, IDS_HDW_STDCFG);

               //
               // Hide the bullet text items.
               //
               ShowWindow(GetDlgItem(hDlg, IDC_BULLET_1), SW_HIDE);
               ShowWindow(GetDlgItem(hDlg, IDC_ANALYZE_INSTALL_TEXT), SW_HIDE);
               ShowWindow(GetDlgItem(hDlg, IDC_BULLET_2), SW_HIDE);
               ShowWindow(GetDlgItem(hDlg, IDC_ANALYZE_EXIT_TEXT), SW_HIDE);
            }

            if (InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {

                if (RegisterError == ERROR_SUCCESS ||
                   !(InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT)) {

                    SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_ANALYZE_NEXTPAGE);
                }
            }

            //
            // If a device has recources and it does not have a forced config
            // and it is a manually installed device then pop up the resource
            // picker.  We need to do this because a legacy device must have 
            // a forced or boot config or else it won't get started.
            //
            if ((ERROR_SUCCESS == RegisterError) && 
                !HardwareWiz->PnpDevice &&
                DeviceHasResources(HardwareWiz->DeviceInfoData.DevInst) &&
                !DeviceHasForcedConfig(HardwareWiz->DeviceInfoData.DevInst)) {

                //
                // Post ourselves a message to show the resource picker
                //
                PostMessage(hDlg, WUM_RESOURCEPICKER, 0, 0);
            }

            break;
        }


        case PSN_WIZBACK:
            //
            // Undo the registration
            //
            if (HardwareWiz->Registered) {

                HardwareWiz->Registered = FALSE;
            }

            if (HardwareWiz->WizExtPostAnalyze.hPropSheet) {

                PropSheet_RemovePage(hwndParentDlg,
                                     (WPARAM)-1,
                                     HardwareWiz->WizExtPostAnalyze.hPropSheet
                                     );

                HardwareWiz->WizExtPostAnalyze.hPropSheet = NULL;
            }

            SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PREANALYZE);
            break;

        case PSN_WIZNEXT:


            if (!HardwareWiz->Registered &&
                !SetupDiRegisterDeviceInfo(HardwareWiz->hDeviceInfo,
                                           &HardwareWiz->DeviceInfoData,
                                           0,
                                           NULL,
                                           NULL,
                                           NULL
                                           ))
            {
                InstallFailedWarning(hDlg, HardwareWiz);
                if (HardwareWiz->WizExtPostAnalyze.hPropSheet) {
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         HardwareWiz->WizExtPostAnalyze.hPropSheet
                                         );
                    HardwareWiz->WizExtPostAnalyze.hPropSheet = NULL;
                }

                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PREANALYZE);
            }
            else  {

                //
                // Add the PostAnalyze Page and jump to it
                //

                HardwareWiz->WizExtPostAnalyze.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_POSTANALYZE,
                                                                           WizExtPostAnalyzeDlgProc,
                                                                           HardwareWiz
                                                                           );

                if (HardwareWiz->WizExtPostAnalyze.hPropSheet) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPostAnalyze.hPropSheet);
                }

                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_POSTANALYZE);
            }

            break;
       }
       break;


       default:
           return(FALSE);
    
    }
    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreAnalyzeDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_PREANALYZE;

            if (PrevPageId == IDD_WIZARDEXT_SELECT) {
                //
                // Moving forward on first page
                //


                //
                // if we are not doing the old fashioned DYNAWIZ
                // Add ClassWizard Extension pages for preanalyze
                //

                if (!(HardwareWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED))
                {
                    AddClassWizExtPages(hwndParentDlg,
                                        HardwareWiz,
                                        &HardwareWiz->WizExtPreAnalyze.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_PREANALYZE
                                        );
                }


                //
                // Add the end page, which is PreAnalyze end
                //

                HardwareWiz->WizExtPreAnalyze.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_PREANALYZE_END,
                                                                             WizExtPreAnalyzeEndDlgProc,
                                                                             HardwareWiz
                                                                             );

                if (HardwareWiz->WizExtPreAnalyze.hPropSheetEnd) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPreAnalyze.hPropSheetEnd);
                }

                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

            }
            else {
                //
                // Moving backwards from PreAnalyze end on PreAanalyze
                //

                //
                // Clean up proppages added.
                //

                if (HardwareWiz->WizExtPreAnalyze.hPropSheetEnd) {
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         HardwareWiz->WizExtPreAnalyze.hPropSheetEnd
                                         );
                    HardwareWiz->WizExtPreAnalyze.hPropSheetEnd = NULL;
                }


                RemoveClassWizExtPages(hwndParentDlg,
                                       &HardwareWiz->WizExtPreAnalyze.DeviceWizardData
                                       );




                //
                // Jump back
                // Note: The target pages don't set PrevPage, so set it for them
                //
                HardwareWiz->PrevPage = IDD_WIZARDEXT_SELECT;
                if (HardwareWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
                    SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_ANALYZE_PREVPAGE);
                }
                else {
                    SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_SELECTDEV_PAGE);
                }
             }

            break;

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreAnalyzeEndDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_PREANALYZE_END;

            if (PrevPageId == IDD_ADDDEVICE_ANALYZEDEV) {
                //
                // Moving backwards from analyzepage
                //

                //
                // Jump back
                //


                PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);

            }
            else {
                //
                // Moving forward on end page
                //

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_ANALYZEDEV);
            }


            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPostAnalyzeDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_POSTANALYZE;

            if (PrevPageId == IDD_ADDDEVICE_ANALYZEDEV) {
                //
                // Moving forward on first page
                //

                //
                // if we are not doing the old fashioned DYNAWIZ
                // Add ClassWizard Extension pages for postanalyze
                //

                if (!(HardwareWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED))
                {
                    AddClassWizExtPages(hwndParentDlg,
                                        HardwareWiz,
                                        &HardwareWiz->WizExtPostAnalyze.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_POSTANALYZE
                                        );
                }


                //
                // Add the end page, which is PostAnalyze end
                //

                HardwareWiz->WizExtPostAnalyze.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_POSTANALYZE_END,
                                                                             WizExtPostAnalyzeEndDlgProc,
                                                                              HardwareWiz
                                                                              );

                if (HardwareWiz->WizExtPostAnalyze.hPropSheetEnd) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPostAnalyze.hPropSheetEnd);
                }

                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

            }
            else  {
                //
                // Moving backwards from PostAnalyze end on PostAnalyze
                //

                //
                // Clean up proppages added.
                //

                if (HardwareWiz->WizExtPostAnalyze.hPropSheetEnd) {
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         HardwareWiz->WizExtPostAnalyze.hPropSheetEnd
                                         );
                    HardwareWiz->WizExtPostAnalyze.hPropSheetEnd = NULL;
                }


                RemoveClassWizExtPages(hwndParentDlg,
                                       &HardwareWiz->WizExtPostAnalyze.DeviceWizardData
                                       );
            }

            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPostAnalyzeEndDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:
            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_POSTANALYZE_END;

            if (PrevPageId == IDD_ADDDEVICE_INSTALLDEV) {

                 //
                 // Moving backwards from finishpage
                 //

                 //
                 // Jump back
                 //

                 PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);

            }
            else  {
                //
                // Moving forward on End page
                //

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_INSTALLDEV);
            }

            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\finish.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       finish.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"
#include <help.h>

HMODULE hSrClientDll;

typedef
BOOL
(*SRSETRESTOREPOINT)(
    PRESTOREPOINTINFO pRestorePtSpec,
    PSTATEMGRSTATUS pSMgrStatus
    );

BOOL
DeviceHasResources(
                  DEVINST DeviceInst
                  )
{
    CONFIGRET ConfigRet;
    ULONG lcType = NUM_LOG_CONF;

    while (lcType--) {
        
        ConfigRet = CM_Get_First_Log_Conf_Ex(NULL, DeviceInst, lcType, NULL);
        
        if (ConfigRet == CR_SUCCESS) {
            
            return TRUE;
        }
    }

    return FALSE;
}

DWORD
HdwRemoveDevice(
               PHARDWAREWIZ HardwareWiz
               )
{
    SP_REMOVEDEVICE_PARAMS RemoveDeviceParams;
    LONG Error = ERROR_SUCCESS;

    RemoveDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    RemoveDeviceParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    RemoveDeviceParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    RemoveDeviceParams.HwProfile = 0;

    if (!SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      (PSP_CLASSINSTALL_HEADER)&RemoveDeviceParams,
                                      sizeof(RemoveDeviceParams)
                                     )
        ||
        !SetupDiCallClassInstaller(DIF_REMOVE,
                                   HardwareWiz->hDeviceInfo,
                                   &HardwareWiz->DeviceInfoData
                                  )) {
        Error = GetLastError();
    }


    //
    // Clear the class install parameters.
    //
    SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                 &HardwareWiz->DeviceInfoData,
                                 NULL,
                                 0
                                );

    return Error;
}

BOOL
GetClassGuidForInf(
    PTSTR InfFileName,
    LPGUID ClassGuid
    )
{
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    DWORD NumGuids;

    if (!SetupDiGetINFClass(InfFileName,
                            ClassGuid,
                            ClassName,
                            sizeof(ClassName)/sizeof(TCHAR),
                            NULL)) {
        return FALSE;
    }

    if (IsEqualGUID(ClassGuid, &GUID_NULL)) {
        //
        // Then we need to retrieve the GUID associated with the INF's class name.
        // (If this class name isn't installed (i.e., has no corresponding GUID),
        // of if it matches with multiple GUIDs, then we abort.
        //
        if (!SetupDiClassGuidsFromName(ClassName, ClassGuid, 1, &NumGuids) ||
            !NumGuids) {
            
            return FALSE;
        }
    }

    return TRUE;
}

LONG
ClassInstallerInstalls(
                      HWND hwndParent,
                      PHARDWAREWIZ HardwareWiz,
                      HDEVINFO hDeviceInfo,
                      PSP_DEVINFO_DATA DeviceInfoData,
                      BOOL InstallFilesOnly
                      )
{
    DWORD Err = ERROR_SUCCESS;
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    PVOID MessageHandlerContext = NULL;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    DWORD ScanResult = 0;
    RESTOREPOINTINFO RestorePointInfo;
    STATEMGRSTATUS SMgrStatus;
    int FileQueueNeedsReboot = 0;

    //
    // verify with class installer, and class-specific coinstallers
    // that the driver is not blacklisted. For DIF_ALLOW_INSTALL we
    // accept ERROR_SUCCESS or ERROR_DI_DO_DEFAULT as good return codes.
    //
    if (!SetupDiCallClassInstaller(DIF_ALLOW_INSTALL,
                                   hDeviceInfo,
                                   DeviceInfoData
                                   ) &&
        (GetLastError() != ERROR_DI_DO_DEFAULT)) {

        Err = GetLastError();
        goto clean0;
    }

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (!SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                       &HardwareWiz->DeviceInfoData,
                                       &DeviceInstallParams
                                       )) {

        Err = GetLastError();
        goto clean0;
    }

    FileQueue = SetupOpenFileQueue();

    if (FileQueue == INVALID_HANDLE_VALUE) {
       Err = ERROR_NOT_ENOUGH_MEMORY;
       goto clean0;
    }

    DeviceInstallParams.Flags |= DI_NOVCP;
    DeviceInstallParams.FileQueue = FileQueue;

    SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData,
                                  &DeviceInstallParams
                                  );

    //
    // Set the SPQ_FLAG_ABORT_IF_UNSIGNED value on the file queue. With this
    // flag set setupapi will bail out of the copy if it encounters an unsigned
    // file. At that point we will set a system restore point and then 
    // do the copy. This way the user can back out of an unsigned driver
    // install using system restore.
    //
    // Note that system restore is currently not supported on 64-bit so don't 
    // bother setting the SPQ_FLAG_ABORT_IF_UNSIGNED.
    //
#ifndef _WIN64
    SetupSetFileQueueFlags(FileQueue,
                           SPQ_FLAG_ABORT_IF_UNSIGNED,
                           SPQ_FLAG_ABORT_IF_UNSIGNED
                           );
#endif

    //
    // Install the files first in one shot.
    // This allows new coinstallers to run during the install.
    //
    if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                   hDeviceInfo,
                                   DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    //
    // Since we created our own FileQueue then we need to
    // scan and possibly commit the queue and prune copies as needed.
    //
    if (!SetupScanFileQueue(FileQueue,
                            SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                            hwndParent,
                            NULL,
                            NULL,
                            &ScanResult
                            )) {

        //
        // If the API failed then set the ScanResult to 0 (failure).
        //
        ScanResult = 0;
    }

    //
    // If the ScanResult is 1 then that means that all of the files are present
    // and that there are no rename or delete operations are left in the copy
    // queue. This means we can skip the file queue commit.
    //
    // If the ScanResult is 0 then there are file copy operations that are needed.
    // If the ScanResult is 2 then there are delete, rename or backup operations
    // that are needed. 
    //
    if (ScanResult != 1) {
        MessageHandlerContext = SetupInitDefaultQueueCallbackEx(
                                    hwndParent,
                                    (DeviceInstallParams.Flags & DI_QUIETINSTALL)
                                        ? INVALID_HANDLE_VALUE : NULL,
                                    0,
                                    0,
                                    NULL
                                    );

        if (MessageHandlerContext) {
            //
            // Commit the file queue.
            //
            if (!SetupCommitFileQueue(hwndParent,
                                      FileQueue,
                                      SetupDefaultQueueCallback,
                                      MessageHandlerContext
                                      )) {

                Err = GetLastError();

                if (Err == ERROR_SET_SYSTEM_RESTORE_POINT) {
                    SetupTermDefaultQueueCallback(MessageHandlerContext);

                    MessageHandlerContext = SetupInitDefaultQueueCallbackEx(
                                                hwndParent,
                                                (DeviceInstallParams.Flags & DI_QUIETINSTALL)
                                                    ? INVALID_HANDLE_VALUE : NULL,
                                                0,
                                                0,
                                                NULL
                                                );

                    if (MessageHandlerContext) {
                        HMODULE hSrClientDll = NULL;
                        SRSETRESTOREPOINT pfnSrSetRestorePoint = NULL;

                        if (((hSrClientDll = LoadLibrary(TEXT("srclient.dll")))) &&
                            ((pfnSrSetRestorePoint = (SRSETRESTOREPOINT)GetProcAddress(hSrClientDll,
                                                                                       "SRSetRestorePointW"
                                                                                       )))) {
                            //
                            // Set the system restore point.
                            //
                            RestorePointInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
                            RestorePointInfo.dwRestorePtType = DEVICE_DRIVER_INSTALL;
                            RestorePointInfo.llSequenceNumber = 0;
    
                            if (!LoadString(hHdwWiz,
                                            IDS_NEW_SETRESTOREPOINT,
                                            RestorePointInfo.szDescription,
                                            SIZECHARS(RestorePointInfo.szDescription)
                                            )) {
                                RestorePointInfo.szDescription[0] = TEXT('\0');
                            }
    
                            pfnSrSetRestorePoint(&RestorePointInfo, &SMgrStatus);

                            FreeLibrary(hSrClientDll);
                        }

                        //
                        // Clear the SPQ_FLAG_ABORT_IF_UNSIGNED flag so the file
                        // queue will be commited the next time.
                        //
                        SetupSetFileQueueFlags(FileQueue,
                                               SPQ_FLAG_ABORT_IF_UNSIGNED,
                                               0
                                               );

                        //
                        // Now that we have set the restore point and cleared the
                        // SPQ_FLAG_ABORT_IF_UNSIGNED flag from the file queue we
                        // can commit the queue again.
                        //
                        if (!SetupCommitFileQueue(hwndParent,
                                                  FileQueue,
                                                  SetupDefaultQueueCallback,
                                                  MessageHandlerContext
                                                  )) {
                            Err = GetLastError();
                            goto clean0;
                        } else {
                            //
                            // We were successful in commiting the file queue, so check
                            // to see whether a reboot is required as a result of committing
                            // the queue (i.e. because files were in use, or the INF requested
                            // a reboot).
                            //
                            FileQueueNeedsReboot = SetupPromptReboot(FileQueue, NULL, TRUE);
                        }
                    }
                } else {
                    goto clean0;
                }
            } else {
                //
                // We were successful in commiting the file queue, so check
                // to see whether a reboot is required as a result of committing
                // the queue (i.e. because files were in use, or the INF requested
                // a reboot).
                //
                FileQueueNeedsReboot = SetupPromptReboot(FileQueue, NULL, TRUE);
            }
        }
    }

    //
    // If we were only copiny files then we are done!
    //
    if (InstallFilesOnly) {
        Err = ERROR_SUCCESS;
        goto clean0;
    }

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(hDeviceInfo,
                                      DeviceInfoData,
                                      &DeviceInstallParams
                                      )) {
        DWORD FileQueueFlags;
        
        //
        // If we didn't copy any files when commiting the file queue then the
        // SPQ_FLAG_FILES_MODIFIED flag will NOT be set.  In this case set
        // the DI_FLAGSEX_RESTART_DEVICE_ONLY flag so that we only stop/start
        // this single device.  By default setupapi will stop/start this device
        // as well as any other device that was using the same driver/filter 
        // that this device is using.
        //
        if (SetupGetFileQueueFlags(FileQueue, &FileQueueFlags) &&
            !(FileQueueFlags & SPQ_FLAG_FILES_MODIFIED)) {
            
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;
        }

        //
        // Set the DI_NOFILECOPY flag since we already copied the files during
        // the DIF_INSTALLDEVICEFILES, so we don't need to copy them again during
        // the DIF_INSTALLDEVICE.
        //
        DeviceInstallParams.Flags |= DI_NOFILECOPY;
        SetupDiSetDeviceInstallParams(hDeviceInfo,
                                      DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }


    //
    // Register any device-specific co-installers for this device,
    //
    if (!SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS,
                                   hDeviceInfo,
                                   DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    //
    // install any INF/class installer-specified interfaces.
    // and then finally the real "InstallDevice"!
    //
    if (!SetupDiCallClassInstaller(DIF_INSTALLINTERFACES,
                                  hDeviceInfo,
                                  DeviceInfoData
                                  )
        ||
        !SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                   hDeviceInfo,
                                   DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    Err = ERROR_SUCCESS;

clean0:

    if (MessageHandlerContext) {
        SetupTermDefaultQueueCallback(MessageHandlerContext);
    }

    //
    // If the file queue said that a reboot was needed then set the 
    // DI_NEEDRESTART flag.
    //
    if (FileQueueNeedsReboot) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {

            DeviceInstallParams.Flags |= DI_NEEDRESTART;

            SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }
    }

    if (FileQueue != INVALID_HANDLE_VALUE) {
        //
        // If we have a valid file queue handle and there was an error during
        // the device install then we want to delete any new INFs that were
        // copied into the INF directory.  We do this under the assumption that
        // since there was an error during the install these INFs must be bad.
        //
        if (Err != ERROR_SUCCESS) {
            SetupUninstallNewlyCopiedInfs(FileQueue,
                                          0,
                                          NULL
                                          );
        }

        //
        // Clear out our file queue from the device install params. We need
        // to do this or else SetupCloseFileQueue will fail because it will
        // still have a ref count.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {

            DeviceInstallParams.Flags &= ~DI_NOVCP;
            DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

            SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        SetupCloseFileQueue(FileQueue);
    }

    return Err;
}







//
// invokable only from finish page!
//

DWORD
InstallDev(
          HWND       hwndParent,
          PHARDWAREWIZ HardwareWiz
          )
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    TCHAR ClassGuidString[MAX_GUID_STRING_LEN];
    GUID ClassGuidInf;
    LPGUID ClassGuid;
    int   ClassGuidNum;
    DWORD Error = ERROR_SUCCESS;
    BOOL IgnoreRebootFlags = FALSE;
    TCHAR Buffer[MAX_PATH*2];
    PVOID pvBuffer = Buffer;
    ULONG DevNodeStatus = 0, Problem = 0;
    DWORD ClassGuidListSize, i;


    if (!HardwareWiz->ClassGuidSelected) {
        HardwareWiz->ClassGuidSelected = (LPGUID)&GUID_NULL;
    }


    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(HardwareWiz->hDeviceInfo,
                                 &HardwareWiz->DeviceInfoData,
                                 &DriverInfoData
                                )) {
        //
        // Get details on this driver node, so that we can examine the INF that this
        // node came from.
        //
        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if (!SetupDiGetDriverInfoDetail(HardwareWiz->hDeviceInfo,
                                        &HardwareWiz->DeviceInfoData,
                                        &DriverInfoData,
                                        &DriverInfoDetailData,
                                        sizeof(DriverInfoDetailData),
                                        NULL
                                       )) {
            Error = GetLastError();
            if (Error != ERROR_INSUFFICIENT_BUFFER) {
                goto clean0;
            }
        }


        //
        // Verif that the class is installed, if its not then
        // attempt to install it.
        //
        HdwBuildClassInfoList(HardwareWiz, 
                              0,
                              HardwareWiz->hMachine ? HardwareWiz->MachineName : NULL
                             );


        //
        // fetch classguid from inf, (It may be different than what we already
        // have in class guid selected).
        //
        if (!GetClassGuidForInf(DriverInfoDetailData.InfFileName, &ClassGuidInf)) {
            
            ClassGuidInf = *HardwareWiz->ClassGuidSelected;
        }

        if (IsEqualGUID(&ClassGuidInf, &GUID_NULL)) {

            ClassGuidInf = GUID_DEVCLASS_UNKNOWN;
        }

        //
        // if the ClassGuidInf wasn't found then this class hasn't been installed yet.
        // -install the class installer now.
        //
        ClassGuid = HardwareWiz->ClassGuidList;
        ClassGuidNum = HardwareWiz->ClassGuidNum;
        while (ClassGuidNum--) {
            if (IsEqualGUID(ClassGuid, &ClassGuidInf)) {
                break;
            }

            ClassGuid++;
        }

        if (ClassGuidNum < 0 &&
            !SetupDiInstallClass(hwndParent,
                                 DriverInfoDetailData.InfFileName,
                                 0,
                                 NULL
                                )) {
            Error = GetLastError();
            goto clean0;
        }


        //
        // Now make sure that the class of this device is the same as the class
        // of the selected driver node.
        //
        if (!IsEqualGUID(&ClassGuidInf, HardwareWiz->ClassGuidSelected)) {
            pSetupStringFromGuid(&ClassGuidInf,
                                 ClassGuidString,
                                 sizeof(ClassGuidString)/sizeof(TCHAR)
                                );

            SetupDiSetDeviceRegistryProperty(HardwareWiz->hDeviceInfo,
                                             &HardwareWiz->DeviceInfoData,
                                             SPDRP_CLASSGUID,
                                             (PBYTE)ClassGuidString,
                                             sizeof(ClassGuidString)
                                            );
        }
    }

    //
    // No selected driver, and no associated class--use "Unknown" class.
    //
    else {

        //
        // If the devnode is currently running 'raw', then remember this
        // fact so that we don't require a reboot later (NULL driver installation
        // isn't going to change anything).
        //
        if (CM_Get_DevNode_Status(&DevNodeStatus,
                                  &Problem,
                                  HardwareWiz->DeviceInfoData.DevInst,
                                  0) == CR_SUCCESS) {
            if (!SetupDiGetDeviceRegistryProperty(HardwareWiz->hDeviceInfo,
                                                  &HardwareWiz->DeviceInfoData,
                                                  SPDRP_SERVICE,
                                                  NULL,     // regdatatype
                                                  pvBuffer,
                                                  sizeof(Buffer),
                                                  NULL
                                                 )) {
                *Buffer = TEXT('\0');
            }

            if ((DevNodeStatus & DN_STARTED) && (*Buffer == TEXT('\0'))) {
                IgnoreRebootFlags = TRUE;
            }
        }

        if (IsEqualGUID(HardwareWiz->ClassGuidSelected, &GUID_NULL)) {

            pSetupStringFromGuid(&GUID_DEVCLASS_UNKNOWN,
                                 ClassGuidString,
                                 sizeof(ClassGuidString)/sizeof(TCHAR)
                                );


            SetupDiSetDeviceRegistryProperty(HardwareWiz->hDeviceInfo,
                                             &HardwareWiz->DeviceInfoData,
                                             SPDRP_CLASSGUID,
                                             (PBYTE)ClassGuidString,
                                             sizeof(ClassGuidString)
                                            );
        }
    }


    //
    // since this is a legacy install, set the manually installed bit if the
    // driver that was selected was not a PnP driver.
    //
    if (!HardwareWiz->PnpDevice) {
        ULONG Len;
        CONFIGRET ConfigRet;
        ULONG ConfigFlag;

        Len = sizeof(ConfigFlag);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(HardwareWiz->DeviceInfoData.DevInst,
                                                        CM_DRP_CONFIGFLAGS,
                                                        NULL,
                                                        (PVOID)&ConfigFlag,
                                                        &Len,
                                                        0,
                                                        NULL
                                                       );
        if (ConfigRet != CR_SUCCESS) {
            ConfigFlag = 0;
        }

        ConfigFlag |= CONFIGFLAG_MANUAL_INSTALL;
        CM_Set_DevNode_Registry_Property_Ex(HardwareWiz->DeviceInfoData.DevInst,
                                            CM_DRP_CONFIGFLAGS,
                                            (PVOID)&ConfigFlag,
                                            sizeof(ConfigFlag),
                                            0,
                                            NULL
                                           );
    }

    Error = ClassInstallerInstalls(hwndParent,
                                   HardwareWiz,
                                   HardwareWiz->hDeviceInfo,
                                   &HardwareWiz->DeviceInfoData,
                                   HardwareWiz->PnpDevice
                                  );

    if (Error != ERROR_SUCCESS) {

        //
        // we Have an install error, including a user cancel.
        // Install the null driver.
        //
        if (SetupDiSetSelectedDriver(HardwareWiz->hDeviceInfo,
                                     &HardwareWiz->DeviceInfoData,
                                     NULL
                                    )) {

            if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                              &HardwareWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                             )) {
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
                SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                              &HardwareWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                             );
            }

            SetupDiInstallDevice(HardwareWiz->hDeviceInfo, &HardwareWiz->DeviceInfoData);
        }

        goto clean0;
    }


    //
    // Fetch the latest DeviceInstallParams for the restart bits.
    //
    if (!IgnoreRebootFlags) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                         )) {
            if (DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
                HardwareWiz->Reboot |= DI_NEEDREBOOT;
            }
        }
    }


    clean0:

    return Error;
}



DWORD
InstallNullDriver(
                 HWND  hDlg,
                 PHARDWAREWIZ HardwareWiz,
                 BOOL FailedInstall
                 )
{
    SP_DEVINSTALL_PARAMS    DevInstallParams;
    DWORD  Status = ERROR_SUCCESS;

    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if (FailedInstall) {
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DevInstallParams
                                         )) {
            DevInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
            SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DevInstallParams
                                         );
        }
    }


    if (SetupDiSetSelectedDriver(HardwareWiz->hDeviceInfo,
                                 &HardwareWiz->DeviceInfoData,
                                 NULL
                                )) {
        Status = InstallDev(hDlg, HardwareWiz);
    }


    return Status;

} // InstallNullDriver


BOOL
CALLBACK
AddPropSheetPageProc(
                    IN HPROPSHEETPAGE hpage,
                    IN LPARAM lParam
                    )
{
    *((HPROPSHEETPAGE *)lParam) = hpage;
    return TRUE;
}

void
DisplayResource(
               PHARDWAREWIZ HardwareWiz,
               HWND hWndParent,
               BOOL NeedsForcedConfig 
               )
{
    HINSTANCE hLib;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsPages[1];
    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
    LPFNADDPROPSHEETPAGES ExtensionPropSheetPage = NULL;
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    //
    // Now get the resource selection page from setupapi.dll
    //
    hLib = GetModuleHandle(TEXT("setupapi.dll"));
    if (hLib) {
        ExtensionPropSheetPage = (PVOID)GetProcAddress(hLib, "ExtensionPropSheetPageProc");
    }

    if (!ExtensionPropSheetPage) {
        return;
    }

    PropPageRequest.cbSize = sizeof(SP_PROPSHEETPAGE_REQUEST);
    PropPageRequest.PageRequested  = SPPSR_SELECT_DEVICE_RESOURCES;
    PropPageRequest.DeviceInfoSet  = HardwareWiz->hDeviceInfo;
    PropPageRequest.DeviceInfoData = &HardwareWiz->DeviceInfoData;

    if (!ExtensionPropSheetPage(&PropPageRequest,
                                AddPropSheetPageProc,
                                (LONG_PTR)hpsPages
                               )) {
        // warning ?
        return;
    }

    //
    // create the property sheet
    //

    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    psh.hwndParent  = hWndParent;
    psh.hInstance   = hHdwWiz;
    psh.pszIcon     = NULL;

    psh.pszCaption  = (LPTSTR)IDS_ADDNEWDEVICE;

    psh.nPages      = 1;
    psh.phpage      = hpsPages;
    psh.nStartPage  = 0;
    psh.pfnCallback = NULL;


    //
    // Clear the Propchange pending bit in the DeviceInstall params.
    //
    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      &DevInstallParams
                                     )) {
        DevInstallParams.FlagsEx &= ~DI_FLAGSEX_PROPCHANGE_PENDING;
        SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      &DevInstallParams
                                     );
    }

    //
    // Set the CONFIGFLAG_NEEDS_FORCED_CONFIG if this device needs a forced config.
    //
    if (NeedsForcedConfig) {

        DWORD ConfigFlags = 0;
        ULONG ulSize = sizeof(ConfigFlags);

        if (CM_Get_DevInst_Registry_Property(HardwareWiz->DeviceInfoData.DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             NULL,
                                             (LPBYTE)&ConfigFlags,
                                             &ulSize,
                                             0) != CR_SUCCESS) {
            ConfigFlags = 0;
        }

        ConfigFlags |= CONFIGFLAG_NEEDS_FORCED_CONFIG;

        CM_Set_DevInst_Registry_Property(HardwareWiz->DeviceInfoData.DevInst,
                                         CM_DRP_CONFIGFLAGS,
                                         (LPBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags),
                                         0
                                        );
    }

    if (PropertySheet(&psh) == -1) {
        DestroyPropertySheetPage(hpsPages[0]);
    }


    //
    // If a PropChange occurred invoke the DIF_PROPERTYCHANGE
    //
    if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      &DevInstallParams
                                     )) {
        if (DevInstallParams.FlagsEx & DI_FLAGSEX_PROPCHANGE_PENDING) {
            SP_PROPCHANGE_PARAMS PropChangeParams;

            PropChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            PropChangeParams.Scope = DICS_FLAG_GLOBAL;
            PropChangeParams.HwProfile = 0;

            if (SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                             &HardwareWiz->DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                             sizeof(PropChangeParams)
                                            )) {
                SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                          HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData
                                         );
            }

            //
            // Clear the class install parameters.
            //

            SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                         &HardwareWiz->DeviceInfoData,
                                         NULL,
                                         0
                                        );
        }
    }

    //
    // See if we need to reboot
    //
    if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData,
                                      &DevInstallParams
                                     )) {
        if (DevInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            HardwareWiz->Reboot |= DI_NEEDREBOOT;
        }
    }


    //
    // Clear the CONFIGFLAG_NEEDS_FORCED_CONFIG if this device needs a forced config.
    //
    if (NeedsForcedConfig) {

        DWORD ConfigFlags = 0;
        ULONG ulSize = sizeof(ConfigFlags);

        if (CM_Get_DevInst_Registry_Property(HardwareWiz->DeviceInfoData.DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             NULL,
                                             (LPBYTE)&ConfigFlags,
                                             &ulSize,
                                             0) == CR_SUCCESS) {

            ConfigFlags &= ~CONFIGFLAG_NEEDS_FORCED_CONFIG;

            CM_Set_DevInst_Registry_Property(HardwareWiz->DeviceInfoData.DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             (LPBYTE)&ConfigFlags,
                                             sizeof(ConfigFlags),
                                             0
                                            );
        }
    }

    return;
}

INT_PTR CALLBACK
HdwInstallDevDlgProc(
                    HWND hDlg,
                    UINT wMsg,
                    WPARAM wParam,
                    LPARAM lParam
                    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    LONG Error;
    ULONG DevNodeStatus, Problem;

    switch (wMsg) {
    case WM_INITDIALOG: {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

            break;
        }

    case WM_DESTROY:
        break;

    case WUM_DOINSTALL:

        // do the Install
        HardwareWiz->LastError = InstallDev(hDlg, HardwareWiz);
        HardwareWiz->InstallPending = FALSE;
        HardwareWiz->CurrCursor = NULL;
        PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE: {
                HICON hicon;
                SP_DRVINFO_DATA DriverInfoData;

                HardwareWiz->PrevPage = IDD_ADDDEVICE_INSTALLDEV;

                //
                // This is an intermediary status page, no buttons needed.
                // Set the device description
                // Set the class Icon
                //
                PropSheet_SetWizButtons(hwndParentDlg, 0);
                EnableWindow(GetDlgItem(GetParent(hDlg),  IDCANCEL), FALSE);

                SetDriverDescription(hDlg, IDC_HDW_DESCRIPTION, HardwareWiz);

                if (SetupDiLoadClassIcon(HardwareWiz->ClassGuidSelected, &hicon, NULL)) {
                    hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                    if (hicon) {
                        DestroyIcon(hicon);
                    }
                }

                HardwareWiz->CurrCursor = HardwareWiz->IdcWait;
                SetCursor(HardwareWiz->CurrCursor);

                //
                // Post ourselves a msg, to do the actual install, this allows this
                // page to show itself while the install is actually occuring.
                //
                HardwareWiz->InstallPending = TRUE;

                PostMessage(hDlg, WUM_DOINSTALL, 0, 0);

                break;
            }


        case PSN_WIZNEXT:

            //
            // Add the FinishInstall Page and jump to it if the installation succeded.
            //
            if (HardwareWiz->LastError == ERROR_SUCCESS) {

                HardwareWiz->WizExtFinishInstall.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL,
                                                                               WizExtFinishInstallDlgProc,
                                                                               HardwareWiz
                                                                              );

                if (HardwareWiz->WizExtFinishInstall.hPropSheet) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtFinishInstall.hPropSheet);
                }

                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_FINISHINSTALL);

                //
                // There was an error during the installation so just jump to our finish page.
                //
            } else {

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_FINISH);
            }
            break;
        }
        break;


    case WM_SETCURSOR:
        if (HardwareWiz->CurrCursor) {
            SetCursor(HardwareWiz->CurrCursor);
            break;
        }

        // fall thru to return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}



void
ShowInstallSummary(
                  HWND hDlg,
                  PHARDWAREWIZ HardwareWiz
                  )
{
    LONG Error;
    CONFIGRET ConfigRet;
    ULONG Len, Problem, DevNodeStatus;
    BOOL HasResources;
    HWND hwndParentDlg = GetParent(hDlg);
    PTCHAR ErrorMsg, ProblemText;
    TCHAR TextBuffer[MAX_PATH*4];


    Problem = 0;
    *TextBuffer = TEXT('\0');

    Error = HardwareWiz->LastError;

    //
    // Installation was canceled
    //
    if (Error == ERROR_CANCELLED) {
        PropSheet_PressButton(hwndParentDlg, PSBTN_CANCEL);
        return;
    }

    //
    // Installation failed
    //
    if (Error != ERROR_SUCCESS) {
        HardwareWiz->Installed = FALSE;
        LoadText(TextBuffer, sizeof(TextBuffer), IDS_HDW_ERRORFIN1, IDS_HDW_ERRORFIN1);

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          HRESULT_FROM_SETUPAPI(Error),
                          0,
                          (LPTSTR)&ErrorMsg,
                          0,
                          NULL
                         )) {
            lstrcat(TextBuffer, TEXT("\n\n"));
            lstrcat(TextBuffer, ErrorMsg);
            LocalFree(ErrorMsg);
        }

        SetDlgItemText(hDlg, IDC_HDW_TEXT, TextBuffer);
    }

    //
    // No errors installing the drivers for this device
    //
    else {
        //
        // Check to see if the device itself has any problems
        //
        Error = CM_Get_DevNode_Status(&DevNodeStatus,
                                      &Problem,
                                      HardwareWiz->DeviceInfoData.DevInst,
                                      0
                                     );
        if (Error != CR_SUCCESS) {

            //
            // For some reason, we couldn't retrieve the devnode's status.
            // Default status and problem values to zero.
            //
            DevNodeStatus = Problem = 0;
        }

        //
        // make sure the reboot flags\Problem are set correctly
        //
        if (HardwareWiz->PnpDevice || HardwareWiz->Reboot || Problem == CM_PROB_NEED_RESTART  ) {
            
            if (Problem != CM_PROB_PARTIAL_LOG_CONF) {
                Problem = CM_PROB_NEED_RESTART;
            }

            HardwareWiz->Reboot |= DI_NEEDREBOOT;
        }


        HardwareWiz->Installed = TRUE;
        HasResources = DeviceHasResources(HardwareWiz->DeviceInfoData.DevInst);

        //
        // The device has a problem
        //
        if ((Error != CR_SUCCESS) || Problem) {
            if (Problem == CM_PROB_NEED_RESTART) {
                if (HasResources &&
                    !HardwareWiz->PnpDevice) {
                    LoadText(TextBuffer, sizeof(TextBuffer), IDS_HDW_NORMAL_LEGACY_FINISH1, IDS_HDW_NORMAL_LEGACY_FINISH1);
                } else {
                    LoadText(TextBuffer, sizeof(TextBuffer), IDS_HDW_NORMALFINISH1, IDS_HDW_NORMALFINISH1);
                }

                LoadText(TextBuffer, sizeof(TextBuffer), IDS_NEEDREBOOT, IDS_NEEDREBOOT);
            }

            else {
                LoadText(TextBuffer, sizeof(TextBuffer), IDS_INSTALL_PROBLEM, IDS_INSTALL_PROBLEM);

                if (Problem) {
                    ProblemText = DeviceProblemText(NULL,
                                                    HardwareWiz->DeviceInfoData.DevInst,
                                                    0,
                                                    Problem
                                                   );

                    if (ProblemText) {
                        lstrcat(TextBuffer, TEXT("\n\n"));
                        lstrcat(TextBuffer, ProblemText);
                        LocalFree(ProblemText);
                    }
                }
            }

            //
            // Show the resource button if the device has resources and it has a problem
            //
            if (HasResources ||
                (Problem && !(HardwareWiz->Reboot && (DevNodeStatus & DN_STARTED))) ||
                (Problem == CM_PROB_PARTIAL_LOG_CONF)) {
                ShowWindow(GetDlgItem(hDlg, IDC_HDW_DISPLAYRESOURCE), SW_SHOW);
            }
        }

        //
        // Installation was sucessful and the device does not have any problems
        //
        else {
            LoadText(TextBuffer, sizeof(TextBuffer), IDS_HDW_NORMALFINISH1, IDS_HDW_NORMALFINISH1);
        }

        SetDlgItemText(hDlg, IDC_HDW_TEXT, TextBuffer);
    }
}

INT_PTR CALLBACK
HdwAddDeviceFinishDlgProc(
                         HWND hDlg,
                         UINT wMsg,
                         WPARAM wParam,
                         LPARAM lParam
                         )
{
    HICON hicon;
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG: 
        {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);

            break;
        }

    case WM_DESTROY:
        hicon = (HICON)LOWORD(SendDlgItemMessage(hDlg,IDC_CLASSICON,STM_GETICON,0,0));
        if (hicon) {
            
            DestroyIcon(hicon);
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:
            //
            // No back button since install is already done.
            // set the device description
            // Hide Resources button until we know if resources exist or not.
            // Set the class Icon
            //
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

            SetDriverDescription(hDlg, IDC_HDW_DESCRIPTION, HardwareWiz);

            ShowWindow(GetDlgItem(hDlg, IDC_HDW_DISPLAYRESOURCE), SW_HIDE);

            //
            // Set the class Icon
            //
            if (SetupDiLoadClassIcon(&HardwareWiz->DeviceInfoData.ClassGuid, &hicon, NULL)) {

                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                if (hicon) {

                    DestroyIcon(hicon);
                }
            }

            ShowInstallSummary(hDlg, HardwareWiz);
            break;

        case PSN_RESET:
            //
            // Cancel the install
            //
            if (HardwareWiz->Registered) {
                HardwareWiz->Installed = FALSE;
            }
            break;

        case PSN_WIZFINISH:
            //
            // Pnp Device install only consists of copying files
            // when the system does the real install, it will create
            // the proper devnode, so remove our temporary devnode.
            //
            if (HardwareWiz->PnpDevice && HardwareWiz->Registered) {
                HardwareWiz->Installed = FALSE;
                break;
            }
            break;

        case NM_RETURN:
        case NM_CLICK:
            DisplayResource(HardwareWiz, GetParent(hDlg), FALSE);
            break;

        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR CALLBACK
WizExtFinishInstallDlgProc(
                          HWND hDlg, 
                          UINT wMsg, 
                          WPARAM wParam, 
                          LPARAM lParam
                          )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
    case WM_INITDIALOG: {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            break;
        }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_FINISHINSTALL;

            if (PrevPageId == IDD_ADDDEVICE_INSTALLDEV) {
                
                //
                // Moving forward on first page
                //

                //
                // Add ClassWizard Extension pages for FinishInstall
                //
                AddClassWizExtPages(hwndParentDlg,
                                    HardwareWiz,
                                    &HardwareWiz->WizExtFinishInstall.DeviceWizardData,
                                    DIF_NEWDEVICEWIZARD_FINISHINSTALL
                                   );

                //
                // Add the end page, which is FinishInstall end
                //
                HardwareWiz->WizExtFinishInstall.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL_END,
                                                                                  WizExtFinishInstallEndDlgProc,
                                                                                  HardwareWiz
                                                                                 );

                if (HardwareWiz->WizExtFinishInstall.hPropSheetEnd) {
                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtFinishInstall.hPropSheetEnd);
                }
            }


            //
            // We can't go backwards, so always go forward
            //

            SetDlgMsgResult(hDlg, wMsg, -1);
            break;

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtFinishInstallEndDlgProc(
                             HWND hDlg, 
                             UINT wMsg, 
                             WPARAM wParam, 
                             LPARAM lParam
                             )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
    case WM_INITDIALOG: {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            break;
        }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            PrevPageId = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_WIZARDEXT_FINISHINSTALL_END;

            //
            // We can't go backwards, so always go forward
            //

            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_FINISH);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\cfgmgr32\util.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains general utility routines used by cfgmgr32 code.

               INVALID_DEVINST
               CopyFixedUpDeviceId
               PnPUnicodeToMultiByte
               PnPMultiByteToUnicode
               PnPRetrieveMachineName
               PnPGetVersion
               PnPGetGlobalHandles
               EnablePnPPrivileges
               IsRemoteServiceRunning

Author:

    Paula Tomlinson (paulat) 6-22-1995

Environment:

    User mode only.

Revision History:

    22-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "cfgi.h"
#include "setupapi.h"
#include "spapip.h"


//
// Private prototypes
//
BOOL
EnablePnPPrivileges(
    VOID
    );


//
// global data
//
extern PVOID    hLocalStringTable;                  // MODIFIED by PnPGetGlobalHandles
extern PVOID    hLocalBindingHandle;                // MODIFIED by PnPGetGlobalHandles
extern WORD     LocalServerVersion;                 // MODIFIED by PnPGetVersion
extern WCHAR    LocalMachineNameNetBIOS[];          // NOT MODIFIED BY THIS FILE
extern CRITICAL_SECTION BindingCriticalSection;     // NOT MODIFIED IN THIS FILE
extern CRITICAL_SECTION StringTableCriticalSection; // NOT MODIFIED IN THIS FILE

LUID            gLuidLoadDriverPrivilege;
LUID            gLuidUndockPrivilege;



BOOL
INVALID_DEVINST(
   PWSTR    pDeviceID
   )

/*++

Routine Description:

    This routine attempts a simple check whether the pDeviceID string
    returned from StringTableStringFromID is valid or not.  It does
    this simply by dereferencing the pointer and comparing the first
    character in the string against the range of characters for a valid
    device id.  If the string is valid but it's not an existing device id
    then this error will be caught later.

Arguments:

    pDeviceID  Supplies a pointer to the string to be validated.

Return Value:

    If it's invalid it returns TRUE, otherwise it returns FALSE.

--*/
{
    BOOL  Status = FALSE;

    try {

        if ((!ARGUMENT_PRESENT(pDeviceID)) ||
            (*pDeviceID <= TEXT(' '))      ||
            (*pDeviceID > (TCHAR)0x7F)     ||
            (*pDeviceID == TEXT(','))) {
            Status = TRUE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = TRUE;
    }

    return Status;

} // INVALID_DEVINST



VOID
CopyFixedUpDeviceId(
      OUT LPTSTR  DestinationString,
      IN  LPCTSTR SourceString,
      IN  DWORD   SourceStringLen
      )
/*++

Routine Description:

    This routine copies a device id, fixing it up as it does the copy.
    'Fixing up' means that the string is made upper-case, and that the
    following character ranges are turned into underscores (_):

    c <= 0x20 (' ')
    c >  0x7F
    c == 0x2C (',')

    (NOTE: This algorithm is also implemented in the Config Manager APIs,
    and must be kept in sync with that routine. To maintain device identifier
    compatibility, these routines must work the same as Win95.)

Arguments:

    DestinationString - Supplies a pointer to the destination string buffer
        where the fixed-up device id is to be copied.  This buffer must
        be large enough to hold a copy of the source string (including
        terminating NULL).

    SourceString - Supplies a pointer to the (null-terminated) source
        string to be fixed up.

    SourceStringLen - Supplies the length, in characters, of the source
        string (not including terminating NULL).

Return Value:

    None.

--*/
{
    PTCHAR p;

    try {

        CopyMemory(DestinationString,
                   SourceString,
                   ((SourceStringLen + 1) * sizeof(TCHAR)));

        CharUpperBuff(DestinationString, SourceStringLen);

        for(p = DestinationString; *p; p++) {

            if((*p <= TEXT(' '))  ||
               (*p > (TCHAR)0x7F) ||
               (*p == TEXT(','))) {
                *p = TEXT('_');
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

} // CopyFixedUpDeviceId



CONFIGRET
PnPUnicodeToMultiByte(
    IN     PWSTR   UnicodeString,
    IN     ULONG   UnicodeStringLen,
    OUT    PSTR    AnsiString           OPTIONAL,
    IN OUT PULONG  AnsiStringLen
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString    - Supplies string to be converted.

    UnicodeStringLen - Specifies the size, in bytes, of the string to be
                       converted.

    AnsiString       - Optionally, supplies a buffer to receive the ANSI
                       string.

    AnsiStringLen    - Supplies the address of a variable that contains the
                       size, in bytes, of the buffer pointed to by AnsiString.
                       This API replaces the initial size with the number of
                       bytes of data copied to the buffer.  If the variable is
                       initially zero, the API replaces it with the buffer size
                       needed to receive all the registry data.  In this case,
                       the AnsiString parameter is ignored.

Return Value:

    Returns a CONFIGRET code.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    NTSTATUS  ntStatus;
    ULONG     ulAnsiStringLen = 0;

    try {
        //
        // Validate parameters
        //
        if ((!ARGUMENT_PRESENT(AnsiStringLen)) ||
            (!ARGUMENT_PRESENT(AnsiString)) && (*AnsiStringLen != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Determine the size required for the ANSI string representation.
        //
        ntStatus = RtlUnicodeToMultiByteSize(&ulAnsiStringLen,
                                             UnicodeString,
                                             UnicodeStringLen);
        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(AnsiString)) ||
            (*AnsiStringLen < ulAnsiStringLen)) {
            *AnsiStringLen = ulAnsiStringLen;
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        //
        // Perform the conversion.
        //
        ntStatus = RtlUnicodeToMultiByteN(AnsiString,
                                          *AnsiStringLen,
                                          &ulAnsiStringLen,
                                          UnicodeString,
                                          UnicodeStringLen);

        ASSERT(NT_SUCCESS(ntStatus));
        ASSERT(ulAnsiStringLen <= *AnsiStringLen);

        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
        }

        *AnsiStringLen = ulAnsiStringLen;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PnPUnicodeToMultiByte



CONFIGRET
PnPMultiByteToUnicode(
    IN     PSTR    AnsiString,
    IN     ULONG   AnsiStringLen,
    OUT    PWSTR   UnicodeString           OPTIONAL,
    IN OUT PULONG  UnicodeStringLen
    )

/*++

Routine Description:

    Convert a string from ansi to unicode.

Arguments:

    AnsiString       - Supplies string to be converted.

    AnsiStringLen    - Specifies the size, in bytes, of the string to be
                       converted.

    UnicodeString    - Optionally, supplies a buffer to receive the Unicode
                       string.

    UnicodeStringLen - Supplies the address of a variable that contains the
                       size, in bytes, of the buffer pointed to by UnicodeString.
                       This API replaces the initial size with the number of
                       bytes of data copied to the buffer.  If the variable is
                       initially zero, the API replaces it with the buffer size
                       needed to receive all the registry data.  In this case,
                       the UnicodeString parameter is ignored.

Return Value:

    Returns a CONFIGRET code.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    NTSTATUS  ntStatus;
    ULONG     ulUnicodeStringLen = 0;

    try {
        //
        // Validate parameters
        //
        if ((!ARGUMENT_PRESENT(UnicodeStringLen)) ||
            (!ARGUMENT_PRESENT(UnicodeString)) && (*UnicodeStringLen != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Determine the size required for the ANSI string representation.
        //
        ntStatus = RtlMultiByteToUnicodeSize(&ulUnicodeStringLen,
                                             AnsiString,
                                             AnsiStringLen);
        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(UnicodeString)) ||
            (*UnicodeStringLen < ulUnicodeStringLen)) {
            *UnicodeStringLen = ulUnicodeStringLen;
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        //
        // Perform the conversion.
        //
        ntStatus = RtlMultiByteToUnicodeN(UnicodeString,
                                          *UnicodeStringLen,
                                          &ulUnicodeStringLen,
                                          AnsiString,
                                          AnsiStringLen);

        ASSERT(NT_SUCCESS(ntStatus));
        ASSERT(ulUnicodeStringLen <= *UnicodeStringLen);

        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
        }

        *UnicodeStringLen = ulUnicodeStringLen;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PnPMultiByteToUnicode



BOOL
PnPRetrieveMachineName(
    IN  HMACHINE   hMachine,
    OUT LPWSTR     pszMachineName
    )

/*++

Routine Description:

    Optimized version of PnPConnect, only returns the machine name
    associated with this connection.

Arguments:

    hMachine         Information about this connection

    pszMachineName   Returns machine name specified when CM_Connect_Machine
                     was called.

                     ** This buffer must be at least (MAX_PATH + 3)
                     characters long. **

Return Value:

    Return TRUE if the function succeeds and FALSE if it fails.

--*/

{
    BOOL Status = TRUE;

    try {

        if (hMachine == NULL) {
            //
            // local machine scenario
            //
            // use the global local machine name string that was filled
            // when the DLL initialized.
            //
            lstrcpy(pszMachineName, LocalMachineNameNetBIOS);

        } else {
            //
            // remote machine scenario
            //
            // validate the machine handle.
            //
            if (((PPNP_MACHINE)hMachine)->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
                Status = FALSE;
                goto Clean0;
            }

            //
            // use information within the hMachine handle to fill in the
            // machine name.  The hMachine info was set on a previous call
            // to CM_Connect_Machine.
            //
            lstrcpy(pszMachineName, ((PPNP_MACHINE)hMachine)->szMachineName);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

} // PnPRetrieveMachineName



BOOL
PnPGetVersion(
    IN  HMACHINE   hMachine,
    IN  WORD *     pwVersion
    )

/*++

Routine Description:

    This routine returns the internal server version for the specified machine
    connection, as returned by the RPC server interface routine
    PNP_GetVersionInternal.  If the PNP_GetVersionInternal interface does not
    exist on the specified machine, this routine returns the version as reported
    by PNP_GetVersion.

Arguments:

    hMachine  - Information about this connection

    pwVersion - Receives the internal server version.

Return Value:

    Return TRUE if the function succeeds and FALSE if it fails.

Notes:

    The version reported by PNP_GetVersion is defined to be constant, at 0x0400.
    The version returned by PNP_GetVersionInternal may change with each release
    of the product, starting with 0x0501 for Windows NT 5.1.

--*/

{
    BOOL Status = TRUE;
    handle_t hBinding = NULL;
    CONFIGRET crStatus;
    WORD wVersionInternal;

    try {

        if (pwVersion == NULL) {
            return FALSE;
        }

        if (hMachine == NULL) {
            //
            // local machine scenario
            //
            if (LocalServerVersion != 0) {
                //
                // local server version has already been retrieved.
                //
                *pwVersion = LocalServerVersion;

            } else {
                //
                // retrieve binding handle for the local machine.
                //
                if (!PnPGetGlobalHandles(hMachine, NULL, &hBinding)) {
                    return FALSE;
                }

                ASSERT(hBinding);

                //
                // initialize the version supplied to the internal client
                // version, in case the server wants to adjust the response
                // based on the client version.
                //
                wVersionInternal = (WORD)CFGMGR32_VERSION_INTERNAL;

                RpcTryExcept {
                    //
                    // call rpc service entry point
                    //
                    crStatus = PNP_GetVersionInternal(
                        hBinding,           // rpc binding
                        &wVersionInternal); // internal server version
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_WARNINGS,
                               "PNP_GetVersionInternal caused an exception (%d)\n",
                               RpcExceptionCode()));

                    crStatus = MapRpcExceptionToCR(RpcExceptionCode());
                }
                RpcEndExcept

                if (crStatus == CR_SUCCESS) {
                    //
                    // PNP_GetVersionInternal exists on NT 5.1 and later.
                    //
                    ASSERT(wVersionInternal >= (WORD)0x0501);

                    //
                    // initialize the global local server version.
                    //
                    LocalServerVersion = *pwVersion = wVersionInternal;

                } else {
                    //
                    // we successfully retrieved a local binding handle, but
                    // PNP_GetVersionInternal failed for some reason other than
                    // the server not being available.
                    //
                    ASSERT(0);

                    //
                    // although we know this version of the client should match
                    // a version of the server where PNP_GetVersionInternal is
                    // available, it's technically possible (though unsupported)
                    // that this client is communicating with a downlevel server
                    // on the local machine, so we'll have to resort to calling
                    // PNP_GetVersion.
                    //
                    RpcTryExcept {
                        //
                        // call rpc service entry point
                        //
                        crStatus = PNP_GetVersion(
                            hBinding,           // rpc binding
                            &wVersionInternal); // server version
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_WARNINGS,
                                   "PNP_GetVersion caused an exception (%d)\n",
                                   RpcExceptionCode()));

                        crStatus = MapRpcExceptionToCR(RpcExceptionCode());
                    }
                    RpcEndExcept

                    if (crStatus == CR_SUCCESS) {
                        //
                        // PNP_GetVersion should always return 0x0400 on all servers.
                        //
                        ASSERT(wVersionInternal == (WORD)0x0400);

                        //
                        // initialize the global local server version.
                        //
                        LocalServerVersion = *pwVersion = wVersionInternal;

                    } else {
                        //
                        // nothing more we can do here but fail.
                        //
                        ASSERT(0);
                        Status = FALSE;
                    }
                }
            }

        } else {
            //
            // remote machine scenario
            //
            // validate the machine handle.
            //
            if (((PPNP_MACHINE)hMachine)->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
                return FALSE;
            }

            //
            // use information within the hMachine handle to fill in the
            // version.  The hMachine info was set on a previous call to
            // CM_Connect_Machine.
            //
            *pwVersion = ((PPNP_MACHINE)hMachine)->wVersion;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

} // PnPGetVersion



BOOL
PnPGetGlobalHandles(
    IN  HMACHINE   hMachine,
    OUT PVOID     *phStringTable,      OPTIONAL
    OUT PVOID     *phBindingHandle     OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves a handle to the string table and/or the rpc binding
    handle for the specified server machine connection.

Arguments:

    hMachine        - Specifies a server machine connection handle, as returned
                      by CM_Connect_Machine.

    phStringTable   - Optionally, specifies an address to receive a handle to
                      the string table for the specified server machine
                      connection.

    phBindingHandle - Optionally, specifies an address to receive the RPC
                      binding handle for the specifies server machine
                      connection.

Return value:

    Returns TRUE if successful, FALSE otherwise.

--*/

{
    BOOL    bStatus = TRUE;


    try {

        EnablePnPPrivileges();

        if (phStringTable != NULL) {

            if (hMachine == NULL) {

                //------------------------------------------------------
                // Retrieve String Table Handle for the local machine
                //-------------------------------------------------------

                EnterCriticalSection(&StringTableCriticalSection);

                if (hLocalStringTable != NULL) {
                    //
                    // local string table has already been created
                    //
                    *phStringTable = hLocalStringTable;

                } else {
                    //
                    // first time, initialize the local string table
                    //

                    hLocalStringTable = pSetupStringTableInitialize();

                    if (hLocalStringTable == NULL) {
                        bStatus = FALSE;
                        *phStringTable = NULL;

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "CFGMGR32: failed to initialize local string table\n"));

                        goto Clean0;
                    }

                    //
                    // No matter how the string table is implemented, I never
                    // want to have a string id of zero - this would generate
                    // an invalid devinst. So, add a small priming string just
                    // to be safe.
                    //
                    pSetupStringTableAddString(hLocalStringTable,
                                         PRIMING_STRING,
                                         STRTAB_CASE_SENSITIVE);

                    *phStringTable = hLocalStringTable;
                }

                LeaveCriticalSection(&StringTableCriticalSection);

            } else {

                //-------------------------------------------------------
                // Retrieve String Table Handle for the remote machine
                //-------------------------------------------------------

                //
                // validate the machine handle.
                //
                if (((PPNP_MACHINE)hMachine)->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
                    bStatus = FALSE;
                    goto Clean0;
                }

                //
                // use information within the hMachine handle to set the string
                // table handle.  The hMachine info was set on a previous call
                // to CM_Connect_Machine.
                //
                *phStringTable = ((PPNP_MACHINE)hMachine)->hStringTable;
            }
        }



        if (phBindingHandle != NULL) {

            if (hMachine == NULL) {

                //-------------------------------------------------------
                // Retrieve Binding Handle for the local machine
                //-------------------------------------------------------

                EnterCriticalSection(&BindingCriticalSection);

                if (hLocalBindingHandle != NULL) {
                    //
                    // local binding handle has already been set
                    //
                    *phBindingHandle = hLocalBindingHandle;

                } else {
                    //
                    // first time, explicitly force binding to local machine
                    //
                    pnp_handle = PNP_HANDLE_bind(NULL);    // set rpc global

                    if (pnp_handle == NULL) {
                        bStatus = FALSE;
                        *phBindingHandle = NULL;

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "CFGMGR32: failed to initialize local binding handle\n"));

                        goto Clean0;
                    }

                    *phBindingHandle = hLocalBindingHandle = (PVOID)pnp_handle;

                }

                LeaveCriticalSection(&BindingCriticalSection);

            } else {

                //-------------------------------------------------------
                // Retrieve Binding Handle for the remote machine
                //-------------------------------------------------------

                //
                // validate the machine handle.
                //
                if (((PPNP_MACHINE)hMachine)->ulSignature != (ULONG)MACHINE_HANDLE_SIGNATURE) {
                    bStatus = FALSE;
                    goto Clean0;
                }

                //
                // use information within the hMachine handle to set the
                // binding handle.  The hMachine info was set on a previous call
                // to CM_Connect_Machine.
                //
                *phBindingHandle = ((PPNP_MACHINE)hMachine)->hBindingHandle;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bStatus = FALSE;
    }

    return bStatus;

} // PnpGetGlobalHandles



BOOL
EnablePnPPrivileges(
    VOID
    )

/*++

Routine Description:

    This routine attempts to enable the SE_LOAD_DRIVER_NAME and SE_UNDOCK_NAME
    privileges in either the thread token or the calling thread (if
    impersonating), or thread's process token if no thread token exists.

Arguments:

    None.

Return value:

    Returns TRUE if successful, FALSE otherwise.

Notes:

    Note that this routine can return successfully even if either the
    SE_LOAD_DRIVER_NAME or SE_UNDOCK_NAME (or both) privileges were not
    successfully enabled in the appropriate token.

    If sucessful, to determine whether the function adjusted all of the
    specified privileges, call GetLastError to determine the last error set by
    AdjustTokenPrivileges, which returns one of the following values when the
    function succeeds:

      ERROR_SUCCESS          - The function adjusted all specified privileges.

      ERROR_NOT_ALL_ASSIGNED - The token does not have one or more of the
                               privileges enabled.

--*/

{
    HANDLE              hToken;
    PTOKEN_PRIVILEGES   lpTokenPrivs;
    BOOL                bSuccess;

    if (gLuidLoadDriverPrivilege.LowPart == 0 &&
        gLuidLoadDriverPrivilege.HighPart == 0) {

        bSuccess = LookupPrivilegeValue( NULL,
                                         SE_LOAD_DRIVER_NAME,
                                         &gLuidLoadDriverPrivilege);

        if (!bSuccess) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "CFGMGR32: LookupPrivilegeValue failed, error = %d\n",
                       GetLastError()));

            return FALSE;
        }
    }

    if (gLuidUndockPrivilege.LowPart == 0 && gLuidUndockPrivilege.HighPart == 0) {
        bSuccess = LookupPrivilegeValue( NULL,
                                         SE_UNDOCK_NAME,
                                         &gLuidUndockPrivilege);
        if (!bSuccess) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "CFGMGR32: LookupPrivilegeValue failed, error = %d\n",
                       GetLastError()));

            return FALSE;
        }
    }

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken)) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "CFGMGR32: OpenProcessToken returned %d\n",
                           GetLastError()));

                return FALSE;
            }
        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "CFGMGR32: OpenThreadToken returned %d\n",
                       GetLastError()));
            return FALSE;
        }
    }

    lpTokenPrivs = pSetupMalloc(sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES));

    if (lpTokenPrivs == NULL) {

        CloseHandle(hToken);
        return FALSE;
    }

    lpTokenPrivs->PrivilegeCount = 2;

    lpTokenPrivs->Privileges[0].Luid = gLuidLoadDriverPrivilege;
    lpTokenPrivs->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    lpTokenPrivs->Privileges[1].Luid = gLuidUndockPrivilege;
    lpTokenPrivs->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    bSuccess = AdjustTokenPrivileges( hToken,
                                      FALSE,        // DisableAllPrivileges
                                      lpTokenPrivs,
                                      0,
                                      (PTOKEN_PRIVILEGES) NULL,
                                      (PDWORD) NULL);
    if (!bSuccess) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "CFGMGR32: AdjustTokenPrivileges failed: %u\n",
                   GetLastError()));
    }

    pSetupFree(lpTokenPrivs);

    CloseHandle(hToken);

    return bSuccess;

} // EnablePnPPrivileges



BOOL
IsRemoteServiceRunning(
    IN  LPCWSTR   UNCServerName,
    IN  LPCWSTR   ServiceName
    )

/*++

Routine Description:

   This routine connects to the active service database of the Service Control
   Manager (SCM) on the machine specified and returns whether or not the
   specified service is running.

Arguments:

   UNCServerName - Specifies the name of the remote machine.

   ServiceName   - Specifies the name of the service whose status is to be
                   queried.

Return value:

   Returns TRUE if the specified service is installed on the remote machine and
   is currently in the SERVICE_RUNNING state, FALSE otherwise.

--*/

{
    BOOL           Status = FALSE;
    SC_HANDLE      hSCManager = NULL, hService = NULL;
    SERVICE_STATUS ServiceStatus;


    //
    // Open the Service Control Manager
    //
    hSCManager = OpenSCManager(
        UNCServerName,            // computer name
        SERVICES_ACTIVE_DATABASE, // SCM database name
        SC_MANAGER_CONNECT        // access type
        );

    if (hSCManager == NULL) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "CFGMGR32: OpenSCManager failed, error = %d\n",
                   GetLastError()));
        return FALSE;
    }

    //
    // Open the service
    //
    hService = OpenService(
        hSCManager,               // handle to SCM database
        ServiceName,              // service name
        SERVICE_QUERY_STATUS      // access type
        );

    if (hService == NULL) {
        Status = FALSE;
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "CFGMGR32: OpenService failed, error = %d\n",
                   GetLastError()));
        goto Clean0;
    }

    //
    // Query the service status
    //
    if (!QueryServiceStatus(hService,
                            &ServiceStatus)) {
        Status = FALSE;
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "CFGMGR32: QueryServiceStatus failed, error = %d\n",
                   GetLastError()));
        goto Clean0;
    }

    //
    // Check if the service is running.
    //
    if (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
        Status = TRUE;
    }

 Clean0:

    if (hService) {
        CloseServiceHandle(hService);
    }

    if (hSCManager) {
        CloseServiceHandle(hSCManager);
    }

    return Status;

} // IsRemoteServiceRunning
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\devcfg.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       devcfg.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <initguid.h>
#include <devguid.h>


//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

TCHAR szUnknownDevice[64];
USHORT LenUnknownDevice;

TCHAR szUnknown[64];
USHORT LenUnknown;

PTCHAR
BuildFriendlyName(
   DEVINST DevInst,
   HMACHINE hMachine
   )
{
    PTCHAR Location;
    PTCHAR FriendlyName;
    CONFIGRET ConfigRet;
    ULONG ulSize;
    TCHAR szBuffer[MAX_PATH];

    //
    // Try the registry for FRIENDLYNAME
    //

    ulSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                    CM_DRP_FRIENDLYNAME,
                                                    NULL,
                                                    szBuffer,
                                                    &ulSize,
                                                    0,
                                                    hMachine
                                                    );
    if (ConfigRet != CR_SUCCESS || !*szBuffer) {
        //
        // Try the registry for DEVICEDESC
        //

        ulSize = sizeof(szBuffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                        CM_DRP_DEVICEDESC,
                                                        NULL,
                                                        szBuffer,
                                                        &ulSize,
                                                        0,
                                                        hMachine
                                                        );
        if (ConfigRet != CR_SUCCESS || !*szBuffer) {
            
            GUID ClassGuid;

            //
            // Initialize ClassGuid to GUID_NULL
            //
            CopyMemory(&ClassGuid,
                       &GUID_NULL,
                       sizeof(GUID)
                       );
            
            //
            // Try the registry for CLASSNAME
            //
            ulSize = sizeof(szBuffer);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                            CM_DRP_CLASSGUID,
                                                            NULL,
                                                            szBuffer,
                                                            &ulSize,
                                                            0,
                                                            hMachine
                                                            );


            if (ConfigRet == CR_SUCCESS) {
                pSetupGuidFromString(szBuffer, &ClassGuid);
                }


            if (!IsEqualGUID(&ClassGuid, &GUID_NULL) &&
                !IsEqualGUID(&ClassGuid, &GUID_DEVCLASS_UNKNOWN))
              {
                ulSize = sizeof(szBuffer);
                ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                                CM_DRP_CLASS,
                                                                NULL,
                                                                szBuffer,
                                                                &ulSize,
                                                                0,
                                                                hMachine
                                                                );
                }
            else {
                ConfigRet = ~CR_SUCCESS;
                }


            }
        }


    if (ConfigRet == CR_SUCCESS && *szBuffer) {
        FriendlyName = LocalAlloc(LPTR, ulSize);
        if (FriendlyName) {
            memcpy(FriendlyName, szBuffer, ulSize);
            }
        }
    else {
        FriendlyName = NULL;
        }


    return FriendlyName;
}

void
AddItemToListView(
    PHARDWAREWIZ HardwareWiz,
    HWND hwndListView,
    DEVINST DevInst,
    DWORD Problem,
    BOOL HiddenDevice,
    DEVINST SelectedDevInst
    )
{
    INT Index;
    LV_ITEM lviItem;
    PTCHAR FriendlyName;
    PTCHAR LocationInfo;
    GUID ClassGuid;
    ULONG ulSize;
    CONFIGRET ConfigRet;
    TCHAR szBuffer[MAX_PATH];


    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iSubItem = 0;
    lviItem.lParam = DevInst;

    //
    // Devices with problems need to go at the top of the list
    //
    if (Problem) {
    
        lviItem.iItem = 0;

    } else {

        lviItem.iItem = ListView_GetItemCount(hwndListView);
    }
    
    //
    // fetch a name for this device
    //

    FriendlyName = BuildFriendlyName(DevInst, HardwareWiz->hMachine);
    if (FriendlyName) {
    
        lviItem.pszText = FriendlyName;

    } else {
    
        lviItem.pszText = szUnknown;
    }

    //
    // Fetch the class icon for this device.
    //

    ulSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                    CM_DRP_CLASSGUID,
                                                    NULL,
                                                    szBuffer,
                                                    &ulSize,
                                                    0,
                                                    HardwareWiz->hMachine
                                                    );


    if (ConfigRet == CR_SUCCESS) {
    
        pSetupGuidFromString(szBuffer, &ClassGuid);

    } else {
    
        ClassGuid = GUID_DEVCLASS_UNKNOWN;
    }

    if (SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                  &ClassGuid,
                                  &lviItem.iImage
                                  ))
    {
        lviItem.mask |= (LVIF_IMAGE | LVIF_STATE);

        if (Problem) {
        
            lviItem.state = (Problem == CM_PROB_DISABLED) ?
                            INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1) :
                            INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);

        } else {

            lviItem.state = INDEXTOOVERLAYMASK(0);
        }

        lviItem.stateMask = LVIS_OVERLAYMASK;

        if (HiddenDevice) {

            lviItem.state |= LVIS_CUT;
            lviItem.stateMask |= LVIS_CUT;
        }
    }

    Index = ListView_InsertItem(hwndListView, &lviItem);

    if ((Index != -1) && (SelectedDevInst == DevInst)) {

        ListView_SetItemState(hwndListView,
                              Index,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED
                              );
    }


    if (FriendlyName) {
    
        LocalFree(FriendlyName);
    }

    return;
}


BOOL
BuildDeviceListView(
    PHARDWAREWIZ HardwareWiz,
    HWND hwndListView,
    BOOL ShowHiddenDevices,
    DEVINST SelectedDevInst,
    DWORD *DevicesDetected,
    ADDDEVNODETOLIST_CALLBACK AddDevNodeToListCallBack
    )
{
    HDEVINFO hDeviceInfo;
    DWORD Index;
    ULONG DevNodeStatus, DevNodeProblem;
    SP_DEVINFO_DATA DevInfoData;
    BOOL HiddenDevice;

    *DevicesDetected = 0;

    hDeviceInfo = SetupDiGetClassDevsEx(NULL,   // classguid
                                        NULL,   // enumerator
                                        NULL,   // hdwnParent
                                        ShowHiddenDevices ? DIGCF_ALLCLASSES : DIGCF_ALLCLASSES | DIGCF_PRESENT,
                                        NULL,   // existing HDEVINFO set
                                        HardwareWiz->hMachine ? HardwareWiz->MachineName : NULL,
                                        0
                                        );
                                        
    if (hDeviceInfo == INVALID_HANDLE_VALUE) {
    
        return FALSE;
    }

    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    Index = 0;
    while (SetupDiEnumDeviceInfo(hDeviceInfo, Index++, &DevInfoData)) {

        if (CM_Get_DevNode_Status_Ex(&DevNodeStatus,
                                     &DevNodeProblem,
                                     DevInfoData.DevInst,
                                     0,
                                     HardwareWiz->hMachine
                                     ) != CR_SUCCESS) {
        
            DevNodeProblem = 0;
        }

        HiddenDevice = IsDeviceHidden(HardwareWiz, &DevInfoData);

        //
        // Only call AddItemToListView if the device is not a hidden device.
        //
        if (ShowHiddenDevices || !HiddenDevice) {
        
            //
            // Check the callback to see if we should add this devnode to the list.
            //
            if (!AddDevNodeToListCallBack || AddDevNodeToListCallBack(HardwareWiz, &DevInfoData)) {
                
                *DevicesDetected += 1;

                //
                // Add the item to the ListView
                //
                AddItemToListView(HardwareWiz,
                                  hwndListView,
                                  DevInfoData.DevInst,
                                  DevNodeProblem,
                                  HiddenDevice,
                                  SelectedDevInst);
            }
        }

        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    }
    
    SetupDiDestroyDeviceInfoList(hDeviceInfo);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\detect.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       detect.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"


typedef
UINT
(*PINSTALLSELECTEDDEVICE)(
    HWND hwndParent,
    HDEVINFO hDeviceInfo,
    PDWORD pReboot
    );

PINSTALLSELECTEDDEVICE pInstallSelectedDevice = NULL;


/*
 * BuildMissingAndNew
 *
 * worker routine for BuildDeviceDetection.
 *
 * On entry:
 * Missing contains known devices prior to class installer detection.
 * Detected contains devices detected by class installer.
 * NewDevices is an empty list.
 *
 * If a device is in Missing and not in Detected, then it is missing.
 * If a device is in Detected and not in Missing, then it is newly detected.
 *
 * On Exit:
 * Missing contains only missing devices,
 * Detected gone.
 * NewDevices contains those that were newly detectd
 *
 */
BOOL
BuildMissingAndNew(
    HWND hwndParent,
    PCLASSDEVINFO ClassDevInfo
    )
{
    HDEVINFO Missing, Detected;
    int iMissing, iDetect;
    ULONG DevNodeStatus, Problem;
    SP_DEVINFO_DATA DevInfoDataDetect;
    SP_DEVINFO_DATA DevInfoDataMissing;
    TCHAR DetectedId[MAX_DEVICE_ID_LEN +sizeof(TCHAR)];
    BOOL Removed;

    Detected   = ClassDevInfo->Detected;
    Missing    = ClassDevInfo->Missing;

    DevInfoDataMissing.cbSize = sizeof(DevInfoDataMissing);
    DevInfoDataDetect.cbSize = sizeof(DevInfoDataDetect);



    //
    // For each member of the detected list, fetch its Device ID
    // and see if it exists in the missing list.
    //

BMNBuildDetectedList:
    Removed = FALSE;
    iMissing = 0;
    
    while (SetupDiEnumDeviceInfo(Missing, iMissing++, &DevInfoDataMissing)) {

        iDetect = 0;
        while (SetupDiEnumDeviceInfo(Detected, iDetect++, &DevInfoDataDetect)) {

            //
            // If Found in both lists, its not a new device and exists(not missing).
            // remove it from both lists.
            //

            if (DevInfoDataDetect.DevInst == DevInfoDataMissing.DevInst) {

                SetupDiDeleteDeviceInfo(Missing, &DevInfoDataMissing);
                SetupDiDeleteDeviceInfo(Detected, &DevInfoDataDetect);
                Removed = TRUE;
                break;
            }
        }
    }

    //
    // If a device info was removed, the enumeration index changes
    // and we will miss some in the list. Rescan until none are deleted.
    //

    if (Removed && SetupDiEnumDeviceInfo(Detected, 0, &DevInfoDataDetect)) {

        goto BMNBuildDetectedList;
    }


    //
    // Remove devices which are up and running from the misssing list,
    // since they are obviously present. Class installers may not report
    // all devices which are present, if they are already installed and
    // running. e.g. Bios enumerated devices. We also check that it is
    // a Root Enumerated Device (not a PnP BIOS device) and that it was
    // not a manually installed device.
    //

BMNRemoveLiveFromMissing:
    Removed = FALSE;
    iMissing = 0;

    while (SetupDiEnumDeviceInfo(Missing, iMissing++, &DevInfoDataMissing)) {

        if ((CM_Get_DevNode_Status(&DevNodeStatus,
                                  &Problem,
                                  DevInfoDataMissing.DevInst,
                                  0) == CR_SUCCESS) &&
            ((DevNodeStatus & DN_STARTED) &&
             !(DevNodeStatus & DN_HAS_PROBLEM)) ||
             !(DevNodeStatus & DN_ROOT_ENUMERATED) ||
            (DevNodeStatus & DN_MANUAL)) {
            
            SetupDiDeleteDeviceInfo(Missing, &DevInfoDataMissing);
            Removed = TRUE;
        }
    }


    if (Removed) {

        goto BMNRemoveLiveFromMissing;
    }


    //
    // Register the newly detected devices
    //

BMNRegisterDetected:
    Removed = FALSE;
    iDetect = 0;

    while (SetupDiEnumDeviceInfo(Detected, iDetect++, &DevInfoDataDetect)) {

        if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
                                       Detected,
                                       &DevInfoDataDetect
                                       )) {
                                       
            SetupDiDeleteDeviceInfo(Detected, &DevInfoDataDetect);
            Removed = TRUE;
        }
    }

    if (Removed) {
    
        goto BMNRegisterDetected;
    }


    //
    // if the missing devices list is empty, don't need it anymore either
    //
    if (!SetupDiEnumDeviceInfo(Missing, 0, &DevInfoDataMissing)) {
    
        SetupDiDestroyDeviceInfoList(Missing);
        ClassDevInfo->Missing = NULL;
    }

    return SetupDiEnumDeviceInfo(Detected, 0, &DevInfoDataDetect) || ClassDevInfo->Missing;
}

BOOL
DevInstIsSelected(
   HWND hwndListView,
   DEVINST DevInst
   )
{
    LVITEM lvItem;

    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;
    lvItem.iItem = -1;

    while ((lvItem.iItem = ListView_GetNextItem(hwndListView, lvItem.iItem, LVNI_ALL)) != -1) {
    
        ListView_GetItem(hwndListView, &lvItem);

        if (lvItem.lParam == (LPARAM)DevInst) {
        
            // Image list is 0 based, and one means checked.
            return (ListView_GetCheckState(hwndListView, lvItem.iItem) == 1);
        }
    }

    return FALSE;
}

void
RemoveDeviceInfo(
   HDEVINFO DeviceInfo,
   HWND hwndListView
   )
{
    int Index;
    SP_REMOVEDEVICE_PARAMS RemoveDeviceParams;
    SP_DEVINFO_DATA DevInfoData;

    Index = 0;
    DevInfoData.cbSize = sizeof(DevInfoData);

    while (SetupDiEnumDeviceInfo(DeviceInfo, Index++, &DevInfoData)) {
    
        if (!hwndListView || DevInstIsSelected(hwndListView, DevInfoData.DevInst)) {
       
            RemoveDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            RemoveDeviceParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
            RemoveDeviceParams.Scope = DI_REMOVEDEVICE_GLOBAL;
            RemoveDeviceParams.HwProfile = 0;

            if (SetupDiSetClassInstallParams(DeviceInfo,
                                            &DevInfoData,
                                            (PSP_CLASSINSTALL_HEADER)&RemoveDeviceParams,
                                            sizeof(RemoveDeviceParams)
                                            )) {
                                            
                SetupDiCallClassInstaller(DIF_REMOVE, DeviceInfo, &DevInfoData);
            }

            //
            // Clear the class install parameters.
            //

            SetupDiSetClassInstallParams(DeviceInfo,
                                         &DevInfoData,
                                         NULL,
                                         0
                                         );
        }
    }

    SetupDiDestroyDeviceInfoList(DeviceInfo);
}

void
DestroyClassDevinfo(
    PCLASSDEVINFO ClassDevInfo
    )
{
    if (ClassDevInfo->Missing) {
    
        SetupDiDestroyDeviceInfoList(ClassDevInfo->Missing);
        ClassDevInfo->Missing = NULL;
    }

    if (ClassDevInfo->Detected) {
    
        SetupDiDestroyDeviceInfoList(ClassDevInfo->Detected);
        ClassDevInfo->Detected = NULL;
    }
}

void
DestroyDeviceDetection(
    PHARDWAREWIZ HardwareWiz,
    BOOL DetectionCancelled
    )
{
    int ClassGuidNum;
    PCLASSDEVINFO ClassDevInfo;
    LPGUID ClassGuid;

    if (!HardwareWiz->DeviceDetection) {
        
        return;
    }

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid    = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;

    while (ClassGuidNum--) {
    
        if (DetectionCancelled) {

            //
            // If there is a detected list,
            // then invoke the class installer DIF_DETECTCANCEL for its cleanup.
            //

            if (ClassDevInfo->Detected) {
           
                SetupDiCallClassInstaller(DIF_DETECTCANCEL, ClassDevInfo->Detected, NULL);

                //
                // Remove all newly detected devices.
                //

                if (ClassDevInfo->Detected) {
               
                    RemoveDeviceInfo(ClassDevInfo->Detected, NULL);
                    ClassDevInfo->Detected = NULL;
                }
            }
        }

        DestroyClassDevinfo(ClassDevInfo);
        ClassDevInfo++;
        ClassGuid++;
    }

    if (DetectionCancelled) {
    
        HardwareWiz->Reboot = FALSE;
    }

    LocalFree(HardwareWiz->DeviceDetection);
    HardwareWiz->DeviceDetection = NULL;
}

BOOL
DetectProgressNotify(
    PVOID pvProgressNotifyParam,
    DWORD DetectComplete
    )
{
    PHARDWAREWIZ HardwareWiz = pvProgressNotifyParam;
    BOOL ExitDetect;

    try  {
    
        ExitDetect = HardwareWiz->ExitDetect;

        HardwareWiz->DeviceDetection->ClassProgress += (UCHAR)DetectComplete;

        SendDlgItemMessage(HardwareWiz->DeviceDetection->hDlg,
                           IDC_HDW_DETWARN_PROGRESSBAR,
                           PBM_SETPOS,
                           DetectComplete,
                           0
                           );

        SendDlgItemMessage(HardwareWiz->DeviceDetection->hDlg,
                           IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                           PBM_SETPOS,
                           (HardwareWiz->DeviceDetection->TotalProgress + DetectComplete/100),
                           0
                           );
    }

    except(EXCEPTION_EXECUTE_HANDLER)  {
    
        ExitDetect = TRUE;
    }

    return ExitDetect;
}

VOID
SortClassGuidListForDetection(
    IN OUT LPGUID GuidList,
    IN     ULONG  GuidCount
    )
/*++

Routine Description:

        This routine sorts the supplied list of GUID based on a (partial) ordering
        specified in the [DetectionOrder] section of syssetup.inf.  This allows us
        to maintain a detection ordering similar to previous versions of NT.

Arguments:

        GuidList - address of the array of GUIDs to be sorted.

        GuidCount - the number of GUIDs in the array.

Return Value:

        none.

--*/
{
    HINF SyssetupInf;
    LONG LineCount, LineIndex, GuidIndex, NextTopmost;
    PCWSTR CurGuidString;
    INFCONTEXT InfContext;
    GUID CurGuid;

    if ((SyssetupInf = SetupOpenInfFile(L"syssetup.inf",
                                        NULL,
                                        INF_STYLE_WIN4,
                                        NULL
                                        )
         ) == INVALID_HANDLE_VALUE) {

        return;
    }

    LineCount = SetupGetLineCount(SyssetupInf, L"DetectionOrder");
    NextTopmost = 0;

    for(LineIndex = 0; LineIndex < LineCount; LineIndex++) {

        if(!SetupGetLineByIndex(SyssetupInf, L"DetectionOrder", LineIndex, &InfContext) ||
           ((CurGuidString = pSetupGetField(&InfContext, 1)) == NULL) ||
           (pSetupGuidFromString((PWCHAR)CurGuidString, &CurGuid) != NO_ERROR)) {

            continue;
        }

        //
        // Search through the GUID list looking for this GUID.  If found, move the GUID from
        // it's current position to the next topmost position.
        //
        for(GuidIndex = 0; GuidIndex < (LONG)GuidCount; GuidIndex++) {

            if(IsEqualGUID(&CurGuid, &(GuidList[GuidIndex]))) {

                if(NextTopmost != GuidIndex) {
                    //
                    // We should never be moving the GUID _down_ the list.
                    //
                    MoveMemory(&(GuidList[NextTopmost + 1]),
                               &(GuidList[NextTopmost]),
                               (GuidIndex - NextTopmost) * sizeof(GUID)
                              );

                    CopyMemory(&(GuidList[NextTopmost]),
                               &CurGuid,
                               sizeof(GUID)
                              );
                }

                NextTopmost++;
                break;
            }
        }
    }

    SetupCloseInfFile(SyssetupInf);
}

void
BuildDeviceDetection(
    HWND hwndParent,
    PHARDWAREWIZ HardwareWiz
    )
{
    HDEVINFO hDeviceInfo;
    int ClassGuidNum;
    LPGUID ClassGuid;
    PCLASSDEVINFO ClassDevInfo;
    BOOL  MissingOrNew = FALSE;
    SP_DETECTDEVICE_PARAMS DetectDeviceParams;
    TCHAR ClassName[MAX_PATH];
    TCHAR Buffer[MAX_PATH + 64];
    TCHAR Format[64];

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;

    SortClassGuidListForDetection(ClassGuid, ClassGuidNum);

    DetectDeviceParams.ClassInstallHeader.cbSize = sizeof(DetectDeviceParams.ClassInstallHeader);
    DetectDeviceParams.ClassInstallHeader.InstallFunction = DIF_DETECT;
    DetectDeviceParams.DetectProgressNotify = DetectProgressNotify;
    DetectDeviceParams.ProgressNotifyParam  = HardwareWiz;

    HardwareWiz->DeviceDetection->TotalProgress = 0;
    HardwareWiz->DeviceDetection->hDlg = hwndParent;
    SetDlgText(hwndParent, IDC_HDW_DETWARN_PROGRESSTEXT, IDS_DETECTPROGRESS, IDS_DETECTPROGRESS);

    while (!HardwareWiz->ExitDetect && ClassGuidNum--) 
    {
        hDeviceInfo = SetupDiGetClassDevs(ClassGuid,
                                          REGSTR_KEY_ROOTENUM,
                                          hwndParent,
                                          DIGCF_PROFILE
                                          );

        if (hDeviceInfo != INVALID_HANDLE_VALUE) 
        {
            ClassDevInfo->Missing = hDeviceInfo;
        }


        hDeviceInfo =  SetupDiCreateDeviceInfoList(ClassGuid, hwndParent);
        if (hDeviceInfo != INVALID_HANDLE_VALUE) 
        {
            ClassDevInfo->Detected = hDeviceInfo;
        }

        HardwareWiz->DeviceDetection->ClassGuid = ClassGuid;
        HardwareWiz->DeviceDetection->ClassProgress = 0;

        // set progress bar to zero.
        SendDlgItemMessage(hwndParent,
                           IDC_HDW_DETWARN_PROGRESSBAR,
                           PBM_SETPOS,
                           0,
                           0
                           );

        if (!SetupDiGetClassDescription(HardwareWiz->DeviceDetection->ClassGuid,
                                        ClassName,
                                        sizeof(ClassName)/sizeof(TCHAR),
                                        NULL
                                        )
            &&
            !SetupDiClassNameFromGuid(HardwareWiz->DeviceDetection->ClassGuid,
                                      ClassName,
                                      sizeof(ClassName)/sizeof(TCHAR),
                                      NULL
                                      ))
        {
            *ClassName = TEXT('\0');
        }

        LoadString(hHdwWiz, IDS_DETECTCLASS, Format, sizeof(Format)/sizeof(TCHAR));
        wsprintf(Buffer, Format, ClassName);

        SetDlgItemText(hwndParent,
                       IDC_HDW_DETWARN_PROGRESSTEXT,
                       Buffer
                       );

        if (!IsEqualGUID(ClassGuid, &GUID_NULL) &&
            !IsEqualGUID(ClassGuid, &GUID_DEVCLASS_UNKNOWN) &&
            ClassDevInfo->Missing &&
            ClassDevInfo->Detected &&
            SetupDiSetClassInstallParams(ClassDevInfo->Detected,
                                         NULL,
                                         &DetectDeviceParams.ClassInstallHeader,
                                         sizeof(DetectDeviceParams)
                                         )
            &&
            SetupDiCallClassInstaller(DIF_DETECT, ClassDevInfo->Detected, NULL))
        {
            SP_DEVINSTALL_PARAMS DeviceInstallParams;
            SendDlgItemMessage(hwndParent,
                               IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                               PBM_SETPOS,
                               HardwareWiz->DeviceDetection->TotalProgress,
                               0
                               );

            //
            // Clear the class install parameters.
            //

            SetupDiSetClassInstallParams(ClassDevInfo->Detected,
                                         NULL,
                                         NULL,
                                         0
                                         );

            //
            // Get the device install parameters for the reboot flags.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(ClassDevInfo->Detected,
                                              NULL,
                                              &DeviceInstallParams
                                              ))
            {
                HardwareWiz->DeviceDetection->Reboot |= DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT);
            }


            if (BuildMissingAndNew(hwndParent, ClassDevInfo)) 
            {
                HardwareWiz->DeviceDetection->MissingOrNew = TRUE;
            }
        }
        
        else 
        {
            DestroyClassDevinfo(ClassDevInfo);
        }

        HardwareWiz->DeviceDetection->TotalProgress += 10;
        SendDlgItemMessage(hwndParent, IDC_HDW_DETWARN_PROGRESSBAR, PBM_SETPOS, 100, 0);
        SendDlgItemMessage(hwndParent, IDC_HDW_DETWARN_TOTALPROGRESSBAR, PBM_STEPIT, 0, 0);
        ClassDevInfo++;
        ClassGuid++;
    }
}

INT_PTR CALLBACK
HdwDetectionDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndParentDlg=GetParent(hDlg);

    switch (wMsg)  {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

        break;
        }

    case WM_DESTROY:
        CancelSearchRequest(HardwareWiz);
        DestroyDeviceDetection(HardwareWiz, FALSE);
        break;

    break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE: {
           int Len, PrevPage;

            PrevPage = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_ADDDEVICE_DETECTION;

                // Coming back, after doing a previous detection
            if (PrevPage == IDD_ADDDEVICE_DETECTINSTALL) {
                DestroyDeviceDetection(HardwareWiz, TRUE);
                PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);
                break;
                }


            //
            // Only back,cancel button, when detection completes ok, we will
            // jump directly to the next page.
            //

            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK );

            // refresh the class guid list
            HdwBuildClassInfoList(HardwareWiz, 
                                  DIBCI_NOINSTALLCLASS,
                                  HardwareWiz->hMachine ? HardwareWiz->MachineName : NULL
                                  );

            // allocate memory for DeviceDetection data
            Len = sizeof(DEVICEDETECTION) + (HardwareWiz->ClassGuidNum * sizeof(CLASSDEVINFO));
            HardwareWiz->DeviceDetection = LocalAlloc(LPTR, Len);
            if (!HardwareWiz->DeviceDetection) {
                
                PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);
                break;
            }

            memset(HardwareWiz->DeviceDetection, 0, Len);
            HardwareWiz->ExitDetect = FALSE;

            // set progress bar to zero.
            SendDlgItemMessage(hDlg,
                               IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                               PBM_SETPOS,
                               0,
                               0
                               );

            // set the range to 10 * number of classes
            SendDlgItemMessage(hDlg,
                               IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                               PBM_SETRANGE,
                               0,
                               MAKELPARAM(0, 10 * HardwareWiz->ClassGuidNum)
                               );

            // set the step to 10.
            SendDlgItemMessage(hDlg,
                               IDC_HDW_DETWARN_TOTALPROGRESSBAR,
                               PBM_SETSTEP,
                               10,
                               0
                               );


            HardwareWiz->CurrCursor = HardwareWiz->IdcAppStarting;
            SetCursor(HardwareWiz->CurrCursor);

            SearchThreadRequest(HardwareWiz->SearchThread,
                                hDlg,
                                SEARCH_DETECT,
                                0
                                );

            }
            break;


        case PSN_QUERYCANCEL:

            if (HardwareWiz->ExitDetect) {
                SetDlgMsgResult(hDlg, wMsg, TRUE);
                }

            HardwareWiz->ExitDetect = TRUE;
            HardwareWiz->CurrCursor = HardwareWiz->IdcWait;
            SetCursor(HardwareWiz->CurrCursor);
            CancelSearchRequest(HardwareWiz);
            HardwareWiz->CurrCursor = NULL;

            SetDlgMsgResult(hDlg, wMsg, FALSE);
            break;

        case PSN_RESET:
            DestroyDeviceDetection(HardwareWiz, TRUE);
            break;


            //
            // we receive back if
            //   coming back from a previous search result
            //   when user wants to stop current search.
            //

        case PSN_WIZBACK:
            if (HardwareWiz->DeviceDetection) {
                if (HardwareWiz->ExitDetect) {
                    SetDlgMsgResult(hDlg, wMsg, -1);
                    break;
                    }

                HardwareWiz->ExitDetect = TRUE;
                HardwareWiz->CurrCursor = HardwareWiz->IdcWait;
                SetCursor(HardwareWiz->CurrCursor);
                CancelSearchRequest(HardwareWiz);
                HardwareWiz->CurrCursor = NULL;

                DestroyDeviceDetection(HardwareWiz, TRUE);
                }

            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_ASKDETECT);
            break;


             //
             // next button is off, we only receive this after doing detection.
             //

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTINSTALL);
            break;

        }
        break;


    case WUM_DETECT:
        HardwareWiz->CurrCursor = NULL;
        SetCursor(HardwareWiz->IdcArrow);

        if (HardwareWiz->ExitDetect == TRUE) {
            break;
            }

        //
        // finish building the missing\detected stuff
        //

        PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

        break;

    case WM_SETCURSOR:
        if (HardwareWiz->CurrCursor) {
            SetCursor(HardwareWiz->CurrCursor);
            break;
            }

         // fall thru to return(FALSE);


    default:
        return(FALSE);
    }

    return(TRUE);
}







DWORD
InstallNewDevices(
    HWND     hwndParent,
    HDEVINFO NewDevices,
    HWND     hwndListView
    )
{
    DWORD Reboot, dwRet = 0;
    int iNewDevices;
    SP_DEVINFO_DATA DevInfoData;

    DevInfoData.cbSize = sizeof(DevInfoData);
    iNewDevices = 0;
    Reboot = 0;

    while (SetupDiEnumDeviceInfo(NewDevices, iNewDevices++, &DevInfoData)) {
   
        if (DevInstIsSelected(hwndListView, DevInfoData.DevInst)) {
          
            SetupDiSetSelectedDevice(NewDevices, &DevInfoData);

            if (hNewDev) {

                if (!pInstallSelectedDevice) {

                    pInstallSelectedDevice = (PVOID) GetProcAddress(hNewDev, "InstallSelectedDevice");
                }
            }

            if (pInstallSelectedDevice) {

                pInstallSelectedDevice(hwndParent,
                                       NewDevices,
                                       &dwRet
                                       );
            }

        } else {
          
            SP_REMOVEDEVICE_PARAMS RemoveDeviceParams;

            RemoveDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            RemoveDeviceParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
            RemoveDeviceParams.Scope = DI_REMOVEDEVICE_GLOBAL;
            RemoveDeviceParams.HwProfile = 0;

            if (SetupDiSetClassInstallParams(NewDevices,
                                             &DevInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&RemoveDeviceParams,
                                             sizeof(RemoveDeviceParams)
                                             )) {
                                             
                SetupDiCallClassInstaller(DIF_REMOVE, NewDevices, &DevInfoData);
            }


            //
            // Clear the class install parameters.
            //

            SetupDiSetClassInstallParams(NewDevices,
                                         &DevInfoData,
                                         NULL,
                                         0
                                         );
        }

        Reboot |= dwRet;
    }

    SetupDiDestroyDeviceInfoList(NewDevices);

    return Reboot;
}



/*
 * InstallMissingAndNewDevices
 *
 * Missing devices are removed.
 * NewDevices are installed by invoking InstallDevic
 *
 */
void
InstallDetectedDevices(
    HWND hwndParent,
    PHARDWAREWIZ HardwareWiz
    )
{
    int ClassGuidNum;
    PCLASSDEVINFO ClassDevInfo;
    LPGUID ClassGuid;
    HWND hwndDetectList;

    if (!HardwareWiz->DeviceDetection) {
    
        return;
    }

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid    = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;
    hwndDetectList = GetDlgItem(hwndParent,IDC_HDW_INSTALLDET_LIST);;

    while (ClassGuidNum--) {
    
       if (ClassDevInfo->Missing) {
       
           RemoveDeviceInfo(ClassDevInfo->Missing, hwndDetectList);
           ClassDevInfo->Missing = NULL;
       }

       if (ClassDevInfo->Detected) {
       
           HardwareWiz->Reboot |= InstallNewDevices(hwndParent, ClassDevInfo->Detected, hwndDetectList);
           ClassDevInfo->Detected = NULL;
       }

       ClassDevInfo++;
       ClassGuid++;
   }

   HardwareWiz->DeviceDetection->MissingOrNew = FALSE;
}

void
AddDeviceDescription(
    PHARDWAREWIZ HardwareWiz,
    HWND hListView,
    HDEVINFO Devices,
    BOOL Install
    )
{
    PTCHAR FriendlyName;
    LV_ITEM lviItem;
    int iItem;
    int iDevices;
    GUID ClassGuid;
    SP_DEVINFO_DATA DevInfoData;
    SP_DRVINFO_DATA DriverInfoData;
    TCHAR Format[LINE_LEN];
    TCHAR DeviceDesc[MAX_PATH*2];
    TCHAR String[LINE_LEN];

    if (Install) {

        LoadString(hHdwWiz, IDS_INSTALL_LEGACY_DEVICE, Format, sizeof(Format)/sizeof(TCHAR));

    } else {

        LoadString(hHdwWiz, IDS_UNINSTALL_LEGACY_DEVICE, Format, sizeof(Format)/sizeof(TCHAR));
    }


    lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lviItem.iItem = -1;
    lviItem.iSubItem = 0;
    lviItem.state = 0;
    lviItem.stateMask = LVIS_SELECTED;

    if (HardwareWiz->ClassImageList.cbSize &&
        SetupDiGetDeviceInfoListClass(Devices, &ClassGuid) &&
        SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                  &ClassGuid,
                                  &lviItem.iImage
                                  ))
    {
        lviItem.mask |= LVIF_IMAGE;
    }


    DevInfoData.cbSize = sizeof(DevInfoData);
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    iDevices = 0;
    while (SetupDiEnumDeviceInfo(Devices, iDevices++, &DevInfoData)) {

        lviItem.lParam = DevInfoData.DevInst;

        if (SetupDiGetSelectedDriver(Devices,
                                     &DevInfoData,
                                     &DriverInfoData
                                     )
            &&
            *DriverInfoData.Description)
        {
            wcscpy(DeviceDesc, DriverInfoData.Description);
        }

        else 
        {
            FriendlyName = BuildFriendlyName(DevInfoData.DevInst, NULL);
            
            if (FriendlyName) {
            
                wcscpy(DeviceDesc, FriendlyName);
                LocalFree(FriendlyName);
            }
            else {
                lstrcpyn(DeviceDesc, szUnknown, SIZECHARS(DeviceDesc));
            }
        }

        wsprintf(String, Format, DeviceDesc);

        lviItem.pszText = String;

        //
        // Send it to the listview
        //

        iItem = ListView_InsertItem(hListView, &lviItem);

        if (iItem != -1) {
        
            // set the checkbox, control uses one based index, while imageindex is zero based
            ListView_SetItemState(hListView, iItem, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
        }
    }
}

void
ShowDetectedDevices(
    HWND       hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    INT lvIndex;
    int ClassGuidNum;
    PCLASSDEVINFO ClassDevInfo;
    LPGUID ClassGuid;
    HWND    hwndDetectList;
    PTCHAR  FriendlyName;
    LPTSTR  Description;

    hwndDetectList = GetDlgItem(hDlg,IDC_HDW_INSTALLDET_LIST);
    SendMessage(hwndDetectList, WM_SETREDRAW, FALSE, 0L);
    ListView_DeleteAllItems(hwndDetectList);

    if (HardwareWiz->ClassImageList.cbSize) {
    
        ListView_SetImageList(hwndDetectList,
                              HardwareWiz->ClassImageList.ImageList,
                              LVSIL_SMALL
                              );
    }

    //
    // Display the new devices
    //

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid    = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;

    while (ClassGuidNum--) {
    
       if (ClassDevInfo->Detected) {
       
           AddDeviceDescription(HardwareWiz, hwndDetectList, ClassDevInfo->Detected, TRUE);
       }
       
       ClassDevInfo++;
       ClassGuid++;
   }



    //
    // Display the missing devices
    //

    ClassGuidNum = HardwareWiz->ClassGuidNum;
    ClassGuid    = HardwareWiz->ClassGuidList;
    ClassDevInfo = HardwareWiz->DeviceDetection->ClassDevInfo;

    while (ClassGuidNum--) {
    
       if (ClassDevInfo->Missing) {
       
           AddDeviceDescription(HardwareWiz, hwndDetectList, ClassDevInfo->Missing, FALSE);
       }

       ClassDevInfo++;
       ClassGuid++;
   }


    //
    // scroll the first item into view.
    //

    ListView_EnsureVisible(hwndDetectList, , 0, FALSE);
    ListView_SetColumnWidth(hwndDetectList, , 0, LVSCW_AUTOSIZE_USEHEADER);
    SendMessage(hwndDetectList, WM_SETREDRAW, TRUE, 0L);
}

INT_PTR CALLBACK
HdwDetectInstallDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndParentDlg=GetParent(hDlg);
    TCHAR PropSheetHeaderTitle[MAX_PATH];

    switch (wMsg)  {
    case WM_INITDIALOG: {
        HWND hwndDetectList;
        LV_COLUMN lvcCol;
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);


        hwndDetectList = GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LIST);

        // Insert a column for the class list
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.iSubItem = 0;
        ListView_InsertColumn(hwndDetectList, 0, &lvcCol);

        ListView_SetExtendedListViewStyleEx(hwndDetectList, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);

        break;
        }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:
            HardwareWiz->PrevPage = IDD_ADDDEVICE_DETECTINSTALL;

            if (HardwareWiz->DeviceDetection->MissingOrNew) {
                
                ShowDetectedDevices(hDlg, HardwareWiz);
                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_INSTALLDET1, IDS_HDW_INSTALLDET1);
                PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);

                ShowWindow(GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LISTTITLE), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LIST), SW_SHOW);
            }
            
            else if (HardwareWiz->DeviceDetection->Reboot) {
                
                PropSheet_SetWizButtons(hwndParentDlg, 0);
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTREBOOT);
                break;
            }
            
            else {

                //
                // hide the list box
                //
                ShowWindow(GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LISTTITLE), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_HDW_INSTALLDET_LIST), SW_HIDE);

                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_NONEDET1, IDS_HDW_NONEDET1);
                if (LoadString(hHdwWiz, 
                               IDS_ADDDEVICE_DETECTINSTALL_NONE,
                               PropSheetHeaderTitle,
                               SIZECHARS(PropSheetHeaderTitle)
                               )) {
                    PropSheet_SetHeaderTitle(GetParent(hDlg),
                                             PropSheet_IdToIndex(GetParent(hDlg), IDD_ADDDEVICE_DETECTINSTALL),
                                             PropSheetHeaderTitle
                                             );
                }
                PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);
            }

            break;


        case PSN_WIZBACK:
            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTION);
            break;


        case PSN_WIZNEXT:
            if (HardwareWiz->DeviceDetection->MissingOrNew) {
                
                InstallDetectedDevices(hDlg, HardwareWiz);
                HardwareWiz->Reboot |= HardwareWiz->DeviceDetection->Reboot;

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTREBOOT);

            }
            
            else {
                
                DestroyDeviceDetection(HardwareWiz, FALSE);
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTCLASS);
            }

            break;

        case PSN_RESET:
            DestroyDeviceDetection(HardwareWiz, TRUE);
            break;

        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}






INT_PTR CALLBACK
HdwDetectRebootDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndParentDlg=GetParent(hDlg);


    switch (wMsg)  {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);
        break;
        }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:

            HardwareWiz->PrevPage = IDD_ADDDEVICE_DETECTREBOOT;
            if (HardwareWiz->Reboot && HardwareWiz->PromptForReboot) {
                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_REBOOTDET, IDS_HDW_REBOOTDET);
            }
            
            else {
                SetDlgText(hDlg, IDC_HDW_TEXT, IDS_HDW_NOREBOOTDET, IDS_HDW_NOREBOOTDET);
            }


            //
            // no back, no next! This page is just to confirm that the
            // user will continue detection after rebooting.
            //
            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_FINISH);
            EnableWindow(GetDlgItem(hwndParentDlg, IDCANCEL), FALSE);
            break;


        case PSN_WIZFINISH:
            DestroyDeviceDetection(HardwareWiz, FALSE);
            break;

        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\hdwwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       hdwwiz.h
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cpl.h>
#include <prsht.h>
#include <commctrl.h>
#include <dlgs.h>  
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <spapip.h>
#include <regstr.h>
#include <srrestoreptapi.h>
#include <mountmgr.h>
#include <devguid.h>
#include <powrprofp.h>
#include <shfusion.h>
#include "resource.h"

extern HMODULE hHdwWiz;
extern HMODULE hDevMgr;
extern HMODULE hNewDev;
extern int g_BlankIconIndex;

#define SIZECHARS(x) (sizeof((x))/sizeof(TCHAR))

//
// devmgr.dll exports
//
typedef
UINT
(*PDEVICEPROBLEMTEXT)(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPTSTR Buffer,
    UINT   BufferSize
    );

typedef
int
(*PDEVICEPROPERTIESEX)(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

typedef
int
(*PDEVICEPROBLEMWIZARD)(
    HWND hwndParent,
    PTCHAR MachineName,
    PTCHAR DeviceID
    );



//
// Search thread Functions
//
#define SEARCH_NULL     0
#define SEARCH_EXIT     1
#define SEARCH_DRIVERS  2
#define SEARCH_DELAY    3
#define SEARCH_DETECT   4
#define SEARCH_PNPENUM  5

#define WUM_DELAYTIMER      (WM_USER+280)
#define WUM_DOINSTALL       (WM_USER+281)
#define WUM_DETECT          (WM_USER+282)
#define WUM_PNPENUMERATE    (WM_USER+283)
#define WUM_RESOURCEPICKER  (WM_USER+284)


#define MAX_MESSAGE_STRING    512
#define MAX_MESSAGE_TITLE      50


typedef struct _ResourceBitmapPalette {
  HPALETTE hPalette;
  HBITMAP  hBitmap;
  BITMAP   Bitmap;
} RESOURCEBITMAP, *PRESOURCEBITMAP;

typedef struct _SearchThreadData {
   HWND    hDlg;
   HANDLE  hThread;
   HANDLE  RequestEvent;
   HANDLE  ReadyEvent;
   HANDLE  CancelEvent;
   ULONG   Param;
   UCHAR   Function;
   BOOLEAN CancelRequest;
   LPTSTR  Path;
} SEARCHTHREAD, *PSEARCHTHREAD;

typedef struct _ClassDeviceInfo {
   HDEVINFO Missing;
   HDEVINFO Detected;
} CLASSDEVINFO, *PCLASSDEVINFO;

typedef struct _DeviceDetectionData {
   HWND    hDlg;
   LPGUID  ClassGuid;
   UCHAR   ClassProgress;
   UCHAR   TotalProgress;
   BOOLEAN Reboot;
   BOOLEAN MissingOrNew;
   CLASSDEVINFO ClassDevInfo[1];
} DEVICEDETECTION, *PDEVICEDETECTION;

typedef struct _NewDeviceWizardExtension {
   HPROPSHEETPAGE hPropSheet;
   HPROPSHEETPAGE hPropSheetEnd;         // optional
   SP_NEWDEVICEWIZARD_DATA DeviceWizardData;
} WIZARDEXTENSION, *PWIZARDEXTENSION;

typedef struct _HardwareWizard {
    HDEVINFO                hDeviceInfo;
    HDEVINFO                PNPEnumDeviceInfo;

    INT                     PrevPage;
    INT                     EnterFrom;
    INT                     EnterInto;

    int                     ClassGuidNum;
    int                     ClassGuidSize;
    LPGUID                  ClassGuidList;
    LPGUID                  ClassGuidSelected;
    GUID                    lvClassGuidSelected;
    GUID                    SavedClassGuid;

    HCURSOR                 IdcWait;
    HCURSOR                 IdcAppStarting;
    HCURSOR                 IdcArrow;
    HCURSOR                 CurrCursor;

    HFONT                   hfontTextMarlett;
    HFONT                   hfontTextBold;
    HFONT                   hfontTextBigBold;

    INT                     cyText;

    PSEARCHTHREAD           SearchThread;
    PDEVICEDETECTION        DeviceDetection;           // used by detect code
    SP_DEVINFO_DATA         DeviceInfoData;
    DWORD                   AnalyzeResult;
    HMACHINE                hMachine;
    HWND                    hwndProbList;
    DEVINST                 DevInst;
    DEVINST                 ProblemDevInst;
    SP_INSTALLWIZARD_DATA   InstallDynaWiz;
    HPROPSHEETPAGE          SelectDevicePage;
    SP_CLASSIMAGELIST_DATA  ClassImageList;

    BOOL                    Registered;
    BOOL                    Installed;
    BOOL                    InstallPending;
    BOOL                    Cancelled;
    BOOL                    PnpDevice;
    BOOL                    FoundPnPDevices;
    BOOL                    ExitDetect;
    BOOL                    PromptForReboot;
    BOOL                    RunTroubleShooter;
    BOOL                    Shutdown;

    DWORD                   Reboot;
    DWORD                   LastError;

    WIZARDEXTENSION         WizExtPreSelect;
    WIZARDEXTENSION         WizExtSelect;
    WIZARDEXTENSION         WizExtUnplug;
    WIZARDEXTENSION         WizExtPreAnalyze;
    WIZARDEXTENSION         WizExtPostAnalyze;
    WIZARDEXTENSION         WizExtFinishInstall;

    TCHAR                   MachineName[MAX_PATH+1];
    TCHAR                   ClassName[MAX_CLASS_NAME_LEN];
    TCHAR                   ClassDescription[LINE_LEN];
    TCHAR                   DriverDescription[LINE_LEN];

} HARDWAREWIZ, *PHARDWAREWIZ;

#define NUMPROPPAGES 22

typedef struct _HardwareWizPropertySheet {
   PROPSHEETHEADER   PropSheetHeader;
   HPROPSHEETPAGE    PropSheetPages[NUMPROPPAGES];
} HDWPROPERTYSHEET, *PHDWPROPERTYSHEET;

#define TNULL ((TCHAR)0)

typedef BOOL
(CALLBACK* ADDDEVNODETOLIST_CALLBACK)(
    PHARDWAREWIZ HardwareWiz,
    PSP_DEVINFO_DATA DeviceInfoData
    );


INT_PTR CALLBACK
HdwIntroDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwConnectedDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwConnectedFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwProbListDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwProbListFinishDlgProc(
   HWND   hDlg,
   UINT   wMsg,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwClassListDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwDevicePropDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
HdwPnpEnumDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwPnpFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwAskDetectDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwDetectionDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwDetectInstallDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwDetectRebootDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwPickClassDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwSelectDeviceDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwAnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwInstallDevDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
HdwAddDeviceFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
InstallNewDeviceDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
WizExtPreSelectDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtSelectDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtPreAnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtPreAnalyzeEndDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtPostAnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtPostAnalyzeEndDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtFinishInstallDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
WizExtFinishInstallEndDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

PHDWPROPERTYSHEET
HdwWizard(
   HWND hwndParent,
   PHARDWAREWIZ HardwareWiz,
   int StartPageId
   );


//
// miscutil.c
//

VOID
HdwWizPropagateMessage(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
LoadBitmapAndPalette(
    HINSTANCE hInstance,
    LPCTSTR pszResource,
    PRESOURCEBITMAP ResourceBitmap
    );

LONG
HdwBuildClassInfoList(
    PHARDWAREWIZ HardwareWiz,
    DWORD ClassListFlags,
    PTCHAR MachineName
    );

int
HdwMessageBox(
    HWND hWnd,
    LPTSTR szIdText,
    LPTSTR szIdCaption,
    UINT Type
    );

LONG
HdwUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

BOOL
NoPrivilegeWarning(
   HWND hWnd
   );

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

void
LoadText(
    PTCHAR szText,
    int SizeText,
    int nStartString,
    int nEndString
    );

void
InstallFailedWarning(
    HWND    hDlg,
    PHARDWAREWIZ HardwareWiz
    );

void
SetDlgText(
   HWND hDlg,
   int iControl,
   int nStartString,
   int nEndString
   );

void
SetDriverDescription(
    HWND hDlg,
    int iControl,
    PHARDWAREWIZ HardwareWiz
    );

HPROPSHEETPAGE
CreateWizExtPage(
   int PageResourceId,
   DLGPROC pfnDlgProc,
   PHARDWAREWIZ HardwareWiz
   );

BOOL
AddClassWizExtPages(
   HWND hwndParentDlg,
   PHARDWAREWIZ HardwareWiz,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData,
   DI_FUNCTION InstallFunction
   );

void
RemoveClassWizExtPages(
   HWND hwndParentDlg,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData
   );

BOOL
IsDeviceHidden(
    PHARDWAREWIZ HardwareWiz,
    PSP_DEVINFO_DATA DeviceInfoData
    );

BOOL
ShutdownMachine(
    HWND hWnd
    );

int
DeviceProperties(
    HWND hWnd,
    HMACHINE hMachine,
    LPCSTR MachineName,
    DEVNODE DevNode,
    ULONG Flags
    );

//
// devcfg.c
//
typedef void
(*PFNDETECTPROBCALLBACK)(
   PHARDWAREWIZ HardwareWiz,
   DEVINST DevInst,
   ULONG Problem
   );

BOOL
BuildDeviceListView(
    PHARDWAREWIZ HardwareWiz,
    HWND hwndListView,
    BOOL ShowHiddenDevices,
    DEVINST SelectedDevInst,
    DWORD *DevicesDetected,
    ADDDEVNODETOLIST_CALLBACK AddDevNodeToListCallBack
    );

PTCHAR
BuildFriendlyName(
   DEVINST DevInst,
   HMACHINE hMachine
   );


extern TCHAR szUnknown[64];
extern USHORT LenUnknown;
extern TCHAR szUnknownDevice[64];
extern USHORT LenUnknownDevice;


//
// sthread.c
//
LONG
CreateSearchThread(
   PHARDWAREWIZ HardwareWiz
   );

void
DestroySearchThread(
   PSEARCHTHREAD SearchThread
   );

BOOL
SearchThreadRequest(
   PSEARCHTHREAD SearchThread,
   HWND    hDlg,
   UCHAR   Function,
   ULONG   Param
   );

void
CancelSearchRequest(
    PHARDWAREWIZ HardwareWiz
    );


//
// install.c
//
void
InstallSilentChildSiblings(
   HWND hwndParent,
   PHARDWAREWIZ HardwareWiz,
   DEVINST DeviceInstance,
   BOOL ReinstallAll
   );


//
// pnpenum.c
//
DWORD
PNPEnumerate(
    PHARDWAREWIZ HardwareWiz
    );


//
// detect.c
//
void
BuildDeviceDetection(
    HWND hwndParent,
    PHARDWAREWIZ HardwareWiz
    );


//
// finish.c
//
DWORD
HdwRemoveDevice(
   PHARDWAREWIZ HardwareWiz
   );

BOOL
DeviceHasResources(
   DEVINST DeviceInst
   );

void
DisplayResource(
    PHARDWAREWIZ HardwareWiz,
    HWND hWndParent,
    BOOL NeedsForcedConfig
    );


//
// getdev.c
//
PTCHAR
DeviceProblemText(
   HMACHINE hMachine,
   DEVNODE DevNode,
   ULONG Status,
   ULONG ProblemNumber
   );

BOOL
ProblemDeviceListFilter(
    PHARDWAREWIZ HardwareWiz,
    PSP_DEVINFO_DATA DeviceInfoData
    );



//
// config mgr privates
//
DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );


#ifdef DBG

void
Trace(
    LPCTSTR format,
    ...
    );

#define TRACE( args )          Trace args

#else

#define TRACE( args )

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\hdwwiz.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       hdwwiz.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"
#include <htmlhelp.h>


BOOL
InitHdwIntroDlgProc(
   HWND hDlg,
   PHARDWAREWIZ HardwareWiz
   )
{
   HWND hwnd;
   HDC hDC;
   HFONT hfont;
   HICON hIcon;
   LOGFONT LogFont, LogFontOriginal;
   int FontSize, PtsPixels;

   //
   // Set the windows icons, so that we have the correct icon
   // in the alt-tab menu.
   //

   hwnd = GetParent(hDlg);
   hIcon = LoadIcon(hHdwWiz,MAKEINTRESOURCE(IDI_HDWWIZICON));
   
   if (hIcon) {
       SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
       SendMessage(hwnd, WM_SETICON, ICON_BIG,   (LPARAM)hIcon);
   }

   hIcon = LoadImage(hHdwWiz,
                     MAKEINTRESOURCE(IDI_WARN),
                     IMAGE_ICON,
                     GetSystemMetrics(SM_CXSMICON),
                     GetSystemMetrics(SM_CYSMICON),
                     0
                     );

   if (hIcon) {
       hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_WARNING_ICON, STM_SETICON, (WPARAM)hIcon, 0L);
   }

   if (hIcon) {
       DestroyIcon(hIcon);
   }

   hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_HDWNAME), WM_GETFONT, 0, 0);
   GetObject(hfont, sizeof(LogFont), &LogFont);
   LogFontOriginal = LogFont;

   HardwareWiz->cyText = LogFont.lfHeight;

   if (HardwareWiz->cyText < 0) {
       HardwareWiz->cyText = -HardwareWiz->cyText;
   }

   LogFont = LogFontOriginal;
   LogFont.lfWeight = FW_BOLD;
   HardwareWiz->hfontTextBold = CreateFontIndirect(&LogFont);

   LogFont = LogFontOriginal;
   LogFont.lfWeight = FW_BOLD;

   hDC = GetDC(hDlg);

   if (hDC) {
       //
       // Bump up font height.
       //
       PtsPixels = GetDeviceCaps(hDC, LOGPIXELSY);
       FontSize = 12;
       LogFont.lfHeight = 0 - (PtsPixels * FontSize / 72);
    
       HardwareWiz->hfontTextBigBold = CreateFontIndirect(&LogFont);
   }

   //
   // Create the Marlett font.  In the Marlett font the "i" is a bullet.
   //
   hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_BULLET_1), WM_GETFONT, 0, 0);
   GetObject(hfont, sizeof(LogFont), &LogFont);
   LogFont.lfCharSet = SYMBOL_CHARSET;
   LogFont.lfPitchAndFamily = FF_DECORATIVE | DEFAULT_PITCH;
   lstrcpy(LogFont.lfFaceName, TEXT("Marlett"));
   HardwareWiz->hfontTextMarlett = CreateFontIndirect(&LogFont);

   if (!HardwareWiz->hfontTextMarlett   ||
       !HardwareWiz->hfontTextBold   ||
       !HardwareWiz->hfontTextBigBold )
   {
       return FALSE;
   }

   SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);
   SetWindowFont(GetDlgItem(hDlg, IDC_CD_TEXT), HardwareWiz->hfontTextBold, TRUE);

   //
   // An "i" in the marlett font is a small bullet.
   //
   SetWindowText(GetDlgItem(hDlg, IDC_BULLET_1), TEXT("i"));
   SetWindowFont(GetDlgItem(hDlg, IDC_BULLET_1), HardwareWiz->hfontTextMarlett, TRUE);
   SetWindowText(GetDlgItem(hDlg, IDC_BULLET_2), TEXT("i"));
   SetWindowFont(GetDlgItem(hDlg, IDC_BULLET_2), HardwareWiz->hfontTextMarlett, TRUE);

   return TRUE;
}

//
// Wizard intro dialog proc.
//
INT_PTR CALLBACK
HdwIntroDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )
/*++

Routine Description:


Arguments:

   standard stuff.



Return Value:

   INT_PTR

--*/

{
    PHARDWAREWIZ HardwareWiz;
    HICON hIcon;

    if (message == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ) lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

        if (!InitHdwIntroDlgProc(hDlg, HardwareWiz)) {
            return FALSE;
        }

        return TRUE;
    }

    //
    // retrieve private data from window long (stored there during WM_INITDIALOG)
    //
    HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message) {

    case WM_DESTROY:
        if (HardwareWiz->hfontTextMarlett) {
            DeleteObject(HardwareWiz->hfontTextMarlett);
            HardwareWiz->hfontTextMarlett = NULL;
        }

        if (HardwareWiz->hfontTextBold) {
            DeleteObject(HardwareWiz->hfontTextBold);
            HardwareWiz->hfontTextBold = NULL;
        }

        if (HardwareWiz->hfontTextBigBold) {
            DeleteObject(HardwareWiz->hfontTextBigBold);
            HardwareWiz->hfontTextBigBold = NULL;
        }

        hIcon = (HICON)LOWORD(SendDlgItemMessage(hDlg, IDC_WARNING_ICON, STM_GETICON, 0, 0));
        if (hIcon) {
            DestroyIcon(hIcon);
        }
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY: {
        NMHDR FAR *pnmhdr = (NMHDR FAR *)lParam;

        switch (pnmhdr->code) {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            HardwareWiz->PrevPage = IDD_ADDDEVICE_WELCOME;
            break;

        case PSN_WIZNEXT:
            HardwareWiz->EnterFrom = IDD_ADDDEVICE_WELCOME;
            break;
        }
    }
    break;

    case WM_SYSCOLORCHANGE:
        HdwWizPropagateMessage(hDlg, message, wParam, lParam);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\getdev.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       getdev.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"
#include <htmlhelp.h>

HMODULE hDevMgr=NULL;
PDEVICEPROBLEMTEXT pDeviceProblemText = NULL;

PTCHAR
DeviceProblemText(
                 HMACHINE hMachine,
                 DEVNODE DevNode,
                 ULONG Status,
                 ULONG ProblemNumber
                 )
{
    UINT LenChars, ReqLenChars;
    PTCHAR Buffer=NULL;
    PTCHAR p=NULL;
    TCHAR TempBuffer[MAX_PATH];

    if (hDevMgr) {

        if (!pDeviceProblemText) {

            pDeviceProblemText = (PVOID) GetProcAddress(hDevMgr, "DeviceProblemTextW");
        }
    }

    if (pDeviceProblemText) {

        LenChars = (pDeviceProblemText)(hMachine,
                                        DevNode,
                                        ProblemNumber,
                                        Buffer,
                                        0
                                       );

        if (!LenChars) {

            goto DPTExitCleanup;
        }

        LenChars++;  // one extra for terminating NULL

        Buffer = LocalAlloc(LPTR, LenChars*sizeof(TCHAR));

        if (!Buffer) {

            goto DPTExitCleanup;
        }

        ReqLenChars = (pDeviceProblemText)(hMachine,
                                           DevNode,
                                           ProblemNumber,
                                           Buffer,
                                           LenChars
                                          );

        if (!ReqLenChars || ReqLenChars >= LenChars) {

            LocalFree(Buffer);
            Buffer = NULL;
        }

        if (Buffer && (Status != 0)) {
            if (Status & DN_WILL_BE_REMOVED) {
                if (LoadString(hHdwWiz, 
                               IDS_WILL_BE_REMOVED, 
                               TempBuffer, 
                               SIZECHARS(TempBuffer)
                               )) {
                    LenChars += lstrlen(TempBuffer) + 1;
                    p = LocalAlloc(LPTR, LenChars*sizeof(TCHAR));

                    if (p) {
                        lstrcpy(p, Buffer);
                        lstrcat(p, TempBuffer);
                        LocalFree(Buffer);
                        Buffer = p;
                    }
                }
            }

            if (Status & DN_NEED_RESTART) {
                if (LoadString(hHdwWiz, 
                               IDS_NEED_RESTART, 
                               TempBuffer, 
                               SIZECHARS(TempBuffer)
                               )) {
                    LenChars += lstrlen(TempBuffer) + 1;
                    p = LocalAlloc(LPTR, LenChars*sizeof(TCHAR));

                    if (p) {
                        lstrcpy(p, Buffer);
                        lstrcat(p, TempBuffer);
                        LocalFree(Buffer);
                        Buffer = p;
                    }
                }
            }
        }
    }

    DPTExitCleanup:

    return Buffer;
}

int CALLBACK
DeviceListCompare(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    TCHAR ClassName1[MAX_CLASS_NAME_LEN];
    TCHAR ClassName2[MAX_CLASS_NAME_LEN];
    TCHAR Buffer[MAX_PATH];
    GUID  ClassGuid1, ClassGuid2;
    BOOL  bSpecialClass1 = FALSE, bSpecialClass2 = FALSE;
    ULONG ulLength;
    ULONG Status, Problem1, Problem2;

    //
    // Return
    // -1 if the first item should precede the second
    // +1 if the first item should follow the second
    // 0 if they are the same
    //

    //
    // First check if lParam1 or lParam2 are 0. A 0 lParam means that this
    // is the special 'Add a new hardware device' that goes at the bottom
    // of the list.
    //
    if (lParam1 == 0) {
        return 1;
    }

    if (lParam2 == 0) {
        return -1;
    }

    if (CM_Get_DevNode_Status(&Status, &Problem1, (DEVINST)lParam1, 0) != CR_SUCCESS) {
        Problem1 = 0;
    }
    
    if (CM_Get_DevNode_Status(&Status, &Problem2, (DEVINST)lParam2, 0) != CR_SUCCESS) {
        Problem2 = 0;
    }

    //
    // Devices with problems always go at the top of the list.  If both devices
    // have problems then we sort by class name.
    //
    if (Problem1 && !Problem2) {
        return -1;
    } else if (!Problem1 && Problem2) {
        return 1;
    }
    
    //
    // The next check is to put the special device classes above non-special 
    // device classes.
    //
    ulLength = sizeof(Buffer);
    if ((CM_Get_DevNode_Registry_Property((DEVINST)lParam1,
                                          CM_DRP_CLASSGUID,
                                          NULL,
                                          Buffer,
                                          &ulLength,
                                          0) == CR_SUCCESS) &&
        (ulLength != 0)) {

        pSetupGuidFromString(Buffer, &ClassGuid1);

        if (IsEqualGUID(&ClassGuid1, &GUID_DEVCLASS_DISPLAY) ||
            IsEqualGUID(&ClassGuid1, &GUID_DEVCLASS_MEDIA)) {
            //
            // Device 1 is one of the special classes that go at the top of the list.
            //
            bSpecialClass1 = TRUE;
        }
    } 

    ulLength = sizeof(Buffer);
    if ((CM_Get_DevNode_Registry_Property((DEVINST)lParam2,
                                          CM_DRP_CLASSGUID,
                                          NULL,
                                          Buffer,
                                          &ulLength,
                                          0) == CR_SUCCESS) &&
        (ulLength != 0)) {
    
        pSetupGuidFromString(Buffer, &ClassGuid2);

        if (IsEqualGUID(&ClassGuid2, &GUID_DEVCLASS_DISPLAY) ||
            IsEqualGUID(&ClassGuid2, &GUID_DEVCLASS_MEDIA)) {
            //
            // Device 2 is one of the special classes that go at the top of the list.
            //
            bSpecialClass2 = TRUE;
        }
    }

    if (bSpecialClass1 && !bSpecialClass2) {
        return -1;
    } else if (!bSpecialClass1 && bSpecialClass2) {
        return 1;
    }

    //
    // The final check is to sort the items by classes
    //
    ulLength = sizeof(ClassName1);
    if ((CM_Get_DevNode_Registry_Property((DEVINST)lParam1,
                                          CM_DRP_CLASS,
                                          NULL,
                                          ClassName1,
                                          &ulLength,
                                          0) != CR_SUCCESS) ||
        (ulLength == 0)) {
        //
        // If we could not get a class name then set it to all Z's so it will
        // get put at the bottom of the list.
        //
        lstrcpy(ClassName1, TEXT("ZZZZZZZZZZ"));;
    }

    ulLength = sizeof(ClassName2);
    if ((CM_Get_DevNode_Registry_Property((DEVINST)lParam2,
                                          CM_DRP_CLASS,
                                          NULL,
                                          ClassName2,
                                          &ulLength,
                                          0) != CR_SUCCESS) ||
        (ulLength == 0)) {
        //
        // If we could not get a class name then set it to all Z's so it will
        // get put at the bottom of the list.
        //
        lstrcpy(ClassName2, TEXT("ZZZZZZZZZZ"));;
    }

    return lstrcmpi(ClassName1, ClassName2);
}

void
InsertNoneOfTheseDevices(
                        HWND hwndList
                        )
{
    LV_ITEM lviItem;
    TCHAR String[MAX_PATH];

    LoadString(hHdwWiz, IDS_HDW_NONEDEVICES, String, sizeof(String)/sizeof(TCHAR));

    lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lviItem.iSubItem = 0;
    lviItem.lParam = (LPARAM)0;
    lviItem.iItem = 0;
    lviItem.iImage = g_BlankIconIndex;
    lviItem.pszText = String;

    ListView_InsertItem(hwndList, &lviItem);
}

void
InsertProbListView(
                  PHARDWAREWIZ HardwareWiz,
                  DEVINST DevInst,
                  ULONG Problem
                  )
{
    INT Index;
    LV_ITEM lviItem;
    PTCHAR FriendlyName;
    GUID ClassGuid;
    ULONG ulSize;
    CONFIGRET ConfigRet;
    TCHAR szBuffer[MAX_PATH];


    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iSubItem = 0;
    lviItem.lParam = DevInst;
    lviItem.iItem = ListView_GetItemCount(HardwareWiz->hwndProbList);

    //
    // fetch a name for this device
    //

    FriendlyName = BuildFriendlyName(DevInst, HardwareWiz->hMachine);
    if (FriendlyName) {

        lviItem.pszText = FriendlyName;

    } else {

        lviItem.pszText = szUnknown;
    }

    //
    // Fetch the class icon for this device.
    //

    ulSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                    CM_DRP_CLASSGUID,
                                                    NULL,
                                                    szBuffer,
                                                    &ulSize,
                                                    0,
                                                    HardwareWiz->hMachine
                                                   );


    if (ConfigRet == CR_SUCCESS) {

        pSetupGuidFromString(szBuffer, &ClassGuid);

    } else {

        ClassGuid = GUID_DEVCLASS_UNKNOWN;
    }

    if (SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                  &ClassGuid,
                                  &lviItem.iImage
                                 )) {
        lviItem.mask |= (LVIF_IMAGE | LVIF_STATE);

        if (Problem) {

            lviItem.state = (Problem == CM_PROB_DISABLED) ?
                            INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1) :
                            INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);

        } else {

            lviItem.state = INDEXTOOVERLAYMASK(0);
        }

        lviItem.stateMask = LVIS_OVERLAYMASK;
    }

    Index = ListView_InsertItem(HardwareWiz->hwndProbList, &lviItem);


    if ((Index != -1) && (HardwareWiz->ProblemDevInst == DevInst)) {

        ListView_SetItemState(HardwareWiz->hwndProbList,
                              Index,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED
                             );
    }


    if (FriendlyName) {

        LocalFree(FriendlyName);
    }

    return;
}

BOOL
ProblemDeviceListFilter(
                       PHARDWAREWIZ HardwareWiz,
                       PSP_DEVINFO_DATA DeviceInfoData
                       )
/*++

Routine Description:
    
    This function is a callback for the BuildDeviceListView API.  It will get called
    for every device and can filter which devices end up getting displayed.  If it
    returns FALSE then the given device won't be displayed.  If it returns TRUE then
    the device will be displayed.
    
    Currently we will filter out all system devices from the problem devices list since
    they cluter up the list view and it would be very rare that a user would come to
    Add Hardware to add a system device.
    
--*/
{
    //
    // If this is a system class device then filter it out of the list by
    // returning FALSE.
    //
    if (IsEqualGUID(&DeviceInfoData->ClassGuid, &GUID_DEVCLASS_SYSTEM)) {

        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
HdwProbListDlgProc(
                  HWND   hDlg,
                  UINT   message,
                  WPARAM wParam,
                  LPARAM lParam
                  )
/*++

Routine Description:


Arguments:

   standard stuff.



Return Value:

   INT_PTR

--*/

{
    PHARDWAREWIZ HardwareWiz;

    if (message == WM_INITDIALOG) {

        LV_COLUMN lvcCol;
        INT Index;
        TCHAR Buffer[64];
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ) lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        HardwareWiz->hwndProbList = GetDlgItem(hDlg, IDC_HDWPROBLIST);

        //
        // Insert columns for listview.
        // 0 == device name
        //

        lvcCol.mask = LVCF_WIDTH | LVCF_SUBITEM;

        lvcCol.iSubItem = 0;
        ListView_InsertColumn(HardwareWiz->hwndProbList, 0, &lvcCol);

        SendMessage(HardwareWiz->hwndProbList,
                    LVM_SETEXTENDEDLISTVIEWSTYLE,
                    LVS_EX_FULLROWSELECT,
                    LVS_EX_FULLROWSELECT
                   );

        ListView_SetExtendedListViewStyle(HardwareWiz->hwndProbList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        return TRUE;
    }

    //
    // retrieve private data from window long (stored there during WM_INITDIALOG)
    //
    HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message) {
    
    case WM_DESTROY:
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY: {

            NMHDR FAR *pnmhdr = (NMHDR FAR *)lParam;

            switch (pnmhdr->code) {
            
            case PSN_SETACTIVE: {

                    DWORD DevicesDetected;
                    int  nCmdShow;
                    HWND hwndProbList;
                    HWND hwndParentDlg;
                    LVITEM lvItem;
                    HICON hIcon;

                    hwndParentDlg = GetParent(hDlg);

                    HardwareWiz->PrevPage = IDD_ADDDEVICE_PROBLIST;

                    //
                    // initialize the list view, we do this on each setactive
                    // since a new class may have been installed or the problem
                    // device list may change as we go back and forth between pages.
                    //

                    hwndProbList = HardwareWiz->hwndProbList;

                    SendMessage(hwndProbList, WM_SETREDRAW, FALSE, 0L);
                    ListView_DeleteAllItems(hwndProbList);

                    if (HardwareWiz->ClassImageList.cbSize) {

                        ListView_SetImageList(hwndProbList,
                                              HardwareWiz->ClassImageList.ImageList,
                                              LVSIL_SMALL
                                             );
                    }

                    //
                    // Next put all of the devices into the list
                    //
                    DevicesDetected = 0;
                    BuildDeviceListView(HardwareWiz,
                                        HardwareWiz->hwndProbList,
                                        FALSE,
                                        HardwareWiz->ProblemDevInst,
                                        &DevicesDetected,
                                        ProblemDeviceListFilter
                                       );

                    InsertNoneOfTheseDevices(HardwareWiz->hwndProbList);

                    //
                    // Sort the list
                    //
                    ListView_SortItems(HardwareWiz->hwndProbList,
                                       (PFNLVCOMPARE)DeviceListCompare,
                                       NULL
                                       );

                    lvItem.mask = LVIF_PARAM;
                    lvItem.iSubItem = 0;
                    lvItem.iItem = ListView_GetNextItem(HardwareWiz->hwndProbList, -1, LVNI_SELECTED);

                    //
                    // select the first item in the list if nothing else was selected
                    //
                    if (lvItem.iItem == -1) {

                        ListView_SetItemState(hwndProbList,
                                              0,
                                              LVIS_FOCUSED,
                                              LVIS_FOCUSED
                                             );

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);

                    } else {

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    }

                    ListView_EnsureVisible(hwndProbList, lvItem.iItem, FALSE);
                    ListView_SetColumnWidth(hwndProbList, 0, LVSCW_AUTOSIZE_USEHEADER);

                    SendMessage(hwndProbList, WM_SETREDRAW, TRUE, 0L);

                }
                break;

            case PSN_WIZNEXT: {

                    LVITEM lvItem;

                    lvItem.mask = LVIF_PARAM;
                    lvItem.iSubItem = 0;
                    lvItem.iItem = ListView_GetNextItem(HardwareWiz->hwndProbList, -1, LVNI_SELECTED);

                    if (lvItem.iItem != -1) {

                        ListView_GetItem(HardwareWiz->hwndProbList, &lvItem);

                        HardwareWiz->ProblemDevInst = (DEVNODE)lvItem.lParam;

                    } else {

                        HardwareWiz->ProblemDevInst = 0;
                    }

                    //
                    // If the HardwareWiz->ProblemDevInst is 0 then the user selected none of the items
                    // so we will move on to detection
                    //
                    if (HardwareWiz->ProblemDevInst == 0) {

                        SetDlgMsgResult(hDlg, WM_NOTIFY, IDD_ADDDEVICE_ASKDETECT);

                    } else {

                        SetDlgMsgResult(hDlg, WM_NOTIFY, IDD_ADDDEVICE_PROBLIST_FINISH);
                    }
                }
                break;

            case PSN_WIZFINISH:
                break;


            case PSN_WIZBACK:
                SetDlgMsgResult(hDlg, WM_NOTIFY, IDD_ADDDEVICE_CONNECTED);
                break;

            case NM_DBLCLK:
                PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                break;

            case LVN_ITEMCHANGED:
                if (ListView_GetSelectedCount(HardwareWiz->hwndProbList) == 0) {

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                } else {

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
            }

        }
        break;

    case WM_SYSCOLORCHANGE:
        HdwWizPropagateMessage(hDlg, message, wParam, lParam);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
HdwProbListFinishDlgProc(
                        HWND   hDlg,
                        UINT   wMsg,
                        WPARAM wParam,
                        LPARAM lParam
                        )
/*++

Routine Description:


Arguments:


Return Value:

   INT_PTR

--*/

{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    if (wMsg == WM_INITDIALOG) {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);
        return TRUE;
    }

    switch (wMsg) {
    case WM_DESTROY:
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY: {
            NMHDR FAR *pnmhdr = (NMHDR FAR *)lParam;

            switch (pnmhdr->code) {
            case PSN_SETACTIVE: 
                {
                    PTCHAR FriendlyName;
                    TCHAR szBuffer[MAX_PATH];
                    PTCHAR ProblemText;
                    ULONG Status, Problem;

                    FriendlyName = BuildFriendlyName(HardwareWiz->ProblemDevInst, NULL);
                    if (FriendlyName) {

                        SetDlgItemText(hDlg, IDC_HDW_DESCRIPTION, FriendlyName);
                        LocalFree(FriendlyName);
                    }

                    Status = Problem = 0;
                    CM_Get_DevNode_Status_Ex(&Status,
                                             &Problem,
                                             HardwareWiz->ProblemDevInst,
                                             0,
                                             HardwareWiz->hMachine
                                            );

                    ProblemText = DeviceProblemText(HardwareWiz->hMachine,
                                                    HardwareWiz->ProblemDevInst,
                                                    Status,
                                                    Problem
                                                   );

                    if (ProblemText) {
                        SetDlgItemText(hDlg, IDC_PROBLEM_DESC, ProblemText);
                        LocalFree(ProblemText);
                    }

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                }
                break;

            case PSN_WIZFINISH:
                HardwareWiz->RunTroubleShooter = TRUE;
                break;

            case PSN_WIZBACK:
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_PROBLIST);
                break;

            }

        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\pnpenum.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pnpenum.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"


INT_PTR CALLBACK HdwAskDetectDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)  {
        case WM_INITDIALOG: {
            HWND hwndParentDlg;
            HICON hIcon;
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

            break;
        }

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code) {
                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    HardwareWiz->PrevPage = IDD_ADDDEVICE_ASKDETECT;

                    //
                    // Set the Initial radio button state.
                    // default to do autodetection.
                    //
                    CheckRadioButton(hDlg,
                                     IDC_ADDDEVICE_ASKDETECT_AUTO,
                                     IDC_ADDDEVICE_ASKDETECT_SPECIFIC,
                                     IDC_ADDDEVICE_ASKDETECT_AUTO
                                     );

                    break;


                case PSN_WIZBACK:
                    //
                    // If we are going back then this is effectively a Cancel
                    //
                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_PROBLIST);
                    break;

                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_ASKDETECT_AUTO)) {

                        SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTION);

                    } else {

                        SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTCLASS);
                    }
                    break;

                case PSN_RESET:
                    HardwareWiz->Cancelled = TRUE;
                    break;
                }

            break;

        default:
            return(FALSE);
        }

    return(TRUE);
}

DWORD
PNPEnumerate(
    PHARDWAREWIZ HardwareWiz
    )
{
    CONFIGRET ConfigRet;
    DEVINST RootDevInst, ChildDevInst;
    HDEVINFO hDeviceInfo;

    if (HardwareWiz->ExitDetect) {

        return 0;
    }

    //
    // reenumerate from the root of the devnode tree
    //
    ConfigRet = CM_Locate_DevNode_Ex(&RootDevInst,
                                     NULL,
                                     CM_LOCATE_DEVNODE_NORMAL,
                                     NULL
                                     );


    if (ConfigRet != CR_SUCCESS) {

        return 0;
    }


    //
    // Force install of ALL devices which still need installing.
    // save reboot flags to pass back to main thread.
    //
    ConfigRet = CM_Get_Child_Ex(&ChildDevInst,
                                RootDevInst,
                                0,
                                NULL
                                );

    if (ConfigRet == CR_SUCCESS) {

        InstallSilentChildSiblings(NULL, HardwareWiz, ChildDevInst, TRUE);
    }


    if (HardwareWiz->Reboot) {

        return 0;
    }

    Sleep(100); // give a chance for new devices to be noticed by PNP

    //
    // Ask PNP to look for newly arrived devices.
    //
    CM_Reenumerate_DevNode_Ex(
        RootDevInst,
        CM_REENUMERATE_SYNCHRONOUS | CM_REENUMERATE_RETRY_INSTALLATION,
        NULL
        );

    Sleep(5000); // give a chance for new devices to be noticed by PNP

    do {

        if (HardwareWiz->ExitDetect) {

            return 0;
        }

    } while (CMP_WaitNoPendingInstallEvents(1000) == WAIT_TIMEOUT);


    return 0;
}

int
InsertDeviceNodeListView(
    HWND hwndList,
    PHARDWAREWIZ HardwareWiz,
    HDEVINFO hDeviceInfo,
    PSP_DEVINFO_DATA DeviceInfoData
    )
{
    INT lvIndex;
    LV_ITEM lviItem;
    PTCHAR DeviceName;
    TCHAR Buffer[MAX_PATH];
    ULONG Status = 0, Problem = 0;

    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iItem = -1;
    lviItem.iSubItem = 0;

    if (SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                  &DeviceInfoData->ClassGuid,
                                  &lviItem.iImage
                                  )) {

        lviItem.mask |= LVIF_IMAGE;
    }

    DeviceName = BuildFriendlyName(DeviceInfoData->DevInst, NULL);

    if (DeviceName) {

        lviItem.pszText = DeviceName;

    } else {

        lviItem.pszText = szUnknown;
    }

    lviItem.mask |= LVIF_STATE;

    if (CM_Get_DevNode_Status(&Status, &Problem, DeviceInfoData->DevInst, 0) == CR_SUCCESS) {
        if (Problem) {
            //
            // Add the yellow ! or red X overlay to the devnode if it has a 
            // problem.
            //
            lviItem.state = (Problem == CM_PROB_DISABLED) ?
                            INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1) :
                            INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
    
        } else {
            lviItem.state = INDEXTOOVERLAYMASK(0);
        }

        lviItem.stateMask = LVIS_OVERLAYMASK;
    }


    lviItem.lParam = (LPARAM)DeviceInfoData->DevInst;
    lvIndex = ListView_InsertItem(hwndList, &lviItem);

    if (DeviceName) {

        LocalFree(DeviceName);
    }

    return lvIndex;
}

BOOL
AnyNewPnPDevicesFound(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    HDEVINFO NewDeviceInfo, OldDeviceInfo;
    BOOL NewDevicesFound;
    BOOL NewDevice;
    INT iNew, iOld;
    SP_DEVINFO_DATA NewDeviceInfoData, OldDeviceInfoData;

    OldDeviceInfo = HardwareWiz->PNPEnumDeviceInfo;
    NewDeviceInfo = SetupDiGetClassDevs(NULL,
                                     NULL,
                                     GetParent(hDlg),
                                     DIGCF_ALLCLASSES
                                     );

    if (!OldDeviceInfo || NewDeviceInfo == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    NewDevicesFound = FALSE;
    iNew = 0;
    NewDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    while (SetupDiEnumDeviceInfo(NewDeviceInfo, iNew++, &NewDeviceInfoData)) {

        NewDevice = TRUE;
        iOld = 0;
        OldDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        while (SetupDiEnumDeviceInfo(OldDeviceInfo, iOld++, &OldDeviceInfoData)) {

            if (NewDeviceInfoData.DevInst == OldDeviceInfoData.DevInst) {

                //
                // If this DevInst exists in the Old DeviceInfo list then it is
                // not a new device.
                //
                NewDevice = FALSE;
                break;
            }
        }

        //
        // If we did not find this device in the original list then it is a new
        // PnP device.  Set the NewDevicesFound BOOL and break out of the loop.
        //
        if (NewDevice) {

            NewDevicesFound = TRUE;
            break;
        }
    }

    SetupDiDestroyDeviceInfoList(NewDeviceInfo);

    return NewDevicesFound;
}

INT_PTR CALLBACK
HdwPnpEnumDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);


    if (wMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        return TRUE;
    }


    switch (wMsg)  {

    case WM_COMMAND:
        break;

    case WM_DESTROY:
        if (HardwareWiz->PNPEnumDeviceInfo) {

            SetupDiDestroyDeviceInfoList(HardwareWiz->PNPEnumDeviceInfo);
            HardwareWiz->PNPEnumDeviceInfo = NULL;
        }
        break;


    case WUM_PNPENUMERATE:
        HardwareWiz->InstallPending = FALSE;
        HardwareWiz->CurrCursor = NULL;
        SetCursor(HardwareWiz->IdcArrow);
        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));

        if (HardwareWiz->ExitDetect) {

            break;
        }

        HardwareWiz->FoundPnPDevices = AnyNewPnPDevicesFound(hDlg, HardwareWiz);
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

            case PSN_SETACTIVE: {
                int PrevPage;

                PrevPage = HardwareWiz->PrevPage;
                HardwareWiz->PrevPage = IDD_ADDDEVICE_PNPENUM;
                HardwareWiz->ExitDetect = FALSE;


                //
                // If moving forwards, kick off enumeration.
                //
                if (PrevPage != IDD_ADDDEVICE_ASKDETECT) {
                    EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
                    SetDlgText(hDlg, IDC_HDW_TEXT, IDS_ADDDEVICE_PNPENUMERATE, IDS_ADDDEVICE_PNPENUMERATE);

                    Animate_Open(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), MAKEINTRESOURCE(IDA_SEARCHING));
                    Animate_Play(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), 0, -1, -1);

                    //
                    // Create a list of all of the installed devices, which
                    // will be used after enumeration to build the list of
                    // newly installed.
                    //
                    HardwareWiz->PNPEnumDeviceInfo = SetupDiGetClassDevs(
                                                        NULL,
                                                        NULL,
                                                        GetParent(hDlg),
                                                        DIGCF_ALLCLASSES
                                                        );

                    if (HardwareWiz->PNPEnumDeviceInfo == INVALID_HANDLE_VALUE) {

                        HardwareWiz->PNPEnumDeviceInfo = NULL;
                    }


                    HardwareWiz->InstallPending = TRUE;

                    HardwareWiz->CurrCursor = HardwareWiz->IdcAppStarting;
                    SetCursor(HardwareWiz->CurrCursor);

                    if (!SearchThreadRequest(HardwareWiz->SearchThread,
                                        hDlg,
                                        SEARCH_PNPENUM,
                                        0
                                        )) {

                        EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK| PSWIZB_NEXT);
                        SetDlgText(hDlg, IDC_HDW_TEXT, IDS_ADDDEVICE_PNPENUMERROR, IDS_ADDDEVICE_PNPENUMERROR);
                        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
                    }
                }
            }
            break;

            case PSN_QUERYCANCEL:
                if (HardwareWiz->InstallPending) {

                    if (HardwareWiz->ExitDetect) {

                        SetDlgMsgResult(hDlg, wMsg, TRUE);
                        break;
                    }

                    HardwareWiz->ExitDetect = TRUE;
                    HardwareWiz->CurrCursor = HardwareWiz->IdcWait;
                    SetCursor(HardwareWiz->CurrCursor);
                    CancelSearchRequest(HardwareWiz);
                    HardwareWiz->CurrCursor = NULL;
                }

                SetDlgMsgResult(hDlg, wMsg, FALSE);
                break;

            case PSN_RESET:
               HardwareWiz->Cancelled = TRUE;
               Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
               break;

            case PSN_WIZBACK:
               SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_WELCOME);
               break;

            case PSN_WIZNEXT:
                if (HardwareWiz->FoundPnPDevices) {

                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_PNPFINISH);

                } else {

                    EnableWindow(GetDlgItem(GetParent(hDlg),  IDCANCEL), TRUE);
                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_CONNECTED);
                }
                break;

        }
        break;

    case WM_SETCURSOR:

        if (HardwareWiz->CurrCursor) {

            SetCursor(HardwareWiz->CurrCursor);
            break;
        }

        // fall thru to return(FALSE);



    default:
        return(FALSE);
    }

    return(TRUE);
}

BOOL
FillInstalledDevicesList(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    HDEVINFO NewDeviceInfo, OldDeviceInfo;
    BOOL Installed;
    BOOL NewDevice;
    INT iNew, iOld;
    SP_DEVINFO_DATA NewDeviceInfoData, OldDeviceInfoData;
    HWND hwndList;

    hwndList = GetDlgItem(hDlg, IDC_FOUNDPNP_LIST);
    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
    ListView_DeleteAllItems(hwndList);

    OldDeviceInfo = HardwareWiz->PNPEnumDeviceInfo;
    NewDeviceInfo = SetupDiGetClassDevs(NULL,
                                     NULL,
                                     GetParent(hDlg),
                                     DIGCF_ALLCLASSES
                                     );

    if (!OldDeviceInfo || NewDeviceInfo == INVALID_HANDLE_VALUE) {

        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
        return FALSE;
    }

    //
    // For each element in the new list check to see if its in the old list.
    // If its not then it is a newly installed devnode so add it to the list box.
    //

    Installed = FALSE;
    iNew = 0;
    NewDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    while (SetupDiEnumDeviceInfo(NewDeviceInfo, iNew++, &NewDeviceInfoData)) {

        NewDevice = TRUE;
        iOld = 0;
        OldDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        while (SetupDiEnumDeviceInfo(OldDeviceInfo, iOld++, &OldDeviceInfoData)) {

            if (NewDeviceInfoData.DevInst == OldDeviceInfoData.DevInst) {

                //
                // If this DevInst exists in the Old DeviceInfo list then it is
                // not a new device.
                //
                NewDevice = FALSE;
                break;
            }
        }

        //
        // If this is a new device then add it to the list view and set
        // the Installed boolean to TRUE.
        //
        if (NewDevice) {

            InsertDeviceNodeListView(hwndList, HardwareWiz, NewDeviceInfo, &NewDeviceInfoData);
            Installed = TRUE;
        }
    }

    SetupDiDestroyDeviceInfoList(NewDeviceInfo);

    if (!Installed) {

        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
        SetupDiDestroyDeviceInfoList(HardwareWiz->PNPEnumDeviceInfo);
        HardwareWiz->PNPEnumDeviceInfo = NULL;
        return FALSE;
    }


    ListView_SetItemState(hwndList,
                          0,
                          LVIS_SELECTED|LVIS_FOCUSED,
                          LVIS_SELECTED|LVIS_FOCUSED
                          );

    //
    // scroll the selected item into view.
    //

    ListView_EnsureVisible(hwndList, 0, FALSE);
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);

    return Installed;
}

BOOL
InitPnpFinishDlgProc(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    HFONT hfont;
    HICON hIcon;
    int FontSize, PtsPixels;
    HWND hwndParentDlg;
    HWND hwndList;
    LV_COLUMN lvcCol;
    LOGFONT LogFont;
    TCHAR Buffer[64];

    //
    // Insert columns for listview.
    // 0 == device name
    //
    hwndList = GetDlgItem(hDlg, IDC_FOUNDPNP_LIST);

    lvcCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvcCol.fmt = LVCFMT_LEFT;
    lvcCol.pszText = Buffer;

    lvcCol.iSubItem = 0;
    LoadString(hHdwWiz, IDS_DEVINSTALLED, Buffer, SIZECHARS(Buffer));
    ListView_InsertColumn(hwndList, 0, &lvcCol);

    SendMessage(hwndList,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                LVS_EX_FULLROWSELECT,
                LVS_EX_FULLROWSELECT
                );

    if (HardwareWiz->ClassImageList.cbSize) {

        ListView_SetImageList(hwndList,
                              HardwareWiz->ClassImageList.ImageList,
                              LVSIL_SMALL
                              );
    }

    return TRUE;
}

INT_PTR CALLBACK
HdwPnpFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndParentDlg=GetParent(hDlg);


    switch (wMsg)  {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);

        if (!InitPnpFinishDlgProc(hDlg, HardwareWiz)) {
            return FALSE;
        }

        break;
        }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_FINISH);
            EnableWindow(GetDlgItem(hwndParentDlg, IDCANCEL), FALSE);
            FillInstalledDevicesList(hDlg, HardwareWiz);
            break;

        case PSN_WIZFINISH:
            break;

        case NM_DBLCLK:
            if ((((LPNMHDR)lParam)->idFrom) == IDC_FOUNDPNP_LIST) {
                LVITEM lvItem;

                lvItem.mask = LVIF_PARAM;
                lvItem.iSubItem = 0;
                lvItem.iItem = ListView_GetNextItem(GetDlgItem(hDlg, IDC_FOUNDPNP_LIST),
                                                    -1, 
                                                    LVNI_SELECTED);

                if ((lvItem.iItem != -1) &&
                    ListView_GetItem(GetDlgItem(hDlg, IDC_FOUNDPNP_LIST), &lvItem) &&
                    (lvItem.lParam)) {
                    //
                    // Launch the properties for this device.
                    //
                    DeviceProperties(hDlg,
                                     HardwareWiz->hMachine,
                                     (LPCSTR)(HardwareWiz->hMachine ? HardwareWiz->MachineName : NULL),
                                     (DEVNODE)lvItem.lParam,
                                     0
                                     );
                }
            }
        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
HdwConnectedDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);


    if (wMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        return TRUE;
    }


    switch (wMsg)  {

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_ADDDEVICE_CONNECTED_YES:
        case IDC_ADDDEVICE_CONNECTED_NO:
            //
            // Only show the next button if one of the radio buttons are
            // selected.
            //
            if (IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_YES) ||
                IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_NO)) {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            } else {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            }
            break;
        }
        break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

            case PSN_SETACTIVE:
                HardwareWiz->PrevPage = IDD_ADDDEVICE_CONNECTED;
                
                //
                // Only show the next button if one of the radio buttons are
                // selected.
                //
                if (IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_YES) ||
                    IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_NO)) {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                } else {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                }
                break;

            case PSN_WIZBACK:
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_WELCOME);
                break;

            case PSN_WIZNEXT:
                if (IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_YES)) {

                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_PROBLIST);

                } else {

                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_CONNECTED_FINISH);
                }
                break;

        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
HdwConnectedFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);


    if (wMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);
        return TRUE;
    }


    switch (wMsg)  {

    case WM_COMMAND:
        break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            break;

        case PSN_WIZBACK:
            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_CONNECTED);
            break;

        case PSN_WIZFINISH:
            if (IsDlgButtonChecked(hDlg, IDC_NEED_SHUTDOWN)) {
                //
                // Rember that we need to shutdown.
                //
                HardwareWiz->Shutdown = TRUE;    
            }
            break;

        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\init.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       init.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"

HMODULE hHdwWiz;
int g_BlankIconIndex;

INT CALLBACK
iHdwWizardDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{

    switch( uMsg ) {

    case PSCB_INITIALIZED:
        break;

    case PSCB_PRECREATE:
        if( lParam ){
        
            DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
            pDlgTemplate->style &= ~(DS_CONTEXTHELP | WS_SYSMENU);
        }
        break;
    }

    return FALSE;
}

PHDWPROPERTYSHEET
HdwWizard(
    HWND hwndParent,
    PHARDWAREWIZ HardwareWiz,
    int StartPageId
    )
{
    PHDWPROPERTYSHEET HdwPropertySheet;
    LPPROPSHEETHEADER PropSheetHeader;
    PROPSHEETPAGE psp;
    LPTSTR Title;
    LONG Error;
    LONG DialogBaseUnits;
    int Index;


    //
    // Allocate memory for the header and the page array.
    //

    HdwPropertySheet = LocalAlloc(LPTR, sizeof(HDWPROPERTYSHEET));
    if (!HdwPropertySheet) {
    
        return NULL;
    }

    memset(HdwPropertySheet, 0, sizeof(*HdwPropertySheet));

    if (ERROR_SUCCESS != HdwBuildClassInfoList(HardwareWiz, 
                                               DIBCI_NOINSTALLCLASS,
                                               HardwareWiz->hMachine ? HardwareWiz->MachineName : NULL)) {

        return NULL;
    }

    //
    // Initialize the PropertySheet Header
    //
    PropSheetHeader = &HdwPropertySheet->PropSheetHeader;
    PropSheetHeader->dwSize = sizeof(HdwPropertySheet->PropSheetHeader);
    PropSheetHeader->dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;

    PropSheetHeader->hwndParent = hwndParent;
    PropSheetHeader->hInstance = hHdwWiz;
    PropSheetHeader->pszCaption = MAKEINTRESOURCE(IDS_HDWWIZNAME);
    PropSheetHeader->phpage = HdwPropertySheet->PropSheetPages;
    PropSheetHeader->pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
    PropSheetHeader->pszbmHeader = MAKEINTRESOURCE(IDB_BANNER);
    PropSheetHeader->pfnCallback = iHdwWizardDlgCallback;

    PropSheetHeader->nStartPage = 0;
    PropSheetHeader->nPages = 0;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.hInstance = hHdwWiz;
    psp.lParam = (LPARAM)HardwareWiz;
    psp.pszTitle = MAKEINTRESOURCE(IDS_HDWWIZNAME);


    //
    // If the StartPageId is IDD_INSTALLNEWDEVICE then we don't need to create the detection
    // and removal pages.
    //
    if (IDD_INSTALLNEWDEVICE == StartPageId) {
        
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_INSTALLNEWDEVICE);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_INSTALLNEWDEVICE);
        psp.pfnDlgProc = InstallNewDeviceDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    }

    else {
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_WELCOME);
        psp.pfnDlgProc = HdwIntroDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

        //
        // Add Hardware wizard pages
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_PNPENUM);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_PNPENUM);
        psp.pfnDlgProc = HdwPnpEnumDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        //
        // Finish page
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_PNPFINISH);
        psp.pfnDlgProc = HdwPnpFinishDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_CONNECTED);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_CONNECTED);
        psp.pfnDlgProc = HdwConnectedDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        //
        // Finish page
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_CONNECTED_FINISH);
        psp.pfnDlgProc = HdwConnectedFinishDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_PROBLIST);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_PROBLIST);
        psp.pfnDlgProc = HdwProbListDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_PROBLIST_FINISH);
        psp.pfnDlgProc = HdwProbListFinishDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_ASKDETECT);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_ASKDETECT);
        psp.pfnDlgProc = HdwAskDetectDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_DETECTION);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_DETECTION);
        psp.pfnDlgProc = HdwDetectionDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_DETECTINSTALL);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_DETECTINSTALL);
        psp.pfnDlgProc = HdwDetectInstallDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
        //
        // Finish page
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_DETECTREBOOT);
        psp.pfnDlgProc = HdwDetectRebootDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    }

    //
    // These pages are always shown
    //
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_SELECTCLASS);
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_SELECTCLASS);
    psp.pfnDlgProc = HdwPickClassDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = NULL;
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_SELECTDEVICE);
    psp.pfnDlgProc = HdwSelectDeviceDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_ANALYZEDEV);
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_ANALYZEDEV);
    psp.pfnDlgProc = HdwAnalyzeDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_INSTALLDEV);
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_INSTALLDEV);
    psp.pfnDlgProc = HdwInstallDevDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    //
    // Finish page
    //
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_FINISH);
    psp.pfnDlgProc = HdwAddDeviceFinishDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    //
    // check for failure on CreatePropertySheetPage.
    //
    Index = PropSheetHeader->nPages;
    while (Index--) {
    
       if (!PropSheetHeader->phpage[Index]) {
       
           break;
       }
   }

    if (Index >= 0) {
    
        Index = PropSheetHeader->nPages;
        while (Index--) {
        
            if (PropSheetHeader->phpage[Index]) {
           
                DestroyPropertySheetPage(PropSheetHeader->phpage[Index]);
            }
        }

        LocalFree(HdwPropertySheet);
        return NULL;
    }

    HardwareWiz->PrevPage = 0;

    LoadString(hHdwWiz,
               IDS_UNKNOWN,
               (PTCHAR)szUnknown,
               SIZECHARS(szUnknown)
               );

    LenUnknown = lstrlen(szUnknown) * sizeof(TCHAR) + sizeof(TCHAR);


    LoadString(hHdwWiz,
               IDS_UNKNOWNDEVICE,
               (PTCHAR)szUnknownDevice,
               SIZECHARS(szUnknownDevice)
               );

    LenUnknownDevice = lstrlen(szUnknownDevice) * sizeof(TCHAR) + sizeof(TCHAR);

    //
    // Get the Class Icon Image Lists.
    //
    HardwareWiz->ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
    if (SetupDiGetClassImageList(&HardwareWiz->ClassImageList)) {

        HICON hIcon;

        //
        // Add the blank icon for "None of the following devices"
        //
        if ((hIcon = LoadIcon(hHdwWiz, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {

            g_BlankIconIndex = ImageList_AddIcon(HardwareWiz->ClassImageList.ImageList, hIcon);
        }
    
    } else {
    
        HardwareWiz->ClassImageList.cbSize = 0;
    }

    //
    // Load the cursors that the wizard will need
    //
    HardwareWiz->CurrCursor     = NULL;
    HardwareWiz->IdcWait        = LoadCursor(NULL, IDC_WAIT);
    HardwareWiz->IdcAppStarting = LoadCursor(NULL, IDC_APPSTARTING);
    HardwareWiz->IdcArrow       = LoadCursor(NULL, IDC_ARROW);

    return HdwPropertySheet;
}

BOOL
WINAPI
InstallNewDevice(
   HWND hwndParent,
   LPGUID ClassGuid,
   PDWORD pReboot
   )
/*++

Routine Description:

   Exported Entry point from hdwwiz.cpl. Installs a new device. A new Devnode is
   created and the user is prompted to select the device. If the class guid
   is not specified then then the user begins at class selection.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   LPGUID ClassGuid - Optional class of the new device to install.
                      If ClassGuid is NULL we start at detection choice page.
                      If ClassGuid == GUID_NULL or GUID_DEVCLASS_UNKNOWN
                         we start at class selection page.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    HARDWAREWIZ HardwareWiz;
    PHDWPROPERTYSHEET HdwPropertySheet;
    int PropSheetResult;
    SEARCHTHREAD SearchThread;
    BOOL StartDetect;

    if (NoPrivilegeWarning(hwndParent)) {

        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Check to make sure another Device install is underway.
    // This entry point is primarily for manual legacy installs.
    // While Base PNP has queued found new hdw installs, we don't
    // allow the user to install anything manually, since we may get
    // duplicate entries.
    //
    //
    if (CMP_WaitNoPendingInstallEvents(5000) == WAIT_TIMEOUT) {

        HdwMessageBox(hwndParent, 
                      MAKEINTRESOURCE(IDS_HDW_RUNNING_MSG), 
                      MAKEINTRESOURCE(IDS_HDW_RUNNING_TITLE), 
                      MB_OK | MB_ICONINFORMATION
                      );
        return FALSE;
    }

    memset(&HardwareWiz, 0, sizeof(HardwareWiz));

    HardwareWiz.PromptForReboot = pReboot == NULL;

    StartDetect = (ClassGuid == NULL);

    //
    // Create a DeviceInfoList, using the classers Class guid if any.
    //
    if (ClassGuid &&
        (IsEqualGUID(ClassGuid, &GUID_NULL) ||
        IsEqualGUID(ClassGuid, &GUID_DEVCLASS_UNKNOWN))) {

        ClassGuid = NULL;
    }

    HardwareWiz.hDeviceInfo = SetupDiCreateDeviceInfoList(ClassGuid, hwndParent);
    if (HardwareWiz.hDeviceInfo == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    try {

        //
        // If the caller specified a ClassGuid, retrieve the class information
        // and create a DeviceInfo for it.
        //
        if (ClassGuid) {

            HardwareWiz.ClassGuidSelected = ClassGuid;

            //
            // Add a new element to the DeviceInfo from the GUID and class name
            //
            HardwareWiz.DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            if (!SetupDiGetClassDescription(HardwareWiz.ClassGuidSelected,
                                            HardwareWiz.ClassDescription,
                                            sizeof(HardwareWiz.ClassDescription)/sizeof(TCHAR),
                                            NULL
                                            ) 
                ||
                !SetupDiClassNameFromGuid(HardwareWiz.ClassGuidSelected,
                                          HardwareWiz.ClassName,
                                          sizeof(HardwareWiz.ClassName)/sizeof(TCHAR),
                                          NULL
                                          ))
            {
                HardwareWiz.LastError = GetLastError();
                goto INDLeaveExcept;
            }
        
            if (!SetupDiCreateDeviceInfo(HardwareWiz.hDeviceInfo,
                                         HardwareWiz.ClassName,
                                         ClassGuid,
                                         NULL,
                                         hwndParent,
                                         DICD_GENERATE_ID,
                                         &HardwareWiz.DeviceInfoData
                                         )
                ||
                !SetupDiSetSelectedDevice(HardwareWiz.hDeviceInfo,
                                          &HardwareWiz.DeviceInfoData
                                          ))
            {
                HardwareWiz.LastError = GetLastError();
                goto INDLeaveExcept;
            }
        }

        memset(&SearchThread, 0, sizeof(SEARCHTHREAD));
        HardwareWiz.SearchThread = &SearchThread;
        
        HardwareWiz.LastError = CreateSearchThread(&HardwareWiz);

        if (HardwareWiz.LastError != ERROR_SUCCESS) {

            goto INDLeaveExcept;
        }

        //
        // Load the libraries that we will need
        //
        hDevMgr = LoadLibrary(TEXT("devmgr.dll"));
        hNewDev = LoadLibrary(TEXT("newdev.dll"));

        //
        // Create the property sheet
        //
        HdwPropertySheet = HdwWizard(hwndParent,
                                    &HardwareWiz,
                                    StartDetect ? IDD_ADDDEVICE_PNPENUM : IDD_INSTALLNEWDEVICE
                                    );

        if (HdwPropertySheet) {

            PropSheetResult = (int)PropertySheet(&HdwPropertySheet->PropSheetHeader);
            LocalFree(HdwPropertySheet);
        }
        
        //
        // See if we need to run a troubleshooter
        //
        if (HardwareWiz.RunTroubleShooter) {

           TCHAR DeviceID[MAX_DEVICE_ID_LEN];

           if (CM_Get_Device_ID_Ex(HardwareWiz.ProblemDevInst,
                                   DeviceID,
                                   SIZECHARS(DeviceID),
                                   0,
                                   HardwareWiz.hMachine
                                   ) == CR_SUCCESS)
           {
                PDEVICEPROBLEMWIZARD pDeviceProblemWizard = NULL;

                pDeviceProblemWizard = (PVOID) GetProcAddress(hDevMgr, "DeviceProblemWizardW");

                if (pDeviceProblemWizard) {
                    (pDeviceProblemWizard)(hwndParent,
                                           HardwareWiz.MachineName,
                                           DeviceID
                                           );
                }
            }
        }

        //
        // Final cleanup of DeviceInfoData and DeviceInfoList.
        //
        if (HardwareWiz.ClassGuidList) {

            LocalFree(HardwareWiz.ClassGuidList);
            HardwareWiz.ClassGuidList = NULL;
            HardwareWiz.ClassGuidSize = HardwareWiz.ClassGuidNum = 0;
        }

        if (HardwareWiz.ClassImageList.cbSize) {

            SetupDiDestroyClassImageList(&HardwareWiz.ClassImageList);
            HardwareWiz.ClassImageList.cbSize = 0;
        }

        if (HardwareWiz.Cancelled ||
            (HardwareWiz.Registered && !HardwareWiz.Installed)) {

            HdwRemoveDevice(&HardwareWiz);
            HardwareWiz.Reboot = 0;
        }

        SetupDiDestroyDeviceInfoList(HardwareWiz.hDeviceInfo);
        HardwareWiz.hDeviceInfo = NULL;

INDLeaveExcept:;

    } except(HdwUnhandledExceptionFilter(GetExceptionInformation())) {

        HardwareWiz.LastError = RtlNtStatusToDosError(GetExceptionCode());
    }

    
    if (HardwareWiz.hDeviceInfo && HardwareWiz.hDeviceInfo != INVALID_HANDLE_VALUE) {

        SetupDiDestroyDeviceInfoList(HardwareWiz.hDeviceInfo);
        HardwareWiz.hDeviceInfo = NULL;
    }

    if (HardwareWiz.SearchThread) {

        DestroySearchThread(&SearchThread);
    }

    if (hDevMgr) {

        FreeLibrary(hDevMgr);
    }

    if (hNewDev) {

        FreeLibrary(hNewDev);
    }

    //
    // Copy out the reboot flags for the caller
    // or put up the restart dialog if caller didn't ask for the reboot flag
    //
    if (pReboot) {

        *pReboot = HardwareWiz.Reboot;

    } else if (HardwareWiz.Reboot) {

         RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
    }

    //
    // See if we need to shutdown the machine.
    //
    if (HardwareWiz.Shutdown) {
        ShutdownMachine(hwndParent);
    }

    SetLastError(HardwareWiz.LastError);
    return HardwareWiz.LastError == ERROR_SUCCESS;
}

void
AddHardwareWizard(
   HWND hwnd,
   PTCHAR MachineName
   )
/*++

Routine Description:


Arguments:

   hwnd - Window handle of the top-level window to use for any UI related
          to installing the device.


Return Value:

--*/
{

    HARDWAREWIZ HardwareWiz;
    PHDWPROPERTYSHEET HdwPropertySheet;
    int PropSheetResult;
    SEARCHTHREAD SearchThread;
    CONFIGRET ConfigRet;

    //
    // If the user does not have SE_LOAD_DRIVER_NAME privileges then just display a warning
    // message and exit.
    //
    if (NoPrivilegeWarning(hwnd)) {

        SetLastError(ERROR_ACCESS_DENIED);
        return;
    }

    if (MachineName) {

        lstrcpy(HardwareWiz.MachineName, MachineName);
        ConfigRet = CM_Connect_Machine(MachineName, &HardwareWiz.hMachine);
        if (ConfigRet != CR_SUCCESS) {

            return;
        }
    }

    //
    // Check to make sure another Device install is underway.
    // This entry point is primarily for manual legacy installs.
    // While Base PNP has queued found new hdw installs, we don't
    // allow the user to install anything manually, since we may get
    // duplicate entries.
    //
    //
    if (CMP_WaitNoPendingInstallEvents(5000) == WAIT_TIMEOUT) {

        HdwMessageBox(hwnd, 
                      MAKEINTRESOURCE(IDS_HDW_RUNNING_MSG), 
                      MAKEINTRESOURCE(IDS_HDW_RUNNING_TITLE), 
                      MB_OK | MB_ICONINFORMATION
                      );
        return;
    }

    memset(&HardwareWiz, 0, sizeof(HardwareWiz));

    //
    // Create a DeviceInfoList
    HardwareWiz.hDeviceInfo = SetupDiCreateDeviceInfoList(NULL, hwnd);
    if (HardwareWiz.hDeviceInfo == INVALID_HANDLE_VALUE) {

        return;
    }


    //
    // Create the Search thread to look for compatible drivers.
    // This thread will sit around waiting for requests until
    // told to go away.
    //
    memset(&SearchThread, 0, sizeof(SEARCHTHREAD));
    HardwareWiz.SearchThread = &SearchThread;

    if (CreateSearchThread(&HardwareWiz) != ERROR_SUCCESS) {

        SetupDiDestroyDeviceInfoList(HardwareWiz.hDeviceInfo);
        return;
    }

    //
    // Load the libraries that we will need
    //
    hDevMgr = LoadLibrary(TEXT("devmgr.dll"));
    hNewDev = LoadLibrary(TEXT("newdev.dll"));

    HdwPropertySheet = HdwWizard(hwnd, &HardwareWiz, 0);
    if (HdwPropertySheet) {
    
        PropSheetResult = (int)PropertySheet(&HdwPropertySheet->PropSheetHeader);
        LocalFree(HdwPropertySheet);
    }

    //
    // See if we need to run a troubleshooter
    //
    if (HardwareWiz.RunTroubleShooter) {

        TCHAR DeviceID[MAX_DEVICE_ID_LEN];

        if (CM_Get_Device_ID_Ex(HardwareWiz.ProblemDevInst,
                                DeviceID,
                                SIZECHARS(DeviceID),
                                0,
                                HardwareWiz.hMachine
                                ) == CR_SUCCESS)
        {
            PDEVICEPROBLEMWIZARD pDeviceProblemWizard = NULL;

            pDeviceProblemWizard = (PVOID) GetProcAddress(hDevMgr, "DeviceProblemWizardW");
    
            if (pDeviceProblemWizard) {
                (pDeviceProblemWizard)(hwnd,
                                      HardwareWiz.MachineName,
                                      DeviceID
                                      );
            }
        }
    }

    //
    // Final cleanup of DeviceInfoData and DeviceInfoList
    //
    if (HardwareWiz.ClassGuidList) {

        LocalFree(HardwareWiz.ClassGuidList);
        HardwareWiz.ClassGuidList = NULL;
        HardwareWiz.ClassGuidSize = HardwareWiz.ClassGuidNum = 0;
    }

    if (HardwareWiz.ClassImageList.cbSize) {

        SetupDiDestroyClassImageList(&HardwareWiz.ClassImageList);
        HardwareWiz.ClassImageList.cbSize = 0;
    }

    if (HardwareWiz.Cancelled || 
        (HardwareWiz.Registered && !HardwareWiz.Installed)) {

        HdwRemoveDevice(&HardwareWiz);
        HardwareWiz.Reboot = 0;
    }

    SetupDiDestroyDeviceInfoList(HardwareWiz.hDeviceInfo);
    HardwareWiz.hDeviceInfo = NULL;

    if (HardwareWiz.SearchThread) {

        DestroySearchThread(HardwareWiz.SearchThread);
    }

    if (hDevMgr) {

        FreeLibrary(hDevMgr);
    }

    if (hNewDev) {

        FreeLibrary(hNewDev);
    }

    //
    // Do we need to reboot?
    //
    if (HardwareWiz.Reboot) {

        RestartDialogEx(hwnd, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
    }

    //
    // Do we need to shutdown?
    //
    if (HardwareWiz.Shutdown) {
        
        ShutdownMachine(hwnd);
    }

    return;
}

LONG
CPlApplet(
    HWND  hWnd,
    WORD  uMsg,
    DWORD_PTR lParam1,
    LPARAM lParam2
    )
{
    LPNEWCPLINFO lpCPlInfo;
    LPCPLINFO lpOldCPlInfo;


    switch (uMsg) {
       case CPL_INIT:
           return TRUE;

       case CPL_GETCOUNT:
           return 1;

       case CPL_INQUIRE:
           lpOldCPlInfo = (LPCPLINFO)(LPARAM)lParam2;
           lpOldCPlInfo->lData = 0L;
           lpOldCPlInfo->idIcon = IDI_HDWWIZICON;
           lpOldCPlInfo->idName = IDS_HDWWIZ;
           lpOldCPlInfo->idInfo = IDS_HDWWIZINFO;
           return TRUE;

       case CPL_NEWINQUIRE:
           lpCPlInfo = (LPNEWCPLINFO)(LPARAM)lParam2;
           lpCPlInfo->hIcon = LoadIcon(hHdwWiz, MAKEINTRESOURCE(IDI_HDWWIZICON));
           LoadString(hHdwWiz, IDS_HDWWIZ, lpCPlInfo->szName, sizeof(lpCPlInfo->szName));
           LoadString(hHdwWiz, IDS_HDWWIZINFO, lpCPlInfo->szInfo, sizeof(lpCPlInfo->szInfo));
           lpCPlInfo->dwHelpContext = IDH_HDWWIZAPPLET;
           lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
           lpCPlInfo->lData = 0;
           lpCPlInfo->szHelpFile[0] = '\0';
           return TRUE;

       case CPL_DBLCLK:
           AddHardwareWizard(hWnd, NULL);
           break;

       case CPL_STARTWPARMS:
           //
           // what does this mean ?
           //

           break;

       case CPL_EXIT:


           // Free up any allocations of resources made.

           break;

       default:
           break;
       }

    return 0L;
}

BOOL DllInitialize(
    IN PVOID hmod,
    IN ULONG ulReason,
    IN PCONTEXT pctx OPTIONAL
    )
{
    hHdwWiz = hmod;

    if (ulReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hmod);

        SHFusionInitializeFromModule(hmod);
    
    } else if (ulReason == DLL_PROCESS_DETACH) {
        SHFusionUninitialize();
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDI_HDWWIZICON                  100
#define IDI_BLANK                       101
#define IDI_WARN                        102
#define IDH_HDWWIZAPPLET                104
#define IDA_SEARCHING                   105
#define IDB_WATERMARK                   106
#define IDB_BANNER                      107

#define IDD_ADDDEVICE_WELCOME           200
#define IDD_ADDDEVICE_PNPENUM           204
#define IDD_ADDDEVICE_PNPFINISH         205
#define IDD_ADDDEVICE_CONNECTED         206
#define IDD_ADDDEVICE_CONNECTED_FINISH  207
#define IDD_ADDDEVICE_PROBLIST          208
#define IDD_ADDDEVICE_PROBLIST_FINISH   209
#define IDD_ADDDEVICE_ASKDETECT         210
#define IDD_ADDDEVICE_DETECTION         211
#define IDD_ADDDEVICE_DETECTINSTALL     212
#define IDD_ADDDEVICE_DETECTREBOOT      213
#define IDD_ADDDEVICE_SELECTCLASS       214
#define IDD_ADDDEVICE_SELECTDEVICE      215
#define IDD_ADDDEVICE_ANALYZEDEV        216
#define IDD_ADDDEVICE_INSTALLDEV        217
#define IDD_ADDDEVICE_FINISH            218

#define IDD_WIZARDEXT_PRESELECT         250
#define IDD_WIZARDEXT_SELECT            IDD_DYNAWIZ_SELECTCLASS_PAGE
                   // setupapi contains IDD_DYNAWIZ_SELECTDEV_PAGE
#define IDD_WIZARDEXT_PREANALYZE        IDD_DYNAWIZ_ANALYZEDEV_PAGE
#define IDD_WIZARDEXT_PREANALYZE_END    251
#define IDD_WIZARDEXT_POSTANALYZE       252
#define IDD_WIZARDEXT_POSTANALYZE_END   253
#define IDD_WIZARDEXT_FINISHINSTALL     254
#define IDD_WIZARDEXT_FINISHINSTALL_END 255

#define IDD_INSTALLNEWDEVICE            258


#define IDC_HDWNAME                     300
#define IDC_HDWDESC                     301
#define IDC_HDWPROBLIST                 302
#define IDC_HDWPROBTEXT                 303
#define IDC_ERRORTEXT                   304
#define IDC_HDWUNINSTALL                305

#define IDC_HDW_TEXT                    312
#define IDC_FOUNDPNP_TEXT               313
#define IDC_FOUNDPNP_LIST               314
#define IDC_RESTART                     315

#define IDC_ADDDEVICE_ASKDETECT_AUTO        316
#define IDC_ADDDEVICE_ASKDETECT_SPECIFIC    317

#define IDC_HDW_DETWARN_PROGRESSTEXT        318
#define IDC_HDW_DETWARN_PROGRESSBAR         319
#define IDC_HDW_DETWARN_TOTALPROGRESSTEXT   320
#define IDC_HDW_DETWARN_TOTALPROGRESSBAR    321
#define IDC_HDW_INSTALLDET_LISTTITLE        322
#define IDC_HDW_INSTALLDET_LIST             323
#define IDC_HDW_PICKCLASS_HWTYPES           324
#define IDC_HDW_PICKCLASS_CLASSLIST         325
#define IDC_HDW_DESCRIPTION                 326
#define IDC_CLASSICON                       327
#define IDC_HDW_DISPLAYRESOURCE             328
#define IDC_HDW_DISABLEDEVICE               329
#define IDC_CHOICE_UNINSTALL                430
#define IDC_CHOICE_UNPLUG                   431
#define IDC_HDWUNINSTALLLIST                432
#define IDC_SHOW_HIDDEN                     433
#define IDC_UNINSTALL_CONFIRM_YES           434
#define IDC_UNINSTALL_CONFIRM_NO            435
#define IDC_PROBLEM_DESC                    436
#define IDC_ANIMATE_SEARCH                  438
#define IDC_BULLET_1                        500
#define IDC_BULLET_2                        501
#define IDC_WARNING_ICON                    502
#define IDC_CD_TEXT                         503
#define IDC_ADDDEVICE_CONNECTED_YES         504
#define IDC_ADDDEVICE_CONNECTED_NO          505
#define IDC_NEED_SHUTDOWN                   506

#define IDS_HDWWIZ                          1000
#define IDS_HDWWIZNAME                      1001
#define IDS_HDWWIZINFO                      1002
#define IDS_ADDDEVICE_PROBLIST              1005
#define IDS_UNKNOWN                         1012
#define IDS_UNKNOWNDEVICE                   1016
#define IDS_HDWUNINSTALL_NOPRIVILEGE        1017
#define IDS_DEVINSTALLED                    1019
#define IDS_ADDDEVICE_PNPENUMERATE          1020
#define IDS_ADDDEVICE_PNPENUM               1025
#define IDS_ADDDEVICE_ASKDETECT             1027
#define IDS_ADDDEVICE_DETECTION             1029
#define IDS_ADDDEVICE_DETECTINSTALL         1031
#define IDS_ADDDEVICE_DETECTINSTALL_NONE    1032
#define IDS_DETECTPROGRESS                  1035
#define IDS_DETECTCLASS                     1036
#define IDS_HDW_REBOOTDET                   1039
#define IDS_HDW_NOREBOOTDET                 1040
#define IDS_INSTALL_LEGACY_DEVICE           1041
#define IDS_UNINSTALL_LEGACY_DEVICE         1042
#define IDS_HDW_NONEDET1                    1043
#define IDS_HDW_INSTALLDET1                 1045
#define IDS_HDW_PICKCLASS1                  1047
#define IDS_HDW_DUPLICATE1                  1048
#define IDS_HDW_ANALYZEERR1                 1053
#define IDS_HDW_STDCFG                      1056
#define IDS_ADDNEWDEVICE                    1058
#define IDS_HDW_ERRORFIN1                   1059
#define IDS_HDW_ERRORFIN2                   1060
#define IDS_ADDDEVICE_SELECTCLASS           1061
#define IDS_ADDDEVICE_ANALYZEDEV            1065
#define IDS_HDW_RUNNING_TITLE               1067
#define IDS_HDW_RUNNING_MSG                 1068
#define IDS_HDW_NORMAL_LEGACY_FINISH1       1071
#define IDS_HDW_NORMALFINISH1               1073
#define IDS_INSTALL_PROBLEM                 1074
#define IDS_NEEDREBOOT                      1076
#define IDS_ADDDEVICE_INSTALLDEV            1077
#define IDS_HDW_NONEDEVICES                 1081
#define IDS_ADDDEVICE_PNPENUMERROR          1098
#define IDS_INSTALLNEWDEVICE                1100
#define IDS_NEED_FORCED_CONFIG              1102
#define IDS_SHOWALLDEVICES                  1103
#define IDC_ANALYZE_INSTALL_TEXT            1104
#define IDC_ANALYZE_EXIT_TEXT               1105
#define IDS_NEW_SETRESTOREPOINT             1110
#define IDS_WILL_BE_REMOVED                 1111
#define IDS_NEED_RESTART                    1112
#define IDS_ADDDEVICE_CONNECTED             1113
#define IDS_NO_PERMISSION_SHUTDOWN          1114
#define IDS_SHUTDOWN                        1115

#define IDC_STATIC                          -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\install.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       install.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"


typedef
UINT
(*PINSTALLDEVINST)(
    HWND hwndParent,
    LPCWSTR DeviceInstanceId,
    BOOL UpdateDriver,
    PDWORD pReboot
    );

HMODULE hNewDev = NULL;
PINSTALLDEVINST pInstallDevInst = NULL;



void
InstallSilentChilds(
   HWND hwdnParent,
   PHARDWAREWIZ HardwareWiz
   );
   
void
InstallSilentChildSiblings(
   HWND hwndParent,
   PHARDWAREWIZ HardwareWiz,
   DEVINST DeviceInstance,
   BOOL ReinstallAll
   )
{
    CONFIGRET ConfigRet;
    DEVINST ChildDeviceInstance;
    ULONG Ulong, ulValue;
    BOOL NeedsInstall, IsSilent;

    do {

        //
        // If this device instance needs installing and is silent then install it,
        // and its children.
        //

        IsSilent = FALSE;
        if (!ReinstallAll) {

            Ulong = sizeof(ulValue);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                            CM_DRP_CAPABILITIES,
                                                            NULL,
                                                            (PVOID)&ulValue,
                                                            &Ulong,
                                                            0,
                                                            NULL
                                                            );

            if (ConfigRet == CR_SUCCESS && (ulValue & CM_DEVCAP_SILENTINSTALL)) {

                IsSilent = TRUE;
            }
        }

        if (IsSilent || ReinstallAll) {

            Ulong = sizeof(ulValue);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                            CM_DRP_CONFIGFLAGS,
                                                            NULL,
                                                            (PVOID)&ulValue,
                                                            &Ulong,
                                                            0,
                                                            NULL
                                                            );

            if (ConfigRet == CR_SUCCESS && (ulValue & CONFIGFLAG_FINISH_INSTALL)) {

                NeedsInstall = TRUE;

            } else {

                ConfigRet = CM_Get_DevNode_Status(&Ulong,
                                                  &ulValue,
                                                  DeviceInstance,
                                                  0
                                                  );

                NeedsInstall = ConfigRet == CR_SUCCESS &&
                               (ulValue == CM_PROB_REINSTALL ||
                                ulValue == CM_PROB_NOT_CONFIGURED
                                );
            }


            if (NeedsInstall) {

                TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];

                ConfigRet = CM_Get_Device_ID(DeviceInstance,
                                            DeviceInstanceId,
                                            sizeof(DeviceInstanceId)/sizeof(TCHAR),
                                            0
                                            );

                if (ConfigRet == CR_SUCCESS) {

                    if (hNewDev) {

                        if (!pInstallDevInst) {

                            pInstallDevInst = (PVOID) GetProcAddress(hNewDev, "InstallDevInst");
                        }
                    }

                    if (pInstallDevInst) {

                        if (pInstallDevInst(hwndParent,
                                            DeviceInstanceId,
                                            FALSE,   // only for found new.
                                            &Ulong
                                            )) {

                           HardwareWiz->Reboot |= Ulong;
                        }
                    }


                    //
                    // If this devinst has children, then recurse to install them as well.
                    //

                    ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                                DeviceInstance,
                                                0,
                                                NULL
                                                );

                    if (ConfigRet == CR_SUCCESS) {

                        InstallSilentChildSiblings(hwndParent, HardwareWiz, ChildDeviceInstance, ReinstallAll);
                    }

                }
            }
        }


        //
        // Next sibling ...
        //

        ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance,
                                      DeviceInstance,
                                      0,
                                      NULL
                                      );

    } while (ConfigRet == CR_SUCCESS);

}





void
InstallSilentChilds(
   HWND hwndParent,
   PHARDWAREWIZ HardwareWiz
   )
{
    CONFIGRET ConfigRet;
    DEVINST ChildDeviceInstance;

    ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                HardwareWiz->DeviceInfoData.DevInst,
                                0,
                                NULL
                                );

    if (ConfigRet == CR_SUCCESS) {

        InstallSilentChildSiblings(hwndParent, HardwareWiz, ChildDeviceInstance, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\miscutil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       miscutil.c
//
//--------------------------------------------------------------------------

#include "HdwWiz.h"


/* ----------------------------------------------------------------------
 * SetDlgText - Set Dialog Text Field
 *
 * Concatenates a number of string resources and does a SetWindowText()
 * for a dialog text control.
 *
 * Parameters:
 *
 *  hDlg         - Dialog handle
 *  iControl     - Dialog control ID to receive text
 *  nStartString - ID of first string resource to concatenate
 *  nEndString   - ID of last string resource to concatenate
 *
 *  Note: the string IDs must be consecutive.
 */

void
SetDlgText(HWND hDlg, int iControl, int nStartString, int nEndString)
{
    int     iX;
    TCHAR   szText[MAX_PATH*4];

    szText[0] = '\0';
    for (iX = nStartString; iX<= nEndString; iX++) {

         LoadString(hHdwWiz,
                    iX,
                    szText + lstrlen(szText),
                    sizeof(szText)/sizeof(TCHAR) - lstrlen(szText)
                    );
    }

    if (iControl) {

        SetDlgItemText(hDlg, iControl, szText);

    } else {

        SetWindowText(hDlg, szText);
    }
}


VOID
HdwWizPropagateMessage(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    while ((hWnd = GetWindow(hWnd, GW_CHILD))) {

        SendMessage(hWnd, uMessage, wParam, lParam);
    }
}


BOOL
Use256Color(
    VOID
    )
{
    HDC hdc;
    BOOL bRetVal= FALSE;

    hdc = GetDC(NULL);
    if(hdc) {

        if (GetDeviceCaps(hdc, BITSPIXEL) >= 8) {

            bRetVal = TRUE;
        }

        ReleaseDC(NULL, hdc);
    }

    return bRetVal;
}





HPALETTE
CreateDIBPalette(
    LPBITMAPINFO lpbmi,
    LPINT lpiNumColors
    )
{
    LPBITMAPINFOHEADER  lpbi;
    LPLOGPALETTE     lpPal;
    HANDLE           hLogPal;
    HPALETTE         hPal = NULL;
    int              i;

    lpbi = (LPBITMAPINFOHEADER)lpbmi;

    if (lpbi->biBitCount <= 8) {

        *lpiNumColors = (1 << lpbi->biBitCount);
    } else {

        *lpiNumColors = 0;  // No palette needed for 24 BPP DIB
    }

    if (*lpiNumColors) {

        hLogPal = GlobalAlloc(GHND,
                             sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));

        if (hLogPal) {

            lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);

            if (lpPal) {

                lpPal->palVersion    = 0x300;
                lpPal->palNumEntries = (unsigned short)(*lpiNumColors);

                for (i = 0;  i < *lpiNumColors;  i++)
                {
                    lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
                    lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
                    lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
                    lpPal->palPalEntry[i].peFlags = 0;
                }

                hPal = CreatePalette (lpPal);
                GlobalUnlock (hLogPal);
                GlobalFree   (hLogPal);
            }
        }
    }

    return hPal;
}


BOOL
LoadBitmapAndPalette(
    HINSTANCE hInstance,
    LPCTSTR pszResource,
    PRESOURCEBITMAP ResourceBitmap
    )
{
    HBITMAP hBitmap = NULL;
    HPALETTE hPalette = NULL;
    LPBITMAPINFOHEADER  lpbi;

    HDC    hdc;
    HRSRC  hRsrc;
    HGLOBAL hGlobal;

    int iNumColors;

    hRsrc = FindResource(hInstance, pszResource, RT_BITMAP);
    if (hRsrc) {

        hGlobal = LoadResource(hInstance, hRsrc);

        if (hGlobal) {

            lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

            if (lpbi) {

                hdc = GetDC(NULL);

                hPalette = CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);

                if (hPalette) {

                    SelectPalette(hdc, hPalette, TRUE);
                    RealizePalette(hdc);
                }

                hBitmap = CreateDIBitmap(hdc,
                                         (LPBITMAPINFOHEADER)lpbi,
                                         (LONG)CBM_INIT,
                                         (LPSTR)lpbi + lpbi->biSize + iNumColors * sizeof(RGBQUAD),
                                         (LPBITMAPINFO)lpbi,
                                         DIB_RGB_COLORS
                                         );

                UnlockResource(hGlobal);
            }

            FreeResource(hGlobal);
        }
    }

    if (!hBitmap || !hPalette) {

        if (hBitmap)
            DeleteObject(hBitmap);

        if (hPalette)
            DeleteObject(hPalette);

        return FALSE;
    }

    ResourceBitmap->hBitmap = hBitmap;
    ResourceBitmap->hPalette = hPalette;
    GetObject(hBitmap, sizeof(ResourceBitmap->Bitmap), &ResourceBitmap->Bitmap);

    return TRUE;
}



void
HideWindowByMove(
    HWND hDlg
    )
{
    RECT rect;
    GetWindowRect(hDlg, &rect);

    MoveWindow(hDlg,
               0,
               -(rect.bottom - rect.top),
               rect.right - rect.left,
               rect.bottom - rect.top,
               FALSE
               );
}




LONG
HdwBuildClassInfoList(
    PHARDWAREWIZ HardwareWiz,
    DWORD ClassListFlags,
    PTCHAR MachineName
    )
{
    LONG Error;

    while (!SetupDiBuildClassInfoListEx(ClassListFlags,
                                        HardwareWiz->ClassGuidList,
                                        HardwareWiz->ClassGuidSize,
                                        &HardwareWiz->ClassGuidNum,
                                        MachineName,
                                        NULL
                                        )) {

        Error = GetLastError();

        if (HardwareWiz->ClassGuidList) {

            LocalFree(HardwareWiz->ClassGuidList);
            HardwareWiz->ClassGuidList = NULL;
        }

        if (Error == ERROR_INSUFFICIENT_BUFFER &&
            HardwareWiz->ClassGuidNum > HardwareWiz->ClassGuidSize) {

            HardwareWiz->ClassGuidList = LocalAlloc(LPTR, HardwareWiz->ClassGuidNum*sizeof(GUID));

            if (!HardwareWiz->ClassGuidList) {

                HardwareWiz->ClassGuidSize = 0;
                HardwareWiz->ClassGuidNum = 0;
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            HardwareWiz->ClassGuidSize = HardwareWiz->ClassGuidNum;

        } else {

            if (HardwareWiz->ClassGuidList) {

                LocalFree(HardwareWiz->ClassGuidList);
            }

            HardwareWiz->ClassGuidSize = 0;
            HardwareWiz->ClassGuidNum = 0;
            return Error;
        }
    }

    return ERROR_SUCCESS;
}



int
HdwMessageBox(
   HWND hWnd,
   LPTSTR szIdText,
   LPTSTR szIdCaption,
   UINT Type
   )
{
   TCHAR szText[MAX_PATH];
   TCHAR szCaption[MAX_PATH];

   if (!HIWORD(szIdText)) {
       *szText = TEXT('\0');
       LoadString(hHdwWiz, LOWORD(szIdText), szText, MAX_PATH);
       szIdText = szText;
       }

   if (!HIWORD(szIdCaption)) {
       *szCaption = TEXT('\0');
       LoadString(hHdwWiz, LOWORD(szIdCaption), szCaption, MAX_PATH);
       szIdCaption = szCaption;
       }

   return MessageBox(hWnd, szIdText, szIdCaption, Type);
}





LONG
HdwUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionPointers
    )
{
    LONG lRet;
    BOOL BeingDebugged;

    lRet = UnhandledExceptionFilter(ExceptionPointers);

    BeingDebugged = IsDebuggerPresent();

    //
    // Normal code path is to handle the exception.
    // However, if a debugger is present, and the system's unhandled
    // exception filter returns continue search, we let it go
    // thru to allow the debugger a chance at it.
    //

    if (lRet == EXCEPTION_CONTINUE_SEARCH && !BeingDebugged) {
        lRet = EXCEPTION_EXECUTE_HANDLER;
        }

    return lRet;
}

BOOL
NoPrivilegeWarning(
   HWND hWnd
   )
/*++

    This function checks to see if the user has SE_LOAD_DRIVER_NAME privileges
    which means they can install and load new kernel mode drivers.

    If the user does NOT have this privilege then a warning is displayed telling
    them that they have insufficient privileges to install hardware on this machine.

Arguments

    hWnd - Parent window handle

Return Value:
    TRUE if the user does NOT have SE_LOAD_DRIVER_NAME privileges and
    FALSE if the user does have this privilege

--*/
{
   TCHAR szMsg[MAX_PATH];
   TCHAR szCaption[MAX_PATH];

   if (!pSetupDoesUserHavePrivilege((PCTSTR)SE_LOAD_DRIVER_NAME)) {

       if (LoadString(hHdwWiz,
                      IDS_HDWUNINSTALL_NOPRIVILEGE,
                      szMsg,
                      MAX_PATH)
          &&
           LoadString(hHdwWiz,
                      IDS_HDWWIZNAME,
                      szCaption,
                      MAX_PATH))
        {
            MessageBox(hWnd, szMsg, szCaption, MB_OK | MB_ICONEXCLAMATION);
        }

       return TRUE;
    }

   return FALSE;
}

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{

    HWND hChildWnd;

    hChildWnd = GetWindow(hWnd, GW_CHILD);
    while (hChildWnd != NULL) {
        SendMessage(hChildWnd, WM_SYSCOLORCHANGE, wParam, lParam);
        hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);
        }

}

void
LoadText(
    PTCHAR szText,
    int SizeText,
    int nStartString,
    int nEndString
    )
{
    int     iX;

    for (iX = nStartString; iX<= nEndString; iX++) {

        LoadString(hHdwWiz,
                   iX,
                   szText + lstrlen(szText),
                   SizeText/sizeof(TCHAR) - lstrlen(szText)
                   );
    }

    return;
}


/*  InstallFailedWarning
 *
 *  Displays device install failed warning in a message box.  For use
 *  when installation fails.
 *
 */
void
InstallFailedWarning(
    HWND    hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    int len;
    TCHAR szMsg[MAX_MESSAGE_STRING];
    TCHAR szTitle[MAX_MESSAGE_TITLE];
    PTCHAR ErrorMsg;

    LoadString(hHdwWiz,
               IDS_ADDNEWDEVICE,
               szTitle,
               sizeof(szTitle)/sizeof(TCHAR)
               );

    if ((len = LoadString(hHdwWiz, IDS_HDW_ERRORFIN1, szMsg, sizeof(szMsg)/sizeof(TCHAR)))) {

        LoadString(hHdwWiz, IDS_HDW_ERRORFIN2, szMsg+len, sizeof(szMsg)/sizeof(TCHAR)-len);
    }

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL,
                      HRESULT_FROM_SETUPAPI(HardwareWiz->LastError),
                      0,
                      (LPTSTR)&ErrorMsg,
                      0,
                      NULL
                      ))
    {
        lstrcat(szMsg, TEXT("\n\n"));

        if ((lstrlen(szMsg) + lstrlen(ErrorMsg)) < SIZECHARS(szMsg)) {

            lstrcat(szMsg, ErrorMsg);
        }

        LocalFree(ErrorMsg);
    }

    MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);
}


void
SetDriverDescription(
    HWND hDlg,
    int iControl,
    PHARDWAREWIZ HardwareWiz
    )
{
    CONFIGRET ConfigRet;
    ULONG  ulSize;
    PTCHAR FriendlyName;
    PTCHAR Location;
    SP_DRVINFO_DATA DriverInfoData;


    //
    // If there is a selected driver use its driver description,
    // since this is what the user is going to install.
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(HardwareWiz->hDeviceInfo,
                                 &HardwareWiz->DeviceInfoData,
                                 &DriverInfoData
                                 )
        &&
        *DriverInfoData.Description) {

        wcscpy(HardwareWiz->DriverDescription, DriverInfoData.Description);
        SetDlgItemText(hDlg, iControl, HardwareWiz->DriverDescription);
        return;
    }


    FriendlyName = BuildFriendlyName(HardwareWiz->DeviceInfoData.DevInst, NULL);
    if (FriendlyName) {

        SetDlgItemText(hDlg, iControl, FriendlyName);
        LocalFree(FriendlyName);
        return;
    }

    SetDlgItemText(hDlg, iControl, szUnknown);

    return;
}

HPROPSHEETPAGE
CreateWizExtPage(
   int PageResourceId,
   DLGPROC pfnDlgProc,
   PHARDWAREWIZ HardwareWiz
   )
{
    PROPSHEETPAGE    psp;

    memset(&psp, 0, sizeof(PROPSHEETPAGE));
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = hHdwWiz;
    psp.lParam = (LPARAM)HardwareWiz;
    psp.pszTemplate = MAKEINTRESOURCE(PageResourceId);
    psp.pfnDlgProc = pfnDlgProc;

    return CreatePropertySheetPage(&psp);
}

BOOL
AddClassWizExtPages(
   HWND hwndParentDlg,
   PHARDWAREWIZ HardwareWiz,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData,
   DI_FUNCTION InstallFunction
   )
{
    DWORD NumPages;
    BOOL bRet = FALSE;

    memset(DeviceWizardData, 0, sizeof(SP_NEWDEVICEWIZARD_DATA));
    DeviceWizardData->ClassInstallHeader.InstallFunction = InstallFunction;
    DeviceWizardData->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    DeviceWizardData->hwndWizardDlg = hwndParentDlg;

    if (SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                     &HardwareWiz->DeviceInfoData,
                                     &DeviceWizardData->ClassInstallHeader,
                                     sizeof(SP_NEWDEVICEWIZARD_DATA)
                                     )
        &&

        (SetupDiCallClassInstaller(InstallFunction,
                                  HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData
                                  )

            ||

            (ERROR_DI_DO_DEFAULT == GetLastError()))

        &&
        SetupDiGetClassInstallParams(HardwareWiz->hDeviceInfo,
                                     &HardwareWiz->DeviceInfoData,
                                     &DeviceWizardData->ClassInstallHeader,
                                     sizeof(SP_NEWDEVICEWIZARD_DATA),
                                     NULL
                                     )
        &&
        DeviceWizardData->NumDynamicPages)
    {
        NumPages = 0;
        while (NumPages < DeviceWizardData->NumDynamicPages) {

           PropSheet_AddPage(hwndParentDlg, DeviceWizardData->DynamicPages[NumPages++]);
        }

        bRet = TRUE;
    }

   //
   // Clear the class install parameters.
   //

   SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                &HardwareWiz->DeviceInfoData,
                                NULL,
                                0
                                );

   return bRet;
}

void
RemoveClassWizExtPages(
   HWND hwndParentDlg,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData
   )
{
    DWORD NumPages;

    NumPages = DeviceWizardData->NumDynamicPages;
    while (NumPages--) {

       PropSheet_RemovePage(hwndParentDlg,
                            (WPARAM)-1,
                            DeviceWizardData->DynamicPages[NumPages]
                            );
    }

    memset(DeviceWizardData, 0, sizeof(SP_NEWDEVICEWIZARD_DATA));

    return;
}

BOOL
IsDeviceHidden(
    PHARDWAREWIZ HardwareWiz,
    PSP_DEVINFO_DATA DeviceInfoData
    )
{
    BOOL bHidden = FALSE;
    ULONG DevNodeStatus, DevNodeProblem;
    HKEY hKeyClass;

    //
    // If the DN_NO_SHOW_IN_DM status bit is set
    // then we should hide this device.
    //
    if ((CM_Get_DevNode_Status(&DevNodeStatus,
                              &DevNodeProblem,
                              DeviceInfoData->DevInst,
                              0) == CR_SUCCESS) &&
        (DevNodeStatus & DN_NO_SHOW_IN_DM)) {

        bHidden = TRUE;
        goto HiddenDone;
    }

    //
    // If the devices class has the NoDisplayClass value then
    // don't display this device.
    //
    if (hKeyClass = SetupDiOpenClassRegKeyEx(&DeviceInfoData->ClassGuid,
                                 KEY_READ,
                                 DIOCR_INSTALLER,
                                 HardwareWiz->hMachine ? HardwareWiz->MachineName : NULL,
                                 NULL)) {

        if (RegQueryValueEx(hKeyClass, REGSTR_VAL_NODISPLAYCLASS, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            bHidden = TRUE;
        }

        RegCloseKey(hKeyClass);
    }



HiddenDone:
    return bHidden;
}

DWORD 
SetPrivilegeAttribute(
    LPCTSTR PrivilegeName, 
    DWORD NewPrivilegeAttribute, 
    DWORD *OldPrivilegeAttribute
    )
/*++

    sets the security attributes for a given privilege.

Arguments:

    PrivilegeName - Name of the privilege we are manipulating.

    NewPrivilegeAttribute - The new attribute value to use.

    OldPrivilegeAttribute - Pointer to receive the old privilege value. OPTIONAL

Return value:

    NO_ERROR or WIN32 error.

--*/
{
    LUID             PrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges, OldTokenPrivileges;
    DWORD            ReturnLength;
    HANDLE           TokenHandle;

    //
    // First, find out the LUID Value of the privilege
    //

    if (!LookupPrivilegeValue(NULL, PrivilegeName, &PrivilegeValue)) 
    {
        return GetLastError();
    }

    //
    // Get the token handle
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &TokenHandle)) 
    {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = NewPrivilegeAttribute;

    ReturnLength = sizeof( TOKEN_PRIVILEGES );
    if (!AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                &OldTokenPrivileges,
                &ReturnLength
                )) 
    {
        CloseHandle(TokenHandle);
        return GetLastError();
    }
    else 
    {
        if (OldPrivilegeAttribute != NULL) 
        {
            *OldPrivilegeAttribute = OldTokenPrivileges.Privileges[0].Attributes;
        }
        CloseHandle(TokenHandle);
        return NO_ERROR;
    }
}

BOOL
ShutdownMachine(
    HWND hWnd
    )
{
    BOOL fOk;
    DWORD dwExitWinCode = EWX_SHUTDOWN;
    DWORD OldState;
    DWORD dwError;

    if (IsPwrShutdownAllowed()) {
        dwExitWinCode |= EWX_POWEROFF;
    }

    dwError = SetPrivilegeAttribute(SE_SHUTDOWN_NAME, SE_PRIVILEGE_ENABLED, &OldState);

    if (GetKeyState(VK_CONTROL) < 0) {
        dwExitWinCode |= EWX_FORCE;
    }

    fOk = ExitWindowsEx(dwExitWinCode, REASON_PLANNED_FLAG | REASON_HWINSTALL);

    //
    // If we were able to set the privilege, then reset it.
    //
    if (dwError == ERROR_SUCCESS) {
        SetPrivilegeAttribute(SE_SHUTDOWN_NAME, OldState, NULL);
    }
    else
    {
        //
        // Otherwise, if we failed, then it must have been some
        // security stuff.
        //
        if (!fOk)
        {
            TCHAR Title[MAX_PATH], Message[MAX_PATH];

            if (LoadString(hHdwWiz, IDS_NO_PERMISSION_SHUTDOWN, Message, SIZECHARS(Message)) &&
                LoadString(hHdwWiz, IDS_SHUTDOWN, Title, SIZECHARS(Title))) {

                MessageBox(hWnd, Message, Title, MB_OK | MB_ICONSTOP);
            }
        }
    }

    return fOk;
}

int
DeviceProperties(
                 HWND hWnd,
                 HMACHINE hMachine,
                 LPCSTR MachineName,
                 DEVNODE DevNode,
                 ULONG Flags
                 )
{
    TCHAR DeviceID[MAX_DEVICE_ID_LEN];
    PDEVICEPROPERTIESEX pDevicePropertiesEx = NULL;    
    int iRet = 0;

    if (!hDevMgr) {
        return 0;
    }

    pDevicePropertiesEx = (PVOID) GetProcAddress(hDevMgr, "DevicePropertiesExW");

    if (!pDevicePropertiesEx) {
        return 0;
    }

    if (CM_Get_Device_ID_Ex(DevNode,
                            DeviceID,
                            SIZECHARS(DeviceID),
                            0,
                            hMachine
                            ) == CR_SUCCESS) {
        
        iRet = pDevicePropertiesEx(hWnd,            
                                   MachineName,
                                   (LPCSTR)DeviceID,
                                   Flags,
                                   FALSE);
    }

    return iRet;
}

#if DBG
//
// Debugging aids
//
void
Trace(
    LPCTSTR format,
    ...
    )
{
    // according to wsprintf specification, the max buffer size is
    // 1024
    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(TEXT("HDWWIZ: "));
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\sthread.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       sthread.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"

DWORD
SearchDriversThread(
    PVOID pvHardwareWiz
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ) pvHardwareWiz;
    PSEARCHTHREAD SearchThread;
    DWORD Error = ERROR_SUCCESS;
    DWORD WaitResult;
    UINT Msg;
    WPARAM wParam;
    LPARAM lParam;
    DWORD Delay;

    try {

        if (!HardwareWiz || !HardwareWiz->SearchThread) {
        
            return ERROR_INVALID_PARAMETER;
        }
        
        SearchThread = HardwareWiz->SearchThread;

        while (TRUE) {

            SetEvent(SearchThread->ReadyEvent);

waitloop:            

            if ((WaitResult = WaitForSingleObject(SearchThread->RequestEvent, 5000)) == WAIT_FAILED) {

                Error = GetLastError();
                break;
            }

            else if (WaitResult == WAIT_TIMEOUT) {

                goto waitloop;
            }


            if (SearchThread->Function == SEARCH_NULL) {
            
                Msg = 0;
                Delay = 0;
            }
            
            else if (SearchThread->Function == SEARCH_EXIT) {
            
                break;
            }
            
            else if (SearchThread->Function == SEARCH_DELAY) {
            
                Delay = SearchThread->Param;
                Msg = WUM_DELAYTIMER;
                wParam = TRUE;
                lParam = ERROR_SUCCESS;
            }
            
            else if (SearchThread->Function == SEARCH_DETECT) {
            
                Delay = 0;
                Msg = WUM_DETECT;
                wParam = TRUE;
                lParam = ERROR_SUCCESS;

                try {
                
                   BuildDeviceDetection(SearchThread->hDlg, HardwareWiz);
                }
                
                except (EXCEPTION_EXECUTE_HANDLER) {
                
                   lParam = GetExceptionCode();
                }
            }

            else if (SearchThread->Function == SEARCH_PNPENUM) {
            
                Delay = 0;
                Msg = WUM_PNPENUMERATE;
                wParam = TRUE;
                lParam = ERROR_SUCCESS;

                try {
                
                   Delay = PNPEnumerate(HardwareWiz);
                }

                except (EXCEPTION_EXECUTE_HANDLER) {
                
                   lParam = GetExceptionCode();
                }
            }

            else {
        
                Error = ERROR_INVALID_FUNCTION;
                break;
            }

            SearchThread->Function = SEARCH_NULL;

            WaitForSingleObject(SearchThread->CancelEvent, Delay);

            if (Msg && SearchThread->hDlg) {
        
                PostMessage(SearchThread->hDlg, Msg, wParam, lParam);
            }
        }
    }
   
    except(HdwUnhandledExceptionFilter(GetExceptionInformation())) {

        Error = RtlNtStatusToDosError(GetExceptionCode());
    }

    return Error;
}
BOOL
SearchThreadRequest(
   PSEARCHTHREAD SearchThread,
   HWND    hDlg,
   UCHAR   Function,
   ULONG   Param
   )
{
    MSG Msg;
    DWORD WaitReturn;

    while ((WaitReturn = MsgWaitForMultipleObjects(1,
                                                   &SearchThread->ReadyEvent,
                                                   FALSE,
                                                   INFINITE,
                                                   //QS_ALLINPUT
                                                   QS_ALLEVENTS
                                                   ))
            == WAIT_OBJECT_0 + 1)
    {

        while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)) {
      
            if (!IsDialogMessage(hDlg,&Msg)) {
           
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }
        }
    }


    if (WaitReturn == WAIT_OBJECT_0) {
    
        ResetEvent(SearchThread->CancelEvent);
        SearchThread->CancelRequest = FALSE;
        SearchThread->hDlg = hDlg;
        SearchThread->Function = Function;
        SearchThread->Param = Param;

        SetEvent(SearchThread->RequestEvent);
        return TRUE;
    }

    return FALSE;
}



VOID
CancelSearchRequest(
    PHARDWAREWIZ HardwareWiz
    )
{
    PSEARCHTHREAD SearchThread;

    SearchThread = HardwareWiz->SearchThread;

    if (SearchThread->hDlg) {

        //
        // Cancel drivers search, and then request a NULL operation
        // to get in sync with the search thread.
        //

        if (SearchThread->Function == SEARCH_DRIVERS) {

            SetupDiCancelDriverInfoSearch(HardwareWiz->hDeviceInfo);
        }

        SearchThread->CancelRequest = TRUE;
        SetEvent(SearchThread->CancelEvent);
        SearchThreadRequest(SearchThread,
                            NULL,
                            SEARCH_NULL,
                            0
                            );
        }
}


LONG
CreateSearchThread(
   PHARDWAREWIZ HardwareWiz
   )
{
   PSEARCHTHREAD SearchThread = HardwareWiz->SearchThread;
   DWORD  ThreadId;

   SearchThread->hDlg      = NULL;
   SearchThread->Function  = 0;

   if (!(SearchThread->RequestEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) ||
       !(SearchThread->ReadyEvent   = CreateEvent(NULL, FALSE, FALSE, NULL)) ||
       !(SearchThread->CancelEvent  = CreateEvent(NULL, FALSE, FALSE, NULL)) ||
       !(SearchThread->hThread      = CreateThread(NULL,
                                                   0,
                                                   SearchDriversThread,
                                                   HardwareWiz,
                                                   0,
                                                   &ThreadId
                                                   )))
       {

        if (SearchThread->RequestEvent) {
        
            CloseHandle(SearchThread->RequestEvent);
        }

        if (SearchThread->ReadyEvent) {
        
            CloseHandle(SearchThread->ReadyEvent);
        }

        if (SearchThread->CancelEvent) {
        
            CloseHandle(SearchThread->CancelEvent);
        }

        return GetLastError();
    }

    return ERROR_SUCCESS;
}


void
DestroySearchThread(
   PSEARCHTHREAD SearchThread
   )
{
    //
    // Signal search thread to exit,
    //


    if (SearchThread->hThread) {
    
        DWORD ExitCode;

        if (GetExitCodeThread(SearchThread->hThread, &ExitCode) &&
            ExitCode == STILL_ACTIVE) {
            
            SearchThreadRequest(SearchThread, NULL, SEARCH_EXIT, 0);
        }

        WaitForSingleObject(SearchThread->hThread, INFINITE);
        CloseHandle(SearchThread->hThread);
        SearchThread->hThread = NULL;
    }


    if (SearchThread->ReadyEvent) {
    
        CloseHandle(SearchThread->ReadyEvent);
        SearchThread->ReadyEvent = NULL;
    }

    if (SearchThread->RequestEvent) {
    
        CloseHandle(SearchThread->RequestEvent);
        SearchThread->RequestEvent = NULL;
    }

    if (SearchThread->CancelEvent) {
    
        CloseHandle(SearchThread->CancelEvent);
        SearchThread->CancelEvent = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hdwwiz\selclass.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       selclass.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"


int CALLBACK
ClassListCompare(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    TCHAR ClassDescription1[LINE_LEN];
    TCHAR ClassDescription2[LINE_LEN];

    //
    // Check if the 1st item is GUID_DEVCLASS_UNKNOWN
    //
    if (IsEqualGUID((LPGUID)lParam1, &GUID_DEVCLASS_UNKNOWN)) {
        return -1;
    }

    //
    // Check if the 2nd item is GUID_DEVCLASS_UNKNOWN
    //
    if (IsEqualGUID((LPGUID)lParam2, &GUID_DEVCLASS_UNKNOWN)) {
        return 1;
    }

    if (SetupDiGetClassDescription((LPGUID)lParam1,
                                   ClassDescription1,
                                   LINE_LEN,
                                   NULL
                                   ) &&
        SetupDiGetClassDescription((LPGUID)lParam2,
                                   ClassDescription2,
                                   LINE_LEN,
                                   NULL
                                   )) {
    
        return (lstrcmpi(ClassDescription1, ClassDescription2));
    }

    return 0;
}

void InitHDW_PickClassDlg(
    HWND hwndClassList,
    PHARDWAREWIZ HardwareWiz
    )
{
    int  Index;
    LPGUID ClassGuid, lpClassGuidSelected;
    GUID ClassGuidSelected;
    int    lvIndex;
    DWORD  ClassGuidNum;
    LV_ITEM lviItem;
    TCHAR ClassDescription[LINE_LEN];

    SendMessage(hwndClassList, WM_SETREDRAW, FALSE, 0L);

    // Clear the Class List
    ListView_DeleteAllItems(hwndClassList);

    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iItem = -1;
    lviItem.iSubItem = 0;

    ClassGuid = HardwareWiz->ClassGuidList;
    ClassGuidNum = HardwareWiz->ClassGuidNum;


    // keep track of previosuly selected item
    if (IsEqualGUID(&HardwareWiz->lvClassGuidSelected, &GUID_NULL)) {
    
        lpClassGuidSelected = NULL;

    } else {
    
        ClassGuidSelected = HardwareWiz->lvClassGuidSelected;
        HardwareWiz->lvClassGuidSelected = GUID_NULL;
        lpClassGuidSelected = &ClassGuidSelected;
    }


    while (ClassGuidNum--) {
    
        if (SetupDiGetClassDescription(ClassGuid,
                                       ClassDescription,
                                       LINE_LEN,
                                       NULL
                                       )) {
                                       
            if (IsEqualGUID(ClassGuid, &GUID_DEVCLASS_UNKNOWN)) {

                //
                // We need to special case the UNKNOWN class and to give it a 
                // special icon (blank) and special text (Show All Devices).
                //
                LoadString(hHdwWiz, 
                           IDS_SHOWALLDEVICES, 
                           ClassDescription, 
                           SIZECHARS(ClassDescription)
                           );
                lviItem.iImage = g_BlankIconIndex;                
                lviItem.mask |= LVIF_IMAGE;

            } else if (SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                                 ClassGuid,
                                                 &lviItem.iImage
                                                 )) {
                                           
                lviItem.mask |= LVIF_IMAGE;

            } else {
            
                lviItem.mask &= ~LVIF_IMAGE;

            }

            lviItem.pszText = ClassDescription;
            lviItem.lParam = (LPARAM) ClassGuid;
            lvIndex = ListView_InsertItem(hwndClassList, &lviItem);

            //
            // check for previous selection
            //
            if (lpClassGuidSelected &&
                IsEqualGUID(lpClassGuidSelected, ClassGuid)) {
                
                ListView_SetItemState(hwndClassList,
                                      lvIndex,
                                      LVIS_SELECTED|LVIS_FOCUSED,
                                      LVIS_SELECTED|LVIS_FOCUSED
                                      );

                lpClassGuidSelected = NULL;
            }
        }

        ClassGuid++;
    }

    //
    // Sort the list
    //
    ListView_SortItems(hwndClassList, (PFNLVCOMPARE)ClassListCompare, NULL);

    //
    // if previous selection wasn't found select first in list.
    //
    if (IsEqualGUID(&HardwareWiz->lvClassGuidSelected, &GUID_NULL)) {

        lvIndex = 0;
        ListView_SetItemState(hwndClassList,
                              lvIndex,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED
                              );
    }

    //
    // previous selection was found, fetch its current index
    //
    else {

        lvIndex = ListView_GetNextItem(hwndClassList,
                                       -1,
                                       LVNI_SELECTED
                                       );
    }

    //
    // scroll the selected item into view.
    //
    ListView_EnsureVisible(hwndClassList, lvIndex, FALSE);
    ListView_SetColumnWidth(hwndClassList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndClassList, WM_SETREDRAW, TRUE, 0L);
}

INT_PTR CALLBACK
HdwPickClassDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    DWORD Error;
    HWND hwndClassList = GetDlgItem(hDlg, IDC_HDW_PICKCLASS_CLASSLIST);
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);



    switch (wMsg) {
    
        case WM_INITDIALOG: {
       
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            LV_COLUMN lvcCol;

            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

            //
            // Get the Class Icon Image Lists.  We do this only the first
            // time this dialog is initialized.
            //
            if (HardwareWiz->ClassImageList.cbSize) {

                ListView_SetImageList(hwndClassList,
                                      HardwareWiz->ClassImageList.ImageList,
                                      LVSIL_SMALL
                                      );
            }

            // Insert a column for the class list
            lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
            lvcCol.fmt = LVCFMT_LEFT;
            lvcCol.iSubItem = 0;
            ListView_InsertColumn(hwndClassList, 0, (LV_COLUMN FAR *)&lvcCol);

            //
            // Save the class before the user chooses one. This will be restored
            // in the event the install is cancelled.
            //

            HardwareWiz->SavedClassGuid = HardwareWiz->DeviceInfoData.ClassGuid;


           break;
        }


        case WM_DESTROY:
            break;

        case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

            //
            // This dialog is being activated.  Each time we are activated
            // we free up the current DeviceInfo and create a new one. Although
            // inefficient, its necessary to reenumerate the class list.
            //

            case PSN_SETACTIVE:

                PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);
                HardwareWiz->PrevPage = IDD_ADDDEVICE_SELECTCLASS;

                //
                // If we have DeviceInfo from going forward delete it.
                //

                if (HardwareWiz->ClassGuidSelected) {

                    SetupDiDeleteDeviceInfo(HardwareWiz->hDeviceInfo, &HardwareWiz->DeviceInfoData);
                    memset(&HardwareWiz->DeviceInfoData, 0, sizeof(SP_DEVINFO_DATA));
                }

                HardwareWiz->ClassGuidSelected = NULL;

                HdwBuildClassInfoList(HardwareWiz, 
                                      DIBCI_NOINSTALLCLASS,
                                      HardwareWiz->hMachine ? HardwareWiz->MachineName : NULL
                                      );
                                     
                InitHDW_PickClassDlg(hwndClassList, HardwareWiz);
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                HardwareWiz->PrevPage = IDD_ADDDEVICE_SELECTCLASS;

                if (HardwareWiz->EnterInto == IDD_ADDDEVICE_SELECTCLASS) {
                
                    SetDlgMsgResult(hDlg, wMsg, HardwareWiz->EnterFrom);

                } else {
                
                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_ASKDETECT);
                }

               break;

            case PSN_WIZNEXT: {
           
                HDEVINFO hDeviceInfo;
                LPGUID  ClassGuidSelected;
                SP_DEVINSTALL_PARAMS DeviceInstallParams;

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTDEVICE);

                if (IsEqualGUID(&HardwareWiz->lvClassGuidSelected, &GUID_NULL)) {
                
                    HardwareWiz->ClassGuidSelected = NULL;
                    break;
                }

                ClassGuidSelected = &HardwareWiz->lvClassGuidSelected;
                HardwareWiz->ClassGuidSelected = ClassGuidSelected;

                //
                // Add a new element to the DeviceInfo from the GUID and class name
                //
                HardwareWiz->DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

                if (!SetupDiGetClassDescription(HardwareWiz->ClassGuidSelected,
                                                HardwareWiz->ClassDescription,
                                                sizeof(HardwareWiz->ClassDescription)/sizeof(TCHAR),
                                                NULL
                                                )
                    ||
                    !SetupDiClassNameFromGuid(HardwareWiz->ClassGuidSelected,
                                              HardwareWiz->ClassName,
                                              sizeof(HardwareWiz->ClassName)/sizeof(TCHAR),
                                              NULL
                                              ))
                {
                    // unhandled error!
                    HardwareWiz->ClassGuidSelected = NULL;
                    break;
                }

                if (IsEqualGUID(HardwareWiz->ClassGuidSelected, &GUID_DEVCLASS_UNKNOWN)) {
                
                    ClassGuidSelected = (LPGUID)&GUID_NULL;
                }

                if (!SetupDiCreateDeviceInfo(HardwareWiz->hDeviceInfo,
                                             HardwareWiz->ClassName,
                                             ClassGuidSelected,
                                             NULL,
                                             hwndParentDlg,
                                             DICD_GENERATE_ID,
                                             &HardwareWiz->DeviceInfoData
                                             )
                    ||
                    !SetupDiSetSelectedDevice(HardwareWiz->hDeviceInfo,
                                              &HardwareWiz->DeviceInfoData
                                              ))
                {
                    HardwareWiz->ClassGuidSelected = NULL;
                    break;
                }
                
                break;
            }

            case NM_DBLCLK:
                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);
                break;

            case LVN_ITEMCHANGED: {
            
                LPNM_LISTVIEW   lpnmlv = (LPNM_LISTVIEW)lParam;

                if ((lpnmlv->uChanged & LVIF_STATE)) {
                
                    if (lpnmlv->uNewState & LVIS_SELECTED) {
                    
                        HardwareWiz->lvClassGuidSelected = *((LPGUID)lpnmlv->lParam);

                    } else if (IsEqualGUID((LPGUID)lpnmlv->lParam, &HardwareWiz->lvClassGuidSelected)) {
                    
                        HardwareWiz->lvClassGuidSelected = GUID_NULL;
                    }
                }

                break;
            }
        }
        break;


       case WM_SYSCOLORCHANGE:
           _OnSysColorChange(hDlg, wParam, lParam);

           // Update the ImageList Background color
           ImageList_SetBkColor((HIMAGELIST)SendMessage(GetDlgItem(hDlg, IDC_HDW_PICKCLASS_CLASSLIST), LVM_GETIMAGELIST, (WPARAM)(LVSIL_SMALL), 0L),
                                   GetSysColor(COLOR_WINDOW));

           break;

       default:
           return(FALSE);
       }

    return(TRUE);
}

void
DestroyDynamicWizard(
    HWND hwndParentDlg,
    PHARDWAREWIZ HardwareWiz,
    BOOL WmDestroy
    )
{
    DWORD Pages;
    PSP_INSTALLWIZARD_DATA InstallWizard = &HardwareWiz->InstallDynaWiz;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;


    Pages = InstallWizard->NumDynamicPages;
    InstallWizard->NumDynamicPages = 0;

    if (InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {

        if (!WmDestroy) {
        
            while (Pages--) {
            
                PropSheet_RemovePage(hwndParentDlg,
                                     (WPARAM)-1,
                                     InstallWizard->DynamicPages[Pages]
                                     );

                InstallWizard->DynamicPages[Pages] = NULL;
            }
        }


        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.Flags |= DI_CLASSINSTALLPARAMS;
            SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }


        InstallWizard->DynamicPageFlags &= ~DYNAWIZ_FLAG_PAGESADDED;
        InstallWizard->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        InstallWizard->ClassInstallHeader.InstallFunction = DIF_DESTROYWIZARDDATA;
        InstallWizard->hwndWizardDlg = hwndParentDlg;

        if (SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                         &HardwareWiz->DeviceInfoData,
                                         &InstallWizard->ClassInstallHeader,
                                         sizeof(SP_INSTALLWIZARD_DATA)
                                         ))
        {
            SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA,
                                      HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData
                                      );
        }
    }

    if (!WmDestroy) {
    
    }
}



//
// The real select device page is in either setupapi or the class installer
// for dyanwiz. this page is a blank page which never shows its face
// to have a consistent place to jump to when the class is known.
//

INT_PTR CALLBACK
HdwSelectDeviceDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);



    switch (wMsg) {
       case WM_INITDIALOG: {
           LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
           HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
           SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
           break;
           }

       case WM_DESTROY:
           break;


       case WM_NOTIFY:
       switch (((NMHDR FAR *)lParam)->code) {

           case PSN_SETACTIVE: {
               int PrevPage, BackUpPage;

               PrevPage = HardwareWiz->PrevPage;
               HardwareWiz->PrevPage = IDD_ADDDEVICE_SELECTDEVICE;
               BackUpPage = HardwareWiz->EnterInto == IDD_ADDDEVICE_SELECTDEVICE
                              ? HardwareWiz->EnterFrom : IDD_ADDDEVICE_SELECTCLASS;

               //
               // If we are coming from select class, driver update or Install NewDevice
               // then we are going forward.
               //

               if (!HardwareWiz->ClassGuidSelected || PrevPage == IDD_WIZARDEXT_PRESELECT) {

                   //
                   // going backwards, cleanup and backup
                   //

                   SetupDiSetSelectedDriver(HardwareWiz->hDeviceInfo,
                                            &HardwareWiz->DeviceInfoData,
                                            NULL
                                            );

                   SetupDiDestroyDriverInfoList(HardwareWiz->hDeviceInfo,
                                                &HardwareWiz->DeviceInfoData,
                                                SPDIT_COMPATDRIVER
                                                );

                   SetupDiDestroyDriverInfoList(HardwareWiz->hDeviceInfo,
                                                &HardwareWiz->DeviceInfoData,
                                                SPDIT_CLASSDRIVER
                                                );


                   //
                   // Cleanup the WizExtPreSelect Page
                   //
                   if (HardwareWiz->WizExtPreSelect.hPropSheet) {
                       PropSheet_RemovePage(GetParent(hDlg),
                                            (WPARAM)-1,
                                            HardwareWiz->WizExtPreSelect.hPropSheet
                                            );
                       }



                   SetDlgMsgResult(hDlg, wMsg, BackUpPage);
                   break;
                   }


               // Set the Cursor to an Hourglass
               SetCursor(LoadCursor(NULL, IDC_WAIT));

               HardwareWiz->WizExtPreSelect.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_PRESELECT,
                                                                        WizExtPreSelectDlgProc,
                                                                        HardwareWiz
                                                                        );

               if (HardwareWiz->WizExtPreSelect.hPropSheet) {
                   PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPreSelect.hPropSheet);
                   SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                   }
               else {
                   SetDlgMsgResult(hDlg, wMsg, BackUpPage);
                   }


               break;
               }

           }
       break;

       default:
           return(FALSE);
       }



    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreSelectDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    switch (wMsg) {
    
        case WM_INITDIALOG: {
        
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            break;
        }

        case WM_DESTROY:
            break;


        case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
       
            case PSN_SETACTIVE:

                PrevPageId = HardwareWiz->PrevPage;
                HardwareWiz->PrevPage = IDD_WIZARDEXT_PRESELECT;

                if (PrevPageId == IDD_ADDDEVICE_SELECTDEVICE) {
              
                    PSP_NEWDEVICEWIZARD_DATA WizardExt;

                    //
                    // Moving forward on first page
                    //


                    //
                    // Set the Cursor to an Hourglass
                    //

                    SetCursor(LoadCursor(NULL, IDC_WAIT));

                    //
                    // Add ClassWizard Extension pages
                    //

                    AddClassWizExtPages(hwndParentDlg,
                                        HardwareWiz,
                                        &HardwareWiz->WizExtPreSelect.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_PRESELECT
                                        );


                    //
                    // Add the end page, which is first of the select page set
                    //

                    HardwareWiz->WizExtSelect.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_SELECT,
                                                                            WizExtSelectDlgProc,
                                                                            HardwareWiz
                                                                            );

                    if (HardwareWiz->WizExtSelect.hPropSheet) {
                  
                        PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtSelect.hPropSheet);
                    }

                    PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

                } else {

                    //
                    // Moving backwards on first page
                    //

                    //
                    // Clean up proppages added.
                    //

                    if (HardwareWiz->WizExtSelect.hPropSheet) {
                    
                        PropSheet_RemovePage(hwndParentDlg,
                                             (WPARAM)-1,
                                             HardwareWiz->WizExtSelect.hPropSheet
                                             );
                                             
                        HardwareWiz->WizExtSelect.hPropSheet = NULL;
                    }

                    RemoveClassWizExtPages(hwndParentDlg,
                                           &HardwareWiz->WizExtPreSelect.DeviceWizardData
                                           );

                    //
                    // Jump back
                    //

                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTDEVICE);
                }

                break;

            case PSN_WIZNEXT:
                SetDlgMsgResult(hDlg, wMsg, 0);
                break;
        }
        break;

        default:
            return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtSelectDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;
    PSP_INSTALLWIZARD_DATA  InstallWizard;

    switch (wMsg) {
    
        case WM_INITDIALOG: {

            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            break;
        }

        case WM_DESTROY:
            DestroyDynamicWizard(hwndParentDlg, HardwareWiz, TRUE);
            break;

        case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
       
            case PSN_SETACTIVE:

                PrevPageId = HardwareWiz->PrevPage;
                HardwareWiz->PrevPage = IDD_WIZARDEXT_SELECT;

                if (PrevPageId == IDD_WIZARDEXT_PRESELECT) {
                
                    SP_DEVINSTALL_PARAMS  DeviceInstallParams;

                    //
                    // Moving forward on first page
                    //



                    //
                    // Prepare to call the class installer, for class install wizard pages.
                    // and Add in setup's SelectDevice wizard page.
                    //

                    InstallWizard = &HardwareWiz->InstallDynaWiz;
                    memset(InstallWizard, 0, sizeof(SP_INSTALLWIZARD_DATA));
                    InstallWizard->ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
                    InstallWizard->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                    InstallWizard->hwndWizardDlg = GetParent(hDlg);

                    if (!SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                                      &HardwareWiz->DeviceInfoData,
                                                      &InstallWizard->ClassInstallHeader,
                                                      sizeof(SP_INSTALLWIZARD_DATA)
                                                      ))
                    {
                        SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                        break;
                    }


                    //
                    // Get current DeviceInstall parameters, and then set the fields
                    // we wanted changed from default
                    //

                    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                    if (!SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                                       &HardwareWiz->DeviceInfoData,
                                                       &DeviceInstallParams
                                                       ))
                    {
                        SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                        break;
                    }

                    DeviceInstallParams.Flags |= DI_SHOWCLASS | DI_SHOWOEM | DI_CLASSINSTALLPARAMS;

                    if (IsEqualGUID(HardwareWiz->ClassGuidSelected, &GUID_DEVCLASS_UNKNOWN)) {
                    
                        DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_FILTERCLASSES;

                   } else {
                   
                        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_FILTERCLASSES;
                   }

                    DeviceInstallParams.hwndParent = hwndParentDlg;

                    if (!SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                                      &HardwareWiz->DeviceInfoData,
                                                      &DeviceInstallParams
                                                      ))
                    {
                        SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                        break;
                    }


                    //
                    // Call the class installer for installwizard
                    // If no class install wizard pages default to run the standard
                    // setup wizard select device page.
                    //

                    if (SetupDiCallClassInstaller(DIF_INSTALLWIZARD,
                                                  HardwareWiz->hDeviceInfo,
                                                  &HardwareWiz->DeviceInfoData
                                                  )
                        &&
                        SetupDiGetClassInstallParams(HardwareWiz->hDeviceInfo,
                                                     &HardwareWiz->DeviceInfoData,
                                                     &InstallWizard->ClassInstallHeader,
                                                     sizeof(SP_INSTALLWIZARD_DATA),
                                                     NULL
                                                     )
                        &&
                        InstallWizard->NumDynamicPages)
                    {
                        DWORD   Pages;

                        InstallWizard->DynamicPageFlags |= DYNAWIZ_FLAG_PAGESADDED;
                        
                        for (Pages = 0; Pages < InstallWizard->NumDynamicPages; ++Pages ) {
                        
                            PropSheet_AddPage(hwndParentDlg, InstallWizard->DynamicPages[Pages]);
                        }

                        HardwareWiz->SelectDevicePage = SetupDiGetWizardPage(HardwareWiz->hDeviceInfo,
                                                                             &HardwareWiz->DeviceInfoData,
                                                                             InstallWizard,
                                                                             SPWPT_SELECTDEVICE,
                                                                             SPWP_USE_DEVINFO_DATA
                                                                             );

                        PropSheet_AddPage(hwndParentDlg, HardwareWiz->SelectDevicePage);


                        //SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_FIRSTPAGE);

                    } else {

                        InstallWizard->DynamicPageFlags = 0;
                        HardwareWiz->SelectDevicePage = NULL;

                        if (!AddClassWizExtPages(hwndParentDlg,
                                                 HardwareWiz,
                                                 &HardwareWiz->WizExtSelect.DeviceWizardData,
                                                 DIF_NEWDEVICEWIZARD_SELECT
                                                 ))
                        {
                            HardwareWiz->SelectDevicePage = SetupDiGetWizardPage(HardwareWiz->hDeviceInfo,
                                                                                 &HardwareWiz->DeviceInfoData,
                                                                                 InstallWizard,
                                                                                 SPWPT_SELECTDEVICE,
                                                                                 SPWP_USE_DEVINFO_DATA
                                                                                 );

                            PropSheet_AddPage(hwndParentDlg, HardwareWiz->SelectDevicePage);

                            //SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_SELECTDEV_PAGE);
                        }
                    }


                    //
                    // Clear the class install parameters.
                    //

                    SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                                 &HardwareWiz->DeviceInfoData,
                                                 NULL,
                                                 0
                                                 );

                    //
                    // Add the end page, which is the preanalyze page.
                    //

                    HardwareWiz->WizExtPreAnalyze.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_PREANALYZE,
                                                                                WizExtPreAnalyzeDlgProc,
                                                                                HardwareWiz
                                                                                );

                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPreAnalyze.hPropSheet);

                    PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

                } else {
                
                    //
                    // Moving backwards on first page
                    //


                    //
                    // Clean up proppages added.
                    //

                    DestroyDynamicWizard(hwndParentDlg, HardwareWiz, FALSE);

                    if (HardwareWiz->SelectDevicePage) {
                    
                        PropSheet_RemovePage(hwndParentDlg,
                                             (WPARAM)-1,
                                             HardwareWiz->SelectDevicePage
                                             );
                                             
                        HardwareWiz->SelectDevicePage = NULL;
                    }


                    if (HardwareWiz->WizExtPreAnalyze.hPropSheet) {
                    
                        PropSheet_RemovePage(hwndParentDlg,
                                             (WPARAM)-1,
                                             HardwareWiz->WizExtPreAnalyze.hPropSheet
                                             );
                                             
                        HardwareWiz->WizExtPreAnalyze.hPropSheet = NULL;
                    }



                    RemoveClassWizExtPages(hwndParentDlg,
                                           &HardwareWiz->WizExtSelect.DeviceWizardData
                                           );


                    //
                    // Jump back
                    //

                    SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                }

             break;

            case PSN_WIZNEXT:
                SetDlgMsgResult(hDlg, wMsg, 0);
                break;

        }
        break;

        default:
            return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\blkdrv.cpp ===
// blkdrv.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for blkdrv.idl by adding the following 
//      files to the Outputs.
//          blkdrv_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f blkdrvps.mk in the project directory.
#include "stdafx.h"
#include <commctrl.h>
#include "resource.h"
#include <initguid.h>
#include "blkdrv.h"
#include "dlldatax.h"

#include "blkdrv_i.c"
#include "Driver.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CMyModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_BlockedDrivers, CBlockedDrivers)
END_OBJECT_MAP()

HMODULE hHotPlug;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;

    hHotPlug = hInstance;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitCommonControls();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer();
}

//
// DCOM support, allow this DLL to also run as local server
// once the server is running, it needs to cleanup after a short period of time
//
const DWORD dwTimeOut = 5000; // time for server to be idle before shutting down

static void CALLBACK ModuleTimer(HWND /*hWnd*/,UINT /*uMsg*/,UINT /*idEvent*/,DWORD /*dwTime*/)
{
    _Module.CheckShutdown();
}

LONG CMyModule::Unlock()
{
    LONG l = CComModule::Unlock();
    
    if (bServer && (l <= (punkFact ? 1 : 0)))
    {
        //
        // DCOM server
        // as soon as lock count reaches 1 (punkFact), timer is reset
        // if timer times out and lock count is still 1
        // then we can kill the server
        //
        SetTimer(NULL,0,dwTimeOut, (TIMERPROC)ModuleTimer);
    }
    return l;
}

void CMyModule::KillServer()
{
    if(bServer) {
        //
        // make it a server no longer
        //
        CoRevokeClassObject(dwROC);
        bServer = FALSE;
    }
    if(punkFact) {
        punkFact->Release();
        punkFact = NULL;
    }
    if(m_nLockCnt != 0) {
        DebugBreak();
    }
}

void CMyModule::CheckShutdown()
{
    if(m_nLockCnt>(punkFact ? 1 : 0)) {
        //
        // module is still in use 
        //
        return;
    }
    //
    // lock count stayed at zero for dwTimeOut ms
    //
    KillServer();
    PostMessage(NULL, WM_QUIT, 0, 0);
}

HRESULT CMyModule::InitServer(GUID & ClsId)
{
    HRESULT hr;

    hr = DllGetClassObject(ClsId, IID_IClassFactory, (LPVOID*)&punkFact);
    if(FAILED(hr)) {
        return hr;
    }
    hr = CoRegisterClassObject(ClsId, punkFact, CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE, &dwROC);
    if(FAILED(hr)) {
        punkFact->Release();
        punkFact = NULL;
        return hr;
    }
    bServer = true;
    
    return S_OK;
}

void WINAPI CreateLocalServerW(HWND /*hwnd*/, HINSTANCE /*hAppInstance*/, LPWSTR pszCmdLine, int /*nCmdShow*/)
{
    GUID ClsId;
    HRESULT hr;
    LPWSTR dup;
    LPWSTR p;
    size_t len;
    MSG msg;

    hr = CoInitialize(NULL);
    if(FAILED(hr)) {
        return;
    }

    //
    // pszCmdLine = the class GUID we want factory for
    //
    p = wcschr(pszCmdLine,'{');
    if(!p) {
        goto final;
    }
    pszCmdLine = p;
    p = wcschr(pszCmdLine,'}');
    if(!p) {
        goto final;
    }
    len = p-pszCmdLine+1;
    dup = new WCHAR[len+1];
    if(!dup) {
        goto final;
    }
    wcsncpy(dup,pszCmdLine,len+1);
    dup[len] = '\0';
    hr = CLSIDFromString(dup,&ClsId);
    delete [] dup;

    if(FAILED(hr)) {
        goto final;
    }
    hr = _Module.InitServer(ClsId);
    if(FAILED(hr)) {
        goto final;
    }

    //
    // now go into dispatch loop until we get a quit message
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    _Module.KillServer();

final:
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\devtree.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       devtree.c
//
//--------------------------------------------------------------------------

#include "HotPlug.h"

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <initguid.h>
#include <devguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);


PDEVINST
BuildDeviceRelationsList(
   PTCHAR   DeviceId,
   HMACHINE hMachine,
   ULONG    FilterFlag,
   PUSHORT  pNumDevinst
   )
{
    ULONG Len, NumDevinst, MaxDevinst;
    USHORT NumDevInst;
    CONFIGRET ConfigRet;
    PTCHAR DeviceIdRelations = NULL, CurrDevId;
    PDEVINST DevinstRelations = NULL;

    DevinstRelations = NULL;
    DeviceIdRelations = NULL;
    NumDevInst = 0;

    Len = 0;
    ConfigRet = CM_Get_Device_ID_List_Size_Ex(&Len,
                                              DeviceId,
                                              FilterFlag,
                                              hMachine
                                              );

    if (ConfigRet == CR_SUCCESS && Len) {

        DeviceIdRelations = (PTCHAR)LocalAlloc(LPTR, Len*sizeof(TCHAR));
        
        if (!DeviceIdRelations) {

            goto BDEarlyExit;
        }
        
        *DeviceIdRelations = TEXT('\0');

        if (DeviceIdRelations) {

            ConfigRet = CM_Get_Device_ID_List_Ex(DeviceId,
                                                 DeviceIdRelations,
                                                 Len,
                                                 FilterFlag,
                                                 hMachine
                                                 );



            if (ConfigRet != CR_SUCCESS || !*DeviceIdRelations) {

                goto BDEarlyExit;
            }
        }
    }

    if (!Len) {

        goto BDEarlyExit;
    }
    
    //
    // Convert the deviceId list into a Devinst list. We make the gross
    // assumption that the Devinst list will NOT be bigger than the deviceId
    // list.
    //

    Len  = (Len + sizeof(DEVINST) - 1) & ~(sizeof(DEVINST) - 1);
    MaxDevinst = Len / sizeof(DEVINST);
    
    DevinstRelations = (PDEVINST)LocalAlloc(LPTR, Len);

    if (!DevinstRelations) {

        goto BDEarlyExit;
    }

    for (CurrDevId = DeviceIdRelations; *CurrDevId; CurrDevId += lstrlen(CurrDevId) + 1) {
        
        ConfigRet = CM_Locate_DevNode_Ex(&DevinstRelations[NumDevInst],
                                        CurrDevId,
                                        CM_LOCATE_DEVNODE_NORMAL,
                                        hMachine
                                        );

        if (ConfigRet == CR_SUCCESS) {

            if (++NumDevInst >= MaxDevinst) {

                //
                // paranoia check, if our devinst size wasn't big enough
                // the id list is probably trashed. so just give up.
                //

                break;
            }
        }
    }

BDEarlyExit:

    if (DeviceIdRelations) {

        LocalFree(DeviceIdRelations);
    }

    if (DevinstRelations) {

        if (NumDevInst) {

            PDEVINST DeviceInstance;

            Len = NumDevInst * sizeof(DEVINST);
            DeviceInstance = (PDEVINST)LocalReAlloc(DevinstRelations, Len, LMEM_FIXED);

            if (DeviceInstance) {

                DevinstRelations = DeviceInstance;
            }
        }

        else {

            LocalFree(DevinstRelations);
            DevinstRelations = NULL;
        }
    }

    *pNumDevinst = NumDevInst;
    return DevinstRelations;
}

LONG
AddChildSiblings(
    PDEVICETREE  DeviceTree,
    PDEVTREENODE ParentNode,
    DEVINST      DeviceInstance,
    int          TreeDepth,
    BOOL         Recurse
    )
{
    DWORD Len;
    CONFIGRET    ConfigRet;
    DEVINST      ChildDeviceInstance;
    PDEVTREENODE DeviceTreeNode;
    PLIST_ENTRY  ChildSiblingList;
    TCHAR        Buffer[MAX_PATH];
    DWORD        NumRelations;
    PDEVINST     pDevInst;

    ChildSiblingList = ParentNode ? &ParentNode->ChildSiblingList
                                  : &DeviceTree->ChildSiblingList;

    if (!ParentNode) {
    
        InitializeListHead(ChildSiblingList);
    }

    if (TreeDepth > DeviceTree->TreeDepth) {

        DeviceTree->TreeDepth = TreeDepth;
    }

    do {
        DeviceTreeNode = (PDEVTREENODE)LocalAlloc(LPTR, sizeof(DEVTREENODE));

        if (!DeviceTreeNode) {
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memset(DeviceTreeNode, 0, sizeof(DEVTREENODE));
        InsertTailList(ChildSiblingList, &DeviceTreeNode->SiblingEntry);

        DeviceTreeNode->ParentNode = ParentNode;

        //
        // fill in info about this device instance.
        //
        InitializeListHead(&DeviceTreeNode->ChildSiblingList);
        DeviceTreeNode->DevInst = DeviceInstance;
        DeviceTreeNode->TreeDepth = TreeDepth;

        //
        // Get ClassGUID, and class name.
        //
        Len = sizeof(Buffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                        CM_DRP_CLASSGUID,
                                                        NULL,
                                                        &Buffer,
                                                        &Len,
                                                        0,
                                                        DeviceTree->hMachine
                                                        );


        if (ConfigRet == CR_SUCCESS) {

            pSetupGuidFromString(Buffer, &DeviceTreeNode->ClassGuid);
        }


        //
        // try fetching the class name from the Class GUID.
        // if that fails we will use the devnodes classname
        //
        *Buffer = TEXT('\0');
        Len = SIZECHARS(Buffer);
        ConfigRet = CM_Get_Class_Name_Ex(&DeviceTreeNode->ClassGuid,
                                         Buffer,
                                         &Len,
                                         0,
                                         DeviceTree->hMachine
                                         );

        if (ConfigRet == CR_SUCCESS && *Buffer) {

            Len *= sizeof(TCHAR); // len includes term null.
        }

        else if (ConfigRet != CR_SUCCESS || !*Buffer) {

            *Buffer = TEXT('\0');
            Len = sizeof(Buffer);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(
                                            DeviceInstance,
                                            CM_DRP_CLASS,
                                            NULL,
                                            (PVOID)Buffer,
                                            &Len,
                                            0,
                                            DeviceTree->hMachine
                                            );

            if (ConfigRet != CR_SUCCESS || !*Buffer) {

                Len = 0;
            }
        }

        if (Len) {
            
            DeviceTreeNode->ClassName = (PTCHAR)LocalAlloc(LPTR, Len);

            if (DeviceTreeNode->ClassName) {

                memcpy(DeviceTreeNode->ClassName, Buffer, Len);
            }
        }

        //
        // Drive list
        //
        DeviceTreeNode->DriveList = DevNodeToDriveLetter(DeviceInstance);

        //
        // FriendlyName
        //
        *Buffer = TEXT('\0');
        Len = sizeof(Buffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                        CM_DRP_FRIENDLYNAME,
                                                        NULL,
                                                        Buffer,
                                                        &Len,
                                                        0,
                                                        DeviceTree->hMachine
                                                        );
        if (ConfigRet == CR_SUCCESS && *Buffer) {

            if (DeviceTreeNode->DriveList) {

                Len += lstrlen(DeviceTreeNode->DriveList) * sizeof(TCHAR);
            }

            DeviceTreeNode->FriendlyName = (PTCHAR)LocalAlloc(LPTR, Len);

            if (DeviceTreeNode->FriendlyName) {

                memcpy(DeviceTreeNode->FriendlyName, Buffer, Len);
            
                if (DeviceTreeNode->DriveList) {

                    lstrcat(DeviceTreeNode->FriendlyName, DeviceTreeNode->DriveList);
                }
            }
        }

        else {

            DeviceTreeNode->FriendlyName = NULL;
        }


        //
        // DeviceDesc
        //
        *Buffer = TEXT('\0');
        Len = sizeof(Buffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(
                                        DeviceInstance,
                                        CM_DRP_DEVICEDESC,
                                        NULL,
                                        (PVOID)Buffer,
                                        &Len,
                                        0,
                                        DeviceTree->hMachine
                                        );

        if (ConfigRet == CR_SUCCESS && *Buffer) {

            if (DeviceTreeNode->DriveList) {

                Len += lstrlen(DeviceTreeNode->DriveList) * sizeof(TCHAR);
            }

            DeviceTreeNode->DeviceDesc = (PTCHAR)LocalAlloc(LPTR, Len);

            if (DeviceTreeNode->DeviceDesc) {

                memcpy(DeviceTreeNode->DeviceDesc, Buffer, Len);
            
                if (DeviceTreeNode->DriveList) {

                    lstrcat(DeviceTreeNode->DeviceDesc, DeviceTreeNode->DriveList);
                }
            }
        }

        else {

            DeviceTreeNode->DeviceDesc = NULL;
        }

        //
        // Device capabilities
        //
        Len = sizeof(DeviceTreeNode->Capabilities);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(
                                        DeviceInstance,
                                        CM_DRP_CAPABILITIES,
                                        NULL,
                                        (PVOID)&DeviceTreeNode->Capabilities,
                                        &Len,
                                        0,
                                        DeviceTree->hMachine
                                        );

        if (ConfigRet != CR_SUCCESS) {

            DeviceTreeNode->Capabilities = 0;
        }

        //
        // Status and Problem number
        //
        ConfigRet = CM_Get_DevNode_Status_Ex(&DeviceTreeNode->DevNodeStatus,
                                             &DeviceTreeNode->Problem,
                                             DeviceInstance,
                                             0,
                                             DeviceTree->hMachine
                                             );

        if (ConfigRet != CR_SUCCESS) {

            DeviceTreeNode->DevNodeStatus = 0;
            DeviceTreeNode->Problem = 0;
        }

        //
        // We need to do the following special case. If a device is not started and
        // it doesn't have a problem and it is a RAW device then give it a problem
        // CM_PROB_FAILED_START.
        //
        if (!(DeviceTreeNode->DevNodeStatus & DN_STARTED) &&
            !(DeviceTreeNode->DevNodeStatus & DN_HAS_PROBLEM) &&
            (DeviceTreeNode->Capabilities & CM_DEVCAP_RAWDEVICEOK)) {

            DeviceTreeNode->Problem = CM_PROB_FAILED_START;
        }

        //
        // LocationInformation
        //
        DeviceTreeNode->Location = BuildLocationInformation(DeviceInstance,
                                                            DeviceTree->hMachine
                                                            );


        //
        // Get InstanceId
        //
        *Buffer = TEXT('\0');
        Len = sizeof(Buffer);
        ConfigRet = CM_Get_Device_ID_ExW(DeviceInstance,
                                         Buffer,
                                         Len/sizeof(TCHAR),
                                         0,
                                         DeviceTree->hMachine
                                         );

        if (ConfigRet == CR_SUCCESS && *Buffer) {

            Len = lstrlen(Buffer) * sizeof(TCHAR) + sizeof(TCHAR);
            DeviceTreeNode->InstanceId = (PTCHAR)LocalAlloc(LPTR, Len);

            if (DeviceTreeNode->InstanceId) {

                memcpy(DeviceTreeNode->InstanceId, Buffer, Len);
            }
        }

        else {

            DeviceTreeNode->InstanceId = NULL;
        }


        //
        // Fetch removal and eject relations
        //
        if (ConfigRet == CR_SUCCESS) {

            DeviceTreeNode->EjectRelations = BuildDeviceRelationsList(
                                                 Buffer,
                                                 DeviceTree->hMachine,
                                                 CM_GETIDLIST_FILTER_EJECTRELATIONS,
                                                 &DeviceTreeNode->NumEjectRelations
                                                 );

            DeviceTreeNode->RemovalRelations = BuildDeviceRelationsList(
                                                 Buffer,
                                                 DeviceTree->hMachine,
                                                 CM_GETIDLIST_FILTER_REMOVALRELATIONS,
                                                 &DeviceTreeNode->NumRemovalRelations
                                                 );
        }
            
        //
        // Only get children and siblings if the Recurse value was TRUE
        // otherwise we will just build a DeviceTreeNode structure for 
        // the individual devnode that was passed in.
        //
        // Also, only add rejection and removal relations when Recurse is TRUE,
        // otherwise we get messed up if two devices have removal or ejection
        // relations to each other.
        //
        if (Recurse) {
            
            LPTSTR tempDriveList;

            DeviceTreeNode->bCopy = FALSE;
            
            //
            // Add Ejection relation drive letters
            //
            NumRelations = DeviceTreeNode->NumEjectRelations;
            pDevInst = DeviceTreeNode->EjectRelations;

            while (NumRelations--) {

                if (tempDriveList = DevNodeToDriveLetter(*pDevInst)) {

                    AddChildSiblings(DeviceTree,
                                     DeviceTreeNode,
                                     *pDevInst,
                                     TreeDepth+1,
                                     FALSE
                                     );

                    LocalFree(tempDriveList);
                }
            
                pDevInst++;
            }

            //
            // Add Removal relation drive letters
            //
            NumRelations = DeviceTreeNode->NumRemovalRelations;
            pDevInst = DeviceTreeNode->RemovalRelations;

            while (NumRelations--) {

                if (tempDriveList = DevNodeToDriveLetter(*pDevInst)) {

                    AddChildSiblings(DeviceTree,
                                     DeviceTreeNode,
                                     *pDevInst,
                                     TreeDepth+1,
                                     FALSE
                                     );

                    LocalFree(tempDriveList);
                }
            
                pDevInst++;
            }
        
            //
            // If this devinst has children, then recurse to fill in its
            // child sibling list.
            //
            ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                        DeviceInstance,
                                        0,
                                        DeviceTree->hMachine
                                        );
    
            if (ConfigRet == CR_SUCCESS) {
    
    
                AddChildSiblings(DeviceTree,
                                 DeviceTreeNode,
                                 ChildDeviceInstance,
                                 TreeDepth+1,
                                 TRUE
                                 );
    
            }
    
            //
            // Next sibling ...
            //
    
            ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance,
                                          DeviceInstance,
                                          0,
                                          DeviceTree->hMachine
                                          );
        } else {

            //
            // If Recurse is FALSE then we are making a Copy of an already existing DeviceTreeNode.
            // We do this when a HotPlug Device has a relation that will get removed when it gets
            // removed.  We need to set the bCopy flag because in certain cases the HotPlug device's 
            // relation is also a HotPlug device.  If we don't mark that it is a copy then it will
            // get added to the list of removeable devices twice.
            //
            DeviceTreeNode->bCopy = TRUE;
        }

    } while (Recurse && (ConfigRet == CR_SUCCESS));


    return ERROR_SUCCESS;
}

void
RemoveChildSiblings(
    PDEVICETREE  DeviceTree,
    PLIST_ENTRY  ChildSiblingList
    )
{
    PLIST_ENTRY Next;
    TV_INSERTSTRUCT tvi;
    PDEVTREENODE DeviceTreeNode;

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);


        //
        // recurse to free this nodes ChildSiblingList
        //
        if (!IsListEmpty(&DeviceTreeNode->ChildSiblingList)) {

            RemoveChildSiblings(DeviceTree,
                                &DeviceTreeNode->ChildSiblingList
                                );
        }

        //
        // free up this node and move on to the next sibling.
        //
        Next = Next->Flink;
        RemoveEntryList(&DeviceTreeNode->SiblingEntry);

        if (DeviceTreeNode->ClassName) {

            LocalFree(DeviceTreeNode->ClassName);
        }

        if (DeviceTreeNode->FriendlyName) {

            LocalFree(DeviceTreeNode->FriendlyName);
        }

        if (DeviceTreeNode->DeviceDesc) {

            LocalFree(DeviceTreeNode->DeviceDesc);
        }

        if (DeviceTreeNode->DriveList) {

            LocalFree(DeviceTreeNode->DriveList);
        }

        if (DeviceTreeNode->Location) {

            LocalFree(DeviceTreeNode->Location);
        }

        if (DeviceTreeNode->InstanceId) {

            LocalFree(DeviceTreeNode->InstanceId);
        }

        if (DeviceTreeNode->EjectRelations) {

            LocalFree(DeviceTreeNode->EjectRelations);
        }

        if (DeviceTreeNode->RemovalRelations) {

            LocalFree(DeviceTreeNode->RemovalRelations);
        }

        if (DeviceTree->SelectedTreeNode == DeviceTreeNode) {

            DeviceTree->SelectedTreeNode = NULL;
        }

        memset(DeviceTreeNode, 0, sizeof(DeviceTreeNode));
        LocalFree(DeviceTreeNode);
    }

    return;
}



/*
 *  Retrives the UI Device Name from the DeviceTreeNode.
 *  It is chosen from the following device registry fields
 *  (in order of preference):
 *  - FriendlyName
 *  - DeviceDescription
 *  - ClassName
 *  - Location
 *
 *  if none of the above is available uses "Unknown"
 *
 */
PTCHAR
FetchDeviceName(
     PDEVTREENODE DeviceTreeNode
     )
{
    if (DeviceTreeNode->FriendlyName) {

        return DeviceTreeNode->FriendlyName;
    }

    if (DeviceTreeNode->DeviceDesc) {

        return DeviceTreeNode->DeviceDesc;
    }

    if (DeviceTreeNode->ClassName &&
        !IsEqualGUID(DeviceTreeNode->ClassGuid, GUID_NULL) &&
        !IsEqualGUID(DeviceTreeNode->ClassGuid, GUID_DEVCLASS_UNKNOWN))
    {
        return DeviceTreeNode->ClassName;
    }

   //
   // darn everything failed
   //
   return NULL;
}

BOOL
DisplayChildSiblings(
    PDEVICETREE DeviceTree,
    PLIST_ENTRY ChildSiblingList,
    HTREEITEM   hParentTreeItem,
    BOOL        HotPlugParent
    )
{
    PLIST_ENTRY Next;
    CONFIGRET ConfigRet;
    PDEVTREENODE DeviceTreeNode;
    TV_INSERTSTRUCT tvi;
    BOOL ChildDisplayed = FALSE;

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);

        //
        // - If this device has a hotplug parent and we are in the complex view then
        //   add this device to the tree.
        // - If this device is a hotplug device and it is not a bCopy then add this device
        //   to the tree.  A bCopy device is one where we create another DeviceTreeNode structure
        //   for a device that is a relation of a hotplug device.  The problem is that this relation
        //   itself could be a hotplug device and we don't want to show to copies of it in the UI.
        //
        if (!DeviceTree->HotPlugTree ||
            (HotPlugParent && DeviceTree->ComplexView) ||
            (!DeviceTreeNode->bCopy && IsHotPlugDevice(DeviceTreeNode->DevInst, DeviceTree->hMachine)))
        {
            tvi.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_STATE ;

            if (SetupDiGetClassImageIndex(&DeviceTree->ClassImageList,
                                         &DeviceTreeNode->ClassGuid,
                                         &tvi.item.iImage
                                         ))
            {
                tvi.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            }

            tvi.hParent = hParentTreeItem;
            tvi.hInsertAfter = TVI_LAST;
            tvi.item.iSelectedImage = tvi.item.iImage;
            tvi.item.pszText = FetchDeviceName(DeviceTreeNode);

            if (!tvi.item.pszText) {

                tvi.item.pszText = szUnknown;
            }

            tvi.item.lParam = (LPARAM)DeviceTreeNode;
            tvi.item.stateMask = TVIS_OVERLAYMASK;

            if (DeviceTreeNode->Problem == CM_PROB_DISABLED) {

                tvi.item.state = INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
            
            } else if (DeviceTreeNode->Problem) {

                tvi.item.state = INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
            
            } else {

                tvi.item.state = INDEXTOOVERLAYMASK(0);
            }

            DeviceTreeNode->hTreeItem = TreeView_InsertItem(DeviceTree->hwndTree, &tvi);
            ChildDisplayed = TRUE;
        
        } else {

            DeviceTreeNode->hTreeItem = NULL;
        }

        //
        // recurse to display this nodes ChildSiblingList
        //
        if (!IsListEmpty(&DeviceTreeNode->ChildSiblingList)) {

            if (DisplayChildSiblings(DeviceTree,
                                     &DeviceTreeNode->ChildSiblingList,
                                     DeviceTree->ComplexView ? DeviceTreeNode->hTreeItem
                                                             : hParentTreeItem,
                                     DeviceTreeNode->hTreeItem != NULL
                                     ))
            {
                ChildDisplayed = TRUE;

                //
                // if we are at the root expand the list of child items.
                //
                if (DeviceTreeNode->hTreeItem && DeviceTree->ComplexView) {

                    TreeView_Expand(DeviceTree->hwndTree,
                                    DeviceTreeNode->hTreeItem,
                                    TVE_EXPAND
                                    );
                }
            }
        }

        //
        // and on to the next sibling.
        //
        Next = Next->Flink;

    }

    return ChildDisplayed;
}

void
AddChildRemoval(
    PDEVICETREE DeviceTree,
    PLIST_ENTRY ChildSiblingList
    )
{
    PLIST_ENTRY Next;
    PDEVTREENODE DeviceTreeNode;
    PDEVTREENODE FirstDeviceTreeNode;

    if (IsListEmpty(ChildSiblingList)) {

        return;
    }

    FirstDeviceTreeNode = DeviceTree->ChildRemovalList;

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);

        DeviceTreeNode->NextChildRemoval = FirstDeviceTreeNode->NextChildRemoval;
        FirstDeviceTreeNode->NextChildRemoval = DeviceTreeNode;

        InvalidateTreeItemRect(DeviceTree->hwndTree, DeviceTreeNode->hTreeItem);

        //
        // recurse to Add this node's Childs
        //
        AddChildRemoval(DeviceTree, &DeviceTreeNode->ChildSiblingList);

        //
        // and on to the next sibling.
        //
        Next = Next->Flink;
    }

    return;
}

void
ClearRemovalList(
    PDEVICETREE  DeviceTree

    )
{
    PDEVTREENODE Next;
    PDEVTREENODE DeviceTreeNode;

    DeviceTreeNode = DeviceTree->ChildRemovalList;

    if (!DeviceTreeNode) {

        return;
    }

    do {

        Next = DeviceTreeNode->NextChildRemoval;
        DeviceTreeNode->NextChildRemoval = NULL;

        //
        // force redraw of this item to reset the colors
        //
        InvalidateTreeItemRect(DeviceTree->hwndTree, DeviceTreeNode->hTreeItem);

        DeviceTreeNode = Next;

    } while (DeviceTreeNode != DeviceTree->ChildRemovalList);


    DeviceTree->ChildRemovalList = NULL;
}

PDEVTREENODE
DevTreeNodeByInstanceId(
    PTCHAR InstanceId,
    PLIST_ENTRY ChildSiblingList
    )
{
    PLIST_ENTRY Next;
    PDEVTREENODE DeviceTreeNode;

    if (!InstanceId) {
        return NULL;
        }

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);

        if (DeviceTreeNode->InstanceId &&
            !lstrcmp(DeviceTreeNode->InstanceId, InstanceId))
        {
            return DeviceTreeNode;
        }

        //
        // recurse to display this nodes ChildSiblingList
        //
        if (!IsListEmpty(&DeviceTreeNode->ChildSiblingList)) {

            DeviceTreeNode = DevTreeNodeByInstanceId(InstanceId,
                                                     &DeviceTreeNode->ChildSiblingList
                                                     );
            if (DeviceTreeNode) {

                return DeviceTreeNode;
            }
        }

        //
        // and on to the next sibling.
        //
        Next = Next->Flink;
    }

    return NULL;
}

PDEVTREENODE
DevTreeNodeByDevInst(
    DEVINST DevInst,
    PLIST_ENTRY ChildSiblingList
    )
{
    PLIST_ENTRY Next;
    PDEVTREENODE DeviceTreeNode;

    if (!DevInst) {

        return NULL;
    }

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);

        //
        // We currently assume that we can compare DEVINST from separate
        // "CM_Locate_Devnode" invocations, since a DEVINST is not a real
        // handle, but a pointer to a globalstring table.
        //
        if (DevInst == DeviceTreeNode->DevInst) {

            return DeviceTreeNode;
        }

        //
        // recurse to display this nodes ChildSiblingList
        //
        if (!IsListEmpty(&DeviceTreeNode->ChildSiblingList)) {

            DeviceTreeNode = DevTreeNodeByDevInst(DevInst,
                                                  &DeviceTreeNode->ChildSiblingList
                                                  );
            if (DeviceTreeNode) {

                return DeviceTreeNode;
            }
        }

        //
        // and on to the next sibling.
        //
        Next = Next->Flink;
    }

    return NULL;
}

PDEVTREENODE
TopLevelRemovalNode(
    PDEVICETREE DeviceTree,
    PDEVTREENODE DeviceTreeNode
    )
{
    PDEVTREENODE ParentNode = DeviceTreeNode;

    while (ParentNode) {

        DeviceTreeNode = ParentNode;

        if (IsHotPlugDevice(ParentNode->DevInst, DeviceTree->hMachine)) {
        
            return ParentNode;
        }

        ParentNode = ParentNode->ParentNode;
    }

    return DeviceTreeNode;
}

void
AddEjectToRemoval(
    PDEVICETREE DeviceTree
    )
{
    PDEVTREENODE RelationTreeNode;
    PDEVTREENODE DeviceTreeNode;
    PDEVINST pDevInst;
    USHORT   NumRelations;


    //
    // For each DeviceTreeNode in the removal list
    //   If it has ejection or removal relations, add it to the removal list.
    //
    DeviceTreeNode = DeviceTree->ChildRemovalList;
    if (!DeviceTreeNode) {

        return;
    }


    do {

        //
        // Ejection Relations
        //
        NumRelations = DeviceTreeNode->NumEjectRelations;
        pDevInst = DeviceTreeNode->EjectRelations;

        while (NumRelations--) {

            RelationTreeNode = DevTreeNodeByDevInst(*pDevInst++,
                                                 &DeviceTree->ChildSiblingList
                                                 );

            //
            // If we can't get a DeviceTreeNode for this device, or it is already
            // in the list of devices that will be removed (it's NextChildRemoval)
            // is non-NULL then we won't add this device to the list that will be removed.
            //
            // If this is a drive letter devnode then we have also already added it to 
            // the list so we can skip it.
            //
            if (!RelationTreeNode || 
                RelationTreeNode->NextChildRemoval ||
                RelationTreeNode->DriveList) {

                continue;
            }


            //
            // Insert the new devtreenode
            //
            RelationTreeNode->NextChildRemoval = DeviceTreeNode->NextChildRemoval;
            DeviceTreeNode->NextChildRemoval = RelationTreeNode;
        }

        //
        // Removal Relations
        //
        NumRelations = DeviceTreeNode->NumRemovalRelations;
        pDevInst = DeviceTreeNode->RemovalRelations;

        while (NumRelations--) {

            RelationTreeNode = DevTreeNodeByDevInst(*pDevInst++,
                                                 &DeviceTree->ChildSiblingList
                                                 );

            //
            // If we can't get a DeviceTreeNode for this device, or it is already
            // in the list of devices that will be removed (it's NextChildRemoval)
            // is non-NULL then we won't add this device to the list that will be removed.
            //
            // If this is a drive letter devnode then we have also already added it to 
            // the list so we can skip it.
            //
            if (!RelationTreeNode || 
                RelationTreeNode->NextChildRemoval || 
                RelationTreeNode->DriveList) {

                continue;
            }


            //
            // Insert the new devtreenode
            //
            RelationTreeNode->NextChildRemoval = DeviceTreeNode->NextChildRemoval;
            DeviceTreeNode->NextChildRemoval = RelationTreeNode;
        }


        //
        // And on to the next node.
        //

        DeviceTreeNode = DeviceTreeNode->NextChildRemoval;

    } while (DeviceTreeNode != DeviceTree->ChildRemovalList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__5658ACC5_147F_4E3F_8D69_213F30620FE0__INCLUDED_)
#define AFX_DLLDATAX_H__5658ACC5_147F_4E3F_8D69_213F30620FE0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__5658ACC5_147F_4E3F_8D69_213F30620FE0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\devicecol.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File: devicecol.h
//
//  Description: This header exposes support for device collections.
//
//--------------------------------------------------------------------------

typedef enum {

    CT_SAFE_REMOVAL_NOTIFICATION,
    CT_VETOED_REMOVAL_NOTIFICATION,
    CT_SURPRISE_REMOVAL_WARNING,
    CT_BLOCKED_DRIVER_NOTIFICATION

} COLLECTION_TYPE, *PCOLLECTION_TYPE;

typedef struct {

    LIST_ENTRY  Link;
    TCHAR       DeviceInstanceId[MAX_DEVICE_ID_LEN+1];
    PTSTR       DeviceFriendlyName;
    ULONG       Capabilities;
    GUID        ClassGuid;

} DEVICE_COLLECTION_ENTRY, *PDEVICE_COLLECTION_ENTRY;

typedef struct {

    HMACHINE                hMachine;
    LIST_ENTRY              DeviceListHead;
    INT                     NumDevices;
    BOOL                    DockInList;
    SP_CLASSIMAGELIST_DATA  ClassImageList;

} DEVICE_COLLECTION, *PDEVICE_COLLECTION;


typedef enum {

    VETOED_EJECT = 1,
    VETOED_REMOVAL,
    VETOED_UNDOCK,
    VETOED_STANDBY,
    VETOED_HIBERNATE,
    VETOED_WARM_EJECT,
    VETOED_WARM_UNDOCK

} VETOED_OPERATION;

typedef struct {

    DEVICE_COLLECTION   dc;
    PNP_VETO_TYPE       VetoType;
    VETOED_OPERATION    VetoedOperation;

} VETO_DEVICE_COLLECTION, *PVETO_DEVICE_COLLECTION;

typedef struct {

    DEVICE_COLLECTION   dc;
    BOOL                SuppressSurprise;
    ULONG               DialogTicker;
    ULONG               MaxWaitForDock;

} SURPRISE_WARN_COLLECTION, *PSURPRISE_WARN_COLLECTION;


BOOL
DeviceCollectionBuildFromPipe(
    IN  HANDLE              ReadPipe,
    IN  COLLECTION_TYPE     CollectionType,
    OUT PDEVICE_COLLECTION  DeviceCollection
    );

VOID
DeviceCollectionDestroy(
    IN  PDEVICE_COLLECTION  DeviceCollection
    );

VOID
DeviceCollectionSuppressSurprise(
    IN  PDEVICE_COLLECTION  DeviceCollection
    );

VOID
DeviceCollectionPopulateListView(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  HWND                ListHandle
    );

BOOL
DeviceCollectionGetDockDeviceIndex(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    OUT ULONG              *DockDeviceIndex
    );

BOOL
DeviceCollectionFormatDeviceText(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index,
    IN  PTSTR               FormatString,
    IN  ULONG               BufferCharSize,
    OUT PTSTR               BufferText
    );

BOOL
DeviceCollectionFormatServiceText(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index,
    IN  PTSTR               FormatString,
    IN  ULONG               BufferCharSize,
    OUT PTSTR               BufferText
    );

PTSTR
DeviceCollectionGetDeviceInstancePath(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index
    );

BOOL
DeviceCollectionGetGuid(
    IN     PDEVICE_COLLECTION  DeviceCollection,
    IN OUT LPGUID              Guid,
    IN     ULONG               Index
    );

#if BUBBLES
BOOL
DeviceCollectionCheckIfAllPresent(
    IN  PDEVICE_COLLECTION  DeviceCollection
    );
#endif // BUBBLES

BOOL
DeviceCollectionCheckIfAllRemoved(
    IN  PDEVICE_COLLECTION  DeviceCollection
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\driver.cpp ===
// Driver.cpp : Implementation of CDriver
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "stdafx.h"
#include "blkdrv.h"
#include "Driver.h"

extern "C" {
#include <cfgmgr32.h>
#include "cfgmgrp.h"
}


/////////////////////////////////////////////////////////////////////////////
// CBlockedDrivers


STDMETHODIMP CBlockedDrivers::BlockedDrivers(LPDISPATCH *pCollection)
{
	HRESULT hr;
	CComObject<CDrivers> *pDriversCollection = NULL;
	CComObject<CDriver> *pDriver = NULL;
	GUID guidDB;
    long Count = 0;

    hr = CComObject<CDrivers>::CreateInstance(&pDriversCollection);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pDriversCollection) {
		return E_OUTOFMEMORY;
	}
	pDriversCollection->AddRef();

    CONFIGRET cr;
    ULONG ulLength = 0;

    cr = CMP_GetBlockedDriverInfo(NULL, &ulLength, 0, NULL);

    if ((cr == CR_SUCCESS) && (ulLength == 0)) {
        //
        // No blocked drivers so set Count to zero to create an empty
        // collection.
        //
        Count = 0;

    } else if ((cr == CR_BUFFER_SMALL) && (ulLength > 0)) {
        //
        // Allocate some memory to hold the list of GUIDs
        //
        Count = ulLength/sizeof(GUID);
        m_guidIDs = new GUID[Count];

        if (m_guidIDs == NULL) {
            return E_OUTOFMEMORY;
        }

        cr = CMP_GetBlockedDriverInfo((LPBYTE)m_guidIDs, &ulLength, 0, NULL);

        if (cr != CR_SUCCESS) {
            return E_OUTOFMEMORY;
        }

        //
        // Open a handle to the database so we can get the database GUID.
        //
        if (!SdbGetStandardDatabaseGUID(SDB_DATABASE_MAIN_DRIVERS, &guidDB)) {
            return E_OUTOFMEMORY;
        }
    } else {
        //
        // We encountered an error.
        //
        return E_OUTOFMEMORY;
    }

    if(!pDriversCollection->InitDriverList(Count)) {
        pDriversCollection->Release();
        return E_OUTOFMEMORY;
    }

    for (long i=0; i<Count; i++) {
    	
    	hr = CComObject<CDriver>::CreateInstance(&pDriver);

    	if(FAILED(hr)) {
    		pDriversCollection->Release();
    		return hr;
    	}

    	pDriver->AddRef();

    	if(!pDriver->Init(&guidDB, &(m_guidIDs[i]))) {
            pDriver->Release();
            pDriversCollection->Release();
            return E_OUTOFMEMORY;
        }

        //
        // Add the driver to the list.
        //
        if(!pDriversCollection->SetDriver(i,pDriver)) {
            pDriver->Release();
            pDriversCollection->Release();
            return E_OUTOFMEMORY;
        }

    	pDriver->Release();
    }

    *pCollection = pDriversCollection;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDriver

CDriver::~CDriver()
{
	if(m_Name) {
		SysFreeString(m_Name);
	}

	if(m_Description) {
		SysFreeString(m_Description);
	}

	if (m_Manufacturer) {
		SysFreeString(m_Manufacturer);
	}

	if (m_HelpFile) {
		SysFreeString(m_HelpFile);
	}

    if (m_hAppHelpInfoContext) {
        SdbCloseApphelpInformation(m_hAppHelpInfoContext);
    }
}

STDMETHODIMP CDriver::get_Name(BSTR *pVal)
{
	*pVal = SysAllocStringLen(m_Name,SysStringLen(m_Name));
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


STDMETHODIMP CDriver::get_Description(BSTR *pVal)
{
	*pVal = SysAllocStringLen(m_Description,SysStringLen(m_Description));
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


STDMETHODIMP CDriver::get_Manufacturer(BSTR *pVal)
{
	*pVal = SysAllocStringLen(m_Manufacturer,SysStringLen(m_Manufacturer));
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


STDMETHODIMP CDriver::get_HelpFile(BSTR *pVal)
{
	*pVal = SysAllocStringLen(m_HelpFile,SysStringLen(m_HelpFile));
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

BSTR CDriver::GetValueFromDatabase(
    APPHELPINFORMATIONCLASS InfoClass
    )
{
    DWORD cbSize = 0;

    //
    // Query for the size
    //
    cbSize = SdbQueryApphelpInformation(m_hAppHelpInfoContext,
                                        InfoClass,
                                        NULL,
                                        0
                                        );

    if (cbSize == 0) {
        //
        // value must not exist.
        //
        return NULL;
    }

    PBYTE pBuffer = new BYTE[cbSize];

    if (pBuffer == NULL) {
        return NULL;
    }

    ZeroMemory(pBuffer, cbSize);

    cbSize = SdbQueryApphelpInformation(m_hAppHelpInfoContext,
                                        InfoClass,
                                        (LPVOID)pBuffer,
                                        cbSize
                                        );

    if (cbSize == 0) {
        return NULL;
    }

    BSTR bValue = SysAllocString((const OLECHAR *)pBuffer);

    delete pBuffer;

    return bValue;
}

BOOL CDriver::Init(GUID *pguidDB, GUID *pguidID)
{
	if(!pguidDB || !pguidID) {
		return FALSE;
	}

    HAPPHELPINFOCONTEXT hAppHelpInfoContext = NULL;

    m_hAppHelpInfoContext = SdbOpenApphelpInformation(pguidDB, pguidID);

    if (!m_hAppHelpInfoContext) {
        return FALSE;
    }

    m_Name = GetValueFromDatabase(ApphelpExeName);
	m_Description = GetValueFromDatabase(ApphelpAppName);
	m_Manufacturer = GetValueFromDatabase(ApphelpVendorName);
    m_HelpFile = GetValueFromDatabase(ApphelpHelpCenterURL);

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDrivers

CDrivers::~CDrivers()
{
	long c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			if(pDrivers[c]) {
				pDrivers[c]->Release();
			}
		}
		delete [] pDrivers;
	}
}

STDMETHODIMP CDrivers::get_Count(long *pVal)
{
	*pVal = Count;
	return S_OK;
}

STDMETHODIMP CDrivers::Item(long Index, LPDISPATCH *ppVal)
{
	*ppVal = NULL;
	if(Index<1 || Index > Count) {
		return E_INVALIDARG;
	}
	Index--;
	pDrivers[Index]->AddRef();
	*ppVal = pDrivers[Index];

	return S_OK;
}

STDMETHODIMP CDrivers::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CDriversEnum> *pEnum = NULL;
	hr = CComObject<CDriversEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->InternalCopyDrivers(pDrivers,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}

BOOL CDrivers::InitDriverList(long NewCount)
{
	long c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			if(pDrivers[c]) {
				pDrivers[c]->Release();
			}
		}
		delete [] pDrivers;
	}
	Count = 0;
	pDrivers = new CDriver*[NewCount];
	if(!pDrivers) {
		return NULL;
	}
	for(c=0;c<NewCount;c++) {
		pDrivers[c] = NULL;
	}
	Count = NewCount;
	return TRUE;
}

BOOL CDrivers::SetDriver(long index, CDriver *pDriver)
{
	if((index<0) || (index>=Count)) {
		return FALSE;
	}
	pDriver->AddRef();
	pDrivers[index] = pDriver;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDriversEnum

CDriversEnum::~CDriversEnum()
{
	long c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			pDrivers[c]->Release();
		}
		delete [] pDrivers;
	}
}


HRESULT CDriversEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	CDriver *pDev;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		pDev = pDrivers[Position];
		pDev->AddRef();
		V_VT(&rgVar[fetched]) = VT_DISPATCH;
		V_DISPATCH(&rgVar[fetched]) = pDev;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CDriversEnum::Skip(
                ULONG celt
            )
{
	long remaining = Count-Position;
	if(remaining<(long)celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (long)celt;
		return S_OK;
	}
}

HRESULT CDriversEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CDriversEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CDriversEnum> *pEnum = NULL;
	hr = CComObject<CDriversEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->InternalCopyDrivers(pDrivers,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}


BOOL CDriversEnum::InternalCopyDrivers(CDriver **pArray, long NewCount)
{
	long c;

	if(pDrivers) {
		delete [] pDrivers;
		pDrivers = NULL;
	}

	Count = 0;
	Position = 0;
	pDrivers = new CDriver*[NewCount];
	if(!pDrivers) {
		return FALSE;
	}

	for(c=0;c<NewCount;c++) {
		pArray[c]->AddRef();
		pDrivers[c] = pArray[c];
		if(!pDrivers[c]) {
			Count = c;
			return FALSE;
		}
	}

	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\devicecol.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File: devicecol.c
//
//  Description: This file handles device collections for the hotplug applet.
//
//--------------------------------------------------------------------------

#include "hotplug.h"

BOOL
DeviceCollectionPrepImageList(
    IN  PDEVICE_COLLECTION  DeviceCollection
    );

VOID
DeviceCollectionSwapFakeDockForRealDock(
    IN      PDEVICE_COLLECTION  DeviceCollection,
    IN      PTSTR               InstancePath,
    IN OUT  DEVNODE            *DeviceNode
    );

BOOL
DeviceCollectionBuildFromPipe(
    IN  HANDLE                  ReadPipe,
    IN  COLLECTION_TYPE         CollectionType,
    OUT PDEVICE_COLLECTION      DeviceCollection
    )
{
    PTSTR deviceIds;
    PTSTR instancePath;
    BOOL bDockDeviceInList;
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    DEVNODE deviceNode;
    DWORD capabilities, configFlags, len;
    ULONG bytesReadFromPipe;
    ULONG numDevices, deviceIdsLength;
    BOOL success;
    CONFIGRET configRet;
    TCHAR classGuidString[MAX_GUID_STRING_LEN];
    GUID classGuid;

    //
    // Preinit.
    //
    success = FALSE;
    deviceIds = NULL;
    deviceIdsLength = 0;
    bDockDeviceInList = FALSE;
    numDevices = 0;

    DeviceCollection->hMachine = NULL;
    DeviceCollection->NumDevices = 0;
    DeviceCollection->DockInList = FALSE;
    DeviceCollection->ClassImageList.cbSize = 0;
    InitializeListHead(&DeviceCollection->DeviceListHead);

    //
    // Our callers shouldn't have to handle an internal failure in any of this.
    //
    __try {

        //
        // Read the first ULONG from the pipe, this is the length of all the
        // Device Ids.
        //
        if (!ReadFile(ReadPipe,
                      (LPVOID)&deviceIdsLength,
                      sizeof(ULONG),
                      &bytesReadFromPipe,
                      NULL) ||
            (deviceIdsLength == 0)) {

            goto clean0;
        }

        //
        // Allocate space to hold the DeviceIds
        //
        deviceIds = (PTSTR)LocalAlloc(LPTR, deviceIdsLength);

        if (!deviceIds) {

            goto clean0;
        }

        //
        // Read all of the DeviceIds from the pipe at once
        //
        if (!ReadFile(ReadPipe,
                      (LPVOID)deviceIds,
                      deviceIdsLength,
                      &bytesReadFromPipe,
                      NULL)) {

            goto clean0;
        }

        //
        // Enumerate through the multi-sz list of Device Ids.
        //
        for (instancePath = deviceIds;
             *instancePath;
             instancePath += lstrlen(instancePath) + 1) {

            deviceEntry = (PDEVICE_COLLECTION_ENTRY)LocalAlloc(
                LPTR,
                sizeof(DEVICE_COLLECTION_ENTRY)
                );

            if (!deviceEntry) {
                goto clean0;
            }

            //
            // If we are building a blocked driver list, just put the driver
            // GUID in the DeviceInstanceId field and continue to the next.
            //
            if (CollectionType == CT_BLOCKED_DRIVER_NOTIFICATION) {
                numDevices++;
                lstrcpyn(deviceEntry->DeviceInstanceId, instancePath, MAX_GUID_STRING_LEN);
                pSetupGuidFromString(instancePath, &(deviceEntry->ClassGuid));
                InsertTailList(
                    &DeviceCollection->DeviceListHead,
                    &deviceEntry->Link
                    );
                continue;
            }

            capabilities = 0;
            classGuid = GUID_NULL;
            if (CM_Locate_DevNode(&deviceNode,
                                  instancePath,
                                  CM_LOCATE_DEVNODE_PHANTOM) == CR_SUCCESS) {

                len = sizeof(DWORD);

                configRet = CM_Get_DevNode_Registry_Property_Ex(
                    deviceNode,
                    CM_DRP_CAPABILITIES,
                    NULL,
                    (PVOID)&capabilities,
                    &len,
                    0,
                    DeviceCollection->hMachine
                    );

                if ((configRet == CR_SUCCESS) &&
                    (capabilities & CM_DEVCAP_DOCKDEVICE)) {

                    DeviceCollectionSwapFakeDockForRealDock(
                        DeviceCollection,
                        instancePath,
                        &deviceNode
                        );

                    bDockDeviceInList = TRUE;
                }

                if (CollectionType == CT_SURPRISE_REMOVAL_WARNING) {

                    //
                    // For surprise removal, we are careful to ignore any devices
                    // with the Suppress-Surprise flag set.
                    //
                    len = sizeof(DWORD);
                    configRet = CM_Get_DevNode_Registry_Property_Ex(
                        deviceNode,
                        CM_DRP_CONFIGFLAGS,
                        NULL,
                        (PVOID)&configFlags,
                        &len,
                        0,
                        DeviceCollection->hMachine
                        );

                    if ((configRet == CR_SUCCESS) &&
                        (configFlags & CONFIGFLAG_SUPPRESS_SURPRISE)) {

                        continue;
                    }
                }

                //
                // Get the class GUID string for the device
                //
                len = sizeof(classGuidString);

                configRet = CM_Get_DevNode_Registry_Property(deviceNode,
                                                             CM_DRP_CLASSGUID,
                                                             NULL,
                                                             (PVOID)classGuidString,
                                                             &len,
                                                             0);

                if (configRet == CR_SUCCESS) {

                    pSetupGuidFromString(classGuidString, &classGuid);
                }
            }

            numDevices++;
            lstrcpyn(deviceEntry->DeviceInstanceId, instancePath, MAX_DEVICE_ID_LEN);

            deviceEntry->DeviceFriendlyName = BuildFriendlyName(deviceNode, NULL);
            deviceEntry->Capabilities = capabilities;
            deviceEntry->ClassGuid = classGuid;

            InsertTailList(
                &DeviceCollection->DeviceListHead,
                &deviceEntry->Link
                );
        }

        DeviceCollection->NumDevices = numDevices;
        DeviceCollection->DockInList = bDockDeviceInList;
        DeviceCollectionPrepImageList(DeviceCollection);
        success = TRUE;

clean0:
        ;

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        ASSERT(success == FALSE);
        ASSERT(0);
    }

    if (deviceIds) {

        LocalFree(deviceIds);
    }

    if (!success) {

        DeviceCollectionDestroy(DeviceCollection);
    }

    return success;
}


VOID
DeviceCollectionDestroy(
    IN  PDEVICE_COLLECTION  DeviceCollection
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;

    while(!IsListEmpty(&DeviceCollection->DeviceListHead)) {

        listEntry = RemoveHeadList(&DeviceCollection->DeviceListHead);

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);

        if (deviceEntry->DeviceFriendlyName) {

            LocalFree(deviceEntry->DeviceFriendlyName);
        }

        LocalFree(deviceEntry);
    }

    if (DeviceCollection->ClassImageList.cbSize) {

        SetupDiDestroyClassImageList(&DeviceCollection->ClassImageList);
        DeviceCollection->ClassImageList.cbSize = 0;
    }

    DeviceCollection->NumDevices = 0;
}

VOID
DeviceCollectionSuppressSurprise(
    IN  PDEVICE_COLLECTION  DeviceCollection
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;
    DEVNODE deviceNode;
    CONFIGRET configRet;
    ULONG configFlags, len;

    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);

        configRet = CM_Locate_DevNode(
            &deviceNode,
            deviceEntry->DeviceInstanceId,
            CM_LOCATE_DEVNODE_PHANTOM
            );

        if (configRet == CR_SUCCESS) {

            len = sizeof(ULONG);
            configRet = CM_Get_DevNode_Registry_Property_Ex(
                deviceNode,
                CM_DRP_CONFIGFLAGS,
                NULL,
                (PVOID)&configFlags,
                &len,
                0,
                DeviceCollection->hMachine
                );

            if (configRet != CR_SUCCESS) {

                configFlags = 0;
            }

            configFlags |= CONFIGFLAG_SUPPRESS_SURPRISE;

            CM_Set_DevNode_Registry_Property_Ex(
                deviceNode,
                CM_DRP_CONFIGFLAGS,
                (PVOID)&configFlags,
                sizeof(configFlags),
                0,
                DeviceCollection->hMachine
                );
        }
    }
}

BOOL
DeviceCollectionPrepImageList(
    IN  PDEVICE_COLLECTION  DeviceCollection
    )
{
    if (DeviceCollection->ClassImageList.cbSize != 0) {

        //
        // We already have an image list, no need to reacquire.
        //
        return TRUE;
    }

    DeviceCollection->ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
    if (SetupDiGetClassImageList(&DeviceCollection->ClassImageList)) {

        //
        // Got it.
        //
        return TRUE;
    }

    //
    // Error path, put size back so we don't accidentally free garbage.
    //
    DeviceCollection->ClassImageList.cbSize = 0;
    return FALSE;
}


VOID
DeviceCollectionPopulateListView(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  HWND                ListHandle
    )
{
    int len;
    LV_ITEM lviItem;
    LV_COLUMN lvcCol;
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;
    ULONG lvIndex;
    BOOL haveImageList = FALSE;

    //
    // Select in the correct image list.
    //
    if (DeviceCollectionPrepImageList(DeviceCollection)) {

        ListView_SetImageList(
            ListHandle,
            DeviceCollection->ClassImageList.ImageList,
            LVSIL_SMALL
            );

        haveImageList = TRUE;
    }

    //
    // Insert a column for the class list
    //
    lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
    lvcCol.fmt = LVCFMT_LEFT;
    lvcCol.iSubItem = 0;
    ListView_InsertColumn(ListHandle, 0, (LV_COLUMN FAR *)&lvcCol);

    //
    // Walk the devinst list and add each of them to the listbox.
    //
    lvIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);

        lviItem.mask = LVIF_TEXT;
        lviItem.iItem = lvIndex;
        lviItem.iSubItem = 0;

        //
        // In the worst possible scenario, we will give the user the instance
        // path. This is by design because we put other things into the list
        // sometimes.
        //
        lviItem.pszText = deviceEntry->DeviceInstanceId;
        if (deviceEntry->DeviceFriendlyName) {

            lviItem.pszText = deviceEntry->DeviceFriendlyName;
        }

        if (haveImageList) {

            if (SetupDiGetClassImageIndex(
                &DeviceCollection->ClassImageList,
                &deviceEntry->ClassGuid,
                &lviItem.iImage)
                ) {

                lviItem.mask |= LVIF_IMAGE;
            }
        }

        lvIndex = ListView_InsertItem(ListHandle, &lviItem);

        lvIndex++;
    }
}


BOOL
DeviceCollectionGetDockDeviceIndex(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    OUT ULONG              *DockDeviceIndex
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;
    ULONG index;

    index = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);

        if (!(deviceEntry->Capabilities & CM_DEVCAP_DOCKDEVICE)) {

            index++;
            continue;
        }

        *DockDeviceIndex = index;
        return TRUE;
    }

    *DockDeviceIndex = 0;
    return FALSE;
}


BOOL
DeviceCollectionFormatDeviceText(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index,
    IN  PTSTR               FormatString,
    IN  ULONG               BufferCharSize,
    OUT PTSTR               BufferText
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PTCHAR friendlyName;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {

            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {

        //
        // We walked the entire list and didn't locate our device. Fail now.
        //
        if (BufferCharSize) {

            *BufferText = TEXT('\0');
        }
        return FALSE;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    //
    // In the worst possible scenario, we will give the user the instance
    // path. This is by design because we put other things into the list
    // sometimes.
    //
    friendlyName = deviceEntry->DeviceInstanceId;
    if (deviceEntry->DeviceFriendlyName) {

        friendlyName = deviceEntry->DeviceFriendlyName;
    }

    wnsprintf(BufferText, BufferCharSize, FormatString, friendlyName);
    return TRUE;
}

BOOL
DeviceCollectionFormatServiceText(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index,
    IN  PTSTR               FormatString,
    IN  ULONG               BufferCharSize,
    OUT PTSTR               BufferText
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PTCHAR serviceName;
    TCHAR  szFriendlyName[MAX_SERVICE_NAME_LEN];
    SC_HANDLE hSCManager;
    DWORD dwSize;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    //
    // Walk the list to the entry specified by the index.
    //
    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {

            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {
        //
        // We walked the entire list and didn't locate our service. Fail now.
        //
        if (BufferCharSize) {
            *BufferText = TEXT('\0');
        }
        return FALSE;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    //
    // Our caller knows this collection entry is really a service (either a
    // windows service, or a kernel driver), so the DeviceInstanceId is really
    // the Service name.  Query the SCM for its friendlier DisplayName property.
    //

    serviceName = deviceEntry->DeviceInstanceId;

    *szFriendlyName = TEXT('\0');

    if (serviceName) {

        //
        // Open the Service Control Manager
        //
        hSCManager = OpenSCManager(
            NULL,                     // local machine
            SERVICES_ACTIVE_DATABASE, // SCM database name
            GENERIC_READ              // access type
            );

        if (hSCManager) {

            //
            // Query the SCM for this service's DisplayName.  Note we use a
            // constant buffer of MAX_SERVICE_NAME_LENGTH chars, which should
            // always be large enough because that's what the SCM limits
            // DisplayNames to.  If GetServiceDisplayName fails, we will receive
            // an empty string, which we'll handle below.
            //

            dwSize = MAX_SERVICE_NAME_LEN;

            GetServiceDisplayName(
                hSCManager,           // handle to SCM database
                serviceName,          // service name
                szFriendlyName,       // display name
                &dwSize               // size of display name buffer (in chars)
                );

            CloseServiceHandle(hSCManager);
        }

        //
        // We couldn't retrieve a friendly name for the service, so just use the
        // name we were given.
        //
        if (!*szFriendlyName) {
            lstrcpyn(szFriendlyName,
                     serviceName,
                     min(MAX_SERVICE_NAME_LEN, lstrlen(serviceName)+1));
        }
    }

    wnsprintf(BufferText, BufferCharSize, FormatString, szFriendlyName);
    return TRUE;
}

PTSTR
DeviceCollectionGetDeviceInstancePath(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {
            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {
        //
        // We walked the entire list and didn't locate our device. Fail now.
        //
        return NULL;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    return deviceEntry->DeviceInstanceId;
}

BOOL
DeviceCollectionGetGuid(
    IN     PDEVICE_COLLECTION  DeviceCollection,
    IN OUT LPGUID              Guid,
    IN     ULONG               Index
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {
            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {
        //
        // We walked the entire list and didn't locate our device. Fail now.
        //
        return FALSE;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    memcpy(Guid, &(deviceEntry->ClassGuid), sizeof(GUID));
    return TRUE;
}

VOID
DeviceCollectionSwapFakeDockForRealDock(
    IN      PDEVICE_COLLECTION  DeviceCollection,
    IN      PTSTR               InstancePath,
    IN OUT  DEVNODE            *DeviceNode
    )
{
    DEVNODE fakeDock, realDock;
    ULONG length;
    CONFIGRET configRet;
    PTSTR deviceIdRelations, realDockId, nextEjectionId, hardwareIds, curEntry;

    //
    // Preinit
    //
    fakeDock = *DeviceNode;
    deviceIdRelations = NULL;
    hardwareIds = NULL;

    length = 0;
    configRet = CM_Get_Device_ID_List_Size_Ex(
        &length,
        InstancePath,
        CM_GETIDLIST_FILTER_EJECTRELATIONS,
        DeviceCollection->hMachine
        );

    if ((configRet != CR_SUCCESS) || (!length)) {

        goto Exit;
    }

    deviceIdRelations = (PTSTR)LocalAlloc(LPTR, length*sizeof(TCHAR));

    if (!deviceIdRelations) {

        goto Exit;
    }

    *deviceIdRelations = TEXT('\0');

    configRet = CM_Get_Device_ID_List_Ex(
        InstancePath,
        deviceIdRelations,
        length,
        CM_GETIDLIST_FILTER_EJECTRELATIONS,
        DeviceCollection->hMachine
        );

    if (configRet != CR_SUCCESS) {

        goto Exit;
    }

    if (!(*deviceIdRelations)) {

        //
        // No ejection relations, bail.
        //
        goto Exit;
    }

    //
    // The last relation should be the real dock. Get it.
    //
    nextEjectionId = deviceIdRelations;

    do {

        realDockId = nextEjectionId;
        nextEjectionId += lstrlen(nextEjectionId)+1;

    } while ( *nextEjectionId );

    configRet = CM_Locate_DevNode(
        &realDock,
        realDockId,
        CM_LOCATE_DEVNODE_PHANTOM
        );

    if (configRet != CR_SUCCESS) {

        goto Exit;
    }

    LocalFree(deviceIdRelations);
    deviceIdRelations = NULL;

    //
    // One last check - we need to check the hardware ID's and compatible ID's.
    // We will only do this if we spot a *PNP0C15 amongst them.
    //
    length = 0;
    configRet = CM_Get_DevNode_Registry_Property_Ex(
        realDock,
        CM_DRP_HARDWAREID,
        NULL,
        NULL,
        &length,
        0,
        DeviceCollection->hMachine
        );

    if (configRet != CR_SUCCESS) {

        goto Exit;
    }

    hardwareIds = (PTSTR)LocalAlloc(LPTR, length*sizeof(TCHAR));

    if (!hardwareIds) {

        goto Exit;
    }

    configRet = CM_Get_DevNode_Registry_Property_Ex(
        realDock,
        CM_DRP_HARDWAREID,
        NULL,
        hardwareIds,
        &length,
        0,
        DeviceCollection->hMachine
        );

    if (configRet == CR_SUCCESS) {

        for(curEntry = hardwareIds;
            *curEntry;
            curEntry += lstrlen(curEntry)+1) {

            if (!lstrcmpi(curEntry, TEXT("*PNP0C15"))) {

                //
                // We found an entry - we can successful "rebrand" this dock
                // for the user.
                //
                *DeviceNode = realDock;
                LocalFree(hardwareIds);
                return;
            }
        }
    }

    LocalFree(hardwareIds);
    hardwareIds = NULL;

    //
    // Now try the compatible ID's. This is where we really expect to find the
    // real dock.
    //
    length = 0;
    configRet = CM_Get_DevNode_Registry_Property_Ex(
        realDock,
        CM_DRP_COMPATIBLEIDS,
        NULL,
        NULL,
        &length,
        0,
        DeviceCollection->hMachine
        );

    if (configRet != CR_SUCCESS) {

        goto Exit;
    }

    hardwareIds = (PTSTR)LocalAlloc(LPTR, length*sizeof(TCHAR));

    if (!hardwareIds) {

        goto Exit;
    }

    configRet = CM_Get_DevNode_Registry_Property_Ex(
        realDock,
        CM_DRP_COMPATIBLEIDS,
        NULL,
        hardwareIds,
        &length,
        0,
        DeviceCollection->hMachine
        );

    if (configRet == CR_SUCCESS) {

        for(curEntry = hardwareIds;
            *curEntry;
            curEntry += lstrlen(curEntry)+1) {

            if (!lstrcmpi(curEntry, TEXT("*PNP0C15"))) {

                //
                // We found an entry - we can successful "rebrand" this dock
                // for the user.
                //
                *DeviceNode = realDock;
                LocalFree(hardwareIds);
                return;
            }
        }
    }


Exit:
    if (deviceIdRelations) {

        LocalFree(deviceIdRelations);
    }

    if (hardwareIds) {

        LocalFree(hardwareIds);
    }
}

#if BUBBLES
BOOL
DeviceCollectionCheckIfAllPresent(
    IN  PDEVICE_COLLECTION  DeviceCollection
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;
    DEVNODE deviceNode;

    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);
        //
        // If we can't locate this device normally then it is not a 'live'
        // device, so return FALSE.
        //
        if (CM_Locate_DevNode(&deviceNode,
                              deviceEntry->DeviceInstanceId,
                              0) != CR_SUCCESS) {
            return FALSE;
        }
    }

    //
    // We were able to locate all the devices in this device collection.
    //
    return TRUE;
}
#endif // BUBBLES
BOOL
DeviceCollectionCheckIfAllRemoved(
    IN  PDEVICE_COLLECTION  DeviceCollection
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;
    DEVNODE deviceNode;

    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);
        //
        // If we can locate this device normally then it is a 'live'
        // device, so return FALSE.
        //
        if (CM_Locate_DevNode(&deviceNode,
                              deviceEntry->DeviceInstanceId,
                              0) == CR_SUCCESS) {
            return FALSE;
        }
    }

    //
    // We were able to locate all the devices in this device collection.
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\hardware.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       hardware.h
//
//--------------------------------------------------------------------------

//#define IDH_DISABLEHELP       (DWORD(-1))
#define IDH_hwwizard_devices_list       15301   //  (SysTreeView32)
#define idh_hwwizard_stop               15305   // "&Stop" (Button)
#define idh_hwwizard_display_components 15307   //  "&Display device components" (Button)
#define idh_hwwizard_show_icon          15308   // "Show &icon on taskbar" (Button)
#define idh_hwwizard_properties         15311   //  "&Properties" (Button)
#define idh_hwwizard_close                      15309   //  "&Close" (Button)
#define idh_hwwizard_tshoot     15313   //Troubleshoot button

/*
const DWORD g_a300HelpIDs[]=
{
        301,    IDH_hwwizard_devices_list,      // "" (SysTreeView32)
        304,    IDH_DISABLEHELP,                // "Hardware Devices:" (Static)
        305,    idh_hwwizard_stop,              // "&Stop" (Button)
        307,    idh_hwwizard_display_components,        //  "&Display device components" (Button)
        308,    idh_hwwizard_show_icon,         // "Show &icon on taskbar" (Button)
        311,    idh_hwwizard_properties,        //  "&Properties" (Button)
        8,      idh_hwwizard_close,             //  "&Close" (Button)
        0, 0
};
*/

// "Stop a Hardware device" Dialog Box

//#define IDH_DISABLEHELP       (DWORD(-1))
#define idh_hwwizard_confirm_stop_list  15321   // "" (SysListView32)

/*
const DWORD g_a320HelpIDs[]=
{
        321,    idh_hwwizard_confirm_stop_list, // "" (SysListView32)
        0, 0
};
*/

// "Unsafe Removal of Device" Dialog Box

//#define IDH_DISABLEHELP       (DWORD(-1))
#define idh_hwwizard_unsafe_remove_list  15330  // "" (SysListView32)
/*
const DWORD g_a330HelpIDs[]=
{
        321,    idh_hwwizard_unsafe_remove_list, // "" (SysListView32)
        0, 0
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\driver.h ===
extern "C" {                   
#include <shimdb.h>
}


#ifndef __BLOCKEDDRIVERS_H_
#define __BLOCKEDDRIVERS_H_

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CBlockedDrivers
class ATL_NO_VTABLE CBlockedDrivers : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CBlockedDrivers, &CLSID_BlockedDrivers>,
	public IDispatchImpl<IBlockedDrivers, &IID_IBlockedDrivers, &LIBID_BLOCKDRIVERLib>
{
protected:
    LPGUID m_guidIDs;


public:
    CBlockedDrivers()
	{
        m_guidIDs = NULL;
	}
    ~CBlockedDrivers()
    {
        if (m_guidIDs) {
            delete m_guidIDs;
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_BLKDRV)
DECLARE_NOT_AGGREGATABLE(CBlockedDrivers)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBlockedDrivers)
	COM_INTERFACE_ENTRY(IBlockedDrivers)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IBlockedDrivers
public:
	STDMETHOD(BlockedDrivers)(/*[out,retval]*/ LPDISPATCH * pCollection);
};

#endif //__BLOCKEDDRIVERS_H_


#ifndef __DRIVER_H_
#define __DRIVER_H_

/////////////////////////////////////////////////////////////////////////////
// CDriver
class ATL_NO_VTABLE CDriver : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDriver, &IID_IDriver, &LIBID_BLOCKDRIVERLib>
{
protected:
    HAPPHELPINFOCONTEXT m_hAppHelpInfoContext;
	BSTR m_Name;
	BSTR m_Description;
	BSTR m_Manufacturer;
	BSTR m_HelpFile;
public:
	CDriver()
	{
        m_hAppHelpInfoContext = NULL;
		m_Name = NULL;
		m_Description = NULL;
		m_Manufacturer = NULL;
		m_HelpFile = NULL;
	}
	~CDriver();

DECLARE_NOT_AGGREGATABLE(CDriver)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDriver)
	COM_INTERFACE_ENTRY(IDriver)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDriver
public:
	BOOL Init(GUID *pguidDB, GUID *pguidID);
    BSTR GetValueFromDatabase(APPHELPINFORMATIONCLASS InfoClass);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Manufacturer)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_HelpFile)(/*[out, retval]*/ BSTR *pVal);
};

#endif //__DRIVER_H_


#ifndef __DRIVERS_H_
#define __DRIVERS_H_

/////////////////////////////////////////////////////////////////////////////
// CDrivers
class CDriver;

class ATL_NO_VTABLE CDrivers : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDrivers, &IID_IDrivers, &LIBID_BLOCKDRIVERLib>
{
protected:
	CDriver ** pDrivers;
	long Count;

public:
	BOOL SetDriver(long index,CDriver *pDriver);
	BOOL InitDriverList(long NewCount);

	CDrivers()
	{
		pDrivers = NULL;
		Count = 0;
	}
	~CDrivers();

DECLARE_NOT_AGGREGATABLE(CDrivers)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDrivers)
	COM_INTERFACE_ENTRY(IDrivers)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDrivers
public:
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ long Index,/*[out, retval]*/ LPDISPATCH * ppVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

};

#endif //__DRIVERS_H_


#ifndef __DRIVERSENUM_H_
#define __DRIVERSENUM_H_

/////////////////////////////////////////////////////////////////////////////
// CDriversEnum
class CDriver;

class ATL_NO_VTABLE CDriversEnum : 
	public IDriversEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	CDriver ** pDrivers;
	long Count;
	long Position;

public:
	BOOL InternalCopyDrivers(CDriver **pArray,long Count);

	CDriversEnum()
	{
		pDrivers = NULL;
		Count = 0;
		Position = 0;
	}

	~CDriversEnum();



DECLARE_NOT_AGGREGATABLE(CDriversEnum)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDriversEnum)
	COM_INTERFACE_ENTRY(IDriversEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

// IEnumVARIANT
public:
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif //__DRIVERSENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\hotplug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       hotplug.h
//
//--------------------------------------------------------------------------


//
// 2001/02/01 - Disable support for *both* arrival bubbles and departure
// bubbles (hotplug.dll must be kept in sync here.) This code is disabled for
// beta2, and should be removed afterwards if feedback is positive.
//
// (Note that HotPlugSurpriseWarnW would need to be put back into hotplug.def
//  were this stuff reenabled. Several dialogs would need to be recovered as
//  well...)
//
#define BUBBLES         0
#define UNDOCK_WARNINGS 0

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <cpl.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <devguid.h>
#include <dbt.h>
#include <help.h>
#include <systrayp.h>
#include <shobjidl.h>

extern "C" {
#include <setupapi.h>
#include <spapip.h>
#include <cfgmgr32.h>
#include <shimdb.h>
#include <regstr.h>
}

#include "resource.h"
#include "devicecol.h"

#define STWM_NOTIFYHOTPLUG  STWM_NOTIFYPCMCIA
#define STSERVICE_HOTPLUG   STSERVICE_PCMCIA
#define HOTPLUG_REGFLAG_NOWARN PCMCIA_REGFLAG_NOWARN
#define HOTPLUG_REGFLAG_VIEWALL (PCMCIA_REGFLAG_NOWARN << 1)

#define TIMERID_DEVICECHANGE 4321

#define ARRAYLEN(array)     (sizeof(array) / sizeof(array[0]))


LRESULT CALLBACK
DevTreeDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

LRESULT CALLBACK
RemoveConfirmDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

LRESULT CALLBACK
SurpriseWarnDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

#if BUBBLES
LRESULT CALLBACK
SurpriseWarnBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );
#endif

LRESULT CALLBACK
SafeRemovalBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
DockSafeRemovalBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


extern HMODULE hHotPlug;


typedef struct _DeviceTreeNode {
  LIST_ENTRY SiblingEntry;
  LIST_ENTRY ChildSiblingList;
  PTCHAR     InstanceId;
  PTCHAR     FriendlyName;
  PTCHAR     DeviceDesc;
  PTCHAR     ClassName;
  PTCHAR     DriveList;
  PTCHAR     Location;
  struct _DeviceTreeNode *ParentNode;
  struct _DeviceTreeNode *NextChildRemoval;
  HTREEITEM  hTreeItem;
  DEVINST    DevInst;
  GUID       ClassGuid;
  DWORD      Capabilities;
  int        TreeDepth;
  PDEVINST   EjectRelations;
  USHORT     NumEjectRelations;
  PDEVINST   RemovalRelations;
  USHORT     NumRemovalRelations;
  ULONG      Problem;
  ULONG      DevNodeStatus;
  BOOL       bCopy;
} DEVTREENODE, *PDEVTREENODE;


typedef struct _DeviceTreeData {
   DWORD Size;
   HWND hwndTree;
   HWND hDlg;
   HWND hwndRemove;
   HMACHINE hMachine;
   int  TreeDepth;
   PDEVTREENODE SelectedTreeNode;
   PDEVTREENODE ChildRemovalList;
   LIST_ENTRY ChildSiblingList;
   DEVINST    DevInst;
   PTCHAR     EjectDeviceInstanceId;
   SP_CLASSIMAGELIST_DATA ClassImageList;
   BOOLEAN    ComplexView;
   BOOLEAN    HotPlugTree;
   BOOLEAN    AllowRefresh;
   BOOLEAN    RedrawWait;
   BOOLEAN    RefreshEvent;
   BOOLEAN    HideUI;
   TCHAR      MachineName[MAX_COMPUTERNAME_LENGTH+1];
} DEVICETREE, *PDEVICETREE;

#define SIZECHARS(x) (sizeof((x))/sizeof(TCHAR))


void
OnContextHelp(
  LPHELPINFO HelpInfo,
  PDWORD ContextHelpIDs
  );

//
// from init.c
//
DWORD
WINAPI
HandleVetoedOperation(
    LPWSTR              szCmd,
    VETOED_OPERATION    RemovalVetoType
    );

//
// from devtree.c
//

LONG
AddChildSiblings(
    PDEVICETREE  DeviceTree,
    PDEVTREENODE ParentNode,
    DEVINST      DeviceInstance,
    int          TreeDepth,
    BOOL         Recurse
    );

void
RemoveChildSiblings(
    PDEVICETREE  DeviceTree,
    PLIST_ENTRY  ChildSiblingList
    );

PTCHAR
FetchDeviceName(
     PDEVTREENODE DeviceTreeNode
     );

BOOL
DisplayChildSiblings(
    PDEVICETREE  DeviceTree,
    PLIST_ENTRY  ChildSiblingList,
    HTREEITEM    hParentTreeItem,
    BOOL         RemovableParent
    );


void
AddChildRemoval(
    PDEVICETREE DeviceTree,
    PLIST_ENTRY ChildSiblingList
    );


void
ClearRemovalList(
    PDEVICETREE  DeviceTree
    );


PDEVTREENODE
DevTreeNodeByInstanceId(
    PTCHAR InstanceId,
    PLIST_ENTRY ChildSiblingList
    );

PDEVTREENODE
DevTreeNodeByDevInst(
    DEVINST DevInst,
    PLIST_ENTRY ChildSiblingList
    );


PDEVTREENODE
TopLevelRemovalNode(
    PDEVICETREE DeviceTree,
    PDEVTREENODE DeviceTreeNode
    );

void
AddEjectToRemoval(
    PDEVICETREE DeviceTree
    );

extern TCHAR szUnknown[64];
extern TCHAR szHotPlugFlags[];




//
// notify.c
//
void
OnTimerDeviceChange(
   PDEVICETREE DeviceTree
   );


BOOL
RefreshTree(
   PDEVICETREE DeviceTree
   );



//
// miscutil.c
//

void
SetDlgText(
    HWND hDlg,
    int iControl,
    int nStartString,
    int nEndString
    );


VOID
HotPlugPropagateMessage(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    );


BOOL
RemovalPermission(
   void
   );

int
HPMessageBox(
   HWND hWnd,
   int  IdText,
   int  IdCaption,
   UINT Type
   );


void
InvalidateTreeItemRect(
   HWND hwndTree,
   HTREEITEM  hTreeItem
   );

DWORD
GetHotPlugFlags(
   PHKEY phKey
   );



PTCHAR
BuildFriendlyName(
   DEVINST DevInst,
   HMACHINE hMachine
   );


PTCHAR
BuildLocationInformation(
   DEVINST DevInst,
   HMACHINE hMachine
   );

LPTSTR
DevNodeToDriveLetter(
    DEVINST DevInst
    );

BOOL
IsHotPlugDevice(
    DEVINST DevInst,
    HMACHINE hMachine
    );

BOOL
OpenPipeAndEventHandles(
    LPWSTR szCmd,
    LPHANDLE lphHotPlugPipe,
    LPHANDLE lphHotPlugEvent
    );

BOOL
VetoedRemovalUI(
    IN  PVETO_DEVICE_COLLECTION VetoedRemovalCollection
    );

void
DisplayDriverBlockBalloon(
    IN  PDEVICE_COLLECTION blockedDriverCollection
    );


#if BUBBLES
VOID
OpenGetSurpriseUndockObjects(
    OUT HANDLE  *SurpriseUndockTimer,
    OUT HANDLE  *SurpriseUndockEvent
    );

//
// We suppress bubbles for some period of time after a dock event. Free build,
// ~15 secs, Checked build ~60.
//
#if DBG
#define BUBBLE_SUPPRESSION_TIME     60
#else
#define BUBBLE_SUPPRESSION_TIME     15
#endif
#endif // BUBBLES

#define WUM_EJECTDEVINST  (WM_USER+279)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDI_HOTPLUGICON             100
#define IDI_UNDOCKICON              101
#define IDI_BLOCKDRIVER             102

#define IDR_BLKDRV                  110

#define IDB_UNDOCKBMP               153
#define IDH_HOTPLUGAPPLET           175

#define IDM_DEVICETREE_CONTEXT      200

#define DLG_DEVTREE                 300
#define IDC_DEVICETREE              301

#define IDC_HDWDEVICES              304
#define IDC_STOPDEVICE              305
#define IDC_MACHINENAME             306
#define IDC_VIEWOPTION              307
#define IDC_DEVICEDESC              309
#define IDC_UNDOCK_MESSAGE          310
#define IDC_SUPPRESS_SURPRISE       311

#define IDC_NOHELP1                 500
#define IDC_NOHELP2                 501
#define IDC_NOHELP3                 502
#define IDC_NOHELP4                 503
#define IDC_NOHELP5                 504
#define IDC_PROPERTIES              311
#define DLG_CONFIRMREMOVE           320
#define IDC_REMOVELIST              321
#define IDC_UNDOCK                  405

#define IDC_VETOTEXT                650
#define IDC_REMOVALTEXT             651

#define IDS_HOTPLUGNAME             1000
#define IDS_HOTPLUGINFO             1001

#define IDS_UNKNOWN                 1003
#define IDS_PROB_NONE               1004
#define IDS_PROB_UNKNOWN            1005

#define IDS_LOCATION                1006
#define IDS_LOCATION_NOUINUMBER     1009
#define IDS_UI_NUMBER_DESC_FORMAT   1011
#define IDS_AT                      1012

#define IDS_STOP                    1101
#define IDS_PROPERTIES              1102

#define IDS_TASKBARTEXT             1105
#define IDS_INSTRUCTION             1108

#define IDS_CONFIRM_STOP            1110
#define IDS_HOTPLUG_TITLE           1111
#define IDS_HOTPLUG_REMOVE_INFO     1112

//
//IDS_VETO_BASE must be the same value as the first veto string
//
#define IDS_VETO_BASE                           1200
#define IDS_VETO_UNKNOWN                        1200
#define IDS_VETO_LEGACYDEVICE                   1201
#define IDS_VETO_PENDINGCLOSE                   1202
#define IDS_VETO_WINDOWSAPP                     1203
#define IDS_VETO_WINDOWSSERVICE                 1204
#define IDS_VETO_OUTSTANDINGOPEN                1205
#define IDS_VETO_DEVICE                         1206
#define IDS_VETO_DRIVER                         1207
#define IDS_VETO_ILLEGALDEVICEREQUEST           1208
#define IDS_VETO_INSUFFICIENTPOWER              1209
#define IDS_VETO_NONDISABLEABLE                 1210
#define IDS_VETO_LEGACYDRIVER                   1211
#define IDS_VETO_INSUFFICIENT_RIGHTS            1212
#define IDS_VETO_UNKNOWNWINDOWSAPP              1299

#define IDS_DOCKVETO_BASE                       1500
#define IDS_DOCKVETO_UNKNOWN                    1500
#define IDS_DOCKVETO_LEGACYDEVICE               1501
#define IDS_DOCKVETO_PENDINGCLOSE               1502
#define IDS_DOCKVETO_WINDOWSAPP                 1503
#define IDS_DOCKVETO_WINDOWSSERVICE             1504
#define IDS_DOCKVETO_OUTSTANDINGOPEN            1505
#define IDS_DOCKVETO_DEVICE                     1506
#define IDS_DOCKVETO_DRIVER                     1507
#define IDS_DOCKVETO_ILLEGALDEVICEREQUEST       1508
#define IDS_DOCKVETO_INSUFFICIENTPOWER          1509
#define IDS_DOCKVETO_NONDISABLEABLE             1510
#define IDS_DOCKVETO_LEGACYDRIVER               1511
#define IDS_DOCKVETO_INSUFFICIENT_RIGHTS        1512
#define IDS_DOCKVETO_WARM_EJECT                 1598
#define IDS_DOCKVETO_UNKNOWNWINDOWSAPP          1599

#define IDS_SLEEPVETO_BASE                      1600
#define IDS_SLEEPVETO_UNKNOWN                   1600
#define IDS_SLEEPVETO_LEGACYDEVICE              1601
#define IDS_SLEEPVETO_PENDINGCLOSE              1602
#define IDS_SLEEPVETO_WINDOWSAPP                1603
#define IDS_SLEEPVETO_WINDOWSSERVICE            1604
#define IDS_SLEEPVETO_OUTSTANDINGOPEN           1605
#define IDS_SLEEPVETO_DEVICE                    1606
#define IDS_SLEEPVETO_DRIVER                    1607
#define IDS_SLEEPVETO_ILLEGALDEVICEREQUEST      1608
#define IDS_SLEEPVETO_INSUFFICIENTPOWER         1609
#define IDS_SLEEPVETO_NONDISABLEABLE            1610
#define IDS_SLEEPVETO_LEGACYDRIVER              1611
#define IDS_SLEEPVETO_INSUFFICIENT_RIGHTS       1612
#define IDS_SLEEPVETO_UNKNOWNWINDOWSAPP         1699

#define IDS_HIBERNATEVETO_BASE                  1700
#define IDS_HIBERNATEVETO_UNKNOWN               1700
#define IDS_HIBERNATEVETO_LEGACYDEVICE          1701
#define IDS_HIBERNATEVETO_PENDINGCLOSE          1702
#define IDS_HIBERNATEVETO_WINDOWSAPP            1703
#define IDS_HIBERNATEVETO_WINDOWSSERVICE        1704
#define IDS_HIBERNATEVETO_OUTSTANDINGOPEN       1705
#define IDS_HIBERNATEVETO_DEVICE                1706
#define IDS_HIBERNATEVETO_DRIVER                1707
#define IDS_HIBERNATEVETO_ILLEGALDEVICEREQUEST  1708
#define IDS_HIBERNATEVETO_INSUFFICIENTPOWER     1709
#define IDS_HIBERNATEVETO_NONDISABLEABLE        1710
#define IDS_HIBERNATEVETO_LEGACYDRIVER          1711
#define IDS_HIBERNATEVETO_INSUFFICIENT_RIGHTS   1712
#define IDS_HIBERNATEVETO_UNKNOWNWINDOWSAPP     1799

#define IDS_VETOED_EJECT_TITLE          2254
#define IDS_DRIVELETTERS                2255
#define IDS_DISKDRIVE                   2256
#define IDS_VETOED_REMOVAL_TITLE        2257
#define IDS_VETOED_UNDOCK_TITLE         2258
#define IDS_UNDOCK_COMPLETE_TEXT        2259
#define IDS_REMOVAL_COMPLETE_TEXT       2260
#define IDS_REMOVAL_COMPLETE_TITLE      2261
#define IDS_UNDOCK_COMPLETE_TITLE       2262
#define IDS_UNSAFE_UNDOCK               2263
#define IDS_VETOED_STANDBY_TITLE        2264
#define IDS_VETOED_HIBERNATION_TITLE    2265
#define IDS_BLOCKDRIVER_TITLE           2270
#define IDS_BLOCKDRIVER_MESSAGE         2271
#define IDS_BLOCKDRIVER_FORMAT          2272


#define IDC_STATIC                  -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\hotplug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       hotplug.c
//
//--------------------------------------------------------------------------

#include "HotPlug.h"

TCHAR szUnknown[64];

TCHAR szHotPlugFlags[]=TEXT("HotPlugFlags");
TCHAR HOTPLUG_NOTIFY_CLASS_NAME[] = TEXT("HotPlugNotifyClass");


typedef int
(*PDEVICEPROPERTIES)(
                    HWND hwndParent,
                    LPTSTR MachineName,
                    LPTSTR DeviceID,
                    BOOL ShowDeviceTree
                    );


//
// colors used to highlight removal relationships for selected device
//
COLORREF RemovalImageBkColor;
COLORREF NormalImageBkColor;
COLORREF RemovalTextColor;

HWND g_hwndNotify = NULL;
HMODULE hDevMgr=NULL;
PDEVICEPROPERTIES pDeviceProperties = NULL;

#define IDH_DISABLEHELP         ((DWORD)(-1))
#define IDH_hwwizard_devices_list       15301   //  (SysTreeView32)
#define idh_hwwizard_stop               15305   // "&Stop" (Button)
#define idh_hwwizard_display_components 15307   //  "&Display device components" (Button)
#define idh_hwwizard_properties         15311   //  "&Properties" (Button)
#define idh_hwwizard_close              15309   //  "&Close" (Button)

DWORD UnplugtHelpIDs[] = {
    IDC_STOPDEVICE,    idh_hwwizard_stop,               // "&Stop" (Button)
    IDC_PROPERTIES,    idh_hwwizard_properties,         //  "&Properties" (Button)
    IDC_VIEWOPTION,    idh_hwwizard_display_components, //  "&Display device components" (Button)
    IDC_DEVICETREE,    IDH_hwwizard_devices_list,       // "" (SysTreeView32)
    IDCLOSE,           idh_hwwizard_close,
    IDC_MACHINENAME,   NO_HELP,
    IDC_HDWDEVICES,    NO_HELP,
    IDC_NOHELP1,       NO_HELP,
    IDC_NOHELP2,       NO_HELP,
    IDC_NOHELP3,       NO_HELP,
    IDC_DEVICEDESC,    NO_HELP,
    0,0
};

void
OnRemoveDevice(
              HWND hDlg,
              PDEVICETREE DeviceTree,
              BOOL Eject
              )
{
    DEVINST DeviceInstance;
    CONFIGRET ConfigRet;
    HTREEITEM hTreeItem;
    PDEVTREENODE DeviceTreeNode;
    PTCHAR DeviceName;

    DeviceTreeNode = DeviceTree->ChildRemovalList;

    if (!DeviceTreeNode) {

        return;
    }

    //
    // Confirm with the user that they really want
    // to remove this device and all of its attached devices.
    // The dialog returns standard IDOK, IDCANCEL etc. for results.
    // if anything besides IDOK  don't do anything.
    //

    DialogBoxParam(hHotPlug,
                   MAKEINTRESOURCE(DLG_CONFIRMREMOVE),
                   hDlg,
                   (DLGPROC)RemoveConfirmDlgProc,
                   (LPARAM)DeviceTree
                  );

    return;
}




void
OnTvnSelChanged(
               PDEVICETREE DeviceTree,
               NM_TREEVIEW *nmTreeView
               )
{
    PDEVTREENODE DeviceTreeNode = (PDEVTREENODE)(nmTreeView->itemNew.lParam);
    PTCHAR DeviceName, ProblemText;
    ULONG DevNodeStatus, Problem;
    CONFIGRET ConfigRet;
    TCHAR Buffer[MAX_PATH*2];

    if (DeviceTree->RedrawWait) {

        return;
    }


    //
    // Clear Removal list for previously selected Node
    //
    ClearRemovalList(DeviceTree);


    //
    // Save the selected treenode.
    //
    DeviceTree->SelectedTreeNode = DeviceTreeNode;

    //
    // No device is selected
    //
    if (!DeviceTreeNode) {

        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), FALSE);
        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_PROPERTIES), FALSE);
        SetDlgItemText(DeviceTree->hDlg, IDC_DEVICEDESC, TEXT(""));
        return;
    }

    //
    // reset the text for the selected item
    //
    DeviceName = FetchDeviceName(DeviceTreeNode);

    if (!DeviceName) {

        DeviceName = szUnknown;
    }

    wsprintf(Buffer,
             TEXT("%s %s"),
             DeviceName,
             DeviceTreeNode->Location  ? DeviceTreeNode->Location : TEXT("")
            );

    SetDlgItemText(DeviceTree->hDlg, IDC_DEVICEDESC, Buffer);

    //
    // Turn on the stop\eject button, and set text accordingly.
    //
    ConfigRet = CM_Get_DevNode_Status_Ex(&DevNodeStatus,
                                         &Problem,
                                         DeviceTreeNode->DevInst,
                                         0,
                                         DeviceTree->hMachine
                                        );
    if (ConfigRet != CR_SUCCESS) {

        DevNodeStatus = 0;
        Problem = 0;
    }

    //
    // Any removable (but not surprise removable) device is OK, except
    // if the user already removed it.
    //
    if (Problem != CM_PROB_HELD_FOR_EJECT) {

        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), TRUE);

    } else {

        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), FALSE);
    }

    EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_PROPERTIES), TRUE);

    //
    // reset the overlay icons if device state has changed
    //
    if (DeviceTreeNode->Problem != Problem || DeviceTreeNode->DevNodeStatus != DevNodeStatus) {

        TV_ITEM tv;

        tv.mask = TVIF_STATE;
        tv.stateMask = TVIS_OVERLAYMASK;
        tv.hItem = DeviceTreeNode->hTreeItem;

        if (DeviceTreeNode->Problem == CM_PROB_DISABLED) {

            tv.state = INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);

        } else if (DeviceTreeNode->Problem) {

            tv.state = INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);

        } else {

            tv.state = INDEXTOOVERLAYMASK(0);
        }

        TreeView_SetItem(DeviceTree->hwndTree, &tv);
    }


    //
    // Starting from the TopLevel removal node, build up the removal lists
    //
    DeviceTreeNode = TopLevelRemovalNode(DeviceTree, DeviceTreeNode);

    //
    // Add devices to ChildRemoval list
    //
    DeviceTree->ChildRemovalList = DeviceTreeNode;
    DeviceTreeNode->NextChildRemoval = DeviceTreeNode;
    InvalidateTreeItemRect(DeviceTree->hwndTree, DeviceTreeNode->hTreeItem);
    AddChildRemoval(DeviceTree, &DeviceTreeNode->ChildSiblingList);

    //
    // Add eject amd removal relations
    //
    AddEjectToRemoval(DeviceTree);
}




int
OnCustomDraw(
            HWND hDlg,
            PDEVICETREE DeviceTree,
            LPNMTVCUSTOMDRAW nmtvCustomDraw
            )
{
    PDEVTREENODE DeviceTreeNode = (PDEVTREENODE)(nmtvCustomDraw->nmcd.lItemlParam);

    if (nmtvCustomDraw->nmcd.dwDrawStage == CDDS_PREPAINT) {
        return CDRF_NOTIFYITEMDRAW;
    }

    //
    // If this node is in the Removal list, then do special
    // highlighting.
    //

    if (DeviceTreeNode->NextChildRemoval) {

        //
        // set text color if its not the selected item
        //

        if (DeviceTree->SelectedTreeNode != DeviceTreeNode) {
            nmtvCustomDraw->clrText = RemovalTextColor;
        }

        //
        // Highlight the image-icon background
        //

        ImageList_SetBkColor(DeviceTree->ClassImageList.ImageList,
                             RemovalImageBkColor
                            );
    } else {

        //
        // Normal image-icon background
        //

        ImageList_SetBkColor(DeviceTree->ClassImageList.ImageList,
                             NormalImageBkColor
                            );
    }

    return CDRF_DODEFAULT;
}



void
OnSysColorChange(
                HWND hDlg,
                PDEVICETREE DeviceTree
                )
{
    COLORREF ColorWindow, ColorHighlight;
    BYTE Red, Green, Blue;

    //
    // Fetch the colors used for removal highlighting
    //

    ColorWindow = GetSysColor(COLOR_WINDOW);
    ColorHighlight = GetSysColor(COLOR_HIGHLIGHT);

    Red = (BYTE)(((WORD)GetRValue(ColorWindow) + (WORD)GetRValue(ColorHighlight)) >> 1);
    Green = (BYTE)(((WORD)GetGValue(ColorWindow) + (WORD)GetGValue(ColorHighlight)) >> 1);
    Blue = (BYTE)(((WORD)GetBValue(ColorWindow) + (WORD)GetBValue(ColorHighlight)) >> 1);

    RemovalImageBkColor = RGB(Red, Green, Blue);
    RemovalTextColor = ColorHighlight;
    NormalImageBkColor = ColorWindow;


    // Update the ImageList Background color
    if (DeviceTree->ClassImageList.cbSize) {
        ImageList_SetBkColor(DeviceTree->ClassImageList.ImageList,
                             ColorWindow
                            );
    }
}


void
OnTvnItemExpanding(
                  HWND hDlg,
                  PDEVICETREE DeviceTree,
                  NM_TREEVIEW *nmTreeView

                  )
{
    PDEVTREENODE DeviceTreeNode = (PDEVTREENODE)(nmTreeView->itemNew.lParam);

    //
    // don't allow collapse of root items with children
    //

    if (!DeviceTreeNode->ParentNode &&
        (nmTreeView->action == TVE_COLLAPSE ||
         nmTreeView->action == TVE_COLLAPSERESET ||
         (nmTreeView->action == TVE_TOGGLE &&
          (nmTreeView->itemNew.state & TVIS_EXPANDED))) ) {
        SetDlgMsgResult(hDlg, WM_NOTIFY, TRUE);
    } else {
        SetDlgMsgResult(hDlg, WM_NOTIFY, FALSE);
    }
}




void
OnContextMenu(
             HWND hDlg,
             PDEVICETREE DeviceTree
             )
{
    int IdCmd;
    CONFIGRET ConfigRet;
    POINT ptPopup;
    RECT rect;
    HMENU hMenu;
    PDEVTREENODE DeviceTreeNode;
    TCHAR Buffer[MAX_PATH];

    DeviceTreeNode = DeviceTree->SelectedTreeNode;
    if (!DeviceTreeNode) {
        return;
    }

    TreeView_GetItemRect(DeviceTree->hwndTree,
                         DeviceTreeNode->hTreeItem,
                         &rect,
                         TRUE
                        );

    ptPopup.x = (rect.left+rect.right)/2;
    ptPopup.y = (rect.top+rect.bottom)/2;
    ClientToScreen(DeviceTree->hwndTree, &ptPopup);

    hMenu = CreatePopupMenu();
    if (!hMenu) {
        return;
    }

    //
    // if device is running add stop item
    //
    if (DeviceTreeNode->DevNodeStatus & DN_STARTED) {

        LoadString(hHotPlug,
                   IDS_STOP,
                   Buffer,
                   SIZECHARS(Buffer)
                  );

        AppendMenu(hMenu, MF_STRING, IDC_STOPDEVICE, Buffer);
    }

    //
    // add Properties item (link to device mgr).
    //
    LoadString(hHotPlug,
               IDS_PROPERTIES,
               Buffer,
               SIZECHARS(Buffer)
              );

    AppendMenu(hMenu, MF_STRING, IDC_PROPERTIES, Buffer);

    IdCmd = TrackPopupMenu(hMenu,
                           TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_NONOTIFY,
                           ptPopup.x,
                           ptPopup.y,
                           0,
                           hDlg,
                           NULL
                          );

    DestroyMenu(hMenu);

    if (!IdCmd) {

        return;
    }

    switch (IdCmd) {
    case IDC_STOPDEVICE:
        OnRemoveDevice(hDlg, DeviceTree, FALSE);
        break;

    case IDC_PROPERTIES: {
            if (pDeviceProperties) {
                (*pDeviceProperties)(
                                    hDlg,
                                    DeviceTree->hMachine ? DeviceTree->MachineName : NULL,
                                    DeviceTreeNode->InstanceId,
                                    FALSE
                                    );
            }
        }
        break;
    }

    return;
}

void
OnRightClick(
            HWND hDlg,
            PDEVICETREE DeviceTree,
            NMHDR * nmhdr
            )
{
    DWORD dwPos;
    TV_ITEM tvi;
    TV_HITTESTINFO tvht;
    PDEVTREENODE DeviceTreeNode;

    if (nmhdr->hwndFrom != DeviceTree->hwndTree) {
        return;
    }

    dwPos = GetMessagePos();

    tvht.pt.x = LOWORD(dwPos);
    tvht.pt.y = HIWORD(dwPos);

    ScreenToClient(DeviceTree->hwndTree, &tvht.pt);
    tvi.hItem = TreeView_HitTest(DeviceTree->hwndTree, &tvht);
    if (!tvi.hItem) {
        return;
    }


    tvi.mask = TVIF_PARAM;
    if (!TreeView_GetItem(DeviceTree->hwndTree, &tvi)) {
        return;
    }


    DeviceTreeNode = (PDEVTREENODE)tvi.lParam;
    if (!DeviceTreeNode) {
        return;
    }

    //
    // Make the current right click item, the selected item
    //
    if (DeviceTreeNode != DeviceTree->SelectedTreeNode) {
        TreeView_SelectItem(DeviceTree->hwndTree, DeviceTreeNode->hTreeItem);
    }

}

void
OnViewOptionClicked(
                   HWND hDlg,
                   PDEVICETREE DeviceTree
                   )
{
    BOOL bChecked;
    DWORD HotPlugFlags, NewFlags;
    HKEY hKey = NULL;
    PDEVTREENODE DeviceTreeNode;
    DEVINST DeviceInstance;
    HTREEITEM hTreeItem;
    TV_ITEM TvItem;

    //
    // checked means "show complex view"
    //
    bChecked = IsDlgButtonChecked(hDlg, IDC_VIEWOPTION);


    //
    // Update HotPlugs registry if needed.
    //
    NewFlags = HotPlugFlags = GetHotPlugFlags(&hKey);

    if (hKey) {

        if (bChecked) {

            NewFlags |= HOTPLUG_REGFLAG_VIEWALL;
        } else {

            NewFlags &= ~HOTPLUG_REGFLAG_VIEWALL;
        }

        if (NewFlags != HotPlugFlags) {

            RegSetValueEx(hKey,
                          szHotPlugFlags,
                          0,
                          REG_DWORD,
                          (LPBYTE)&NewFlags,
                          sizeof(NewFlags)
                         );
        }

        if (hKey) {

            RegCloseKey(hKey);
        }
    }

    if (!DeviceTree->ComplexView && bChecked) {

        DeviceTree->ComplexView = TRUE;
    } else if (DeviceTree->ComplexView && !bChecked) {

        DeviceTree->ComplexView = FALSE;
    } else {

        // we are in the correct state, nothing to do.
        return;
    }

    //
    // redraw the entire tree.
    //
    RefreshTree(DeviceTree);

    return;
}

LRESULT
hotplugNotifyWndProc(
                    HWND hWnd,
                    UINT uMsg,
                    WPARAM wParam,
                    LPARAM lParam
                    )
{
    HWND hMainWnd;
    hMainWnd = (HWND)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (uMsg) {
    case WM_CREATE:
        {
            hMainWnd =  (HWND)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)hMainWnd);
            break;
        }

    case WM_DEVICECHANGE:
        {
            if (DBT_DEVNODES_CHANGED == wParam) {
                // While we are in WM_DEVICECHANGE context,
                // no CM apis can be called because it would
                // deadlock. Here, we schedule a timer so that
                // we can handle the message later on.
                SetTimer(hMainWnd, TIMERID_DEVICECHANGE, 1000, NULL);
            }

            break;
        }

    default:
        break;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

BOOL
CreateNotifyWindow(
                  HWND hWnd
                  )
{
    WNDCLASS wndClass;

    if (!GetClassInfo(hHotPlug, HOTPLUG_NOTIFY_CLASS_NAME, &wndClass)) {

        memset(&wndClass, 0, sizeof(wndClass));
        wndClass.lpfnWndProc = hotplugNotifyWndProc;
        wndClass.hInstance = hHotPlug;
        wndClass.lpszClassName = HOTPLUG_NOTIFY_CLASS_NAME;

        if (!RegisterClass(&wndClass)) {

            return FALSE;
        }
    }

    g_hwndNotify = CreateWindowEx(WS_EX_TOOLWINDOW,
                                  HOTPLUG_NOTIFY_CLASS_NAME,
                                  TEXT(""),
                                  WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                                  CW_USEDEFAULT,
                                  CW_USEDEFAULT,
                                  0,
                                  0,
                                  NULL,
                                  NULL,
                                  hHotPlug,
                                  (void *)hWnd
                                 );

    return(NULL != g_hwndNotify);
}

BOOL
InitDevTreeDlgProc(
                  HWND hDlg,
                  PDEVICETREE DeviceTree
                  )
{
    CONFIGRET ConfigRet;
    HWND hwndTree;
    HTREEITEM hTreeItem;
    DEVINST DeviceInstance;
    DWORD HotPlugFlags;
    HICON hIcon;
    HWND hwndParent;

    DeviceTree->AllowRefresh = TRUE;

    CreateNotifyWindow(hDlg);

    hDevMgr = LoadLibrary(TEXT("devmgr.dll"));

    if (hDevMgr) {

        pDeviceProperties = (PDEVICEPROPERTIES)GetProcAddress(hDevMgr, "DevicePropertiesW");
    }

    hIcon = LoadIcon(hHotPlug,MAKEINTRESOURCE(IDI_HOTPLUGICON));
    if (hIcon) {

        SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
    }

    hwndParent = GetParent(hDlg);

    if (hwndParent) {

        SendMessage(hwndParent, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hwndParent, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
    }

    DeviceTree->hDlg     = hDlg;
    DeviceTree->hwndTree = hwndTree = GetDlgItem(hDlg, IDC_DEVICETREE);

    LoadString(hHotPlug,
               IDS_UNKNOWN,
               (PTCHAR)szUnknown,
               SIZECHARS(szUnknown)
              );

    if (DeviceTree->hMachine) {

        SetDlgItemText(hDlg, IDC_MACHINENAME, DeviceTree->MachineName);
    }

    //
    // Disable the Stop button, until an item is selected.
    //
    EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), FALSE);

    EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_PROPERTIES), FALSE);

    // Get the Class Icon Image Lists
    DeviceTree->ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
    if (SetupDiGetClassImageList(&DeviceTree->ClassImageList)) {

        TreeView_SetImageList(hwndTree, DeviceTree->ClassImageList.ImageList, TVSIL_NORMAL);

    } else {

        DeviceTree->ClassImageList.cbSize = 0;
    }

    OnSysColorChange(hDlg, DeviceTree);

    HotPlugFlags = GetHotPlugFlags(NULL);
    if (HotPlugFlags & HOTPLUG_REGFLAG_VIEWALL) {

        DeviceTree->ComplexView = TRUE;
        CheckDlgButton(hDlg, IDC_VIEWOPTION, BST_CHECKED);

    } else {

        DeviceTree->ComplexView = FALSE;
        CheckDlgButton(hDlg, IDC_VIEWOPTION, BST_UNCHECKED);
    }

    //
    // Get the root devnode.
    //
    ConfigRet = CM_Locate_DevNode_Ex(&DeviceTree->DevInst,
                                     NULL,
                                     CM_LOCATE_DEVNODE_NORMAL,
                                     DeviceTree->hMachine
                                    );

    if (ConfigRet != CR_SUCCESS) {

        return FALSE;
    }

    RefreshTree(DeviceTree);


    if (DeviceTree->EjectDeviceInstanceId) {

        DEVINST EjectDevInst;
        PDEVTREENODE DeviceTreeNode;

        //
        // we are removing a specific device, find it
        // and post a message to trigger device removal.
        //
        ConfigRet = CM_Locate_DevNode_Ex(&EjectDevInst,
                                         DeviceTree->EjectDeviceInstanceId,
                                         CM_LOCATE_DEVNODE_NORMAL,
                                         DeviceTree->hMachine
                                        );


        if (ConfigRet != CR_SUCCESS) {

            return FALSE;
        }

        DeviceTreeNode = DevTreeNodeByDevInst(EjectDevInst,
                                              &DeviceTree->ChildSiblingList
                                             );

        if (!DeviceTreeNode) {

            return FALSE;
        }

        TreeView_SelectItem(hwndTree, DeviceTreeNode->hTreeItem);
        PostMessage(hDlg, WUM_EJECTDEVINST, 0, 0);

    } else {

        ShowWindow(hDlg, SW_SHOW);
    }

    return TRUE;
}

void
OnContextHelp(
             LPHELPINFO HelpInfo,
             PDWORD ContextHelpIDs
             )
{
    // Define an array of dword pairs,
    // where the first of each pair is the control ID,
    // and the second is the context ID for a help topic,
    // which is used in the help file.

    if (HelpInfo->iContextType == HELPINFO_WINDOW) {  // must be for a control

        WinHelp((HWND)HelpInfo->hItemHandle,
                TEXT("hardware.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(void *)ContextHelpIDs
               );
    }

}

LRESULT CALLBACK DevTreeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    PDEVICETREE DeviceTree = NULL;
    BOOL Status = TRUE;

    if (message == WM_INITDIALOG) {
        DeviceTree = (PDEVICETREE)lParam;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)DeviceTree);

        if (DeviceTree) {
            InitDevTreeDlgProc(hDlg, DeviceTree);
        }
        return TRUE;
    }

    // retrieve private data from window long (stored there during WM_INITDIALOG)
    DeviceTree = (PDEVICETREE)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message) {
    case WM_DESTROY:
        // Destroy the Notification Window
        if (g_hwndNotify && IsWindow(g_hwndNotify)) {
            DestroyWindow(g_hwndNotify);
            g_hwndNotify = NULL;
        }

        // Clear the DeviceTree
        TreeView_DeleteAllItems(DeviceTree->hwndTree);

        // clean up the class image list.
        if (DeviceTree->ClassImageList.cbSize) {
            SetupDiDestroyClassImageList(&DeviceTree->ClassImageList);
            DeviceTree->ClassImageList.cbSize = 0;
        }

        // Clean up the device tree
        ClearRemovalList(DeviceTree);
        RemoveChildSiblings(DeviceTree, &DeviceTree->ChildSiblingList);

        if (hDevMgr) {
            FreeLibrary(hDevMgr);
            hDevMgr = NULL;
            pDeviceProperties = NULL;
        }
        break;

    case WM_CLOSE:
        SendMessage(hDlg, WM_COMMAND, IDCANCEL, 0L);
        break;

    case WM_COMMAND:
        {
            UINT Control = GET_WM_COMMAND_ID(wParam, lParam);
            UINT Cmd = GET_WM_COMMAND_CMD(wParam, lParam);

            switch (Control) {
            case IDC_VIEWOPTION:
                if (Cmd == BN_CLICKED) {
                    OnViewOptionClicked(hDlg, DeviceTree);
                }
                break;

            case IDC_STOPDEVICE:
                OnRemoveDevice(hDlg, DeviceTree, FALSE);
                break;

            case IDOK:  // enter -> default  to expand\collapse the selected tree node
                if (DeviceTree->SelectedTreeNode) {
                    TreeView_Expand(DeviceTree->hwndTree,
                                    DeviceTree->SelectedTreeNode->hTreeItem, TVE_TOGGLE);
                }

                break;

            case IDC_PROPERTIES:
                if (DeviceTree->SelectedTreeNode && pDeviceProperties) {
                    (*pDeviceProperties)(hDlg,
                                         DeviceTree->hMachine ? DeviceTree->MachineName : NULL,
                                         DeviceTree->SelectedTreeNode->InstanceId, FALSE);
                }
                break;

            case IDCLOSE:
            case IDCANCEL:
                EndDialog(hDlg, IDCANCEL);
                break;
            }

        }
        break;

        // Listen for Tree notifications
    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case TVN_SELCHANGED:
            OnTvnSelChanged(DeviceTree, (NM_TREEVIEW *)lParam);
            break;

        case TVN_ITEMEXPANDING:
            OnTvnItemExpanding(hDlg,DeviceTree,(NM_TREEVIEW *)lParam);
            break;

        case TVN_KEYDOWN:
            {
                TV_KEYDOWN *tvKeyDown = (TV_KEYDOWN *)lParam;

                if (tvKeyDown->wVKey == VK_DELETE) {
                    OnRemoveDevice(hDlg, DeviceTree, TRUE);
                }
            }
            break;

        case NM_CUSTOMDRAW:
            if (IDC_DEVICETREE == ((NMHDR *)lParam)->idFrom) {
                SetDlgMsgResult(hDlg, WM_NOTIFY, OnCustomDraw(hDlg, DeviceTree, (NMTVCUSTOMDRAW *)lParam));
            }
            break;

        case NM_RETURN:
            // we don't get this in a dialog, see IDOK
            break;

        case NM_DBLCLK:
            OnRemoveDevice(hDlg, DeviceTree, TRUE);
            SetDlgMsgResult(hDlg, WM_NOTIFY, TRUE);
            break;

        case NM_RCLICK:
            OnRightClick(hDlg,DeviceTree, (NMHDR *)lParam);
            break;

        default:
            return FALSE;
        }
        break;

    case WUM_EJECTDEVINST:
        OnRemoveDevice(hDlg, DeviceTree, TRUE);
        EndDialog(hDlg, IDCANCEL);
        break;

    case WM_SYSCOLORCHANGE:
        HotPlugPropagateMessage(hDlg, message, wParam, lParam);
        OnSysColorChange(hDlg,DeviceTree);
        break;

    case WM_TIMER:
        if (TIMERID_DEVICECHANGE == wParam) {
            KillTimer(hDlg, TIMERID_DEVICECHANGE);
            DeviceTree->RefreshEvent = TRUE;

            if (DeviceTree->AllowRefresh) {
                OnTimerDeviceChange(DeviceTree);
            }
        }
        break;

    case WM_SETCURSOR:
        if (DeviceTree->RedrawWait || DeviceTree->RefreshEvent) {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 1);
            break;
        }
        return FALSE;

    case WM_CONTEXTMENU:
        //
        // handle kbd- shift-F10, mouse rclick is invoked from NM_RCLICK
        //
        if ((HWND)wParam == DeviceTree->hwndTree) {
            OnContextMenu(hDlg, DeviceTree);
            break;
        } else {
            WinHelp((HWND)wParam, TEXT("hardware.hlp"), HELP_CONTEXTMENU,
                    (DWORD_PTR)(void *)(PDWORD)UnplugtHelpIDs);
        }
        return FALSE;

    case WM_HELP:
        OnContextHelp((LPHELPINFO)lParam, (PDWORD)UnplugtHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\miscutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       miscutil.c
//
//--------------------------------------------------------------------------

#include "HotPlug.h"
#include <initguid.h>
#include <ntddstor.h>
#include <wdmguid.h>

LPTSTR
FormatString(
    LPCTSTR format,
    ...
    )
{
    LPTSTR str = NULL;
    va_list arglist;
    va_start(arglist, format);

    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      format,
                      0,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                      (LPTSTR)&str,
                      0,
                      &arglist
                      ) == 0) {

        str = NULL;
    }

    va_end(arglist);

    return str;
}

PTCHAR
BuildLocationInformation(
    DEVINST DevInst,
    HMACHINE hMachine
    )
{
    CONFIGRET ConfigRet;
    ULONG ulSize;
    DWORD UINumber;
    PTCHAR Location = NULL;
    PTCHAR ParentName;
    DEVINST DevInstParent;
    int BusLocationStringId;
    TCHAR szBuffer[MAX_PATH];
    TCHAR UINumberDescFormat[MAX_PATH];
    TCHAR szFormat[MAX_PATH];
    HKEY hKey;
    DWORD Type = REG_SZ;

    szBuffer[0] = TEXT('\0');


    //
    // We will first get any LocationInformation for the device.  This will either
    // be in the LocationInformationOverride value in the devices driver (software) key
    // or if that is not present we will look for the LocationInformation value in
    // the devices device (hardware) key.
    //
    ulSize = sizeof(szBuffer);
    if (CR_SUCCESS == CM_Open_DevNode_Key_Ex(DevInst,
                                             KEY_READ,
                                             0,
                                             RegDisposition_OpenExisting,
                                             &hKey,
                                             CM_REGISTRY_SOFTWARE,
                                             hMachine
                                             )) {

        RegQueryValueEx(hKey,
                        REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE,
                        NULL,
                        &Type,
                        (const PBYTE)szBuffer,
                        &ulSize
                        );

        RegCloseKey(hKey);
    }

    //
    // If the buffer is empty then we didn't get the LocationInformationOverride
    // value in the device's software key.  So, we will see if their is a
    // LocationInformation value in the device's hardware key.
    //
    if (szBuffer[0] == TEXT('\0')) {

        //
        // Get the LocationInformation for this device.
        //
        ulSize = sizeof(szBuffer);
        CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                            CM_DRP_LOCATION_INFORMATION,
                                            NULL,
                                            szBuffer,
                                            &ulSize,
                                            0,
                                            hMachine
                                            );
    }

    //
    // UINumber has precedence over all other location information so check if this
    // device has a UINumber
    //
    ulSize = sizeof(UINumber);
    if ((CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                             CM_DRP_UI_NUMBER,
                                             NULL,
                                             &UINumber,
                                             &ulSize,
                                             0,
                                             hMachine
                                             ) == CR_SUCCESS) &&
        (ulSize > 0)) {

        UINumberDescFormat[0] = TEXT('\0');
        ulSize = sizeof(UINumberDescFormat);

        //
        // Get the UINumber description format string from the device's parent,
        // if there is one, otherwise default to 'Location %1'
        if ((CM_Get_Parent_Ex(&DevInstParent, DevInst, 0, hMachine) == CR_SUCCESS) &&
            (CM_Get_DevNode_Registry_Property_Ex(DevInstParent,
                                                 CM_DRP_UI_NUMBER_DESC_FORMAT,
                                                 NULL,
                                                 UINumberDescFormat,
                                                 &ulSize,
                                                 0,
                                                 hMachine) == CR_SUCCESS) &&
            *UINumberDescFormat) {

        } else {

            LoadString(hHotPlug, IDS_UI_NUMBER_DESC_FORMAT, UINumberDescFormat, sizeof(UINumberDescFormat)/sizeof(TCHAR));
        }

        //
        // Prepend "at " to the begining of the UINumber string.
        //
        LoadString(hHotPlug, IDS_AT, szFormat, sizeof(szFormat)/sizeof(TCHAR));
        lstrcat(szFormat, UINumberDescFormat);

        //
        // Fill in the UINumber string
        //
        Location = FormatString(szFormat, UINumber);
    }

    //
    // We don't have a UINumber but we do have LocationInformation
    //
    else if (*szBuffer) {

        LoadString(hHotPlug, IDS_LOCATION, szFormat, sizeof(szFormat)/sizeof(TCHAR));
        Location = (PTCHAR)LocalAlloc(LPTR, lstrlen(szBuffer)*sizeof(TCHAR) + sizeof(szFormat) + sizeof(TCHAR));

        if (Location) {

            wsprintf(Location, szFormat, szBuffer);
        }
    }

    //
    // We don't have a UINumber or LocationInformation so we need to get a description
    // of the parent of this device.
    //
    else {

        ConfigRet = CM_Get_Parent_Ex(&DevInstParent, DevInst, 0, hMachine);
        if (ConfigRet == CR_SUCCESS) {

            //
            // Try the registry for FRIENDLYNAME
            //

            ulSize = sizeof(szBuffer);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInstParent,
                                                            CM_DRP_FRIENDLYNAME,
                                                            NULL,
                                                            szBuffer,
                                                            &ulSize,
                                                            0,
                                                            hMachine
                                                            );
            if (ConfigRet != CR_SUCCESS || !*szBuffer) {
                //
                // Try the registry for DEVICEDESC
                //

                ulSize = sizeof(szBuffer);
                ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInstParent,
                                                                CM_DRP_DEVICEDESC,
                                                                NULL,
                                                                szBuffer,
                                                                &ulSize,
                                                                0,
                                                                hMachine
                                                                );
                if (ConfigRet != CR_SUCCESS || !*szBuffer) {

                    GUID ClassGuid;


                    //
                    // Initialize ClassGuid to GUID_NULL
                    //
                    CopyMemory(&ClassGuid,
                               &GUID_NULL,
                               sizeof(GUID)
                               );

                    //
                    // Try the registry for CLASSNAME
                    //
                    ulSize = sizeof(szBuffer);
                    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInstParent,
                                                                    CM_DRP_CLASSGUID,
                                                                    NULL,
                                                                    szBuffer,
                                                                    &ulSize,
                                                                    0,
                                                                    hMachine
                                                                    );


                    if (ConfigRet == CR_SUCCESS) {

                        pSetupGuidFromString(szBuffer, &ClassGuid);
                    }


                    if (!IsEqualGUID(ClassGuid, GUID_NULL) &&
                        !IsEqualGUID(ClassGuid, GUID_DEVCLASS_UNKNOWN))
                    {
                        ulSize = sizeof(szBuffer);
                        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInstParent,
                                                                        CM_DRP_CLASS,
                                                                        NULL,
                                                                        szBuffer,
                                                                        &ulSize,
                                                                        0,
                                                                        hMachine
                                                                        );
                    }

                    else {

                        ConfigRet = ~CR_SUCCESS;
                    }


                }
            }
        }

        if (*szBuffer) {

            LoadString(hHotPlug, IDS_LOCATION_NOUINUMBER, szFormat, sizeof(szFormat)/sizeof(TCHAR));
            Location = (PTCHAR)LocalAlloc(LPTR, lstrlen(szBuffer)*sizeof(TCHAR) + sizeof(szFormat) + sizeof(TCHAR));

            if (Location) {

                wsprintf(Location, szFormat, szBuffer);
            }
        }
    }

    return Location;
}

PTCHAR
BuildFriendlyName(
   DEVINST DevInst,
   HMACHINE hMachine
   )
{
    PTCHAR FriendlyName;
    CONFIGRET ConfigRet;
    ULONG ulSize;
    TCHAR szBuffer[MAX_PATH];

    //
    // Try the registry for FRIENDLYNAME
    //

    ulSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                    CM_DRP_FRIENDLYNAME,
                                                    NULL,
                                                    szBuffer,
                                                    &ulSize,
                                                    0,
                                                    hMachine
                                                    );
    if (ConfigRet != CR_SUCCESS || !*szBuffer) {
        //
        // Try the registry for DEVICEDESC
        //

        ulSize = sizeof(szBuffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                        CM_DRP_DEVICEDESC,
                                                        NULL,
                                                        szBuffer,
                                                        &ulSize,
                                                        0,
                                                        hMachine
                                                        );
        if (ConfigRet != CR_SUCCESS || !*szBuffer) {
            GUID ClassGuid;

            //
            // Initialize ClassGuid to GUID_NULL
            //
            CopyMemory(&ClassGuid,
                       &GUID_NULL,
                       sizeof(GUID)
                       );

            //
            // Try the registry for CLASSNAME
            //

            ulSize = sizeof(szBuffer);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                            CM_DRP_CLASSGUID,
                                                            NULL,
                                                            szBuffer,
                                                            &ulSize,
                                                            0,
                                                            hMachine
                                                            );


            if (ConfigRet == CR_SUCCESS) {

                pSetupGuidFromString(szBuffer, &ClassGuid);
            }


            if (!IsEqualGUID(ClassGuid, GUID_NULL) &&
                !IsEqualGUID(ClassGuid, GUID_DEVCLASS_UNKNOWN))
            {
                ulSize = sizeof(szBuffer);
                ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                                CM_DRP_CLASS,
                                                                NULL,
                                                                szBuffer,
                                                                &ulSize,
                                                                0,
                                                                hMachine
                                                                );
            }

            else {

                ConfigRet = ~CR_SUCCESS;
            }
        }
    }

    if (ConfigRet == CR_SUCCESS && *szBuffer) {

        FriendlyName = (PTCHAR)LocalAlloc(LPTR, ulSize);
        if (FriendlyName) {

            memcpy(FriendlyName, szBuffer, ulSize);
        }
    }

    else {

        FriendlyName = NULL;
    }


    return FriendlyName;
}





/* ----------------------------------------------------------------------
 * SetDlgText - Set Dialog Text Field
 *
 * Concatenates a number of string resources and does a SetWindowText()
 * for a dialog text control.
 *
 * Parameters:
 *
 *  hDlg         - Dialog handle
 *  iControl     - Dialog control ID to receive text
 *  nStartString - ID of first string resource to concatenate
 *  nEndString   - ID of last string resource to concatenate
 *
 *  Note: the string IDs must be consecutive.
 */

void
SetDlgText(HWND hDlg, int iControl, int nStartString, int nEndString)
{
    int     iX;
    TCHAR   szText[MAX_PATH];

    szText[0] = '\0';

    for (iX = nStartString; iX<= nEndString; iX++) {

        LoadString(hHotPlug,
                    iX,
                    szText + lstrlen(szText),
                    sizeof(szText)/sizeof(TCHAR) - lstrlen(szText)
                    );
    }

    if (iControl) {

        SetDlgItemText(hDlg, iControl, szText);
    }

    else {

        SetWindowText(hDlg, szText);
    }

}


VOID
HotPlugPropagateMessage(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    while ((hWnd = GetWindow(hWnd, GW_CHILD))) {

        SendMessage(hWnd, uMessage, wParam, lParam);
    }
}

BOOL
RemovalPermission(
   void
   )
{
    return TRUE;
}


int
HPMessageBox(
   HWND hWnd,
   int  IdText,
   int  IdCaption,
   UINT Type
   )
{
   TCHAR szText[MAX_PATH];
   TCHAR szCaption[MAX_PATH];

   if (LoadString(hHotPlug, IdText, szText, MAX_PATH) &&
       LoadString(hHotPlug, IdCaption, szCaption, MAX_PATH))
   {
       return MessageBox(hWnd, szText, szCaption, Type);
   }

   return IDIGNORE;
}



void
InvalidateTreeItemRect(
    HWND hwndTree,
    HTREEITEM  hTreeItem
    )
{
    RECT rect;

    if (hTreeItem && TreeView_GetItemRect(hwndTree, hTreeItem, &rect, FALSE)) {

        InvalidateRect(hwndTree, &rect, FALSE);
    }
}




DWORD
GetHotPlugFlags(
    PHKEY phKey
    )
{
    HKEY hKey;
    LONG Error;
    DWORD HotPlugFlags, cbHotPlugFlags;

    Error = RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SYSTRAY, &hKey);
    if (Error == ERROR_SUCCESS) {

        cbHotPlugFlags = sizeof(HotPlugFlags);

        Error = RegQueryValueEx(hKey,
                                szHotPlugFlags,
                                NULL,
                                NULL,
                                (LPBYTE)&HotPlugFlags,
                                &cbHotPlugFlags
                                );

        if (phKey) {

            *phKey = hKey;
        }

        else {

            RegCloseKey(hKey);
        }
    }

    if (Error != ERROR_SUCCESS) {

        HotPlugFlags = 0;
    }

    return HotPlugFlags;
}

//
// This function determines if the device is a boot storage device.
// We spit out a warning when users are trying to remove or disable
// a boot storage device(or a device contains a boot storage device).
//
// INPUT:
//  NONE
// OUTPUT:
//  TRUE  if the device is a boot device
//  FALSE if the device is not a boot device
LPTSTR
DevNodeToDriveLetter(
    DEVINST DevInst
    )
{
    ULONG ulSize;
    TCHAR szBuffer[MAX_PATH];
    TCHAR DeviceID[MAX_DEVICE_ID_LEN];
    PTSTR DriveString = NULL;
    PTSTR DeviceInterface = NULL;

    if (CM_Get_Device_ID_Ex(DevInst,
                            DeviceID,
                            sizeof(DeviceID)/sizeof(TCHAR),
                            0,
                            NULL
                            ) != CR_SUCCESS) {

        return FALSE;
    }

    // create a device info list contains all the interface classed
    // exposed by this device.
    ulSize = 0;

    if ((CM_Get_Device_Interface_List_Size(&ulSize,
                                           (LPGUID)&VolumeClassGuid,
                                           DeviceID,
                                           0)  == CR_SUCCESS) &&
        (ulSize > 1) &&
        ((DeviceInterface = (PTSTR)LocalAlloc(LPTR, ulSize*sizeof(TCHAR))) != NULL) &&
        (CM_Get_Device_Interface_List((LPGUID)&VolumeClassGuid,
                                      DeviceID,
                                      DeviceInterface,
                                      ulSize,
                                      0
                                      )  == CR_SUCCESS) &&
        *DeviceInterface)
    {
        PTSTR devicePath, p;
        TCHAR thisVolumeName[MAX_PATH];
        TCHAR enumVolumeName[MAX_PATH];
        TCHAR driveName[4];
        ULONG length;
        BOOL bResult;

        length = lstrlen(DeviceInterface);
        devicePath = (PTSTR)LocalAlloc(LPTR, (length + 1) * sizeof(TCHAR) + sizeof(UNICODE_NULL));

        if (devicePath) {

            lstrcpyn(devicePath, DeviceInterface, length + 1);

            p = wcschr(&(devicePath[4]), TEXT('\\'));

            if (!p) {
                //
                // No refstring is present in the symbolic link; add a trailing
                // '\' char (as required by GetVolumeNameForVolumeMountPoint).
                //
                p = devicePath + length;
                *p = TEXT('\\');
            }

            p++;
            *p = UNICODE_NULL;

            thisVolumeName[0] = UNICODE_NULL;
            bResult = GetVolumeNameForVolumeMountPoint(devicePath,
                                                       thisVolumeName,
                                                       MAX_PATH
                                                       );
            LocalFree(devicePath);

            if (bResult && thisVolumeName[0]) {

                driveName[1] = TEXT(':');
                driveName[2] = TEXT('\\');
                driveName[3] = TEXT('\0');

                for (driveName[0] = TEXT('A'); driveName[0] <= TEXT('Z'); driveName[0]++) {

                    enumVolumeName[0] = TEXT('\0');

                    GetVolumeNameForVolumeMountPoint(driveName, enumVolumeName, MAX_PATH);

                    if (!lstrcmpi(thisVolumeName, enumVolumeName)) {

                        driveName[2] = TEXT('\0');

                        wsprintf(szBuffer, TEXT(" - (%s)"), driveName);

                        DriveString = (PTSTR)LocalAlloc(LPTR, (lstrlen(szBuffer) + 1) * sizeof(TCHAR));

                        if (DriveString) {

                            lstrcpy(DriveString, szBuffer);
                        }

                        break;
                    }
                }
            }
        }
    }

    if (DeviceInterface) {

        LocalFree(DeviceInterface);
    }

    return DriveString;
}

BOOL
IsHotPlugDevice(
    DEVINST DevInst,
    HMACHINE hMachine
    )
/**+

    A device is considered a HotPlug device if the following are TRUE:
        - has Capability CM_DEVCAP_REMOVABLE
        - does NOT have Capability CM_DEVCAP_SURPRISEREMOVALOK
        - does NOT have Capability CM_DEVCAP_DOCKDEVICE
        - must be started (have the DN_STARTED devnode flag)
            - unless has capability CM_DEVCAP_EJECTSUPPORTED
            - or unless has capability CM_DEVCAP_RAWDEVICEOK

Returns:
    TRUE if this is a HotPlug device
    FALSE if this is not a HotPlug device.

-**/
{
    DWORD Capabilities;
    DWORD Len;
    DWORD Status, Problem;

    Capabilities = Status = Problem = 0;

    Len = sizeof(Capabilities);

    if (CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                            CM_DRP_CAPABILITIES,
                                            NULL,
                                            (PVOID)&Capabilities,
                                            &Len,
                                            0,
                                            hMachine) != CR_SUCCESS) {
        return FALSE;
    }

    if (CM_Get_DevNode_Status_Ex(&Status,
                                 &Problem,
                                 DevInst,
                                 0,
                                 hMachine) != CR_SUCCESS) {
        return FALSE;
    }

    //
    // If this device is not removable, or it is surprise removal ok, or
    // it is a dock device, then it is not a hotplug device.
    //
    if ((!(Capabilities & CM_DEVCAP_REMOVABLE)) ||
        (Capabilities & CM_DEVCAP_SURPRISEREMOVALOK) ||
        (Capabilities & CM_DEVCAP_DOCKDEVICE)) {

        return FALSE;
    }

    //
    // We won't consider a device to be a hotplug device if it is not started,
    // unless it is either RAW capabile or an eject capable device.
    //
    // The reason for this test is that a bus driver might set the
    // CM_DEVCAP_REMOVABLE capability, but if the PDO doesn't get loaded then
    // it can't set the CM_DEVCAP_SURPRISEREMOVALOK. So we won't trust the
    // CM_DEVCAP_REMOVABLE capability if the PDO is not started.
    //
    if ((!(Capabilities & CM_DEVCAP_EJECTSUPPORTED)) &&
        (!(Status & DN_STARTED))) {

        return FALSE;
    }

    return TRUE;
}

BOOL
OpenPipeAndEventHandles(
    IN  LPWSTR    szCmd,
    OUT LPHANDLE  lphHotPlugPipe,
    OUT LPHANDLE  lphHotPlugEvent
    )
{
    BOOL   status = FALSE;
    HANDLE hPipe  = INVALID_HANDLE_VALUE;
    HANDLE hEvent = NULL;
    ULONG  ulEventNameSize;
    WCHAR  szEventName[MAX_PATH];
    DWORD  dwBytesRead;


    __try {
        //
        // Validate supplied arguments.
        //
        if (!lphHotPlugPipe || !lphHotPlugEvent) {
            return FALSE;
        }

        //
        // Make sure that a named pipe was specified in the cmd line.
        //
        if(!szCmd || !*szCmd) {
            return FALSE;
        }

        //
        // Wait for the specified named pipe to become available from the server.
        //
        if (!WaitNamedPipe(szCmd,
                           180000) // BUGBUG-2000/07/10-jamesca:  How long should we wait?
                           ) {
            return FALSE;
        }

        //
        // Open a handle to the specified named pipe
        //
        hPipe = CreateFile(szCmd,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);
        if (hPipe == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        //
        // The very first thing in the pipe should be the size of the event name.
        //
        if (ReadFile(hPipe,
                     (LPVOID)&ulEventNameSize,
                     sizeof(ULONG),
                     &dwBytesRead,
                     NULL)) {

            ASSERT(ulEventNameSize != 0);
            if ((ulEventNameSize == 0) ||
                (ulEventNameSize > MAX_PATH)) {
                goto clean0;
            }

            //
            // The next thing in the pipe should be the name of the event.
            //
            if (!ReadFile(hPipe,
                          (LPVOID)&szEventName,
                          ulEventNameSize,
                          &dwBytesRead,
                          NULL)) {
                goto clean0;
            }

        } else {
            if (GetLastError() == ERROR_INVALID_HANDLE) {
                //
                // The handle to the named pipe is not valid.  Make sure we don't
                // try to close it on exit.
                //
                hPipe = INVALID_HANDLE_VALUE;
            }
            goto clean0;
        }

        //
        // Open a handle to the specified named event that we can set and wait on.
        //
        hEvent = OpenEventW(EVENT_MODIFY_STATE | SYNCHRONIZE,
                            FALSE,
                            szEventName);
        if (hEvent == NULL) {
            goto clean0;
        }

        //
        // We should now have valid handles to both the pipe and the event.
        //
        status = TRUE;
        ASSERT((hPipe != INVALID_HANDLE_VALUE) && hEvent);


    clean0:
        ;

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        status = FALSE;
    }

    if (status) {

        *lphHotPlugPipe  = hPipe;
        *lphHotPlugEvent = hEvent;

    } else {

        if (hPipe != INVALID_HANDLE_VALUE) {
            CloseHandle(hPipe);
        }
        if (hEvent) {
            CloseHandle(hEvent);
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\init.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       init.c
//
//--------------------------------------------------------------------------

#include "hotplug.h"

#define HOTPLUG_CLASS_NAME      TEXT("HotPlugClass")

#if BUBBLES
#define SURPRISE_UNDOCK_TIMER   TEXT("Local\\HotPlug_SurpriseUndockTimer_{25126bc2-1ab0-4494-8b6d-e4034cb9c24a}")
#define SURPRISE_UNDOCK_EVENT   TEXT("Local\\HotPlug_SurpriseUndockEvent_{25126bc2-1ab0-4494-8b6d-e4034cb9c24a}")
#endif

void
HotPlugDeviceTree(
   HWND hwndParent,
   PTCHAR MachineName,
   BOOLEAN HotPlugTree
   )
{
    CONFIGRET ConfigRet;
    DEVICETREE DeviceTree;

    memset(&DeviceTree, 0, sizeof(DeviceTree));

    if (MachineName) {

        lstrcpy(DeviceTree.MachineName, MachineName);
        ConfigRet = CM_Connect_Machine(MachineName, &DeviceTree.hMachine);
        if (ConfigRet != CR_SUCCESS) {

            return;
        }
    }

    DeviceTree.HotPlugTree = HotPlugTree;
    InitializeListHead(&DeviceTree.ChildSiblingList);
    DeviceTree.HideUI = FALSE;

    DialogBoxParam(hHotPlug,
                   MAKEINTRESOURCE(DLG_DEVTREE),
                   hwndParent,
                   (DLGPROC)DevTreeDlgProc,
                   (LPARAM)&DeviceTree
                   );

    if (DeviceTree.hMachine) {

        CM_Disconnect_Machine(DeviceTree.hMachine);
    }

    return;
}




BOOL
HotPlugEjectDevice(
   HWND hwndParent,
   PTCHAR DeviceInstanceId
   )

/*++

Routine Description:

   Exported Entry point from hotplug.dll to eject a specific Device Instance.


Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   DeviceInstanceId - Supplies the ID of the device instance.  This is the registry
                      path (relative to the Enum branch) of the device instance key.

Return Value:

   BOOL TRUE for success (does not mean device was ejected or not),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/

{
    DEVNODE DevNode;
    CONFIGRET ConfigRet;

    if ((ConfigRet = CM_Locate_DevNode(&DevNode,
                                       DeviceInstanceId,
                                       0)) == CR_SUCCESS) {

        ConfigRet = CM_Request_Device_Eject_Ex(DevNode,
                                               NULL,
                                               NULL,
                                               0,
                                               0,
                                               NULL);
    }

    SetLastError(ConfigRet);
    return (ConfigRet == CR_SUCCESS);
}

#if UNDOCK_WARNING
DWORD
WINAPI
HotPlugSurpriseWarnW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    HANDLE hPipeRead;
    HANDLE hEvent;
    SURPRISE_WARN_COLLECTION surpriseWarnCollection;
    MSG Msg;
    WNDCLASS wndClass;
    HWND hSurpriseWarnWnd;
    HANDLE hHotplugIconEvent;
    HANDLE hSurpriseUndockEventTimer = NULL;
    HANDLE hSurpriseUndockEvent = NULL;
    LARGE_INTEGER liDelayTime;
    DWORD result, handleCount;
    HANDLE handleArray[2];

    //
    // Open the specified name pipe and event.
    //
    if (!OpenPipeAndEventHandles(szCmd,
                                 &hPipeRead,
                                 &hEvent)) {

        return 1;
    }

    ASSERT((hEvent != NULL) && (hEvent != INVALID_HANDLE_VALUE));
    ASSERT((hPipeRead != NULL) && (hPipeRead != INVALID_HANDLE_VALUE));

    DeviceCollectionBuildFromPipe(
        hPipeRead,
        CT_SURPRISE_REMOVAL_WARNING,
        (PDEVICE_COLLECTION) &surpriseWarnCollection
        );

    surpriseWarnCollection.SuppressSurprise = FALSE;

#if BUBBLES
    //
    // This is how long the bubble should watch for a surprise undock (in secs)
    //
    surpriseWarnCollection.MaxWaitForDock = BUBBLE_SUPPRESSION_TIME;
#endif

    //
    // We are finished reading from the pipe, so close the handle and tell
    // umpnpmgr that it can continue.
    //
    CloseHandle(hPipeRead);
    SetEvent(hEvent);
    CloseHandle(hEvent);

    //
    // If we have any devices then bring up the surprise removal dialog
    //
    if (surpriseWarnCollection.NumDevices) {

#if BUBBLES
        //
        // A surprise removal event occured. Make sure our waitable timer is
        // up.
        //
        OpenGetSurpriseUndockObjects(
            &hSurpriseUndockEventTimer,
            &hSurpriseUndockEvent
            );
#endif // BUBBLES

        if (surpriseWarnCollection.DockInList) {

#if BUBBLES
            //
            // Tell anyone out there waiting to put up their bubble to bail
            //
            if (hSurpriseUndockEvent) {

                PulseEvent(hSurpriseUndockEvent);
            }

            if (hSurpriseUndockEventTimer) {

                //
                // We suppress bubbles for some period of time after a surprise
                // undock event.
                //
                liDelayTime.QuadPart = -10000000 * BUBBLE_SUPPRESSION_TIME;
                SetWaitableTimer(
                    hSurpriseUndockEventTimer,
                    &liDelayTime,
                    0,
                    NULL,
                    NULL,
                    FALSE
                    );
            }
#endif // BUBBLES

            DialogBoxParam(hHotPlug,
                           MAKEINTRESOURCE(DLG_SURPRISEUNDOCK),
                           NULL,
                           SurpriseWarnDlgProc,
                           (LPARAM)&surpriseWarnCollection
                           );
        } else {

#if BUBBLES
            if (!GetClassInfo(hHotPlug, HOTPLUG_CLASS_NAME, &wndClass)) {

                memset(&wndClass, 0, sizeof(wndClass));
                wndClass.lpfnWndProc = SurpriseWarnBalloonProc;
                wndClass.hInstance = hHotPlug;
                wndClass.lpszClassName = HOTPLUG_CLASS_NAME;

                if (!RegisterClass(&wndClass)) {
                    goto clean0;
                }
            }

            //
            // In order to prevent multiple hotplug icons on the tray and multiple surprise
            // removals stepping on each other, we will create a named event that will be
            // used to serialize the surprise removal UI.
            //
            // Note that if we can't create the event for some reason then we will just
            // display the UI.  This might cause multiple hotplug icons, but it is
            // better than not displaying any UI at all.
            //
            hHotplugIconEvent = CreateEvent(NULL,
                                            FALSE,
                                            TRUE,
                                            TEXT("Local\\HotPlug_TaskBarIcon_Event")
                                            );

            if (hHotplugIconEvent) {

                handleArray[0] = hHotplugIconEvent;
                handleArray[1] = hSurpriseUndockEvent;
                handleCount = hSurpriseUndockEvent ? 2 : 1;

                //
                // Wait for our chance to put up a hotplug icon. Note that we
                // will throw our message away if an undock happened recently.
                // hSurpriseUndockEvent tells us we should throw away this
                // UI attempt.
                //
                result = WaitForMultipleObjects(
                    handleCount,
                    handleArray,
                    FALSE,
                    INFINITE
                    );

                if (result == (WAIT_OBJECT_0 + 1)) {

                    //
                    // A surprise undock occured, throw it back.
                    //
                    goto clean0;

                } else if (hSurpriseUndockEventTimer) {

                    result = WaitForSingleObject(hSurpriseUndockEventTimer, 0);

                    if (result == WAIT_TIMEOUT) {

                        //
                        // We missed the kill event but an undock occured
                        // recently. Throw this one back.
                        //
                        SetEvent(hHotplugIconEvent);
                        CloseHandle(hHotplugIconEvent);
                        goto clean0;
                    }
                }
            }

            //
            // First disable the hotplug service so that the icon will go away from
            // the taskbar.  We do this just in case there are any other hotplug devices
            // in the machine.
            //
            SysTray_EnableService(STSERVICE_HOTPLUG, FALSE);

            hSurpriseWarnWnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                                              HOTPLUG_CLASS_NAME,
                                              TEXT(""),
                                              WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              0,
                                              0,
                                              NULL,
                                              NULL,
                                              hHotPlug,
                                              (LPVOID)&surpriseWarnCollection
                                              );

            if (hSurpriseWarnWnd != NULL) {

                while (IsWindow(hSurpriseWarnWnd)) {

                    if (GetMessage(&Msg, NULL, 0, 0)) {

                        TranslateMessage(&Msg);
                        DispatchMessage(&Msg);
                    }
                }
            }

            //
            // Set the Event so the next surprise removal process can go to work
            // and then close the event handle.
            //
            if (hHotplugIconEvent) {

                SetEvent(hHotplugIconEvent);
                CloseHandle(hHotplugIconEvent);
            }

            //
            // Re-enable the hotplug service so that the icon can show back up in
            // the taskbar if we have any hotplug devices.
            //
            SysTray_EnableService(STSERVICE_HOTPLUG, TRUE);
#endif // BUBBLES
        }
    }

#if BUBBLES
clean0:

    if (hSurpriseUndockEventTimer) {

        CloseHandle(hSurpriseUndockEventTimer);
    }

    if (hSurpriseUndockEvent) {

        CloseHandle(hSurpriseUndockEvent);
    }

    if (surpriseWarnCollection.SuppressSurprise) {

        DeviceCollectionSuppressSurprise(
            (PDEVICE_COLLECTION) &surpriseWarnCollection
            );
    }
#endif

    DeviceCollectionDestroy(
        (PDEVICE_COLLECTION) &surpriseWarnCollection
        );
    return 1;
}
#endif // UNDOCK_WARNING


DWORD
WINAPI
HotPlugRemovalVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    return HandleVetoedOperation(szCmd, VETOED_REMOVAL);
}

DWORD
WINAPI
HotPlugEjectVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    return HandleVetoedOperation(szCmd, VETOED_EJECT);
}

DWORD
WINAPI
HotPlugStandbyVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    return HandleVetoedOperation(szCmd, VETOED_STANDBY);
}

DWORD
WINAPI
HotPlugHibernateVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    return HandleVetoedOperation(szCmd, VETOED_HIBERNATE);
}

DWORD
WINAPI
HotPlugWarmEjectVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    return HandleVetoedOperation(szCmd, VETOED_WARM_EJECT);
}

DWORD
WINAPI
HandleVetoedOperation(
    LPWSTR              szCmd,
    VETOED_OPERATION    VetoedOperation
    )
{
    HANDLE hPipeRead;
    HANDLE hEvent;
    PNP_VETO_TYPE vetoType;
    DWORD bytesRead;
    VETO_DEVICE_COLLECTION removalVetoCollection;

    //
    // Open the specified name pipe and event.
    //
    if (!OpenPipeAndEventHandles(szCmd,
                                 &hPipeRead,
                                 &hEvent)) {
        return 1;
    }

    ASSERT((hEvent != NULL) && (hEvent != INVALID_HANDLE_VALUE));
    ASSERT((hPipeRead != NULL) && (hPipeRead != INVALID_HANDLE_VALUE));

    //
    // The first DWORD is the VetoType
    //
    if (!ReadFile(hPipeRead,
                  (LPVOID)&vetoType,
                  sizeof(PNP_VETO_TYPE),
                  &bytesRead,
                  NULL)) {

        CloseHandle(hPipeRead);
        SetEvent(hEvent);
        CloseHandle(hEvent);
        return 1;
    }

    //
    // Now drain all the removal strings. Note that some of them will be
    // device instance paths (definitely the first)
    //
    DeviceCollectionBuildFromPipe(
        hPipeRead,
        CT_VETOED_REMOVAL_NOTIFICATION,
        (PDEVICE_COLLECTION) &removalVetoCollection
        );

    //
    // We are finished reading from the pipe, so close the handle and tell
    // umpnpmgr that it can continue.
    //
    CloseHandle(hPipeRead);
    S