_POLICY_HINT_TYPE   m_rsopHint;
    static unsigned int     m_cfDSObjectName;

    
public:
    
    CRSOPCMenu();
    ~CRSOPCMenu();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IExtencContextMenu methods
    STDMETHODIMP        AddMenuItems(LPDATAOBJECT piDataObject,
                                     LPCONTEXTMENUCALLBACK piCallback,
                                     long * pInsertionAllowed);

    STDMETHODIMP        Command(long lCommandID, LPDATAOBJECT piDataObject);
};


//
// Save console defines
//

#define RSOP_PERSIST_DATA_VERSION    5              // version number in msc file

#define MSC_RSOP_FLAG_DIAGNOSTIC        0x00000001     // Diagnostic mode vs planning mode
#define MSC_RSOP_FLAG_ARCHIVEDATA       0x00000002     // RSoP data is archived also
#define MSC_RSOP_FLAG_SLOWLINK          0x00000004     // Slow link simulation in planning mode
#define MSC_RSOP_FLAG_NOUSER            0x00000008     // Do not display user data
#define MSC_RSOP_FLAG_NOCOMPUTER        0x00000010     // Do not display computer data
#define MSC_RSOP_FLAG_LOOPBACK_REPLACE	0x00000020     // Simulate loopback replace mode.
#define MSC_RSOP_FLAG_LOOPBACK_MERGE	0x00000040     // Simulate loopback merge mode.
#define MSC_RSOP_FLAG_USERDENIED        0x00000080     // User denied access
#define MSC_RSOP_FLAG_COMPUTERDENIED    0x00000100     // Computer denied access

//
// RSOP Command line switches
//

#define RSOP_CMD_LINE_START          TEXT("/Rsop")        // base to all group policy command line switches
#define RSOP_MODE                    TEXT("/RsopMode:")    // Rsop Mode Planning/Logging 0 is logging, 1 is planning
#define RSOP_USER_OU_PREF            TEXT("/RsopUserOu:") // Rsop User OU preference
#define RSOP_COMP_OU_PREF            TEXT("/RsopCompOu:") // Rsop Comp OU Preference
#define RSOP_USER_NAME               TEXT("/RsopUser:")   // Rsop User Name
#define RSOP_COMP_NAME               TEXT("/RsopComp:")   // Rsop Comp Name
#define RSOP_SITENAME                TEXT("/RsopSite:")   // Rsop Site Name
#define RSOP_DCNAME_PREF             TEXT("/RsopDc:")     // DC Name that the tool should connect to


//
// Various flags to decide which prop sheets to show
//

#define RSOP_NOMSC          1
#define RSOPMSC_OVERRIDE    2
#define RSOPMSC_NOOVERRIDE  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\rsoputil.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.cpp
//
//  Contents:   helper functions for working with the RSOP databases
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "rsoputil.h"
#pragma warning(4:4535)     // set_se_translator used w/o /EHa from sdkinc\provexce.h
#include "wbemtime.h"

//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(szData);
    hr = pInst->Put(szParam, 0, &var, 0);
    SysFreeString(var.bstrVal);
    return hr;
}

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, SAFEARRAY * psa)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = psa;
    hr = pInst->Put(szParam, 0, &var, 0);
    return hr;
}

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT uiData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_I4;
    var.lVal = uiData;
    hr = pInst->Put(szParam, 0, &var, 0);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetParameterToNull
//
//  Synopsis:   sets a paramter's value in a WMI parameter list to null
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//
//  History:    03-01-2000  ericflo   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT SetParameterToNull(IWbemClassObject * pInst, TCHAR * szParam)
{
    VARIANT var;
    var.vt = VT_NULL;
    return (pInst->Put(szParam, 0, &var, 0));
}

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_BSTR)
        {
            if (szData)
            {
                delete [] szData;
                szData = NULL;
            }
            szData = new TCHAR[_tcslen(var.bstrVal) + 1];
            if (szData)
            {
                _tcscpy(szData, var.bstrVal);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_BSTR)
        {
            if (bstrData)
            {
                SysFreeString(bstrData);
            }
            bstrData = SysAllocStringLen(var.bstrVal, SysStringLen(var.bstrVal));
            if (NULL == bstrData)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_BOOL)
        {
            fData = var.bVal;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_I4)
        {
            hrData = (HRESULT) var.lVal;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if ((var.vt == VT_UI4) || (var.vt == VT_I4))
        {
            ulData = var.ulVal;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameterBytes(IWbemClassObject * pInst, TCHAR * szParam, LPBYTE * lpData, DWORD *dwDataSize)
{
    VARIANT var;
    HRESULT hr = S_OK;
    SAFEARRAY * pSafeArray;
    DWORD dwSrcDataSize;
    LPBYTE lpSrcData;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt != VT_NULL)
        {
            pSafeArray = var.parray;
            dwSrcDataSize = pSafeArray->rgsabound[0].cElements;
            lpSrcData = (LPBYTE) pSafeArray->pvData;

            *lpData = (LPBYTE)LocalAlloc (LPTR, dwSrcDataSize);

            if (!(*lpData))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            CopyMemory (*lpData, lpSrcData, dwSrcDataSize);
            *dwDataSize = dwSrcDataSize;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}


HRESULT WINAPI ImportRSoPData (LPOLESTR lpNameSpace, LPOLESTR lpFileName)
{
    IMofCompiler * pIMofCompiler;
    HRESULT hr;
    WBEM_COMPILE_STATUS_INFO info;


    //
    // Check args
    //

    if (!lpNameSpace)
    {
        DebugMsg((DM_WARNING, TEXT("LoadNameSpaceFromFile: Null namespace arg")));
        return E_INVALIDARG;
    }

    if (!lpFileName)
    {
        DebugMsg((DM_WARNING, TEXT("LoadNameSpaceFromFile: Null filename arg")));
        return E_INVALIDARG;
    }


    //
    // Create an instance of the mof compiler
    //

    hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER,
                          IID_IMofCompiler, (LPVOID *) &pIMofCompiler);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("LoadNameSpaceFromFile: CoCreateInstance failed with 0x%x"), hr));
        return hr;
    }

    //
    // Compile the file
    //

    ZeroMemory (&info, sizeof(info));
    hr = pIMofCompiler->CompileFile (lpFileName, lpNameSpace, NULL, NULL, NULL,
                                     0, 0, 0, &info);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("LoadNameSpaceFromFile: CompileFile failed with 0x%x"), hr));
    }


    pIMofCompiler->Release();

    return hr;
}

BOOL WriteMofFile (HANDLE hFile, LPTSTR lpData)
{
    DWORD dwBytesWritten, dwAnsiDataSize, dwByteCount, dwLFCount = 0;
    LPSTR lpAnsiData;
    LPTSTR lpTemp, lpRealData, lpDest;


    //
    // The lpData argument contains linefeed characters only.  We need to convert
    // these to CR LF characters.  Loop through the data to determine how many LFs
    // need to be converted.
    //

    lpTemp = lpData;

    while (*lpTemp)
    {
        if (*lpTemp == 0x0A)
        {
            dwLFCount++;
        }

        lpTemp++;
    }


    //
    // Allocate a new buffer to hold the string plus CR characters
    //

    lpRealData = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpData) + dwLFCount + 1) * sizeof(TCHAR));

    if (!lpRealData)
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: LocalAlloc failed with %d"), GetLastError()));
        return FALSE;
    }


    //
    // Copy the string replacing LF with CRLF as we find them
    //

    lpDest = lpRealData;
    lpTemp = lpData;

    while (*lpTemp)
    {
        if (*lpTemp == 0x0A)
        {
            *lpDest = 0x0D;
            lpDest++;
        }

        *lpDest = *lpTemp;

        lpDest++;
        lpTemp++;
    }


    //
    // Allocate a buffer to hold the ANSI data
    //

    dwAnsiDataSize = lstrlen (lpRealData) * 2;

    lpAnsiData = (LPSTR) LocalAlloc (LPTR, dwAnsiDataSize);

    if (!lpAnsiData)
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: LocalAlloc failed with %d"), GetLastError()));
        LocalFree (lpRealData);
        return FALSE;
    }


    //
    // Convert the buffer
    //

    dwByteCount = (DWORD) WideCharToMultiByte (CP_ACP, 0, lpRealData, lstrlen(lpRealData), lpAnsiData, dwAnsiDataSize, NULL, NULL);

    LocalFree (lpRealData);

    if (!dwByteCount)
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: WriteFile failed with %d"), GetLastError()));
        LocalFree (lpAnsiData);
        return FALSE;
    }


    //
    // Write the mof description to the file
    //

    if (!WriteFile (hFile, lpAnsiData, dwByteCount, &dwBytesWritten, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: WriteFile failed with %d"), GetLastError()));
        LocalFree (lpAnsiData);
        return FALSE;
    }

    LocalFree (lpAnsiData);


    //
    // Make sure it was all written to the file
    //

    if (dwByteCount != dwBytesWritten)
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: Failed to write the correct amount of data.")));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    return TRUE;
}

HRESULT EnumInstances (IWbemServices * pIWbemServices, BSTR pClassName, HANDLE hFile)
{
    IWbemClassObject *pObjects[2], *pObject;
    IEnumWbemClassObject *pEnum = NULL;
    ULONG ulCount;
    HRESULT hr;
    BSTR bstrClass;
    DWORD dwError;


    //
    // Create the instance enumerator
    //

    hr = pIWbemServices->CreateInstanceEnum (pClassName, WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("EnumInstances: CreateInstanceEnum failed with 0x%x"), hr));
        return hr;
    }


    //
    // Walk through the list
    //

    while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulCount) == S_OK)
    {
        pObject = pObjects[0];


        //
        // Get the mof description of this class
        //

        hr = pObject->GetObjectText (0, &bstrClass);

        pObject->Release();

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("EnumInstances: GetObjectText failed with 0x%x"), hr));
            pEnum->Release();
            return hr;
        }


        //
        // Write the mof description to the file
        //

        if (!WriteMofFile (hFile, bstrClass))
        {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("EnumInstances: WriteMofFile failed with %d"), dwError));
            SysFreeString (bstrClass);
            pEnum->Release();
            return HRESULT_FROM_WIN32(dwError);
        }

        SysFreeString (bstrClass);
    }

    pEnum->Release();


    return hr;
}

HRESULT EnumNameSpace (IWbemServices * pIWbemServices, HANDLE hFile)
{
    IWbemClassObject *pObjects[2], *pObject;
    IEnumWbemClassObject *pEnum = NULL;
    ULONG ulCount;
    HRESULT hr;
    VARIANT var;
    BSTR bstrClass;
    DWORD dwError;


    //
    // Create the class enumerator
    //

    hr = pIWbemServices->CreateClassEnum (NULL, WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("EnumNameSpace: CreateClassEnum failed with 0x%x"), hr));
        return hr;
    }


    //
    // Walk through the list
    //

    while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulCount) == S_OK)
    {
        pObject = pObjects[0];


        //
        // Get the class name
        //

        hr = pObject->Get (TEXT("__CLASS"), 0, &var, NULL, NULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("EnumNameSpace: Failed to get class name with 0x%x"), hr));
            pEnum->Release();
            return hr;
        }


        //
        // Check if this is a system class.  System classes start with "_"
        //

        if (var.bstrVal[0] != TEXT('_'))
        {

            //
            // Get the mof description of this class
            //

            hr = pObject->GetObjectText (0, &bstrClass);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("EnumNameSpace: GetObjectText failed with 0x%x"), hr));
                VariantClear (&var);
                pEnum->Release();
                return hr;
            }


            //
            // Write the mof description to the file
            //

            if (!WriteMofFile (hFile, bstrClass))
            {
                dwError = GetLastError();
                DebugMsg((DM_WARNING, TEXT("EnumNameSpace: WriteMofFile failed with %d"), dwError));
                SysFreeString (bstrClass);
                VariantClear (&var);
                pEnum->Release();
                return HRESULT_FROM_WIN32(dwError);
            }

            SysFreeString (bstrClass);


            //
            // Now enumerate the instances of this class
            //

            hr = EnumInstances (pIWbemServices, var.bstrVal, hFile);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("EnumNameSpace: EnumInstances failed with 0x%x"), hr));
                VariantClear (&var);
                pEnum->Release();
                return hr;
            }
        }

        VariantClear (&var);
    }

    pEnum->Release();


    return hr;
}

HRESULT WINAPI ExportRSoPData (LPTSTR lpNameSpace, LPTSTR lpFileName)
{
    IWbemLocator *pIWbemLocator;
    IWbemServices *pIWbemServices;
    HANDLE hFile;
    HRESULT hr;
    DWORD dwError;


    //
    // Open the data file
    //

    hFile = CreateFile (lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: CreateFile for %s failed with %d"), lpFileName, dwError));
        return HRESULT_FROM_WIN32(dwError);
    }


    //
    // Create a locater instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: CoCreateInstance failed with 0x%x"), hr));
        CloseHandle (hFile);
        return hr;
    }


    //
    // Connect to the server
    //

    hr = pIWbemLocator->ConnectServer(lpNameSpace, NULL, NULL, 0, 0, NULL, NULL, &pIWbemServices);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: ConnectServer to %s failed with 0x%x"), lpNameSpace, hr));
        pIWbemLocator->Release();
        CloseHandle (hFile);
        return hr;
    }


    //
    // Enumerate the classes and instances
    //

    hr = EnumNameSpace (pIWbemServices, hFile);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: EnumNameSpace failed with 0x%x"), hr));
    }

    CloseHandle (hFile);


    pIWbemServices->Release();
    pIWbemLocator->Release();

    return hr;
}

//******************************************************************************
//
// Function:        WbemTimeToSystemTime
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     08-16-2000   stevebl   rewrote to use WBEMTime class
//
//******************************************************************************

HRESULT WbemTimeToSystemTime(XBStr& xbstrWbemTime, SYSTEMTIME& sysTime)
{
    HRESULT hr = E_FAIL;
    WBEMTime wt(xbstrWbemTime);
    if (wt.GetSYSTEMTIME(&sysTime))
    {
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\sid.h ===
//*************************************************************
//
//  Header file for Sid.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#ifdef __cplusplus
extern "C" {
#endif

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid);

#ifdef __cplusplus
}
#endif

PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
NTSTATUS LoadSidAuthFromString (const WCHAR* pString, PSID_IDENTIFIER_AUTHORITY pSidAuth);
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue);
NTSTATUS GetDomainSidFromDomainRid(PSID pSid, DWORD dwRid, PSID *ppNewSid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\sid.cpp ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "main.h"

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: GetUserSid returned NULL")));
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlUnicodeStringToAnsiString failed, status = 0x%x"),
                 status));
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = (PTOKEN_USER)LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                      BytesRequired));
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to query user info from user token, status = 0x%x"),
                  status));
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: RtlCopySid Failed. status = %d"),
                  status));
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}


//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    SID_IDENTIFIER_AUTHORITY Auth;

    pSidStr = (WCHAR *)LocalAlloc(LPTR, (lstrlen (lpszSidStr) + 1)*sizeof(WCHAR));;
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    lstrcpy (pSidStr, lpszSidStr);
    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        LocalFree( pSidStr );
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = lstrlenW (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    len = lstrlen (szNum);
    pwszNumStr = (WCHAR *)LocalAlloc( LPTR, (len + 1) * sizeof(WCHAR));

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    lstrcpy (pwszNumStr, szNum);
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        LocalFree( pwszNumStr );
    return Status;
}


//*************************************************************
//
//  GetDomainSidFromRid()
//
//  Purpose:    Given one domain sid, constructs another domain sid
//              by replacing the tail by the passed in Rid
//
//  Parameters: pSid            -   Given Domain Sid
//              dwRid           -   Domain Rid
//              ppNewSid        -   Pointer to the New Sid
//
//  Return:     ERROR_SUCCESS on Success
//              FALSE if an error occurs
//
//  Comments:
//      Sid returned must be freed using FreeSid.
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//
//*************************************************************

NTSTATUS GetDomainSidFromDomainRid(PSID pSid, DWORD dwRid, PSID *ppNewSid)
{
    
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;
    // pointer to identifier authority
    BYTE      nSubAuthorityCount, i;                   // count of subauthorities
    DWORD     dwSubAuthority[8]={0,0,0,0,0,0,0,0};     // subauthority 
    PUCHAR    pSubAuthCount;
    DWORD    *pdwSubAuth;
    NTSTATUS  Status=ERROR_SUCCESS;
    
    DmAssert(IsValidSid(pSid));
    
    //
    // Will fail only if passed in sid is invalid and in the case 
    // the returned value is undefined. 
    //
    
    pIdentifierAuthority = RtlIdentifierAuthoritySid(pSid);
    
    //
    // get the count of subauthorities
    //

    pSubAuthCount = RtlSubAuthorityCountSid (pSid);
    
    if (!pSubAuthCount) {
        Status = ERROR_INVALID_SID;
        goto Exit;
    }
    
    nSubAuthorityCount = *pSubAuthCount;
    
    //
    // get each of the subauthorities
    //

    for (i = 0; i < (nSubAuthorityCount-1); i++) {
        pdwSubAuth = RtlSubAuthoritySid(pSid, i);
        
        if (!pdwSubAuth) {
            Status = ERROR_INVALID_SID;
            goto Exit;
        }
        
        dwSubAuthority[i] = *pdwSubAuth;
    }
    
    dwSubAuthority[i] = dwRid;

    //
    // Allocate a sid with these..
    //

    Status = RtlAllocateAndInitializeSid(
                pIdentifierAuthority,
                nSubAuthorityCount,
                dwSubAuthority[0],
                dwSubAuthority[1],
                dwSubAuthority[2],
                dwSubAuthority[3],
                dwSubAuthority[4],
                dwSubAuthority[5],
                dwSubAuthority[6],
                dwSubAuthority[7],
                ppNewSid
                );
    
Exit:

    // Sid, All Done
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\rsopsnap.cpp ===
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPSnapIn object implementation                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRSOPSnapIn::CRSOPSnapIn(CRSOPComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumnSize = 180;
    m_lViewMode = LVS_REPORT;
    m_bExpand = TRUE;

    LoadString(g_hInstance, IDS_NAME, m_column1, ARRAYSIZE(m_column1));
}

CRSOPSnapIn::~CRSOPSnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPSnapIn object implementation (IUnknown)                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CRSOPSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CRSOPSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CRSOPSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPSnapIn object implementation (IComponent)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));

    return S_OK;
}

STDMETHODIMP CRSOPSnapIn::Destroy(MMC_COOKIE cookie)
{

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CRSOPSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;


    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

        if (hbmp16x16)
        {
            hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

            if (hbmp32x32)
            {
                LPIMAGELIST pImageList = (LPIMAGELIST) arg;

                // Set the images
                pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                                  reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                                  0, RGB(255, 0, 255));

                DeleteObject(hbmp32x32);
            }

            DeleteObject(hbmp16x16);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPRSOPDATAOBJECT pRSOPDataObject;
            MMC_COOKIE cookie;
            INT i;
            LPCONSOLE2 lpConsole2;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IRSOPDataObject, (LPVOID *)&pRSOPDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pRSOPDataObject->GetCookie(&cookie);

            pRSOPDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumnSize);
            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < g_RsopNameSpace[cookie].cResultItems; i++)
            {
                resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                resultItem.str = MMC_CALLBACK;
                resultItem.nImage = g_RsopNameSpace[cookie].pResultItems[i].iImage;
                resultItem.lParam = (LPARAM) &g_RsopNameSpace[cookie].pResultItems[i];
                m_pResult->InsertItem(&resultItem);
            }

            m_pResult->Sort(0, 0, -1);

            if (m_bExpand)
            {
                hr = m_pConsole->QueryInterface(IID_IConsole2,
                                reinterpret_cast<void**>(&lpConsole2));

                if (SUCCEEDED(hr))
                {
                    if (m_pcd->m_hMachine)
                    {
                        lpConsole2->Expand(m_pcd->m_hMachine, TRUE);
                    }

                    if (m_pcd->m_hUser)
                    {
                        lpConsole2->Expand(m_pcd->m_hUser, TRUE);
                    }

                    lpConsole2->Release();
                }

                m_bExpand = FALSE;
            }
        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumnSize);
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;

    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPRESULTITEM pItem;
            LPRSOPDATAOBJECT pRSOPDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IRSOPDataObject, (LPVOID *)&pRSOPDataObject);

            if (FAILED(hr))
                break;

            pRSOPDataObject->GetType(&type);
            pRSOPDataObject->GetCookie(&cookie);

            pRSOPDataObject->Release();


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if ((type == CCT_RESULT) ||
                ((type == CCT_SCOPE) && ((cookie == 0) || (cookie == 1) || (cookie == 2))))
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                //
                // If this is a result pane item, then change the default
                // verb to Properties.
                //

                if (type == CCT_RESULT)
                    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            }

        }
        break;

    case MMCN_CONTEXTHELP:
        {

        if (m_pDisplayHelp)
        {
            LPOLESTR pszHelpTopic;
            LPRSOPDATAOBJECT pRSOPDataObject;
            MMC_COOKIE cookie;


            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IRSOPDataObject, (LPVOID *)&pRSOPDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pRSOPDataObject->GetCookie(&cookie);

            pRSOPDataObject->Release();     // release initial ref

            if (FAILED(hr))
                return S_OK;

            pszHelpTopic = (LPOLESTR) CoTaskMemAlloc (50 * sizeof(WCHAR));

            if (pszHelpTopic)
            {
                lstrcpy (pszHelpTopic, g_RsopNameSpace[cookie].lpHelpTopic);
                m_pDisplayHelp->ShowTopic (pszHelpTopic);
            }
        }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CRSOPSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    pResult->str = g_RsopNameSpace[pResult->lParam].szDisplayName;
                }
                else
                {
                    pResult->str = L"";
                }
            }

            if (pResult->mask & RDI_IMAGE)
            {
                if (m_pcd->m_bInitialized)
                {
                    INT iIcon;

                    iIcon = g_RsopNameSpace[pResult->lParam].iIcon;

                    if ((pResult->lParam == 1) && m_pcd->m_bComputerGPCoreError)
                    {
                        iIcon = 12;
                    }
                    else if ((pResult->lParam == 1) && m_pcd->m_bComputerCSEError)
                    {
                        iIcon = 14;
                    }
                    else if ((pResult->lParam == 2) && m_pcd->m_bUserGPCoreError)
                    {
                        iIcon = 13;
                    }
                    else if ((pResult->lParam == 2) && m_pcd->m_bUserCSEError)
                    {
                        iIcon = 15;
                    }

                    pResult->nImage = iIcon;
                }
                else
                    pResult->nImage = 3;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)pResult->lParam;

                    if (lpResultItem->szDisplayName[0] == TEXT('\0'))
                    {
                        LoadString (g_hInstance, lpResultItem->iStringID,
                                    lpResultItem->szDisplayName,
                                    MAX_DISPLAYNAME_SIZE);
                    }

                    pResult->str = lpResultItem->szDisplayName;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CRSOPSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CRSOPSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CRSOPSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPRSOPDATAOBJECT pRSOPDataObjectA, pRSOPDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPODataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IRSOPDataObject,
                                            (LPVOID *)&pRSOPDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IRSOPDataObject,
                                            (LPVOID *)&pRSOPDataObjectB)))
    {
        pRSOPDataObjectA->Release();
        return S_FALSE;
    }

    pRSOPDataObjectA->GetCookie(&cookie1);
    pRSOPDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pRSOPDataObjectA->Release();
    pRSOPDataObjectB->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPSnapIn object implementation (IExtendContextMenu)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPSnapIn::AddMenuItems(LPDATAOBJECT piDataObject,
                                   LPCONTEXTMENUCALLBACK pCallback,
                                   LONG *pInsertionAllowed)
{
    return m_pcd->AddMenuItems (piDataObject, pCallback, pInsertionAllowed);
}

STDMETHODIMP CRSOPSnapIn::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{

    return m_pcd->Command (lCommandID, piDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\rsoproot.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoproot.cpp
//
//  Contents:   implementation of root RSOP snap-in node
//
//  Classes:    CRSOPComponentDataCF
//              CRSOPComponentData
//
//  Functions:
//
//  History:    09-13-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "objsel.h" // for the object picker
#include "rsoputil.h"
#include <ntdsapi.h> // for the Ds*DomainController* API
#include "sddl.h"    // for sid to string functions

unsigned int CRSOPCMenu::m_cfDSObjectName  = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);

//
// Help ids
//

DWORD aBrowseForOUHelpIds[] =
{
    DSBID_BANNER,        IDH_RSOP_BANNER,
    DSBID_CONTAINERLIST, IDH_RSOP_CONTAINERLIST,

    0, 0
};

DWORD aGPOListHelpIds[] =
{
    IDC_LIST1,   IDH_RSOP_GPOLIST,
    IDC_CHECK1,  IDH_RSOP_GPOSOM,
    IDC_CHECK2,  IDH_RSOP_APPLIEDGPOS,
    IDC_CHECK3,  IDH_RSOP_REVISION,
    IDC_BUTTON1, IDH_RSOP_SECURITY,
    IDC_BUTTON2, IDH_RSOP_EDIT,

    0, 0
};

DWORD aErrorsHelpIds[] =
{
    IDC_LIST1,   IDH_RSOP_COMPONENTLIST,
    IDC_EDIT1,   IDH_RSOP_COMPONENTDETAILS,
    IDC_BUTTON1, IDH_RSOP_SAVEAS,

    0, 0
};


DWORD aQueryHelpIds[] =
{
    IDC_LIST1,  IDH_RSOP_QUERYLIST,

    0, 0
};


DWORD aBrowseDCHelpIds[] =
{
    IDC_LIST1,  IDH_RSOP_BROWSEDC,

    0, 0
};

BSTR ParseDomainName( LPWSTR szDSObject );

//************************************************************************
//  ParseDN
//
//  Purpose:    Parses the given name to get the pieces. 
//
//  Parameters:
//          lpDSObject  - Path to the DS Obkect in the format LDAP://<DC-Name>/DN
//          pwszDomain  - Returns the <DC-Name>. This is allocated in the fn.
//          pszDN       - The DN part of lpDSObject
//          szSOM       - THe actual SOM (the node on which we have the rsop rights on
// 
// No return value. If memory couldn't be allocated for the pwszDomain it is returned as NULL
//
//************************************************************************


void ParseDN(LPWSTR lpDSObject, LPWSTR *pwszDomain, LPWSTR *pszDN, LPWSTR *szSOM)
{
    LPWSTR  szContainer = lpDSObject;
    LPWSTR  lpEnd = NULL;

   *pszDN = szContainer;

   if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, TEXT("LDAP://"),
                      7, szContainer, 7) != CSTR_EQUAL)
   {
       DebugMsg((DM_WARNING, TEXT("GetSOMFromDN: Object does not start with LDAP://")));
       return;
   }

   szContainer += 7;
   
   lpEnd = szContainer;

   //
   // Move till the end of the domain name
   //

   *pwszDomain = NULL;

   while (*lpEnd && (*lpEnd != TEXT('/'))) {
       lpEnd++;
   }

   if (*lpEnd == TEXT('/')) {
       *pwszDomain = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*( (lpEnd - szContainer) + 1));

       if (*pwszDomain) {
           wcsncpy(*pwszDomain, szContainer, (lpEnd - szContainer));
       }

       szContainer = lpEnd + 1;
   }


   *pszDN = szContainer;
   
   while (*szContainer) {

       //
       // See if the DN name starts with OU=
       //

       if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                          szContainer, 3, TEXT("OU="), 3) == CSTR_EQUAL) {
           break;
       }

       //
       // See if the DN name starts with DC=
       //

       else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                               szContainer, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
           break;
       }


       //
       // Move to the next chunk of the DN name
       //

       while (*szContainer && (*szContainer != TEXT(','))) {
           szContainer++;
       }

       if (*szContainer == TEXT(',')) {
           szContainer++;
       }
   }

   *szSOM = szContainer;
   return;
}


BOOL IsPlanningModeAllowed()
{
    //
    // Check the SKU to see if planning is allowed -- it
    // is not implemented for the pro SKU
    //
    
    OSVERSIONINFOEXW version;
    
    version.dwOSVersionInfoSize = sizeof(version);
    
    if ( GetVersionEx( (LPOSVERSIONINFO) &version ) )
    {
        if ( version.wProductType != VER_NT_WORKSTATION )
        {
            //
            // This is a non-pro SKU, so we allow planning mode
            //
            return TRUE;
        }
    }

    return FALSE;
}



//*************************************************************
//
//  MyTranslateName()
//
//  Purpose:    Gets the user name in the requested format
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
// Allocates and retries with the appropriate buffer size
//
//*************************************************************

LPTSTR MyTranslateName (LPTSTR lpAccName, EXTENDED_NAME_FORMAT  NameFormat, EXTENDED_NAME_FORMAT  desiredNameFormat)
{
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;


    //
    // Allocate a buffer for the user name
    //

    ulUserNameSize = 75;

    if (desiredNameFormat == NameFullyQualifiedDN) {
        ulUserNameSize = 200;
    }


    lpUserName = (LPTSTR) LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

    if (!lpUserName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Get the username in the requested format
    //

    if (!TranslateName (lpAccName, NameFormat, desiredNameFormat, lpUserName, &ulUserNameSize)) {

        //
        // If the call failed due to insufficient memory, realloc
        // the buffer and try again.  Otherwise, exit now.
        //

        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER) {
            DebugMsg((DM_WARNING, TEXT("MyGetTranslateName:  TranslateName failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        lpTemp = (LPTSTR) LocalReAlloc (lpUserName, (ulUserNameSize * sizeof(TCHAR)),
                                       LMEM_MOVEABLE);

        if (!lpTemp) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetTranslateName:  Failed to realloc memory with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }


        lpUserName = lpTemp;

        if (!TranslateName (lpAccName, NameFormat, desiredNameFormat, lpUserName, &ulUserNameSize)) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetTranslateName:  TranslateName failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        dwError = ERROR_SUCCESS;
    }


Exit:

    SetLastError(dwError);

    return lpUserName;
}

//*************************************************************
//
//  MyLookupAccountName()
//
//  Purpose:    Gets the SID of the user
//
//  Parameters:
//      szSystemName:   Machine where the account should be resolved
//      szAccName:      The actual account name
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
// Allocates and retries with the appropriate buffer size
//*************************************************************

LPTSTR MyLookupAccountName(LPTSTR szSystemName, LPTSTR szAccName)
{
    PSID            pSid = NULL;
    DWORD           cSid = 0, cbDomain = 0;
    SID_NAME_USE    peUse;
    LPTSTR          lpSidString = NULL, szDomain = NULL;
    DWORD           dwErr = 0;
    BOOL            bRet = FALSE;


    LookupAccountName(szSystemName, szAccName, NULL, &cSid, NULL, &cbDomain, &peUse);

    pSid = (PSID)LocalAlloc(LPTR, cSid);

    szDomain = (LPTSTR) LocalAlloc(LPTR, cbDomain*(sizeof(TCHAR)));

    if (!pSid || !szDomain) {
        return NULL;
    }


    if (!LookupAccountName(szSystemName, szAccName, pSid, &cSid, szDomain, &cbDomain, &peUse)) {
        DebugMsg((DM_WARNING, TEXT("MyLookupAccountName:  LookupAccountName failed with %d"),
                 GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }

    if (!ConvertSidToStringSid(pSid, &lpSidString)) {
        DebugMsg((DM_WARNING, TEXT("MyLookupAccountName:  ConvertSidToStringSid failed with %d"),
                 GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }

    bRet = TRUE;

Exit:
    if (pSid) {
        LocalFree(pSid);
    }

    if (szDomain) {
        LocalFree(szDomain);
    }

    if (!bRet) {
        SetLastError(dwErr);
        return NULL;
    }
    else {
        return lpSidString;
    }
}

WCHAR * NameWithoutDomain(WCHAR * szName)
{
    // The name passed in could be of the form
    // "domain/name"
    // or it could be just
    // "name"

    int cch = 0;
    if (NULL != szName)
    {
        while (szName[cch])
        {
            if (szName[cch] == L'/' || szName[cch] == L'\\')
            {
                return &szName[cch + 1];
            }
            cch++;
        }
    }
    return szName;
}

WCHAR* NormalizedComputerName(WCHAR * szComputerName )
{
    TCHAR* szNormalizedComputerName;
     
    // Computer names may start with '\\', so we will return
    // the computer name without that prefix if it exists

    szNormalizedComputerName = szComputerName;

    if ( szNormalizedComputerName )
    {
        // Make sure that the computer name string is at least 2 characters in length --
        // if the first character is non-zero, we know the second character must exist
        // since this is a zero terminated string -- in this case, it is safe to compare
        // the first 2 characters
        if ( *szNormalizedComputerName )
        {
            if ( ( TEXT('\\') == szNormalizedComputerName[0] ) &&
                 ( TEXT('\\') == szNormalizedComputerName[1] ) )
            {
                szNormalizedComputerName += 2;
            }
        }
    }

    return szNormalizedComputerName;
}

CRSOPComponentData::CRSOPComponentData()
{
    InterlockedIncrement(&g_cRefThisDll);

    m_cRef = 1;
    m_hwndFrame = NULL;
    m_bOverride = FALSE;
    m_bDirty = FALSE;
    m_bRefocusInit = FALSE;
    m_bArchiveData = FALSE;
    m_bViewIsArchivedData = FALSE;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_hMachine = NULL;
    m_hUser = NULL;

    m_pDisplayName = NULL;
    m_bDiagnostic = FALSE;
    m_szNamespace = NULL;
    m_bInitialized = FALSE;

    m_szComputerName = NULL;
    m_szComputerDNName = NULL;
    m_szComputerSOM = NULL;
    m_szDefaultComputerSOM = NULL;
    m_saComputerSecurityGroups = NULL;
    m_saDefaultComputerSecurityGroups = NULL;
    m_saComputerSecurityGroupsAttr = NULL;
    m_saDefaultComputerSecurityGroupsAttr = NULL;
    m_saComputerWQLFilters = NULL;
    m_saComputerWQLFilterNames = NULL;
    m_saDefaultComputerWQLFilters = NULL;
    m_saDefaultComputerWQLFilterNames = NULL;
    m_pComputerObject = NULL;
    m_bNoComputerData = FALSE;
    m_bComputerDeniedAccess = FALSE;

    m_szSite = NULL;
    m_szDC = NULL;
    m_bSlowLink = FALSE;
    m_loopbackMode = LoopbackNone;

    m_szUserName = NULL;
    m_szUserDNName = NULL;
    m_szUserDisplayName = NULL;
    m_szUserSOM = NULL;
    m_szDefaultUserSOM = NULL;
    m_saUserSecurityGroups = NULL;
    m_saUserSecurityGroupsAttr = NULL;
    m_saDefaultUserSecurityGroups = NULL;
    m_saDefaultUserSecurityGroupsAttr = NULL;
    m_saUserWQLFilters = NULL;
    m_saUserWQLFilterNames = NULL;
    m_saDefaultUserWQLFilters = NULL;
    m_saDefaultUserWQLFilterNames = NULL;
    m_pUserObject = NULL;
    m_bNoUserData = FALSE;
    m_bUserDeniedAccess = FALSE;

    m_dwSkippedFrom = 0;

    m_hChooseBitmap = NULL;

    m_pUserGPOList = NULL;
    m_pComputerGPOList = NULL;

    m_pUserCSEList = NULL;
    m_pComputerCSEList = NULL;

    m_bUserCSEError = FALSE;
    m_bComputerCSEError = FALSE;
    m_bUserGPCoreError = FALSE;
    m_bComputerGPCoreError = FALSE;

    m_szUserSOMPref = NULL;
    m_szComputerSOMPref = NULL;
    m_szUserNamePref = NULL;
    m_szComputerNamePref = NULL;
    m_szSitePref = NULL;
    m_szDCPref = NULL;
    m_bSkipUserWQLFilter = TRUE;
    m_bSkipComputerWQLFilter = TRUE;

    m_dwLoadFlags = RSOP_NOMSC;
    
    m_pEvents = new CEvents;

    m_hRichEdit = LoadLibrary (TEXT("riched20.dll"));

    m_BigBoldFont = NULL;
    m_BoldFont = NULL;


}

CRSOPComponentData::~CRSOPComponentData()
{
    FreeUserData();
    FreeComputerData();

    if (m_pEvents)
    {
        delete m_pEvents;
    }

    if (m_pUserCSEList)
    {
        FreeCSEData (m_pUserCSEList);
    }

    if (m_pComputerCSEList)
    {
        FreeCSEData (m_pComputerCSEList);
    }

    if (m_pUserGPOList)
    {
        FreeGPOListData (m_pUserGPOList);
    }

    if (m_pComputerGPOList)
    {
        FreeGPOListData (m_pComputerGPOList);
    }

    if (m_szSite)
    {
        delete [] m_szSite;
    }

    if (m_szDC)
    {
        delete [] m_szDC;
    }

    if (m_pDisplayName)
    {
        delete [] m_pDisplayName;
    }

    if (m_szNamespace)
    {
        delete [] m_szNamespace;
    }

    if (m_szUserSOMPref)
        LocalFree(m_szUserSOMPref);

    if (m_szComputerSOMPref)
        LocalFree(m_szComputerSOMPref);

    if (m_szUserNamePref)
        LocalFree(m_szUserNamePref);
                                                           
    if (m_szComputerNamePref)
        LocalFree(m_szComputerNamePref);

    if (m_szSitePref)
        LocalFree(m_szSitePref);

    if (m_szDCPref)
        LocalFree(m_szDCPref);

    if (m_hChooseBitmap)
    {
        DeleteObject (m_hChooseBitmap);
    }

    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_hRichEdit)
    {
        FreeLibrary (m_hRichEdit);
    }

    if ( m_BoldFont )
    {
        DeleteObject(m_BoldFont); m_BoldFont = NULL;
    }

    if ( m_BoldFont )
    {
        DeleteObject(m_BigBoldFont); m_BigBoldFont = NULL;
    }


    InterlockedDecrement(&g_cRefThisDll);
}

VOID CRSOPComponentData::FreeUserData (VOID)
{
    if (m_szUserName)
    {
        delete [] m_szUserName;
        m_szUserName = NULL;
    }

    if (m_szUserDNName)
    {
        delete [] m_szUserDNName;
        m_szUserDNName = NULL;
    }

    if (m_szUserDisplayName)
    {
        delete [] m_szUserDisplayName;
        m_szUserDisplayName = NULL;
    }

    if (m_szUserSOM)
    {
        delete [] m_szUserSOM;
        m_szUserSOM = NULL;
    }

    if (m_szDefaultUserSOM)
    {
        delete [] m_szDefaultUserSOM;
        m_szDefaultUserSOM = NULL;
    }

    if (m_saUserSecurityGroups)
    {
        SafeArrayDestroy (m_saUserSecurityGroups);
        m_saUserSecurityGroups = NULL;
    }

    if (m_saUserSecurityGroupsAttr)
    {
        LocalFree(m_saUserSecurityGroupsAttr);
        m_saUserSecurityGroupsAttr = NULL;
    }


    if (m_saDefaultUserSecurityGroups)
    {
        SafeArrayDestroy (m_saDefaultUserSecurityGroups);
        m_saDefaultUserSecurityGroups = NULL;
    }

    if (m_saDefaultUserSecurityGroupsAttr)
    {
        LocalFree (m_saDefaultUserSecurityGroupsAttr);
        m_saDefaultUserSecurityGroupsAttr = NULL;
    }

    if (m_saUserWQLFilters)
    {
        SafeArrayDestroy (m_saUserWQLFilters);
        m_saUserWQLFilters = NULL;
    }

    if (m_saUserWQLFilterNames)
    {
        SafeArrayDestroy (m_saUserWQLFilterNames);
        m_saUserWQLFilterNames = NULL;
    }

    if (m_saDefaultUserWQLFilters)
    {
        SafeArrayDestroy (m_saDefaultUserWQLFilters);
        m_saDefaultUserWQLFilters = NULL;
    }

    if (m_saDefaultUserWQLFilterNames)
    {
        SafeArrayDestroy (m_saDefaultUserWQLFilterNames);
        m_saDefaultUserWQLFilterNames = NULL;
    }

    m_bSkipUserWQLFilter = TRUE;

    if (m_pUserObject)
    {
        m_pUserObject->Release();
        m_pUserObject = NULL;
    }
}

VOID CRSOPComponentData::FreeComputerData (VOID)
{
    if (m_szComputerName)
    {
        delete [] m_szComputerName;
        m_szComputerName = NULL;
    }

    if (m_szComputerDNName)
    {
        delete [] m_szComputerDNName;
        m_szComputerDNName = NULL;
    }

    if (m_szComputerSOM)
    {
        delete [] m_szComputerSOM;
        m_szComputerSOM = NULL;
    }

    if (m_szDefaultComputerSOM)
    {
        delete [] m_szDefaultComputerSOM;
        m_szDefaultComputerSOM = NULL;
    }

    if (m_saComputerSecurityGroups)
    {
        SafeArrayDestroy (m_saComputerSecurityGroups);
        m_saComputerSecurityGroups = NULL;
    }

    if (m_saDefaultComputerSecurityGroups)
    {
        SafeArrayDestroy (m_saDefaultComputerSecurityGroups);
        m_saDefaultComputerSecurityGroups = NULL;
    }

    if (m_saComputerSecurityGroupsAttr)
    {
        LocalFree (m_saComputerSecurityGroupsAttr);
        m_saComputerSecurityGroupsAttr = NULL;
    }

    if (m_saDefaultComputerSecurityGroupsAttr)
    {
        LocalFree (m_saDefaultComputerSecurityGroupsAttr);
        m_saDefaultComputerSecurityGroupsAttr = NULL;
    }

    if (m_saComputerWQLFilters)
    {
        SafeArrayDestroy (m_saComputerWQLFilters);
        m_saComputerWQLFilters = NULL;
    }

    if (m_saComputerWQLFilterNames)
    {
        SafeArrayDestroy (m_saComputerWQLFilterNames);
        m_saComputerWQLFilterNames = NULL;
    }

    if (m_saDefaultComputerWQLFilters)
    {
        SafeArrayDestroy (m_saDefaultComputerWQLFilters);
        m_saDefaultComputerWQLFilters = NULL;
    }

    if (m_saDefaultComputerWQLFilterNames)
    {
        SafeArrayDestroy (m_saDefaultComputerWQLFilterNames);
        m_saDefaultComputerWQLFilterNames = NULL;
    }

    m_bSkipComputerWQLFilter = TRUE;

    if (m_pComputerObject)
    {
        m_pComputerObject->Release();
        m_pComputerObject = NULL;
    }


}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPComponentData object implementation (IUnknown)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CRSOPComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CRSOPComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CRSOPComponentData::Release (void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CRSOPComponentData::GetNamespace (DWORD dwSection, LPOLESTR pszName, int cchMaxLength)
{
    TCHAR szPath[2*MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check parameters
    //

    if (!pszName || (cchMaxLength <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    if ((dwSection != GPO_SECTION_ROOT) &&
        (dwSection != GPO_SECTION_USER) &&
        (dwSection != GPO_SECTION_MACHINE))
        return E_INVALIDARG;


    //
    // Build the path
    //

    lstrcpy (szPath, m_szNamespace);

    if (dwSection != GPO_SECTION_ROOT)
    {
        if (dwSection == GPO_SECTION_USER)
        {
            lpEnd = CheckSlash (szPath);
            lstrcpy (lpEnd, USER_SECTION);
        }
        else if (dwSection == GPO_SECTION_MACHINE)
        {
            lpEnd = CheckSlash (szPath);
            lstrcpy (lpEnd, COMPUTER_SECTION);
        }
        else
        {
            return E_INVALIDARG;
        }
    }


    //
    // Save the name
    //

    if ((lstrlen (szPath) + 1) <= cchMaxLength)
    {
        lstrcpy (pszName, szPath);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

STDMETHODIMP CRSOPComponentData::GetFlags (DWORD * pdwFlags)
{
    if (!pdwFlags)
    {
        return E_INVALIDARG;
    }

    *pdwFlags = m_bDiagnostic ? RSOP_INFO_FLAG_DIAGNOSTIC_MODE : 0;

    return S_OK;
}

STDMETHODIMP CRSOPComponentData::GetEventLogEntryText (LPOLESTR pszEventSource,
                                                       LPOLESTR pszEventLogName,
                                                       LPOLESTR pszEventTime,
                                                       DWORD dwEventID,
                                                       LPOLESTR *ppszText)
{
    return (m_pEvents ? m_pEvents->GetEventLogEntryText(pszEventSource, pszEventLogName, pszEventTime,
                                            dwEventID, ppszText) : E_NOINTERFACE);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPComponentData object implementation (IComponentData)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    HBITMAP hbmp32x32;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
    hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                                    reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                    0, RGB(255, 0, 255));

    lpScopeImage->Release();


    return S_OK;
}

STDMETHODIMP CRSOPComponentData::Destroy(VOID)
{
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    BSTR bstrParam = NULL;
    LPTSTR lpTemp = NULL;
    BSTR bstrTemp = NULL;
    HRESULT hr = S_OK;


    if (m_bInitialized)
    {
        if (m_bViewIsArchivedData)
        {

            //
            // Delete the namespace
            //

            hr = CoCreateInstance(CLSID_WbemLocator,
                                  0,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IWbemLocator,
                                  (LPVOID *) &pLocator);
            if (FAILED(hr))
            {
                goto Cleanup;
            }


            //
            // Delete the namespace we created when loading the data
            //

            bstrParam = SysAllocString(TEXT("\\\\.\\root\\rsop"));

            if (!bstrParam)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            hr = pLocator->ConnectServer(bstrParam,
                                         NULL,
                                         NULL,
                                         NULL,
                                         0,
                                         NULL,
                                         NULL,
                                         &pNamespace);
            if (FAILED(hr))
            {
                goto Cleanup;
            }


            //
            // Allocate a temp buffer to store the fully qualified path in
            //

            lpTemp = new TCHAR [(lstrlen(m_szArchivedDataGuid) + 30)];

            if (!lpTemp)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
            }

            wsprintf (lpTemp, TEXT("__Namespace.name=\"%ws\""), m_szArchivedDataGuid);


            //
            // Delete the namespace
            //

            bstrTemp = SysAllocString (lpTemp);

            if (!bstrTemp)
            {
                hr = E_FAIL;
                goto Cleanup;
            }


            hr = pNamespace->DeleteInstance( bstrTemp, 0, NULL, NULL);


Cleanup:
            if (lpTemp)
            {
                delete [] lpTemp;
            }

            if (bstrTemp)
            {
                SysFreeString(bstrTemp);
            }

            if (bstrParam)
            {
                SysFreeString(bstrParam);
            }

            if (pNamespace)
            {
                pNamespace->Release();
            }

            if (pLocator)
            {
                pLocator->Release();
            }
        }
        else
        {
            hr = DeleteRSOPData (m_szNamespace);
        }

        if (SUCCEEDED(hr))
        {
            m_bInitialized = FALSE;
        }
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Destroy: Failed to delete namespace with 0x%x"), hr ));
    }

    return hr;
}

STDMETHODIMP CRSOPComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CRSOPSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CRSOPSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateComponent: Failed to create CRSOPSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CRSOPComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                                 LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CRSOPDataObject *pDataObject;
    LPRSOPDATAOBJECT pRSOPDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CRSOPDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private RSOPDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IRSOPDataObject, (LPVOID *)&pRSOPDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return(hr);
    }

    pRSOPDataObject->SetType(type);
    pRSOPDataObject->SetCookie(cookie);
    pRSOPDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CRSOPComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch (event)
    {
    case MMCN_EXPAND:
        if (arg == TRUE)
            hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
        break;

    case MMCN_PRELOAD:
        if (!m_bRefocusInit)
        {
            SCOPEDATAITEM item;

            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Notify:  Received MMCN_PRELOAD event.")));
            m_bRefocusInit = TRUE;

            ZeroMemory (&item, sizeof(SCOPEDATAITEM));
            item.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
            item.displayname = MMC_CALLBACK;

            if (m_bInitialized)
            {
                if (m_bUserGPCoreError || m_bComputerGPCoreError)
                {
                    item.nImage = 3;
                    item.nOpenImage = 3;
                }
                else if (m_bUserCSEError || m_bComputerCSEError ||
                         m_bUserDeniedAccess || m_bComputerDeniedAccess)
                {
                    item.nImage = 11;
                    item.nOpenImage = 11;
                }
                else
                {
                    item.nImage = 2;
                    item.nOpenImage = 2;
                }
            }
            else
            {
                item.nImage = 3;
                item.nOpenImage = 3;
            }

            item.ID = (HSCOPEITEM) arg;

            m_pScope->SetItem (&item);
        }
        break;

    default:
        break;
    }

    return hr;
}

STDMETHODIMP CRSOPComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        if (g_RsopNameSpace[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == g_dwNameSpaceItems)
        pItem->displayname = NULL;
    else
    {
        if (((DWORD) pItem->lParam == 0) && m_pDisplayName)
            pItem->displayname = m_pDisplayName;
        else
            pItem->displayname = g_RsopNameSpace[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CRSOPComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPRSOPDATAOBJECT pRSOPDataObjectA, pRSOPDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private RSOPDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IRSOPDataObject,
                                             (LPVOID *)&pRSOPDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IRSOPDataObject,
                                             (LPVOID *)&pRSOPDataObjectB)))
    {
        pRSOPDataObjectA->Release();
        return S_FALSE;
    }

    pRSOPDataObjectA->GetCookie(&cookie1);
    pRSOPDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pRSOPDataObjectA->Release();
    pRSOPDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPComponentData object implementation (IExtendPropertySheet2)          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                                     LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    return SetupPropertyPages(RSOP_NOMSC, lpProvider, handle, lpDataObject);
}

STDMETHODIMP CRSOPComponentData::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    HRESULT hr;

    hr = IsSnapInManager(lpDataObject);

    if (hr != S_OK)
    {
        hr = IsNode(lpDataObject, 0); // check for root
        if (S_OK == hr)
        {
            return hr;
        }
        hr = IsNode(lpDataObject, 1); // check for machine
        if (S_OK == hr)
        {
            return hr;
        }
        hr = IsNode(lpDataObject, 2); // check for user
        if (S_OK == hr)
        {
            return hr;
        }
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CRSOPComponentData::GetWatermarks(LPDATAOBJECT lpIDataObject,
                                               HBITMAP* lphWatermark,
                                               HBITMAP* lphHeader,
                                               HPALETTE* lphPalette,
                                               BOOL* pbStretch)
{
    *lphPalette = NULL;
    *lphHeader = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_HEADER));
    *lphWatermark = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_WIZARD));;
    *pbStretch = TRUE;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPComponentData object implementation (IExtendContextMenu)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPComponentData::AddMenuItems(LPDATAOBJECT piDataObject,
                                              LPCONTEXTMENUCALLBACK pCallback,
                                              LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TCHAR szMenuItem[100];
    TCHAR szDescription[250];
    CONTEXTMENUITEM item;


    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        if (IsNode(piDataObject, 0) == S_OK)
        {
            LoadString (g_hInstance, IDS_ARCHIVEDATA, szMenuItem, 100);
            LoadString (g_hInstance, IDS_ARCHIVEDATADESC, szDescription, 250);

            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_ARCHIVEDATA;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
            item.fFlags = m_bArchiveData ? MFS_CHECKED : 0;
            item.fSpecialFlags = 0;

            hr = pCallback->AddItem(&item);
        }
    }


    return(hr);
}

STDMETHODIMP CRSOPComponentData::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{
    TCHAR szCaption[100];
    TCHAR szMessage[300];
    INT iRet;

    if (lCommandID == IDM_ARCHIVEDATA)
    {
        m_bArchiveData = !m_bArchiveData;

        if (m_bViewIsArchivedData && !m_bArchiveData)
        {
            LoadString(g_hInstance, IDS_ARCHIVEDATA_CAPTION, szCaption, ARRAYSIZE(szCaption));
            LoadString(g_hInstance, IDS_ARCHIVEDATA_MESSAGE, szMessage, ARRAYSIZE(szMessage));

            m_pConsole->MessageBox (szMessage, szCaption, MB_OK, &iRet);
        }

        SetDirty();
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPComponentData object implementation (IPersistStreamInit)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    *pClassID = CLSID_RSOPSnapIn;

    return S_OK;
}

STDMETHODIMP CRSOPComponentData::IsDirty(VOID)
{
    return ThisIsDirty() ? S_OK : S_FALSE;
}

HRESULT CRSOPComponentData::DeleteRSOPData(LPTSTR lpNameSpace)
{
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutInst = NULL;
    IWbemClassObject * pInClass = NULL;
    IWbemClassObject * pInInst = NULL;
    BSTR bstrParam = NULL;
    BSTR bstrClassPath = NULL;
    BSTR bstrMethodName = NULL;
    VARIANT var;
    TCHAR szBuffer[MAX_PATH];
    LPTSTR szLocalNameSpace = NULL;

    HRESULT hr;
    HRESULT hrSuccess;

    szLocalNameSpace = (LPTSTR)LocalAlloc(LPTR, (2+lstrlen(lpNameSpace))*sizeof(TCHAR));

    if (!szLocalNameSpace) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::DeleteRSOPData: LocalAlloc failed with 0x%x"), hr));
        goto Cleanup;
    }

    if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, 
                       TEXT("\\\\"), 2, lpNameSpace, 2) == CSTR_EQUAL) {

        if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, 
                           TEXT("\\\\."), 3, lpNameSpace, 3) != CSTR_EQUAL) {
            LPTSTR lpEnd;
            lpEnd = wcschr(lpNameSpace+2, L'\\');

            if (!lpEnd) {
                hr = E_FAIL;
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::DeleteRSOPData: Invalid format for name space")));
                goto Cleanup;
            }
            else {
                lstrcpy(szLocalNameSpace, TEXT("\\\\."));
                lstrcat(szLocalNameSpace, lpEnd);
            }
        }
        else {
            lstrcpy(szLocalNameSpace, lpNameSpace);
        }
    }
    else {
        lstrcpy(szLocalNameSpace, lpNameSpace);
    }

    DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::DeleteRSOPData: Namespace passed to the provider = %s"), szLocalNameSpace));

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (m_bDiagnostic)
    {
        // set up diagnostic mode
        // build a path to the target: "\\\\computer\\root\\rsop"
        _stprintf(szBuffer, TEXT("\\\\%s\\root\\rsop"), NameWithoutDomain(m_szComputerName));
        bstrParam = SysAllocString(szBuffer);

        if (!bstrParam)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pLocator->ConnectServer(bstrParam,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        bstrClassPath = SysAllocString(TEXT("RsopLoggingModeProvider"));
        hr = pNamespace->GetObject(bstrClassPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &pClass,
                                   NULL);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        // set up planning mode
        // build a path to the DC: "\\\\dc\\root\\rsop"
        _stprintf(szBuffer, TEXT("\\\\%s\\root\\rsop"), m_szDC);
        bstrParam = SysAllocString(szBuffer);

        if (!bstrParam)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pLocator->ConnectServer(bstrParam,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        bstrClassPath = SysAllocString(TEXT("RsopPlanningModeProvider"));
        hr = pNamespace->GetObject(bstrClassPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &pClass,
                                   NULL);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    bstrMethodName = SysAllocString(TEXT("RsopDeleteSession"));

    if (!bstrMethodName)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pClass->GetMethod(bstrMethodName,
                           0,
                           &pInClass,
                           NULL);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = pInClass->SpawnInstance(0, &pInInst);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = SetParameter(pInInst, TEXT("nameSpace"), szLocalNameSpace);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Set the proper security to prevent the ExecMethod call from failing
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_CALL,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = pNamespace->ExecMethod(bstrClassPath,
                                bstrMethodName,
                                0,
                                NULL,
                                pInInst,
                                &pOutInst,
                                NULL);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = GetParameter(pOutInst, TEXT("hResult"), hrSuccess);
    if (SUCCEEDED(hr))
    {
        if (FAILED(hrSuccess))
        {
            hr = hrSuccess;
        }
    }

Cleanup:

    if (szLocalNameSpace) {
        LocalFree(szLocalNameSpace);
        szLocalNameSpace = NULL;
    }

    SysFreeString(bstrParam);
    SysFreeString(bstrClassPath);
    SysFreeString(bstrMethodName);
    if (pInInst)
    {
        pInInst->Release();
    }
    if (pOutInst)
    {
        pOutInst->Release();
    }
    if (pInClass)
    {
        pInClass->Release();
    }
    if (pClass)
    {
        pClass->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GenerateRSOPDataEx
//
//  Synopsis:   Wrapper around GenerateRSOPData.  This version adds retry
//              support.  If the user doesn't have access to half of the data
//              this method will re-issue the query for only the part of the data
//              the user has access to.
//
//---------------------------------------------------------------------------

HRESULT CRSOPComponentData::GenerateRSOPDataEx(HWND hDlg, LPTSTR *lpNameSpace)
{
    HRESULT hr;
    ULONG ulErrorInfo;
    BOOL bSkipCSEs, bLimitData, bUser, bForceCreate;


    bSkipCSEs = bLimitData = bUser =  bForceCreate = FALSE;

    hr = GenerateRSOPData (hDlg, lpNameSpace, bSkipCSEs, bLimitData, bUser, bForceCreate, &ulErrorInfo);

    if (FAILED(hr))
    {
        if (ulErrorInfo == RSOP_USER_ACCESS_DENIED)
        {
            ReportError (hDlg, hr, IDS_EXECFAILED_USER);
            m_bUserDeniedAccess = TRUE;
            FillResultsList (GetDlgItem (hDlg, IDC_LIST1));

            bSkipCSEs = bUser =  bForceCreate = FALSE;
            bLimitData = TRUE;
            hr = GenerateRSOPData (hDlg, lpNameSpace, bSkipCSEs, bLimitData, bUser, bForceCreate, &ulErrorInfo);
        }
        else if (ulErrorInfo == RSOP_COMPUTER_ACCESS_DENIED)
        {
            ReportError (hDlg, hr, IDS_EXECFAILED_COMPUTER);
            m_bComputerDeniedAccess = TRUE;
            FillResultsList (GetDlgItem (hDlg, IDC_LIST1));

            bSkipCSEs =  bForceCreate = FALSE;
            bLimitData = bUser = TRUE;
            hr = GenerateRSOPData (hDlg, lpNameSpace, bSkipCSEs, bLimitData, bUser, bForceCreate, &ulErrorInfo);
        }
        
        if (FAILED(hr)) {
            if ((ulErrorInfo & RSOP_COMPUTER_ACCESS_DENIED) && 
                     (ulErrorInfo & RSOP_USER_ACCESS_DENIED)) {
                // both are denied access
                ReportError (hDlg, hr, IDS_EXECFAILED_BOTH);
            }
            else if (ulErrorInfo & RSOP_TEMPNAMESPACE_EXISTS) {
                TCHAR szConfirm[MAX_PATH], szTitle[MAX_PATH];

                szConfirm[0] = szTitle[0] = TEXT('\0');
                LoadString(g_hInstance, IDS_RSOPDELNAMESPACE, szConfirm, ARRAYSIZE(szConfirm));
                LoadString(g_hInstance, IDS_RSOPDELNS_TITLE, szTitle, ARRAYSIZE(szTitle));

                if (MessageBox(hDlg, szConfirm, szTitle, MB_OKCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2) == IDOK) {
                    // use the same options as before
                    bForceCreate = TRUE;
                    hr = GenerateRSOPData (hDlg, lpNameSpace, bSkipCSEs, bLimitData, bUser, bForceCreate,  &ulErrorInfo);
                }
            }
        }

        if (hr == HRESULT_FROM_WIN32(WAIT_TIMEOUT)) {
            ReportError (hDlg, hr, IDS_EXECFAILED_TIMEDOUT);
        }
        else
        {
            if (FAILED(hr)) {
                ReportError (hDlg, hr, IDS_EXECFAILED);
            }
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GenerateRSOPData
//
//  Synopsis:   Calls the rsop provider based on the settings made in the
//              initialization wizard
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    10-04-1999   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CRSOPComponentData::GenerateRSOPData(HWND hDlg, LPTSTR *lpNameSpace,
                                             BOOL bSkipCSEs, BOOL bLimitData,
                                             BOOL bUser, BOOL bForceCreate, 
                                             ULONG *pulErrorInfo)
{
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutInst = NULL;
    IWbemClassObject * pInClass = NULL;
    IWbemClassObject * pInInst = NULL;
    IUnsecuredApartment *pSpawner = NULL;
    IUnknown *pSubstitute = NULL;
    IWbemObjectSink *pSubstituteSink = NULL;
    BSTR bstrParam = NULL;
    BSTR bstrClassPath = NULL;
    BSTR bstrMethodName = NULL;
    VARIANT var;
    TCHAR szBuffer[MAX_PATH];
    HRESULT hr;
    HRESULT hrSuccess;
    CCreateSessionSink *pCSS = NULL;
    MSG msg;
    UINT uiFlags = 0;
    BOOL bSetData;


    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CoCreateInstance failed with 0x%x"), hr));
        goto Cleanup;
    }

    if (m_bDiagnostic)
    {
        // set up diagnostic mode
        // build a path to the target: "\\\\computer\\root\\rsop"
        _stprintf(szBuffer, TEXT("\\\\%s\\root\\rsop"), NameWithoutDomain(m_szComputerName));
        bstrParam = SysAllocString(szBuffer);
        hr = pLocator->ConnectServer(bstrParam,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: ConnectServer failed with 0x%x"), hr));
            ReportError (hDlg, hr, IDS_CONNECTSERVERFAILED, m_szComputerName);
            goto Cleanup;
        }

        bstrClassPath = SysAllocString(TEXT("RsopLoggingModeProvider"));
        hr = pNamespace->GetObject(bstrClassPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &pClass,
                                   NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: GetObject failed with 0x%x"), hr));
            goto Cleanup;
        }

        bstrMethodName = SysAllocString(TEXT("RsopCreateSession"));
        hr = pClass->GetMethod(bstrMethodName,
                               0,
                               &pInClass,
                               NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: GetMethod failed with 0x%x"), hr));
            goto Cleanup;
        }

        hr = pInClass->SpawnInstance(0, &pInInst);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SpawnInstance failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_bNoUserData || m_bUserDeniedAccess)
        {
            uiFlags |= FLAG_NO_USER;
        }

        if (m_bNoComputerData || m_bComputerDeniedAccess)
        {
            uiFlags |= FLAG_NO_COMPUTER;
        }

        if (bForceCreate) {
            uiFlags |= FLAG_FORCE_CREATENAMESPACE;
        }

        hr = SetParameter(pInInst, TEXT("flags"), uiFlags);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (!lstrcmpi(m_szUserName, TEXT(".")))
        {
            hr = SetParameterToNull(pInInst, TEXT("userSid"));
        }
        else
        {
            hr = SetParameter(pInInst, TEXT("userSid"), m_szUserName);
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }
    }
    else if ( IsPlanningModeAllowed() )
    {
        // set up planning mode
        // build a path to the DC: "\\\\dc\\root\\rsop"
        _stprintf(szBuffer, TEXT("\\\\%s\\root\\rsop"), m_szDC);
        bstrParam = SysAllocString(szBuffer);
        hr = pLocator->ConnectServer(bstrParam,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: ConnectServer failed with 0x%x"), hr));
            ReportError (hDlg, hr, IDS_CONNECTSERVERFAILED, m_szDC);
            goto Cleanup;
        }

        bstrClassPath = SysAllocString(TEXT("RsopPlanningModeProvider"));
        hr = pNamespace->GetObject(bstrClassPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &pClass,
                                   NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: GetObject failed with 0x%x"), hr));
            goto Cleanup;
        }

        bstrMethodName = SysAllocString(TEXT("RsopCreateSession"));
        hr = pClass->GetMethod(bstrMethodName,
                               0,
                               &pInClass,
                               NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: GetMethod failed with 0x%x"), hr));
            goto Cleanup;
        }

        hr = pInClass->SpawnInstance(0, &pInInst);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SpawnInstance failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_bSlowLink)
        {
            uiFlags |= FLAG_ASSUME_SLOW_LINK;
        }

        if (!bSkipCSEs || bUser)
        {
            switch (m_loopbackMode)
            {
            case LoopbackReplace:
                uiFlags |= FLAG_LOOPBACK_REPLACE;
                break;
            case LoopbackMerge:
                uiFlags |= FLAG_LOOPBACK_MERGE;
                break;
            default:
                break;
            }
        }

        if (bSkipCSEs)
        {
            uiFlags |= (FLAG_NO_GPO_FILTER | FLAG_NO_CSE_INVOKE);
        }
        else {
            if (m_bSkipComputerWQLFilter) {
                uiFlags |= FLAG_ASSUME_COMP_WQLFILTER_TRUE;
            }

            if (m_bSkipUserWQLFilter) {
                uiFlags |= FLAG_ASSUME_USER_WQLFILTER_TRUE;
            }
        }

        hr = SetParameter(pInInst, TEXT("flags"), uiFlags);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        //
        // If this method is being called to generate temporary rsop data for the
        // wmi filter UI, we only want to initialize half of the args (either user
        // or computer).  Decide if we want to set the computer information here.
        //

        bSetData = TRUE;

        if (bLimitData)
        {
            if (bUser && (LoopbackNone == m_loopbackMode))
            {
                bSetData = FALSE;
            }
        }

        if (m_szComputerName && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("computerName"), m_szComputerName);
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("computerName"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_szComputerSOM && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("computerSOM"), m_szComputerSOM);
        }
        else
        {
            hr = SetParameterToNull (pInInst, TEXT("computerSOM"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_saComputerSecurityGroups && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("computerSecurityGroups"), m_saComputerSecurityGroups);
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("computerSecurityGroups"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_saComputerWQLFilters && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("computerGPOFilters"), m_saComputerWQLFilters);
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("computerGPOFilters"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }


        //
        // If this method is being called to generate temporary rsop data for the
        // wmi filter UI, we only want to initialize half of the args (either user
        // or computer).  Decide if we want to set the user information here.
        //

        bSetData = TRUE;

        if (bLimitData)
        {
            if (!bUser)
            {
                bSetData = FALSE;
            }
        }

        if (m_szUserName && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("userName"), m_szUserName);
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("userName"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_szUserSOM && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("userSOM"), m_szUserSOM);
        }
        else
        {
            hr = SetParameterToNull (pInInst, TEXT("userSOM"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_saUserSecurityGroups && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("userSecurityGroups"), m_saUserSecurityGroups);
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("userSecurityGroups"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_saUserWQLFilters && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("userGPOFilters"), m_saUserWQLFilters);
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("userGPOFilters"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if (m_szSite)
        {
            hr = SetParameter(pInInst, TEXT("site"), m_szSite);
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("site"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed because planning mode view is not implemented on non-server SKUs")));
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    hr = CoCreateInstance(CLSID_UnsecuredApartment, NULL, CLSCTX_ALL,
                          IID_IUnsecuredApartment, (void **)&pSpawner);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CoCreateInstance for unsecure apartment failed with 0x%x"), hr));
        goto Cleanup;
    }


    pCSS = new CCreateSessionSink (hDlg ? GetDlgItem(hDlg, IDC_PROGRESS1) : NULL, GetCurrentThreadId());

    if (!pCSS)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: Failed to create createsessionsink")));
        goto Cleanup;
    }


    hr = pSpawner->CreateObjectStub(pCSS, &pSubstitute);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CreateObjectStub failed with 0x%x"), hr));
        goto Cleanup;
    }

    hr = pSubstitute->QueryInterface(IID_IWbemObjectSink, (LPVOID *)&pSubstituteSink);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: QI failed with 0x%x"), hr));
        goto Cleanup;
    }


    // Set the proper security to prevent the ExecMethod call from failing
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_CALL,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Cleanup;
    }

    pCSS->SendQuitMessage (TRUE);

    hr = pNamespace->ExecMethodAsync(bstrClassPath,
                                     bstrMethodName,
                                     WBEM_FLAG_SEND_STATUS,
                                     NULL,
                                     pInInst,
                                     pSubstituteSink);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: ExecMethodAsync failed with 0x%x"), hr));
        pCSS->SendQuitMessage (FALSE);
        goto Cleanup;
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    pCSS->SendQuitMessage (FALSE);
    pCSS->GetResult (&hrSuccess);
    pCSS->GetErrorInfo (pulErrorInfo);

    if (SUCCEEDED(hrSuccess))
    {
        LPTSTR lpComputerName;
        BSTR bstrNamespace = NULL;

        pCSS->GetNamespace (&bstrNamespace);

        if (bstrNamespace)
        {
            if (m_bDiagnostic)
            {
                lpComputerName = NameWithoutDomain(m_szComputerName);
            }
            else
            {
                lpComputerName = m_szDC;
            }

            *lpNameSpace = new TCHAR[_tcslen(bstrNamespace) + _tcslen(lpComputerName) + 1];

            if (*lpNameSpace)
            {
                lstrcpy (*lpNameSpace, TEXT("\\\\"));
                lstrcat (*lpNameSpace, lpComputerName);
                lstrcat (*lpNameSpace, (bstrNamespace+3));

                DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::GenerateRSOPData: Complete namespace is: %s"), *lpNameSpace));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    }
    else
    {
        hr = hrSuccess;
        if (hDlg)
        {
            SendMessage (GetDlgItem(hDlg, IDC_PROGRESS1), PBM_SETPOS, 0, 0);
        }
        goto Cleanup;
    }

Cleanup:
    SysFreeString(bstrParam);
    SysFreeString(bstrClassPath);
    SysFreeString(bstrMethodName);

    if (pInInst)
    {
        pInInst->Release();
    }

    if (pOutInst)
    {
        pOutInst->Release();
    }

    if (pInClass)
    {
        pInClass->Release();
    }

    if (pClass)
    {
        pClass->Release();
    }

    if (pNamespace)
    {
        pNamespace->Release();
    }

    if (pLocator)
    {
        pLocator->Release();
    }

    if (pSubstitute)
    {
        pSubstitute->Release();
    }

    if (pSubstituteSink)
    {
        pSubstituteSink->Release();
    }

    if (pSpawner)
    {
        pSpawner->Release();
    }

    if (pCSS)
    {
        pCSS->Release();
    }

    return hr;
}


HRESULT CRSOPComponentData::SetupPropertyPages(DWORD dwFlags, LPPROPERTYSHEETCALLBACK lpProvider,
                                               LONG_PTR handle, LPDATAOBJECT lpDataObject)
{
    HRESULT hr = E_FAIL;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage;
    TCHAR szTitle[150];
    TCHAR szSubTitle[300];
    BOOL  bShowNow;
    
    HPROPSHEETPAGE hShowNowPages[20];
    DWORD          dwCount=0, dwDiagStartPage = 0, dwPlanStartPage = 0, dwDiagFinishPage = 0, dwPlanFinishPage = 0;



    hr = this->SetupFonts();
    if (FAILED(hr))
        return hr;


    bShowNow = (!(dwFlags & RSOP_NOMSC));

    if (bShowNow || (IsSnapInManager(lpDataObject) == S_OK))
    {
        //
        // Create the wizard property sheets
        //

        //
        // Welcome sheet and the mode are only applicable in no override mode
        //

        if (!bShowNow) {
//            LoadString (g_hInstance, IDS_TITLE_WELCOME, szTitle, ARRAYSIZE(szTitle));
            psp.dwSize = sizeof(PROPSHEETPAGE);
//            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.dwFlags = PSP_HIDEHEADER;
             
            psp.hInstance = g_hInstance;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_WELCOME);
            psp.pfnDlgProc = RSOPWelcomeDlgProc;
            psp.lParam = (LPARAM) this;
            //psp.pszHeaderTitle = szTitle;
            psp.pszHeaderTitle = NULL;
            psp.pszHeaderSubTitle = NULL;

            hPage = CreatePropertySheetPage(&psp);

            if (!hPage)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                          GetLastError()));
                return E_FAIL;
            }


            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }

            LoadString (g_hInstance, IDS_TITLE_CHOOSEMODE, szTitle, ARRAYSIZE(szTitle));
            LoadString (g_hInstance, IDS_SUBTITLE_CHOOSEMODE, szSubTitle, ARRAYSIZE(szSubTitle));
            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.hInstance = g_hInstance;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_CHOOSEMODE);
            psp.pfnDlgProc = RSOPChooseModeDlgProc;
            psp.lParam = (LPARAM) this;
            psp.pszHeaderTitle = szTitle;
            psp.pszHeaderSubTitle = szSubTitle;

            hPage = CreatePropertySheetPage(&psp);

            if (!hPage)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                          GetLastError()));
                return E_FAIL;
            }

            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }

        LoadString (g_hInstance, IDS_TITLE_GETCOMP, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_GETCOMP, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GETCOMP);
        psp.pfnDlgProc = RSOPGetCompDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwDiagStartPage = dwCount;
            dwCount++;
        }

        LoadString (g_hInstance, IDS_TITLE_GETUSER, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_GETUSER, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GETUSER);
        psp.pfnDlgProc = RSOPGetUserDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwCount++;
        }



        LoadString (g_hInstance, IDS_TITLE_GETTARGET, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_GETTARGET, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GETTARGET);
        psp.pfnDlgProc = RSOPGetTargetDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwPlanStartPage = dwCount;
            dwCount++;
        }


        LoadString (g_hInstance, IDS_TITLE_GETDC, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_GETDC, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GETDC);
        psp.pfnDlgProc = RSOPGetDCDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwCount++;
        }


        LoadString (g_hInstance, IDS_TITLE_ALTDIRS, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_ALTDIRS, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_ALTDIRS);
        psp.pfnDlgProc = RSOPAltDirsDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwCount++;
        }



        LoadString (g_hInstance, IDS_TITLE_USERSECGRPS, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_USERSECGRPS, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_ALTUSERSEC);
        psp.pfnDlgProc = RSOPAltUserSecDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwCount++;
        }


        LoadString (g_hInstance, IDS_TITLE_COMPSECGRPS, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_COMPSECGRPS, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_ALTCOMPSEC);
        psp.pfnDlgProc = RSOPAltCompSecDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwCount++;
        }


        LoadString (g_hInstance, IDS_TITLE_WQLUSER, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_WQL, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_WQLUSER);
        psp.pfnDlgProc = RSOPWQLUserDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwCount++;
        }


        LoadString (g_hInstance, IDS_TITLE_WQLCOMP, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_WQL, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_WQLCOMP);
        psp.pfnDlgProc = RSOPWQLCompDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwCount++;
        }

        LoadString (g_hInstance, IDS_TITLE_FINISHED, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_FINISHED, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_FINISHED);
        psp.pfnDlgProc = RSOPFinishedDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwDiagFinishPage = dwCount;
            dwCount++;
        }


        LoadString (g_hInstance, IDS_TITLE_FINISHED, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SUBTITLE_FINISHED, szSubTitle, ARRAYSIZE(szSubTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_FINISHED3);
        psp.pfnDlgProc = RSOPFinishedDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = szSubTitle;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwPlanFinishPage = dwCount;
            dwCount++;
        }

        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_HIDEHEADER;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_FINISHED2);
        psp.pfnDlgProc = RSOPFinished2DlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = NULL;
        psp.pszHeaderSubTitle = NULL;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        if (!bShowNow) {
            hr = lpProvider->AddPage(hPage);

            if (FAILED(hr))
            {
                return hr;
            }
        }
        else {
            hShowNowPages[dwCount] = hPage;
            dwCount++;
        }


        if (bShowNow) {
            INT_PTR         iRet;
            PROPSHEETHEADER psph;

            psph.dwSize = sizeof(PROPSHEETHEADER);

            psph.dwFlags = PSH_WIZARD97 | PSH_HEADER | PSH_WATERMARK;
            /*PSH_NOCONTEXTHELP | PSH_NOAPPLYNOW | PSH_WIZARD | PSH_WIZARD97 |
                           PSH_STRETCHWATERMARK | PSH_HEADER |  PSH_USEHBMHEADER |*/

            psph.hwndParent = NULL;
            psph.hInstance = g_hInstance;
            psph.nPages = dwCount;

//            psph.hbmHeader = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_HEADER));
            psph.pszbmHeader = MAKEINTRESOURCE(IDB_HEADER);
            psph.pszbmWatermark = MAKEINTRESOURCE(IDB_WIZARD);
            //psph.hbmWatermark = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_WIZARD));

/*
            if (!psph.hbmHeader) {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: couldn't load bitmap. Error %d."), GetLastError()));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::CreatePropertyPages: loaded bitmap")));
            }
*/

            if (dwFlags & RSOPMSC_OVERRIDE) {   
                psph.nStartPage = m_bDiagnostic ? dwDiagStartPage : dwPlanStartPage;
                DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::CreatePropertyPages: Showing prop sheet in override mode.")));
            }
            else {
                psph.nStartPage = m_bDiagnostic ? dwDiagFinishPage : dwPlanFinishPage;
                DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::CreatePropertyPages: Showing prop sheet in no override mode.")));
            }

            psph.phpage  = hShowNowPages;


            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::CreatePropertyPages: Showing prop sheet.")));
            iRet = PropertySheet(&psph);

            if (iRet == -1) {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: PropertySheet failed with error %d."),
                          GetLastError()));
            }

            // user cancelled in the wizard
            if (iRet != IDOK) {
                return S_FALSE;
            }
            else {
                return S_OK;
            }
        }
    }
    else
    {
        BOOL fRoot, fMachine, fUser;
        hr = IsNode(lpDataObject, 0); // check for root node
        fRoot = (S_OK == hr);
        hr = IsNode(lpDataObject, 1); // check for machine node
        fMachine = (S_OK == hr);
        hr = IsNode(lpDataObject, 2); // check for user
        fUser = (S_OK == hr);
        hr = E_FAIL;
        if (fMachine || fUser)
        {
            //
            // Create the GPO property sheet
            //

            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = 0;
            psp.hInstance = g_hInstance;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GPOLIST);
            psp.pfnDlgProc = fMachine ? RSOPGPOListMachineProc : RSOPGPOListUserProc;
            psp.lParam = (LPARAM) this;

            hPage = CreatePropertySheetPage(&psp);

            if (!hPage)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                          GetLastError()));
                return E_FAIL;
            }

            hr = lpProvider->AddPage(hPage);


            //
            // Create the Error information property sheet
            //

            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = 0;
            psp.hInstance = g_hInstance;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_ERRORS);
            psp.pfnDlgProc = fMachine ? RSOPErrorsMachineProc : RSOPErrorsUserProc;
            psp.lParam = (LPARAM) this;

            hPage = CreatePropertySheetPage(&psp);

            if (!hPage)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                          GetLastError()));
                return E_FAIL;
            }

            hr = lpProvider->AddPage(hPage);

        }

        if (fRoot)
        {
            //
            // Create the GPO property sheet
            //
    
            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = 0;
            psp.hInstance = g_hInstance;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_QUERY);
            psp.pfnDlgProc = QueryDlgProc;
            psp.lParam = (LPARAM) this;
    
            hPage = CreatePropertySheetPage(&psp);
    
            if (!hPage)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                          GetLastError()));
                return E_FAIL;
            }
    
            hr = lpProvider->AddPage(hPage);
        }
    }
    
    return S_OK;
}

HRESULT CRSOPComponentData::InitializeRSOPFromMSC(DWORD dwFlags)
{
    HRESULT hr;
    hr = SetupPropertyPages(dwFlags, NULL, NULL, NULL);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOP: SetupPropertyPages failed with 0x%x"), hr));
    }
  
    if (hr == S_FALSE) {
        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::InitializeRSOP: User cancelled in the init wizard")));
    }

    return hr;
}

HRESULT CRSOPComponentData::InitializeRSOP(HWND hDlg)
{
    HRESULT hr;

    hr = GenerateRSOPDataEx (hDlg, &m_szNamespace);

    if (SUCCEEDED(hr))
    {
        m_bInitialized = TRUE;

        BuildGPOLists();
        BuildCSELists();

        if (m_pEvents)
        {
            m_pEvents->DumpDebugInfo();
        }

        if (hDlg)
        {
            SetDirty();
        }

        BuildDisplayName();
    }
    else
    {
        m_bInitialized = FALSE;
    }

    return hr;
}

STDMETHODIMP CRSOPComponentData::BuildDisplayName (void)
{
    TCHAR szArchiveData[100];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szComputerName[100];
    LPTSTR lpUserName, lpComputerName, lpEnd;
    LPTSTR lpUserOU = NULL, lpComputerOU = NULL;
    DWORD dwSize;
    int n;


    //
    // Make the display name (needs to handle empty names)
    //

    if (m_bViewIsArchivedData)
    {
        LoadString(g_hInstance, IDS_ARCHIVEDATATAG, szArchiveData, ARRAYSIZE(szArchiveData));
    }
    else
    {
        szArchiveData[0] = TEXT('\0');
    }


    if (m_szUserDisplayName && !m_bNoUserData)
    {
        lpUserName = NameWithoutDomain(m_szUserDisplayName);
    }
    else if (m_szUserName && !m_bNoUserData)
    {
        lpUserName = NameWithoutDomain(m_szUserName);
    }
    else if (m_szUserSOM && !m_bNoUserData)
    {
        lpUserOU = GetContainerFromLDAPPath (m_szUserSOM);
        lpUserName = lpUserOU;
    }
    else
    {
        lpUserName =  NULL;
    }

    if (m_szComputerName && !m_bNoComputerData)
    {
        if (!lstrcmpi(m_szComputerName, TEXT(".")))
        {
            szComputerName[0] = TEXT('\0');
            dwSize = ARRAYSIZE(szComputerName);
            GetComputerNameEx (ComputerNameNetBIOS, szComputerName, &dwSize);
            lpComputerName = szComputerName;
        }
        else
        {
            lstrcpyn (szComputerName, NameWithoutDomain(m_szComputerName),
                      ARRAYSIZE(szComputerName));

            lpComputerName = szComputerName;

            lpEnd = lpComputerName + lstrlen(lpComputerName) - 1;

            if (*lpEnd == TEXT('$'))
            {
                *lpEnd =  TEXT('\0');
            }

        }
    }
    else if (m_szComputerSOM && !m_bNoComputerData)
    {
        lpComputerOU = GetContainerFromLDAPPath (m_szComputerSOM);
        lpComputerName = lpComputerOU;
    }
    else
    {
        lpComputerName =  NULL;
    }


    if (lpUserName && lpComputerName)
    {
        LoadString(g_hInstance, IDS_RSOP_DISPLAYNAME1, szBuffer, ARRAYSIZE(szBuffer));

        n = wcslen(szBuffer) + wcslen (szArchiveData) +
            wcslen(lpUserName) + wcslen(lpComputerName) + 1;

        m_pDisplayName = new WCHAR[n];

        if (m_pDisplayName)
        {
            wsprintf(m_pDisplayName, szBuffer, lpUserName, lpComputerName);
        }
    }
    else if (lpUserName && !lpComputerName)
    {
        LoadString(g_hInstance, IDS_RSOP_DISPLAYNAME2, szBuffer, ARRAYSIZE(szBuffer));

        n = wcslen(szBuffer) + wcslen (szArchiveData) +
            wcslen(lpUserName) + 1;

        m_pDisplayName = new WCHAR[n];

        if (m_pDisplayName)
        {
            wsprintf(m_pDisplayName, szBuffer, lpUserName);
        }
    }
    else
    {
        LoadString(g_hInstance, IDS_RSOP_DISPLAYNAME2, szBuffer, ARRAYSIZE(szBuffer));

        n = wcslen(szBuffer) + wcslen (szArchiveData) +
            (lpComputerName ? wcslen(lpComputerName) : 0) + 1;

        m_pDisplayName = new WCHAR[n];

        if (m_pDisplayName)
        {
            wsprintf(m_pDisplayName, szBuffer, (lpComputerName ? lpComputerName : L""));
        }
    }


    if (m_pDisplayName && m_bViewIsArchivedData)
    {
        lstrcat (m_pDisplayName, szArchiveData);
    }

    if (lpUserOU)
    {
        delete [] lpUserOU;
    }

    if (lpComputerOU)
    {
        delete [] lpComputerOU;
    }


    return S_OK;
}


STDMETHODIMP CRSOPComponentData::CopyMSCToFile (IStream *pStm, LPTSTR *lpMofFileName)
{
    HRESULT hr;
    LPTSTR lpFileName;
    ULARGE_INTEGER FileSize, SubtractAmount;
    ULONG nBytesRead;
    LPBYTE lpData;
    DWORD dwError, dwReadAmount, dwRead, dwBytesWritten;
    HANDLE hFile;


    //
    // Get the filename to work with
    //

    lpFileName = CreateTempFile();

    if (!lpFileName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to create temp filename with %d"), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // Read in the data length
    //

    hr = pStm->Read(&FileSize, sizeof(FileSize), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(FileSize)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to read data size with 0x%x."), hr));
        return E_FAIL;
    }


    //
    // Allocate a buffer to use for the transfer
    //

    lpData = (LPBYTE) LocalAlloc (LPTR, 4096);

    if (!lpData)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to allocate memory with %d."), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // Open the temp file
    //

    hFile = CreateFile (lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: CreateFile for %s failed with %d"), lpFileName, dwError));
        LocalFree (lpData);
        return HRESULT_FROM_WIN32(dwError);
    }


    while (FileSize.QuadPart)
    {

        //
        // Determine how much to read
        //

        dwReadAmount = (FileSize.QuadPart > 4096) ? 4096 : FileSize.LowPart;


        //
        // Read from the msc file
        //

        hr = pStm->Read(lpData, dwReadAmount, &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != dwReadAmount))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Read failed with 0x%x"), hr));
            LocalFree (lpData);
            CloseHandle (hFile);
            return hr;
        }


        //
        // Write to the temp file
        //

        if (!WriteFile(hFile, lpData, dwReadAmount, &dwBytesWritten, NULL))
        {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to write data with %d."), dwError));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(dwError);
        }

        if (dwBytesWritten != dwReadAmount)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to write the correct amount of data.")));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        SubtractAmount.LowPart = dwReadAmount;
        SubtractAmount.HighPart = 0;

        FileSize.QuadPart = FileSize.QuadPart - SubtractAmount.QuadPart;
    }


    CloseHandle (hFile);
    LocalFree (lpData);

    *lpMofFileName = lpFileName;

    return S_OK;
}

STDMETHODIMP CRSOPComponentData::CreateNameSpace (LPTSTR lpNameSpace, LPTSTR lpParentNameSpace)
{
    IWbemLocator *pIWbemLocator;
    IWbemServices *pIWbemServices;
    IWbemClassObject *pIWbemClassObject = NULL, *pObject = NULL;
    VARIANT var;
    BSTR bstrName, bstrNameProp;
    HRESULT hr;


    //
    // Create a locater instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: CoCreateInstance failed with 0x%x"), hr));
        return hr;
    }


    //
    // Connect to the server
    //

    hr = pIWbemLocator->ConnectServer(lpParentNameSpace, NULL, NULL, 0, 0, NULL, NULL, &pIWbemServices);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: ConnectServer to %s failed with 0x%x"), lpNameSpace, hr));
        pIWbemLocator->Release();
        return hr;
    }


    //
    // Get the namespace class
    //

    bstrName = SysAllocString (TEXT("__Namespace"));

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: SysAllocString failed with %d"), GetLastError()));
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }

    hr = pIWbemServices->GetObject( bstrName, 0, NULL, &pIWbemClassObject, NULL);

    SysFreeString (bstrName);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: GetObject failed with 0x%x"), hr));
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }


    //
    // Spawn Instance
    //

    hr = pIWbemClassObject->SpawnInstance(0, &pObject);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: SpawnInstance failed with 0x%x"), hr));
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }


    //
    // Convert new namespace to a bstr
    //

    bstrName = SysAllocString (lpNameSpace);

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: SysAllocString failed with %d"), GetLastError()));
        pObject->Release();
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }


    //
    // Set the display name
    //

    var.vt = VT_BSTR;
    var.bstrVal = bstrName;

    bstrNameProp = SysAllocString (TEXT("Name"));

    if (!bstrNameProp)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: SysAllocString failed with %d"), GetLastError()));
        pObject->Release();
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }


    hr = pObject->Put( bstrNameProp, 0, &var, 0 );

    SysFreeString (bstrNameProp);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: Put failed with 0x%x"), hr));
        SysFreeString (bstrName);
        pObject->Release();
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }


    //
    // Commit the instance
    //

    hr = pIWbemServices->PutInstance( pObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: PutInstance failed with 0x%x"), hr));
    }

    SysFreeString (bstrName);
    pObject->Release();
    pIWbemServices->Release();
    pIWbemLocator->Release();

    return hr;
}

STDMETHODIMP CRSOPComponentData::InitializeRSOPFromArchivedData(IStream *pStm)
{
    HRESULT hr;
    TCHAR szNameSpace[100];
    GUID guid;
    LPTSTR lpEnd, lpFileName, lpTemp;


    //
    // Create a guid to work with
    //

    hr = CoCreateGuid( &guid );

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CoCreateGuid failed with 0x%x"), hr));
        return hr;
    }

    wsprintf( m_szArchivedDataGuid,
              L"NS%08lX_%04X_%04X_%02X%02X_%02X%02X%02X%02X%02X%02X",
              guid.Data1,
              guid.Data2,
              guid.Data3,
              guid.Data4[0], guid.Data4[1],
              guid.Data4[2], guid.Data4[3],
              guid.Data4[4], guid.Data4[5],
              guid.Data4[6], guid.Data4[7] );

    lstrcpy (szNameSpace, TEXT("\\\\.\\root\\rsop"));


    //
    // Build the parent namespace
    //

    hr = CreateNameSpace (m_szArchivedDataGuid, szNameSpace);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CreateNameSpace failed with 0x%x"), hr));
        return hr;
    }

    lpEnd = CheckSlash (szNameSpace);
    lstrcpy (lpEnd, m_szArchivedDataGuid);


    //
    // Build the user subnamespace
    //

    hr = CreateNameSpace (TEXT("User"), szNameSpace);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CreateNameSpace failed with 0x%x"), hr));
        return hr;
    }


    //
    // Build the computer subnamespace
    //

    hr = CreateNameSpace (TEXT("Computer"), szNameSpace);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CreateNameSpace failed with 0x%x"), hr));
        return hr;
    }


    //
    // Save the namespace for future use
    //

    m_szNamespace = new TCHAR[(lstrlen(szNameSpace) + 1)];

    if (!m_szNamespace) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Failed to allocate memory with %d"), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lstrcpy (m_szNamespace, szNameSpace);

    DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Namespace name is: %s"), m_szNamespace));



    //
    // Make a copy of the namespace that we can manipulate (to load the data with)
    //

    lpTemp = new TCHAR[(lstrlen(szNameSpace) + 10)];

    if (!lpTemp) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Failed to allocate memory with %d"), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lstrcpy (lpTemp, m_szNamespace);
    lpEnd = CheckSlash (lpTemp);
    lstrcpy (lpEnd, TEXT("Computer"));


    //
    // Extract the computer data to a temp file
    //

    hr = CopyMSCToFile (pStm, &lpFileName);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CopyMSCToFile failed with 0x%x"), hr));
        return hr;
    }


    //
    // Use the mof compiler to pull the data from the file and put it in the
    // new namespace
    //

    hr = ImportRSoPData (lpTemp, lpFileName);

    DeleteFile (lpFileName);
    delete [] lpFileName;

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: ImportRSoPData failed with 0x%x"), hr));
        return hr;
    }


    //
    // Now extract the user data to a temp file
    //

    lstrcpy (lpEnd, TEXT("User"));


    hr = CopyMSCToFile (pStm, &lpFileName);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CopyMSCToFile failed with 0x%x"), hr));
        return hr;
    }


    //
    // Use the mof compiler to pull the data from the file and put it in the
    // new namespace
    //

    hr = ImportRSoPData (lpTemp, lpFileName);

    DeleteFile (lpFileName);
    delete [] lpFileName;

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: ImportRSoPData failed with 0x%x"), hr));
        return hr;
    }

    delete [] lpTemp;


    //
    // Pull the event log information and initialize the database
    //

    hr = m_pEvents->LoadEntriesFromStream(pStm);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: LoadEntriesFromStream failed with 0x%x."), hr));
        return hr;
    }


    //
    // Build the common data structures used by various property sheets
    //

    BuildGPOLists();
    BuildCSELists();

    if (m_pEvents)
    {
        m_pEvents->DumpDebugInfo();
    }


    //
    // Build the display name
    //

    BuildDisplayName();

    m_bInitialized = TRUE;

    return S_OK;
}


//************************************************************************
//  ParseCommandLine
//
//  Purpose:    Parse the command line to return the value associated with options
//
//  Parameters:
//          szCommandLine   - Part remaining in the unparsed command lines
//          szArgPrefix     - Argument prefix
//          szArgVal        - Argument value. expected in unescaped quotes
//          pbFoundArg      - Whether the argument was found or not
// 
// 
//  Return
//          The remaining cmd line
//
//************************************************************************

LPTSTR ParseCommandLine(LPTSTR szCommandLine, LPTSTR szArgPrefix, LPTSTR *szArgVal, BOOL *pbFoundArg)
{
    LPTSTR lpEnd = NULL;
    int    iTemp;

    iTemp = lstrlen (szArgPrefix);
    if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                   szArgPrefix, iTemp,
                   szCommandLine, iTemp) == CSTR_EQUAL)
    {
        *pbFoundArg = TRUE;
    
         //
         // Found the switch
         //
        
         szCommandLine += iTemp + 1;
        
         lpEnd = szCommandLine;
         while (*lpEnd && 
                (!( ( (*(lpEnd-1)) != TEXT('\\') ) && ( (*lpEnd) == TEXT('\"') ) ) ) ) /* look for an unesced quote */
             lpEnd++;
        
         // lpEnd is at the end or at the last quote
         *szArgVal = (LPTSTR) LocalAlloc (LPTR, ((lpEnd - szCommandLine) + 1) * sizeof(TCHAR));
        
         if (*szArgVal)
         {
             lstrcpyn (*szArgVal, szCommandLine, (int)((lpEnd - szCommandLine) + 1));
             DebugMsg((DM_VERBOSE, TEXT("ParseCOmmandLine: Argument %s = <%s>"), szArgPrefix, *szArgVal));
         }
        
         if ((*lpEnd) == TEXT('\"'))
             szCommandLine = lpEnd+1;
         
    }
    else
         *pbFoundArg = FALSE;

    return szCommandLine;
}

STDMETHODIMP CRSOPComponentData::Load(IStream *pStm)
{
    HRESULT hr = E_FAIL;
    DWORD dwVersion, dwFlags;
    ULONG nBytesRead;
    SAFEARRAYBOUND rgsabound[1];
    LONG lIndex, lMax;
    LPTSTR lpText = NULL;
    BSTR bstrText;
    LPTSTR lpCommandLine = NULL;
    LPTSTR lpTemp, lpMode;
    BOOL   bFoundArg;
    int    iStrLen;



    //
    // Parameter / initialization check
    //

    if (!pStm)
        return E_FAIL;

    //
    // Get the command line
    //

    lpCommandLine = GetCommandLine();


    //
    // Read in the saved data version number
    //

    hr = pStm->Read(&dwVersion, sizeof(dwVersion), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read version number with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Confirm that we are working with the correct version
    //

    if (dwVersion != RSOP_PERSIST_DATA_VERSION)
    {
        ReportError(m_hwndFrame, 0, IDS_INVALIDMSC);
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Wrong version number (%d)."), dwVersion));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read the flags
    //

    hr = pStm->Read(&dwFlags, sizeof(dwFlags), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwFlags)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read flags with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Parse the command line
    //

    DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Command line switch override enabled.  Command line = %s"), lpCommandLine));

    lpTemp = lpCommandLine;
    iStrLen = lstrlen (RSOP_CMD_LINE_START);

    do
    {
        if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                          RSOP_CMD_LINE_START, iStrLen,
                          lpTemp, iStrLen) == CSTR_EQUAL)
        {

            m_bOverride = TRUE;
            m_dwLoadFlags = RSOPMSC_OVERRIDE;
            lpTemp = ParseCommandLine(lpTemp, RSOP_MODE, &lpMode, &bFoundArg);

            if (bFoundArg) {
                if (lpMode && lpMode[0]) {
                    m_bDiagnostic = (_ttoi(lpMode) == 0);
                }
                else {
                    m_bDiagnostic = FALSE;
                }

                if (lpMode) {
                    LocalFree(lpMode);
                }

                m_bOverride = TRUE;
                continue;
            }


            lpTemp = ParseCommandLine(lpTemp, RSOP_USER_OU_PREF, &m_szUserSOMPref, &bFoundArg);

            if (bFoundArg) {
                continue;
            }
           
            lpTemp = ParseCommandLine(lpTemp, RSOP_COMP_OU_PREF, &m_szComputerSOMPref, &bFoundArg);

            if (bFoundArg) {
                continue;
            }
           
            lpTemp = ParseCommandLine(lpTemp, RSOP_USER_NAME, &m_szUserNamePref, &bFoundArg);

            if (bFoundArg) {
                continue;
            }
           
            lpTemp = ParseCommandLine(lpTemp, RSOP_COMP_NAME, &m_szComputerNamePref, &bFoundArg);

            if (bFoundArg) {
                continue;
            }
           
            lpTemp = ParseCommandLine(lpTemp, RSOP_SITENAME, &m_szSitePref, &bFoundArg);

            if (bFoundArg) {
                continue;
            }

            lpTemp = ParseCommandLine(lpTemp, RSOP_DCNAME_PREF, &m_szDCPref, &bFoundArg);

            if (bFoundArg) {
                continue;
            }

            lpTemp += iStrLen;
            continue;
        }
        lpTemp++;

    } while (*lpTemp);
        
    
    if (!m_bOverride) {
        m_dwLoadFlags = RSOPMSC_NOOVERRIDE;

        m_bOverride = FALSE;

        if (dwFlags & MSC_RSOP_FLAG_DIAGNOSTIC)
        {
            m_bDiagnostic = TRUE;
        }
    
    
        if (dwFlags & MSC_RSOP_FLAG_ARCHIVEDATA)
        {
            m_bArchiveData = TRUE;
            m_bViewIsArchivedData = TRUE;
        }
    
    
        if (dwFlags & MSC_RSOP_FLAG_SLOWLINK)
        {
            m_bSlowLink = TRUE;
        }
        
        if (dwFlags & MSC_RSOP_FLAG_LOOPBACK_REPLACE)
        {
            m_loopbackMode = LoopbackReplace;
        }
        else if (dwFlags & MSC_RSOP_FLAG_LOOPBACK_MERGE)
        {
            m_loopbackMode = LoopbackMerge;
        }
        else
        {
            m_loopbackMode = LoopbackNone;
        }
  
    
        if (dwFlags & MSC_RSOP_FLAG_NOUSER)
        {
            m_bNoUserData = TRUE;
        }
    
    
        if (dwFlags & MSC_RSOP_FLAG_NOCOMPUTER)
        {
            m_bNoComputerData = TRUE;
        }


        if (dwFlags & MSC_RSOP_FLAG_USERDENIED)
        {
            m_bUserDeniedAccess = TRUE;
        }


        if (dwFlags & MSC_RSOP_FLAG_COMPUTERDENIED)
        {
            m_bComputerDeniedAccess = TRUE;
        }


        //
        // Read the computer name
        //
    
        hr = ReadString (pStm, &m_szComputerName);
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the computer name with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read the computer SOM
        //
    
        hr = ReadString (pStm, &m_szComputerSOM);
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the computer SOM with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read in the security group count
        //
    
        hr = pStm->Read(&lMax, sizeof(lMax), &nBytesRead);
    
        if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read security group count with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read in the security groups
        //
    
        if (lMax)
        {
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = lMax + 1;
    
            m_saComputerSecurityGroups = SafeArrayCreate (VT_BSTR, 1, rgsabound);
    
            if (m_saComputerSecurityGroups)
            {
                for (lIndex = 0; lIndex <= lMax; lIndex++)
                {
                    hr = ReadString (pStm, &lpText);
    
                    if (hr != S_OK)
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read security group with 0x%x."), hr));
                        hr = E_FAIL;
                        goto Exit;
                    }
    
                    bstrText = SysAllocString (lpText);
                    if (bstrText)
                    {
                        hr = SafeArrayPutElement(m_saComputerSecurityGroups, &lIndex, bstrText);
    
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: SafeArrayPutElement failed with 0x%x."), hr));
                            goto Exit;
                        }
                    }
    
                    delete [] lpText;
                }
            }
        }
    
    
        //
        // Read in the WQL filter count
        //
    
        hr = pStm->Read(&lMax, sizeof(lMax), &nBytesRead);
    
        if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read wql filter count with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read in the WQL filters
        //
    
        if (lMax)
        {
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = lMax + 1;
    
            m_saComputerWQLFilters = SafeArrayCreate (VT_BSTR, 1, rgsabound);
    
            if (m_saComputerWQLFilters)
            {
                for (lIndex = 0; lIndex <= lMax; lIndex++)
                {
                    hr = ReadString (pStm, &lpText);
    
                    if (hr != S_OK)
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read wql filter with 0x%x."), hr));
                        hr = E_FAIL;
                        goto Exit;
                    }
    
                    bstrText = SysAllocString (lpText);
                    if (bstrText)
                    {
                        hr = SafeArrayPutElement(m_saComputerWQLFilters, &lIndex, bstrText);
    
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: SafeArrayPutElement failed with 0x%x."), hr));
                            goto Exit;
                        }
                    }
    
                    delete [] lpText;
                }
            }
        }
    
    
        //
        // Read in the WQL filter name count
        //
    
        hr = pStm->Read(&lMax, sizeof(lMax), &nBytesRead);
    
        if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read wql filter name count with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read in the WQL filter names
        //
    
        if (lMax)
        {
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = lMax + 1;
    
            m_saComputerWQLFilterNames = SafeArrayCreate (VT_BSTR, 1, rgsabound);
    
            if (m_saComputerWQLFilterNames)
            {
                for (lIndex = 0; lIndex <= lMax; lIndex++)
                {
                    hr = ReadString (pStm, &lpText);
    
                    if (hr != S_OK)
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read wql filter with 0x%x."), hr));
                        hr = E_FAIL;
                        goto Exit;
                    }
    
                    bstrText = SysAllocString (lpText);
                    if (bstrText)
                    {
                        hr = SafeArrayPutElement(m_saComputerWQLFilterNames, &lIndex, bstrText);
    
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: SafeArrayPutElement failed with 0x%x."), hr));
                            goto Exit;
                        }
                    }
    
                    delete [] lpText;
                }
            }
        }
    
    
        //
        // Read the user name
        //
    
        hr = ReadString (pStm, &m_szUserName);
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the user name with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read the user display name (only used in diagnostic mode)
        //
    
        hr = ReadString (pStm, &m_szUserDisplayName);
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the user display name with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
        if (m_bDiagnostic && !lstrcmpi(m_szUserName, TEXT(".")) && !m_bArchiveData)
        {
            LPTSTR lpTemp;
    
            lpTemp = MyGetUserName (NameSamCompatible);
    
            if (lpTemp)
            {
                if (m_szUserDisplayName)
                {
                    delete [] m_szUserDisplayName;
                }
    
                m_szUserDisplayName = new TCHAR[lstrlen(lpTemp) + 1];
    
                if (m_szUserDisplayName)
                {
                    lstrcpy (m_szUserDisplayName, lpTemp);
                }
    
                LocalFree (lpTemp);
            }
        }
    
    
        //
        // Read the user SOM
        //
    
        hr = ReadString (pStm, &m_szUserSOM);
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the user SOM with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read in the security group count
        //
    
        hr = pStm->Read(&lMax, sizeof(lMax), &nBytesRead);
    
        if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read security group count with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read in the security groups
        //
    
        if (lMax)
        {
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = lMax + 1;
    
            m_saUserSecurityGroups = SafeArrayCreate (VT_BSTR, 1, rgsabound);
    
            if (m_saUserSecurityGroups)
            {
                for (lIndex = 0; lIndex <= lMax; lIndex++)
                {
                    hr = ReadString (pStm, &lpText);
    
                    if (hr != S_OK)
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read security group with 0x%x."), hr));
                        hr = E_FAIL;
                        goto Exit;
                    }
    
                    bstrText = SysAllocString (lpText);
                    if (bstrText)
                    {
                        hr = SafeArrayPutElement(m_saUserSecurityGroups, &lIndex, bstrText);
    
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: SafeArrayPutElement failed with 0x%x."), hr));
                            goto Exit;
                        }
                    }
    
                    delete [] lpText;
                }
            }
        }
    
    
        //
        // Read in the WQL filter count
        //
    
        hr = pStm->Read(&lMax, sizeof(lMax), &nBytesRead);
    
        if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read WQL filter count with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read in the WQL filters
        //
    
        if (lMax)
        {
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = lMax + 1;
    
            m_saUserWQLFilters = SafeArrayCreate (VT_BSTR, 1, rgsabound);
    
            if (m_saUserWQLFilters)
            {
                for (lIndex = 0; lIndex <= lMax; lIndex++)
                {
                    hr = ReadString (pStm, &lpText);
    
                    if (hr != S_OK)
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read wql filters with 0x%x."), hr));
                        hr = E_FAIL;
                        goto Exit;
                    }
    
                    bstrText = SysAllocString (lpText);
                    if (bstrText)
                    {
                        hr = SafeArrayPutElement(m_saUserWQLFilters, &lIndex, bstrText);
    
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: SafeArrayPutElement failed with 0x%x."), hr));
                            goto Exit;
                        }
                    }
    
                    delete [] lpText;
                }
            }
        }
    
    
        //
        // Read in the WQL filter name count
        //
    
        hr = pStm->Read(&lMax, sizeof(lMax), &nBytesRead);
    
        if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read WQL filter name count with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read in the WQL filter names
        //
    
        if (lMax)
        {
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = lMax + 1;
    
            m_saUserWQLFilterNames = SafeArrayCreate (VT_BSTR, 1, rgsabound);
    
            if (m_saUserWQLFilterNames)
            {
                for (lIndex = 0; lIndex <= lMax; lIndex++)
                {
                    hr = ReadString (pStm, &lpText);
    
                    if (hr != S_OK)
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read wql filters with 0x%x."), hr));
                        hr = E_FAIL;
                        goto Exit;
                    }
    
                    bstrText = SysAllocString (lpText);
                    if (bstrText)
                    {
                        hr = SafeArrayPutElement(m_saUserWQLFilterNames, &lIndex, bstrText);
    
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: SafeArrayPutElement failed with 0x%x."), hr));
                            goto Exit;
                        }
                    }
    
                    delete [] lpText;
                }
            }
        }
    
        //
        // Read the site
        //
    
        hr = ReadString (pStm, &m_szSite);
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the site with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
    
        //
        // Read the DC
        //
    
        hr = ReadString (pStm, &m_szDC);
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the dc with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    }
    
    //
    // Read in the WMI data if appropriate
    //

    if (m_bArchiveData)
    {
        m_pStm = pStm;
        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Load: Launching RSOP status dialog box.")));

        if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_RSOP_STATUSMSC),
                           NULL, InitRsopDlgProc, (LPARAM) this ) == -1) {

            m_pStm = NULL;
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Falied to create dialog box. 0x%x"), hr));
            goto Exit;
        }
        m_pStm = NULL;
    }
    else
    {
        //
        // Initialize the snapin
        //

        if (m_dwLoadFlags == RSOPMSC_OVERRIDE) {
            hr = InitializeRSOPFromMSC(m_dwLoadFlags);

            if (hr == S_FALSE) {
                // this is a hack to get mmc to not launch itself when user cancelled the wizard
                DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Load: User cancelled the wizard. Exitting the process")));
                TerminateProcess (GetCurrentProcess(), ERROR_CANCELLED);
            }
            else {
                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: InitializeRSOP failed with 0x%x."), hr));
                    goto Exit;
                }
            }
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Load: Launching RSOP status dialog box.")));

            if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_RSOP_STATUSMSC),
                               NULL, InitRsopDlgProc, (LPARAM) this ) == -1) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Falied to create dialog box. 0x%x"), hr));
                goto Exit;
            }
        }
    }
    
    

Exit:
    return hr;
}

INT_PTR CALLBACK CRSOPComponentData::InitRsopDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;
    HRESULT hr = S_OK;
    TCHAR szMessage[200];


    switch (message)
    {
        case WM_INITDIALOG:
        {
            pCD = (CRSOPComponentData *) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

            if (pCD)
            {
                pCD->InitializeResultsList (GetDlgItem (hDlg, IDC_LIST1));
                pCD->FillResultsList (GetDlgItem (hDlg, IDC_LIST1));
                if (pCD->m_bArchiveData) {
                    LoadString(g_hInstance, IDS_PLEASEWAIT1, szMessage, ARRAYSIZE(szMessage));
                    SetWindowText(GetDlgItem(hDlg, IDC_STATIC1), szMessage);
                    ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS1), SW_HIDE);
                }
            }


            PostMessage(hDlg, WM_INITRSOP, 0, 0);
            return TRUE;
        }

        case WM_INITRSOP:

            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
                        
            if (pCD->m_bArchiveData) {
                hr = pCD->InitializeRSOPFromArchivedData(pCD->m_pStm);

                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitRsopDlgProc: InitializeRSOPFromArchivedData failed with 0x%x."), hr));
                    EndDialog(hDlg, 0);
                    return TRUE;
                }
            }
            else {
                hr = pCD->InitializeRSOP(hDlg);

                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitRsopDlgProc: InitializeRSOP failed with 0x%x."), hr));
                    EndDialog(hDlg, 0);
                    return TRUE;
                }
            }
            EndDialog(hDlg, 1);
            return TRUE;
    }

    return FALSE;
}

STDMETHODIMP CRSOPComponentData::CopyFileToMSC (LPTSTR lpFileName, IStream *pStm)
{
    ULONG nBytesWritten;
    WIN32_FILE_ATTRIBUTE_DATA info;
    ULARGE_INTEGER FileSize, SubtractAmount;
    HANDLE hFile;
    DWORD dwError, dwReadAmount, dwRead;
    LPBYTE lpData;
    HRESULT hr;


    //
    // Get the file size
    //

    if (!GetFileAttributesEx (lpFileName, GetFileExInfoStandard, &info))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to get file attributes with %d."), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    FileSize.LowPart = info.nFileSizeLow;
    FileSize.HighPart = info.nFileSizeHigh;


    //
    // Save the file size
    //

    hr = pStm->Write(&FileSize, sizeof(FileSize), &nBytesWritten);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to write string length with %d."), hr));
        return hr;
    }

    if (nBytesWritten != sizeof(FileSize))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to write the correct amount of data.")));
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }


    //
    // Allocate a buffer to use for the transfer
    //

    lpData = (LPBYTE) LocalAlloc (LPTR, 4096);

    if (!lpData)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to allocate memory with %d."), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // Open the temp file
    //

    hFile = CreateFile (lpFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: CreateFile for %s failed with %d"), lpFileName, dwError));
        LocalFree (lpData);
        return HRESULT_FROM_WIN32(dwError);
    }


    while (FileSize.QuadPart)
    {

        //
        // Determine how much to read
        //

        dwReadAmount = (FileSize.QuadPart > 4096) ? 4096 : FileSize.LowPart;


        //
        // Read from the temp file
        //

        if (!ReadFile (hFile, lpData, dwReadAmount, &dwRead, NULL))
        {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: ReadFile failed with %d"), dwError));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(dwError);
        }


        //
        // Make sure we read enough
        //

        if (dwReadAmount != dwRead)
        {
            dwError = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to read enough data")));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(dwError);
        }


        //
        // Write to the stream
        //

        hr = pStm->Write(lpData, dwReadAmount, &nBytesWritten);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to write data with %d."), hr));
            LocalFree (lpData);
            CloseHandle (hFile);
            return hr;
        }

        if (nBytesWritten != dwReadAmount)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to write the correct amount of data.")));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        SubtractAmount.LowPart = dwReadAmount;
        SubtractAmount.HighPart = 0;

        FileSize.QuadPart = FileSize.QuadPart - SubtractAmount.QuadPart;
    }


    CloseHandle (hFile);
    LocalFree (lpData);

    return S_OK;
}

STDMETHODIMP CRSOPComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr = STG_E_CANTSAVE;
    ULONG nBytesWritten;
    DWORD dwTemp;
    DWORD dwFlags;
    GROUP_POLICY_OBJECT_TYPE gpoType;
    LPTSTR lpPath = NULL;
    LPTSTR lpTemp;
    DWORD dwPathSize = 1024;
    LONG lIndex, lMax;
    LPTSTR lpText;
    LPTSTR lpUserData = NULL, lpComputerData = NULL;
    TCHAR szPath[2*MAX_PATH];


    //
    // Save the version number
    //

    dwTemp = RSOP_PERSIST_DATA_VERSION;

    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write version number with %d."), hr));
        goto Exit;
    }


    //
    // Save the flags
    //

    dwTemp = 0;

    if (m_bDiagnostic)
    {
        dwTemp |= MSC_RSOP_FLAG_DIAGNOSTIC;
    }

    if (m_bArchiveData)
    {
        dwTemp |= MSC_RSOP_FLAG_ARCHIVEDATA;
    }

    if (m_bSlowLink)
    {
        dwTemp |= MSC_RSOP_FLAG_SLOWLINK;
    }
    
    switch (m_loopbackMode)
    {
    case LoopbackReplace:
        dwTemp |= MSC_RSOP_FLAG_LOOPBACK_REPLACE;
        break;
    case LoopbackMerge:
        dwTemp |= MSC_RSOP_FLAG_LOOPBACK_MERGE;
        break;
    default:
        break;
    }

    if (m_bNoUserData)
    {
        dwTemp |= MSC_RSOP_FLAG_NOUSER;
    }

    if (m_bNoComputerData)
    {
        dwTemp |= MSC_RSOP_FLAG_NOCOMPUTER;
    }

    if (m_bUserDeniedAccess)
    {
        dwTemp |= MSC_RSOP_FLAG_USERDENIED;
    }

    if (m_bComputerDeniedAccess)
    {
        dwTemp |= MSC_RSOP_FLAG_COMPUTERDENIED;
    }

    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write flags with %d."), hr));
        goto Exit;
    }


    //
    // Save the computer name
    //

    TCHAR szLocalComputerName[MAX_PATH+1];
    ULONG ulSize;

    if ( (m_bArchiveData) && (!lstrcmpi(m_szComputerName, TEXT("."))) )
    {
        ulSize = ARRAYSIZE(szLocalComputerName);
        if (!GetComputerObjectName (NameSamCompatible, szLocalComputerName, &ulSize))
        {
            GetComputerNameEx (ComputerNameNetBIOS, szLocalComputerName, &ulSize);
        }
    }
    else {
        lstrcpyn(szLocalComputerName, m_szComputerName, MAX_PATH);
    }

    hr = SaveString (pStm, szLocalComputerName);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save computer name with %d."), hr));
        goto Exit;
    }


    //
    // Save the computer SOM
    //

    hr = SaveString (pStm, m_szComputerSOM);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save computer SOM with %d."), hr));
        goto Exit;
    }


    //
    // Save the computer security groups
    //

    lMax = 0;

    if (m_saComputerSecurityGroups)
    {
        SafeArrayGetUBound (m_saComputerSecurityGroups, 1, &lMax);
    }

    hr = pStm->Write(&lMax, sizeof(lMax), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write security group count with %d."), hr));
        goto Exit;
    }

    if (lMax)
    {
        for (lIndex = 0; lIndex <= lMax; lIndex++)
        {
            if (SUCCEEDED(SafeArrayGetElement(m_saComputerSecurityGroups, &lIndex, &lpText)))
            {
                hr = SaveString (pStm, lpText);

                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save security group with %d."), hr));
                    goto Exit;
                }
            }
        }
    }


    //
    // Save the computer WQL filters
    //

    lMax = 0;

    if (m_saComputerWQLFilters)
    {
        SafeArrayGetUBound (m_saComputerWQLFilters, 1, &lMax);
    }

    hr = pStm->Write(&lMax, sizeof(lMax), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write security group count with %d."), hr));
        goto Exit;
    }

    if (lMax)
    {
        for (lIndex = 0; lIndex <= lMax; lIndex++)
        {
            if (SUCCEEDED(SafeArrayGetElement(m_saComputerWQLFilters, &lIndex, &lpText)))
            {
                hr = SaveString (pStm, lpText);

                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save wql filter with %d."), hr));
                    goto Exit;
                }
            }
        }
    }


    //
    // Save the computer WQL filter names
    //

    lMax = 0;

    if (m_saComputerWQLFilterNames)
    {
        SafeArrayGetUBound (m_saComputerWQLFilterNames, 1, &lMax);
    }

    hr = pStm->Write(&lMax, sizeof(lMax), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write security group count with %d."), hr));
        goto Exit;
    }

    if (lMax)
    {
        for (lIndex = 0; lIndex <= lMax; lIndex++)
        {
            if (SUCCEEDED(SafeArrayGetElement(m_saComputerWQLFilterNames, &lIndex, &lpText)))
            {
                hr = SaveString (pStm, lpText);

                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save wql filter with %d."), hr));
                    goto Exit;
                }
            }
        }
    }

    //
    // Save the user name/
    // fyi, This is not used in diagnostic mode archive data
    //
    
    hr = SaveString (pStm, m_szUserName);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save user name with %d."), hr));
        goto Exit;
    }


    //
    // Save the user display name (only used in diagnostic mode)
    //

    if (m_bDiagnostic && !lstrcmpi(m_szUserName, TEXT(".")))
    {
        if (m_bArchiveData) {
            LPTSTR lpTemp;

            lpTemp = MyGetUserName (NameSamCompatible);

            if (lpTemp)
            {
                hr = SaveString (pStm, lpTemp);
                LocalFree (lpTemp);
            }
        }
    }
    else
    {
        hr = SaveString (pStm, m_szUserDisplayName);
    }

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save user display name with %d."), hr));
        goto Exit;
    }


    //
    // Save the user SOM
    //

    hr = SaveString (pStm, m_szUserSOM);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save user SOM with %d."), hr));
        goto Exit;
    }


    //
    // Save the user security groups
    //

    lMax = 0;

    if (m_saUserSecurityGroups)
    {
        SafeArrayGetUBound (m_saUserSecurityGroups, 1, &lMax);
    }

    hr = pStm->Write(&lMax, sizeof(lMax), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write security group count with %d."), hr));
        goto Exit;
    }

    if (lMax)
    {
        for (lIndex = 0; lIndex <= lMax; lIndex++)
        {
            if (SUCCEEDED(SafeArrayGetElement(m_saUserSecurityGroups, &lIndex, &lpText)))
            {
                hr = SaveString (pStm, lpText);

                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save security group with %d."), hr));
                    goto Exit;
                }
            }
        }
    }


    //
    // Save the user WQL filters
    //

    lMax = 0;

    if (m_saUserWQLFilters)
    {
        SafeArrayGetUBound (m_saUserWQLFilters, 1, &lMax);
    }

    hr = pStm->Write(&lMax, sizeof(lMax), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write security group count with %d."), hr));
        goto Exit;
    }

    if (lMax)
    {
        for (lIndex = 0; lIndex <= lMax; lIndex++)
        {
            if (SUCCEEDED(SafeArrayGetElement(m_saUserWQLFilters, &lIndex, &lpText)))
            {
                hr = SaveString (pStm, lpText);

                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save wql filter with %d."), hr));
                    goto Exit;
                }
            }
        }
    }


    //
    // Save the user WQL filter names
    //

    lMax = 0;

    if (m_saUserWQLFilterNames)
    {
        SafeArrayGetUBound (m_saUserWQLFilterNames, 1, &lMax);
    }

    hr = pStm->Write(&lMax, sizeof(lMax), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write security group count with %d."), hr));
        goto Exit;
    }

    if (lMax)
    {
        for (lIndex = 0; lIndex <= lMax; lIndex++)
        {
            if (SUCCEEDED(SafeArrayGetElement(m_saUserWQLFilterNames, &lIndex, &lpText)))
            {
                hr = SaveString (pStm, lpText);

                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save wql filter with %d."), hr));
                    goto Exit;
                }
            }
        }
    }


    //
    // Save the site
    //

    hr = SaveString (pStm, m_szSite);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save site with %d."), hr));
        goto Exit;
    }


    //
    // Save the DC
    //

    hr = SaveString (pStm, m_szDC);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save DC with %d."), hr));
        goto Exit;
    }


    //
    // Save the WMI and event log data if appropriate
    //

    if (m_bArchiveData)
    {
        lpComputerData = CreateTempFile();

        if (!lpComputerData)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: CreateTempFile failed with %d."), GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        lstrcpy (szPath, m_szNamespace);
        lpTemp = CheckSlash (szPath);
        lstrcpy (lpTemp, COMPUTER_SECTION);

        hr = ExportRSoPData (szPath, lpComputerData);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: ExportRSoPData failed with 0x%x."), hr));
            goto Exit;
        }

        hr = CopyFileToMSC (lpComputerData, pStm);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: CopyFileToMSC failed with 0x%x."), hr));
            goto Exit;
        }


        lpUserData = CreateTempFile();

        if (!lpUserData)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: CreateTempFile failed with %d."), GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        lstrcpy (lpTemp, USER_SECTION);

        hr = ExportRSoPData (szPath, lpUserData);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: ExportRSoPData failed with 0x%x."), hr));
            goto Exit;
        }

        hr = CopyFileToMSC (lpUserData, pStm);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: CopyFileToMSC failed with 0x%x."), hr));
            goto Exit;
        }


        //
        //  Save the event log entries
        //

        hr = m_pEvents->SaveEntriesToStream(pStm);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: SaveEntriesToStream failed with 0x%x."), hr));
            goto Exit;
        }
    }

    if (fClearDirty)
    {
        ClearDirty();
    }

Exit:

    if (lpUserData)
    {
        DeleteFile (lpUserData);
        delete [] lpUserData;
    }

    if (lpComputerData)
    {
        DeleteFile (lpComputerData);
        delete [] lpComputerData;
    }

    return hr;
}


STDMETHODIMP CRSOPComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRSOPComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPComponentData object implementation (ISnapinHelp)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\rsopsnp.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPComponentData object implementation (Internal functions)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CRSOPComponentData::IsNode (LPDATAOBJECT lpDataObject, MMC_COOKIE cookie)
{
    HRESULT hr = S_FALSE;
    LPRSOPDATAOBJECT pRSOPDataObject;
    DATA_OBJECT_TYPES type;
    MMC_COOKIE testcookie;


    //
    // We can determine if this is a GPO DataObject by trying to
    // QI for the private IGPEDataObject interface.  If found,
    // it belongs to us.
    //

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IRSOPDataObject,
                 (LPVOID *)&pRSOPDataObject)))
    {

        pRSOPDataObject->GetType(&type);
        pRSOPDataObject->GetCookie(&testcookie);

        if ((type == CCT_SCOPE) && (cookie == testcookie))
        {
            hr = S_OK;
        }

        pRSOPDataObject->Release();
    }

    return (hr);
}


HRESULT CRSOPComponentData::IsSnapInManager (LPDATAOBJECT lpDataObject)
{
    HRESULT hr = S_FALSE;
    LPRSOPDATAOBJECT pRSOPDataObject;
    DATA_OBJECT_TYPES type;


    //
    // We can determine if this is a RSOP DataObject by trying to
    // QI for the private IRSOPDataObject interface.  If found,
    // it belongs to us.
    //

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IRSOPDataObject,
                                               (LPVOID *)&pRSOPDataObject)))
    {

        //
        // This is a GPO object.  Now see if is a scope pane
        // data object.  We only want to display the property
        // sheet for the scope pane.
        //

        if (SUCCEEDED(pRSOPDataObject->GetType(&type)))
        {
            if (type == CCT_SNAPIN_MANAGER)
            {
                hr = S_OK;
            }
        }
        pRSOPDataObject->Release();
    }

    return(hr);
}


HRESULT CRSOPComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if (!m_hRoot)
    {

        m_hRoot = hParent;

        if (!m_bRefocusInit)
        {
            SCOPEDATAITEM item;

            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::EnumerateScopePane:  Resetting the root node")));
            m_bRefocusInit = TRUE;

            ZeroMemory (&item, sizeof(SCOPEDATAITEM));
            item.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
            item.displayname = MMC_CALLBACK;

            if (m_bInitialized)
            {
                if (m_bUserGPCoreError || m_bComputerGPCoreError)
                {
                    item.nImage = 3;
                    item.nOpenImage = 3;
                }
                else if (m_bUserCSEError || m_bComputerCSEError ||
                         m_bUserDeniedAccess || m_bComputerDeniedAccess)
                {
                    item.nImage = 11;
                    item.nOpenImage = 11;
                }
                else
                {
                    item.nImage = 2;
                    item.nOpenImage = 2;
                }
            }
            else
            {
                item.nImage = 3;
                item.nOpenImage = 3;
            }

            item.ID = hParent;

            m_pScope->SetItem (&item);
        }
    }


    if (!m_bInitialized)
    {
        if (m_hRoot == hParent)
        {
            SCOPEDATAITEM item;

            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::EnumerateScopePane: No GPO available.  Exiting.")));

            ZeroMemory (&item, sizeof(SCOPEDATAITEM));
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = 3;
            item.nOpenImage = 3;
            item.nState = 0;
            item.cChildren = 0;
            item.lParam = g_NameSpace[0].dwID;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
        }

        return S_OK;
    }


    if (m_hRoot == hParent)
    {
        dwIndex = 0;
    }
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = (DWORD)item.lParam;
    }

    for (i = 0; i < g_dwNameSpaceItems; i++)
    {
        if (g_RsopNameSpace[i].dwParent == dwIndex)
        {
            BOOL bAdd = TRUE;

            if (g_RsopNameSpace[i].dwID == 1)
            {
                if (!m_szComputerName && !m_szComputerSOM)
                {
                    bAdd = FALSE;
                }

                if (m_bNoComputerData)
                {
                    bAdd = FALSE;
                }

                if (m_bComputerDeniedAccess)
                {
                    bAdd = FALSE;
                }
            }

            if (g_RsopNameSpace[i].dwID == 2)
            {
                if (!m_szUserName && !m_szUserSOM && LoopbackNone == m_loopbackMode)
                {
                    bAdd = FALSE;
                }

                if (m_bNoUserData)
                {
                    bAdd = FALSE;
                }

                if (m_bUserDeniedAccess)
                {
                    bAdd = FALSE;
                }
            }

            if (bAdd)
            {
                INT iIcon, iOpenIcon;

                iIcon = g_RsopNameSpace[i].iIcon;
                iOpenIcon = g_RsopNameSpace[i].iOpenIcon;

                if ((i == 1) && m_bComputerGPCoreError)
                {
                    iIcon = 12;
                    iOpenIcon = 12;
                }

                else if ((i == 1) && m_bComputerCSEError)
                {
                    iIcon = 14;
                    iOpenIcon = 14;
                }
                else if ((i == 2) && m_bUserGPCoreError)
                {
                    iIcon = 13;
                    iOpenIcon = 13;
                }
                else if ((i == 2) && m_bUserCSEError)
                {
                    iIcon = 15;
                    iOpenIcon = 15;
                }

                item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
                item.displayname = MMC_CALLBACK;
                item.nImage = iIcon;
                item.nOpenImage = iOpenIcon;
                item.nState = 0;
                item.cChildren = g_RsopNameSpace[i].cChildren;
                item.lParam = g_RsopNameSpace[i].dwID;
                item.relativeID =  hParent;

                if (SUCCEEDED(m_pScope->InsertItem (&item)))
                {
                    if (i == 1)
                    {
                        m_hMachine = item.ID;
                    }
                    else if (i == 2)
                    {
                        m_hUser = item.ID;
                    }
                }
            }
        }
    }

    return S_OK;
}

HRESULT ImplementBrowseButton(HWND hDlg, DWORD dwFlagsUp, DWORD dwFlagsDown,
                              DWORD dwflScope, HWND hLB, TCHAR * &sz)
{
        // shell the object picker to get the computer list
        HRESULT                 hr = E_FAIL;
        IDsObjectPicker *       pDsObjectPicker = NULL;
        const ULONG             cbNumScopes = 4;    //make sure this number matches the number of scopes initialized
        DSOP_SCOPE_INIT_INFO    ascopes [cbNumScopes];
        DSOP_INIT_INFO          InitInfo;
        IDataObject *           pdo = NULL;
        STGMEDIUM               stgmedium = {
                                                TYMED_HGLOBAL,
                                                NULL
                                            };
        UINT                    cf = 0;
        FORMATETC               formatetc = {
                                                (CLIPFORMAT)cf,
                                                NULL,
                                                DVASPECT_CONTENT,
                                                -1,
                                                TYMED_HGLOBAL
                                            };
        BOOL                    bAllocatedStgMedium = FALSE;
        PDS_SELECTION_LIST      pDsSelList = NULL;
        PDS_SELECTION           pDsSelection = NULL;
        ULONG                   ulSize, ulIndex, ulMax;
        LPWSTR                  lpTemp;

        hr = CoInitialize (NULL);

        if (FAILED(hr))
            goto Browse_Cleanup;

        hr = CoCreateInstance (CLSID_DsObjectPicker,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IDsObjectPicker,
                               (void **) & pDsObjectPicker
                               );

        if (FAILED(hr))
            goto Browse_Cleanup;

        //Initialize the scopes.
        ZeroMemory (ascopes, cbNumScopes * sizeof (DSOP_SCOPE_INIT_INFO));

        ascopes[0].cbSize = ascopes[1].cbSize = ascopes[2].cbSize = ascopes[3].cbSize
            = sizeof (DSOP_SCOPE_INIT_INFO);

        ascopes[0].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        ascopes[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP
                             | DSOP_SCOPE_FLAG_STARTING_SCOPE | dwflScope;
        ascopes[0].FilterFlags.Uplevel.flBothModes = dwFlagsUp;

        ascopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        ascopes[1].FilterFlags.Uplevel.flBothModes = dwFlagsUp;
        ascopes[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP | dwflScope;

        ascopes[2].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
                            DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
        ascopes[2].FilterFlags.Uplevel.flBothModes = dwFlagsUp;
        ascopes[2].FilterFlags.flDownlevel = dwFlagsDown;
        ascopes[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP | dwflScope;

        ascopes[3].flType = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE |
                            DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE |
                            DSOP_SCOPE_TYPE_WORKGROUP;
        ascopes[3].FilterFlags.Uplevel.flBothModes = dwFlagsUp;
        ascopes[3].FilterFlags.flDownlevel = dwFlagsDown;
        ascopes[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP | dwflScope;

        //populate the InitInfo structure that will be used to initialize the
        //object picker
        ZeroMemory (&InitInfo, sizeof (DSOP_INIT_INFO));

        InitInfo.cbSize = sizeof (DSOP_INIT_INFO);
        InitInfo.cDsScopeInfos = cbNumScopes;
        InitInfo.aDsScopeInfos = ascopes;
        InitInfo.flOptions = (hLB ? DSOP_FLAG_MULTISELECT : 0);

        hr = pDsObjectPicker->Initialize (&InitInfo);

        if (FAILED(hr))
            goto Browse_Cleanup;

        hr = pDsObjectPicker->InvokeDialog (hDlg, &pdo);

        //if the computer selection dialog cannot be invoked or if the user
        //hits cancel, bail out.
        if (FAILED(hr) || S_FALSE == hr)
            goto Browse_Cleanup;

       //if we are here, the user chose, OK, so find out what group was chosen
       cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);

       if (0 == cf)
           goto Browse_Cleanup;

       //set the clipboard format for the FORMATETC structure
       formatetc.cfFormat = (CLIPFORMAT)cf;

       hr = pdo->GetData (&formatetc, &stgmedium);

       if (FAILED (hr))
           goto Browse_Cleanup;

       bAllocatedStgMedium = TRUE;

       pDsSelList = (PDS_SELECTION_LIST) GlobalLock (stgmedium.hGlobal);



       //
       // Decide what the max number of items to process is
       //

       ulMax = pDsSelList->cItems;

       if (!hLB && (ulMax > 1))
       {
          ulMax = 1;
       }


       //
       // Loop through the items
       //

       for (ulIndex = 0; ulIndex < ulMax; ulIndex++)
       {

           pDsSelection = &(pDsSelList->aDsSelection[ulIndex]);


           //
           // Find the beginning of the object name after the domain name
           //

           lpTemp = pDsSelection->pwzADsPath + 7;

           while (*lpTemp && *lpTemp != TEXT('/'))
           {
               lpTemp++;
           }

           if (!(*lpTemp))
           {
               hr = E_FAIL;
               goto Browse_Cleanup;
           }

           lpTemp++;

           ulSize = wcslen(lpTemp);

           //
           // Convert the name from full DN to sam compatible
           //

           sz = new WCHAR[ulSize];
           if (sz)
           {
                if (TranslateName (lpTemp, NameFullyQualifiedDN,
                                   NameSamCompatible, sz, &ulSize))
                {
                    BOOL bDollarRemoved = FALSE;

                    if (sz[wcslen(sz)-1] == L'$')
                    {
                        bDollarRemoved = TRUE;
                        sz[wcslen(sz)-1] = 0;
                    }

                    if (hLB)
                    {
                        INT iIndex;

                        iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) sz);
                        SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) ((bDollarRemoved) ? 2: 0));

                        SendMessage (hLB, LB_SETCURSEL, (WPARAM) iIndex, 0);
                        delete [] sz;
                        sz = NULL;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DebugMsg((DM_WARNING, TEXT("ImplementBrowseButton: TranslateName for %s to SAM style failed with %d."),
                             lpTemp, GetLastError()));
                    delete [] sz;
                    goto Browse_Cleanup;
                }
           }
           else
           {
               hr = E_OUTOFMEMORY;
           }
       }


    Browse_Cleanup:
        if (pDsSelList)
            GlobalUnlock (pDsSelList);
        if (bAllocatedStgMedium)
            ReleaseStgMedium (&stgmedium);
        if (pdo)
            pdo->Release();
        if (pDsObjectPicker)
            pDsObjectPicker->Release();
    return hr;
}
 
void GetControlText(HWND hDlg, DWORD ctrlid, TCHAR * &sz)
{
    UINT n;

    if (sz)
    {
        delete [] sz;
        sz = NULL;
    }
    n = (UINT) SendMessage(GetDlgItem(hDlg, ctrlid),
                    WM_GETTEXTLENGTH, 0, 0);
    if (n > 0)
    {
        sz =  new TCHAR[n + 1];
        if (sz)
        {
            LPTSTR lpDest, lpSrc;

            GetDlgItemText(hDlg, ctrlid, sz, n + 1);

            if (sz[0] == TEXT(' '))
            {
                //
                // Remove leading blanks by shuffling the characters forward
                //

                lpDest = lpSrc = sz;

                while ((*lpSrc == TEXT(' ')) && *lpSrc)
                    lpSrc++;

                if (*lpSrc)
                {
                    while (*lpSrc)
                    {
                        *lpDest = *lpSrc;
                        lpDest++;
                        lpSrc++;
                    }
                    *lpDest = TEXT('\0');
                }
            }

            //
            // Remove trailing blanks
            //

            lpDest = sz + lstrlen(sz) - 1;

            while ((*lpDest == TEXT(' ')) && (lpDest >= sz))
                lpDest--;

            *(lpDest+1) = TEXT('\0');
        }
    }
}

INT_PTR CALLBACK CRSOPComponentData::RSOPWelcomeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        {
            TCHAR szDefaultGPO[128];


            pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

            SendMessage(GetDlgItem(hDlg, IDC_RSOP_BIG_BOLD1),
                        WM_SETFONT, (WPARAM)pCD->m_BigBoldFont, (LPARAM)TRUE);

/*

            if (!pCD->m_hChooseBitmap)
            {
                pCD->m_hChooseBitmap = (HBITMAP) LoadImage (g_hInstance,
                                                            MAKEINTRESOURCE(IDB_WIZARD),
                                                            IMAGE_BITMAP, 0, 0,
                                                            LR_DEFAULTCOLOR);
            }

            if (pCD->m_hChooseBitmap)
            {
                SendDlgItemMessage (hDlg, IDC_BITMAP, STM_SETIMAGE,
                                    IMAGE_BITMAP, (LPARAM) pCD->m_hChooseBitmap);
            }
*/
        }

        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }
        }

        break;
    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_NEXT);
            break;

        case PSN_WIZFINISH:
            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPChooseModeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        SendMessage(GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_CHECKED, 0);

        if (IsStandaloneComputer() || 
            ! IsPlanningModeAllowed())
        {
            EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
        }
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_WIZNEXT:
            pCD->m_bDiagnostic = TRUE;
            if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
            {
                // skip to the planning mode pages
                pCD->m_bDiagnostic = FALSE;
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETTARGET);
                return TRUE;
            }
            break;
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
            break;

        case PSN_WIZFINISH:
            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

BOOL CRSOPComponentData::TestAndValidateComputer(HWND hDlg)
{
    LPTSTR lpMachineName = NULL;
    BOOL bOk = TRUE;
    HKEY hKeyRoot = 0, hKey = 0;
    DWORD dwType, dwSize, dwValue = 1;
    INT iRet;
    TCHAR szMessage[200];
    TCHAR szCaption[100];
    LONG lResult;

    if (m_szComputerName && lstrcmpi(m_szComputerName, TEXT(".")))
    {
        lpMachineName = new TCHAR[(lstrlen(m_szComputerName) + 3)];

        if (!lpMachineName)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: Failed to allocate memory with %d"), GetLastError()));
            goto Exit;
        }

        lstrcpy (lpMachineName, TEXT("\\\\"));

        if ((lstrlen (m_szComputerName) > 2) && (m_szComputerName[0] == TEXT('\\')) &&
            (m_szComputerName[1] == TEXT('\\')))
        {
            lstrcat (lpMachineName, m_szComputerName + 2);
        }
        else
        {
            lstrcat (lpMachineName, NameWithoutDomain(m_szComputerName));
        }
    }

    SetWaitCursor();

    //
    // If we are testing a remote machine, test if the machine is alive and has
    // the rsop namespace
    //

    if (lpMachineName)
    {
        if (!IsComputerRSoPEnabled (lpMachineName))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: IsComputerRSoPEnabled failed on machine <%s>"), lpMachineName));

            if (GetLastError() == WBEM_E_INVALID_NAMESPACE)
            {
                ReportError (hDlg, 0, IDS_DOWNLEVELCOMPUTER, m_szComputerName);
            }
            else
            {
                ReportError (hDlg, GetLastError(), IDS_CONNECTSERVERFAILED, m_szComputerName);
            }
            bOk = FALSE;
            goto Exit;
        }
    }


    //
    // Check if the machine has rsop logging enabled or disabled
    //

    lResult = RegConnectRegistry (lpMachineName, HKEY_LOCAL_MACHINE, &hKeyRoot);

    ClearWaitCursor();

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: Failed to connect to %s with %d"),
                 lpMachineName, lResult));
        ReportError (hDlg, lResult, IDS_CONNECTSERVERFAILED, m_szComputerName);
        bOk = FALSE;
        goto Exit;
    }


    lResult = RegOpenKeyEx (hKeyRoot, TEXT("Software\\Policies\\Microsoft\\Windows\\System"),
                            0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwSize = sizeof (dwValue);
        lResult = RegQueryValueEx (hKey, TEXT("RsopLogging"), NULL, &dwType, (LPBYTE) &dwValue,
                                   &dwSize);

        RegCloseKey (hKey);

        if (lResult == ERROR_SUCCESS)
        {
            RegCloseKey (hKeyRoot);
            goto Exit;
        }
    }


    lResult = RegOpenKeyEx (hKeyRoot, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: Failed to open winlogon key with %d"),
                 lResult));
        RegCloseKey (hKeyRoot);
        goto Exit;
    }

    dwSize = sizeof (dwValue);
    RegQueryValueEx (hKey, TEXT("RsopLogging"), NULL, &dwType, (LPBYTE) &dwValue, &dwSize);

    RegCloseKey (hKey);
    RegCloseKey (hKeyRoot);


Exit:

    if (bOk && (dwValue == 0))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: RSOP Logging is not enabled on %s"),
                 lpMachineName));


        LoadString(g_hInstance, IDS_RSOPLOGGINGDISABLED, szMessage, ARRAYSIZE(szMessage));
        LoadString(g_hInstance, IDS_RSOPLOGGINGTITLE, szCaption, ARRAYSIZE(szCaption));

        iRet = MessageBox (hDlg, szMessage, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2);

        if (iRet == IDNO)
        {
            bOk = FALSE;
        }
    }


    if (lpMachineName)
    {
        delete [] lpMachineName;
    }

    return bOk;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPGetCompDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        if (pCD->m_szComputerNamePref) {
            if (pCD->m_szComputerName)
            {
                delete [] pCD->m_szComputerName;
            }

            pCD->m_szComputerName =  new WCHAR[wcslen(pCD->m_szComputerNamePref)+1];
            if (pCD->m_szComputerName)
            {
                wcscpy (pCD->m_szComputerName, NormalizedComputerName(pCD->m_szComputerNamePref));
                if (wcslen(pCD->m_szComputerName) >= 1) {
                    // this is being called from dsa. A terminating '$' will be passed in
                    pCD->m_szComputerName[wcslen(pCD->m_szComputerName)-1] = L'\0';
                }
            }

            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
            EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
            SetDlgItemText (hDlg, IDC_EDIT1, pCD->m_szComputerName);


            pCD->m_bNoComputerData = FALSE;
            CheckDlgButton (hDlg, IDC_CHECK1, BST_UNCHECKED);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);

        }
        else {
            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
        }

        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }

            switch (LOWORD(wParam))
            {
            case IDC_EDIT1:
                if (HIWORD(wParam) == EN_CHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }

                break;
            case IDC_BUTTON1:
                {
                TCHAR * sz;

                if (ImplementBrowseButton(hDlg, DSOP_FILTER_COMPUTERS,
                                          DSOP_DOWNLEVEL_FILTER_COMPUTERS,
                                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS,
                                          NULL, sz) == S_OK)
                {
                    SetDlgItemText (hDlg, IDC_EDIT1, sz);
                    delete [] sz;
                }
                }
                break;

            case IDC_RADIO1:
                SetDlgItemText (hDlg, IDC_EDIT1, TEXT(""));
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_RADIO2:
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);
                SetFocus (GetDlgItem(hDlg, IDC_EDIT1));
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            }
        }

        break;

    case WM_REFRESHDISPLAY:
        {
            UINT n;

            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD->m_bOverride) {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            }
            else {
                if (IsDlgButtonChecked (hDlg, IDC_RADIO2) == BST_CHECKED)
                {
                    n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_GETTEXTLENGTH, 0, 0);
    
                    if (n > 0 )
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    else
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                }
                else
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
            }
        }
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_WIZNEXT:
            if (IsDlgButtonChecked (hDlg, IDC_RADIO2) == BST_CHECKED)
            {
                GetControlText(hDlg, IDC_EDIT1, pCD->m_szComputerName);

                if ( pCD->m_szComputerName )
                {
                    TCHAR* szNormalizedComputerName;
                    
                    // We need to handle the case where the user enters a name 
                    // prefixed by '\\'

                    szNormalizedComputerName = NormalizedComputerName( pCD->m_szComputerName );
                    
                    // If we detect the '\\' prefix, we must remove it since this syntax
                    // is not recognized by the RSoP provider
                    if ( szNormalizedComputerName != pCD->m_szComputerName )
                    {
                        TCHAR* szNewComputerName;

                        szNewComputerName = new TCHAR [ lstrlen( szNormalizedComputerName ) + 1 ];

                        if ( szNewComputerName )
                        {
                            lstrcpy( szNewComputerName, szNormalizedComputerName );
                        }

                        delete [] pCD->m_szComputerName;                            

                        pCD->m_szComputerName = szNewComputerName;
                    }
                }
            }
            else
            {
                if (pCD->m_szComputerName)
                {
                    delete [] pCD->m_szComputerName;
                }

                pCD->m_szComputerName =  new TCHAR[2];
                if (pCD->m_szComputerName)
                {
                    wcscpy (pCD->m_szComputerName, L".");
                }
            }

            if (pCD->TestAndValidateComputer (hDlg))
            {
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                if (pCD->m_szUserName)
                {
                    delete [] pCD->m_szUserName;
                    pCD->m_szUserName = NULL;
                }

                if (pCD->m_szUserDisplayName)
                {
                    delete [] pCD->m_szUserDisplayName;
                    pCD->m_szUserDisplayName = NULL;
                }
            }
            else
            {
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }

            if (IsDlgButtonChecked (hDlg, IDC_CHECK1) == BST_CHECKED)
            {
                pCD->m_bNoComputerData = TRUE;
            }
            else
            {
                pCD->m_bNoComputerData = FALSE;
            }

            return TRUE;

        case PSN_SETACTIVE:
            if (pCD->m_bOverride) {
                // This is the start page if rsop.msc is launched with
                // cmd line arg for logging mode
                PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_NEXT);
            }

            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            break;


        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;

    }


    return FALSE;
}

HRESULT CRSOPComponentData::FillUserList (HWND hList, BOOL *bFoundCurrentUser)
{
    HRESULT hr, hrSuccess;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pOutInst = NULL;
    BSTR bstrParam = NULL;
    BSTR bstrClassPath = NULL;
    BSTR bstrMethodName = NULL;
    VARIANT var;
    TCHAR szBuffer[MAX_PATH];
    IWbemLocator * pLocator = NULL;
    SAFEARRAY * psa;
    LONG lMax, lIndex;
    BSTR bstrSid;
    PSID pSid;
    TCHAR szName[125];
    TCHAR szDomain[125];
    TCHAR szFullName[MAX_PATH];
    DWORD dwNameSize, dwDomainSize;
    SID_NAME_USE NameUse;
    LPTSTR lpData, szUserSidPref = NULL;
    INT iRet;
    LVITEM item;
    LPTSTR lpCurrentUserSid = NULL;
    HANDLE hToken;
    LPTSTR lpSystemName = NULL;
    BOOL   bFoundUserPref = FALSE;

    if (m_szUserNamePref) {
        // Just show the user alone
        *bFoundCurrentUser = FALSE;

        szUserSidPref = MyLookupAccountName(
                               (lstrcmpi(m_szComputerName, TEXT(".")) == 0) ? NULL : NameWithoutDomain(m_szComputerName),
                               m_szUserNamePref);

        if (!szUserSidPref) {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: MyLookupAccountName failed with %d"), GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (lstrcmpi(m_szComputerName, TEXT(".")))
    {
        lpSystemName = m_szComputerName;
    }


    *bFoundCurrentUser = FALSE;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_READ, &hToken))
    {
        lpCurrentUserSid = GetSidString(hToken);

        CloseHandle (hToken);
    }


    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: CoCreateInstance failed with 0x%x"), hr));
        goto Cleanup;
    }

    // set up diagnostic mode
    // build a path to the target: "\\\\computer\\root\\rsop"
    _stprintf(szBuffer, TEXT("\\\\%s\\root\\rsop"), NameWithoutDomain(m_szComputerName));
    bstrParam = SysAllocString(szBuffer);
    hr = pLocator->ConnectServer(bstrParam,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: ConnectServer to %s failed with 0x%x"), szBuffer, hr));
        goto Cleanup;
    }

    // Set the proper security to prevent the ExecMethod call from failing
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_CALL,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Cleanup;
    }

    bstrClassPath = SysAllocString(TEXT("RsopLoggingModeProvider"));
    bstrMethodName = SysAllocString(TEXT("RsopEnumerateUsers"));
    hr = pNamespace->ExecMethod(bstrClassPath,
                                bstrMethodName,
                                0,
                                NULL,
                                NULL,
                                &pOutInst,
                                NULL);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: ExecMethod failed with 0x%x"), hr));
        goto Cleanup;
    }

    hr = GetParameter(pOutInst, TEXT("hResult"), hrSuccess);
    if (SUCCEEDED(hr) && SUCCEEDED(hrSuccess))
    {

        VariantInit(&var);
        hr = pOutInst->Get(TEXT("userSids"), 0, &var, 0, 0);

        if (SUCCEEDED(hr))
        {
            if (var.vt & VT_ARRAY)
            {
                psa = var.parray;

                if (SUCCEEDED( SafeArrayGetUBound(psa, 1, &lMax)))
                {
                    for (lIndex = 0; lIndex <= lMax; lIndex++)
                    {
                        if (SUCCEEDED(SafeArrayGetElement (psa, &lIndex, &bstrSid)))
                        {
                            lpData = new WCHAR[(lstrlen(bstrSid) + 1)];

                            if (lpData)
                            {
                                lstrcpy (lpData, bstrSid);

                                if (lpCurrentUserSid)
                                {
                                    if (!lstrcmpi(lpCurrentUserSid, lpData))
                                    {
                                        *bFoundCurrentUser = TRUE;
                                    }
                                }

                                if (NT_SUCCESS(AllocateAndInitSidFromString (bstrSid, &pSid)))
                                {
                                    dwNameSize = ARRAYSIZE(szName);
                                    dwDomainSize = ARRAYSIZE(szDomain);
                                    if (LookupAccountSid (NameWithoutDomain(lpSystemName), pSid, szName, &dwNameSize,
                                                          szDomain, &dwDomainSize, &NameUse))
                                    {
                                        BOOL bAddUser;

                                        bAddUser = (!m_szUserNamePref || (lstrcmpi(szUserSidPref, lpData) == 0));
                                        
                                        if ((m_szUserNamePref) && (lstrcmpi(szUserSidPref, lpData) == 0))
                                            bFoundUserPref = TRUE;

                                        if  (bAddUser) {
                                            wsprintf (szFullName, TEXT("%s\\%s"), szDomain, szName);

                                            ZeroMemory (&item, sizeof(item));
                                            item.mask = LVIF_TEXT | LVIF_PARAM;
                                            item.pszText = szFullName;
                                            item.lParam = (LPARAM) lpData;
    
                                            iRet = (int) SendMessage (hList, LVM_INSERTITEM, 0, (LPARAM) &item);
    
                                            if (iRet == -1)
                                            {
                                                delete [] lpData;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        delete [] lpData;
                                    }

                                    RtlFreeSid(pSid);
                                }
                                else
                                {
                                    delete [] lpData;
                                }
                            }
                        }
                    }
                }
            }
        }
        VariantClear(&var);

        item.mask = LVIF_STATE;
        item.iItem = 0;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendMessage (hList, LVM_SETITEMSTATE, 0, (LPARAM) &item);

    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: Either GetParameter or the return value failed.  hr = 0x%x, hrSuccess = 0x%x"), hr, hrSuccess));
    }

    if ((m_szUserNamePref) && (!bFoundUserPref)) {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: User not found on the machine")));
    }

Cleanup:
    SysFreeString(bstrParam);
    SysFreeString(bstrClassPath);
    SysFreeString(bstrMethodName);
    if (pOutInst)
    {
        pOutInst->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }

    if (lpCurrentUserSid)
    {
        DeleteSidString(lpCurrentUserSid);
    }

    return hr;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPGetUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:
        {
        LVCOLUMN lvcol;
        RECT rect;
        HWND hLV = GetDlgItem(hDlg, IDC_LIST1);

        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        GetClientRect(hLV, &rect);

        ZeroMemory(&lvcol, sizeof(lvcol));

        lvcol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcol.fmt = LVCFMT_LEFT;
        lvcol.cx = rect.right - GetSystemMetrics(SM_CYHSCROLL);
        ListView_InsertColumn(hLV, 0, &lvcol);

        SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                    LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        }
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_WIZNEXT:
            {
                LPTSTR lpData;
                HWND hList = GetDlgItem(hDlg, IDC_LIST1);
                INT iSel;


                if (pCD->m_szUserName)
                {
                    delete [] pCD->m_szUserName;
                    pCD->m_szUserName = NULL;
                }

                if (pCD->m_szUserDisplayName)
                {
                    delete [] pCD->m_szUserDisplayName;
                    pCD->m_szUserDisplayName = NULL;
                }

//                if (IsDlgButtonChecked (hDlg, IDC_CHECK1) == BST_CHECKED)
                if (IsDlgButtonChecked (hDlg, IDC_RADIO4) == BST_CHECKED)
                {
                    pCD->m_bNoUserData = TRUE;
                }
                else
                {
                    pCD->m_bNoUserData = FALSE;

                    if (IsDlgButtonChecked (hDlg, IDC_RADIO1))
                    {
                        LPTSTR lpTemp;

                        if (IsStandaloneComputer())
                        {
                            lpTemp = MyGetUserName (NameUnknown);
                        }
                        else
                        {
                            lpTemp = MyGetUserName (NameSamCompatible);
                        }

                        if (lpTemp)
                        {
                            pCD->m_szUserDisplayName = new TCHAR[lstrlen(lpTemp) + 1];

                            if (pCD->m_szUserDisplayName)
                            {
                                lstrcpy (pCD->m_szUserDisplayName, lpTemp);
                            }

                            LocalFree (lpTemp);
                        }

                        pCD->m_szUserName = new TCHAR[2];

                        if (pCD->m_szUserName)
                        {
                            lstrcpy (pCD->m_szUserName, TEXT("."));
                        }
                    }
                    else
                    {
                        iSel = (INT) SendMessage(hList, LVM_GETNEXTITEM, (WPARAM) -1, MAKELPARAM(LVNI_SELECTED, 0));

                        if (iSel != -1)
                        {
                            pCD->m_szUserDisplayName = new TCHAR[200];
                            if (pCD->m_szUserDisplayName)
                            {
                                LVITEM item;

                                ZeroMemory (&item, sizeof(item));

                                item.mask = LVIF_TEXT | LVIF_PARAM;
                                item.iItem =  iSel;
                                item.pszText = pCD->m_szUserDisplayName;
                                item.cchTextMax = 200;

                                if (SendMessage(hList, LVM_GETITEM, 0, (LPARAM) &item))
                                {

                                    lpData = (LPTSTR) item.lParam;

                                    if (lpData)
                                    {
                                        pCD->m_szUserName = new TCHAR[(lstrlen(lpData) + 1)];
                                        if (pCD->m_szUserName)
                                        {
                                            lstrcpy (pCD->m_szUserName, lpData);
                                        }
                                    }
                                }
                            }
                        }

                    }   // if (IsDlgButtonChecked (hDlg, IDC_RADIO1))

                }


                // skip to the last page in the wizard
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED);
            }
            return TRUE;

        case PSN_SETACTIVE:
            {
                HRESULT hr;
                BOOL bCurrentUserFound;
                HWND hList = GetDlgItem(hDlg, IDC_LIST1);
                SendMessage(hList, LVM_DELETEALLITEMS, 0 ,0);
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);

                CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);

                hr = pCD->FillUserList (hList, &bCurrentUserFound);

                if (SUCCEEDED(hr))
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), TRUE);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), TRUE);

                    if (!ListView_GetItemCount (hList))
                    {
//                        CheckDlgButton (hDlg, IDC_CHECK1, BST_CHECKED);
                        CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO4);
                    }
                }
                else
                {
                    ReportError (hDlg, hr, IDS_ENUMUSERSFAILED);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), FALSE);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    break;
                }


                if (!(pCD->m_szUserNamePref)) {
                    if ((!lstrcmpi(pCD->m_szComputerName, TEXT("."))) && bCurrentUserFound)
                    {
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), TRUE);
                    }
                    else
                    {
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                    }

                    if (pCD->m_szUserName)
                    {
                        if (!lstrcmpi(pCD->m_szUserName, TEXT(".")))
                        {
                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
                        }
                        else
                        {
                            LVFINDINFO FindInfo;
                            LVITEM item;
                            INT iRet;

                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);

                            ZeroMemory (&FindInfo, sizeof(FindInfo));
                            FindInfo.flags = LVFI_STRING;
                            FindInfo.psz = pCD->m_szUserDisplayName;

                            iRet =  (INT) SendMessage (hList, LVM_FINDITEM,
                                                       (WPARAM) -1, (LPARAM) &FindInfo);

                            if (iRet != -1)
                            {
                                ZeroMemory (&item, sizeof(item));
                                item.mask = LVIF_STATE;
                                item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                                SendMessage (hList, LVM_SETITEMSTATE, (WPARAM) -1, (LPARAM) &item);

                                ZeroMemory (&item, sizeof(item));
                                item.mask = LVIF_STATE;
                                item.iItem = iRet;
                                item.state = LVIS_SELECTED | LVIS_FOCUSED;
                                item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                                SendMessage (hList, LVM_SETITEMSTATE, (WPARAM) iRet, (LPARAM) &item);
                            }
                        }
                    }
                    else
                    {
                        if ((!lstrcmpi(pCD->m_szComputerName, TEXT("."))) && bCurrentUserFound)
                        {
                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
                        }
                        else
                        {
                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
                        }
                    }

                    if (pCD->m_bNoComputerData)
                    {
                        pCD->m_bNoUserData = FALSE;
//                        CheckDlgButton (hDlg, IDC_CHECK1, BST_UNCHECKED);
                        CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
//                        EnableWindow (GetDlgItem(hDlg, IDC_CHECK1), FALSE);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), FALSE);
                    }
                    else
                    {
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), TRUE);
                    }
                }
                else {
                    // disable current user radio button
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                    CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
                    
                    // disable no user data chk box
                    pCD->m_bNoUserData = FALSE;
//                    CheckDlgButton (hDlg, IDC_CHECK1, BST_UNCHECKED);
                    CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
//                    EnableWindow (GetDlgItem(hDlg, IDC_CHECK1), FALSE);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), FALSE);

                }

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
            break;


        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;

        case LVN_DELETEITEM:
            {
            NMLISTVIEW * pNMListView = (NMLISTVIEW *) lParam;

            if (pNMListView && pNMListView->lParam)
            {
                delete [] ((LPTSTR)pNMListView->lParam);
            }
            }
            break;
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDC_RADIO1:
                CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            case IDC_RADIO2:
                CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            case IDC_RADIO3:
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            case IDC_RADIO4:
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            }
        }

        break;

     case WM_REFRESHDISPLAY:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }

            if (IsDlgButtonChecked (hDlg, IDC_RADIO4) == BST_CHECKED) {

                EnableWindow(GetDlgItem(hDlg, IDC_LIST1), FALSE);

            } else {


                if (IsWindowEnabled (GetDlgItem(hDlg, IDC_RADIO1)) ||
                    IsWindowEnabled (GetDlgItem(hDlg, IDC_RADIO2)))
                {
                    if (pCD->m_bNoComputerData)
                    {
                        pCD->m_bNoUserData = FALSE;
    //                    CheckDlgButton (hDlg, IDC_CHECK1, BST_UNCHECKED);
                        CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
    //                    EnableWindow (GetDlgItem(hDlg, IDC_CHECK1), FALSE);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), FALSE);

                    }
                    else
                    {
    //                    EnableWindow (GetDlgItem(hDlg, IDC_CHECK1), TRUE);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), TRUE);
                    }

                    if (IsDlgButtonChecked (hDlg, IDC_RADIO2) == BST_CHECKED)
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_LIST1), TRUE);

                        if ((INT) SendMessage(GetDlgItem(hDlg, IDC_LIST1), LVM_GETITEMCOUNT, 0, 0))
                        {
                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                            SetFocus (GetDlgItem(hDlg, IDC_LIST1));
                        }
                        else
                        {
    //                        if (IsDlgButtonChecked (hDlg, IDC_CHECK1) == BST_CHECKED)
                            if (IsDlgButtonChecked (hDlg, IDC_RADIO4) == BST_CHECKED)
                            {
                                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                            }
                            else
                            {
                                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                            }
                        }
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_LIST1), FALSE);
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    }
                }
                else
                {
                    if (pCD->m_bNoComputerData)
                    {
                        //
                        // if the user said no computer data but
                        // he has access to no users, enable on back button and
                        // disable the checkbox
                        //
                        pCD->m_bNoUserData = FALSE;

    //                    CheckDlgButton (hDlg, IDC_CHECK1, BST_UNCHECKED);
                        CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
    //                    EnableWindow (GetDlgItem(hDlg, IDC_CHECK1), FALSE);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), FALSE);

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                    }
                    else
                    {
                        //
                        // This is an error condition where ::FillUserList failed
                        //

                        EnableWindow(GetDlgItem(hDlg, IDC_LIST1), FALSE);

    //                    CheckDlgButton (hDlg, IDC_CHECK1, BST_CHECKED);
                        CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO4);
    //                    EnableWindow(GetDlgItem(hDlg, IDC_CHECK1), FALSE);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);

                    }
                }
            }
        }
        break;

    }

    return FALSE;
}

WCHAR * ExtractDomain(WCHAR * sz)
{
    // parse through the string looking for a forward slash
    DWORD cch = 0;
    if (!sz)
    {
        return NULL;
    }
    while (sz[cch])
    {
        if (L'\\' == sz[cch] || L'/' == sz[cch])
        {
            WCHAR * szNew = new WCHAR[cch+1];
            if (szNew)
            {
                wcsncpy(szNew, sz, cch);
                szNew[cch] = TEXT('\0');
            }
            return szNew;
        }
        cch++;
    }

    // didn't find a forward slash
    return NULL;
}

LPTSTR CRSOPComponentData::GetDefaultSOM (LPTSTR lpDNName)
{
    HRESULT hr;
    LPTSTR lpPath = NULL;
    IADsPathname * pADsPathname = NULL;
    BSTR bstrContainer = NULL;


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the DN name
    //

    hr = pADsPathname->Set (lpDNName, ADS_SETTYPE_DN);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    //
    // Remove the user / computer name
    //

    hr = pADsPathname->RemoveLeafElement ();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to retreive GPO name with 0x%x"), hr));
        goto Exit;
    }


    //
    // Get the new path
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500_DN, &bstrContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    //
    // Allocate a new buffer for the path
    //

    lpPath = new TCHAR [(lstrlen(bstrContainer)+ 1)];

    if (!lpPath)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }


    //
    // Build the path
    //

    lstrcpy (lpPath, bstrContainer);

Exit:

    if (bstrContainer)
    {
        SysFreeString (bstrContainer);
    }

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    return lpPath;
}

LPTSTR CRSOPComponentData::GetDomainFromSOM (LPTSTR lpSOM)
{
    LPTSTR lpFullName, lpResult;
    LPOLESTR lpLdapDomain, lpDomainName;
    HRESULT hr;

    lpFullName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpSOM) + 10) * sizeof(TCHAR));

    if (!lpFullName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetDomainFromSOM: Failed to allocate memory with %d."), GetLastError()));
        return NULL;
    }

    lstrcpy (lpFullName, TEXT("LDAP://"));
    lstrcat (lpFullName, lpSOM);

    lpLdapDomain = GetDomainFromLDAPPath(lpFullName);

    LocalFree (lpFullName);

    if (!lpLdapDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetDomainFromSOM: Failed to get ldap domain name from path.")));
        return NULL;
    }

    hr = ConvertToDotStyle (lpLdapDomain, &lpDomainName);

    delete [] lpLdapDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetDomainFromSOM: Failed to convert to dot style.")));
        return NULL;
    }

    lpResult = new TCHAR[lstrlen(lpDomainName) + 1];

    if (lpResult)
    {
        lstrcpy (lpResult, lpDomainName);
    }

    LocalFree (lpDomainName);

    return lpResult;
}

VOID CRSOPComponentData::EscapeString (LPTSTR *lpString)
{
    IADsPathname * pADsPathnameDest = NULL;
    IADsPathname * pADsPathnameSrc = NULL;
    HRESULT hr;
    BSTR bstr = NULL, bstrResult;
    LPTSTR lpTemp;
    LONG lIndex, lCount;



    //
    // Create a pathname object to put the source string into so we
    // can take it apart one element at a time.
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathnameSrc);


    if (FAILED(hr))
    {
        goto Exit;
    }

    hr = pADsPathnameSrc->put_EscapedMode (ADS_ESCAPEDMODE_OFF_EX);

    if (FAILED(hr))
    {
        goto Exit;
    }

    //
    // Set the provider to LDAP and set the source string
    //

    hr = pADsPathnameSrc->Set (TEXT("LDAP"), ADS_SETTYPE_PROVIDER);

    if (FAILED(hr))
    {
        goto Exit;
    }

    hr = pADsPathnameSrc->Set (*lpString, ADS_SETTYPE_DN);

    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Query for the number of elements
    //

    hr = pADsPathnameSrc->GetNumElements (&lCount);
    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Create a pathname object to put the freshly escaped string into
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathnameDest);


    if (FAILED(hr))
    {
        goto Exit;
    }


    hr = pADsPathnameDest->put_EscapedMode(ADS_ESCAPEDMODE_ON );

    if (FAILED(hr))
    {
        goto Exit;
    }



    //
    // Loop through the string one element at at time escaping the RDN
    //

    for (lIndex = lCount; lIndex > 0; lIndex--)
    {

        //
        // Get this element
        //

        hr = pADsPathnameSrc->GetElement ((lIndex - 1), &bstr);

        if (FAILED(hr))
        {
            goto Exit;
        }


        //
        // Check for escape characters
        //

        hr = pADsPathnameDest->GetEscapedElement (0, bstr, &bstrResult);

        if (FAILED(hr))
        {
            goto Exit;
        }


        //
        // Add the new element to the destination pathname object
        //

        hr = pADsPathnameDest->AddLeafElement (bstrResult);

        SysFreeString (bstrResult);

        if (FAILED(hr))
        {
            goto Exit;
        }


        SysFreeString (bstr);
        bstr = NULL;
    }


    //
    // Get the final path
    //

    hr = pADsPathnameDest->Retrieve (ADS_FORMAT_X500_DN, &bstr);

    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Allocate a new buffer to hold the string
    //

    lpTemp = new TCHAR [lstrlen(bstr) + 1];

    if (lpTemp)
    {
        lstrcpy (lpTemp, bstr);

        delete [] *lpString;
        *lpString = lpTemp;
    }



Exit:

    if (bstr)
    {
        SysFreeString (bstr);
    }

    if (pADsPathnameDest)
    {
        pADsPathnameDest->Release();
    }

    if (pADsPathnameSrc)
    {
        pADsPathnameSrc->Release();
    }
}

INT CALLBACK CRSOPComponentData::DsBrowseCallback (HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{

    if (uMsg == DSBM_HELP)
    {
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                (ULONG_PTR) (LPSTR) aBrowseForOUHelpIds);
    }
    else if (uMsg == DSBM_CONTEXTMENU)
    {
        WinHelp((HWND) lParam, HELP_FILE, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPSTR) aBrowseForOUHelpIds);
    }

    return 0;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPGetTargetDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:
        {
            LPTSTR lpText, lpPath;
    
            pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
    
            if (pCD)
            {
                lpText = MyGetUserName(NameSamCompatible);
    
                if (lpText)
                {
                    SetDlgItemText (hDlg, IDC_EDIT6, lpText);
                    LocalFree (lpText);
                }
    
                lpText = MyGetUserName(NameFullyQualifiedDN);
    
                if (lpText)
                {
                    lpPath = pCD->GetDefaultSOM(lpText);
    
                    if (lpPath)
                    {
                        SetDlgItemText (hDlg, IDC_EDIT5, lpPath);
                        delete [] lpPath;
                    }
    
                    LocalFree (lpText);
                }
            }
    
            if (pCD->m_szUserNamePref) {
                CheckDlgButton (hDlg, IDC_RADIO2, BST_CHECKED);
                SetDlgItemText(hDlg, IDC_EDIT2, pCD->m_szUserNamePref);
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_RADIO1), FALSE);
            }
            else if (pCD->m_szUserSOMPref) {
                CheckDlgButton (hDlg, IDC_RADIO1, BST_CHECKED);
                SetDlgItemText(hDlg, IDC_EDIT1, pCD->m_szUserSOMPref);
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), FALSE);
            }
            else {
                CheckDlgButton (hDlg, IDC_RADIO1, BST_CHECKED);
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), FALSE);
            }
    
    
            if (pCD->m_szComputerNamePref) {
                LPTSTR  szCompName;

                szCompName = new WCHAR[wcslen(pCD->m_szComputerNamePref)+1]; 

                if (szCompName)
                {
                    wcscpy (szCompName, pCD->m_szComputerNamePref);
                    if (wcslen(szCompName) >= 1) {
                        // this is being called from dsa. A terminating '$' will be passed in
                        szCompName[wcslen(szCompName)-1] = L'\0';
                    }
                    
                    CheckDlgButton (hDlg, IDC_RADIO4, BST_CHECKED);
                    SetDlgItemText(hDlg, IDC_EDIT4, szCompName);
                    EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_RADIO3), FALSE);
                }
                                                   

            }
            else if (pCD->m_szComputerSOMPref) {
                CheckDlgButton (hDlg, IDC_RADIO3, BST_CHECKED);
                SetDlgItemText(hDlg, IDC_EDIT3, pCD->m_szComputerSOMPref);
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), FALSE);
            }
            else {
                CheckDlgButton (hDlg, IDC_RADIO3, BST_CHECKED);
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), FALSE);
            }
        }
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }
            switch (LOWORD(wParam))
            {
            case IDC_RADIO1:
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE1), TRUE);

                SetDlgItemText (hDlg, IDC_EDIT2, TEXT(""));
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), FALSE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_RADIO2:
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), TRUE);

                SetDlgItemText (hDlg, IDC_EDIT1, TEXT(""));
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE1), FALSE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_RADIO3:
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE3), TRUE);

                SetDlgItemText (hDlg, IDC_EDIT4, TEXT(""));
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), FALSE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_RADIO4:
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), TRUE);

                SetDlgItemText (hDlg, IDC_EDIT3, TEXT(""));
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE3), FALSE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_EDIT1:
            case IDC_EDIT2:
            case IDC_EDIT3:
            case IDC_EDIT4:
                if (HIWORD(wParam) == EN_CHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BROWSE1:
                {
                DSBROWSEINFO dsbi = {0};
                TCHAR *szResult;
                TCHAR szTitle[256];
                TCHAR szCaption[256];
                dsbi.hwndOwner = hDlg;
                dsbi.pszCaption = szTitle;
                dsbi.pszTitle = szCaption;
                dsbi.cbStruct = sizeof(dsbi);
                dsbi.dwFlags = DSBI_ENTIREDIRECTORY;
                dsbi.pfnCallback = DsBrowseCallback;

                szResult = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*4000);

                if (szResult) {
                    dsbi.pszPath = szResult;
                    dsbi.cchPath = 4000;

                    LoadString(g_hInstance,
                               IDS_BROWSE_USER_OU_TITLE,
                               szTitle,
                               ARRAYSIZE(szTitle));
                    LoadString(g_hInstance,
                               IDS_BROWSE_USER_OU_CAPTION,
                               szCaption,
                               ARRAYSIZE(szCaption));
                    if (IDOK == DsBrowseForContainer(&dsbi))
                    {
                        SetDlgItemText(hDlg, IDC_EDIT1, (szResult+7));
                    }
                    
                    LocalFree(szResult);

                }
                }
                break;

            case IDC_BROWSE2:
                {
                TCHAR * sz;

                if (ImplementBrowseButton(hDlg, DSOP_FILTER_USERS,
                                          DSOP_DOWNLEVEL_FILTER_USERS,
                                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,
                                          NULL, sz) == S_OK)
                {
                    SetDlgItemText (hDlg, IDC_EDIT2, sz);
                    delete [] sz;
                }
                }
                break;

            case IDC_BROWSE3:
                {
                DSBROWSEINFO dsbi = {0};
                TCHAR *szResult;
                TCHAR szTitle[256];
                TCHAR szCaption[256];
                dsbi.hwndOwner = hDlg;
                dsbi.pszCaption = szTitle;
                dsbi.pszTitle = szCaption;
                dsbi.cbStruct = sizeof(dsbi);
                dsbi.dwFlags = DSBI_ENTIREDIRECTORY;
                dsbi.pfnCallback = DsBrowseCallback;

                szResult = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*4000);

                if (szResult) {
                    dsbi.pszPath = szResult;
                    dsbi.cchPath = 4000;
                    LoadString(g_hInstance,
                               IDS_BROWSE_COMPUTER_OU_TITLE,
                               szTitle,
                               ARRAYSIZE(szTitle));
                    LoadString(g_hInstance,
                               IDS_BROWSE_COMPUTER_OU_CAPTION,
                               szCaption,
                               ARRAYSIZE(szCaption));
                    if (IDOK == DsBrowseForContainer(&dsbi))
                    {
                        SetDlgItemText(hDlg, IDC_EDIT3, (szResult+7));
                    }

                    LocalFree(szResult);
                }

                }
                break;

            case IDC_BROWSE4:
                {
                TCHAR * sz;

                if (ImplementBrowseButton(hDlg, DSOP_FILTER_COMPUTERS,
                                          DSOP_DOWNLEVEL_FILTER_COMPUTERS,
                                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS,
                                          NULL, sz) == S_OK)
                {
                    SetDlgItemText (hDlg, IDC_EDIT4, sz);
                    delete [] sz;
                }
                }
                break;
            }
        }

        break;

    case WM_REFRESHDISPLAY:
        {
            UINT n;

            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_GETTEXTLENGTH, 0, 0);

            if (n == 0)
            {
               n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT2), WM_GETTEXTLENGTH, 0, 0);
            }

            if (n == 0)
            {
               n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT3), WM_GETTEXTLENGTH, 0, 0);
            }

            if (n == 0)
            {
               n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT4), WM_GETTEXTLENGTH, 0, 0);
            }
            if (pCD->m_bOverride) {
                // This is the start page if rsop.msc is launched with
                // cmd line arg for planning mode
                if (n > 0 )
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
            }
            else {
                if (n > 0 )
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            }
        }
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_WIZBACK:
            SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_CHOOSEMODE);
            return TRUE;


        case PSN_SETACTIVE:
            if (pCD->m_bOverride) {
                // This is the start page if rsop.msc is launched with
                // cmd line arg for planning mode
                PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_NEXT);
            }

            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            break;

        case PSN_WIZNEXT:
            {
                HRESULT hr;
                IDirectoryObject * pUserObject = NULL;
                IDirectoryObject * pComputerObject = NULL;
                LPTSTR lpUserName = NULL, lpUserSOM = NULL;
                LPTSTR lpComputerName = NULL, lpComputerSOM = NULL;
                LPTSTR lpFullName;

                SetWaitCursor();


                //
                // Get the user and dn name
                //

                if (IsDlgButtonChecked(hDlg, IDC_RADIO1) == BST_CHECKED)
                {
                    GetControlText(hDlg, IDC_EDIT1, lpUserSOM);

                    if (lpUserSOM)
                    {
                        pCD->EscapeString (&lpUserSOM);

                        hr = pCD->TestSOM (lpUserSOM, hDlg);

                        if (FAILED(hr))
                        {
                            if (hr != E_INVALIDARG)
                            {
                                ReportError (hDlg, hr, IDS_NOUSERCONTAINER);
                            }

                            delete [] lpUserSOM;

                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }
                    }
                }
                else
                {
                    GetControlText(hDlg, IDC_EDIT2, lpUserName);
                    lpUserSOM = ConvertName(lpUserName);

                    if (lpUserName && !lpUserSOM)
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::RSOPGetTargetDlgProc: Failed to convert username %s to DN name with %d."), lpUserName, GetLastError()));

                        if (GetLastError() == ERROR_FILE_NOT_FOUND)
                        {
                            ReportError (hDlg, 0, IDS_NOUSER2);
                        }
                        else
                        {
                            ReportError (hDlg, GetLastError(), IDS_NOUSER);
                        }

                        delete [] lpUserName;

                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    pCD->EscapeString (&lpUserSOM);
                }

                if (lpUserSOM)
                {
                    lpFullName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpUserSOM) + 10) * sizeof(TCHAR));

                    if (lpFullName)
                    {
                        lstrcpy (lpFullName, TEXT("LDAP://"));
                        lstrcat (lpFullName, lpUserSOM);

                        hr = OpenDSObject(lpFullName, IID_IDirectoryObject, (void**)&pUserObject);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::RSOPGetTargetDlgProc: Failed to bind to user object %s with %d."), lpFullName, hr));
                            ReportError (hDlg, hr, IDS_NOUSERCONTAINER);

                            if (lpUserName)
                            {
                                delete [] lpUserName;
                            }

                            LocalFree (lpFullName);
                            delete [] lpUserSOM;

                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }

                        LocalFree (lpFullName);
                    }
                }


                //
                // Get the computer and dn name
                //

                if (IsDlgButtonChecked(hDlg, IDC_RADIO3) == BST_CHECKED)
                {
                    GetControlText(hDlg, IDC_EDIT3, lpComputerSOM);

                    if (lpComputerSOM)
                    {
                        pCD->EscapeString (&lpComputerSOM);

                        hr = pCD->TestSOM (lpComputerSOM, hDlg);

                        if (FAILED(hr))
                        {
                            if (hr != E_INVALIDARG)
                            {
                                ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);
                            }

                            delete [] lpComputerSOM;

                            if (lpUserName)
                            {
                                delete [] lpUserName;
                            }

                            if (lpUserSOM)
                            {
                                delete [] lpUserSOM;
                            }

                            if (pUserObject)
                            {
                                pUserObject->Release();
                            }

                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }
                    }
                }
                else
                {
                    GetControlText(hDlg, IDC_EDIT4, lpComputerName);

                    if (lpComputerName)
                    {
                        lpFullName = new TCHAR [lstrlen(lpComputerName) + 2];

                        if (lpFullName)
                        {
                            lstrcpy (lpFullName, lpComputerName);
                            lstrcat (lpFullName, TEXT("$"));
                            lpComputerSOM = ConvertName(lpFullName);
                            delete [] lpComputerName;
                            lpComputerName = lpFullName;
                        }
                    }

                    if (lpComputerName && !lpComputerSOM)
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::RSOPGetTargetDlgProc: Failed to convert computername %s to DN name with %d."), lpComputerName, GetLastError()));

                        if (GetLastError() == ERROR_FILE_NOT_FOUND)
                        {
                            ReportError (hDlg, 0, IDS_NOCOMPUTER2);
                        }
                        else
                        {
                            ReportError (hDlg, GetLastError(), IDS_NOCOMPUTER);
                        }

                        delete [] lpComputerName;

                        if (lpUserName)
                        {
                            delete [] lpUserName;
                        }

                        if (lpUserSOM)
                        {
                            delete [] lpUserSOM;
                        }

                        if (pUserObject)
                        {
                            pUserObject->Release();
                        }

                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    pCD->EscapeString (&lpComputerSOM);
                }

                if (lpComputerSOM)
                {
                    lpFullName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpComputerSOM) + 10) * sizeof(TCHAR));

                    if (lpFullName)
                    {
                        lstrcpy (lpFullName, TEXT("LDAP://"));
                        lstrcat (lpFullName, lpComputerSOM);

                        hr = OpenDSObject(lpFullName, IID_IDirectoryObject, (void**)&pComputerObject);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::RSOPGetTargetDlgProc: Failed to bind to computer object %s with %d."), lpFullName, hr));
                            ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);

                            if (lpComputerName)
                            {
                                delete [] lpComputerName;
                            }

                            LocalFree (lpFullName);
                            delete [] lpComputerSOM;

                            if (lpUserName)
                            {
                                delete [] lpUserName;
                            }

                            if (lpUserSOM)
                            {
                                delete [] lpUserSOM;
                            }

                            if (pUserObject)
                            {
                                pUserObject->Release();
                            }

                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }

                        LocalFree (lpFullName);
                    }
                }


                //
                // Store the user information
                //

                if (pCD->m_szUserName && lpUserName && (!lstrcmpi(pCD->m_szUserName, lpUserName)))
                {
                    delete [] lpUserName;

                    if (lpUserSOM)
                    {
                        delete [] lpUserSOM;
                    }

                    if (pUserObject)
                    {
                        pUserObject->Release();
                    }
                }
                else if (!pCD->m_szUserName && !lpUserName && pCD->m_szUserSOM && lpUserSOM && (!lstrcmpi(pCD->m_szUserSOM, lpUserSOM)))
                {
                    delete [] lpUserSOM;
                    if (pUserObject)
                    {
                        pUserObject->Release();
                    }
                }
                else
                {
                    pCD->FreeUserData ();

                    if (lpUserName)
                    {
                        pCD->m_szUserName = lpUserName;
                        pCD->m_szUserDNName = lpUserSOM;
                        pCD->m_szDefaultUserSOM = pCD->GetDefaultSOM (lpUserSOM);
                    }
                    else
                    {
                        pCD->m_szUserSOM = lpUserSOM;
                    }

                    pCD->m_pUserObject = pUserObject;
                }


                //
                // Store the computer information
                //

                if (pCD->m_szComputerName && lpComputerName && (!lstrcmpi(pCD->m_szComputerName, lpComputerName)))
                {
                    delete [] lpComputerName;
                    if (lpComputerSOM)
                    {
                        delete [] lpComputerSOM;
                    }

                    if (pComputerObject)
                    {
                        pComputerObject->Release();
                    }
                }
                else if (!pCD->m_szComputerName && !lpComputerName && pCD->m_szComputerSOM && lpComputerSOM && (!lstrcmpi(pCD->m_szComputerSOM, lpComputerSOM)))
                {
                    delete [] lpComputerSOM;

                    if (pComputerObject)
                    {
                        pComputerObject->Release();
                    }
                }
                else
                {
                    pCD->FreeComputerData ();

                    if (lpComputerName)
                    {
                        pCD->m_szComputerName = lpComputerName;
                        pCD->m_szComputerDNName = lpComputerSOM;
                        pCD->m_szDefaultComputerSOM = pCD->GetDefaultSOM (lpComputerSOM);
                    }
                    else
                    {
                        pCD->m_szComputerSOM = lpComputerSOM;
                    }

                    pCD->m_pComputerObject = pComputerObject;
                }


                if (pCD->m_szDC)
                {
                    delete [] pCD->m_szDC;
                    pCD->m_szDC = NULL;
                }


                if (pCD->m_szSite)
                {
                    delete [] pCD->m_szSite;
                    pCD->m_szSite = NULL;
                }


                if ( (pCD->m_szSitePref) && (!pCD->m_szSite)) {
                    GetSiteFriendlyName(pCD->m_szSitePref, &(pCD->m_szSite));
                }


                // set m_szDC to the primary DC
                LPTSTR szDomain = NULL;

                // Determine the focused domain so we can focus on the correct
                // DC.

                if (pCD->m_szUserName)
                {
                    //
                    // try and get the user's domain
                    //

                    szDomain = ExtractDomain(pCD->m_szUserName);
                }

                if (!szDomain && pCD->m_szUserSOM)
                {
                    //
                    // try and get the user's domain from the SOM
                    //

                    szDomain = pCD->GetDomainFromSOM(pCD->m_szUserSOM);
                }

                if (!szDomain && pCD->m_szComputerName)
                {
                    //
                    // try and get the computer's domain
                    //

                    szDomain = ExtractDomain(pCD->m_szComputerName);
                }

                if (!szDomain && pCD->m_szComputerSOM)
                {
                    //
                    // try and get the computer's domain from the SOM
                    //

                    szDomain = pCD->GetDomainFromSOM(pCD->m_szComputerSOM);
                }

                if (!szDomain)
                {
                    //
                    // use the local domain
                    //
                    TCHAR szName[1024];
                    DWORD dwSize = sizeof(szName) / sizeof(szName[0]);
                    GetUserNameEx(NameSamCompatible, szName, &dwSize);
                    szDomain = ExtractDomain(szName);
                }

                LPTSTR lpDCName;

                lpDCName = GetDCName (szDomain, pCD->m_szDCPref, NULL, FALSE, 0, DS_RETURN_DNS_NAME);

                if (lpDCName)
                {
                    if (pCD->m_szDC)
                    {
                        delete [] pCD->m_szDC;
                        pCD->m_szDC = NULL;
                    }
                    pCD->m_szDC = new WCHAR [ wcslen(lpDCName) + 1];
                    if (pCD->m_szDC)
                    {
                        wcscpy(pCD->m_szDC, lpDCName);
                    }
                    LocalFree(lpDCName);
                }

                if (szDomain)
                {
                    delete [] szDomain;
                }

                ClearWaitCursor();
            }

            if (SendMessage(GetDlgItem(hDlg, IDC_BUTTON1), BM_GETCHECK, 0, 0))
            {
                if (!(pCD->IsComputerRSoPEnabled(pCD->m_szDC))) {
                    if (GetLastError() == WBEM_E_INVALID_NAMESPACE)
                    {
                        ReportError (hDlg, 0, IDS_DEFDC_DOWNLEVEL);
                    }
                    else
                    {
                        ReportError (hDlg, GetLastError(), IDS_DEFDC_CONNECTFAILED);
                    }
                    delete [] pCD->m_szDC;
                    pCD->m_szDC = NULL;
                }
                else {
                    pCD->m_dwSkippedFrom = IDD_RSOP_GETTARGET;
                    pCD->m_loopbackMode = LoopbackNone;
                    // skip to the diagnostic pages
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                    return TRUE;
                }
            }

            pCD->m_dwSkippedFrom = 0;
            break;

        case PSN_WIZFINISH:
        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

BOOL CRSOPComponentData::IsComputerRSoPEnabled(LPTSTR lpComputerName)
{
    LPSTR lpComputerNameA;
    LPTSTR lpName, lpWMIPath;
    HRESULT hr;
    BOOL bRetVal = FALSE;
    struct hostent *hostp;
    DWORD dwResult, dwSize = (lstrlen(lpComputerName) + 1) * 2;
    ULONG inaddr, ulSpeed;
    IWbemLocator * pLocator = 0;
    IWbemServices * pNamespace = 0;
    BSTR bstrPath;


    SetLastError(ERROR_SUCCESS);

    //
    // Allocate memory for a ANSI computer name
    //

    lpComputerNameA = new CHAR[dwSize];

    if (lpComputerNameA)
    {

        //
        // Skip the leading \\ if present
        //

        if ((*lpComputerName == TEXT('\\')) && (*(lpComputerName+1) == TEXT('\\')))
        {
            lpName = lpComputerName + 2;
        }
        else
        {
            lpName = lpComputerName;
        }


        //
        // Convert the computer name to ANSI
        //

        if (WideCharToMultiByte (CP_ACP, 0, lpName, -1, lpComputerNameA, dwSize, NULL, NULL))
        {

            //
            // Get the host information for the computer
            //

            hostp = gethostbyname(lpComputerNameA);

            if (hostp)
            {

                //
                // Get the ip address of the computer
                //

                inaddr = *(long *)hostp->h_addr;


                //
                // Test if the computer is alive
                //

                dwResult = PingComputer (inaddr, &ulSpeed);

                if (dwResult == ERROR_SUCCESS)
                {

                    //
                    // Create an instance of the WMI locator
                    //

                    hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
                                          IID_IWbemLocator, (LPVOID *) &pLocator);

                    if (SUCCEEDED(hr))
                    {

                        //
                        // Try to connect to the rsop namespace
                        //

                        dwSize = lstrlen(lpName) + 20;

                        lpWMIPath = new TCHAR[dwSize];

                        if (lpWMIPath)
                        {
                            wsprintf (lpWMIPath, TEXT("\\\\%s\\root\\rsop"), lpName);

                            bstrPath = SysAllocString(lpWMIPath);

                            if (bstrPath)
                            {

                                hr = pLocator->ConnectServer(bstrPath,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);

                                if (SUCCEEDED(hr))
                                {

                                    //
                                    // Success.  This computer has RSOP support
                                    //

                                    pNamespace->Release();
                                    bRetVal = TRUE;
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: ConnectServer for %s failed with 0x%x"), bstrPath, hr));
                                }

                                SysFreeString (bstrPath);

                                //
                                // Set hr into  the last error code.  Note, this has to happen after
                                // the call to SysFreeString since it changes the last error code
                                // to success
                                //

                                if (hr != S_OK)
                                {
                                    SetLastError(hr);
                                }
                            }
                            else
                            {
                                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: SysAllocString failed")));
                                SetLastError(ERROR_OUTOFMEMORY);
                            }

                            delete [] lpWMIPath;
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: Failed to alloc memory for wmi path.")));
                            SetLastError(ERROR_OUTOFMEMORY);
                        }

                        pLocator->Release();
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: CoCreateInstance failed with 0x%x."), hr));
                        SetLastError((DWORD)hr);
                    }
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: PingComputer failed with %d."), dwResult));
                    SetLastError(dwResult);
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: gethostbyname failed with %d."), WSAGetLastError()));
                SetLastError(WSAGetLastError());
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: WideCharToMultiByte failed with %d"), GetLastError()));
        }

        delete [] lpComputerNameA;
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: Failed to allocate memory for ansi dc name")));
        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRetVal;
}

INT_PTR CALLBACK CRSOPComponentData::BrowseDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            pCD = (CRSOPComponentData *) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
            pCD->InitializeDCInfo(hDlg);
            return TRUE;
        }

        case WM_COMMAND:

            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }

            if (LOWORD(wParam) == IDOK)
            {
                INT iSel, iStrLen;

                iSel = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                if (iSel == LB_ERR)
                {
                    break;
                }

                iStrLen = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETTEXTLEN, (WPARAM) iSel, 0);

                if (iStrLen == LB_ERR)
                {
                    break;
                }

                delete [] pCD->m_szDC;

                pCD->m_szDC = new TCHAR[iStrLen+1];

                if (!pCD->m_szDC)
                {
                    break;
                }

                SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM) iSel, (LPARAM) pCD->m_szDC);

                EndDialog(hDlg, 1);
                return TRUE;
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, 0);
                return TRUE;
            }

            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aBrowseDCHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aBrowseDCHelpIds);
            return (TRUE);
    }

    return FALSE;
}


VOID CRSOPComponentData::InitializeDCInfo (HWND hDlg)
{
    LPTSTR szDomain = NULL;
    TCHAR szName[1024];
    DWORD dwSize, dwError;
    INT iDefault = LB_ERR, nPDC = LB_ERR, nCount = 0;


    //
    // Determine the focused domain so we can focus on the correct
    // DC.

    if (m_szUserName)
    {
        //
        // Try and get the user's domain
        //

        szDomain = ExtractDomain(m_szUserName);
    }

    if (!szDomain && m_szComputerName)
    {
        //
        // Try and get the computer's domain
        //

        szDomain = ExtractDomain(m_szComputerName);
    }

    if (!szDomain)
    {
        //
        // Use the local domain
        //

        dwSize = ARRAYSIZE(szName);

        if (GetUserNameEx(NameSamCompatible, szName, &dwSize))
        {
            szDomain = ExtractDomain(szName);
        }
    }

    if (szDomain)
    {
        DWORD cInfo;
        INT n;
        PDS_DOMAIN_CONTROLLER_INFO_1 pInfo = NULL;
        HANDLE hDs;
        DWORD result;

        result = DsBind(NULL, szDomain, &hDs);

        if (ERROR_SUCCESS == result)
        {
            result = DsGetDomainControllerInfo(hDs,
                                               szDomain,
                                               1,
                                               &cInfo,
                                               (void **)&pInfo);
            if (ERROR_SUCCESS == result)
            {
                //
                // Enumerate the list
                //

                for (n = 0; (DWORD)n < cInfo; n++)
                {

                    if (IsComputerRSoPEnabled(pInfo[n].DnsHostName))
                    {
                        SendMessage(GetDlgItem(hDlg, IDC_LIST1), LB_ADDSTRING, 0, (LPARAM)pInfo[n].DnsHostName);

                        if (pInfo[n].fIsPdc)
                        {
                            nPDC = n;
                        }

                        nCount++;
                    }
                    else
                    {
                        dwError = GetLastError();
                    }
                }


                if (nCount)
                {
                    //
                    // Set the initial selection
                    //

                    if (m_szDC)
                    {
                        iDefault = (INT) SendMessage (GetDlgItem(hDlg, IDC_LIST1), LB_FINDSTRING,
                                                (WPARAM) -1, (LPARAM) m_szDC);
                    }
                    else if (nPDC != LB_ERR)
                    {
                        iDefault = (INT) SendMessage(GetDlgItem(hDlg, IDC_LIST1), LB_FINDSTRINGEXACT,
                                        (WPARAM) -1, (LPARAM) pInfo[nPDC].DnsHostName);
                    }

                    SendMessage(GetDlgItem(hDlg, IDC_LIST1), LB_SETCURSEL,
                                (WPARAM) (iDefault == LB_ERR) ? 0 : iDefault, NULL);
                }
                else
                {
                    ReportError (hDlg, dwError, IDS_NORSOPDC, szDomain);
                }


                DsFreeDomainControllerInfo(1, cInfo, pInfo);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeDCInfo: DsGetDomainControllerInfo to %s failed with %d."), szDomain, result));
            }

            DsUnBind(&hDs);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeDCInfo: DsBind to %s failed with %d."), szDomain, result));
            ReportError(hDlg, result, IDS_DSBINDFAILED);
        }

        delete [] szDomain;
    }

}


VOID CRSOPComponentData::InitializeSitesInfo (HWND hDlg)
{
    LPTSTR szDomain = NULL;
    TCHAR szName[1024];
    DWORD dwSize;
    PDS_NAME_RESULTW pSites;
    int iInitialSite = 0;
    int iIndex, iDefault = CB_ERR;
    HANDLE hDs;
    DWORD dw, n;


    SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_RESETCONTENT, 0, 0);

    //
    // Determine which domain to use for the bind
    //

    if (m_szUserName)
    {
        //
        // Try and get the user's domain
        //

        szDomain = ExtractDomain(m_szUserName);
    }

    if (!szDomain && m_szComputerName)
    {
        //
        // Try and get the computer's domain
        //

        szDomain = ExtractDomain(m_szComputerName);
    }

    if (!szDomain)
    {
        //
        // use the local domain
        //

        dwSize = ARRAYSIZE(szName);

        if (GetUserNameEx(NameSamCompatible, szName, &dwSize))
        {
            szDomain = ExtractDomain(szName);
        }
    }


    //
    // Bind to the domain
    //

    dw = DsBindW(NULL, szDomain, &hDs);

    if (dw == ERROR_SUCCESS)
    {
        //
        // If we have a site pref, show only that..
        //

        if (m_szSitePref) {

            LPWSTR szSiteFriendlyName=NULL;

            //
            // Get the friendly name
            //

            if (GetSiteFriendlyName(m_szSitePref, &szSiteFriendlyName)) {
                SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_ADDSTRING,
                            (WPARAM) 0, (LPARAM) (LPCTSTR) szSiteFriendlyName);
                delete [] szSiteFriendlyName;
            }
        }
        else {
            
            //
            // Query for the list of sites
            //

            dw = DsListSitesW(hDs, &pSites);

            if (dw == ERROR_SUCCESS)
            {
                for (n = 0; n < pSites->cItems; n++)
                {
                    //
                    // Add the site name (if it has a name)
                    //

                    if (pSites->rItems[n].pName)
                    {
                        LPWSTR szSiteFriendlyName=NULL;

                        if (GetSiteFriendlyName(pSites->rItems[n].pName, &szSiteFriendlyName)) {
                            SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_ADDSTRING,
                                        (WPARAM) 0, (LPARAM) (LPCTSTR) szSiteFriendlyName);

                            delete [] szSiteFriendlyName;
                        }
                    }
                }

                DsFreeNameResultW(pSites);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeSitesInfo: DsListSites failed with 0x%x"), dw));
            }

        }

        DsUnBindW(&hDs);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeSitesInfo: DsBindW failed with 0x%x"), dw));
    }


    if (!m_szSitePref) {
        LoadString (g_hInstance, IDS_NONE, szName, ARRAYSIZE(szName));
    
        iIndex = (int) SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_ADDSTRING,
                                   (WPARAM) 0, (LPARAM) (LPCTSTR) szName);
    }

    //
    // Set the initial selection
    //


    if (m_szSitePref) {
        iDefault = (INT) SendMessage (GetDlgItem(hDlg, IDC_COMBO1), CB_FINDSTRINGEXACT,
                                (WPARAM) -1, (LPARAM) m_szSitePref);
    }

    if (m_szSite)
    {
        iDefault = (INT) SendMessage (GetDlgItem(hDlg, IDC_COMBO1), CB_FINDSTRINGEXACT,
                                (WPARAM) -1, (LPARAM) m_szSite);
    }


    SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_SETCURSEL,
                (WPARAM) (iDefault == CB_ERR) ? iIndex : iDefault, NULL);


    if (szDomain)
    {
        delete [] szDomain;
    }


}

INT_PTR CALLBACK CRSOPComponentData::RSOPGetDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData *    pCD;
    BOOL                    bEnable;

    switch (message)
    {
    case WM_INITDIALOG:
        {
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        }
        break;

    case WM_COMMAND:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (LOWORD(wParam))
        {
            case IDC_CHECK2:
                if (SendMessage (GetDlgItem(hDlg, IDC_CHECK2), BM_GETCHECK, 0, 0))
                {
                    pCD->m_loopbackMode = LoopbackReplace;
                    SendMessage (GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_CHECKED, 0);            
                    SendMessage (GetDlgItem(hDlg, IDC_RADIO3), BM_SETCHECK, BST_UNCHECKED, 0);
                    bEnable = TRUE;
                    if (NULL == pCD->m_szUserName && NULL == pCD->m_szUserSOM)
                        bEnable = FALSE;
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), bEnable);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), bEnable);
                }
                else
                {
                    pCD->m_loopbackMode = LoopbackNone;
                    SendMessage (GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_UNCHECKED, 0);            
                    SendMessage (GetDlgItem(hDlg, IDC_RADIO3), BM_SETCHECK, BST_UNCHECKED, 0);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), FALSE);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);
                }
                break;
            case IDC_RADIO2:
                pCD->m_loopbackMode = LoopbackReplace;
                break;
            case IDC_RADIO3:
                pCD->m_loopbackMode = LoopbackMerge;
                break;
        }
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_SETACTIVE:
            {
                SetWaitCursor();
                pCD->InitializeSitesInfo (hDlg);

                if ((LoopbackNone == pCD->m_loopbackMode) ||
                    (LoopbackMerge == pCD->m_loopbackMode && ((NULL == pCD->m_szUserName && NULL == pCD->m_szUserSOM) || 
                                                              (NULL == pCD->m_szComputerName && NULL == pCD->m_szComputerSOM))
                     ) ||
                    (LoopbackReplace == pCD->m_loopbackMode && NULL == pCD->m_szComputerName && NULL == pCD->m_szComputerSOM)
                    )
                {
                    pCD->m_loopbackMode = LoopbackNone;
                    SendMessage (GetDlgItem(hDlg, IDC_CHECK2), BM_SETCHECK, BST_UNCHECKED, 0);            
                    SendMessage (GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_UNCHECKED, 0);            
                    SendMessage (GetDlgItem(hDlg, IDC_RADIO3), BM_SETCHECK, BST_UNCHECKED, 0);
                    if (NULL == pCD->m_szComputerName && NULL == pCD->m_szComputerSOM)
                        EnableWindow (GetDlgItem(hDlg, IDC_CHECK2), FALSE);
                    else
                        EnableWindow (GetDlgItem(hDlg, IDC_CHECK2), TRUE);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), FALSE);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);
                }
                else if (LoopbackReplace == pCD->m_loopbackMode)
                {
                    bEnable = TRUE;
                    if (NULL == pCD->m_szUserName && NULL == pCD->m_szUserSOM)
                        bEnable = FALSE;
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), bEnable);
                    EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), bEnable);
                }
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                ClearWaitCursor();
            }
            break;

        case PSN_WIZNEXT:

            SetWaitCursor();

            GetControlText(hDlg, IDC_COMBO1, pCD->m_szSite);

            if (pCD->m_szSite)
            {
                TCHAR szName[30];

                LoadString (g_hInstance, IDS_NONE, szName, ARRAYSIZE(szName));

                if (!lstrcmpi(pCD->m_szSite, szName))
                {
                    delete [] pCD->m_szSite;
                    pCD->m_szSite = NULL;
                }
            }

            if (SendMessage(GetDlgItem(hDlg, IDC_CHECK1), BM_GETCHECK, 0, 0))
            {
                pCD->m_bSlowLink = TRUE;
            }
            else
            {
                pCD->m_bSlowLink = FALSE;
            }

            ClearWaitCursor();

            if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
            {
                pCD->m_dwSkippedFrom = IDD_RSOP_GETDC;
                // skip to the diagnostic pages
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                return TRUE;
            }


            if ((NULL == pCD->m_szUserName) && (NULL == pCD->m_szComputerName))
            {
                pCD->m_dwSkippedFrom = IDD_RSOP_GETDC;

                if (pCD->m_szUserSOM || LoopbackNone != pCD->m_loopbackMode)
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTUSERSEC);
                }
                else if (pCD->m_szComputerSOM)
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTCOMPSEC);
                }
                else
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                }
                return TRUE;
            }

            pCD->m_dwSkippedFrom = 0;

            break;

        case PSN_WIZFINISH:
            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

HRESULT CRSOPComponentData::TestSOM (LPTSTR lpSOM, HWND hDlg)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPTSTR lpFullName;
    IDirectoryObject * pObject;
    ADS_OBJECT_INFO *pInfo;


    if (!lpSOM)
    {
        return E_INVALIDARG;
    }


    lpFullName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpSOM) + 10) * sizeof(TCHAR));

    if (lpFullName)
    {
        lstrcpy (lpFullName, TEXT("LDAP://"));
        lstrcat (lpFullName, lpSOM);

        hr = OpenDSObject(lpFullName, IID_IDirectoryObject, (void**)&pObject);

        if (SUCCEEDED(hr))
        {
            hr = pObject->GetObjectInformation (&pInfo);

            if (SUCCEEDED(hr))
            {
                if (!lstrcmpi (pInfo->pszClassName, TEXT("user")))
                {
                    hr = E_INVALIDARG;
                    ReportError (hDlg, hr, IDS_BADUSERSOM);
                }
                else if (!lstrcmpi (pInfo->pszClassName, TEXT("computer")))
                {
                    hr = E_INVALIDARG;
                    ReportError (hDlg, hr, IDS_BADCOMPUTERSOM);
                }

                FreeADsMem (pInfo);
            }

            pObject->Release();
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestSOM: OpenDSObject to %s failed with 0x%x"), lpFullName, hr));
        }

        LocalFree (lpFullName);
    }

    return hr;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPAltDirsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        break;

    case WM_COMMAND:
        {
            DSBROWSEINFO dsbi = {0};
            TCHAR szResult[MAX_PATH];
            TCHAR szTitle[256];
            TCHAR szCaption[256];
            dsbi.hwndOwner = hDlg;
            dsbi.pszCaption = szTitle;
            dsbi.pszTitle = szCaption;
            dsbi.cbStruct = sizeof(dsbi);
            dsbi.pszPath = szResult;
            dsbi.cchPath = ARRAYSIZE(szResult);
            dsbi.dwFlags = DSBI_ENTIREDIRECTORY;
            dsbi.pfnCallback = DsBrowseCallback;

            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON1:
                // browse for user's OU
                {
                    LoadString(g_hInstance,
                               IDS_BROWSE_USER_OU_TITLE,
                               szTitle,
                               ARRAYSIZE(szTitle));
                    LoadString(g_hInstance,
                               IDS_BROWSE_USER_OU_CAPTION,
                               szCaption,
                               ARRAYSIZE(szCaption));
                    if (IDOK == DsBrowseForContainer(&dsbi))
                    {
                        SetDlgItemText(hDlg, IDC_EDIT1, (szResult+7));
                    }
                }
                break;
            case IDC_BUTTON2:
                // browse for computer's OU
                {
                    LoadString(g_hInstance,
                               IDS_BROWSE_COMPUTER_OU_TITLE,
                               szTitle,
                               ARRAYSIZE(szTitle));
                    LoadString(g_hInstance,
                               IDS_BROWSE_COMPUTER_OU_CAPTION,
                               szCaption,
                               ARRAYSIZE(szCaption));
                    if (IDOK == DsBrowseForContainer(&dsbi))
                    {
                        SetDlgItemText(hDlg, IDC_EDIT2, (szResult+7));
                    }
                }
                break;

            case IDC_BUTTON3:
                if (IsWindowEnabled (GetDlgItem(hDlg, IDC_EDIT1)))
                {
                    if (pCD->m_szDefaultUserSOM)
                    {
                        SetDlgItemText (hDlg, IDC_EDIT1, pCD->m_szDefaultUserSOM);
                    }
                }

                if (IsWindowEnabled (GetDlgItem(hDlg, IDC_EDIT2)))
                {
                    if (pCD->m_szDefaultComputerSOM)
                    {
                        SetDlgItemText (hDlg, IDC_EDIT2, pCD->m_szDefaultComputerSOM);
                    }
                }
                break;
            }
        }

        break;
    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);


            EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
            SetDlgItemText (hDlg, IDC_EDIT1, TEXT(""));

            if (pCD->m_szUserSOM)
            {
                SetDlgItemText (hDlg, IDC_EDIT1, pCD->m_szUserSOM);
                if (!pCD->m_szUserName)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
                }
            }
            else if (pCD->m_szDefaultUserSOM)
            {
                SetDlgItemText (hDlg, IDC_EDIT1, pCD->m_szDefaultUserSOM);
            }
            else if (!pCD->m_szUserName)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
            }


            EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
            SetDlgItemText (hDlg, IDC_EDIT2, TEXT(""));

            if (pCD->m_szComputerSOM)
            {
                SetDlgItemText (hDlg, IDC_EDIT2, pCD->m_szComputerSOM);
                if (!pCD->m_szComputerName)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                }
            }
            else if (pCD->m_szDefaultComputerSOM)
            {
                SetDlgItemText (hDlg, IDC_EDIT2, pCD->m_szDefaultComputerSOM);
            }
            else if (!pCD->m_szComputerName)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
            }

            if (IsWindowEnabled (GetDlgItem(hDlg, IDC_EDIT1)) ||
                IsWindowEnabled (GetDlgItem(hDlg, IDC_EDIT2)))
            {
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON3), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
            }
            break;

        case PSN_WIZNEXT:
            {
            LPTSTR lpUserSOM = NULL, lpComputerSOM = NULL;
            HRESULT hr;


            GetControlText(hDlg, IDC_EDIT1, lpUserSOM);
            GetControlText(hDlg, IDC_EDIT2, lpComputerSOM);

            if (lpUserSOM)
            {
                hr = pCD->TestSOM (lpUserSOM, hDlg);

                if (FAILED(hr))
                {
                    if (hr != E_INVALIDARG)
                    {
                        ReportError (hDlg, hr, IDS_NOUSERCONTAINER);
                    }

                    if (lpUserSOM)
                    {
                        delete [] lpUserSOM;
                    }

                    if (lpComputerSOM)
                    {
                        delete [] lpComputerSOM;
                    }

                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }
            }

            if (lpComputerSOM)
            {
                hr = pCD->TestSOM (lpComputerSOM, hDlg);

                if (FAILED(hr))
                {
                    if (hr != E_INVALIDARG)
                    {
                        ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);
                    }

                    if (lpUserSOM)
                    {
                        delete [] lpUserSOM;
                    }

                    if (lpComputerSOM)
                    {
                        delete [] lpComputerSOM;
                    }

                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }
            }

            pCD->m_szUserSOM = lpUserSOM;
            pCD->m_szComputerSOM = lpComputerSOM;


            if (pCD->m_szDefaultUserSOM && pCD->m_szUserSOM)
            {
                if (!lstrcmpi(pCD->m_szDefaultUserSOM, pCD->m_szUserSOM))
                {
                    delete [] pCD->m_szUserSOM;
                    pCD->m_szUserSOM = NULL;
                }
            }

            if (pCD->m_szDefaultComputerSOM && pCD->m_szComputerSOM)
            {
                if (!lstrcmpi(pCD->m_szDefaultComputerSOM, pCD->m_szComputerSOM))
                {
                    delete [] pCD->m_szComputerSOM;
                    pCD->m_szComputerSOM = NULL;
                }
            }

            if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
            {
                pCD->m_dwSkippedFrom = IDD_RSOP_ALTDIRS;
                // skip to the diagnostic pages
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                return TRUE;
            }

            if ((NULL == pCD->m_szUserName) && (NULL == pCD->m_szUserSOM))
            {
                pCD->m_dwSkippedFrom = IDD_RSOP_ALTDIRS;

                if (pCD->m_szComputerName || pCD->m_szComputerSOM)
                {
                    if (LoopbackNone == pCD->m_loopbackMode)
                    {
                        // skip to the alternate computer security page
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTCOMPSEC);
                    }
                    else
                    {
                        // Skip to the alternate user security page if simulating loopback mode
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTUSERSEC);
                    }
                }
                else
                {
                    // skip to the finish page
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                }
                return TRUE;
            }

            pCD->m_dwSkippedFrom = 0;
            }
            break;

        case PSN_WIZFINISH:
            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

VOID CRSOPComponentData::AddDefaultGroups (HWND hLB)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    PSID  psidUser, psidEveryone;
    DWORD dwNameSize, dwDomainSize;
    TCHAR szName[200];
    TCHAR szDomain[50];
    SID_NAME_USE SidName;
    INT iIndex;


    //
    // Get the authenticated users sid
    //

    if (AllocateAndInitializeSid(&authNT, 1, SECURITY_AUTHENTICATED_USER_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidUser))
    {
        //
        // Get the friendly display name and add it to the list
        //

        dwNameSize = ARRAYSIZE(szName);
        dwDomainSize = ARRAYSIZE(szDomain);

        if (LookupAccountSid (NULL, psidUser, szName, &dwNameSize,
                              szDomain, &dwDomainSize, &SidName))
        {
            iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szName);
            SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) 1);
        }

        FreeSid(psidUser);
    }


    //
    // Get the everyone sid
    //

    if (AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryone))
    {
        //
        // Get the friendly display name and add it to the list
        //

        dwNameSize = ARRAYSIZE(szName);
        dwDomainSize = ARRAYSIZE(szDomain);

        if (LookupAccountSid (NULL, psidEveryone, szName, &dwNameSize,
                              szDomain, &dwDomainSize, &SidName))
        {
            iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szName);
            SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) 1);
        }

        FreeSid(psidEveryone);
    }

}

VOID CRSOPComponentData::GetPrimaryGroup (HWND hLB, IDirectoryObject * pDSObj)
{
    HRESULT hr;
    PADS_ATTR_INFO spAttrs;
    WCHAR wzObjectSID[] = L"objectSid";
    WCHAR wzPrimaryGroup[] = L"primaryGroupID";
    PWSTR rgpwzAttrNames[] = {wzObjectSID, wzPrimaryGroup};
    DWORD cAttrs = 2, i;
    DWORD dwOriginalPriGroup;
    LPBYTE pObjSID = NULL;
    UCHAR * psaCount, iIndex;
    PSID pSID = NULL;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD rgRid[8];
    TCHAR szName[200];
    TCHAR szDomain[300];
    TCHAR szFullName[501];
    DWORD dwNameSize, dwDomainSize;
    SID_NAME_USE SidName;


    //
    // Get the SID and perhaps the Primary Group attribute values.
    //

    hr = pDSObj->GetObjectAttributes(rgpwzAttrNames, cAttrs, &spAttrs, &cAttrs);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: GetObjectAttributes failed with 0x%x"), hr));
        return;
    }

    for (i = 0; i < cAttrs; i++)
    {
        if (_wcsicmp(spAttrs[i].pszAttrName, wzPrimaryGroup) == 0)
        {
            dwOriginalPriGroup = spAttrs[i].pADsValues->Integer;
            continue;
        }

        if (_wcsicmp(spAttrs[i].pszAttrName, wzObjectSID) == 0)
        {
            pObjSID = new BYTE[spAttrs[i].pADsValues->OctetString.dwLength];

            if (!pObjSID)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: Failed to allocate memory for sid with %d"), GetLastError()));
                goto Exit;
            }

            memcpy(pObjSID, spAttrs[i].pADsValues->OctetString.lpValue,
                   spAttrs[i].pADsValues->OctetString.dwLength);
        }
    }

    if (!IsValidSid (pObjSID))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: SID is not valid.")));
        goto Exit;
    }


    psaCount = GetSidSubAuthorityCount(pObjSID);

    if (psaCount == NULL)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: GetSidSubAuthorityCount failed with %d"), GetLastError()));
        goto Exit;
    }

    if (*psaCount > 8)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: psaCount is greater than 8")));
        goto Exit;
    }

    for (iIndex = 0; iIndex < (*psaCount - 1); iIndex++)
    {
        PDWORD pRid = GetSidSubAuthority(pObjSID, (DWORD)iIndex);
        if (pRid == NULL)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: GetSidSubAuthority failed with %d"), GetLastError()));
            goto Exit;
        }
        rgRid[iIndex] = *pRid;
    }

    rgRid[*psaCount - 1] = dwOriginalPriGroup;

    for (iIndex = *psaCount; iIndex < 8; iIndex++)
    {
        rgRid[iIndex] = 0;
    }

    psia = GetSidIdentifierAuthority(pObjSID);

    if (psia == NULL)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: GetSidIdentifierAuthorityCount failed with %d"), GetLastError()));
        goto Exit;
    }

    if (!AllocateAndInitializeSid(psia, *psaCount, rgRid[0], rgRid[1],
                                  rgRid[2], rgRid[3], rgRid[4],
                                  rgRid[5], rgRid[6], rgRid[7], &pSID))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: AllocateAndInitializeSid failed with %d"), GetLastError()));
        goto Exit;
    }


    dwNameSize = ARRAYSIZE(szName);
    dwDomainSize = ARRAYSIZE(szDomain);
    if (LookupAccountSid (NULL, pSID, szName, &dwNameSize, szDomain, &dwDomainSize,
                          &SidName))
    {
        wsprintf (szFullName, TEXT("%s\\%s"), szDomain, szName);
        SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szFullName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: LookupAccountSid failed with %d"), GetLastError()));
    }

    FreeSid (pSID);

Exit:
    FreeADsMem (spAttrs);

    if (pObjSID)
    {
        delete [] pObjSID;
    }

}

HRESULT CRSOPComponentData::BuildMembershipList (HWND hLB, IDirectoryObject * pDSObj, SAFEARRAY **psaSecGrp, DWORD ** pdwSecGrpAttr)
{
    HRESULT hr;
    PADS_ATTR_INFO spAttrs;
    DWORD i, j, cAttrs = 0;
    WCHAR wzMembershipAttr[MAX_PATH] = L"memberOf;range=0-*";
    const WCHAR wcSep = L'-';
    const WCHAR wcEnd = L'*';
    const WCHAR wzFormat[] = L"memberOf;range=%ld-*";
    BOOL fMoreRemain = FALSE;
    PWSTR rgpwzAttrNames[] = {wzMembershipAttr};
    TCHAR szDisplayName[MAX_PATH];
    ULONG ulSize;
    LPTSTR lpFullName, lpTemp;
    IADs * pGroup;
    VARIANT varType;

    SetWaitCursor();
    SendMessage (hLB, WM_SETREDRAW, FALSE, 0);
    SendMessage (hLB, LB_RESETCONTENT, 0, 0);


    AddDefaultGroups (hLB);
    if (!pDSObj)
        goto BuildMembershipListEnd;

    GetPrimaryGroup (hLB, pDSObj);

    //
    // Read the membership list from the object. First read the attribute off
    // of the actual object which will give all memberships in the object's
    // domain (including local groups which are not replicated to the GC).
    //
    do
    {
        hr = pDSObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

        if (SUCCEEDED(hr))
        {
            if (cAttrs > 0 && spAttrs != NULL)
            {
                for (i = 0; i < spAttrs->dwNumValues; i++)
                {
                    ulSize = (lstrlen(spAttrs->pADsValues[i].CaseIgnoreString) + 10);
                    lpFullName = (LPTSTR) LocalAlloc (LPTR,  ulSize * sizeof(TCHAR));

                    if (lpFullName)
                    {
                        lstrcpy (lpFullName, TEXT("LDAP://"));
                        lstrcat (lpFullName, spAttrs->pADsValues[i].CaseIgnoreString);

                        hr = OpenDSObject(lpFullName, IID_IADs, (void**)&pGroup);

                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(pGroup->Get(TEXT("groupType"), &varType)))
                            {
                                if ( varType.lVal & 0x80000000)
                                {
                                    if ( varType.lVal & 0x5)
                                    {
                                        lpTemp = lpFullName;

                                        while (*lpTemp && (*lpTemp != TEXT(',')))
                                        {
                                            lpTemp++;
                                        }

                                        if (*lpTemp)
                                        {
                                            *lpTemp = TEXT('\0');
                                            SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) (lpFullName+10));
                                        }
                                    }
                                    else
                                    {
                                        if (TranslateName (spAttrs->pADsValues[i].CaseIgnoreString, NameFullyQualifiedDN,
                                                           NameSamCompatible, lpFullName, &ulSize))
                                        {
                                            SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) lpFullName);
                                        }
                                    }
                                }
                                VariantClear (&varType);
                            }
                            pGroup->Release();
                        }

                        LocalFree (lpFullName);
                    }
                }

                //
                // Check to see if there is more data. If the last char of the
                // attribute name string is an asterisk, then we have everything.
                //
                int cchEnd = wcslen(spAttrs->pszAttrName);

                fMoreRemain = spAttrs->pszAttrName[cchEnd - 1] != wcEnd;

                if (fMoreRemain)
                {
                    PWSTR pwz = wcsrchr(spAttrs->pszAttrName, wcSep);
                    if (!pwz)
                    {
                        fMoreRemain = FALSE;
                    }
                    else
                    {
                        pwz++; // move past the hyphen to the range end value.
                        long lEnd = _wtol(pwz);
                        lEnd++; // start with the next value.
                        wsprintfW(wzMembershipAttr, wzFormat, lEnd);
                        DebugMsg((DM_VERBOSE, TEXT("Range returned is %s, now asking for %s"),
                                 spAttrs->pszAttrName, wzMembershipAttr));
                    }
                }
            }

            FreeADsMem (spAttrs);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildMembershipList: GetObjectAttributes failed with 0x%s"), hr));
        }

    } while (fMoreRemain);

BuildMembershipListEnd:
    SendMessage (hLB, LB_SETCURSEL, 0, 0);
    SendMessage (hLB, WM_SETREDRAW, TRUE, 0);
    UpdateWindow (hLB);

    SaveSecurityGroups (hLB, psaSecGrp, pdwSecGrpAttr);

    ClearWaitCursor();

    return S_OK;
}

HRESULT CRSOPComponentData::SaveSecurityGroups (HWND hLB, SAFEARRAY **psaSecGrp, DWORD **pdwSecGrpAttr)
{
    SAFEARRAY * psa;
    SAFEARRAYBOUND rgsabound[1];
    LONG i, lCount = (LONG) SendMessage (hLB, LB_GETCOUNT, 0, 0);
    DWORD dwLen;
    LPTSTR lpText;
    BSTR bstrText;
    HRESULT hr;


    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lCount;

    *pdwSecGrpAttr = (DWORD *)LocalAlloc(LPTR, sizeof(DWORD)*lCount);


    psa = SafeArrayCreate (VT_BSTR, 1, rgsabound);

    if ((!psa) || (!(*pdwSecGrpAttr)))
    {
        return E_OUTOFMEMORY;
    }

    for (i = 0; i < lCount; i++)
    {

        dwLen = (DWORD) SendMessage (hLB, LB_GETTEXTLEN, (WPARAM) i, 0);

        if (dwLen != LB_ERR)
        {
            lpText = (LPTSTR) LocalAlloc (LPTR, (dwLen+2) * sizeof(TCHAR));

            if (lpText)
            {
                if (SendMessage (hLB, LB_GETTEXT, (WPARAM) i, (LPARAM) lpText) != LB_ERR)
                {
                    LONG lFlags;
                    BOOL bDollarRemoved;
                    lFlags = (LONG) SendMessage (hLB, LB_GETITEMDATA, (WPARAM) i, 0);

                    bDollarRemoved = (lFlags & 2);

                    if (bDollarRemoved) {
                        lpText[wcslen(lpText)] = L'$';
                    }

                    if (lFlags & 1) { // default grps
                        (*pdwSecGrpAttr)[i] = 1;
                    }

                    bstrText = SysAllocString (lpText);
                    if (bstrText)
                    {
                        hr = SafeArrayPutElement(psa, &i, bstrText);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::SaveSecurityGroups: SafeArrayPutElement failed with 0x%x."), hr));
                        }
                    }
                }
                LocalFree (lpText);
            }
        }
    }

    *psaSecGrp = psa;

    return S_OK;
}

VOID CRSOPComponentData::FillListFromSafeArraySecurityGroup (HWND hLB, SAFEARRAY * psa, DWORD * pdwSecGrpAttr)
{
    LONG lIndex, lMax;
    LPTSTR lpText;

    SetWaitCursor();
    SendMessage (hLB, WM_SETREDRAW, FALSE, 0);
    SendMessage (hLB, LB_RESETCONTENT, 0, 0);

    if (psa)
    {
        if (SUCCEEDED(SafeArrayGetUBound (psa, 1, &lMax)))
        {
            for (lIndex = 0; lIndex <= lMax; lIndex++)
            {
                if (SUCCEEDED(SafeArrayGetElement(psa, &lIndex, &lpText)))
                {
                    BOOL bDollarRemoved = FALSE;

                    if (lpText[wcslen(lpText)-1] == L'$')
                    {
                        bDollarRemoved = TRUE;
                        lpText[wcslen(lpText)-1] = 0;
                    }

                    INT iIndex;
                    iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) lpText);
                    if (pdwSecGrpAttr[lIndex] & 1) {
                        SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) 1);
                    }
                    else {
                        SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) (bDollarRemoved) ? 2 : 0);
                    }

                    // we just modified it, set it back
                    if (bDollarRemoved) {
                        lpText[wcslen(lpText)] = L'$';
                    }
                }
            }
        }
    }

    SendMessage (hLB, LB_SETCURSEL, 0, 0);
    SendMessage (hLB, WM_SETREDRAW, TRUE, 0);
    UpdateWindow (hLB);
    ClearWaitCursor();
}

BOOL CRSOPComponentData::CompareSafeArrays(SAFEARRAY *psa1, SAFEARRAY *psa2)
{
    LONG lIndex1, lMax1;
    LONG lIndex2, lMax2;
    LPTSTR lpText1;
    LPTSTR lpText2;
    BOOL bFound;


    //
    // Null ptr checks
    //

    if (!psa1 && !psa2)
    {
        return TRUE;
    }

    if (!psa1 && psa2)
    {
        return FALSE;
    }

    if (psa1 && !psa2)
    {
        return FALSE;
    }


    //
    // Get the array sizes
    //

    if (FAILED(SafeArrayGetUBound (psa1, 1, &lMax1)))
    {
        return FALSE;
    }

    if (FAILED(SafeArrayGetUBound (psa2, 1, &lMax2)))
    {
        return FALSE;
    }


    //
    // Check if the same number of entries are in the arrays
    //

    if (lMax1 != lMax2)
    {
        return FALSE;
    }


    //
    // Loop through comparing item by item
    //

    for (lIndex1 = 0; lIndex1 <= lMax1; lIndex1++)
    {
        if (FAILED(SafeArrayGetElement(psa1, &lIndex1, &lpText1)))
        {
            return FALSE;
        }

        bFound = FALSE;

        for (lIndex2 = 0; lIndex2 <= lMax2; lIndex2++)
        {
            if (FAILED(SafeArrayGetElement(psa2, &lIndex2, &lpText2)))
            {
                return FALSE;
            }

            if (!lstrcmpi(lpText1, lpText2))
            {
                bFound = TRUE;
            }
        }

        if (!bFound)
        {
            return FALSE;
        }
    }

    return TRUE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPAltUserSecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON1:
                {
                TCHAR * sz;

                ImplementBrowseButton(hDlg, (DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE),
                                      (DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS),
                                      (DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS),
                                      GetDlgItem(hDlg, IDC_LIST1), sz);

                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON2:
                {
                    INT iIndex;

                    iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iIndex != LB_ERR)
                    {
                        if ((SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM) iIndex, 0) & 1) == 0)
                        {
                            SendDlgItemMessage (hDlg, IDC_LIST1, LB_DELETESTRING, (WPARAM) iIndex, 0);
                            SendDlgItemMessage (hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM) iIndex, 0);
                        }
                    }

                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON3:
                {

                if (pCD->m_saUserSecurityGroups)
                {
                    SafeArrayDestroy (pCD->m_saUserSecurityGroups);
                    pCD->m_saUserSecurityGroups = NULL;
                }

                pCD->FillListFromSafeArraySecurityGroup(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saDefaultUserSecurityGroups, pCD->m_saDefaultUserSecurityGroupsAttr);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_LIST1:
                if (HIWORD(wParam) == LBN_SELCHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            }
        }

        break;

    case WM_REFRESHDISPLAY:
        if (SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0) > 0)
        {
            INT iIndex;

            iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

            if (iIndex != LB_ERR)
            {
                if ((SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM) iIndex, 0) & 1) == 0)
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
                }
                else
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                }
            }
        } else {
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
        }
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);

            if (pCD->m_saUserSecurityGroups)
            {
                pCD->FillListFromSafeArraySecurityGroup(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saUserSecurityGroups, pCD->m_saUserSecurityGroupsAttr);
            }
            else if (pCD->m_saDefaultUserSecurityGroups)
            {
                pCD->FillListFromSafeArraySecurityGroup(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saDefaultUserSecurityGroups, pCD->m_saDefaultUserSecurityGroupsAttr);
            }
            else
            {
                pCD->BuildMembershipList (GetDlgItem(hDlg, IDC_LIST1), pCD->m_pUserObject, &(pCD->m_saDefaultUserSecurityGroups), &(pCD->m_saDefaultUserSecurityGroupsAttr));
            }

            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);

            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            break;

        case PSN_WIZNEXT:

            //
            // Free the previous list of security groups
            //
            if (pCD->m_saUserSecurityGroups)
            {
                SafeArrayDestroy (pCD->m_saUserSecurityGroups);
            }


            if (pCD->m_saUserSecurityGroupsAttr) {
                LocalFree(pCD->m_saUserSecurityGroupsAttr);
            }

            //
            // Save the current list
            //

            pCD->SaveSecurityGroups (GetDlgItem(hDlg, IDC_LIST1), &(pCD->m_saUserSecurityGroups), &(pCD->m_saUserSecurityGroupsAttr));


            //
            // Compare the current list with the default list.  If the default list
            // matches the current list, then delete the current list and just use
            // the defaults
            //

            if (pCD->CompareSafeArrays(pCD->m_saUserSecurityGroups, pCD->m_saDefaultUserSecurityGroups))
            {
                if (pCD->m_saUserSecurityGroups)
                {
                    SafeArrayDestroy (pCD->m_saUserSecurityGroups);
                    pCD->m_saUserSecurityGroups = NULL;
                }
            }

            if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
            {
                pCD->m_dwSkippedFrom = IDD_RSOP_ALTUSERSEC;
                // skip to the diagnostic pages
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                return TRUE;
            }

            if ((NULL == pCD->m_szComputerName) && (NULL == pCD->m_szComputerSOM))
            {
                // skip to the finish page
                pCD->m_dwSkippedFrom = IDD_RSOP_ALTUSERSEC;
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WQLUSER);
                return TRUE;
            }

            pCD->m_dwSkippedFrom = 0;

            break;

        case PSN_WIZBACK:
            
            //
            // Free the previous list of security groups
            //
            if (pCD->m_saUserSecurityGroups)
            {
                SafeArrayDestroy (pCD->m_saUserSecurityGroups);
            }

            if (pCD->m_saUserSecurityGroupsAttr) {
                LocalFree(pCD->m_saUserSecurityGroupsAttr);
            }

            //
            // Save the current list
            //

            pCD->SaveSecurityGroups (GetDlgItem(hDlg, IDC_LIST1), &(pCD->m_saUserSecurityGroups), &(pCD->m_saUserSecurityGroupsAttr));


            if (!pCD->m_szUserName && !pCD->m_szComputerName)
            {
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETDC);
                return TRUE;
            }
            break;

        case PSN_WIZFINISH:
            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPAltCompSecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON1:
                {
                TCHAR * sz;

                ImplementBrowseButton(hDlg, (DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE),
                                      (DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS),
                                      (DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS),
                                      GetDlgItem(hDlg, IDC_LIST1), sz);

                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON2:
                {
                    INT iIndex;

                    iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iIndex != LB_ERR)
                    {
                        if ((SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM) iIndex, 0) & 1) == 0)
                        {
                            SendDlgItemMessage (hDlg, IDC_LIST1, LB_DELETESTRING, (WPARAM) iIndex, 0);
                            SendDlgItemMessage (hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM) iIndex, 0);
                        }
                    }

                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON3:
                {

                if (pCD->m_saComputerSecurityGroups)
                {
                    SafeArrayDestroy (pCD->m_saComputerSecurityGroups);
                    pCD->m_saComputerSecurityGroups = NULL;
                }

                pCD->FillListFromSafeArraySecurityGroup(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saDefaultComputerSecurityGroups, pCD->m_saDefaultComputerSecurityGroupsAttr);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_LIST1:
                if (HIWORD(wParam) == LBN_SELCHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            }
        }

        break;

    case WM_REFRESHDISPLAY:
        if (SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0) > 0)
        {
            INT iIndex;

            iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

            if (iIndex != LB_ERR)
            {
                if ((SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM) iIndex, 0) & 1) == 0)
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
                }
                else
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                }
            }
        } else {
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
        }
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);

            if (pCD->m_saComputerSecurityGroups)
            {
                pCD->FillListFromSafeArraySecurityGroup(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saComputerSecurityGroups, pCD->m_saComputerSecurityGroupsAttr);
            }
            else if (pCD->m_saDefaultComputerSecurityGroups)
            {
                pCD->FillListFromSafeArraySecurityGroup(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saDefaultComputerSecurityGroups, pCD->m_saDefaultComputerSecurityGroupsAttr);
            }
            else
            {
                pCD->BuildMembershipList (GetDlgItem(hDlg, IDC_LIST1), pCD->m_pComputerObject, &(pCD->m_saDefaultComputerSecurityGroups), &(pCD->m_saDefaultComputerSecurityGroupsAttr));
            }

            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);


            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            break;

        case PSN_WIZNEXT:

            //
            // Free the previous list of security groups
            //
            if (pCD->m_saComputerSecurityGroups)
            {
                SafeArrayDestroy (pCD->m_saComputerSecurityGroups);
            }

            if (pCD->m_saComputerSecurityGroupsAttr)
            {
                LocalFree (pCD->m_saComputerSecurityGroupsAttr);
            }

            //
            // Save the current list
            //

            pCD->SaveSecurityGroups (GetDlgItem(hDlg, IDC_LIST1), &(pCD->m_saComputerSecurityGroups), &(pCD->m_saComputerSecurityGroupsAttr));


            //
            // Compare the current list with the default list.  If the default list
            // matches the current list, then delete the current list and just use
            // the defaults
            //

            if (pCD->CompareSafeArrays(pCD->m_saComputerSecurityGroups, pCD->m_saDefaultComputerSecurityGroups))
            {
                if (pCD->m_saComputerSecurityGroups)
                {
                    SafeArrayDestroy (pCD->m_saComputerSecurityGroups);
                    pCD->m_saComputerSecurityGroups = NULL;
                }
            }


            if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
            {
                pCD->m_dwSkippedFrom = IDD_RSOP_ALTCOMPSEC;
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                return TRUE;
            }

            if ((NULL == pCD->m_szUserName) && (NULL == pCD->m_szUserSOM) && (LoopbackNone == pCD->m_loopbackMode))
            {
                pCD->m_dwSkippedFrom = IDD_RSOP_ALTCOMPSEC;
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WQLCOMP);
                return TRUE;
            }

            pCD->m_dwSkippedFrom = 0;

            break;

        case PSN_WIZBACK:
            
            //
            // Free the previous list of security groups
            //
            if (pCD->m_saComputerSecurityGroups)
            {
                SafeArrayDestroy (pCD->m_saComputerSecurityGroups);
            }


            if (pCD->m_saComputerSecurityGroupsAttr)
            {
                LocalFree (pCD->m_saComputerSecurityGroupsAttr);
            }

            //
            // Save the current list
            //

            pCD->SaveSecurityGroups (GetDlgItem(hDlg, IDC_LIST1), &(pCD->m_saComputerSecurityGroups), &(pCD->m_saComputerSecurityGroupsAttr));

            if (!pCD->m_szUserName && !pCD->m_szUserSOM)
            {
                if (pCD->m_szComputerName)
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTDIRS);
                }
                else
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETDC);
                }
                return TRUE;
            }
            break;

        case PSN_WIZFINISH:
            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

HRESULT CRSOPComponentData::ExtractWQLFilters (LPTSTR lpNameSpace, SAFEARRAY **psaNamesArg, SAFEARRAY **psaDataArg)
{
    HRESULT hr;
    ULONG n;
    IWbemClassObject * pObjGPO = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_GPO"));
    BSTR bstrFilterId = NULL;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    LPTSTR lpDisplayName;
    INT iIndex;
    SAFEARRAY * psaNames, *psaData;
    SAFEARRAYBOUND rgsabound[1];
    BSTR    *pWQLFilterIds, bstrText;
    LONG   lCount=0, lCountAllocated = 0, l=0;

    psaNames = psaData = NULL;
    pWQLFilterIds = NULL;

    //
    // Get a locator instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: CoCreateInstance failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Connect to the namespace
    //

    hr = pLocator->ConnectServer(lpNameSpace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: ConnectServer failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Query for the RSOP_GPO instances
    //

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }


    // allocate mem. 10 should be enough for most cases

    pWQLFilterIds = (BSTR *)LocalAlloc(LPTR, sizeof(BSTR)*(lCountAllocated+10));

    if (!pWQLFilterIds) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: LocalAlloc failed with 0x%x"), hr));
        goto cleanup;
    }
    

    lCountAllocated += 10;


    //
    // Loop through the results
    //

    while (TRUE)
    {

        //
        // Get one instance of RSOP_GPO
        //

        hr = pEnum->Next(WBEM_INFINITE, 1, &pObjGPO, &n);

        if (FAILED(hr) || (n == 0))
        {
            hr = S_OK;
            break;
        }


        //
        // Allocate more memory if necessary
        //

        if (lCount == lCountAllocated) {
            BSTR *pNewWQLFilterIds = (BSTR *)LocalAlloc(LPTR, sizeof(BSTR)*(lCountAllocated+10));

            if (!pNewWQLFilterIds) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: LocalAlloc failed with 0x%x"), hr));
                goto cleanup;
            }


            lCountAllocated += 10;

            for (l=0; l < lCount; l++) {
                pNewWQLFilterIds[l] = pWQLFilterIds[l];    
            }

            LocalFree(pWQLFilterIds);
            pWQLFilterIds = pNewWQLFilterIds;

        }

        //
        // Get the filter id
        //

        pWQLFilterIds[lCount] = NULL;
        hr = GetParameterBSTR(pObjGPO, TEXT("filterId"), pWQLFilterIds[lCount]);

        if (FAILED(hr))
        {
            goto LoopAgain;
        }

        if (!pWQLFilterIds[lCount] || !(*pWQLFilterIds[lCount]) || (*pWQLFilterIds[lCount] == TEXT(' ')))
        {
            if (pWQLFilterIds[lCount]) {
                SysFreeString(pWQLFilterIds[lCount]);
            }
            goto LoopAgain;
        }


#ifdef DBG
        BSTR bstrGPOName;

        bstrGPOName = NULL;
        hr = GetParameterBSTR(pObjGPO, TEXT("name"), bstrGPOName);

        if ( (SUCCEEDED(hr)) && (bstrGPOName) )
        {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::ExtractWQLFilters: Found filter on GPO <%s>"), bstrGPOName));
            SysFreeString (bstrGPOName);
            bstrGPOName = NULL;
        }

        hr = S_OK;
#endif

        //
        // eliminate duplicates
        //

        for (l=0; l < lCount; l++) {
            if (lstrcmpi(pWQLFilterIds[lCount], pWQLFilterIds[l]) == 0) {
                break;
            }
        }

        if ((lCount != 0) && (l != lCount)) {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::ExtractWQLFilters: filter = <%s> is a duplicate"), pWQLFilterIds[lCount]));
            SysFreeString(pWQLFilterIds[lCount]);
            goto LoopAgain;
        }

        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::ExtractWQLFilters: filter = <%s>"), pWQLFilterIds[lCount]));


        lCount++;

LoopAgain:

        pObjGPO->Release();
        pObjGPO = NULL;

    }

    //
    // Now allocate safe arrays. 
    // Notice that safe array is always allocated even if there are zero filters
    //

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lCount;

    psaNames = SafeArrayCreate (VT_BSTR, 1, rgsabound);

    if (!psaNames)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    psaData = SafeArrayCreate (VT_BSTR, 1, rgsabound);

    if (!psaData)
    {
        SafeArrayDestroy (psaNames);
        hr = E_FAIL;
        goto cleanup;
    }
    for (l = 0; l < lCount; l++) {
        hr = SafeArrayPutElement(psaData, &l, pWQLFilterIds[l]);

        if (SUCCEEDED(hr))
        {
            //
            // Get the filter's friendly display name
            //

            lpDisplayName = GetWMIFilterDisplayName (NULL, pWQLFilterIds[l], FALSE, TRUE);

            if (!lpDisplayName)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: Failed to get display name for filter id:  %s"), pWQLFilterIds[l]));
                bstrText = SysAllocString(pWQLFilterIds[l]);
            }
            else {
                bstrText = SysAllocString(lpDisplayName);
                delete lpDisplayName;
            }

            if (!bstrText) {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: Failed to Allocate memory for displayname")));
                hr = E_FAIL;
                goto cleanup;
            }

            hr = SafeArrayPutElement(psaNames, &l, bstrText);

            SysFreeString(bstrText);

            if (FAILED(hr)) {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: Failed to get display name for filter id:  %s"), pWQLFilterIds[l]));
                goto cleanup;
            }
        }
    }

    *psaNamesArg = psaNames;
    *psaDataArg = psaData;

    psaNames = NULL;
    psaData = NULL;

cleanup:

    if (bstrFilterId)
    {
        SysFreeString (bstrFilterId);
    }

    if (pObjGPO)
    {
        pObjGPO->Release();
    }

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pNamespace)
    {
        pNamespace->Release();
    }

    if (pLocator)
    {
        pLocator->Release();
    }

    if (pWQLFilterIds) {
        for (l=0; l < lCount; l++) {
            if (pWQLFilterIds[l])
                SysFreeString(pWQLFilterIds[l]);
        }

        LocalFree(pWQLFilterIds);
    }

    if (psaNames) {
        SafeArrayDestroy(psaNames);
    }

    if (psaData) {
        SafeArrayDestroy(psaData);
    }

    SysFreeString(strQueryLanguage);
    SysFreeString(strQuery);

    return hr;
}

VOID CRSOPComponentData::BuildWQLFilterList (HWND hDlg, BOOL bUser, SAFEARRAY **psaNames, SAFEARRAY **psaData)
{
    HRESULT hr;
    LPTSTR lpNameSpace, lpFullNameSpace, lpEnd;
    TCHAR szBuffer[150];
    HWND hLB = GetDlgItem (hDlg, IDC_LIST1);
    ULONG ulErrorInfo;

    //
    // Prepare to generate the rsop data.  Give the user a message in the listbox
    // and disable the controls on the page
    //

    SetWaitCursor();

    SendMessage (hLB, LB_RESETCONTENT, 0, 0);
    LoadString(g_hInstance, IDS_PLEASEWAIT, szBuffer, ARRAYSIZE(szBuffer));
    SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szBuffer);

    PropSheet_SetWizButtons (GetParent(hDlg), 0);
    EnableWindow (GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
    EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);


    //
    // Generate the rsop data using the info we have already
    //

    hr = GenerateRSOPData (NULL, &lpNameSpace, TRUE, TRUE, bUser, FALSE, &ulErrorInfo);

    SendMessage (hLB, LB_RESETCONTENT, 0, 0);

    if (FAILED (hr))
    {
        ReportError (hDlg, hr, IDS_EXECFAILED);
        goto Exit;
    }


    lpFullNameSpace = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpNameSpace) + 20) * sizeof(TCHAR));

    if (lpFullNameSpace)
    {
        lstrcpy (lpFullNameSpace, lpNameSpace);
        lpEnd = CheckSlash(lpFullNameSpace);

        if (bUser)
        {
            lstrcpy (lpEnd, TEXT("User"));
        }
        else
        {
            lstrcpy (lpEnd, TEXT("Computer"));
        }


        if (SUCCEEDED(ExtractWQLFilters (lpFullNameSpace, psaNames, psaData)))
        {
            FillListFromSafeArrays (hLB, *psaNames, *psaData);
        }

        LocalFree (lpFullNameSpace);
    }


    DeleteRSOPData (lpNameSpace);

Exit:

    PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
    EnableWindow (GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);
    EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), TRUE);


    ClearWaitCursor();
}

VOID CRSOPComponentData::FillListFromSafeArrays (HWND hLB, SAFEARRAY * psaNames, SAFEARRAY * psaData)
{
    LONG lIndex, lMax;
    INT iIndex;
    LPTSTR lpText;

    SetWaitCursor();
    SendMessage (hLB, WM_SETREDRAW, FALSE, 0);
    SendMessage (hLB, LB_RESETCONTENT, 0, 0);

    if (psaData)
    {
        if (SUCCEEDED(SafeArrayGetUBound (psaData, 1, &lMax)))
        {
            for (lIndex = 0; lIndex <= lMax; lIndex++)
            {
                if (SUCCEEDED(SafeArrayGetElement(psaNames, &lIndex, &lpText)))
                {
                    iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) lpText);
                    DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::FillListFromSafeArrays: Added WQL filter %s"), lpText));

                    if (iIndex != LB_ERR)
                    {
                        if (SUCCEEDED(SafeArrayGetElement(psaData, &lIndex, &lpText)))
                        {
                            SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpText);
                        }
                    }
                }
            }
        }
    }

    SendMessage (hLB, LB_SETCURSEL, 0, 0);
    SendMessage (hLB, WM_SETREDRAW, TRUE, 0);
    UpdateWindow (hLB);
    ClearWaitCursor();
}


VOID CRSOPComponentData::SaveWQLFilters (HWND hLB, SAFEARRAY **psaNamesArg, SAFEARRAY **psaDataArg)
{
    SAFEARRAY * psaNames, *psaData;
    SAFEARRAYBOUND rgsabound[1];
    LONG i, lLength, lCount = (LONG) SendMessage (hLB, LB_GETCOUNT, 0, 0);
    LPTSTR lpText, lpName;
    BSTR bstrText;
    HRESULT hr;


    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lCount;

    psaNames = SafeArrayCreate (VT_BSTR, 1, rgsabound);

    if (!psaNames)
    {
        return;
    }

    psaData = SafeArrayCreate (VT_BSTR, 1, rgsabound);

    if (!psaData)
    {
        SafeArrayDestroy (psaNames);
        return;
    }

    for (i = 0; i < lCount; i++)
    {
        lLength = (LONG) SendMessage (hLB, LB_GETTEXTLEN, (WPARAM) i, 0);

        lpName = new TCHAR [lLength + 1];

        if (lpName)
        {
            if (SendMessage (hLB, LB_GETTEXT, (WPARAM) i, (LPARAM) lpName) != LB_ERR)
            {
                bstrText = SysAllocString (lpName);

                if (bstrText)
                {
                    hr = SafeArrayPutElement(psaNames, &i, bstrText);

                    if (SUCCEEDED(hr))
                    {
                        lpText = (LPTSTR) SendMessage (hLB, LB_GETITEMDATA, (WPARAM) i, 0);

                        if (lpText)
                        {
                            bstrText = SysAllocString (lpText);
                            if (bstrText)
                            {
                                hr = SafeArrayPutElement(psaData, &i, bstrText);

                                if (FAILED(hr))
                                {
                                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::SaveWQLFilters: SafeArrayPutElement failed with 0x%x."), hr));
                                }
                            }
                        }
                    }
                }
            }

            delete [] lpName;
        }
    }

    *psaNamesArg = psaNames;
    *psaDataArg = psaData;
}


INT_PTR CALLBACK CRSOPComponentData::RSOPWQLUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;
    
    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON2:
                {
                    INT iIndex;

                    iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iIndex != LB_ERR)
                    {
                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_DELETESTRING, (WPARAM) iIndex, 0);
                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM) iIndex, 0);
                    }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON1:
                {

                if (pCD->m_saUserWQLFilters)
                {
                    SafeArrayDestroy (pCD->m_saUserWQLFilters);
                    pCD->m_saUserWQLFilters = NULL;
                }

                if (pCD->m_saUserWQLFilterNames)
                {
                    SafeArrayDestroy (pCD->m_saUserWQLFilterNames);
                    pCD->m_saUserWQLFilterNames = NULL;
                }

                pCD->m_bSkipUserWQLFilter = FALSE;

                if (pCD->m_saDefaultUserWQLFilters) {
                    pCD->FillListFromSafeArrays(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saDefaultUserWQLFilterNames, pCD->m_saDefaultUserWQLFilters);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                else {
                    PostMessage (hDlg, WM_BUILDWQLLIST, 0, 0);
                }
                
                }
                break;
            
            case IDC_RADIO2:
                {
                    if (pCD->m_saUserWQLFilters)
                    {
                        SafeArrayDestroy (pCD->m_saUserWQLFilters);
                        pCD->m_saUserWQLFilters = NULL;
                    }

                    if (pCD->m_saUserWQLFilterNames)
                    {
                        SafeArrayDestroy (pCD->m_saUserWQLFilterNames);
                        pCD->m_saUserWQLFilterNames = NULL;
                    }

                    pCD->m_bSkipUserWQLFilter = TRUE;
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            
            case IDC_RADIO3:
                {
                    pCD->m_bSkipUserWQLFilter = FALSE;
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            }
        }

        break;

    case WM_BUILDWQLLIST:
        {

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        pCD->BuildWQLFilterList (hDlg, TRUE, &pCD->m_saDefaultUserWQLFilterNames, &pCD->m_saDefaultUserWQLFilters);
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        }
        break;

    case WM_REFRESHDISPLAY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD->m_bSkipUserWQLFilter) {
            // set the listbox to null
            pCD->FillListFromSafeArrays(GetDlgItem(hDlg, IDC_LIST1), NULL, NULL);
            CheckDlgButton (hDlg, IDC_RADIO2, BST_CHECKED);
            CheckDlgButton (hDlg, IDC_RADIO3, BST_UNCHECKED);
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_LIST1), FALSE);
            ShowWindow(GetDlgItem(hDlg, IDC_LIST2), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_LIST1), SW_HIDE);
        }
        else {
            CheckDlgButton (hDlg, IDC_RADIO2, BST_UNCHECKED);
            CheckDlgButton (hDlg, IDC_RADIO3, BST_CHECKED);
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
            EnableWindow (GetDlgItem(hDlg, IDC_LIST1), TRUE);
            ShowWindow(GetDlgItem(hDlg, IDC_LIST1), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_LIST2), SW_HIDE);
            if (SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0) > 0)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
            }
            else
            {
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
            }
        }

        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);

            if (!(pCD->m_bSkipUserWQLFilter)) {
                pCD->FillListFromSafeArrays(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saUserWQLFilterNames, pCD->m_saUserWQLFilters);
            }

            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);

            break;

        case PSN_WIZNEXT:

            //
            // Free the previous list of WQL Filters
            //

            if (pCD->m_saUserWQLFilters)
            {
                SafeArrayDestroy (pCD->m_saUserWQLFilters);
                pCD->m_saUserWQLFilters = NULL;
            }

            if (pCD->m_saUserWQLFilterNames)
            {
                SafeArrayDestroy (pCD->m_saUserWQLFilterNames);
                pCD->m_saUserWQLFilterNames = NULL;
            }


            //
            // Save the current list
            //

            if (!pCD->m_bSkipUserWQLFilter) {
                pCD->SaveWQLFilters (GetDlgItem(hDlg, IDC_LIST1), &pCD->m_saUserWQLFilterNames,
                                     &pCD->m_saUserWQLFilters);
            }


            //
            // Move to the next page
            //

            if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
            {
                pCD->m_dwSkippedFrom = IDD_RSOP_WQLUSER;
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                return TRUE;
            }

            if ((NULL == pCD->m_szComputerName) && (NULL == pCD->m_szComputerSOM))
            {
                // skip to the finish page
                pCD->m_dwSkippedFrom = IDD_RSOP_WQLUSER;
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
                return TRUE;
            }

            pCD->m_dwSkippedFrom = 0;

            break;

        case PSN_WIZBACK:
            if (!pCD->m_szComputerName && !pCD->m_szComputerSOM)
            {
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTUSERSEC);
                return TRUE;
            }
            break;

        case PSN_WIZFINISH:
            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;

    }

    return FALSE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPWQLCompDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD)
            {
                break;
            }
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON2:
                {
                    INT iIndex;

                    iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iIndex != LB_ERR)
                    {
                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_DELETESTRING, (WPARAM) iIndex, 0);
                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM) iIndex, 0);
                    }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON1:
                {

                if (pCD->m_saComputerWQLFilters)
                {
                    SafeArrayDestroy (pCD->m_saComputerWQLFilters);
                    pCD->m_saComputerWQLFilters = NULL;
                }

                if (pCD->m_saComputerWQLFilterNames)
                {
                    SafeArrayDestroy (pCD->m_saComputerWQLFilterNames);
                    pCD->m_saComputerWQLFilterNames = NULL;
                }

                pCD->m_bSkipComputerWQLFilter = FALSE;

                if (pCD->m_saDefaultComputerWQLFilters) {
                    pCD->FillListFromSafeArrays(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saDefaultComputerWQLFilterNames, pCD->m_saDefaultComputerWQLFilters);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                else {
                    PostMessage (hDlg, WM_BUILDWQLLIST, 0, 0);
                }
                
                }
                break;

            case IDC_RADIO2:
                {
                    if (pCD->m_saComputerWQLFilters)
                    {
                        SafeArrayDestroy (pCD->m_saComputerWQLFilters);
                        pCD->m_saComputerWQLFilters = NULL;
                    }

                    if (pCD->m_saComputerWQLFilterNames)
                    {
                        SafeArrayDestroy (pCD->m_saComputerWQLFilterNames);
                        pCD->m_saComputerWQLFilterNames = NULL;
                    }

                    pCD->m_bSkipComputerWQLFilter = TRUE;
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            
            case IDC_RADIO3:
                {
                    pCD->m_bSkipComputerWQLFilter = FALSE;
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            }
        }

        break;

    case WM_BUILDWQLLIST:
        {

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        pCD->BuildWQLFilterList (hDlg, FALSE, &pCD->m_saDefaultComputerWQLFilterNames, &pCD->m_saDefaultComputerWQLFilters);
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        }
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD->m_bSkipComputerWQLFilter) {
            // set the listbox to null
            CheckDlgButton (hDlg, IDC_RADIO2, BST_CHECKED);
            CheckDlgButton (hDlg, IDC_RADIO3, BST_UNCHECKED);
            pCD->FillListFromSafeArrays(GetDlgItem(hDlg, IDC_LIST1), NULL, NULL);
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_LIST1), FALSE);
            ShowWindow(GetDlgItem(hDlg, IDC_LIST2), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_LIST1), SW_HIDE);
        }
        else {
            CheckDlgButton (hDlg, IDC_RADIO2, BST_UNCHECKED);
            CheckDlgButton (hDlg, IDC_RADIO3, BST_CHECKED);
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
            EnableWindow (GetDlgItem(hDlg, IDC_LIST1), TRUE);
            ShowWindow(GetDlgItem(hDlg, IDC_LIST1), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_LIST2), SW_HIDE);
            if (SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0) > 0)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
            }
            else
            {
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
            }
        }
        
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
            if (!(pCD->m_bSkipComputerWQLFilter)) {
                pCD->FillListFromSafeArrays(GetDlgItem(hDlg, IDC_LIST1), pCD->m_saComputerWQLFilterNames, pCD->m_saComputerWQLFilters);
            }

            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            break;

        case PSN_WIZNEXT:

            //
            // Free the previous list of WQL Filters
            //

            if (pCD->m_saComputerWQLFilters)
            {
                SafeArrayDestroy (pCD->m_saComputerWQLFilters);
                pCD->m_saComputerWQLFilters = NULL;
            }

            if (pCD->m_saComputerWQLFilterNames)
            {
                SafeArrayDestroy (pCD->m_saComputerWQLFilterNames);
                pCD->m_saComputerWQLFilterNames = NULL;
            }


            //
            // Save the current list
            //

            if (!pCD->m_bSkipComputerWQLFilter) {
                pCD->SaveWQLFilters (GetDlgItem(hDlg, IDC_LIST1), &pCD->m_saComputerWQLFilterNames, &pCD->m_saComputerWQLFilters);
            }


            pCD->m_dwSkippedFrom = 0;

            // skip to the last page in the wizard
            SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED3);
            return TRUE;


        case PSN_WIZBACK:
            if (!pCD->m_szUserName && !pCD->m_szUserSOM)
            {
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTCOMPSEC);
                return TRUE;
            }
            break;

        case PSN_WIZFINISH:
            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPFinishedDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:

        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        if (pCD)
        {
            pCD->InitializeResultsList (GetDlgItem (hDlg, IDC_LIST1));
        }

        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
        if (!pCD)
        {
            break;
        }
        if (pCD->m_bDiagnostic == FALSE) 
        {
            UINT n;

            n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_GETTEXTLENGTH, 0, 0);

            if (n > 0 )
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            else
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
        }
        break;

    case WM_COMMAND:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        if (pCD->m_bDiagnostic == FALSE) 
        {
            switch (LOWORD(wParam))
            {

            case IDC_BUTTON1:
                if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_RSOP_BROWSEDC), hDlg,
                                    BrowseDCDlgProc, (LPARAM) pCD))
                {
                    SetDlgItemText (hDlg, IDC_EDIT1, pCD->m_szDC);
                }
                break;

            case IDC_EDIT1:
                if (HIWORD(wParam) == EN_CHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }

                break;
            }
    	}

        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_WIZBACK:
            if (pCD->m_bDiagnostic)
            {
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETUSER);
                return TRUE;
            }
            if (pCD->m_dwSkippedFrom)
            {
                SetWindowLong(hDlg, DWLP_MSGRESULT, pCD->m_dwSkippedFrom);
                return TRUE;
            }
            if (!pCD->m_szComputerName && !pCD->m_szComputerSOM)
            {
                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WQLUSER);
                return TRUE;
            }
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

            if (pCD->m_bDiagnostic == FALSE) 
            {
                if (pCD->m_szDC && pCD->IsComputerRSoPEnabled(pCD->m_szDC))
                {
                    SetDlgItemText (hDlg, IDC_EDIT1, pCD->m_szDC);
                }
                else
                {
                    SetDlgItemText (hDlg, IDC_EDIT1, TEXT(""));
                }
            }

            pCD->FillResultsList (GetDlgItem (hDlg, IDC_LIST1));

            break;

        case PSN_WIZNEXT:

            if (pCD->m_bDiagnostic == FALSE) 
            {
                SetWaitCursor();
                GetControlText(hDlg, IDC_EDIT1, pCD->m_szDC);

                if (!pCD->IsComputerRSoPEnabled(pCD->m_szDC))
                {
                    ClearWaitCursor();
                    ReportError(hDlg, GetLastError(), IDS_DCMISSINGRSOP);
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }

                ClearWaitCursor();
            }


//            PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_DISABLEDFINISH);
            PropSheet_SetWizButtons (GetParent(hDlg), 0);
            EnableWindow (GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
            if (FAILED(pCD->InitializeRSOP(hDlg)))
            {
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK);
                EnableWindow (GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                return TRUE;
            }

            // skip to the VERY last page in the wizard
            SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED2);
            return TRUE;


        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPFinished2DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;


    switch (message)
    {
    case WM_INITDIALOG:

        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        SendMessage(GetDlgItem(hDlg, IDC_RSOP_BIG_BOLD1),
                    WM_SETFONT, (WPARAM)pCD->m_BigBoldFont, (LPARAM)TRUE);

/*
        if (!pCD->m_hChooseBitmap)
        {
            pCD->m_hChooseBitmap = (HBITMAP) LoadImage (g_hInstance,
                                                        MAKEINTRESOURCE(IDB_WIZARD),
                                                        IMAGE_BITMAP, 0, 0,
                                                        LR_DEFAULTCOLOR);
        }

        if (pCD->m_hChooseBitmap)
        {
            SendDlgItemMessage (hDlg, IDC_BITMAP, STM_SETIMAGE,
                                IMAGE_BITMAP, (LPARAM) pCD->m_hChooseBitmap);
        }
*/
        break;

    case WM_NOTIFY:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (!pCD)
        {
            break;
        }

        switch (((NMHDR FAR*)lParam)->code)
        {

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_FINISH);
            break;

        case PSN_WIZFINISH:

            // fall through

        case PSN_RESET:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

void CRSOPComponentData::InitializeResultsList (HWND hLV)
{
    LV_COLUMN lvcol;
    RECT rect;
    TCHAR szTitle[50];


    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

    //
    // Add the columns to the listview
    //

    GetClientRect(hLV, &rect);

    ZeroMemory(&lvcol, sizeof(lvcol));

    LoadString(g_hInstance, IDS_RSOP_DETAILS, szTitle, ARRAYSIZE(szTitle));
    lvcol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvcol.pszText = szTitle;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.cx = (int)(rect.right * .40);
    ListView_InsertColumn(hLV, 0, &lvcol);

    LoadString(g_hInstance, IDS_RSOP_SETTINGS, szTitle, ARRAYSIZE(szTitle));
    lvcol.cx = ((rect.right - lvcol.cx) - GetSystemMetrics(SM_CYHSCROLL));
    lvcol.pszText = szTitle;
    ListView_InsertColumn(hLV, 1, &lvcol);

}

void CRSOPComponentData::FillResultsList (HWND hLV)
{
    TCHAR szTitle[200];
    TCHAR szAccessDenied[75];
    LPTSTR lpEnd;
    LVITEM item;
    INT iIndex = 0;
    ULONG ulSize;

    ListView_DeleteAllItems (hLV);

    //
    // Mode
    //

    ZeroMemory (&item, sizeof(item));

    LoadString(g_hInstance, IDS_RSOP_FINISH_P0, szTitle, ARRAYSIZE(szTitle));

    item.mask = LVIF_TEXT;
    item.iItem = iIndex;
    item.pszText = szTitle;
    iIndex = ListView_InsertItem (hLV, &item);

    if (iIndex != -1)
    {
        if (m_bDiagnostic)
        {
            LoadString(g_hInstance, IDS_DIAGNOSTIC, szTitle, ARRAYSIZE(szTitle));
        }
        else
        {
            LoadString(g_hInstance, IDS_PLANNING, szTitle, ARRAYSIZE(szTitle));
        }

        item.mask = LVIF_TEXT;
        item.pszText = szTitle;
        item.iItem = iIndex;
        item.iSubItem = 1;
        ListView_SetItem(hLV, &item);
    }

    if (m_bDiagnostic)
    {
        //
        // User Name
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P1, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            item.mask = LVIF_TEXT;

            if (m_szUserDisplayName)
            {
                lstrcpyn (szTitle, m_szUserDisplayName, ARRAYSIZE(szTitle));
            }
            else
            {
                LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
            }

            if (m_bUserDeniedAccess)
            {
                LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT) lstrlen(szAccessDenied))
                {
                    lstrcat (szTitle, szAccessDenied);
                }
            }

            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


        //
        // Do not display user data
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P15, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            if (!m_bNoUserData)
            {
                LoadString(g_hInstance, IDS_YES, szTitle, ARRAYSIZE(szTitle));
            }
            else
            {
                LoadString(g_hInstance, IDS_NO, szTitle, ARRAYSIZE(szTitle));
            }

            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


        //
        // Computer Name
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P2, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            szTitle[0] = TEXT('\0');

            if (!lstrcmpi(m_szComputerName, TEXT(".")))
            {
                ulSize = ARRAYSIZE(szTitle);
                if (!GetComputerObjectName (NameSamCompatible, szTitle, &ulSize))
                {
                    GetComputerNameEx (ComputerNameNetBIOS, szTitle, &ulSize);
                }
            }
            else
            {
                lstrcpyn (szTitle, m_szComputerName, ARRAYSIZE(szTitle));
            }


            //
            // Remove the trailing $
            //

            lpEnd = szTitle + lstrlen(szTitle) - 1;

            if (*lpEnd == TEXT('$'))
            {
                *lpEnd =  TEXT('\0');
            }

            if (m_bComputerDeniedAccess)
            {
                LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                {
                    lstrcat (szTitle, szAccessDenied);
                }
            }


            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


        //
        // Do not display computer data
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P14, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            if (!m_bNoComputerData)
            {
                LoadString(g_hInstance, IDS_YES, szTitle, ARRAYSIZE(szTitle));
            }
            else
            {
                LoadString(g_hInstance, IDS_NO, szTitle, ARRAYSIZE(szTitle));
            }

            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }

    }
    else
    {
        //
        // User Name
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        if (!m_szUserName && m_szUserSOM)
        {
            LoadString(g_hInstance, IDS_RSOP_FINISH_P9, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                lstrcpyn (szTitle, m_szUserSOM, ARRAYSIZE(szTitle));

                if (m_bUserDeniedAccess)
                {
                    LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                    if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                    {
                        lstrcat (szTitle, szAccessDenied);
                    }
                }

                item.pszText = szTitle;
                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }
        else
        {
            LoadString(g_hInstance, IDS_RSOP_FINISH_P1, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                if (m_szUserName)
                {
                    lstrcpyn (szTitle, m_szUserName, ARRAYSIZE(szTitle));
                }
                else
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
                }

                if (m_bUserDeniedAccess)
                {
                    LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                    if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                    {
                        lstrcat (szTitle, szAccessDenied);
                    }
                }

                item.pszText = szTitle;
                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }


        //
        // Computer Name
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        if (!m_szComputerName && m_szComputerSOM)
        {
            LoadString(g_hInstance, IDS_RSOP_FINISH_P10, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                lstrcpyn (szTitle, m_szComputerSOM, ARRAYSIZE(szTitle));

                if (m_bComputerDeniedAccess)
                {
                    LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                    if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                    {
                        lstrcat (szTitle, szAccessDenied);
                    }
                }

                item.pszText = szTitle;
                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }
        else
        {
            LoadString(g_hInstance, IDS_RSOP_FINISH_P2, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                if (m_szComputerName)
                {
                    lstrcpyn (szTitle, m_szComputerName, ARRAYSIZE(szTitle));

                    lpEnd = szTitle + lstrlen(szTitle) - 1;

                    if (*lpEnd == TEXT('$'))
                    {
                        *lpEnd = TEXT('\0');
                    }
                }
                else
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
                }

                if (m_bComputerDeniedAccess)
                {
                    LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                    if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                    {
                        lstrcat (szTitle, szAccessDenied);
                    }
                }

                item.iItem = iIndex;
                item.iSubItem = 1;
                item.pszText = szTitle;
                ListView_SetItem(hLV, &item);
            }
        }


        //
        // Show all GPOs
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P13, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            if (m_bSlowLink)
            {
                LoadString(g_hInstance, IDS_YES, szTitle, ARRAYSIZE(szTitle));
            }
            else
            {
                LoadString(g_hInstance, IDS_NO, szTitle, ARRAYSIZE(szTitle));
            }

            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }

        //
        // Indicate the loopback mode
        //
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P16, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            switch (m_loopbackMode)
            {
            case LoopbackNone:
                LoadString(g_hInstance, IDS_NONE, szTitle, ARRAYSIZE(szTitle));
                break;
            case LoopbackReplace:
                LoadString(g_hInstance, IDS_LOOPBACK_REPLACE, szTitle, ARRAYSIZE(szTitle));
                break;
            case LoopbackMerge:
                LoadString(g_hInstance, IDS_LOOPBACK_MERGE, szTitle, ARRAYSIZE(szTitle));
                break;
            }

            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }

        //
        // Site Name
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P3, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            item.mask = LVIF_TEXT;

            if (m_szSite)
            {
                item.pszText = m_szSite;
            }
            else
            {
                LoadString(g_hInstance, IDS_NONE, szTitle, ARRAYSIZE(szTitle));
                item.pszText = szTitle;
            }

            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


/*
        //
        // DC Name
        //

        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P4, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            item.mask = LVIF_TEXT;
            item.pszText = m_szDC;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }
*/

        //
        // Alternate User Location
        //

        if (m_szUserName)
        {
            ZeroMemory (&item, sizeof(item));
            iIndex++;

            LoadString(g_hInstance, IDS_RSOP_FINISH_P5, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                if (m_szUserSOM)
                {
                    item.pszText = m_szUserSOM;
                }
                else
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
                    item.pszText = szTitle;
                }

                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }


        //
        // Alternate Computer Location
        //

        if (m_szComputerName)
        {

            ZeroMemory (&item, sizeof(item));
            iIndex++;

            LoadString(g_hInstance, IDS_RSOP_FINISH_P6, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                if (m_szComputerSOM)
                {
                    item.pszText = m_szComputerSOM;
                }
                else
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
                    item.pszText = szTitle;
                }

                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }


        //
        // Alternate User security groups
        //

        if (m_szUserName || m_szUserSOM || LoopbackNone != m_loopbackMode)
        {

            if (m_saUserSecurityGroups)
            {
                LONG lIndex = 0, lMax;
                LPTSTR lpText;

                if (SUCCEEDED(SafeArrayGetUBound (m_saUserSecurityGroups, 1, &lMax)))
                {

                    do {
                        if (SUCCEEDED(SafeArrayGetElement(m_saUserSecurityGroups, &lIndex, &lpText)))
                        {
                            ZeroMemory (&item, sizeof(item));
                            iIndex++;

                            item.mask = LVIF_TEXT;
                            item.iItem = iIndex;

                            if (lIndex == 0)
                            {
                                LoadString(g_hInstance, IDS_RSOP_FINISH_P7, szTitle, ARRAYSIZE(szTitle));
                                item.pszText = szTitle;
                            }
                            else
                            {
                                item.pszText = TEXT("");
                            }

                            iIndex = ListView_InsertItem (hLV, &item);

                            if (iIndex != -1)
                            {
                                LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                                item.mask = LVIF_TEXT;
                                item.pszText = lpText;
                                item.iItem = iIndex;
                                item.iSubItem = 1;
                                ListView_SetItem(hLV, &item);
                            }
                        }

                        lIndex++;

                    } while (lIndex <= (lMax + 1));
                }
            }
            else
            {
                ZeroMemory (&item, sizeof(item));
                iIndex++;

                LoadString(g_hInstance, IDS_RSOP_FINISH_P7, szTitle, ARRAYSIZE(szTitle));

                item.mask = LVIF_TEXT;
                item.iItem = iIndex;
                item.pszText = szTitle;
                iIndex = ListView_InsertItem (hLV, &item);

                if (iIndex != -1)
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                    item.mask = LVIF_TEXT;
                    item.pszText = szTitle;
                    item.iItem = iIndex;
                    item.iSubItem = 1;
                    ListView_SetItem(hLV, &item);
                }
            }
        }


        //
        // Alternate Computer security groups
        //

        if (m_szComputerName || m_szComputerSOM)
        {

            if (m_saComputerSecurityGroups)
            {
                LONG lIndex = 0, lMax;
                LPTSTR lpText;

                if (SUCCEEDED(SafeArrayGetUBound (m_saComputerSecurityGroups, 1, &lMax)))
                {

                    do {
                        if (SUCCEEDED(SafeArrayGetElement(m_saComputerSecurityGroups, &lIndex, &lpText)))
                        {
                            ZeroMemory (&item, sizeof(item));
                            iIndex++;

                            item.mask = LVIF_TEXT;
                            item.iItem = iIndex;

                            if (lIndex == 0)
                            {
                                LoadString(g_hInstance, IDS_RSOP_FINISH_P8, szTitle, ARRAYSIZE(szTitle));
                                item.pszText = szTitle;
                            }
                            else
                            {
                                item.pszText = TEXT("");
                            }

                            iIndex = ListView_InsertItem (hLV, &item);

                            if (iIndex != -1)
                            {
                                LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                                item.mask = LVIF_TEXT;

                                BOOL bDollarRemoved = FALSE;

                                if (lpText[wcslen(lpText)-1] == L'$')
                                {
                                    bDollarRemoved = TRUE;
                                    lpText[wcslen(lpText)-1] = 0;
                                }

                                item.pszText = lpText;
                                item.iItem = iIndex;
                                item.iSubItem = 1;
                                ListView_SetItem(hLV, &item);

                                if (bDollarRemoved) {
                                    lpText[wcslen(lpText)] = L'$';
                                }
                            }
                        }

                        lIndex++;

                    } while (lIndex <= (lMax + 1));
                }
            }
            else
            {
                ZeroMemory (&item, sizeof(item));
                iIndex++;

                LoadString(g_hInstance, IDS_RSOP_FINISH_P8, szTitle, ARRAYSIZE(szTitle));

                item.mask = LVIF_TEXT;
                item.iItem = iIndex;
                item.pszText = szTitle;
                iIndex = ListView_InsertItem (hLV, &item);

                if (iIndex != -1)
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                    item.mask = LVIF_TEXT;
                    item.pszText = szTitle;
                    item.iItem = iIndex;
                    item.iSubItem = 1;
                    ListView_SetItem(hLV, &item);
                }
            }
        }


        //
        // User WQL filters
        //

        if (m_szUserName || m_szUserSOM || LoopbackNone != m_loopbackMode)
        {
            LONG lFilterCount = 0;
            if (m_saUserWQLFilterNames)
            {
                LONG lIndex = 0, lMax = 0;
                LPTSTR lpText;

                if (SUCCEEDED(SafeArrayGetUBound (m_saUserWQLFilterNames, 1, &lMax)))
                {

                    do {
                        if (SUCCEEDED(SafeArrayGetElement(m_saUserWQLFilterNames, &lIndex, &lpText)))
                        {
                            lFilterCount++;
                            ZeroMemory (&item, sizeof(item));
                            iIndex++;

                            item.mask = LVIF_TEXT;
                            item.iItem = iIndex;

                            if (lIndex == 0)
                            {
                                LoadString(g_hInstance, IDS_RSOP_FINISH_P11, szTitle, ARRAYSIZE(szTitle));
                                item.pszText = szTitle;
                            }
                            else
                            {
                                item.pszText = TEXT("");
                            }

                            iIndex = ListView_InsertItem (hLV, &item);

                            if (iIndex != -1)
                            {
                                LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                                item.mask = LVIF_TEXT;
                                item.pszText = lpText;
                                item.iItem = iIndex;
                                item.iSubItem = 1;
                                ListView_SetItem(hLV, &item);
                            }
                        }

                        lIndex++;

                    } while (lIndex <= (lMax + 1));
                }
            }

            if ((!m_saUserWQLFilterNames) || (lFilterCount == 0))  {
                
                ZeroMemory (&item, sizeof(item));
                iIndex++;

                LoadString(g_hInstance, IDS_RSOP_FINISH_P11, szTitle, ARRAYSIZE(szTitle));

                item.mask = LVIF_TEXT;
                item.iItem = iIndex;
                item.pszText = szTitle;
                iIndex = ListView_InsertItem (hLV, &item);

                if (iIndex != -1)
                {
                    if (m_bSkipUserWQLFilter) {
                        LoadString(g_hInstance, IDS_SKIPWQLFILTER, szTitle, ARRAYSIZE(szTitle));
                    }
                    else {
                        LoadString(g_hInstance, IDS_NONESELECTED, szTitle, ARRAYSIZE(szTitle));
                    }

                    item.mask = LVIF_TEXT;
                    item.pszText = szTitle;
                    item.iItem = iIndex;
                    item.iSubItem = 1;
                    ListView_SetItem(hLV, &item);
                }
            }
        }


        //
        // Computer WQL filters
        //

        if (m_szComputerName || m_szComputerSOM)
        {
            LONG lFilterCount = 0;
            if (m_saComputerWQLFilterNames)
            {
                LONG lIndex = 0, lMax = 0;
                LPTSTR lpText;

                if (SUCCEEDED(SafeArrayGetUBound (m_saComputerWQLFilterNames, 1, &lMax)))
                {

                    do {
                        if (SUCCEEDED(SafeArrayGetElement(m_saComputerWQLFilterNames, &lIndex, &lpText)))
                        {
                            lFilterCount++;
                            ZeroMemory (&item, sizeof(item));
                            iIndex++;

                            item.mask = LVIF_TEXT;
                            item.iItem = iIndex;

                            if (lIndex == 0)
                            {
                                LoadString(g_hInstance, IDS_RSOP_FINISH_P12, szTitle, ARRAYSIZE(szTitle));
                                item.pszText = szTitle;
                            }
                            else
                            {
                                item.pszText = TEXT("");
                            }

                            iIndex = ListView_InsertItem (hLV, &item);

                            if (iIndex != -1)
                            {
                                LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                                item.mask = LVIF_TEXT;
                                item.pszText = lpText;
                                item.iItem = iIndex;
                                item.iSubItem = 1;
                                ListView_SetItem(hLV, &item);
                            }
                        }

                        lIndex++;

                    } while (lIndex <= (lMax + 1));
                }
            }
            

            if ((!m_saComputerWQLFilterNames) || (lFilterCount == 0))  {
                ZeroMemory (&item, sizeof(item));
                iIndex++;

                LoadString(g_hInstance, IDS_RSOP_FINISH_P12, szTitle, ARRAYSIZE(szTitle));

                item.mask = LVIF_TEXT;
                item.iItem = iIndex;
                item.pszText = szTitle;
                iIndex = ListView_InsertItem (hLV, &item);

                if (iIndex != -1)
                {
                    if (m_bSkipComputerWQLFilter) {
                        LoadString(g_hInstance, IDS_SKIPWQLFILTER, szTitle, ARRAYSIZE(szTitle));
                    }
                    else {
                        LoadString(g_hInstance, IDS_NONESELECTED, szTitle, ARRAYSIZE(szTitle));
                    }

                    item.mask = LVIF_TEXT;
                    item.pszText = szTitle;
                    item.iItem = iIndex;
                    item.iSubItem = 1;
                    ListView_SetItem(hLV, &item);
                }
            }
        }
    }
}

//
// CopyUnescapedSOM
//
// Purpose: to remove all escape sequence literals
// of the form \" from a SOM stored in WMI -- WMI
// cannot store the " character in a key field, so the 
// only way to store the " is to escape it -- this is done
// so by preceding it with the \ char.  To give back
// a friendly display to the user, we undo the escape process
//
void
CopyUnescapedSOM(
    LPTSTR lpUnescapedSOM,
    LPTSTR lpSOM )
{
    while ( *lpSOM )
    {
        //
        // If we have the escape character
        //
        if ( TEXT('\\') == *lpSOM )
        {
            //
            // Check for the " character
            //
            if ( TEXT('"') == *(lpSOM + 1) ) 
            {
                //
                // Skip the escape character if this is the " char
                //
                lpSOM++;
                
                continue;
            }
        }

        *lpUnescapedSOM++ = *lpSOM++;
    } 

    *lpUnescapedSOM = TEXT('\0');
}

BOOL CRSOPComponentData::AddGPOListNode(LPTSTR lpGPOName, LPTSTR lpDSPath, LPTSTR lpSOM,
                                        LPTSTR lpFiltering, DWORD dwVersion, BOOL bApplied,
                                        LPBYTE pSD, DWORD dwSDSize, LPGPOLISTITEM *lpList)
{
    DWORD dwSize;
    LPGPOLISTITEM lpItem, lpTemp;


    //
    // Calculate the size of the new item
    //

    dwSize = sizeof (GPOLISTITEM);

    dwSize += ((lstrlen(lpGPOName) + 1) * sizeof(TCHAR));

    if (lpDSPath)
    {
        dwSize += ((lstrlen(lpDSPath) + 1) * sizeof(TCHAR));
    }

    dwSize += ((lstrlen(lpSOM) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpSOM) + 1) * sizeof(TCHAR)); // The unescaped SOM length -- it is always smaller than the actual SOM
    dwSize += ((lstrlen(lpFiltering) + 1) * sizeof(TCHAR));
    dwSize += dwSDSize + MAX_ALIGNMENT_SIZE;


    //
    // Allocate space for it
    //

    lpItem = (LPGPOLISTITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::AddGPOListNode: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    lpItem->lpGPOName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(GPOLISTITEM));
    lstrcpy (lpItem->lpGPOName, lpGPOName);

    if (lpDSPath)
    {
        lpItem->lpDSPath = lpItem->lpGPOName + lstrlen (lpItem->lpGPOName) + 1;
        lstrcpy (lpItem->lpDSPath, lpDSPath);

        lpItem->lpSOM = lpItem->lpDSPath + lstrlen (lpItem->lpDSPath) + 1;
        lstrcpy (lpItem->lpSOM, lpSOM);
    }
    else
    {
        lpItem->lpSOM = lpItem->lpGPOName + lstrlen (lpItem->lpGPOName) + 1;
        lstrcpy (lpItem->lpSOM, lpSOM);
    }

    //
    // Note that the DS SOM's may contain characters such as '"' that 
    // must be escaped with a "\" in WMI -- thus the SOM name will contain
    // '\' escape chars that are not actually present in the real SOM name,
    // so we call a function that removes them
    //
    lpItem->lpUnescapedSOM = lpItem->lpSOM + lstrlen (lpItem->lpSOM) + 1;        
    CopyUnescapedSOM( lpItem->lpUnescapedSOM, lpItem->lpSOM );

    lpItem->lpFiltering = lpItem->lpUnescapedSOM + lstrlen (lpItem->lpUnescapedSOM) + 1;
    lstrcpy (lpItem->lpFiltering, lpFiltering);

    if (pSD)
    {
        // sd has to be pointer aligned. This is currently aligning it to
        // 8 byte boundary

        DWORD dwOffset;

        dwOffset = (DWORD) ((LPBYTE)(lpItem->lpFiltering + lstrlen (lpItem->lpFiltering) + 1) - (LPBYTE)lpItem);
        lpItem->pSD = (LPBYTE)lpItem + ALIGN_SIZE_TO_NEXTPTR(dwOffset);

        CopyMemory (lpItem->pSD, pSD, dwSDSize);
    }

    lpItem->dwVersion = dwVersion;
    lpItem->bApplied = bApplied;


    //
    // Add item to the link list
    //

    if (*lpList)
    {
        lpTemp = *lpList;

        while (lpTemp)
        {
            if (!lpTemp->pNext)
            {
                lpTemp->pNext = lpItem;
                break;
            }
            lpTemp = lpTemp->pNext;
        }
    }
    else
    {
        *lpList = lpItem;
    }


    return TRUE;
}

VOID CRSOPComponentData::FreeGPOListData(LPGPOLISTITEM lpList)
{
    LPGPOLISTITEM lpTemp;


    do {
        lpTemp = lpList->pNext;
        LocalFree (lpList);
        lpList = lpTemp;

    } while (lpTemp);
}

void CRSOPComponentData::BuildGPOList (LPGPOLISTITEM * lpList, LPTSTR lpNamespace)
{
    HRESULT hr;
    ULONG n, ulIndex = 0, ulOrder, ulAppliedOrder;
    IWbemClassObject * pObjGPLink = NULL;
    IWbemClassObject * pObjGPO = NULL;
    IWbemClassObject * pObjSOM = NULL;
    IEnumWbemClassObject * pAppliedEnum = NULL;
    IEnumWbemClassObject * pNotAppliedEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strAppliedQuery = SysAllocString(TEXT("SELECT * FROM RSOP_GPLink where AppliedOrder > 0"));
    BSTR strNotAppliedQuery = SysAllocString(TEXT("SELECT * FROM RSOP_GPLink where AppliedOrder = 0"));
    BSTR strNamespace = SysAllocString(lpNamespace);
    BSTR strTemp = NULL;
    WCHAR * szGPOName = NULL;
    WCHAR * szSOM = NULL;
    WCHAR * szGPOPath = NULL;
    WCHAR szFiltering[80] = {0};
    BSTR bstrTemp = NULL;
    ULONG ul = 0, ulVersion = 0;
    BOOL bLinkEnabled, bGPOEnabled, bAccessDenied, bFilterAllowed, bSOMBlocked;
    BOOL bProcessAppliedList = TRUE;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    LV_COLUMN lvcol;
    BOOL      bValidGPOData;
    LPBYTE pSD = NULL;
    DWORD dwDataSize = 0;


    //
    // Get a locator instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: CoCreateInstance failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Connect to the namespace
    //

    hr = pLocator->ConnectServer(lpNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: ConnectServer failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Query for the RSOP_GPLink (applied) instances 
    //

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strAppliedQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY,
                               NULL,
                               &pAppliedEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Query for the RSOP_GPLink (notapplied) instances 
    //

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strNotAppliedQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY,
                               NULL,
                               &pNotAppliedEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: ExecQuery (notapplied) failed with 0x%x"), hr));
        goto cleanup;
    }


    bProcessAppliedList = FALSE;

    //
    // Loop through the results
    //

    while (TRUE)
    {

        if (!bProcessAppliedList) {
            
            //
            // No need to sort the not applied list
            //

            hr = pNotAppliedEnum->Next(WBEM_INFINITE, 1, &pObjGPLink, &n);
            if (FAILED(hr) || (n == 0))
            {
                DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::BuildGPOList: Getting applied links")));
                bProcessAppliedList = TRUE;
            }
            else {
                hr = GetParameter(pObjGPLink, TEXT("AppliedOrder"), ulOrder);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get link order with 0x%x"), hr));
                    goto cleanup;
                }
            }
        }

        
        //
        // Reset the enumerator so we can look through the results to find the
        // correct index
        //

        if (bProcessAppliedList) {
            pAppliedEnum->Reset();


            //
            // Find the correct index in the result set
            //
            
            ulIndex++;
            ulOrder = 0;
            do {
                hr = pAppliedEnum->Next(WBEM_INFINITE, 1, &pObjGPLink, &n);
                if (FAILED(hr) || (n == 0))
                {
                    goto cleanup;
                }


                hr = GetParameter(pObjGPLink, TEXT("AppliedOrder"), ulOrder);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get link order with 0x%x"), hr));
                    goto cleanup;
                }

                if (ulOrder != ulIndex)
                {
                    pObjGPLink->Release();
                    pObjGPLink = NULL;
                }

            } while (ulOrder != ulIndex);


            if (FAILED(hr)) {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Next failed with error 0x%x"), hr));
                goto cleanup;
            }
        }



        //
        // Get the applied order of this link
        //

        hr = GetParameter(pObjGPLink, TEXT("AppliedOrder"), ulAppliedOrder);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get applied order with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the enabled state of the link
        //

        hr = GetParameter(pObjGPLink, TEXT("enabled"), bLinkEnabled);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get enabled with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the GPO path
        //

        hr = GetParameterBSTR(pObjGPLink, TEXT("GPO"), bstrTemp);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get GPO with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Set the default GPO name to be the gpo path.  Don't worry about
        // freeing this string because the GetParameter call will free the buffer
        // when the real name is successfully queried. Sometimes the rsop_gpo instance
        // won't exist if this gpo is new.
        //

        szGPOName = new TCHAR[_tcslen(bstrTemp) + 1];

        if (!szGPOName)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to allocate memory for temp gpo name.")));
            goto cleanup;
        }

        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                           TEXT("RSOP_GPO.id="), 12, bstrTemp, 12) == CSTR_EQUAL)
        {
            // removing the first and last quote
            lstrcpy (szGPOName, bstrTemp+13);
            szGPOName[lstrlen(szGPOName)-1] = TEXT('\0');
        }
        else
        {
            lstrcpy (szGPOName, bstrTemp);
        }


        //
        // Add ldap to the path if appropriate
        //

        if (lstrcmpi(szGPOName, TEXT("LocalGPO")))
        {
            szGPOPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szGPOName) + 10) * sizeof(WCHAR));

            if (!szGPOPath)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to allocate memory for full path with %d"),
                         GetLastError()));
                goto cleanup;
            }

            lstrcpy (szGPOPath, TEXT("LDAP://"));
            lstrcat (szGPOPath, szGPOName);
        }
        else
        {
            szGPOPath = NULL;
        }



        bValidGPOData = FALSE;

        //
        // Bind to the GPO
        //

        hr = pNamespace->GetObject(
                          bstrTemp,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pObjGPO,
                          NULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: GetObject for GPO %s failed with 0x%x"),
                      bstrTemp, hr));
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
            goto GetSOMData;
        }
        SysFreeString (bstrTemp);
        bstrTemp = NULL;



        //
        // Get the GPO name
        //

        hr = GetParameter(pObjGPO, TEXT("name"), szGPOName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get name with 0x%x"), hr));
            goto GetSOMData;

        }


        //
        // Get the version number
        //

        hr = GetParameter(pObjGPO, TEXT("version"), ulVersion);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get version with 0x%x"), hr));
            goto GetSOMData;

        }


        //
        // Get the enabled state of the GPO
        //

        hr = GetParameter(pObjGPO, TEXT("enabled"), bGPOEnabled);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get gpo enabled state with 0x%x"), hr));
            goto GetSOMData;
        }


        //
        // Get the WMI filter state of the GPO
        //

        hr = GetParameter(pObjGPO, TEXT("filterAllowed"), bFilterAllowed);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get gpo enabled state with 0x%x"), hr));
            goto GetSOMData;
        }



        //
        // Check for access denied
        //

        hr = GetParameter(pObjGPO, TEXT("accessDenied"), bAccessDenied);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get accessdenied with 0x%x"), hr));
            goto GetSOMData;
        }


        //
        // Get the security descriptor
        //

        if (szGPOPath)
        {
            hr = GetParameterBytes(pObjGPO, TEXT("securityDescriptor"), &pSD, &dwDataSize);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get security descriptor with 0x%x"), hr));
                goto GetSOMData;
            }
        }

        
        bValidGPOData = TRUE;

GetSOMData:

        //
        // Get the SOM for this link (the S,D,OU that this GPO is linked to)
        //

        hr = GetParameterBSTR(pObjGPLink, TEXT("SOM"), bstrTemp);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get SOM with 0x%x"), hr));
            goto AddNode;
        }


        //
        // Bind to the SOM instance
        //

        hr = pNamespace->GetObject(
                          bstrTemp,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pObjSOM,
                          NULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: GetObject for SOM of %s failed with 0x%x"),
                     bstrTemp, hr));
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
            goto AddNode;
        }

        SysFreeString (bstrTemp);
        bstrTemp = NULL;


        //
        // Get SOM name
        //

        hr = GetParameter(pObjSOM, TEXT("id"), szSOM);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get som id with 0x%x"), hr));
            goto AddNode;
        }

        //
        // Get blocked from above
        //

        hr = GetParameter(pObjSOM, TEXT("blocked"), bSOMBlocked);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get som id with 0x%x"), hr));
            goto AddNode;
        }



AddNode:

        //
        // Decide on the filtering name
        //

        if (ulAppliedOrder > 0)
        {
            LoadString(g_hInstance, IDS_APPLIED, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if (!bLinkEnabled)
        {
            LoadString(g_hInstance, IDS_DISABLEDLINK, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if (bSOMBlocked) {
            LoadString(g_hInstance, IDS_BLOCKEDSOM, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if ((bValidGPOData) && (!bGPOEnabled))
        {
            LoadString(g_hInstance, IDS_DISABLEDGPO, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if ((bValidGPOData) && (bAccessDenied))
        {
            LoadString(g_hInstance, IDS_SECURITYDENIED, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if ((bValidGPOData) && (!bFilterAllowed))
        {
            LoadString(g_hInstance, IDS_WMIFILTERFAILED, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if ((bValidGPOData) && (ulVersion == 0))
        {
            LoadString(g_hInstance, IDS_NODATA, szFiltering, ARRAYSIZE(szFiltering));
        }
        else
        {
            LoadString(g_hInstance, IDS_UNKNOWNREASON, szFiltering, ARRAYSIZE(szFiltering));
        }


        if (!szSOM)
        {
            szSOM = new TCHAR[2];

            if (!szSOM)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to allocate memory for temp som name.")));
                goto cleanup;
            }

            szSOM[0] = TEXT(' ');
        }

        //
        // Add this node to the list
        //

        if (!AddGPOListNode(szGPOName, szGPOPath, szSOM, szFiltering, ulVersion,
                            ((ulAppliedOrder > 0) ? TRUE : FALSE), pSD, dwDataSize, lpList))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: AddGPOListNode failed.")));
        }



        //
        // Prepare for next iteration
        //

        if (pObjSOM)
        {
            pObjSOM->Release();
            pObjSOM = NULL;
        }
        if (pObjGPO)
        {
            pObjGPO->Release();
            pObjGPO = NULL;
        }
        if (pObjGPLink)
        {
            pObjGPLink->Release();
            pObjGPLink = NULL;
        }

        if (szGPOName)
        {
            delete [] szGPOName;
            szGPOName = NULL;
        }

        if (szSOM)
        {
            delete [] szSOM;
            szSOM = NULL;
        }

        if (szGPOPath)
        {
            LocalFree (szGPOPath);
            szGPOPath = NULL;
        }

        if (pSD)
        {
            LocalFree (pSD);
            pSD = NULL;
            dwDataSize = 0;
        }

        ulVersion = 0;
    }

cleanup:
    if (szGPOPath)
    {
        LocalFree (szGPOPath);
    }
    if (pSD)
    {
        LocalFree (pSD);
    }
    if (szGPOName)
    {
        delete [] szGPOName;
    }
    if (szSOM)
    {
        delete [] szSOM;
    }
    if (pObjSOM)
    {
        pObjSOM->Release();
    }
    if (pObjGPO)
    {
        pObjGPO->Release();
    }
    if (pObjGPLink)
    {
        pObjGPLink->Release();
    }
    if (pAppliedEnum)
    {
        pAppliedEnum->Release();
    }
    if (pNotAppliedEnum)
    {
        pNotAppliedEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    SysFreeString(strQueryLanguage);
    SysFreeString(strAppliedQuery);
    SysFreeString(strNotAppliedQuery);
    SysFreeString(strNamespace);
}

void CRSOPComponentData::BuildGPOLists (void)
{
    LPTSTR lpNamespace, lpEnd;

    lpNamespace = (LPTSTR) LocalAlloc (LPTR, (lstrlen(m_szNamespace) + 20) * sizeof(TCHAR));

    if (lpNamespace)
    {
        lstrcpy (lpNamespace, m_szNamespace);
        lpEnd = CheckSlash(lpNamespace);

        lstrcpy (lpEnd, TEXT("User"));

        if (m_pUserGPOList)
        {
            FreeGPOListData(m_pUserGPOList);
            m_pUserGPOList = NULL;
        }

        BuildGPOList (&m_pUserGPOList, lpNamespace);


        lstrcpy (lpEnd, TEXT("Computer"));

        if (m_pComputerGPOList)
        {
            FreeGPOListData(m_pComputerGPOList);
            m_pComputerGPOList = NULL;
        }

        BuildGPOList (&m_pComputerGPOList, lpNamespace);

        LocalFree (lpNamespace);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOLists: Failed to allocate memory for namespace with %d"),
                 GetLastError()));
    }
}

void CRSOPComponentData::PrepGPOList(HWND hList, BOOL bSOM, BOOL bFiltering,
                                     BOOL bVersion, DWORD dwCount)
{
    RECT rect;
    WCHAR szHeading[256];
    LV_COLUMN lvcol;
    LONG lWidth;
    INT cxName = 0, cxSOM = 0, cxFiltering = 0, cxVersion = 0, iTotal = 0;
    INT iColIndex = 0;


    //
    // Delete any previous columns
    //

    SendMessage (hList, LVM_DELETECOLUMN, 3, 0);
    SendMessage (hList, LVM_DELETECOLUMN, 2, 0);
    SendMessage (hList, LVM_DELETECOLUMN, 1, 0);
    SendMessage (hList, LVM_DELETECOLUMN, 0, 0);


    //
    // Decide on the column widths
    //

    GetClientRect(hList, &rect);

    if (dwCount > (DWORD)ListView_GetCountPerPage(hList))
    {
        lWidth = (rect.right - rect.left) - GetSystemMetrics(SM_CYHSCROLL);
    }
    else
    {
        lWidth = rect.right - rect.left;
    }


    if (bFiltering)
    {
        cxFiltering = (lWidth * 30) / 100;
        iTotal += cxFiltering;
    }

    if (bVersion)
    {
        cxVersion = (lWidth * 30) / 100;
        iTotal += cxVersion;
    }

    if (bSOM)
    {
        cxSOM = (lWidth - iTotal) / 2;
        iTotal += cxSOM;
        cxName = lWidth - iTotal;
    }
    else
    {
        cxName = lWidth - iTotal;
    }


    //
    // Insert the GPO Name column and then any appropriate columns
    //

    memset(&lvcol, 0, sizeof(lvcol));

    lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.pszText = szHeading;
    lvcol.cx = cxName;
    LoadString(g_hInstance, IDS_GPO_NAME, szHeading, ARRAYSIZE(szHeading));
    ListView_InsertColumn(hList, iColIndex, &lvcol);
    iColIndex++;


    if (bFiltering)
    {
        lvcol.cx = cxFiltering;
        LoadString(g_hInstance, IDS_FILTERING, szHeading, ARRAYSIZE(szHeading));
        ListView_InsertColumn(hList, iColIndex, &lvcol);
        iColIndex++;
    }

    if (bSOM)
    {
        lvcol.cx = cxSOM;
        LoadString(g_hInstance, IDS_SOM, szHeading, ARRAYSIZE(szHeading));
        ListView_InsertColumn(hList, iColIndex, &lvcol);
        iColIndex++;
    }

    if (bVersion)
    {
        lvcol.cx = cxVersion;
        LoadString(g_hInstance, IDS_VERSION, szHeading, ARRAYSIZE(szHeading));
        ListView_InsertColumn(hList, iColIndex, &lvcol);
    }


    //
    // Turn on some listview features
    //

    SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

}

void CRSOPComponentData::FillGPOList(HWND hDlg, DWORD dwListID, LPGPOLISTITEM lpList,
                                     BOOL bSOM, BOOL bFiltering, BOOL bVersion, BOOL bInitial)
{
    LV_COLUMN lvcol;
    HWND hList;
    LV_ITEM item;
    int iItem;
    TCHAR szVersion[80];
    TCHAR szVersionFormat[50];
    INT iColIndex, iDefault = 0;
    LPGPOLISTITEM lpItem, lpDefault = NULL;
    DWORD dwCount = 0;
    LVFINDINFO FindInfo;


    LoadString(g_hInstance, IDS_VERSIONFORMAT, szVersionFormat, ARRAYSIZE(szVersionFormat));

    hList = GetDlgItem(hDlg, dwListID);
    ListView_DeleteAllItems(hList);

    lpItem = lpList;

    while (lpItem)
    {
        if (bInitial)
        {
            if (LOWORD(lpItem->dwVersion) != HIWORD(lpItem->dwVersion))
            {
                bVersion = TRUE;
                CheckDlgButton (hDlg, IDC_CHECK3, BST_CHECKED);
            }
        }
        lpItem = lpItem->pNext;
        dwCount++;
    }


    PrepGPOList(hList, bSOM, bFiltering, bVersion, dwCount);

    lpItem = lpList;

    while (lpItem)
    {
        if (lpItem->bApplied || bFiltering)
        {
            wsprintf (szVersion, szVersionFormat, LOWORD(lpItem->dwVersion), HIWORD(lpItem->dwVersion));

            iColIndex = 0;
            memset(&item, 0, sizeof(item));
            item.mask = LVIF_TEXT | LVIF_PARAM;
            item.pszText = lpItem->lpGPOName;
            item.iItem = 0;
            item.lParam = (LPARAM) lpItem;
            iItem = ListView_InsertItem(hList, &item);
            iColIndex++;

            if (bInitial)
            {
                if (LOWORD(lpItem->dwVersion) != HIWORD(lpItem->dwVersion))
                {
                    lpDefault = lpItem;
                }
            }

            if (bFiltering)
            {
                item.mask = LVIF_TEXT;
                item.pszText = lpItem->lpFiltering;
                item.iItem = iItem;
                item.iSubItem = iColIndex;
                ListView_SetItem(hList, &item);
                iColIndex++;
            }

            if (bSOM)
            {
                item.mask = LVIF_TEXT;
                item.pszText = lpItem->lpUnescapedSOM;
                item.iItem = iItem;
                item.iSubItem = iColIndex;
                ListView_SetItem(hList, &item);
                iColIndex++;
            }

            if (bVersion)
            {
                item.mask = LVIF_TEXT;
                item.pszText = szVersion;
                item.iItem = iItem;
                item.iSubItem = iColIndex;
                ListView_SetItem(hList, &item);
            }
        }

        lpItem = lpItem->pNext;
    }


    if (lpDefault)
    {
        ZeroMemory (&FindInfo, sizeof(FindInfo));
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM) lpDefault;

        iDefault = ListView_FindItem(hList, -1, &FindInfo);

        if (iDefault == -1)
        {
            iDefault = 0;
        }
    }


    //
    // Select a item
    //

    item.mask = LVIF_STATE;
    item.iItem = iDefault;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hList, LVM_SETITEMSTATE, (WPARAM)iDefault, (LPARAM) &item);
    SendMessage (hList, LVM_ENSUREVISIBLE, iDefault, FALSE);

}

void CRSOPComponentData::OnSecurity(HWND hDlg)
{
    HWND hLV;
    INT i;
    HRESULT hr;
    LVITEM item;
    LPGPOLISTITEM lpItem;
    TCHAR szGPOName[MAX_FRIENDLYNAME];
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE hPages[2];

    //
    // Get the selected item (if any)
    //

    hLV = GetDlgItem (hDlg, IDC_LIST1);
    i = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);

    if (i < 0)
    {
        return;
    }


    ZeroMemory (&item, sizeof(item));
    item.mask = LVIF_TEXT | LVIF_PARAM;
    item.iItem = i;
    item.pszText = szGPOName;
    item.cchTextMax = ARRAYSIZE(szGPOName);

    if (!ListView_GetItem (hLV, &item))
    {
        return;
    }

    lpItem = (LPGPOLISTITEM) item.lParam;


    //
    // Create the security page
    //

    hr = DSCreateSecurityPage (lpItem->lpDSPath, L"groupPolicyContainer",
                                    DSSI_IS_ROOT | DSSI_READ_ONLY,
                                    &hPages[0], ReadSecurityDescriptor,
                                    WriteSecurityDescriptor, (LPARAM)lpItem);

    if (FAILED(hr))
    {
        return;
    }


    //
    // Display the property sheet
    //

    ZeroMemory (&psh, sizeof(psh));
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE;
    psh.hwndParent = hDlg;
    psh.hInstance = g_hInstance;
    psh.pszCaption = szGPOName;
    psh.nPages = 1;
    psh.phpage = hPages;

    PropertySheet (&psh);
}

HRESULT WINAPI CRSOPComponentData::ReadSecurityDescriptor (LPCWSTR lpGPOPath,
                                                           SECURITY_INFORMATION si,
                                                           PSECURITY_DESCRIPTOR *pSD,
                                                           LPARAM lpContext)
{
    LPGPOLISTITEM lpItem;
    HRESULT hr;


    lpItem = (LPGPOLISTITEM) lpContext;

    if (!lpItem)
    {
        return E_FAIL;
    }

    if (si & DACL_SECURITY_INFORMATION)
    {
        *pSD = lpItem->pSD;
    }
    else
    {
        *pSD = NULL;
    }

    return S_OK;
}

HRESULT WINAPI CRSOPComponentData::WriteSecurityDescriptor (LPCWSTR lpGPOPath,
                                                            SECURITY_INFORMATION si,
                                                            PSECURITY_DESCRIPTOR pSD,
                                                            LPARAM lpContext)
{
    return S_OK;
}

void CRSOPComponentData::OnEdit(HWND hDlg)
{
    HWND hLV;
    LVITEM item;
    LPGPOLISTITEM lpItem;
    INT i;
    SHELLEXECUTEINFO ExecInfo;
    TCHAR szArgs[MAX_PATH + 30];

    //
    // Get the selected item (if any)
    //

    hLV = GetDlgItem (hDlg, IDC_LIST1);
    i = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);

    if (i < 0)
    {
        return;
    }


    ZeroMemory (&item, sizeof(item));
    item.mask = LVIF_PARAM;
    item.iItem = i;

    if (!ListView_GetItem (hLV, &item))
    {
        return;
    }

    lpItem = (LPGPOLISTITEM) item.lParam;


    if (lpItem->lpDSPath)
    {
        if (!SpawnGPE(lpItem->lpDSPath, GPHintUnknown, NULL, hDlg))
        {
            ReportError (hDlg, GetLastError(), IDS_SPAWNGPEFAILED);
        }
    }
    else
    {
        ZeroMemory (&ExecInfo, sizeof(ExecInfo));
        ExecInfo.cbSize = sizeof(ExecInfo);
        ExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
        ExecInfo.lpVerb = TEXT("open");
        ExecInfo.lpFile = TEXT("gpedit.msc");
        ExecInfo.nShow = SW_SHOWNORMAL;

        if (lstrcmpi(m_szComputerName, TEXT(".")))
        {
            wsprintf (szArgs, TEXT("/gpcomputer:\"%s\" /gphint:1"), m_szComputerName);
            ExecInfo.lpParameters = szArgs;
        }

        if (ShellExecuteEx (&ExecInfo))
        {
            SetWaitCursor();
            WaitForInputIdle (ExecInfo.hProcess, 10000);
            ClearWaitCursor();
            CloseHandle (ExecInfo.hProcess);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnEdit: ShellExecuteEx failed with %d"),
                     GetLastError()));
            ReportError(NULL, GetLastError(), IDS_SPAWNGPEFAILED);
        }
    }
}

void CRSOPComponentData::OnContextMenu(HWND hDlg, LPARAM lParam)
{
    LPGPOLISTITEM lpItem;
    LVITEM item;
    HMENU hPopup;
    HWND hLV;
    int i;
    RECT rc;
    POINT pt;

    //
    // Get the selected item (if any)
    //

    hLV = GetDlgItem (hDlg, IDC_LIST1);
    i = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);

    if (i < 0)
    {
        return;
    }

    item.mask = LVIF_PARAM;
    item.iItem = i;
    item.iSubItem = 0;

    if (!ListView_GetItem (GetDlgItem(hDlg, IDC_LIST1), &item))
    {
        return;
    }

    lpItem = (LPGPOLISTITEM) item.lParam;


    //
    // Figure out where to place the context menu
    //

    pt.x = ((int)(short)LOWORD(lParam));
    pt.y = ((int)(short)HIWORD(lParam));

    GetWindowRect (hLV, &rc);

    if (!PtInRect (&rc, pt))
    {
        if ((lParam == (LPARAM) -1) && (i >= 0))
        {
            rc.left = LVIR_SELECTBOUNDS;
            SendMessage (hLV, LVM_GETITEMRECT, i, (LPARAM) &rc);

            pt.x = rc.left + 8;
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);

            ClientToScreen (hLV, &pt);
        }
        else
        {
            pt.x = rc.left + ((rc.right - rc.left) / 2);
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);
        }
    }


    //
    // Load the context menu
    //


    hPopup = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_GPOLIST_CONTEXTMENU));

    if (!hPopup) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnContextMenu: LoadMenu failed with %d"),
                 GetLastError()));
        return;
    }

    if (!(lpItem->pSD)) {
        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::OnContextMenu: Disabling Security menu item")));
        EnableMenuItem(GetSubMenu(hPopup, 0), IDM_GPOLIST_SECURITY, MF_GRAYED);
        DrawMenuBar(hDlg);
    }

    //
    // Display the menu
    //

    TrackPopupMenu(GetSubMenu(hPopup, 0), TPM_LEFTALIGN, pt.x, pt.y, 0, hDlg, NULL);

    DestroyMenu(hPopup);
}

void CRSOPComponentData::OnRefreshDisplay(HWND hDlg)
{
    INT iIndex;
    LVITEM item;
    LPGPOLISTITEM lpItem;


    iIndex = ListView_GetNextItem (GetDlgItem(hDlg, IDC_LIST1), -1,
                                   LVNI_ALL | LVNI_SELECTED);

    if (iIndex != -1)
    {

        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (GetDlgItem(hDlg, IDC_LIST1), &item))
        {
            return;
        }

        lpItem = (LPGPOLISTITEM) item.lParam;

        if (lpItem->pSD)
        {
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
        }
        else
        {
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
        }

        EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
    }
    else
    {
        EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
        EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
    }
}

INT_PTR CALLBACK CRSOPComponentData::QueryDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR szBuffer[MAX_PATH];
    CRSOPComponentData * pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        if (pCD)
        {
            pCD->InitializeResultsList (GetDlgItem(hDlg, IDC_LIST1));
            pCD->FillResultsList (GetDlgItem(hDlg, IDC_LIST1));
        }

        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aQueryHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (ULONG_PTR) (LPSTR) aQueryHelpIds);
        return (TRUE);

    }
    return FALSE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPGPOListMachineProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR szBuffer[MAX_PATH];
    CRSOPComponentData * pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        LoadString(g_hInstance, IDS_RSOP_GPOLIST_MACHINE, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hDlg, IDC_STATIC1, szBuffer);

        if (pCD)
        {
            pCD->FillGPOList(hDlg, IDC_LIST1, pCD->m_pComputerGPOList, FALSE, FALSE, FALSE, TRUE);
        }
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD)
            {
                switch (LOWORD(wParam))
                {
                case IDC_CHECK1:
                case IDC_CHECK2:
                case IDC_CHECK3:
                    {
                        pCD->FillGPOList(hDlg,
                                         IDC_LIST1,
                                         pCD->m_pComputerGPOList,
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK1), BM_GETCHECK, 0, 0),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK2), BM_GETCHECK, 0, 0),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK3), BM_GETCHECK, 0, 0),
                                         FALSE);
                    }
                    break;

                case IDC_BUTTON2:
                case IDM_GPOLIST_EDIT:
                    pCD->OnEdit(hDlg);
                    break;

                case IDC_BUTTON1:
                case IDM_GPOLIST_SECURITY:
                    pCD->OnSecurity(hDlg);
                    break;
                }
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
        }
        break;

    case WM_NOTIFY:
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (pCD)
        {
            pCD->OnRefreshDisplay(hDlg);
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aGPOListHelpIds);
        break;


    case WM_CONTEXTMENU:
        if (GetDlgItem(hDlg, IDC_LIST1) == (HWND)wParam)
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD)
            {
                pCD->OnContextMenu(hDlg, lParam);
            }
        }
        else
        {
            // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aGPOListHelpIds);
        }
        return TRUE;

    }
    return FALSE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPGPOListUserProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR szBuffer[MAX_PATH];
    CRSOPComponentData * pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);

        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        LoadString(g_hInstance, IDS_RSOP_GPOLIST_USER, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hDlg, IDC_STATIC1, szBuffer);

        if (pCD)
        {
            pCD->FillGPOList(hDlg, IDC_LIST1, pCD->m_pUserGPOList, FALSE, FALSE, FALSE, TRUE);
        }
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD)
            {
                switch (LOWORD(wParam))
                {
                case IDC_CHECK1:
                case IDC_CHECK2:
                case IDC_CHECK3:
                    {
                        pCD->FillGPOList(hDlg,
                                         IDC_LIST1,
                                         pCD->m_pUserGPOList,
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK1), BM_GETCHECK, 0, 0),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK2), BM_GETCHECK, 0, 0),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK3), BM_GETCHECK, 0, 0),
                                         FALSE);
                    }
                    break;

                case IDC_BUTTON2:
                case IDM_GPOLIST_EDIT:
                    pCD->OnEdit(hDlg);
                    break;

                case IDC_BUTTON1:
                case IDM_GPOLIST_SECURITY:
                    pCD->OnSecurity(hDlg);
                    break;
                }
            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
        }
        break;

    case WM_NOTIFY:
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

        if (pCD)
        {
            pCD->OnRefreshDisplay(hDlg);
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aGPOListHelpIds);
        break;

    case WM_CONTEXTMENU:
        if (GetDlgItem(hDlg, IDC_LIST1) == (HWND)wParam)
        {
            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD)
            {
                pCD->OnContextMenu(hDlg, lParam);
            }
        }
        else
        {
            // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aGPOListHelpIds);
        }
        return TRUE;

    }
    return FALSE;
}

void CRSOPComponentData::QueryRSoPPolicySettingStatusInstances (LPTSTR lpNamespace)
{
    HRESULT hr;
    ULONG n;
    IWbemClassObject * pStatus = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = SysAllocString(TEXT("SELECT * FROM RSoP_PolicySettingStatus"));
    BSTR strNamespace = SysAllocString(lpNamespace);
    BSTR bstrEventSource = NULL;
    BSTR bstrEventLogName = NULL;
    DWORD dwEventID;
    BSTR bstrEventTime = NULL;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    SYSTEMTIME EventTime, BeginTime, EndTime;
    XBStr xbstrWbemTime;
    FILETIME ft;
    ULARGE_INTEGER ulTime;


    //
    // Get a locator instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: CoCreateInstance failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Connect to the namespace
    //

    hr = pLocator->ConnectServer(lpNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: ConnectServer failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Query for the RSoP_PolicySettingStatus instances
    //

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Loop through the results
    //

    while (TRUE)
    {

        //
        // Get 1 instance
        //

        hr = pEnum->Next(WBEM_INFINITE, 1, &pStatus, &n);

        if (FAILED(hr) || (n == 0))
        {
            goto cleanup;
        }


        //
        // Get the event source name
        //

        hr = GetParameterBSTR(pStatus, TEXT("eventSource"), bstrEventSource);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the event log name
        //

        hr = GetParameterBSTR(pStatus, TEXT("eventLogName"), bstrEventLogName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the event ID
        //

        hr = GetParameter(pStatus, TEXT("eventID"), (ULONG)dwEventID);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the EventTime in bstr format
        //

        hr = GetParameterBSTR(pStatus, TEXT("eventTime"), bstrEventTime);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to get event time with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Convert it to system time format
        //

        xbstrWbemTime = bstrEventTime;

        hr = WbemTimeToSystemTime(xbstrWbemTime, EventTime);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: WbemTimeToSystemTime failed with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Take the event time minus 1 second to get the begin time
        //

        if (!SystemTimeToFileTime (&EventTime, &ft))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: SystemTimeToFileTime failed with %d"), GetLastError()));
            goto cleanup;
        }

        ulTime.LowPart = ft.dwLowDateTime;
        ulTime.HighPart = ft.dwHighDateTime;

        ulTime.QuadPart = ulTime.QuadPart - 10000000;  // 1 second

        ft.dwLowDateTime = ulTime.LowPart;
        ft.dwHighDateTime = ulTime.HighPart;

        if (!FileTimeToSystemTime (&ft, &BeginTime))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: FileTimeToSystemTime failed with %d"), GetLastError()));
            goto cleanup;
        }


        //
        // Take the event time plus 1 second to get the end time
        //

        if (!SystemTimeToFileTime (&EventTime, &ft))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: SystemTimeToFileTime failed with %d"), GetLastError()));
            goto cleanup;
        }

        ulTime.LowPart = ft.dwLowDateTime;
        ulTime.HighPart = ft.dwHighDateTime;

        ulTime.QuadPart = ulTime.QuadPart + 10000000;  // 1 second

        ft.dwLowDateTime = ulTime.LowPart;
        ft.dwHighDateTime = ulTime.HighPart;

        if (!FileTimeToSystemTime (&ft, &EndTime))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: FileTimeToSystemTime failed with %d"), GetLastError()));
            goto cleanup;
        }


        //
        // Get the event log source information
        //

        if (m_pEvents)
        {
            m_pEvents->QueryForEventLogEntries ((m_bDiagnostic ? m_szComputerName : m_szDC),
                                                bstrEventLogName, bstrEventSource, dwEventID,
                                                &BeginTime, &EndTime);
        }

        //
        // Prepare for next iteration
        //

        SysFreeString (bstrEventSource);
        bstrEventSource = NULL;

        SysFreeString (bstrEventLogName);
        bstrEventLogName = NULL;

        SysFreeString (bstrEventTime);
        bstrEventTime = NULL;

        pStatus->Release();
        pStatus = NULL;
    }

cleanup:

    if (bstrEventSource)
    {
        SysFreeString (bstrEventSource);
    }
    if (bstrEventLogName)
    {
        SysFreeString (bstrEventLogName);
    }
    if (bstrEventTime)
    {
        SysFreeString (bstrEventTime);
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    SysFreeString(strQueryLanguage);
    SysFreeString(strQuery);
    SysFreeString(strNamespace);
}

void CRSOPComponentData::GetEventLogSources (IWbemServices * pNamespace,
                                             LPTSTR lpCSEGUID, LPTSTR lpComputerName,
                                             SYSTEMTIME *BeginTime, SYSTEMTIME *EndTime,
                                             LPSOURCEENTRY *lpSources)
{
    HRESULT hr;
    ULONG n;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = NULL;
    LPTSTR lpQuery;
    const TCHAR szBaseQuery [] = TEXT("SELECT * FROM RSOP_ExtensionEventSourceLink WHERE extensionStatus=\"RSOP_ExtensionStatus.extensionGuid=\\\"%s\\\"\"");
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject * pLink = NULL;
    IWbemClassObject * pEventSource = NULL;
    BSTR bstrEventSource = NULL;
    BSTR bstrEventLogName = NULL;
    BSTR bstrEventSourceName = NULL;


    //
    // Build the query first
    //

    lpQuery = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBaseQuery) + 50) * sizeof(TCHAR));

    if (!lpQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed  to allocate memory for query")));
        goto cleanup;
    }

    wsprintf (lpQuery, szBaseQuery, lpCSEGUID);

    strQuery = SysAllocString(lpQuery);

    LocalFree (lpQuery);

    if (!strQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed  to allocate memory for query (2)")));
        goto cleanup;
    }


    //
    // Query for the RSOP_ExtensionEventSourceLink instances that match this CSE
    //

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Loop through the results
    //

    while (TRUE)
    {

        //
        // Get 1 instance
        //

        hr = pEnum->Next(WBEM_INFINITE, 1, &pLink, &n);

        if (FAILED(hr) || (n == 0))
        {
            goto cleanup;
        }


        //
        // Get the eventSource reference
        //

        hr = GetParameterBSTR(pLink, TEXT("eventSource"), bstrEventSource);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed to get event source reference with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the eventSource instance
        //

        hr = pNamespace->GetObject(
                          bstrEventSource,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pEventSource,
                          NULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: GetObject for event source of %s failed with 0x%x"),
                     bstrEventSource, hr));
            goto loopagain;
        }


        //
        // Get the eventLogSource property
        //

        hr = GetParameterBSTR(pEventSource, TEXT("eventLogSource"), bstrEventSourceName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed to get event source name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the eventLogName property
        //

        hr = GetParameterBSTR(pEventSource, TEXT("eventLogName"), bstrEventLogName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed to get event log name with 0x%x"), hr));
            goto cleanup;
        }


        if (m_pEvents)
        {
            //
            // Add it to the list of sources
            //

            m_pEvents->AddSourceEntry (bstrEventLogName, bstrEventSourceName, lpSources);


            //
            // Initialize the event log database for this source if we are working
            // with a live query.  If this is archived data, the event log entries
            // will be reloaded from the saved console file.
            //

            if (!m_bArchiveData)
            {
                m_pEvents->QueryForEventLogEntries (lpComputerName,
                                                    bstrEventLogName, bstrEventSourceName,
                                                    0, BeginTime, EndTime);
            }
        }


        //
        // Clean up for next item
        //

        SysFreeString (bstrEventLogName);
        bstrEventLogName = NULL;

        SysFreeString (bstrEventSourceName);
        bstrEventSourceName = NULL;

        pEventSource->Release();
        pEventSource = NULL;

loopagain:
        SysFreeString (bstrEventSource);
        bstrEventSource = NULL;

        pLink->Release();
        pLink = NULL;
    }

cleanup:


    if (bstrEventSourceName)
    {
        SysFreeString (bstrEventSourceName);
    }

    if (bstrEventLogName)
    {
        SysFreeString (bstrEventLogName);
    }

    if (bstrEventSource)
    {
        SysFreeString (bstrEventSource);
    }

    if (pEventSource)
    {
        pEventSource->Release();
    }

    if (pLink)
    {
        pLink->Release();
    }

    if (pEnum)
    {
        pEnum->Release();
    }

    if (strQueryLanguage)
    {
        SysFreeString(strQueryLanguage);
    }

    if (strQuery)
    {
        SysFreeString(strQuery);
    }

}

void CRSOPComponentData::BuildCSEList (LPCSEITEM * lpList, LPTSTR lpNamespace, BOOL *bCSEError, BOOL *bGPCoreError)
{
    HRESULT hr;
    ULONG n;
    IWbemClassObject * pExtension = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ExtensionStatus"));
    BSTR strNamespace = SysAllocString(lpNamespace);
    BSTR bstrName = NULL;
    BSTR bstrGUID = NULL;
    BSTR bstrBeginTime = NULL;
    BSTR bstrEndTime = NULL;
    ULONG ulLoggingStatus;
    ULONG ulStatus;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    SYSTEMTIME BeginTime, EndTime;
    LPTSTR lpSourceNames = NULL;
    XBStr xbstrWbemTime;
    LPSOURCEENTRY lpSources;


    //
    // Get a locator instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: CoCreateInstance failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Connect to the namespace
    //

    hr = pLocator->ConnectServer(lpNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: ConnectServer failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Query for the RSOP_ExtensionStatus instances
    //

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Loop through the results
    //

    while (TRUE)
    {

        //
        // Get 1 instance
        //

        hr = pEnum->Next(WBEM_INFINITE, 1, &pExtension, &n);

        if (FAILED(hr) || (n == 0))
        {
            goto cleanup;
        }


        //
        // Get the name
        //

        hr = GetParameterBSTR(pExtension, TEXT("displayName"), bstrName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the GUID
        //

        hr = GetParameterBSTR(pExtension, TEXT("extensionGuid"), bstrGUID);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the status
        //

        hr = GetParameter(pExtension, TEXT("error"), ulStatus);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get status with 0x%x"), hr));
            goto cleanup;

        }


        //
        // Get the rsop logging status
        //

        hr = GetParameter(pExtension, TEXT("loggingStatus"), ulLoggingStatus);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get logging status with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the BeginTime in bstr format
        //

        hr = GetParameterBSTR(pExtension, TEXT("beginTime"), bstrBeginTime);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get begin time with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Convert it to system time format
        //

        xbstrWbemTime = bstrBeginTime;

        hr = WbemTimeToSystemTime(xbstrWbemTime, BeginTime);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: WbemTimeToSystemTime failed with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the EndTime in bstr format
        //

        hr = GetParameterBSTR(pExtension, TEXT("endTime"), bstrEndTime);

        if (SUCCEEDED(hr))
        {
            //
            // Convert it to system time format
            //

            xbstrWbemTime = bstrEndTime;

            hr = WbemTimeToSystemTime(xbstrWbemTime, EndTime);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: WbemTimeToSystemTime failed with 0x%x"), hr));
                goto cleanup;
            }
        }
        else
        {
            FILETIME ft;
            ULARGE_INTEGER ulTime;

            //
            // Add 2 minutes to BeginTime to get a close approx of the EndTime
            //

            if (!SystemTimeToFileTime (&BeginTime, &ft))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: SystemTimeToFileTime failed with %d"), GetLastError()));
                goto cleanup;
            }

            ulTime.LowPart = ft.dwLowDateTime;
            ulTime.HighPart = ft.dwHighDateTime;

            ulTime.QuadPart = ulTime.QuadPart + (10000000 * 120);  // 120 seconds

            ft.dwLowDateTime = ulTime.LowPart;
            ft.dwHighDateTime = ulTime.HighPart;

            if (!FileTimeToSystemTime (&ft, &EndTime))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: FileTimeToSystemTime failed with %d"), GetLastError()));
                goto cleanup;
            }
        }


        //
        // Get the event log source information
        //

        lpSources = NULL;
        GetEventLogSources (pNamespace, bstrGUID, (m_bDiagnostic ? m_szComputerName : m_szDC),
                            &BeginTime, &EndTime, &lpSources);


        //
        // Add this node to the list
        //

        if (!AddCSENode(bstrName, bstrGUID, ulStatus, ulLoggingStatus, &BeginTime, &EndTime,
                        lpList, bCSEError, bGPCoreError, lpSources))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: AddGPOListNode failed.")));
            if (m_pEvents)
            {
                m_pEvents->FreeSourceData (lpSources);
            }
            goto cleanup;
        }


        //
        // Prepare for next iteration
        //

        SysFreeString (bstrName);
        bstrName = NULL;

        SysFreeString (bstrGUID);
        bstrGUID = NULL;

        SysFreeString (bstrBeginTime);
        bstrBeginTime = NULL;

        if (bstrEndTime)
        {
            SysFreeString (bstrEndTime);
            bstrEndTime = NULL;
        }

        LocalFree (lpSourceNames);
        lpSourceNames = NULL;

        pExtension->Release();
        pExtension = NULL;
    }

cleanup:

    if (bstrName)
    {
        SysFreeString (bstrName);
    }
    if (bstrGUID)
    {
        SysFreeString (bstrGUID);
    }
    if (bstrBeginTime)
    {
        SysFreeString (bstrBeginTime);
    }
    if (bstrEndTime)
    {
        SysFreeString (bstrEndTime);
    }
    if (lpSourceNames)
    {
        LocalFree (lpSourceNames);
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    SysFreeString(strQueryLanguage);
    SysFreeString(strQuery);
    SysFreeString(strNamespace);
}

VOID CRSOPComponentData::BuildCSELists (void)
{
    LPTSTR lpNamespace, lpEnd;

    lpNamespace = (LPTSTR) LocalAlloc (LPTR, (lstrlen(m_szNamespace) + 20) * sizeof(TCHAR));

    if (lpNamespace)
    {
        lstrcpy (lpNamespace, m_szNamespace);
        lpEnd = CheckSlash(lpNamespace);

        lstrcpy (lpEnd, TEXT("User"));

        if (m_pUserCSEList)
        {
            FreeCSEData(m_pUserCSEList);
            m_pUserCSEList = NULL;
        }

        BuildCSEList (&m_pUserCSEList, lpNamespace, &m_bUserCSEError, &m_bUserGPCoreError);

        if (!m_bArchiveData)
        {
            QueryRSoPPolicySettingStatusInstances (lpNamespace);
        }


        lstrcpy (lpEnd, TEXT("Computer"));

        if (m_pComputerCSEList)
        {
            FreeCSEData(m_pComputerCSEList);
            m_pComputerCSEList = NULL;
        }

        BuildCSEList (&m_pComputerCSEList, lpNamespace, &m_bComputerCSEError, &m_bComputerGPCoreError);

        if (!m_bArchiveData)
        {
            QueryRSoPPolicySettingStatusInstances (lpNamespace);
        }

        LocalFree (lpNamespace);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSELists: Failed to allocate memory for namespace with %d"),
                 GetLastError()));
    }
}

BOOL CRSOPComponentData::AddCSENode(LPTSTR lpName, LPTSTR lpGUID, DWORD dwStatus,
                                    ULONG ulLoggingStatus, SYSTEMTIME *pBeginTime, SYSTEMTIME *pEndTime,
                                    LPCSEITEM *lpList, BOOL *bCSEError, BOOL *bGPCoreError,
                                    LPSOURCEENTRY lpSources)
{
    DWORD dwSize;
    LPCSEITEM lpItem, lpTemp;
    GUID guid;


    //
    // Calculate the size of the new item
    //

    dwSize = sizeof (CSEITEM);

    dwSize += ((lstrlen(lpName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpGUID) + 1) * sizeof(TCHAR));


    //
    // Allocate space for it
    //

    lpItem = (LPCSEITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::AddCSENode: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    lpItem->lpName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(CSEITEM));
    lstrcpy (lpItem->lpName, lpName);

    lpItem->lpGUID = lpItem->lpName + lstrlen (lpItem->lpName) + 1;
    lstrcpy (lpItem->lpGUID, lpGUID);

    lpItem->dwStatus = dwStatus;
    lpItem->ulLoggingStatus = ulLoggingStatus;
    lpItem->lpEventSources = lpSources;

    CopyMemory ((LPBYTE)&lpItem->BeginTime, pBeginTime, sizeof(SYSTEMTIME));
    CopyMemory ((LPBYTE)&lpItem->EndTime, pEndTime, sizeof(SYSTEMTIME));


    //
    // Add item to the link list
    //

    if (*lpList)
    {
        StringToGuid( lpGUID, &guid);

        if (IsNullGUID (&guid))
        {
            lpItem->pNext = *lpList;
            *lpList = lpItem;
        }
        else
        {
            lpTemp = *lpList;

            while (lpTemp)
            {
                if (!lpTemp->pNext)
                {
                    lpTemp->pNext = lpItem;
                    break;
                }
                lpTemp = lpTemp->pNext;
            }
        }
    }
    else
    {
        *lpList = lpItem;
    }


    //
    // Set the error flag if appropriate
    //

    if ((dwStatus != ERROR_SUCCESS) || (ulLoggingStatus == 2))
    {
        StringToGuid( lpGUID, &guid);

        if (IsNullGUID (&guid))
        {
            *bGPCoreError = TRUE;
        }
        else
        {
            *bCSEError =  TRUE;
        }
    }

    return TRUE;
}

VOID CRSOPComponentData::FreeCSEData(LPCSEITEM lpList)
{
    LPCSEITEM lpTemp;


    do {
        lpTemp = lpList->pNext;
        if (m_pEvents)
        {
            m_pEvents->FreeSourceData (lpList->lpEventSources);
        }
        LocalFree (lpList);
        lpList = lpTemp;

    } while (lpTemp);
}

void CRSOPComponentData::InitializeErrorsDialog(HWND hDlg, LPCSEITEM lpList)
{
    RECT rect;
    WCHAR szBuffer[256];
    LV_COLUMN lvcol;
    LONG lWidth;
    INT cxName = 0, cxStatus = 0, iIndex = 0, iDefault = 0;
    DWORD dwCount = 0;
    HWND hList = GetDlgItem(hDlg, IDC_LIST1);
    LPCSEITEM lpTemp;
    LVITEM item;
    GUID guid;
    BOOL bGPCoreFailed = FALSE;


    //
    // Count the number of components
    //

    lpTemp = lpList;

    while (lpTemp)
    {
        lpTemp = lpTemp->pNext;
        dwCount++;
    }


    //
    // Decide on the column widths
    //

    GetClientRect(hList, &rect);

    if (dwCount > (DWORD)ListView_GetCountPerPage(hList))
    {
        lWidth = (rect.right - rect.left) - GetSystemMetrics(SM_CYHSCROLL);
    }
    else
    {
        lWidth = rect.right - rect.left;
    }


    cxStatus = (lWidth * 35) / 100;
    cxName = lWidth - cxStatus;


    //
    // Insert the component name column and then the status column
    //

    memset(&lvcol, 0, sizeof(lvcol));

    lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.pszText = szBuffer;
    lvcol.cx = cxName;
    LoadString(g_hInstance, IDS_COMPONENT_NAME, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hList, 0, &lvcol);


    lvcol.cx = cxStatus;
    LoadString(g_hInstance, IDS_STATUS, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hList, 1, &lvcol);


    //
    // Turn on some listview features
    //

    SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


    //
    // Insert the CSE's
    //

    lpTemp = lpList;

    while (lpTemp)
    {
        ZeroMemory (&item, sizeof(item));

        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = iIndex;
        item.pszText = lpTemp->lpName;
        item.lParam = (LPARAM) lpTemp;
        iIndex = ListView_InsertItem (hList, &item);


        if (bGPCoreFailed)
        {
            LoadString(g_hInstance, IDS_CSE_NA, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if ((lpTemp->dwStatus == ERROR_SUCCESS) && (lpTemp->ulLoggingStatus != 2))
        {
            if (lpTemp->ulLoggingStatus == 3)
            {
                LoadString(g_hInstance, IDS_SUCCESS2, szBuffer, ARRAYSIZE(szBuffer));
            }
            else
            {
                LoadString(g_hInstance, IDS_SUCCESS, szBuffer, ARRAYSIZE(szBuffer));
            }
        }
        else if (lpTemp->dwStatus == E_PENDING)
        {
            LoadString(g_hInstance, IDS_PENDING, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (lpTemp->dwStatus == ERROR_OVERRIDE_NOCHANGES)
        {
            LoadString(g_hInstance, IDS_WARNING, szBuffer, ARRAYSIZE(szBuffer));
        }
        else
        {
            if (lpTemp->ulLoggingStatus == 3)
            {
                LoadString(g_hInstance, IDS_FAILED2, szBuffer, ARRAYSIZE(szBuffer));
            }
            else
            {
                LoadString(g_hInstance, IDS_FAILED, szBuffer, ARRAYSIZE(szBuffer));
            }
        }


        item.mask = LVIF_TEXT;
        item.pszText = szBuffer;
        item.iItem = iIndex;
        item.iSubItem = 1;
        ListView_SetItem(hList, &item);


        //
        // Check if GPCore failed
        //

        StringToGuid( lpTemp->lpGUID, &guid);

        if (IsNullGUID (&guid))
        {
            if (lpTemp->dwStatus != ERROR_SUCCESS)
            {
                bGPCoreFailed = TRUE;
            }
        }

        lpTemp = lpTemp->pNext;
        iIndex++;
    }


    //
    // Select the first non-successful item
    //


    iIndex = 0;

    while (iIndex < ListView_GetItemCount(hList))
    {
        ZeroMemory (&item, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;

        if (!ListView_GetItem (hList, &item))
        {
            break;
        }

        if (item.lParam)
        {
            lpTemp = (LPCSEITEM) item.lParam;

            if ((lpTemp->dwStatus != ERROR_SUCCESS) || (lpTemp->ulLoggingStatus == 2))
            {
                iDefault = iIndex;
                break;
            }
        }

        iIndex++;
    }

    item.mask = LVIF_STATE;
    item.iItem = iDefault;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hList, LVM_SETITEMSTATE, iDefault, (LPARAM) &item);
    SendMessage (hList, LVM_ENSUREVISIBLE, iDefault, FALSE);
}

void CRSOPComponentData::RefreshErrorInfo (HWND hDlg)
{
    HWND hList = GetDlgItem(hDlg, IDC_LIST1);
    HWND hEdit = GetDlgItem(hDlg, IDC_EDIT1);
    LPCSEITEM lpItem;
    LVITEM item;
    INT iIndex;
    TCHAR szBuffer[300];
    LPTSTR lpMsg;
    TCHAR szDate[100];
    TCHAR szTime[100];
    TCHAR szFormat[80];
    FILETIME ft, ftLocal;
    SYSTEMTIME systime;
    LPOLESTR lpEventLogText = NULL;
    CHARFORMAT2 chFormat;
    BOOL bBold = FALSE;
    GUID guid;

    iIndex = ListView_GetNextItem (hList, -1, LVNI_ALL | LVNI_SELECTED);

    if (iIndex != -1)
    {
        //
        // Get the CSEITEM pointer
        //

        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hList, &item))
        {
            return;
        }

        lpItem = (LPCSEITEM) item.lParam;

        if (!lpItem)
        {
            return;
        }


        SendMessage (hEdit, WM_SETREDRAW, FALSE, 0);

        //
        // Set the time information
        //

        SendMessage (hEdit, EM_SETSEL, 0, (LPARAM) -1);

        SystemTimeToFileTime (&lpItem->EndTime, &ft);
        FileTimeToLocalFileTime (&ft, &ftLocal);
        FileTimeToSystemTime (&ftLocal, &systime);


        GetDateFormat (LOCALE_USER_DEFAULT, DATE_LONGDATE, &systime,
                       NULL, szDate, ARRAYSIZE (szDate));

        GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                       NULL, szTime, ARRAYSIZE (szTime));

        LoadString (g_hInstance, IDS_DATETIMEFORMAT, szFormat, ARRAYSIZE(szFormat));
        wsprintf (szBuffer, szFormat, szDate, szTime);


        //
        // Turn italic on
        //

        ZeroMemory (&chFormat, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_ITALIC;
        chFormat.dwEffects = CFE_ITALIC;

        SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                     (LPARAM) &chFormat);


        SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);


        if (lpItem->ulLoggingStatus == 3)
        {
            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) TEXT("\r\n\r\n"));

            LoadString(g_hInstance, IDS_LEGACYCSE, szBuffer, ARRAYSIZE(szBuffer));
            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);

            LoadString(g_hInstance, IDS_LEGACYCSE1, szBuffer, ARRAYSIZE(szBuffer));
            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);
        }


        //
        // Turn italic off
        //

        ZeroMemory (&chFormat, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_ITALIC;

        SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                     (LPARAM) &chFormat);


        //
        // Put a blank line in between the time and the main message
        //

        SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
        SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) TEXT("\r\n\r\n"));


        //
        // Set the main message
        //

        if (lpItem->ulLoggingStatus == 2)
        {
            if ( lpItem->dwStatus == ERROR_SUCCESS )
                LoadString(g_hInstance, IDS_LOGGINGFAILED, szBuffer, ARRAYSIZE(szBuffer));
            else
                LoadString(g_hInstance, IDS_FAILEDMSG2, szBuffer, ARRAYSIZE(szBuffer));
            bBold = TRUE;
        }
        else if (lpItem->dwStatus == ERROR_SUCCESS)
        {
            LoadString(g_hInstance, IDS_SUCCESSMSG, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (lpItem->dwStatus == E_PENDING)
        {
            LoadString(g_hInstance, IDS_PENDINGMSG, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (lpItem->dwStatus == ERROR_OVERRIDE_NOCHANGES)
        {
            LoadString(g_hInstance, IDS_OVERRIDE, szBuffer, ARRAYSIZE(szBuffer));
            bBold = TRUE;
        }
        else if (lpItem->dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED)
        {
            LoadString(g_hInstance, IDS_SYNC_REQUIRED, szBuffer, ARRAYSIZE(szBuffer));
            bBold = TRUE;
        }
        else
        {
            LoadString(g_hInstance, IDS_FAILEDMSG1, szBuffer, ARRAYSIZE(szBuffer));
            bBold = TRUE;
        }


        if (bBold)
        {
            //
            // Turn bold on
            //

            ZeroMemory (&chFormat, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_BOLD;
            chFormat.dwEffects = CFE_BOLD;

            SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                         (LPARAM) &chFormat);
        }

        lpMsg = (LPTSTR) LocalAlloc(LPTR, (lstrlen(lpItem->lpName) + lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (!lpMsg)
        {
            SendMessage (hEdit, WM_SETREDRAW, TRUE, 0);
            InvalidateRect (hEdit, NULL, TRUE);
            UpdateWindow (hEdit);
            return;
        }

        wsprintf (lpMsg, szBuffer, lpItem->lpName);
        SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
        SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) lpMsg);
        LocalFree (lpMsg);


        //
        // Even if the CSE was successful or if it returned E_PENDING, continue on to get the
        // eventlog msgs
        //

        StringToGuid( lpItem->lpGUID, &guid);

        if (!((lpItem->dwStatus == ERROR_SUCCESS) || (lpItem->dwStatus == E_PENDING)))
        {
            //
            // Print the error code if appropriate
            //

            if (lpItem->dwStatus != ERROR_OVERRIDE_NOCHANGES && lpItem->dwStatus != ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
            {
                lpMsg = (LPTSTR) LocalAlloc(LPTR, 300 * sizeof(TCHAR));

                if (lpMsg)
                {
                    LoadMessage (lpItem->dwStatus, lpMsg, 300);

                    SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
                    SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) lpMsg);

                    LocalFree (lpMsg);
                }
            }


            //
            // Special case GPCore to have an additional message
            //

            if (IsNullGUID (&guid))
            {
                LoadString(g_hInstance, IDS_GPCOREFAIL, szBuffer, ARRAYSIZE(szBuffer));
                SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
                SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);
            }

        }
        else {

            if (lpItem->ulLoggingStatus == 2) {

                //
                // Special case GPCore to have an additional message if logging failed
                //

                if (IsNullGUID (&guid))
                {
                    LoadString(g_hInstance, IDS_GPCORE_LOGGINGFAIL, szBuffer, ARRAYSIZE(szBuffer));
                    SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
                    SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);
                }
            }
        }


        if (bBold)
        {
            //
            // Turn bold off
            //

            ZeroMemory (&chFormat, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_BOLD;

            SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                         (LPARAM) &chFormat);
        }


        //
        // Get any event log text for this CSE
        //

        if (m_pEvents && SUCCEEDED(m_pEvents->GetCSEEntries(&lpItem->BeginTime, &lpItem->EndTime,
                                                            lpItem->lpEventSources, &lpEventLogText,
                                                            (IsNullGUID (&guid)))))
        {
            //
            // Put a blank line between the main message and the Additional information header
            //

            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) TEXT("\r\n"));


            //
            // Turn underline on
            //

            ZeroMemory (&chFormat, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_UNDERLINETYPE | CFM_UNDERLINE;
            chFormat.dwEffects = CFE_UNDERLINE;
            chFormat.bUnderlineType = CFU_UNDERLINE;

            SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                         (LPARAM) &chFormat);

            LoadString(g_hInstance, IDS_ADDITIONALINFO, szBuffer, ARRAYSIZE(szBuffer));
            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);


            //
            // Turn underline off
            //

            ZeroMemory (&chFormat, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_UNDERLINETYPE | CFM_UNDERLINE;
            chFormat.dwEffects = CFE_UNDERLINE;
            chFormat.bUnderlineType = CFU_UNDERLINENONE;

            SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                         (LPARAM) &chFormat);


            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) TEXT("\r\n"));


            //
            //  Add the event log info to the edit control
            //

            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) lpEventLogText);

            CoTaskMemFree (lpEventLogText);
        }

        SendMessage (hEdit, EM_SETSEL, 0, 0);
        SendMessage (hEdit, EM_SCROLLCARET, 0, 0);

        SendMessage (hEdit, WM_SETREDRAW, TRUE, 0);
        InvalidateRect (hEdit, NULL, TRUE);
        UpdateWindow (hEdit);
    }

}

void CRSOPComponentData::OnSaveAs (HWND hDlg)
{
    OPENFILENAME ofn;
    TCHAR szFilter[100];
    LPTSTR lpTemp;
    TCHAR szFile[2*MAX_PATH];
    HANDLE hFile;
    DWORD dwSize, dwBytesWritten;


    //
    // Load the filter string and replace the # signs with nulls
    //

    LoadString (g_hInstance, IDS_ERRORFILTER, szFilter, ARRAYSIZE(szFilter));


    lpTemp = szFilter;

    while (*lpTemp)
    {
        if (*lpTemp == TEXT('#'))
            *lpTemp = TEXT('\0');

        lpTemp++;
    }


    //
    // Call the Save common dialog
    //

    szFile[0] = TEXT('\0');
    ZeroMemory (&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = 2*MAX_PATH;
    ofn.lpstrDefExt = TEXT("txt");
    ofn.Flags = OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

    if (!GetSaveFileName (&ofn))
    {
        return;
    }


    SetWaitCursor ();

    //
    // Create the text file
    //

    hFile = CreateFile (szFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnSaveAs: CreateFile failed with %d"), GetLastError()));
        ClearWaitCursor ();
        return;
    }


    //
    // Get the text out of the edit control
    //

    dwSize = (DWORD) SendDlgItemMessage (hDlg, IDC_EDIT1, WM_GETTEXTLENGTH, 0, 0);

    lpTemp = (LPTSTR) LocalAlloc (LPTR, (dwSize+2) * sizeof(TCHAR));

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnSaveAs: LocalAlloc failed with %d"), GetLastError()));
        CloseHandle (hFile);
        ClearWaitCursor ();
        return;
    }

    SendDlgItemMessage (hDlg, IDC_EDIT1, WM_GETTEXT, (dwSize+1), (LPARAM) lpTemp);



    //
    // Save it to the new file
    //

    WriteFile(hFile, L"\xfeff\r\n", 3 * sizeof(WCHAR), &dwBytesWritten, NULL);

    if (!WriteFile (hFile, lpTemp, (dwSize * sizeof(TCHAR)), &dwBytesWritten, NULL) ||
        (dwBytesWritten != (dwSize * sizeof(TCHAR))))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnSaveAs: Failed to text with %d"),
                 GetLastError()));
    }


    LocalFree (lpTemp);
    CloseHandle (hFile);
    ClearWaitCursor ();

}

INT_PTR CALLBACK CRSOPComponentData::RSOPErrorsMachineProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        if (pCD)
        {
            pCD->InitializeErrorsDialog(hDlg, pCD->m_pComputerCSEList);
            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        }
        break;

    case WM_COMMAND:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD)
        {
            if (LOWORD(wParam) == IDC_BUTTON1)
            {
                pCD->OnSaveAs(hDlg);
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                SendMessage(GetParent(hDlg), message, wParam, lParam);
            }
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpHdr = (LPNMHDR)lParam;

            if (lpHdr->code == LVN_ITEMCHANGED)
            {
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
        }
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD)
        {
            pCD->RefreshErrorInfo (hDlg);
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aErrorsHelpIds);
        break;


    case WM_CONTEXTMENU:
        // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (ULONG_PTR) (LPSTR) aErrorsHelpIds);
        return TRUE;

    }
    return FALSE;
}

INT_PTR CALLBACK CRSOPComponentData::RSOPErrorsUserProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        if (pCD)
        {
            pCD->InitializeErrorsDialog(hDlg, pCD->m_pUserCSEList);
            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        }
        break;

    case WM_COMMAND:

        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD)
        {
            if (LOWORD(wParam) == IDC_BUTTON1)
            {
                pCD->OnSaveAs(hDlg);
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                SendMessage(GetParent(hDlg), message, wParam, lParam);
            }
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpHdr = (LPNMHDR)lParam;

            if (lpHdr->code == LVN_ITEMCHANGED)
            {
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
        }
        break;
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD)
        {
            pCD->RefreshErrorInfo (hDlg);
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aErrorsHelpIds);
        break;


    case WM_CONTEXTMENU:
        // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (ULONG_PTR) (LPSTR) aErrorsHelpIds);
        return TRUE;

    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRSOPComponentDataCF::CRSOPComponentDataCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CRSOPComponentDataCF::~CRSOPComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CRSOPComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CRSOPComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CRSOPComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CRSOPComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                                     REFIID      riid,
                                     LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CRSOPComponentData *pComponentData = new CRSOPComponentData(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CRSOPComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IWbemObjectSink implementation                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CCreateSessionSink::CCreateSessionSink(HWND hProgress, DWORD dwThread)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_hProgress = hProgress;
    m_dwThread  = dwThread;

    m_bSendQuitMessage = FALSE;
    m_hrSuccess  = S_OK;
    m_pNameSpace = NULL;
    m_ulErrorInfo = 0;


    SendMessage (hProgress, PBM_SETPOS, 0, 0);
}

CCreateSessionSink::~CCreateSessionSink()
{
    if (m_pNameSpace)
    {
        SysFreeString (m_pNameSpace);
    }

    InterlockedDecrement(&g_cRefThisDll);
}

STDMETHODIMP_(ULONG)
CCreateSessionSink::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CCreateSessionSink::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CCreateSessionSink::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IWbemObjectSink))
    {
        *ppv = (IWbemObjectSink *)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP CCreateSessionSink::SendQuitMessage (BOOL bSendQuitMessage)
{
    m_bSendQuitMessage = bSendQuitMessage;
    return S_OK;
}

STDMETHODIMP CCreateSessionSink::GetResult (HRESULT *hSuccess)
{
    *hSuccess = m_hrSuccess;
    return S_OK;
}

STDMETHODIMP CCreateSessionSink::GetNamespace (BSTR *pNamespace)
{
    *pNamespace = m_pNameSpace;
    return S_OK;
}

STDMETHODIMP CCreateSessionSink::GetErrorInfo (ULONG *pulErrorInfo)
{
    *pulErrorInfo = m_ulErrorInfo;
    return S_OK;
}

STDMETHODIMP CCreateSessionSink::Indicate(long lObjCount, IWbemClassObject **pArray)
{
    LONG lIndex;
    HRESULT hr;
    IWbemClassObject *pObject;

    for (lIndex = 0; lIndex < lObjCount; lIndex++)
    {
        pObject = pArray[lIndex];

        hr = GetParameter(pObject, TEXT("hResult"), m_hrSuccess);

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(m_hrSuccess))
            {
                GetParameterBSTR(pObject, TEXT("nameSpace"), m_pNameSpace);
            }
            else
            {
                GetParameter(pObject, TEXT("ExtendedInfo"), m_ulErrorInfo);
            }
        }

        DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::Indicate:  Status:        0x%x"), m_hrSuccess));
        DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::Indicate:  Namespace:     %s"), m_pNameSpace ? m_pNameSpace : TEXT("Null")));
        DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::Indicate:  ExtendedInfo:  %d"), m_ulErrorInfo));
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CCreateSessionSink::SetStatus(LONG lFlags, HRESULT hResult,
                                      BSTR strParam, IWbemClassObject *pObjParam)
{
    HRESULT hr;
    ULONG ulValue;


    if (lFlags == WBEM_STATUS_PROGRESS)
    {
        if (m_hProgress)
        {
            //
            //  The hResult arg contains both the denominator
            //  and the numerator packed together.
            //
            //  Denominator is in the high word
            //  Numerator is in the low word
            //

            ulValue = MAKELONG(HIWORD(hResult), 0);
            SendMessage (m_hProgress, PBM_SETRANGE32, 0, (LPARAM) ulValue);

            ulValue = MAKELONG(LOWORD(hResult), 0);
            SendMessage (m_hProgress, PBM_SETPOS, (WPARAM) ulValue, 0);

            DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::SetStatus:  Precentage complete:  %d"), ulValue));
        }
    }

    if (lFlags == WBEM_STATUS_COMPLETE)
    {
        if (m_bSendQuitMessage)
        {
            if (hResult != WBEM_S_NO_ERROR)
            {
                m_hrSuccess = hResult;
                DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::SetStatus:  Setting error status to:  0x%x"), m_hrSuccess));
            }

            PostThreadMessage (m_dwThread, WM_QUIT, 0, 0);
        }
    }

    return WBEM_S_NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory implementation for rsop context menu                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRSOPCMenuCF::CRSOPCMenuCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CRSOPCMenuCF::~CRSOPCMenuCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CRSOPCMenuCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CRSOPCMenuCF::Release()
{
    m_cRef = InterlockedDecrement(&m_cRef);

    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CRSOPCMenuCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CRSOPCMenuCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CRSOPCMenu *pRsopCMenu = new CRSOPCMenu(); // ref count == 1

    if (!pRsopCMenu)
        return E_OUTOFMEMORY;

    HRESULT hr = pRsopCMenu->QueryInterface(riid, ppvObj);
    pRsopCMenu->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CRSOPCMenuCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPCMenu implementation for rsop context menu                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRSOPCMenu::CRSOPCMenu()
{
    m_cRef = 1;
    m_lpDSObject = NULL;
    m_szDN = NULL;
    m_szDomain = NULL;
    InterlockedIncrement(&g_cRefThisDll);
}

CRSOPCMenu::~CRSOPCMenu()
{
    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu:: Context menu destroyed")));
    InterlockedDecrement(&g_cRefThisDll);

    if (m_lpDSObject)
        LocalFree(m_lpDSObject);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPCMenu implementation (IUnknown)                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRSOPCMenu::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CRSOPCMenu::Release()
{
    m_cRef = InterlockedDecrement(&m_cRef);

    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CRSOPCMenu::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPCLASSFACTORY)this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPCMenu implementation (IExtendContextMenu)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP        
CRSOPCMenu::AddMenuItems(LPDATAOBJECT piDataObject,
                         LPCONTEXTMENUCALLBACK piCallback,
                         long * pInsertionAllowed)
{
    FORMATETC       fm;
    STGMEDIUM       medium;
    LPDSOBJECTNAMES lpNames;
    CONTEXTMENUITEM ctxMenu;
    HRESULT         hr=S_OK;
    LPTSTR          lpTemp;
    HANDLE          hTokenUser = 0;
    BOOL            bPlAccessGranted = FALSE, bLoAccessGranted = FALSE;
    BOOL            bLoNeeded = TRUE;


    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: Entering")));

    
    // if we are not allowed in the tasks menu quit
    if (!((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TASK )) {
        return S_OK;
    }

    
    //
    // Ask DS admin for the ldap path to the selected object
    //

    ZeroMemory (&fm, sizeof(fm));
    fm.cfFormat = (WORD)m_cfDSObjectName;
    fm.tymed = TYMED_HGLOBAL;

    ZeroMemory (&medium, sizeof(medium));
    medium.tymed = TYMED_HGLOBAL;

    medium.hGlobal = GlobalAlloc (GMEM_MOVEABLE | GMEM_NODISCARD, 512);

    if (medium.hGlobal)
    {
        hr = piDataObject->GetData(&fm, &medium);

        if (SUCCEEDED(hr))
        {
            lpNames = (LPDSOBJECTNAMES) GlobalLock (medium.hGlobal);

            if (lpNames) {
                lpTemp = (LPWSTR) (((LPBYTE)lpNames) + lpNames->aObjects[0].offsetName);

                if (m_lpDSObject)
                {
                    LocalFree (m_lpDSObject);
                }

                m_lpDSObject = (LPTSTR) LocalAlloc (LPTR, (lstrlen (lpTemp) + 1) * sizeof(TCHAR));

                if (m_lpDSObject)
                {
                    lstrcpy (m_lpDSObject, lpTemp);
                    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: LDAP path from DS Admin %s"), m_lpDSObject));
                }
                else {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
                
                m_rsopHint = RSOPHintUnknown;

                if (lpNames->aObjects[0].offsetClass) {
                    lpTemp = (LPWSTR) (((LPBYTE)lpNames) + lpNames->aObjects[0].offsetClass);

                    if (lstrcmpi (lpTemp, TEXT("domainDNS")) == 0)
                    {
                        m_rsopHint = RSOPHintDomain;
                    }
                    else if (lstrcmpi (lpTemp, TEXT("organizationalUnit")) == 0)
                    {
                        m_rsopHint = RSOPHintOrganizationalUnit;
                    }
                    else if (lstrcmpi (lpTemp, TEXT("site")) == 0)
                    {
                        m_rsopHint = RSOPHintSite;
                    }
                    else if (lstrcmpi (lpTemp, TEXT("user")) == 0)
                    {
                        m_rsopHint = RSOPHintUser;
                    }
                    else if (lstrcmpi (lpTemp, TEXT("computer")) == 0)
                    {
                        m_rsopHint = RSOPHintMachine;
                    }

                    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: m_rsopHint = %d"), m_rsopHint));
                } else {
                    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: No objectclass defined.")));
                }

                GlobalUnlock (medium.hGlobal);

            }
            else {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        GlobalFree(medium.hGlobal);
    }
    else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // if we got our data as expected add the menu
    //

    if (SUCCEEDED(hr)) {
        LPWSTR  szContainer = NULL;

        //
        // Now check whether the user has right to do rsop generation
        // if the container is anything other than the Site
        //

        if (m_szDomain) {
            LocalFree(m_szDomain);
            m_szDomain = NULL;
        }

        ParseDN(m_lpDSObject, &m_szDomain, &m_szDN, &szContainer);


        if ((m_rsopHint == RSOPHintMachine) || (m_rsopHint == RSOPHintUser)) 
            bLoNeeded = TRUE;
        else
            bLoNeeded = FALSE;


        if (m_rsopHint != RSOPHintSite) {
            if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY, TRUE, &hTokenUser)) {
                if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY, &hTokenUser)) {
                    DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::AddMenuItems: Couldn't get process token. Error %d"), GetLastError()));
                    bLoAccessGranted = bPlAccessGranted = FALSE;
                }
            }


            if (hTokenUser) {
                DWORD   dwErr;

                dwErr = CheckAccessForPolicyGeneration( hTokenUser, szContainer, m_szDomain, FALSE, &bPlAccessGranted);

                if (dwErr != ERROR_SUCCESS) {
                    DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::AddMenuItems: CheckAccessForPolicyGeneration. Error %d"), dwErr));
                    bPlAccessGranted = FALSE;
                }


                if (bLoNeeded) {                  
                    dwErr = CheckAccessForPolicyGeneration( hTokenUser, szContainer, m_szDomain, TRUE, &bLoAccessGranted);
                    
                    if (dwErr != ERROR_SUCCESS) {
                        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::AddMenuItems: CheckAccessForPolicyGeneration. Error %d"), dwErr));
                        bLoAccessGranted = FALSE;
                    }
                }

                CloseHandle(hTokenUser);
            }

        }
        else {
            bPlAccessGranted = TRUE;
        }


        if (bPlAccessGranted) {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: User has right to do Planning RSOP")));

            if ( ! IsPlanningModeAllowed() )
            {
                bPlAccessGranted = FALSE;
                DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: Planning mode is not available because planning mode view is not implemented on non-server SKUs")));
            }
        }

        if (bLoAccessGranted) {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: User has right to do Logging RSOP")));
        }



        //
        // Add the Context menu appropriately
        //
        
        WCHAR szMenuName[150];

        memset(&ctxMenu, 0, sizeof(ctxMenu));

        LoadString (g_hInstance, IDS_RSOP_PLANNING, szMenuName, ARRAYSIZE(szMenuName));
        ctxMenu.strName = szMenuName;
        ctxMenu.strStatusBarText = NULL;
        ctxMenu.lCommandID = RSOP_LAUNCH_PLANNING;  // no sp. flags
        ctxMenu.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
        
        if (bPlAccessGranted)
            ctxMenu.fFlags = MF_ENABLED;
        else
            ctxMenu.fFlags = MF_GRAYED | MF_DISABLED;

        hr = piCallback->AddItem(&ctxMenu);

        if (bLoNeeded) {
            LoadString (g_hInstance, IDS_RSOP_LOGGING, szMenuName, ARRAYSIZE(szMenuName));
            ctxMenu.strName = szMenuName;
            ctxMenu.strStatusBarText = NULL;
            ctxMenu.lCommandID = RSOP_LAUNCH_LOGGING;  // no sp. flags
            ctxMenu.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
                 
            if (bLoAccessGranted)
                ctxMenu.fFlags = MF_ENABLED;
            else
                ctxMenu.fFlags = MF_GRAYED | MF_DISABLED;

            hr = piCallback->AddItem(&ctxMenu);
        }
    }
                

    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: Leaving hr = 0x%x"), hr));
    return hr;

}


STDMETHODIMP        
CRSOPCMenu::Command(long lCommandID, LPDATAOBJECT piDataObject)
{
    DWORD   dwSize = 0;
    LPTSTR lpArgs=NULL, lpEnd=NULL;
    SHELLEXECUTEINFO ExecInfo;
    LPTSTR  szUserName=NULL, szMachName=NULL;
    

    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::Command: lCommandID = %d"), lCommandID));

    //
    // Launch rsop.msc with the appropriate cmd line arguments
    //

    dwSize += lstrlen(RSOP_MODE) + 10;


    if (m_rsopHint == RSOPHintSite) {
        dwSize += lstrlen(RSOP_SITENAME) + lstrlen(m_szDN)+10;
    }

    if (m_rsopHint == RSOPHintDomain) {
        dwSize += lstrlen(RSOP_COMP_OU_PREF) + lstrlen(m_szDN)+10;
        dwSize += lstrlen(RSOP_USER_OU_PREF) + lstrlen(m_szDN)+10;
    }

    if (m_rsopHint == RSOPHintOrganizationalUnit) {
        dwSize += lstrlen(RSOP_COMP_OU_PREF) + lstrlen(m_szDN)+10;
        dwSize += lstrlen(RSOP_USER_OU_PREF) + lstrlen(m_szDN)+10;
    }

    if (m_rsopHint == RSOPHintMachine) {
        szMachName = MyTranslateName(m_szDN, NameFullyQualifiedDN, NameSamCompatible);

        if (!szMachName) {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: MyTranslateName failed with error %d"), GetLastError()));
//            ReportError(NULL, GetLastError(), IDS_SPAWNRSOPFAILED);
            goto Exit;
        }
        dwSize += lstrlen(RSOP_COMP_NAME) + lstrlen(szMachName)+10;
    }

    if (m_rsopHint == RSOPHintUser) {
        szUserName = MyTranslateName(m_szDN, NameFullyQualifiedDN, NameSamCompatible);

        if (!szUserName) {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: MyTranslateName failed with error %d"), GetLastError()));
//            ReportError(NULL, GetLastError(), IDS_SPAWNRSOPFAILED);
            goto Exit;
        }
        
        dwSize += lstrlen(RSOP_USER_NAME) + lstrlen(szUserName)+10;
    }

    if (m_szDomain) {
        dwSize += lstrlen(RSOP_DCNAME_PREF) + lstrlen(m_szDomain)+10;
    }

    lpArgs = (LPTSTR) LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

    if (!lpArgs)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Failed to allocate memory with %d"),
                 GetLastError()));
//            ReportError(NULL, GetLastError(), IDS_SPAWNRSOPFAILED);
        goto Exit;
    }


    wsprintf (lpArgs, TEXT("/s "));
    lpEnd = lpArgs + lstrlen(lpArgs);


    //
    // Build the command line arguments
    //

    wsprintf(lpEnd, L"%s\"%d\" ", RSOP_MODE, (lCommandID == RSOP_LAUNCH_PLANNING) ? 1 : 0);
    lpEnd = lpArgs + lstrlen(lpArgs);


    if (m_rsopHint == RSOPHintSite) {
        wsprintf(lpEnd, L"%s\"%s\" ", RSOP_SITENAME, m_szDN);
        lpEnd = lpArgs + lstrlen(lpArgs);
    }

    if (m_rsopHint == RSOPHintDomain) {
        wsprintf(lpEnd, L"%s\"%s\" ", RSOP_COMP_OU_PREF, m_szDN);
        lpEnd = lpArgs + lstrlen(lpArgs);
    
        wsprintf(lpEnd, L"%s\"%s\" ", RSOP_USER_OU_PREF, m_szDN);
        lpEnd = lpArgs + lstrlen(lpArgs);
    }

    if (m_rsopHint == RSOPHintOrganizationalUnit) {
        wsprintf(lpEnd, L"%s\"%s\" ", RSOP_COMP_OU_PREF, m_szDN);
        lpEnd = lpArgs + lstrlen(lpArgs);
    
        wsprintf(lpEnd, L"%s\"%s\" ", RSOP_USER_OU_PREF, m_szDN);
        lpEnd = lpArgs + lstrlen(lpArgs);
    }

    if (m_rsopHint == RSOPHintMachine) {
        wsprintf(lpEnd, L"%s\"%s\" ", RSOP_COMP_NAME, szMachName);
        lpEnd = lpArgs + lstrlen(lpArgs);
    }

    if (m_rsopHint == RSOPHintUser) {
        wsprintf(lpEnd, L"%s\"%s\" ", RSOP_USER_NAME, szUserName);
        lpEnd = lpArgs + lstrlen(lpArgs);
    }

    if (m_szDomain) {
        wsprintf(lpEnd, L"%s\"%s\" ", RSOP_DCNAME_PREF, m_szDomain);
        lpEnd = lpArgs + lstrlen(lpArgs);
    }

    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::Command: Starting GPE with %s"), lpArgs));


    ZeroMemory (&ExecInfo, sizeof(ExecInfo));
    ExecInfo.cbSize = sizeof(ExecInfo);
    ExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    ExecInfo.lpVerb = TEXT("open");
    ExecInfo.lpFile = TEXT("rsop.msc");
    ExecInfo.lpParameters = lpArgs;
    ExecInfo.nShow = SW_SHOWNORMAL;


    if (ShellExecuteEx (&ExecInfo))
    {
        DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::Command: Launched rsop tool")));

        SetWaitCursor();
        WaitForInputIdle (ExecInfo.hProcess, 10000);
        ClearWaitCursor();
        CloseHandle (ExecInfo.hProcess);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: ShellExecuteEx failed with %d"),
                 GetLastError()));
//        ReportError(NULL, GetLastError(), IDS_SPAWNRSOPFAILED);
        goto Exit;
    }

Exit:
    if (szUserName) {
        LocalFree(szUserName);
    }
    
    if (szMachName) {
        LocalFree(szMachName);
    }

    if (lpArgs) {
        LocalFree (lpArgs);
    }
    
    return S_OK;
}

BOOL
EnableWMIFilters( LPWSTR szGPOPath )
{
    BOOL bReturn = FALSE;
    LPWSTR szDomain = szGPOPath;
    IWbemLocator* pLocator = 0;
    IWbemServices*  pServices = 0;
    HRESULT hr;

    while ( szDomain )
    {
        if ( CompareString( LOCALE_USER_DEFAULT,
                            NORM_IGNORECASE,
                            szDomain,
                            3,
                            L"DC=",
                            3 ) == CSTR_EQUAL )
        {
            break;
        }
        szDomain++;
    }

    if ( !szDomain )
    {
        goto Exit;
    }


    hr = CoCreateInstance(  CLSID_WbemLocator,
                            0,
                            CLSCTX_INPROC_SERVER,
                            IID_IWbemLocator,
                            (void**) &pLocator );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    BSTR xbstrNamespace = SysAllocString( L"\\\\.\\root\\Policy" );
    if ( !xbstrNamespace )
    {
        goto Exit;
    }


    hr = pLocator->ConnectServer(   xbstrNamespace, // namespace
                                    0,              // user
                                    0,              // password
                                    0,              // locale
                                    0,              // security flags
                                    0,              // authority
                                    0,              // Wbem context
                                    &pServices );   // IWbemServices
    SysFreeString( xbstrNamespace );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    WCHAR szDomainCanonical[512];
    DWORD dwSize = 512;
    
    if ( !TranslateName(szDomain,
                         NameUnknown,
                         NameCanonical,
                         szDomainCanonical,
                         &dwSize ) )
    {
        goto Exit;
    }

    LPWSTR szTemp = wcsrchr( szDomainCanonical, L'/' );

    if ( szTemp )
    {
        *szTemp = 0;
    }

    WCHAR szBuffer[512];
    wsprintf( szBuffer, L"MSFT_SomFilterStatus.domain=\"%s\"", szDomainCanonical );

    BSTR bstrObjectPath = SysAllocString( szBuffer );
    if ( !bstrObjectPath )
    {
        goto Exit;
    }

    hr = CoSetProxyBlanket(pServices, 
                           RPC_C_AUTHN_WINNT, 
                           RPC_C_AUTHZ_DEFAULT, 
                           0, 
                           RPC_C_AUTHN_LEVEL_CONNECT, 
                           RPC_C_IMP_LEVEL_IMPERSONATE, 
                           0,
                           0);

    IWbemClassObject* xObject = 0;
    hr = pServices->GetObject(  bstrObjectPath,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xObject,
                                0 );
    SysFreeString( bstrObjectPath );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    VARIANT var;
    VariantInit(&var);

    hr = xObject->Get(L"SchemaAvailable", 0, &var, NULL, NULL);

    if((FAILED(hr)) || ( var.vt == VT_NULL ))
    {
        DebugMsg((DM_WARNING, TEXT("EnableWMIFilters: Get failed for SchemaAvailable with error 0x%x"), hr));
        goto Exit;
    }

    if (var.boolVal == VARIANT_FALSE )
    {
        VariantClear(&var);
        goto Exit;
    }

    VariantClear(&var);
    DebugMsg((DM_VERBOSE, TEXT("Schema is available for wmi filters")));
    bReturn = TRUE;

Exit:
    if ( pLocator )
    {
        pLocator->Release();
    }
    if ( pServices )
    {
        pServices->Release();
    }

    return bReturn;
}


HRESULT CRSOPComponentData::SetupFonts()
{
	HRESULT hr;
	LOGFONT BigBoldLogFont;
	LOGFONT BoldLogFont;
    HDC pdc = NULL;
    WCHAR largeFontSizeString[128];
    INT		largeFontSize;
    WCHAR smallFontSizeString[128];
    INT		smallFontSize;

    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof (ncm);
    if (SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0) == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }


	BigBoldLogFont  = ncm.lfMessageFont;
	BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;


    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if ( !LoadString (g_hInstance, IDS_LARGEFONTNAME, BigBoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
		ASSERT (0);
        lstrcpy (BigBoldLogFont.lfFaceName, L"Verdana");
    }

    if ( LoadString (g_hInstance, IDS_LARGEFONTSIZE, largeFontSizeString, ARRAYSIZE(largeFontSizeString)) ) 
    {
        largeFontSize = wcstoul ((LPCWSTR) largeFontSizeString, NULL, 10);
    } 
    else 
    {
		ASSERT (0);
        largeFontSize = 12;
    }

    if ( !LoadString (g_hInstance, IDS_SMALLFONTNAME, BoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
		ASSERT (0);
        lstrcpy (BoldLogFont.lfFaceName, L"Verdana");
    }

    if ( LoadString (g_hInstance, IDS_SMALLFONTSIZE, smallFontSizeString, ARRAYSIZE(smallFontSizeString)) ) 
    {
        smallFontSize = wcstoul ((LPCWSTR) smallFontSizeString, NULL, 10);
    } 
    else 
    {
		ASSERT (0);
        smallFontSize = 8;
    }

	pdc = GetDC (NULL);

    if (pdc == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps (pdc, LOGPIXELSY) * largeFontSize / 72);
    BoldLogFont.lfHeight = 0 - (GetDeviceCaps (pdc, LOGPIXELSY) * smallFontSize / 72);

    m_BigBoldFont = CreateFontIndirect (&BigBoldLogFont);
    if (m_BigBoldFont == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
	m_BoldFont = CreateFontIndirect (&BoldLogFont);
    if (m_BoldFont == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

	hr = S_OK;

end:
    if (pdc != NULL) {
        ReleaseDC (NULL, pdc);
        pdc = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\rsopsnap.h ===
//
// SnapIn class
//

class CRSOPSnapIn:
    public IComponent,
    public IExtendContextMenu
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CRSOPComponentData  *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    LPDISPLAYHELP        m_pDisplayHelp; // IDisplayHelp interface
    WCHAR                m_column1[40];  // Text for column 1
    INT                  m_nColumnSize;  // Size of column 1
    LONG                 m_lViewMode;    // View mode
    BOOL                 m_bExpand;      // Expand root nodes

public:
    CRSOPSnapIn(CRSOPComponentData *pComponent);
    ~CRSOPSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);

    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\rsoputil.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.h
//
//  Contents:   helper functions for working with the RSOP database
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData);
HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, SAFEARRAY * psa);
HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT uiData);
HRESULT SetParameterToNull(IWbemClassObject * pInst, TCHAR * szParam);

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//              (Note that BSTR is a special case since the compiler can't
//              distinguish it from a TCHAR * but it's semantics are
//              different.)
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData);
HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData);
HRESULT GetParameterBytes(IWbemClassObject * pInst, TCHAR * szParam, LPBYTE * lpData, DWORD *dwDataSize);


HRESULT WbemTimeToSystemTime(XBStr& xbstrWbemTime, SYSTEMTIME& sysTime);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\smartptr.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        smartptr.h
//
// Contents:    Classes for smart pointers
//
// History:     24-Oct-98       SitaramR    Created
//
//---------------------------------------------------------------------------

#pragma once

template<class CItem> class XPtrST
{
public:
    XPtrST(CItem* p = 0) : _p( p )
    {
    }

    ~XPtrST() { delete _p; }

    BOOL IsNull() const { return ( 0 == _p ); }

    void Set ( CItem* p )
    {
        _p = p;
    }

    CItem * Acquire()
    {
        CItem * pTemp = _p;
        _p = 0;
        return pTemp;
    }

    CItem & GetReference() const
    {
        return *_p;
    }

    CItem * GetPointer() const { return _p ; }

    void Free() { delete Acquire(); }

private:
    XPtrST (const XPtrST<CItem> & x);
    XPtrST<CItem> & operator=( const XPtrST<CItem> & x);

    CItem * _p;
};


//*************************************************************
//
//  Class:      XBStr
//
//  Purpose:    Smart pointer class for BSTRs
//
//*************************************************************

class XBStr
{

private:

    XBStr(const XBStr& x);
    XBStr& operator=(const XBStr& x);

    BSTR _p;

public:

    XBStr(WCHAR* p = 0) : _p(0)
    {
        if(p)
        {
            _p = SysAllocString(p);
        }
    }

    ~XBStr()
    {
        SysFreeString(_p);
    }

    operator BSTR(){ return _p; }

    void operator=(WCHAR* p)
    {
        SysFreeString(_p);
        _p = p ? SysAllocString(p) : NULL;
    }

    BSTR Acquire()
    {
        BSTR p = _p;
        _p = 0;
        return p;
    }

};

//*************************************************************
//
//  Class:      MyXPtrST
//
//  Purpose:    Smart pointer template to wrap pointers to a single type.
//
//*************************************************************

template<class T> class MyXPtrST
{

private:

    MyXPtrST (const MyXPtrST<T>& x);
    MyXPtrST<T>& operator=(const MyXPtrST<T>& x);

    T* _p;

public:

    MyXPtrST(T* p = NULL) : _p(p){}

    ~MyXPtrST(){ delete _p; }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            delete _p;
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\snapin.cpp ===
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CSnapIn::CSnapIn(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumnSize = 180;
    m_lViewMode = LVS_REPORT;
    m_bExpand = TRUE;

    LoadString(g_hInstance, IDS_NAME, m_column1, ARRAYSIZE(m_column1));
}

CSnapIn::~CSnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IComponent)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));

    return S_OK;
}

STDMETHODIMP CSnapIn::Destroy(MMC_COOKIE cookie)
{

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;


    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

        if (hbmp16x16)
        {
            hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

            if (hbmp32x32)
            {
                LPIMAGELIST pImageList = (LPIMAGELIST) arg;

                // Set the images
                pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                                  reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                                  0, RGB(255, 0, 255));

                DeleteObject(hbmp32x32);
            }

            DeleteObject(hbmp16x16);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPGPEDATAOBJECT pGPEDataObject;
            MMC_COOKIE cookie;
            INT i;
            LPCONSOLE2 lpConsole2;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IGPEDataObject, (LPVOID *)&pGPEDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pGPEDataObject->GetCookie(&cookie);

            pGPEDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumnSize);
            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < g_NameSpace[cookie].cResultItems; i++)
            {
                resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                resultItem.str = MMC_CALLBACK;
                resultItem.nImage = g_NameSpace[cookie].pResultItems[i].iImage;
                resultItem.lParam = (LPARAM) &g_NameSpace[cookie].pResultItems[i];
                m_pResult->InsertItem(&resultItem);
            }

            m_pResult->Sort(0, 0, -1);

            if (m_bExpand)
            {
                hr = m_pConsole->QueryInterface(IID_IConsole2,
                                reinterpret_cast<void**>(&lpConsole2));

                if (SUCCEEDED(hr))
                {
                    if (m_pcd->m_hRoot)
                    {
                        lpConsole2->Expand(m_pcd->m_hRoot, TRUE);
                    }

                    if (m_pcd->m_hMachine)
                    {
                        lpConsole2->Expand(m_pcd->m_hMachine, TRUE);
                    }

                    if (m_pcd->m_hUser)
                    {
                        lpConsole2->Expand(m_pcd->m_hUser, TRUE);
                    }

                    lpConsole2->Release();
                }

                m_bExpand = FALSE;
            }
        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumnSize);
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;

    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPRESULTITEM pItem;
            LPGPEDATAOBJECT pGPEDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IGPEDataObject, (LPVOID *)&pGPEDataObject);

            if (FAILED(hr))
                break;

            pGPEDataObject->GetType(&type);
            pGPEDataObject->GetCookie(&cookie);

            pGPEDataObject->Release();


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if (m_pcd->m_pGPO)
            {
                if ((type == CCT_RESULT) || ((type == CCT_SCOPE) && (cookie == 0)))
                {
                    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                    //
                    // If this is a result pane item, then change the default
                    // verb to Properties.
                    //

                    if (type == CCT_RESULT)
                        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
                }
            }
        }
        break;

    case MMCN_CONTEXTHELP:
        {

        if (m_pDisplayHelp)
        {
            LPOLESTR pszHelpTopic;
            LPGPEDATAOBJECT pGPEDataObject;
            MMC_COOKIE cookie;


            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IGPEDataObject, (LPVOID *)&pGPEDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pGPEDataObject->GetCookie(&cookie);

            pGPEDataObject->Release();     // release initial ref

            if (FAILED(hr))
                return S_OK;

            pszHelpTopic = (LPOLESTR) CoTaskMemAlloc (50 * sizeof(WCHAR));

            if (pszHelpTopic)
            {
                lstrcpy (pszHelpTopic, g_NameSpace[cookie].lpHelpTopic);
                m_pDisplayHelp->ShowTopic (pszHelpTopic);
            }
        }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    pResult->str = g_NameSpace[pResult->lParam].szDisplayName;
                }
                else
                {
                    pResult->str = L"";
                }
            }

            if (pResult->mask & RDI_IMAGE)
            {
                if (m_pcd->m_pGPO)
                    pResult->nImage = g_NameSpace[pResult->lParam].iIcon;
                else
                    pResult->nImage = 3;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)pResult->lParam;

                    if (lpResultItem->szDisplayName[0] == TEXT('\0'))
                    {
                        LoadString (g_hInstance, lpResultItem->iStringID,
                                    lpResultItem->szDisplayName,
                                    MAX_DISPLAYNAME_SIZE);
                    }

                    pResult->str = lpResultItem->szDisplayName;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPEDATAOBJECT pGPEDataObjectA, pGPEDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPODataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPEDataObject,
                                            (LPVOID *)&pGPEDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPEDataObject,
                                            (LPVOID *)&pGPEDataObjectB)))
    {
        pGPEDataObjectA->Release();
        return S_FALSE;
    }

    pGPEDataObjectA->GetCookie(&cookie1);
    pGPEDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPEDataObjectA->Release();
    pGPEDataObjectB->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IExtendContextMenu)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::AddMenuItems(LPDATAOBJECT piDataObject,
                                   LPCONTEXTMENUCALLBACK pCallback,
                                   LONG *pInsertionAllowed)
{
    return m_pcd->AddMenuItems (piDataObject, pCallback, pInsertionAllowed);
}

STDMETHODIMP CSnapIn::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{

    return m_pcd->Command (lCommandID, piDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\structs.h ===
//*************************************************************
//  File name: STRUCTS.H
//
//  Description:  Structures and function prototypes used in this project
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

//
// Max displayname for a namespace item
//

#define MAX_DISPLAYNAME_SIZE    100

typedef struct _RESULTITEM
{
    DWORD        dwID;
    DWORD        dwNameSpaceItem;
    INT          iStringID;
    INT          iImage;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
} RESULTITEM, *LPRESULTITEM;


typedef struct _NAMESPACEITEM
{
    DWORD        dwID;
    DWORD        dwParent;
    INT          iIcon;
    INT          iOpenIcon;
    INT          iStringID;
    INT          iStringDescID;
    INT          cChildren;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
    INT          cResultItems;
    LPRESULTITEM pResultItems;
    const GUID   *pNodeID;
    LPCTSTR      lpHelpTopic;
} NAMESPACEITEM, *LPNAMESPACEITEM;



//
// External function proto-types that we dynamicly link with
//

typedef BOOL (*PFNREFRESHPOLICY)(BOOL bMachine);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\util.h ===
//*************************************************************
//  File name: UTIL.H
//
//  Description: Header file for util.cpp
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

LPTSTR CheckSlash (LPTSTR lpDir);
BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);
UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
VOID LoadMessage (DWORD dwID, LPTSTR lpBuffer, DWORD dwSize);
BOOL ReportError (HWND hParent, DWORD dwError, UINT idMsg, ...);
void SetWaitCursor (void);
void ClearWaitCursor (void);
BOOL Delnode (LPTSTR lpDir);
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal);
HRESULT DSDelnode (LPTSTR lpDSPath);
UINT CreateSecureDirectory (LPTSTR lpDirectory);
HRESULT ConvertToDotStyle (LPOLESTR lpName, LPOLESTR *lpResult);
LPOLESTR GetDomainFromLDAPPath(LPOLESTR szIn);
LPOLESTR GetContainerFromLDAPPath(LPOLESTR szIn);

#define VALIDATE_INHERIT_DC     1
LPTSTR GetDCName (LPTSTR lpDomainName, LPTSTR lpInheritServer, HWND hParent, BOOL bAllowUI, DWORD dwFlags, ULONG ulRetFlags = 0);

LPTSTR MyGetUserName (EXTENDED_NAME_FORMAT  NameFormat);
void StringToGuid( TCHAR *szValue, GUID *pGuid );
void GuidToString( GUID *pGuid, TCHAR * szValue );
BOOL ValidateGuid( TCHAR *szValue );
INT CompareGuid( GUID *pGuid1, GUID *pGuid2 );
BOOL IsNullGUID (GUID *pguid);
BOOL SpawnGPE (LPTSTR lpGPO, GROUP_POLICY_HINT_TYPE gpHint, LPTSTR lpDC, HWND hParent);
LPTSTR MakeFullPath (LPTSTR lpDN, LPTSTR lpServer);
LPTSTR MakeNamelessPath (LPTSTR lpDN);
LPTSTR ExtractServerName (LPTSTR lpPath);
BOOL DoesPathContainAServerName (LPTSTR lpPath);
HRESULT OpenDSObject (LPTSTR lpPath, REFIID riid, void FAR * FAR * ppObject);
HRESULT CheckDSWriteAccess (LPUNKNOWN punk, LPTSTR lpProperty);
VOID FreeDCSelections (void);
LPTSTR GetFullGPOPath (LPTSTR lpGPO, HWND hParent);
DWORD GetDCHelper (LPTSTR lpDomainName, ULONG ulFlags, LPTSTR *lpDCName);
LPTSTR ConvertName (LPTSTR lpName);
LPTSTR CreateTempFile (void);
DWORD QueryForForestName (LPTSTR lpServerName, LPTSTR lpDomainName, ULONG ulFlags,  LPTSTR *lpForestFound);
void NameToPath(WCHAR * szPath, WCHAR *szName, UINT cch);
LPTSTR GetPathToForest(LPOLESTR szServer);
BOOL IsForest(LPOLESTR szLDAPPath);
BOOL IsStandaloneComputer (VOID);
BOOL GetNewGPODisplayName (LPTSTR lpDisplayName, DWORD dwDisplayNameSize);
BOOL GetWMIFilter (BOOL bBrowser, HWND hwndParent, BOOL bDSFormat,
                   LPTSTR *lpDisplayName, LPTSTR * lpFilter, BSTR bstrDomain );
LPTSTR GetWMIFilterDisplayName (HWND hParent, LPTSTR lpFilter, BOOL bDSFormat, BOOL bRetRsopFormat);
HRESULT SaveString(IStream *pStm, LPTSTR lpString);
HRESULT ReadString(IStream *pStm, LPTSTR *lpString);
BOOL GetSiteFriendlyName (LPWSTR szSitePath, LPWSTR *pszSiteName );


//
// Length in chars of string form of guid {44cffeec-79d0-11d2-a89d-00c04fbbcfa2}
//
#define GUID_LENGTH 38
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\snapin.h ===
//
// SnapIn class
//

class CSnapIn:
    public IComponent,
    public IExtendContextMenu
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CComponentData      *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    LPDISPLAYHELP        m_pDisplayHelp; // IDisplayHelp interface
    WCHAR                m_column1[40];  // Text for column 1
    INT                  m_nColumnSize;  // Size of column 1
    LONG                 m_lViewMode;    // View mode
    BOOL                 m_bExpand;      // Expand root nodes

public:
    CSnapIn(CComponentData *pComponent);
    ~CSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);

    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\util.cpp ===
#include "main.h"
#include <schemamanager.h>
#include "rsoputil.h"
#include <initguid.h>

typedef struct _GPOERRORINFO
{
    DWORD   dwError;
    LPTSTR  lpMsg;
} GPOERRORINFO, *LPGPOERRORINFO;

typedef struct _DCOPTION
{
    LPTSTR  lpDomainName;
    INT     iOption;
    struct _DCOPTION *pNext;
} DCOPTION, *LPDCOPTION;

LPDCOPTION g_DCInfo = NULL;

//
// Help ids
//

DWORD aErrorHelpIds[] =
{

    0, 0
};

DWORD aNoDCHelpIds[] =
{
    IDC_NODC_PDC,                 IDH_DC_PDC,
    IDC_NODC_INHERIT,             IDH_DC_INHERIT,
    IDC_NODC_ANYDC,               IDH_DC_ANYDC,

    0, 0
};

DEFINE_GUID(CLSID_WMIFilterManager,0xD86A8E9B,0xF53F,0x45AD,0x8C,0x49,0x0A,0x0A,0x52,0x30,0xDE,0x28);
DEFINE_GUID(IID_IWMIFilterManager,0x64DCCA00,0x14A6,0x473C,0x90,0x06,0x5A,0xB7,0x9D,0xC6,0x84,0x91);



//*************************************************************
//
//  SetWaitCursor()
//
//  Purpose:    Sets the wait cursor
//
//  Parameters: none
//
//
//  Return:     void
//
//*************************************************************
void SetWaitCursor (void)
{
    SetCursor (LoadCursor(NULL, IDC_WAIT));
}

//*************************************************************
//
//  ClearWaitCursor()
//
//  Purpose:    Resets the wait cursor
//
//  Parameters: none
//
//
//  Return:     void
//
//*************************************************************
void ClearWaitCursor (void)
{
    SetCursor (LoadCursor(NULL, IDC_ARROW));
}

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    LPTSTR lpEnd;
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }


    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            lstrcpy (lpEnd, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    TCHAR szDelKey[2 * MAX_PATH];


    lstrcpy (szDelKey, lpSubKey);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);

}

//*************************************************************
//
//  CreateNestedDirectory()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary.
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//
//*************************************************************

UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;

    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  Received a NULL pointer.")));
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  CreateDirectory failed for %s with %d."),
                            szDirectory, GetLastError()));
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateNestedDirectory:  Failed to create the directory with error %d."), GetLastError()));

    return 0;

}

VOID LoadMessage (DWORD dwID, LPTSTR lpBuffer, DWORD dwSize)
{
    HINSTANCE hInstActiveDS;
    HINSTANCE hInstWMI;


    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, dwID,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  lpBuffer, dwSize, NULL))
    {
        hInstActiveDS = LoadLibrary (TEXT("activeds.dll"));

        if (hInstActiveDS)
        {
            if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                          hInstActiveDS, dwID,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                          lpBuffer, dwSize, NULL))
            {
                hInstWMI = LoadLibrary (TEXT("wmiutils.dll"));

                if (hInstWMI)
                {

                    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                                  hInstWMI, dwID,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                  lpBuffer, dwSize, NULL))
                    {
                        DebugMsg((DM_WARNING, TEXT("LoadMessage: Failed to query error message text for %d due to error %d"),
                                 dwID, GetLastError()));
                        wsprintf (lpBuffer, TEXT("%d (0x%x)"), dwID, dwID);
                    }

                    FreeLibrary (hInstWMI);
                }
            }

            FreeLibrary (hInstActiveDS);
        }
    }
}

//*************************************************************
//
//  ErrorDlgProc()
//
//  Purpose:    Dialog box procedure for errors
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

INT_PTR CALLBACK ErrorDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szError[MAX_PATH];
            LPGPOERRORINFO lpEI = (LPGPOERRORINFO) lParam;
            HICON hIcon;

            hIcon = LoadIcon (NULL, IDI_WARNING);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDC_ERROR_ICON, STM_SETICON, (WPARAM)hIcon, 0);
            }

            SetDlgItemText (hDlg, IDC_ERRORTEXT, lpEI->lpMsg);

            szError[0] = TEXT('\0');
            if (lpEI->dwError)
            {
                LoadMessage (lpEI->dwError, szError, ARRAYSIZE(szError));
            }

            if (szError[0] == TEXT('\0'))
            {
                LoadString (g_hInstance, IDS_NONE, szError, ARRAYSIZE(szError));
            }

            SetDlgItemText (hDlg, IDC_DETAILSTEXT, szError);

            return TRUE;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCLOSE || LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aErrorHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aErrorHelpIds);
            return (TRUE);
    }

    return FALSE;
}

//*************************************************************
//
//  ReportError()
//
//  Purpose:    Displays an error message to the user
//
//  Parameters: hParent     -   Parent window handle
//              dwError     -   Error number
//              idMsg       -   Error message id
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL ReportError (HWND hParent, DWORD dwError, UINT idMsg, ...)
{
    GPOERRORINFO ei;
    TCHAR szMsg[MAX_PATH];
    TCHAR szErrorMsg[2*MAX_PATH+40];
    va_list marker;


    //
    // Load the error message
    //

    if (!LoadString (g_hInstance, idMsg, szMsg, MAX_PATH))
    {
        return FALSE;
    }


    //
    // Special case access denied errors with a custom message
    //

    if ((dwError == ERROR_ACCESS_DENIED) || (dwError == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)))
    {
        if ((idMsg != IDS_EXECFAILED_USER) && (idMsg != IDS_EXECFAILED_COMPUTER) &&
            (idMsg != IDS_EXECFAILED) && (idMsg != IDS_EXECFAILED_BOTH))
        {
            if (!LoadString (g_hInstance, IDS_ACCESSDENIED, szMsg, MAX_PATH))
            {
                return FALSE;
            }
        }
    }
    else if ( dwError == WBEM_E_INVALID_NAMESPACE )
    {
        if (!LoadString (g_hInstance, IDS_INVALID_NAMESPACE, szMsg, MAX_PATH))
        {
            return FALSE;
        }
    }

    //
    // Plug in the arguments
    //

    va_start(marker, idMsg);
    wvsprintf(szErrorMsg, szMsg, marker);
    va_end(marker);


    //
    // Display the message
    //

    ei.dwError = dwError;
    ei.lpMsg   = szErrorMsg;

    DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_ERROR), hParent,
                    ErrorDlgProc, (LPARAM) &ei);

    return TRUE;
}

//*************************************************************
//
//  Delnode_Recurse()
//
//  Purpose:    Recursive delete function for Delnode
//
//  Parameters: lpDir   -   Directory
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/10/95     ericflo    Created
//
//*************************************************************

BOOL Delnode_Recurse (LPTSTR lpDir)
{
    WIN32_FIND_DATA fd;
    HANDLE hFile;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Entering, lpDir = <%s>"), lpDir));


    //
    // Setup the current working dir
    //

    if (!SetCurrentDirectory (lpDir)) {
        DebugMsg((DM_WARNING, TEXT("Delnode_Recurse:  Failed to set current working directory.  Error = %d"), GetLastError()));
        return FALSE;
    }


    //
    // Find the first file
    //

    hFile = FindFirstFile(TEXT("*.*"), &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } else {
            DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: FindFirstFile failed.  Error = %d"),
                     GetLastError()));
            return FALSE;
        }
    }


    do {
        //
        //  Verbose output
        //

        DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: FindFile found:  <%s>"),
                 fd.cFileName));

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, TEXT("."))) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
            continue;
        }


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //

            if (!Delnode_Recurse(fd.cFileName)) {
                FindClose(hFile);
                return FALSE;
            }

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                fd.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes (fd.cFileName, fd.dwFileAttributes);
            }


            if (!RemoveDirectory (fd.cFileName)) {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Failed to delete directory <%s>.  Error = %d"),
                        fd.cFileName, GetLastError()));
            }

        } else {

            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                SetFileAttributes (fd.cFileName, FILE_ATTRIBUTE_NORMAL);
            }

            if (!DeleteFile (fd.cFileName)) {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Failed to delete <%s>.  Error = %d"),
                        fd.cFileName, GetLastError()));
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    //
    // Close the search handle
    //

    FindClose(hFile);


    //
    // Reset the working directory
    //

    if (!SetCurrentDirectory (TEXT(".."))) {
        DebugMsg((DM_WARNING, TEXT("Delnode_Recurse:  Failed to reset current working directory.  Error = %d"), GetLastError()));
        return FALSE;
    }


    //
    // Success.
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Leaving <%s>"), lpDir));

    return TRUE;
}


//*************************************************************
//
//  Delnode()
//
//  Purpose:    Recursive function that deletes files and
//              directories.
//
//  Parameters: lpDir   -   Directory
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/23/95     ericflo    Created
//
//*************************************************************

BOOL Delnode (LPTSTR lpDir)
{
    TCHAR szCurWorkingDir[MAX_PATH];

    if (GetCurrentDirectory(MAX_PATH, szCurWorkingDir)) {

        Delnode_Recurse (lpDir);

        SetCurrentDirectory (szCurWorkingDir);

        if (!RemoveDirectory (lpDir)) {
            DebugMsg((DM_VERBOSE, TEXT("Delnode: Failed to delete directory <%s>.  Error = %d"),
                    lpDir, GetLastError()));
            return FALSE;
        }


    } else {

        DebugMsg((DM_WARNING, TEXT("Delnode:  Failed to get current working directory.  Error = %d"), GetLastError()));
        return FALSE;
    }

    return TRUE;

}

/*******************************************************************

        NAME:           StringToNum

        SYNOPSIS:       Converts string value to numeric value

        NOTES:          Calls atoi() to do conversion, but first checks
                                for non-numeric characters

        EXIT:           Returns TRUE if successful, FALSE if invalid
                                (non-numeric) characters

********************************************************************/
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal)
{
        TCHAR *pTst = pszStr;

        if (!pszStr) return FALSE;

        // verify that all characters are numbers
        while (*pTst)
        {
            if (!(*pTst >= TEXT('0') && *pTst <= TEXT('9')))
            {
               if (*pTst != TEXT('-'))
                   return FALSE;
            }
            pTst = CharNext(pTst);
        }

        *pnVal = _ttoi(pszStr);

        return TRUE;
}

//*************************************************************
//
//  DSDelnodeRecurse()
//
//  Purpose:    Delnodes a tree in the DS
//
//  Parameters: pADsContainer - IADSContainer interface
//
//  Return:     S_OK if successful
//
//*************************************************************

HRESULT DSDelnodeRecurse (IADsContainer * pADsContainer)
{
    HRESULT hr;
    BSTR bstrRelativeName;
    BSTR bstrClassName;
    IEnumVARIANT *pVar = NULL;
    IADsContainer * pADsChild = NULL;
    IADs * pDSObject = NULL;
    IDispatch * pDispatch;
    VARIANT var;
    ULONG ulResult;



    //
    // Enumerate the children and delete them first
    //

    hr = ADsBuildEnumerator (pADsContainer, &pVar);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse: Failed to get enumerator with 0x%x"), hr));
        goto Exit;
    }


    while (TRUE)
    {

        VariantInit(&var);
        hr = ADsEnumerateNext(pVar, 1, &var, &ulResult);

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("DSDelnodeRecurse: Failed to enumerator with 0x%x"), hr));
            VariantClear (&var);
            break;
        }


        if (S_FALSE == hr)
        {
            VariantClear (&var);
            break;
        }


        //
        // If var.vt isn't VT_DISPATCH, we're finished.
        //

        if (var.vt != VT_DISPATCH)
        {
            VariantClear (&var);
            break;
        }


        //
        // We found something, get the IDispatch interface
        //

        pDispatch = var.pdispVal;

        if (!pDispatch)
        {
            VariantClear (&var);
            goto Exit;
        }


        //
        // Now query for the IADsContainer interface so we can recurse
        // if necessary.  Note it is ok if this fails because not
        // everything is a container.
        //

        hr = pDispatch->QueryInterface(IID_IADsContainer, (LPVOID *)&pADsChild);

        if (SUCCEEDED(hr)) {

            hr = DSDelnodeRecurse (pADsChild);

            if (FAILED(hr)) {
                goto Exit;
            }

            pADsChild->Release();
        }


        //
        // Now query for the IADs interface so we can get some
        // properties from this object
        //

        hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pDSObject);

        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: QI for IADs failed with 0x%x"), hr));
            VariantClear (&var);
            goto Exit;
        }


        //
        // Get the relative and class names
        //

        hr = pDSObject->get_Name (&bstrRelativeName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed get relative name with 0x%x"), hr));
            pDSObject->Release();
            VariantClear (&var);
            goto Exit;
        }

        hr = pDSObject->get_Class (&bstrClassName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed get class name with 0x%x"), hr));
            SysFreeString (bstrRelativeName);
            pDSObject->Release();
            VariantClear (&var);
            goto Exit;
        }


        pDSObject->Release();


        //
        // Delete the object
        //

        hr = pADsContainer->Delete (bstrClassName,
                                    bstrRelativeName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed to delete object with 0x%x"), hr));
            SysFreeString (bstrRelativeName);
            SysFreeString (bstrClassName);
            VariantClear (&var);
            goto Exit;
        }


        SysFreeString (bstrRelativeName);
        SysFreeString (bstrClassName);

        VariantClear (&var);
    }

Exit:

    if (pVar)
    {
        ADsFreeEnumerator (pVar);
    }

    return hr;
}

//*************************************************************
//
//  DSDelnodeRecurse()
//
//  Purpose:    Delnodes a tree in the DS
//
//  Parameters: lpDSPath  - Path of DS object to delete
//
//  Return:     S_OK if successful
//
//*************************************************************

HRESULT DSDelnode (LPTSTR lpDSPath)
{
    HRESULT hr;
    BSTR bstrParent = NULL;
    BSTR bstrRelativeName = NULL;
    BSTR bstrClassName = NULL;
    IADsContainer * pADsContainer = NULL;
    IADs * pDSObject = NULL;
    VARIANT var;
    ULONG ulResult;



    //
    // Enumerate the children and delete them first
    //

    hr = OpenDSObject(lpDSPath, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("DSDelnode: Failed to get gpo container interface with 0x%x"), hr));
        goto Exit;
    }


    hr = DSDelnodeRecurse (pADsContainer);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("DSDelnode: Failed to delete children with 0x%x"), hr));
        goto Exit;
    }


    pADsContainer->Release();
    pADsContainer = NULL;


    //
    // Bind to the object
    //

    hr = OpenDSObject (lpDSPath, IID_IADs, (void **)&pDSObject);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed bind to the object %s with 0x%x"),
                 lpDSPath, hr));
        goto Exit;
    }


    //
    // Get the parent's name
    //

    hr = pDSObject->get_Parent (&bstrParent);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed get parent's name with 0x%x"), hr));
        goto Exit;
    }


    //
    // Get this object's relative and class names
    //

    hr = pDSObject->get_Name (&bstrRelativeName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed get relative name with 0x%x"), hr));
        goto Exit;
    }


    hr = pDSObject->get_Class (&bstrClassName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed get class name with 0x%x"), hr));
        goto Exit;
    }


    pDSObject->Release();
    pDSObject = NULL;


    //
    // Bind to the parent object
    //

    hr = OpenDSObject(bstrParent, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("DSDelnode: Failed to get parent container interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Delete the object
    //

    hr = pADsContainer->Delete (bstrClassName,
                                bstrRelativeName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed to delete object with 0x%x"), hr));
        goto Exit;
    }



Exit:

    if (pADsContainer)
    {
        pADsContainer->Release();
    }

    if (pDSObject)
    {
        pDSObject->Release();
    }

    if (bstrParent)
    {
        SysFreeString (bstrParent);
    }

    if (bstrRelativeName)
    {
        SysFreeString (bstrRelativeName);
    }

    if (bstrClassName)
    {
        SysFreeString (bstrClassName);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   CreateGPOLink
//
//  Synopsis:   Creates a GPO link for a domain, site or OU
//
//  Arguments:  [lpGPO]         - LDAP path to the GPO
//              [lpContainer]   - LDAP path to the container object
//              [fHighPriority] - FALSE (default) - adds GPO to the bottom
//                                                  of the prioritized list
//                                TRUE - adds GPO to the top of the list
//
//  Returns:    S_OK on success
//
//  History:    5-08-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CreateGPOLink(LPOLESTR lpGPO, LPOLESTR lpContainer, BOOL fHighPriority)
{
    IADs * pADs = NULL;
    LPTSTR lpNamelessGPO;
    HRESULT hr;

    lpNamelessGPO = MakeNamelessPath (lpGPO);

    if (lpNamelessGPO)
    {
        hr = OpenDSObject(lpContainer, IID_IADs, (void **)&pADs);

        if (SUCCEEDED(hr))
        {
            VARIANT var;
            BSTR bstr = NULL;
            LPOLESTR szLink = new OLECHAR[1 + wcslen(lpNamelessGPO) + 3 + 1];
            if (szLink)
            {
                wcscpy(szLink, L"[");
                wcscat(szLink, lpNamelessGPO);
                wcscat(szLink, L";0]");

                VariantInit(&var);
                bstr = SysAllocString(GPM_LINK_PROPERTY);

                if (bstr)
                {
                    hr = pADs->Get(bstr, &var);

                    if (SUCCEEDED(hr))
                    {
                        LPOLESTR szTemp = new OLECHAR[wcslen(var.bstrVal) + wcslen(szLink) + 1];
                        if (szTemp)
                        {
                            if (fHighPriority)
                            {
                                // Highest priority is at the END of the list
                                wcscpy(szTemp, var.bstrVal);
                                wcscat(szTemp, szLink);
                            }
                            else
                            {
                                wcscpy(szTemp, szLink);
                                wcscat(szTemp, var.bstrVal);
                            }
                            delete [] szLink;
                            szLink = szTemp;
                        }
                        else
                        {
                            hr = ERROR_OUTOFMEMORY;
                            goto Cleanup;
                        }
                    }
                    else
                    {
                        if (hr != E_ADS_PROPERTY_NOT_FOUND)
                        {
                            goto Cleanup;
                        }
                    }
                }
                else
                {
                     hr = ERROR_OUTOFMEMORY;
                     goto Cleanup;
                }

                VariantClear(&var);

                VariantInit(&var);
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(szLink);

                if (var.bstrVal)
                {
                    hr = pADs->Put(bstr, var);

                    if (SUCCEEDED(hr))
                    {
                        hr = pADs->SetInfo();
                    }
                }
                else
                {
                     hr = ERROR_OUTOFMEMORY;
                }

Cleanup:
                VariantClear(&var);
                if (bstr)
                {
                    SysFreeString(bstr);
                 }
                delete [] szLink;
            }
            else
                hr = ERROR_OUTOFMEMORY;
            pADs->Release();
        }

        LocalFree (lpNamelessGPO);
    }
    else
    {
        hr = ERROR_OUTOFMEMORY;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteAllGPOLinks
//
//  Synopsis:   Deletes all GPO links for a domain, OU or site
//
//  Arguments:  [lpContainer] - LDAP to the container object
//
//  Returns:    S_OK on success
//
//  History:    5-08-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT DeleteAllGPOLinks(LPOLESTR lpContainer)
{
    IADs * pADs = NULL;

    HRESULT hr = OpenDSObject(lpContainer, IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hr))
    {
        VARIANT var;
        BSTR bstr;

        bstr = SysAllocString(GPM_LINK_PROPERTY);

        if (bstr)
        {
            VariantInit(&var);
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(L" ");

            if (var.bstrVal)
            {
                hr = pADs->Put(bstr, var);

                if (SUCCEEDED(hr))
                {
                    pADs->SetInfo();
                }
            }
            else
            {
                hr = ERROR_OUTOFMEMORY;
            }

            VariantClear(&var);
            SysFreeString(bstr);
        }
        else
        {
            hr = ERROR_OUTOFMEMORY;
        }

        pADs->Release();
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteGPOLink
//
//  Synopsis:   Deletes a GPO link from a domain, OU or site
//              (if there is one).
//
//  Arguments:  [lpGPO]       - LDAP to the GPO
//              [lpContainer] - LDAP to the container object
//
//  Returns:    S_OK - success
//
//  History:    5-08-1998   stevebl   Created
//
//  Notes:      If a GPO is linked more than once, this will remove
//              only the first link.
//
//              If a GPO is NOT linked with this object, then this
//              routine will still return S_OK.
//
//---------------------------------------------------------------------------

HRESULT DeleteGPOLink(LPOLESTR lpGPO, LPOLESTR lpContainer)
{
    IADs * pADs = NULL;

    HRESULT hr = OpenDSObject(lpContainer, IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hr))
    {
        VARIANT var;
        BSTR bstr;
        // Build the substring to look for.
        // This is the first part of the link, the link ends with ]
        LPOLESTR szLink = new OLECHAR[1 + wcslen(lpGPO) + 1];
        if (szLink)
        {
            wcscpy(szLink, L"[");
            wcscat(szLink, lpGPO);

            bstr = SysAllocString(GPM_LINK_PROPERTY);

            if (bstr)
            {
                VariantInit(&var);

                hr = pADs->Get(bstr, &var);

                if (SUCCEEDED(hr))
                {
                    // find the link and remove it
                    LPOLESTR sz = new OLECHAR[wcslen(var.bstrVal)+1];

                    if (sz)
                    {
                        wcscpy(sz, var.bstrVal);
                        OLECHAR * pch = wcsstr(sz, szLink);
                        if (pch)
                        {
                            OLECHAR * pchEnd = pch;

                            // look for the ']'
                            while (*pchEnd && (*pchEnd != L']'))
                                pchEnd++;

                            // skip it
                            if (*pchEnd)
                                pchEnd++;

                            // copy over the rest of the string
                            while (*pchEnd)
                                *pch++ = *pchEnd++;

                            *pch = L'\0';

                            VariantClear(&var);

                            VariantInit(&var);
                            var.vt = VT_BSTR;
                            if (wcslen(sz))
                            {
                                var.bstrVal = SysAllocString(sz);
                            }
                            else
                            {
                                // Put will gag if this is an empty string
                                // so we need to put a space here if we've
                                // deleted all the entries.
                                var.bstrVal = SysAllocString(L" ");
                            }

                            if (var.bstrVal)
                            {
                                // set the link property again

                                hr = pADs->Put(bstr, var);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pADs->SetInfo();
                                }
                            }
                            else
                            {
                                hr = ERROR_OUTOFMEMORY;
                            }
                        }

                        delete [] sz;

                    }
                    else
                    {
                        hr = ERROR_OUTOFMEMORY;
                    }
                }

                VariantClear(&var);
                SysFreeString(bstr);
            }
            else
            {
                hr = ERROR_OUTOFMEMORY;
            }
            delete [] szLink;
        }
        else
            hr = ERROR_OUTOFMEMORY;
        pADs->Release();
    }
    return hr;
}

//*************************************************************
//
//  CreateSecureDirectory()
//
//  Purpose:    Creates a secure directory that only domain admins
//              and the OS have read / write access.  Everyone else has
//              read access only.
//
//  Parameters: lpDirectory  -   Directory name
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/28/98     ericflo    Created
//
//*************************************************************

UINT CreateSecureDirectory (LPTSTR lpDirectory)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidAuthUsers = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    UINT uRet = 0;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the authenticated users sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_AUTHENTICATED_USER_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidAuthUsers)) {

         DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize world sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidAuthUsers)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));



    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidAuthUsers)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }



    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID *)&lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID *)&lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidAuthUsers)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID *)&lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Add the security descriptor to the sa structure
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Attempt to create the directory
    //

    uRet = CreateNestedDirectory(lpDirectory, &sa);
    if ( uRet ) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Created the directory <%s>"), lpDirectory));

    } else {

        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to created the directory <%s>"), lpDirectory));
    }



Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }


    if (psidAuthUsers) {
        FreeSid(psidAuthUsers);
    }


    if (pAcl) {
        GlobalFree (pAcl);
    }

    return uRet;
}

//*************************************************************
//
//  ConvertToDotStyle()
//
//  Purpose:    Converts an LDAP path to a DN path
//
//  Parameters: lpName   - LDAP name
//              lpResult - pointer to a buffer with the DN name
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HRESULT ConvertToDotStyle (LPOLESTR lpName, LPOLESTR *lpResult)
{
    LPTSTR lpNewName;
    LPTSTR lpSrc, lpDest;
    TCHAR lpProvider[] = TEXT("LDAP://");
    DWORD dwStrLen = lstrlen (lpProvider);


    lpNewName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpName) + 1) * sizeof(TCHAR));

    if (!lpNewName)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertToDotStyle: Failed to allocate memory with 0x%x"),
                 GetLastError()));
        return E_FAIL;
    }


    lpSrc = lpName;
    lpDest = lpNewName;
    LPTSTR lpStopChecking = (lstrlen(lpSrc) - 2) + lpSrc;

    //
    // Skip the LDAP:// if found
    //

    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                       lpProvider, dwStrLen, lpSrc, dwStrLen) == CSTR_EQUAL)
    {
        lpSrc += dwStrLen;
    }

    //
    // Parse through the name replacing all the XX= with .
    // Skip server name (if any)
    //

    BOOL fMightFindServer = TRUE;

    while (*lpSrc)
    {
        if (lpSrc < lpStopChecking)
        {
            if (*(lpSrc+2) == TEXT('='))
            {
                lpSrc += 3;
                // no need to look for a server name any more because we've found an XX= string
                fMightFindServer = FALSE;
            }
        }

        while (*lpSrc && (*lpSrc != TEXT(',')))
        {
            *lpDest++ = *lpSrc++;
            if (fMightFindServer && TEXT('/') == *(lpSrc-1))
            {
                // Found a server name
                // reset lpDest so the rest gets put in the front of the buffer (leaving off the server name)
                lpDest = lpNewName;
                break;
            }
        }
        fMightFindServer = FALSE; // don't check any more

        if (*lpSrc == TEXT(','))
        {
            *lpDest++ = TEXT('.');
            lpSrc++;
        }
    }

    *lpDest = 0;

    *lpResult = lpNewName;

    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetDomainFromLDAPPath
//
//  Synopsis:   returns a freshly allocated string containing the LDAP path
//              to the domain name contained with an arbitrary LDAP path.
//
//  Arguments:  [szIn] - LDAP path to the initial object
//
//  Returns:    NULL - if no domain could be found or if OOM
//
//  History:     5-06-1998   stevebl   Created
//              10-20-1998   stevebl   modified to preserve server names
//
//  Notes:      This routine works by repeatedly removing leaf elements from
//              the LDAP path until an element with the "DC=" prefix is
//              found, indicating that a domain name has been located.  If a
//              path is given that is not rooted in a domain (is that even
//              possible?) then NULL would be returned.
//
//              The caller must free this path using the standard c++ delete
//              operation. (I/E this isn't an exportable function.)
//
//---------------------------------------------------------------------------

LPOLESTR GetDomainFromLDAPPath(LPOLESTR szIn)
{
    LPOLESTR sz = NULL;
    IADsPathname * pADsPathname = NULL;
    HRESULT hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (SUCCEEDED(hr))
    {
        hr = pADsPathname->Set(szIn, ADS_SETTYPE_FULL);
        if (SUCCEEDED(hr))
        {
            BSTR bstr;
            BOOL fStop = FALSE;

            while (!fStop)
            {
                hr = pADsPathname->Retrieve(ADS_FORMAT_LEAF, &bstr);
                if (SUCCEEDED(hr))
                {

                    // keep peeling them off until we find something
                    // that is a domain name
                    fStop = (0 == _wcsnicmp(L"DC=", bstr, 3));
                    SysFreeString(bstr);
                }
                else
                {
                     DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve leaf with 0x%x."), hr));
                }

                if (!fStop)
                {
                    hr = pADsPathname->RemoveLeafElement();
                    if (FAILED(hr))
                    {
                        DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to remove leaf with 0x%x."), hr));
                        fStop = TRUE;
                    }
                }
            }

            hr = pADsPathname->Retrieve(ADS_FORMAT_X500, &bstr);
            if (SUCCEEDED(hr))
            {
                sz = new OLECHAR[wcslen(bstr)+1];
                if (sz)
                {
                    wcscpy(sz, bstr);
                }
                SysFreeString(bstr);
            }
            else
            {
                 DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve full path with 0x%x."), hr));
            }
        }
        else
        {
             DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to set pathname with 0x%x."), hr));
        }

        pADsPathname->Release();
    }
    else
    {
         DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to CoCreateInstance for IID_IADsPathname with 0x%x."), hr));
    }


    return sz;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetContainerFromLDAPPath
//
//  Synopsis:   returns a the container name from an LDAP path
//
//  Arguments:  [szIn] - LDAP path to the initial object
//
//  Returns:    NULL - if no domain could be found or if OOM
//
//  History:     3-17-2000   ericflo   Created
//
//              The caller must free this path using the standard c++ delete
//              operation. (I/E this isn't an exportable function.)
//
//---------------------------------------------------------------------------

LPOLESTR GetContainerFromLDAPPath(LPOLESTR szIn)
{
    LPOLESTR sz = NULL;
    IADsPathname * pADsPathname = NULL;
    HRESULT hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (SUCCEEDED(hr))
    {
        hr = pADsPathname->Set(szIn, ADS_SETTYPE_DN);

        if (SUCCEEDED(hr))
        {
            BSTR bstr;
            BOOL fStop = FALSE;

            hr = pADsPathname->Retrieve(ADS_FORMAT_LEAF, &bstr);
            if (SUCCEEDED(hr))
            {
                sz = new OLECHAR[wcslen(bstr)+1];
                if (sz)
                {
                    wcscpy(sz, (bstr+3));
                }
                SysFreeString(bstr);
            }
            else
            {
                 DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve leaf with 0x%x."), hr));
            }
        }
        else
        {
             DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to set pathname with 0x%x."), hr));
        }

        pADsPathname->Release();
    }
    else
    {
         DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to CoCreateInstance for IID_IADsPathname with 0x%x."), hr));
    }


    return sz;
}

//*************************************************************
//
//  DCDlgProc()
//
//  Purpose:    Dialog box procedure for DC selection
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

INT_PTR CALLBACK DCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szTitle[100];
            TCHAR szBuffer[350];
            LPDCSELINFO lpSelInfo = (LPDCSELINFO) lParam;
            HICON hIcon;


            if (lpSelInfo->bError)
            {
                hIcon = LoadIcon (NULL, IDI_ERROR);

                if (hIcon)
                {
                    SendDlgItemMessage (hDlg, IDC_NODC_ERROR, STM_SETICON, (WPARAM)hIcon, 0);
                }

                LoadString (g_hInstance, IDS_NODC_ERROR_TEXT, szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText (hDlg, IDC_NODC_TEXT, szBuffer);

                LoadString (g_hInstance, IDS_NODC_ERROR_TITLE, szTitle, ARRAYSIZE(szTitle));
                wsprintf (szBuffer, szTitle, lpSelInfo->lpDomainName);
                SetWindowText (hDlg, szBuffer);

            }
            else
            {
                LoadString (g_hInstance, IDS_NODC_OPTIONS_TEXT, szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText (hDlg, IDC_NODC_TEXT, szBuffer);

                LoadString (g_hInstance, IDS_NODC_OPTIONS_TITLE, szBuffer, ARRAYSIZE(szBuffer));
                SetWindowText (hDlg, szBuffer);
            }

            if (!lpSelInfo->bAllowInherit)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_NODC_INHERIT), FALSE);
            }

            if (lpSelInfo->iDefault == 2)
            {
                if (lpSelInfo->bAllowInherit)
                {
                    CheckDlgButton (hDlg, IDC_NODC_INHERIT, BST_CHECKED);
                }
                else
                {
                    CheckDlgButton (hDlg, IDC_NODC_PDC, BST_CHECKED);
                }
            }
            else if (lpSelInfo->iDefault == 3)
            {
                CheckDlgButton (hDlg, IDC_NODC_ANYDC, BST_CHECKED);
            }
            else
            {
                CheckDlgButton (hDlg, IDC_NODC_PDC, BST_CHECKED);
            }

            return TRUE;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (IsDlgButtonChecked (hDlg, IDC_NODC_PDC) == BST_CHECKED)
                {
                    EndDialog(hDlg, 1);
                }
                else if (IsDlgButtonChecked (hDlg, IDC_NODC_INHERIT) == BST_CHECKED)
                {
                    EndDialog(hDlg, 2);
                }
                else
                {
                    EndDialog(hDlg, 3);
                }

                return TRUE;
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, 0);
                return TRUE;
            }

            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aNoDCHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aNoDCHelpIds);
            return (TRUE);
    }

    return FALSE;
}

//*************************************************************
//
//  AddDCSelection()
//
//  Purpose:    Adds a DC selection to the array
//
//  Parameters: lpDomainName - Domain name
//              iOption     - Option
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddDCSelection (LPTSTR lpDomainName, INT iOption)
{
    LPDCOPTION lpTemp;
    UINT uiSize;


    //
    // Check to see if we already have an entry first
    //

    EnterCriticalSection(&g_DCCS);

    lpTemp = g_DCInfo;

    while (lpTemp)
    {
        if (!lstrcmpi(lpDomainName, lpTemp->lpDomainName))
        {
            lpTemp->iOption = iOption;
            LeaveCriticalSection(&g_DCCS);
            return TRUE;
        }

        lpTemp = lpTemp->pNext;
    }


    //
    // Add a new entry
    //

    uiSize = sizeof(DCOPTION);
    uiSize += ((lstrlen(lpDomainName) + 1) * sizeof(TCHAR));

    lpTemp = (LPDCOPTION) LocalAlloc (LPTR, uiSize);

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("AddDCSelection: Failed to allocate memory with %d"),
                 GetLastError()));
        LeaveCriticalSection(&g_DCCS);
        return FALSE;
    }

    lpTemp->lpDomainName = (LPTSTR)((LPBYTE) lpTemp + sizeof(DCOPTION));
    lstrcpy (lpTemp->lpDomainName, lpDomainName);
    lpTemp->iOption = iOption;


    if (g_DCInfo)
    {
        lpTemp->pNext = g_DCInfo;
        g_DCInfo = lpTemp;
    }
    else
    {
        g_DCInfo = lpTemp;
    }

    LeaveCriticalSection(&g_DCCS);

    return TRUE;
}

//*************************************************************
//
//  FreeDCSelections()
//
//  Purpose:    Frees the cached DC selections
//
//  Parameters: none
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

VOID FreeDCSelections (void)
{
    LPDCOPTION lpTemp, lpNext;

    EnterCriticalSection(&g_DCCS);

    lpTemp = g_DCInfo;

    while (lpTemp)
    {
        lpNext = lpTemp->pNext;

        LocalFree (lpTemp);

        lpTemp = lpNext;
    }

    g_DCInfo = NULL;

    LeaveCriticalSection(&g_DCCS);
}

//*************************************************************
//
//  CheckForCachedDCSelection()
//
//  Purpose:    Checks if the DC selection for this domain is in
//              the cache
//
//  Parameters: lpDomainName - Domain name
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

INT CheckForCachedDCSelection (LPTSTR lpDomainName)
{
    INT iResult = 0;
    LPDCOPTION lpTemp;


    EnterCriticalSection(&g_DCCS);

    lpTemp = g_DCInfo;

    while (lpTemp)
    {
        if (!lstrcmpi(lpDomainName, lpTemp->lpDomainName))
        {
            iResult = lpTemp->iOption;
            break;
        }

        lpTemp = lpTemp->pNext;
    }

    LeaveCriticalSection(&g_DCCS);

    return iResult;
}

//*************************************************************
//
//  ValidateInheritServer()
//
//  Purpose:    Tests if the given DC name is in the given domain
//
//  Parameters: lpDomainName  -- Domain name
//              lpDCName      -- Domain controller name
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//*************************************************************

DWORD ValidateInheritServer (LPTSTR lpDomainName, LPTSTR lpDCName)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic;
    DWORD dwResult;


    dwResult = DsRoleGetPrimaryDomainInformation (lpDCName, DsRolePrimaryDomainInfoBasic,
                                                 (LPBYTE *) &pBasic);

    if (dwResult == ERROR_SUCCESS) {

        if (lstrcmpi(lpDomainName, pBasic->DomainNameDns))
        {
            dwResult = ERROR_NO_SUCH_DOMAIN;

            DebugMsg((DM_VERBOSE, TEXT("ValidateInheritServer: DC %s is not part of domain %s, it is part of %s.  This server will not be used for inheritance."),
                     lpDCName, lpDomainName, pBasic->DomainNameDns));
        }

        DsRoleFreeMemory (pBasic);
    }

    return dwResult;
}

//*************************************************************
//
//  TestDC()
//
//  Purpose:    Tests if a DC is available
//
//  Parameters:
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//*************************************************************

DWORD TestDC (LPTSTR lpDCName)
{
    LPTSTR lpTest;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    BOOL bResult = FALSE;

    lpTest = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpDCName) + 25) * sizeof(TCHAR));

    if (!lpTest)
    {
        DebugMsg((DM_WARNING, TEXT("TestDC: Failed to allocate memory with %d"),
                  GetLastError()));
        return GetLastError();
    }

    lstrcpy (lpTest, TEXT("\\\\"));
    lstrcat (lpTest, lpDCName);
    lstrcat (lpTest, TEXT("\\sysvol\\*.*"));

    hFile = FindFirstFile (lpTest, &fd);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugMsg((DM_WARNING, TEXT("TestDC: Failed to access <%s> with %d"),
                 lpTest, GetLastError()));
        LocalFree (lpTest);
        return GetLastError();
    }

    FindClose (hFile);

    LocalFree (lpTest);

    return ERROR_SUCCESS;
}

//*************************************************************
//
//  QueryForForestName()
//
//  Purpose:    Queries for a domain controller name
//
//  Parameters:
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//*************************************************************

DWORD QueryForForestName (LPTSTR lpServerName, LPTSTR lpDomainName, ULONG ulFlags,  LPTSTR *lpForestFound)
    {
        PDOMAIN_CONTROLLER_INFO pDCI;
        DWORD  dwResult;
        LPTSTR lpTemp, lpEnd;


        //
        // Call for a DC name
        //

        dwResult = DsGetDcName (lpServerName, lpDomainName, NULL, NULL,
                                ulFlags,
                                &pDCI);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("QueryForForestName: Failed to query <%s> for a DC name with %d"),
                     lpDomainName, dwResult));
            return dwResult;
        }


        if (!(pDCI->Flags & DS_DS_FLAG))
        {
            DebugMsg((DM_WARNING, TEXT("QueryForForestName: %s doesn't have Active Directory support (downlevel domain)"),
                     lpDomainName));
            NetApiBufferFree(pDCI);
            return ERROR_DS_UNAVAILABLE;
        }

        lpTemp = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pDCI->DnsForestName) + 1) * sizeof(TCHAR));

        if (!lpTemp)
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("QueryForForestName: Failed to allocate memory for forest name with %d"),
                     dwResult));
            NetApiBufferFree(pDCI);
            return dwResult;
        }

        lstrcpy(lpTemp, pDCI->DnsForestName);

        NetApiBufferFree(pDCI);

        LocalFree(*lpForestFound);
        *lpForestFound = lpTemp;
        return ERROR_SUCCESS;
    }

//*************************************************************
//
//  QueryForDCName()
//
//  Purpose:    Queries for a domain controller name
//
//  Parameters:
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//*************************************************************

DWORD QueryForDCName (LPTSTR lpDomainName, ULONG ulFlags, LPTSTR *lpDCName)
{
    PDOMAIN_CONTROLLER_INFO pDCI;
    DWORD  dwResult;
    LPTSTR lpTemp, lpEnd;


    //
    // Call for a DC name
    //

    dwResult = DsGetDcName (NULL, lpDomainName, NULL, NULL,
                            ulFlags, &pDCI);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("QueryForDCName: Failed to query <%s> for a DC name with %d"),
                 lpDomainName, dwResult));
        return dwResult;
    }


    if (!(pDCI->Flags & DS_DS_FLAG))
    {
        DebugMsg((DM_WARNING, TEXT("QueryForDCName: %s doesn't not have Active Directory support (downlevel domain)"),
                 lpDomainName));
        return ERROR_DS_UNAVAILABLE;
    }


    //
    // Save the DC name
    //

    lpTemp = (LPTSTR) LocalAlloc (LPTR, (lstrlen (pDCI->DomainControllerName) + 1) * sizeof(TCHAR));

    if (!lpTemp)
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("QueryForDCName: Failed to allocate memory for DC name with %d"),
                 dwResult));
        NetApiBufferFree(pDCI);
        return dwResult;
    }

    lstrcpy (lpTemp, (pDCI->DomainControllerName + 2));


    //
    // Remove the trailing .
    //

    lpEnd = lpTemp + lstrlen(lpTemp) - 1;

    if (*lpEnd == TEXT('.'))
    {
        *lpEnd =  TEXT('\0');
    }

    *lpDCName = lpTemp;

    NetApiBufferFree(pDCI);

    return ERROR_SUCCESS;
}

//*************************************************************
//
//  GetDCHelper()
//
//  Purpose:    Queries for a domain controller based upon
//              the flags and then rediscovers if necessary
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

DWORD GetDCHelper (LPTSTR lpDomainName, ULONG ulFlags, LPTSTR *lpDCName)
{
    DWORD dwError;

    //
    // Query for a DC name
    //

    SetWaitCursor();

    ulFlags |= DS_DIRECTORY_SERVICE_PREFERRED;

    dwError = QueryForDCName (lpDomainName, ulFlags, lpDCName);

    if (dwError == ERROR_SUCCESS)
    {

        //
        // Test if the DC is available
        //

        dwError = TestDC (*lpDCName);

        if (dwError != ERROR_SUCCESS)
        {

            //
            // The DC isn't available.  Query for another one
            //

            LocalFree (*lpDCName);
            ulFlags |= DS_FORCE_REDISCOVERY;

            dwError = QueryForDCName (lpDomainName, ulFlags, lpDCName);

            if (dwError == ERROR_SUCCESS)
            {

                //
                // Test if this DC is available
                //

                dwError = TestDC (*lpDCName);

                if (dwError != ERROR_SUCCESS)
                {
                    LocalFree (*lpDCName);
                }
            }
        }
    }

    ClearWaitCursor();

    return dwError;
}

//*************************************************************
//
//  GetDCName()
//
//  Purpose:    Gets a domain controller name
//
//  Parameters: lpDomainName    - Domain name
//              lpInheritServer - Inheritable server name
//              hParent         - Parent window handle for prompt dialog
//              bAllowUI        - Displaying UI is ok
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Notes:      DC Option values in the registry
//
//              Not specified  0
//              PDC            1
//              Inherit        2
//              Any Writable   3
//
//              Rules for finding a DC:
//                                         Inherit
//              Preference     Policy      DC Avail        Result
//              ==========     ======      ========        ======
//              Undefined      Undefined                   1) PDC 2) Prompt
//              PDC            Undefined                   1) PDC 2) Prompt
//              Inherit        Undefined     Yes           Inhert
//              Inherit        Undefined     No            Any DC
//              Any            Undefined                   Any DC
//
//              n/a            PDC                         PDC only
//              n/a            Inherit       Yes           Inhert
//              n/a            Inherit       No            Any DC
//              n/a            Any                         Any DC
//
//
//*************************************************************

LPTSTR GetDCName (LPTSTR lpDomainName, LPTSTR lpInheritServer,
                  HWND hParent, BOOL bAllowUI, DWORD dwFlags, ULONG ulRetFlags)
{
    LPTSTR lpDCName;
    ULONG  ulFlags;
    DWORD  dwDCPref = 1;
    DWORD  dwDCPolicy = 0;
    HKEY   hKey;
    DWORD  dwSize, dwType, dwError;
    dwError = ERROR_SUCCESS;
    DCSELINFO SelInfo;
    INT iResult;

    ulFlags = ulRetFlags;

    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Entering for:  %s"), lpDomainName));
    DebugMsg((DM_VERBOSE, TEXT("GetDCName: lpInheritServer is:  %s"), lpInheritServer));


    if (-1 == CheckForCachedDCSelection (lpDomainName))
    {
        DebugMsg((DM_VERBOSE, TEXT("GetDCName: Known dead domain.  Exiting.")));
        return NULL;
    }

    //
    // Check for a user DC preference
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwDCPref);
        RegQueryValueEx (hKey, DCOPTION_VALUE, NULL, &dwType,
                         (LPBYTE) &dwDCPref, &dwSize);

        if (dwDCPref > 3)
        {
            dwDCPref = 1;
        }

        RegCloseKey (hKey);
    }


    //
    // Check for a user DC policy
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwDCPolicy);
        RegQueryValueEx (hKey, DCOPTION_VALUE, NULL, &dwType,
                         (LPBYTE) &dwDCPolicy, &dwSize);

        if (dwDCPolicy > 3)
        {
            dwDCPolicy = 1;
        }

        RegCloseKey (hKey);
    }

    DebugMsg((DM_VERBOSE, TEXT("GetDCName: User preference is:  %d"), dwDCPref));
    DebugMsg((DM_VERBOSE, TEXT("GetDCName: User policy is:      %d"), dwDCPolicy));


    //
    // Validate that the inherit DC name is part of the domain name
    //

    if (lpInheritServer && (dwFlags & VALIDATE_INHERIT_DC))
    {
        if (ValidateInheritServer (lpDomainName, lpInheritServer) != ERROR_SUCCESS)
        {
            lpInheritServer = NULL;
        }
    }



    //
    // Based upon the rules, try to get a DC name
    //

    if (dwDCPolicy == 0)
    {

        //
        // The user doesn't have a preference or they have
        // a preference of using the PDC
        //

        if ((dwDCPref == 0) || (dwDCPref == 1))
        {
            ulFlags = DS_PDC_REQUIRED | ulRetFlags;

            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                return lpDCName;
            }
        }

        //
        // The user has a preference of inheriting
        //

        else if (dwDCPref == 2)
        {
            if (lpInheritServer)
            {
                lpDCName = (LPTSTR) LocalAlloc (LPTR, (lstrlen (lpInheritServer) + 1) * sizeof(TCHAR));

                if (!lpDCName)
                {
                    DebugMsg((DM_WARNING, TEXT("GetDCName: Failed to allocate memory for DC name with %d"),
                             GetLastError()));
                    return NULL;
                }

                lstrcpy (lpDCName, lpInheritServer);

                dwError = TestDC (lpDCName);

                if (dwError == ERROR_SUCCESS)
                {
                    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                    return lpDCName;
                }

                LocalFree (lpDCName);
            }
            else
            {
                ulFlags = ulRetFlags;
                dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

                if (dwError == ERROR_SUCCESS)
                {
                    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                    return lpDCName;
                }
            }
        }

        //
        // The user has a preference of using any DC
        //

        else if (dwDCPref == 3)
        {
            ulFlags = ulRetFlags;
            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                return lpDCName;
            }
        }
    }
    else
    {
        //
        // Policy says to use PDC
        //

        if (dwDCPolicy == 1)
        {
            ulFlags = DS_PDC_REQUIRED | ulRetFlags;
            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                return lpDCName;
            }
        }

        //
        // Policy says to inherit
        //

        else if (dwDCPolicy == 2)
        {
            if (lpInheritServer)
            {
                lpDCName = (LPTSTR) LocalAlloc (LPTR, (lstrlen (lpInheritServer) + 1) * sizeof(TCHAR));

                if (!lpDCName)
                {
                    DebugMsg((DM_WARNING, TEXT("GetDCName: Failed to allocate memory for DC name with %d"),
                             GetLastError()));
                    return NULL;
                }

                lstrcpy (lpDCName, lpInheritServer);

                dwError = TestDC (lpDCName);

                if (dwError == ERROR_SUCCESS)
                {
                    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                    return lpDCName;
                }

                LocalFree (lpDCName);
            }
            else
            {
                ulFlags = ulRetFlags;
                dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

                if (dwError == ERROR_SUCCESS)
                {
                    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                    return lpDCName;
                }
            }

        }

        //
        // Policy says to use any DC
        //

        else if (dwDCPolicy == 3)
        {
            ulFlags = ulRetFlags;
            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                return lpDCName;
            }
        }
    }


    DebugMsg((DM_VERBOSE, TEXT("GetDCName: First attempt at DC name failed with %d"), dwError));


    //
    // The first attempt at getting a DC name failed
    //
    // In 2 cases, we will prompt the user for what to do and try again.
    //

    if (bAllowUI && (dwError != ERROR_DS_UNAVAILABLE) && (dwDCPolicy == 0) && ((dwDCPref == 0) || (dwDCPref == 1)))
    {

        iResult = CheckForCachedDCSelection (lpDomainName);

        if (iResult == 0)
        {
            //
            // Display the message
            //

            SelInfo.bError = TRUE;
            SelInfo.bAllowInherit = (lpInheritServer != NULL) ? TRUE : FALSE;
            SelInfo.iDefault = 1;
            SelInfo.lpDomainName = lpDomainName;

            iResult = (INT)DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_NODC), hParent,
                                      DCDlgProc, (LPARAM) &SelInfo);
        }


        //
        // Based upon the return value, try for another DC
        //

        if (iResult == 1)
        {
            ulFlags = DS_PDC_REQUIRED | ulRetFlags;

            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                AddDCSelection (lpDomainName, iResult);
                return lpDCName;
            }
            else
            {
                AddDCSelection (lpDomainName, -1);
            }
        }
        else if (iResult == 2)
        {
            lpDCName = (LPTSTR) LocalAlloc (LPTR, (lstrlen (lpInheritServer) + 1) * sizeof(TCHAR));

            if (!lpDCName)
            {
                DebugMsg((DM_WARNING, TEXT("GetDCName: Failed to allocate memory for DC name with %d"),
                         GetLastError()));
                return NULL;
            }

            lstrcpy (lpDCName, lpInheritServer);

            dwError = TestDC (lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                AddDCSelection (lpDomainName, iResult);
                return lpDCName;
            }
            else
            {
                AddDCSelection (lpDomainName, -1);
            }

            LocalFree (lpDCName);
        }
        else if (iResult == 3)
        {
            ulFlags = 0 | ulRetFlags;

            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                AddDCSelection (lpDomainName, iResult);
                return lpDCName;
            }
            else
            {
                AddDCSelection (lpDomainName, -1);
            }
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("GetDCName: User cancelled the dialog box")));
            return NULL;
        }
    }


    DebugMsg((DM_WARNING, TEXT("GetDCName: Failed to find a domain controller")));

    if (bAllowUI)
    {
        if (dwError == ERROR_DS_UNAVAILABLE)
        {
            ReportError(NULL, dwError, IDS_NODSDC, lpDomainName);
        }
        else
        {
            ReportError(NULL, dwError, IDS_NODC);
        }
    }

    SetLastError(dwError);

    return NULL;
}

//*************************************************************
//
//  MyGetUserName()
//
//  Purpose:    Gets the user name in the requested format
//
//  Parameters: NameFormat  - GetUserNameEx naming format
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetUserName (EXTENDED_NAME_FORMAT  NameFormat)
{
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;


    //
    // Allocate a buffer for the user name
    //

    ulUserNameSize = 75;

    if (NameFormat == NameFullyQualifiedDN) {
        ulUserNameSize = 200;
    }


    lpUserName = (LPTSTR) LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

    if (!lpUserName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Special case NameUnknown to just get the simple user logon name
    //

    if (NameFormat == NameUnknown)
    {
        if (!GetUserName (lpUserName, &ulUserNameSize))
        {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetUserName:  GetUserName failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
        }
        goto Exit;
    }


    //
    // Get the username in the requested format
    //

    if (!GetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {

        //
        // If the call failed due to insufficient memory, realloc
        // the buffer and try again.  Otherwise, exit now.
        //

        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER) {
            DebugMsg((DM_WARNING, TEXT("MyGetUserName:  GetUserNameEx failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        lpTemp = (LPTSTR) LocalReAlloc (lpUserName, (ulUserNameSize * sizeof(TCHAR)),
                                       LMEM_MOVEABLE);

        if (!lpTemp) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to realloc memory with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }


        lpUserName = lpTemp;

        if (!GetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetUserName:  GetUserNameEx failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        dwError = ERROR_SUCCESS;
    }


Exit:

    SetLastError(dwError);

    return lpUserName;
}

//*************************************************************
//
//  GuidToString, StringToGuid, ValidateGuid
//
//  Purpose:    Guid utility routines
//
//*************************************************************

void GuidToString( GUID *pGuid, TCHAR * szValue )
{
    wsprintf( szValue,
              TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
              pGuid->Data1,
              pGuid->Data2,
              pGuid->Data3,
              pGuid->Data4[0], pGuid->Data4[1],
              pGuid->Data4[2], pGuid->Data4[3],
              pGuid->Data4[4], pGuid->Data4[5],
              pGuid->Data4[6], pGuid->Data4[7] );
}


void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    WCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == L'{' )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = wcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

BOOL ValidateGuid( TCHAR *szValue )
{
    //
    // Check if szValue is of form {19e02dd6-79d2-11d2-a89d-00c04fbbcfa2}
    //

    if ( lstrlen(szValue) < GUID_LENGTH )
        return FALSE;

    if ( szValue[0] != TEXT('{')
         || szValue[9] != TEXT('-')
         || szValue[14] != TEXT('-')
         || szValue[19] != TEXT('-')
         || szValue[24] != TEXT('-')
         || szValue[37] != TEXT('}') )
    {
        return FALSE;
    }

    return TRUE;
}


INT CompareGuid( GUID * pGuid1, GUID * pGuid2 )
{
    INT i;

    if ( pGuid1->Data1 != pGuid2->Data1 )
        return ( pGuid1->Data1 < pGuid2->Data1 ? -1 : 1 );

    if ( pGuid1->Data2 != pGuid2->Data2 )
        return ( pGuid1->Data2 < pGuid2->Data2 ? -1 : 1 );

    if ( pGuid1->Data3 != pGuid2->Data3 )
        return ( pGuid1->Data3 < pGuid2->Data3 ? -1 : 1 );

    for ( i = 0; i < 8; i++ )
    {
        if ( pGuid1->Data4[i] != pGuid2->Data4[i] )
            return ( pGuid1->Data4[i] < pGuid2->Data4[i] ? -1 : 1 );
    }

    return 0;
}

BOOL IsNullGUID (GUID *pguid)
{

    return ( (pguid->Data1 == 0)    &&
             (pguid->Data2 == 0)    &&
             (pguid->Data3 == 0)    &&
             (pguid->Data4[0] == 0) &&
             (pguid->Data4[1] == 0) &&
             (pguid->Data4[2] == 0) &&
             (pguid->Data4[3] == 0) &&
             (pguid->Data4[4] == 0) &&
             (pguid->Data4[5] == 0) &&
             (pguid->Data4[6] == 0) &&
             (pguid->Data4[7] == 0) );
}

//*************************************************************
//
//  SpawnGPE()
//
//  Purpose:    Spawns GPE for a GPO
//
//  Parameters: lpGPO    - ADSI path to the GPO
//              gpHint   - GPO hint type
//              lpDC     - GPO DC name to use (or NULL)
//              hParent  - Parent window handle
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SpawnGPE (LPTSTR lpGPO, GROUP_POLICY_HINT_TYPE gpHint, LPTSTR lpDC, HWND hParent)
{
    LPTSTR lpArgs, lpFullPath, lpDomainName, lpGPODCName;
    UINT uiSize;
    SHELLEXECUTEINFO ExecInfo;
    LPOLESTR pszDomain;
    HRESULT hr;


    //
    // If a DC was given, we need to build a full path to the GPO on that DC.
    // If a DC was not given, then we need to query for a DC and then build a
    // full path.
    //

    if (lpDC)
    {
        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpGPO, lpDC);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("SpawnGPE:  Failed to build new DS object path")));
            return FALSE;
        }
    }
    else
    {
        //
        // Get the friendly domain name
        //

        pszDomain = GetDomainFromLDAPPath(lpGPO);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("SpawnGPE: Failed to get domain name")));
            return FALSE;
        }


        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpDomainName);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
            return FALSE;
        }


        //
        // Get the GPO DC for this domain
        //

        lpGPODCName = GetDCName (lpDomainName, lpDC, hParent, TRUE, VALIDATE_INHERIT_DC);

        if (!lpGPODCName)
        {
            DebugMsg((DM_WARNING, TEXT("SpawnGPE:  Failed to get DC name for %s"),
                     lpDomainName));
            LocalFree (lpDomainName);
            return FALSE;
        }

        LocalFree (lpDomainName);


        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpGPO, lpGPODCName);

        LocalFree (lpGPODCName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("SpawnGPE:  Failed to build new DS object path")));
            return FALSE;
        }
    }


    uiSize = lstrlen (lpFullPath) + 30;

    lpArgs = (LPTSTR) LocalAlloc (LPTR, uiSize * sizeof(TCHAR));

    if (!lpArgs)
    {
        DebugMsg((DM_WARNING, TEXT("SpawnGPE: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Build the command line arguments
    //

    wsprintf (lpArgs, TEXT("/s /gphint:%d /gpobject:\"%s\""), gpHint, lpFullPath);

    DebugMsg((DM_VERBOSE, TEXT("SpawnGPE: Starting GPE with %s"), lpArgs));


    ZeroMemory (&ExecInfo, sizeof(ExecInfo));
    ExecInfo.cbSize = sizeof(ExecInfo);
    ExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    ExecInfo.lpVerb = TEXT("open");
    ExecInfo.lpFile = TEXT("gpedit.msc");
    ExecInfo.lpParameters = lpArgs;
    ExecInfo.nShow = SW_SHOWNORMAL;


    if (ShellExecuteEx (&ExecInfo))
    {
        SetWaitCursor();
        WaitForInputIdle (ExecInfo.hProcess, 10000);
        ClearWaitCursor();
        CloseHandle (ExecInfo.hProcess);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("SpawnGPE: ShellExecuteEx failed with %d"),
                 GetLastError()));
        ReportError(NULL, ( (GetLastError() == -1) ? 0 : GetLastError()), IDS_SPAWNGPEFAILED);
        LocalFree (lpArgs);
        return FALSE;
    }


    LocalFree (lpArgs);
    LocalFree (lpFullPath);

    return TRUE;
}


//*************************************************************
//
//  MakeFullPath()
//
//  Purpose:    Builds a fully qualified ADSI path consisting
//              of server and DN name
//
//  Parameters: lpDN     - DN path,  must start with LDAP://
//              lpServer - Server name
//
//  Return:     lpFullPath if success
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MakeFullPath (LPTSTR lpDN, LPTSTR lpServer)
{
    IADsPathname * pADsPathname;
    LPTSTR lpFullPath;
    BSTR bstr;
    HRESULT hr;


    //
    // Make sure the incoming path is nameless first
    //

    hr = CoCreateInstance(CLSID_Pathname,
                  NULL,
                  CLSCTX_INPROC_SERVER,
                  IID_IADsPathname,
                  (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to create IAdsPathName object with = 0x%x"), hr));
        SetLastError(hr);
        return NULL;
    }


    hr = pADsPathname->Set(lpDN, ADS_SETTYPE_FULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to set <%s> in IAdsPathName object with = 0x%x"),
                 lpDN, hr));
        pADsPathname->Release();
        SetLastError(hr);
        return NULL;
    }


    hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);
    pADsPathname->Release();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to retrieve pathname with = 0x%x"), hr));
        SetLastError(hr);
        return NULL;
    }


    //
    // Allocate a new buffer for the named path including LDAP://
    //

    lpFullPath = (LPTSTR) LocalAlloc (LPTR, (7 + lstrlen(bstr) + 
                                            (lpServer ? lstrlen(lpServer) : 0) + 3) * sizeof(TCHAR));

    if (!lpFullPath)
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to allocate memory with = %d"), GetLastError()));
        SysFreeString (bstr);
        return NULL;
    }


    lstrcpy (lpFullPath, TEXT("LDAP://"));
    if (lpServer)
    {
        lstrcat (lpFullPath, lpServer);
        lstrcat (lpFullPath, TEXT("/"));
    }
    lstrcat (lpFullPath, (LPTSTR)(bstr + 7));

    SysFreeString (bstr);

    return lpFullPath;
}

//*************************************************************
//
//  MakeNamelessPath()
//
//  Purpose:    Builds a server nameless ADSI path
//
//  Parameters: lpDN     - DN path,  must start with LDAP://
//
//  Return:     lpPath if success
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MakeNamelessPath (LPTSTR lpDN)
{
    IADsPathname * pADsPathname;
    LPTSTR lpPath;
    BSTR bstr;
    HRESULT hr;


    //
    // Create a pathname object to work with
    //

    hr = CoCreateInstance(CLSID_Pathname,
                  NULL,
                  CLSCTX_INPROC_SERVER,
                  IID_IADsPathname,
                  (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to create IAdsPathName object with = 0x%x"), hr));
        return NULL;
    }


    hr = pADsPathname->Set(lpDN, ADS_SETTYPE_FULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to set <%s> in IAdsPathName object with = 0x%x"),
                 lpDN, hr));
        pADsPathname->Release();
        return NULL;
    }


    hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);
    pADsPathname->Release();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to retrieve pathname with = 0x%x"), hr));
        return NULL;
    }


    //
    // Allocate a new buffer for the path
    //

    lpPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(bstr) + 1) * sizeof(TCHAR));

    if (!lpPath)
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to allocate memory with = %d"), GetLastError()));
        SysFreeString (bstr);
        return NULL;
    }


    lstrcpy (lpPath, bstr);

    SysFreeString (bstr);

    return lpPath;
}

//*************************************************************
//
//  ExtractServerName()
//
//  Purpose:    Extracts the server name from a ADSI path
//
//  Parameters: lpPath - ADSI path, must start with LDAP://
//
//  Return:     lpServerName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ExtractServerName (LPTSTR lpPath)
{
    LPTSTR lpServerName = NULL;
    LPTSTR lpEnd, lpTemp;


    //
    // Check the path to see if it has a server name
    //

    if (*(lpPath + 9) != TEXT('='))
    {
        //
        // Allocate memory for the server name
        //

        lpServerName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpPath) + 1) * sizeof(TCHAR));

        if (!lpServerName)
        {
            DebugMsg((DM_WARNING, TEXT("ExtractServerName: Failed to allocate memory for name with 0xd"),
                     GetLastError()));
            return NULL;
        }

        lpTemp = (lpPath + 7);
        lpEnd = lpServerName;

        while (*lpTemp && (*lpTemp != TEXT('/')) && (*lpTemp != TEXT(',')))
        {
            *lpEnd = *lpTemp;
            lpEnd++;
            lpTemp++;
        }

        if (*lpTemp != TEXT('/'))
        {
            DebugMsg((DM_WARNING, TEXT("ExtractServerName: Failed to parse server name from ADSI path")));
            LocalFree (lpServerName);
            lpServerName = NULL;
        }
    }

    return lpServerName;
}

//*************************************************************
//
//  DoesPathContainAServerName()
//
//  Purpose:    Checks the given ADSI path to see if it
//              contains a server name
//
//  Parameters: lpPath - ADSI path
//
//  Return:     True if the path contains a server name
//              FALSE if not
//
//*************************************************************

BOOL DoesPathContainAServerName (LPTSTR lpPath)
{
    BOOL bResult = FALSE;


    //
    // Skip over LDAP:// if found
    //

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                        lpPath, 7, L"LDAP://", 7 ) == CSTR_EQUAL )
    {
        lpPath += 7;
    }


    //
    // Check if the 3rd character in the path is an equal sign.
    // If so, this path does not contain a server name
    //

    if ((lstrlen(lpPath) > 2) && (*(lpPath + 3) != TEXT('=')))
    {
        bResult = TRUE;
    }

    return bResult;
}

//*************************************************************
//
//  OpenDSObject()
//
//  Purpose:    Checks the given ADSI path to see if it
//              contains a server name
//
//  Parameters: lpPath - ADSI path
//
//  Return:     True if the path contains a server name
//              FALSE if not
//
//*************************************************************

HRESULT OpenDSObject (LPTSTR lpPath, REFIID riid, void FAR * FAR * ppObject)
{
    DWORD dwFlags = ADS_SECURE_AUTHENTICATION;


    if (DoesPathContainAServerName (lpPath))
    {
        dwFlags |= ADS_SERVER_BIND;
    }

    return (ADsOpenObject(lpPath, NULL, NULL, dwFlags,
                          riid, ppObject));
}

HRESULT CheckDSWriteAccess (LPUNKNOWN punk, LPTSTR lpProperty)
{
    HRESULT hr;
    IDirectoryObject *pDO = NULL;
    PADS_ATTR_INFO pAE = NULL;
    LPWSTR lpAttributeNames[2];
    DWORD dwResult, dwIndex;


    //
    // Get the IDirectoryObject interface
    //

    hr = punk->QueryInterface(IID_IDirectoryObject, (void**)&pDO);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CheckDSWriteAccess: Failed to get the IDirectoryObject interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Get the property value
    //

    lpAttributeNames[0] = L"allowedAttributesEffective";

    hr = pDO->GetObjectAttributes(lpAttributeNames, 1, &pAE, &dwResult);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CheckDSWriteAccess: Failed to get object attributes with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the default return value
    //

    hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);


    //
    // Go through the list of effective attributes
    //

    if (dwResult != 0) {
        for (dwIndex = 0; dwIndex < pAE[0].dwNumValues; dwIndex++)
        {
            if (lstrcmpi(pAE[0].pADsValues[dwIndex].CaseIgnoreString,
                         lpProperty) == 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_SUCCESS);
            }
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("CheckDSWriteAccess: Couldn't get allowedAttributesEffective")));
    }

Exit:

    if (pAE)
    {
        FreeADsMem (pAE);
    }

    if (pDO)
    {
        pDO->Release();
    }

    return hr;
}

LPTSTR GetFullGPOPath (LPTSTR lpGPO, HWND hParent)
{
    LPTSTR lpFullPath = NULL, lpDomainName = NULL;
    LPTSTR lpGPODCName;
    LPOLESTR pszDomain;
    HRESULT hr;



    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(lpGPO);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("GetFullGPOPath: Failed to get domain name")));
        return NULL;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
        return NULL;
    }

    //
    // Get the GPO DC for this domain
    //

    lpGPODCName = GetDCName (lpDomainName, NULL, hParent, TRUE, 0);

    if (!lpGPODCName)
    {
        DebugMsg((DM_WARNING, TEXT("GetFullGPOPath:  Failed to get DC name for %s"),
                 lpDomainName));
        goto Exit;
    }


    //
    // Make the full path
    //

    lpFullPath = MakeFullPath (lpGPO, lpGPODCName);

    LocalFree (lpGPODCName);

    if (!lpFullPath)
    {
        DebugMsg((DM_WARNING, TEXT("GetFullGPOPath:  Failed to build new DS object path")));
        goto Exit;
    }


Exit:

    if (lpDomainName)
    {
        LocalFree (lpDomainName);
    }

    return lpFullPath;
}

//*************************************************************
//
//  ConvertName()
//
//  Purpose:    Converts the user / computer name from SAM style
//              to fully qualified DN
//
//  Parameters: lpName  -   name in sam style
//
//
//  Return:     lpDNName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ConvertName (LPTSTR lpName)
{
    LPTSTR lpDNName = NULL, lpSAMName = NULL;
    LPTSTR lpTemp, lpDCName = NULL;
    DWORD dwResult;
    HANDLE hDS = NULL;
    PDS_NAME_RESULT pNameResult = NULL;
    PDS_NAME_RESULT_ITEM pNameResultItem;


    //
    // Check the argument
    //

    if (!lpName)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: lpName is null")));
        SetLastError(ERROR_INVALID_DATA);
        goto Exit;
    }


    //
    // Make a copy of the name so we can edit it
    //

    lpSAMName = new TCHAR[(lstrlen(lpName) + 1)];

    if (!lpSAMName)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }

    lstrcpy (lpSAMName, lpName);


    //
    // Find the slash between the domain name and the account name and replace
    // it with a null
    //

    lpTemp = lpSAMName;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
    {
        lpTemp++;
    }

    if (!(*lpTemp))
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: Failed to find backslash in %s"), lpSAMName));
        SetLastError(ERROR_INVALID_DATA);
        goto Exit;
    }

    *lpTemp = TEXT('\0');


    //
    // Call DsGetDcName to convert the netbios name to a FQDN name
    //

    dwResult = GetDCHelper (lpSAMName, DS_IS_FLAT_NAME | DS_RETURN_DNS_NAME, &lpDCName);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: GetDCHelper failed with %d"), dwResult));
        SetLastError(dwResult);
        goto Exit;
    }


    //
    // Bind to the domain controller
    //

    dwResult = DsBind (lpDCName, NULL, &hDS);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: DsBind failed with %d"), dwResult));
        SetLastError(dwResult);
        goto Exit;
    }


    //
    // Use DsCrackNames to convert the name FQDN
    //

    dwResult = DsCrackNames (hDS, DS_NAME_NO_FLAGS, DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME,
                             1, &lpName, &pNameResult);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: DsCrackNames failed with %d"), dwResult));
        SetLastError(dwResult);
        goto Exit;
    }


    //
    // Setup a pointer to the first item
    //

    pNameResultItem = &pNameResult->rItems[0];

    if (pNameResultItem->status != DS_NAME_NO_ERROR)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: DsCrackNames failed to convert name with %d"), pNameResultItem->status));
        SetLastError(pNameResultItem->status);
        goto Exit;
    }


    //
    // Save the name in a new buffer so it can returned
    //

    lpDNName = new TCHAR[(lstrlen(pNameResultItem->pName) + 1)];

    if (!lpDNName)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }

    lstrcpy (lpDNName, pNameResultItem->pName);

Exit:

    if (pNameResult)
    {
        DsFreeNameResult (pNameResult);
    }

    if (hDS)
    {
        DsUnBind (&hDS);
    }

    if (lpDCName)
    {
        LocalFree (lpDCName);
    }

    if (lpSAMName)
    {
       delete [] lpSAMName;
    }

    return lpDNName;
}

//*************************************************************
//
//  CreateTempFile()
//
//  Purpose:    Creates a temp file
//
//  Parameters: void
//
//  Return:     filename if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR CreateTempFile (void)
{
    TCHAR szTempDir[MAX_PATH];
    TCHAR szTempFile[MAX_PATH];
    LPTSTR lpFileName;


    //
    // Query for the temp directory
    //

    if (!GetTempPath (MAX_PATH, szTempDir))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateTempFile: GetTempPath failed with %d"), GetLastError()));
        return NULL;
    }


    //
    // Query for a temp filename
    //

    if (!GetTempFileName (szTempDir, TEXT("RSP"), 0, szTempFile))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateTempFile: GetTempFile failed with %d"), GetLastError()));
        return NULL;
    }


    //
    // Allocate a new buffer for the filename
    //

    lpFileName = new TCHAR[(lstrlen(szTempFile) + 1)];

    if (!lpFileName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateTempFile: Failed to allocate memory for temp filename with %d"), GetLastError()));
        return NULL;
    }

    lstrcpy (lpFileName, szTempFile);

    return lpFileName;
}

//+--------------------------------------------------------------------------
//
//  Function:   NameToPath
//
//  Synopsis:   converts a dot-format domain name to an LDAP:// style path
//
//  Arguments:  [szPath]    - (out) buffer to hold the path
//              [szName]    - (in) dot-format domain name
//              [cch]       - (in) size of the out buffer
//
//  History:    10-15-1998   stevebl   Created
//
//  Note:       Currently, this routine will truncate if it doesn't get a
//              large enough buffer so you'd better be sure your
//              buffer's large enough.  (The formula is string size + 10 + 3
//              for each dot in the string.)
//
//              That's good enough to avoid an AV but could have some really
//              wierd side effects so beware.
//
//---------------------------------------------------------------------------

void NameToPath(WCHAR * szPath, WCHAR *szName, UINT cch)
{
    WCHAR * szOut = szPath;
    WCHAR * szIn = szName;
    wcscpy(szOut, TEXT("LDAP://DC="));
    szOut += 10;
    while ((*szIn) && (szOut + 1 < szPath + cch))
    {
        if (*szIn == TEXT('.') && (szOut + 4 < szPath + cch))
        {
            ++szIn;
            if (*szIn && *szIn != TEXT('.'))
            {
                *szOut = TEXT(',');
                ++szOut;
                *szOut = TEXT('D');
                ++szOut;
                *szOut = TEXT('C');
                ++szOut;
                *szOut = TEXT('=');
                ++szOut;
            }
        }
        else
        {
            *szOut = *szIn;
            ++szOut;
            ++szIn;
        }
    }
    *szOut = TEXT('\0');
}

//+--------------------------------------------------------------------------
//
//  Function:   GetPathToForest
//
//  Synopsis:   given a domain, return a pointer to its forest
//
//  Arguments:  [szServer] - DOT style path to a server (may be NULL)
//
//  Returns:    LDAP style path to the forest's Configuration container
//
//  History:    03-31-2000   stevebl   Created
//
//  Notes:      return value is allocated with new
//
//---------------------------------------------------------------------------

LPTSTR GetPathToForest(LPOLESTR szServer)
{
    LPOLESTR szReturn = NULL;
    LPOLESTR lpForest = NULL;
    LPOLESTR lpTemp = NULL;
    LPOLESTR lpDCName = NULL;
    IADsPathname * pADsPathname = NULL;
    BSTR bstrForest = NULL;
    HRESULT hr = 0;
    int cch, n;

    DWORD dwResult = QueryForForestName(szServer,
                                        NULL,
                                        DS_PDC_REQUIRED | DS_RETURN_DNS_NAME,
                                        &lpTemp);
    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: QueryForestName failed for domain name %s with %d"),
                  szServer, dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }

    cch = 0;
    n = 0;
    // count the dots in lpTemp;
    while (lpTemp[n])
    {
        if (L'.' == lpTemp[n])
        {
            cch++;
        }
        n++;
    }
    cch *= 3; // multiply the number of dots by 3;
    cch += 11; // add 10 + 1 (for the null)
    cch += n; // add the string size;
    lpForest = (LPTSTR) LocalAlloc(LPTR, sizeof(WCHAR) * cch);
    if (!lpForest)
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to allocate memory for forest name with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    NameToPath(lpForest, lpTemp, cch);
    LocalFree(lpTemp);
    lpTemp = NULL;

    // See if we need to put a specific server on this.
    //
    if (szServer)
    {
        // we have a path to a specific DC
        // need to prepend it to the forest name
        lpTemp = MakeFullPath(lpForest, szServer);

        if (!lpTemp)
        {
            DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to combine server name with Forest path")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        // clean up the variables we just borrowed so they can be used later
        LocalFree(lpForest);
        lpForest = lpTemp;
        lpTemp = NULL;
    }


    // at this point we have the path to the forest's DC in lpForest
    // we still need to add "CN=Configuration" to this

    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the domain name
    //

    hr = pADsPathname->Set (lpForest, ADS_SETTYPE_FULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }

    //
    // Add the Configuration folder to the path
    //

    hr = pADsPathname->AddLeafElement (TEXT("CN=Configuration"));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to add configuration folder with 0x%x"), hr));
        goto Exit;
    }

    //
    // Retreive the GPC path
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrForest);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetPathToForest: conatiner path is:  %s"), bstrForest));

    szReturn = new OLECHAR[SysStringLen(bstrForest)+1];
    lstrcpy(szReturn, bstrForest);

Exit:
    if (bstrForest)
    {
        SysFreeString(bstrForest);
    }

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    if (lpForest)
    {
        LocalFree(lpForest);
    }
    if (lpDCName)
    {
        LocalFree(lpDCName);
    }
    if (lpTemp)
    {
        LocalFree(lpTemp);
    }

    if (!szReturn)
    {
        SetLastError(hr);
    }

    return szReturn;
}

BOOL IsForest(LPOLESTR szLDAPPath)
{
#if FGPO_SUPPORT
    return ((StrStrI(szLDAPPath, TEXT("CN=Configuration"))) ? TRUE : FALSE);
#else
    return FALSE;
#endif
}

//*************************************************************
//
//  IsStandaloneComputer()
//
//  Purpose:    Determines if the computer is not a member of a domain
//
//  Parameters: none
//
//
//  Return:     TRUE if the computer is running standalone
//              FALSE if not
//
//*************************************************************

BOOL IsStandaloneComputer (VOID)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic;
    DWORD dwResult;
    BOOL bRetVal = FALSE;

    //
    // Ask for the role of this machine
    //

    dwResult = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic,
                                                 (PBYTE *)&pBasic);


    if (dwResult == ERROR_SUCCESS)
    {

        //
        // Check for standalone flags
        //

        if ((pBasic->MachineRole == DsRole_RoleStandaloneWorkstation) ||
            (pBasic->MachineRole == DsRole_RoleStandaloneServer))
        {
            bRetVal = TRUE;
        }

        DsRoleFreeMemory (pBasic);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("IsStandaloneComputer:  DsRoleGetPrimaryDomainInformation failed with %d."),
                 dwResult));
    }

    return bRetVal;
}

//*************************************************************
//
//  GetNewGPODisplayName()
//
//  Purpose:    Gets the new GPO display name
//
//  Parameters: lpDisplayName      -  Receives the display name
//              dwDisplayNameSize  -  Size of lpDisplayName
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetNewGPODisplayName (LPTSTR lpDisplayName, DWORD dwDisplayNameSize)
{
    TCHAR szName[256];
    LONG lResult;
    HKEY hKey;
    DWORD dwSize, dwType;


    //
    // Load the default string
    //

    LoadString(g_hInstance, IDS_NEWGPO, szName, ARRAYSIZE(szName));


    //
    // Check for a user preference
    //

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        dwSize = sizeof(szName);
        RegQueryValueEx (hKey, GPO_DISPLAY_NAME_VALUE, NULL, &dwType,
                         (LPBYTE) szName, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a user policy
    //

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        dwSize = sizeof(szName);
        RegQueryValueEx (hKey, GPO_DISPLAY_NAME_VALUE, NULL, &dwType,
                         (LPBYTE) szName, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Expand the string to resolve any environment variables
    //

    if (!ExpandEnvironmentStrings (szName, lpDisplayName, dwDisplayNameSize))
    {
        return FALSE;
    }

    return TRUE;
}

HRESULT GetWMIFilterName (LPTSTR lpFilter, BOOL bDSFormat, BOOL bRetRsopFormat, LPTSTR *lpName)
{
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject *pObject = NULL;
    BSTR bstrParam = NULL;
    BSTR bstrObject = NULL;
    HRESULT hr;
    LPTSTR lpID, lpDSPath, lpTemp, lpFullFilter = NULL, lpObject = NULL;
    LPTSTR lpDomain = NULL;


    *lpName = NULL;

    hr = E_OUTOFMEMORY;

    if (bDSFormat)
    {
        //
        // Parse the filter path
        //

        lpFullFilter = new TCHAR [lstrlen(lpFilter) + 1];

        if (!lpFullFilter)
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to alloc memory for full filter path")));
            goto Cleanup;
        }

        lstrcpy (lpFullFilter, lpFilter);

        lpTemp = lpFullFilter;


        //
        // Skip over the opening [ character
        //

        lpTemp++;
        lpDSPath = lpTemp;


        //
        // Find the semi-colon.  This is the end of the DS Path
        //

        while (*lpTemp && (*lpTemp != TEXT(';')))
            lpTemp++;

        if (!(*lpTemp))
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Filter parsing problem")));
            goto Cleanup;
        }

        *lpTemp = TEXT('\0');
        lpTemp++;


        //
        // Next is the ID  (a guid).  Find the next semi-colon and the ID is complete
        //

        lpID = lpTemp;


        while (*lpTemp && (*lpTemp != TEXT(';')))
            lpTemp++;

        if (!(*lpTemp))
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Filter parsing problem")));
            goto Cleanup;
        }

        *lpTemp = TEXT('\0');



        //
        // Now build the query
        //

        lpObject = new TCHAR [lstrlen(lpDSPath) + lstrlen(lpID) + 50];

        if (!lpObject)
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to alloc memory for object path")));
            goto Cleanup;
        }

        wsprintf (lpObject, TEXT("MSFT_SomFilter.ID=\"%s\",Domain=\"%s\""), lpID, lpDSPath);
    }
    else
    {
        //
        // The filter is already in the correct format.  Just dup it and go.
        //

        lpObject = new TCHAR [lstrlen(lpFilter) + 1];

        if (!lpObject)
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to alloc memory for object path")));
            goto Cleanup;
        }

        lstrcpy (lpObject, lpFilter);
    }


    //
    // Get a locator instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: CoCreateInstance failed with 0x%x"), hr));
        goto Cleanup;
    }


    //
    // Build a path to the policy provider
    //

    bstrParam = SysAllocString(TEXT("\\\\.\\root\\policy"));

    if (!bstrParam)
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to allocate bstr for namespace path")));
        goto Cleanup;
    }


    //
    // Connect to the namespace
    //

    hr = pLocator->ConnectServer(bstrParam,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: ConnectServer failed with 0x%x"), hr));
        goto Cleanup;
    }


    //
    // Set the proper security to prevent the GetObject call from failing
    //

    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_CALL,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Cleanup;
    }



    bstrObject = SysAllocString(lpObject);

    if (!bstrObject)
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to allocate bstr for namespace path")));
        goto Cleanup;
    }

    hr = pNamespace->GetObject(bstrObject,
                               WBEM_FLAG_RETURN_WBEM_COMPLETE,
                               NULL,
                               &pObject,
                               NULL);

    if (FAILED(hr))
    {
        TCHAR szDefault[100];

        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: GetObject for %s failed with 0x%x"), bstrObject, hr));

        goto Cleanup;
    }



    hr = GetParameter(pObject, TEXT("Name"), *lpName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: GetParameter failed with 0x%x"), hr));
    }


    if (bRetRsopFormat) {
        LPTSTR lpTemp1;
        TCHAR szRsopQueryFormat[200];

        hr = GetParameter(pObject, TEXT("Domain"), lpDomain);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: GetParameter failed with 0x%x"), hr));
        }

        if (lpDomain) {
            szRsopQueryFormat[0] = TEXT('\0');
            LoadString(g_hInstance, IDS_RSOPWMIQRYFMT, szRsopQueryFormat, ARRAYSIZE(szRsopQueryFormat));

            lpTemp1 = new TCHAR[lstrlen(szRsopQueryFormat)+lstrlen(*lpName)+
                               lstrlen(lpDomain)+2];

            if (!lpTemp1) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                delete [] *lpName;
                *lpName = NULL;
                DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to allocate memory with 0x%x"), hr));
                goto Cleanup;
            }

            wsprintf(lpTemp1, szRsopQueryFormat, *lpName, lpDomain);
            delete [] *lpName;
            *lpName = lpTemp1;

            delete [] lpDomain;
        }
    }

Cleanup:
    SysFreeString(bstrParam);

    if (pObject)
    {
        pObject->Release();
    }

    if (pNamespace)
    {
        pNamespace->Release();
    }

    if (pLocator)
    {
        pLocator->Release();
    }

    if (bstrParam)
    {
        SysFreeString (bstrParam);
    }

    if (bstrObject)
    {
        SysFreeString (bstrParam);
    }

    if (lpFullFilter)
    {
        delete [] lpFullFilter;
    }

    if (lpObject)
    {
        delete [] lpObject;
    }

    return hr;
}


//*************************************************************
//
//  GetWMIFilter()
//
//  Purpose:    Displays the WMI filter UI and returns back a dspath, id,
//              and friendly display name if the user selects OK.
//
//  Parameters: bBrowser      -  Browser or full manager.
//              hwndParent    -  Hwnd of parent window
//              bDSFormat     -  Boolean that states DS vs WMI format
//              lpDisplayName -  Address of pointer to friendly display name
//              lpFilter      -  Address of pointer to filter
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Notes:      The filter is returned in either DS or WMI format.
//                 The DS format is: [DSPath;id;flags]     flags is always 0
//                 The WMI format is: MSFT_SomFilter.ID="<id>",Domain="<context>"
//
//*************************************************************

BOOL GetWMIFilter(  BOOL bBrowser,
                    HWND hwndParent,
                    BOOL bDSFormat,
                    LPTSTR *lpDisplayName,
                    LPTSTR * lpFilter,
                    BSTR    bstrDomain )
{
    HRESULT hr;
    VARIANT var;
    IWMIFilterManager * pWMIFilterManager;
    IWbemClassObject * pFilter;
    LPTSTR lpName = NULL, lpDSPath = NULL, lpID = NULL;

    VariantInit (&var);

    //
    // Display the appropriate WMI filter UI
    //

    hr = CoCreateInstance (CLSID_WMIFilterManager, NULL,
                           CLSCTX_SERVER, IID_IWMIFilterManager,
                           (void**)&pWMIFilterManager);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  CoCreateInstance failed with 0x%x."),hr));
        return FALSE;
    }


    if (bBrowser)
    {
        hr = pWMIFilterManager->RunBrowser( hwndParent,
                                            bstrDomain,
                                            &var );
    }
    else
    {
        hr = pWMIFilterManager->RunManager( hwndParent,
                                            bstrDomain,
                                            &var);
    }


    pWMIFilterManager->Release();


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  RunBrowser / RunManager failed with 0x%x."),hr));
        return FALSE;
    }

    if (hr == S_FALSE)
    {
        if (*lpFilter) {
            hr = GetWMIFilterName (*lpFilter, TRUE, FALSE, lpDisplayName);

            if (!(*lpDisplayName)) {
                DebugMsg((DM_VERBOSE, TEXT("GetWMIFilter:  Currently attached WMI filter doesn't exist.")));

                if (hwndParent)
                {
                    ReportError(hwndParent, 0, IDS_WMIFILTERFORCEDNONE);
                }


                delete [] *lpFilter;
                *lpFilter = NULL;
            }
        }

        return TRUE;
    }


    if (var.vt != VT_UNKNOWN)
    {
         DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  variant isn't of type VT_UNKNOWN.")));
         VariantClear (&var);
         return FALSE;
    }


    //
    //  Get the IWbemClassobject interface pointer
    //

    hr = var.punkVal->QueryInterface (IID_IWbemClassObject, (void**)&pFilter);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  QueryInterface failed with 0x%x."),hr));
        VariantClear (&var);
        return FALSE;
    }


    //
    //  Get the display name
    //

    hr = GetParameter (pFilter, TEXT("Name"), lpName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  GetParameter for Name failed with 0x%x."),hr));
        pFilter->Release();
        VariantClear (&var);
        return FALSE;
    }


    //
    //  Get the DS Path (Domain)
    //

    hr = GetParameter (pFilter, TEXT("Domain"), lpDSPath);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  GetParameter for DsContext failed with 0x%x."),hr));
        delete [] lpName;
        pFilter->Release();
        VariantClear (&var);
        return FALSE;
    }


    //
    //  Get the ID
    //

    hr = GetParameter (pFilter, TEXT("ID"), lpID);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  GetParameter for ID failed with 0x%x."),hr));
        delete [] lpDSPath;
        delete [] lpName;
        pFilter->Release();
        VariantClear (&var);
        return FALSE;
    }


    //
    // Put the path together
    //


    LPTSTR lpTemp = NULL;
    lpTemp = new TCHAR[lstrlen(lpDSPath) + lstrlen(lpID) + 50];

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  New failed")));
        delete [] lpID;
        delete [] lpDSPath;
        delete [] lpName;
        pFilter->Release();
        VariantClear (&var);
        return FALSE;
    }

    delete [] *lpFilter;
    *lpFilter = lpTemp;

    if (bDSFormat)
    {
        wsprintf (*lpFilter, TEXT("[%s;%s;0]"), lpDSPath, lpID);
    }
    else
    {
        wsprintf (*lpFilter, TEXT("MSFT_SomFilter.ID=\"%s\",Domain=\"%s\""), lpID, lpDSPath);
    }


    //
    // Save the display name
    //

    *lpDisplayName = lpName;

    delete [] lpID;
    delete [] lpDSPath;
    pFilter->Release();
    VariantClear (&var);

    DebugMsg((DM_VERBOSE, TEXT("GetWMIFilter:  Name:  %s   Filter:  %s"), *lpDisplayName, *lpFilter));

    return TRUE;
}

//*************************************************************
//
//  GetWMIFilterDisplayName()
//
//  Purpose:    Gets the friendly display name for the specified
//              WMI filter link
//
//  Parameters: lpFilter - filter string
//              bDSFormat - in ds format or wmi format
//
//
//  Return:     Pointer to display name if successful
//              NULL if an error occurs
//
//*************************************************************
LPTSTR GetWMIFilterDisplayName (HWND hParent, LPTSTR lpFilter, BOOL bDSFormat, BOOL bRetRsopFormat)
{
    LPTSTR lpName = NULL;
    HRESULT hr;


    hr = GetWMIFilterName(lpFilter, bDSFormat, bRetRsopFormat, &lpName);

    if (FAILED(hr) || ((*lpName) == NULL)) {
        TCHAR szDefault[100];

        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: GetObject for %s failed with 0x%x"), lpFilter, hr));

        if (hParent)
        {
            ReportError(hParent, hr, IDS_WMIFILTERMISSING);
        }

        LoadString(g_hInstance, IDS_MISSINGFILTER, szDefault, ARRAYSIZE(szDefault));

        lpName = new TCHAR [lstrlen(szDefault) + 1];

        if (!lpName)
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to alloc memory for default name")));
            goto Cleanup;
        }

        lstrcpy (lpName, szDefault);
    }


Cleanup:
    return lpName;
}

//*************************************************************
//
//  SaveString()
//
//  Purpose:    Saves the given string to the stream
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HRESULT SaveString(IStream *pStm, LPTSTR lpString)
{
    ULONG nBytesWritten;
    DWORD dwTemp;
    HRESULT hr;


    //
    // Save the string length
    //

    dwTemp = lstrlen (lpString);

    if (dwTemp)
    {
        dwTemp = (dwTemp + 1) * sizeof (TCHAR);
    }

    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("SaveString: Failed to write string length with %d."), hr));
        goto Exit;
    }


    //
    // Save the string
    //

    if (dwTemp)
    {
        hr = pStm->Write(lpString, dwTemp, &nBytesWritten);

        if ((hr != S_OK) || (nBytesWritten != dwTemp))
        {
            DebugMsg((DM_WARNING, TEXT("SaveString: Failed to write string with %d."), hr));
            goto Exit;
        }
    }

Exit:

    return hr;
}

HRESULT ReadString(IStream *pStm, LPTSTR *lpString)
{
    HRESULT hr;
    DWORD dwStringLen;
    ULONG nBytesRead;


    //
    // Read in the string length (including null terminator)
    //

    hr = pStm->Read(&dwStringLen, sizeof(dwStringLen), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwStringLen)))
    {
        DebugMsg((DM_WARNING, TEXT("ReadString: Failed to read string size with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read in the string if there is one
    //

    if (dwStringLen > 0)
    {

        *lpString = new TCHAR[(dwStringLen/sizeof(TCHAR))];

        if (!(*lpString))
        {
            DebugMsg((DM_WARNING, TEXT("ReadString: Failed to allocate memory with %d."),
                     GetLastError()));
            hr = E_FAIL;
            goto Exit;
        }

        hr = pStm->Read(*lpString, dwStringLen, &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != dwStringLen))
        {
            DebugMsg((DM_WARNING, TEXT("ReadString: Failed to read String with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("ReadString: String is: <%s>"), *lpString));
    }

Exit:


    return hr;

}


//*************************************************************
//
//  GetSiteFriendlyName()
//
//  Purpose:    Returns the sites friendly name
//
//  Parameters:
//
//          szSitePath  - Path to the site
//          pszSiteName - Friendly name of the site
//
//  Return:     currently it always returns true, if it
//              couldn't get the sitename, returns itself
//
//*************************************************************

BOOL GetSiteFriendlyName (LPWSTR szSitePath, LPWSTR *pszSiteName)
{
    *pszSiteName = new WCHAR[wcslen(szSitePath)+1];

    if (!*pszSiteName) {
        return FALSE;
    }

    LPWSTR szData;

    //
    // Build the LDAP path (serverless)
    //

    szData = new WCHAR[wcslen(szSitePath)+1+7];

    if (szData)
    {
        wcscpy(szData, TEXT("LDAP://"));
        wcscat(szData, szSitePath);


        //
        // Setup the default friendly name
        //

        if (*pszSiteName)
        {
            wcscpy(*pszSiteName, szSitePath);
        }


        //
        // Bind to the site object in the DS to try and get the
        // real friendly name
        //

        IADs * pADs = NULL;

        HRESULT hr = OpenDSObject(szData, IID_IADs, (void **)&pADs);

        if (SUCCEEDED(hr))
        {
            VARIANT varName;
            BSTR bstrNameProp;
            VariantInit(&varName);
            bstrNameProp = SysAllocString(SITE_NAME_PROPERTY);

            if (bstrNameProp)
            {
                hr = pADs->Get(bstrNameProp, &varName);

                if (SUCCEEDED(hr))
                {
                    LPOLESTR sz = new OLECHAR[wcslen(varName.bstrVal) + 1];
                    if (sz)
                    {
                        wcscpy(sz, varName.bstrVal);
                        if (*pszSiteName)
                        {
                            delete [] *pszSiteName;
                        }
                        *pszSiteName = sz;
                    }
                }
                SysFreeString(bstrNameProp);
            }

            VariantClear(&varName);
            pADs->Release();
        }

        delete [] szData;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

#include "gptext.h"

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPTExt[] = TEXT("GPTEXT(%x.%x) %02d:%02d:%02d:%03d ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("GPTExtDebugLevel")

//
// Log files
//

TCHAR szLogFileName[] = TEXT("%SystemRoot%\\Debug\\UserMode\\gptext.log");

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

#if DBG
    dwDebugLevel = DL_NORMAL | DL_LOGFILE | DL_DEBUGGER;
#else
    dwDebugLevel = DL_NORMAL | DL_LOGFILE;
#endif


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[40];
    TCHAR szDebugBuffer[2048];
    va_list marker;
    DWORD dwErrCode;
    SYSTEMTIME systime;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {

        //
        // Build the error text prefix and message
        //

        GetLocalTime (&systime);
        wsprintf (szDebugTitle, c_szGPTExt,
                  GetCurrentProcessId(), GetCurrentThreadId(),
                  systime.wHour, systime.wMinute, systime.wSecond,
                  systime.wMilliseconds);

        va_start(marker, pszMsg);
        wvsprintf(szDebugBuffer, pszMsg, marker);
        va_end(marker);


        //
        // Print to the debugger if appropriate
        //

        if (dwDebugLevel & DL_DEBUGGER) {
            OutputDebugString(szDebugTitle);
            OutputDebugString(szDebugBuffer);
            OutputDebugString(c_szCRLF);
        }


        //
        // Add to the log file if appropriate
        //

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;
            TCHAR szExpLogFileName[MAX_PATH+1];

            ExpandEnvironmentStrings (szLogFileName, szExpLogFileName, ARRAYSIZE(szExpLogFileName));

            hFile = CreateFile(szExpLogFileName,
                               FILE_WRITE_DATA | FILE_APPEND_DATA,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }
        }
    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000
#define DL_DEBUGGER 0x00020000

extern DWORD dwDebugLevel;


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) if (dwDebugLevel != DL_NONE) \
                        _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\gposcripts.cpp ===
#include "gptext.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "SmartPtr.h"

LPWSTR
StripLinkPrefix( LPWSTR pwszPath )
{
    WCHAR wszPrefix[] = L"LDAP://";
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Som
    //

    if ( wcslen(pwszPath) <= (DWORD) iPrefixLen ) {
        return pwszPath;
    }

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                        pwszPath, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}

HRESULT
SystemTimeToWbemTime( SYSTEMTIME& sysTime, XBStr& xbstrWbemTime )
{
    XPtrST<WCHAR> xTemp = new WCHAR[25 + 1];

    if ( !xTemp )
    {
        return E_OUTOFMEMORY;
    }

    int nRes = wsprintf(xTemp, L"%04d%02d%02d%02d%02d%02d.000000+000",
                sysTime.wYear,
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond);
    if ( nRes != 25 )
    {
        return E_FAIL;
    }

    xbstrWbemTime = xTemp;
    if ( !xbstrWbemTime )
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

PSID
GetUserSid( HANDLE UserToken )
{
    XPtrLF<TOKEN_USER> pUser;
    PTOKEN_USER pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;

    //
    // Allocate space for the user info
    //
    pUser = (PTOKEN_USER) LocalAlloc( LMEM_FIXED, BytesRequired );
    if ( !pUser )
    {
        return 0;
    }

    //
    // Read in the UserInfo
    //
    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL )
    {
        //
        // Allocate a bigger buffer and try again.
        //
        pTemp = (PTOKEN_USER) LocalReAlloc( pUser, BytesRequired, LMEM_MOVEABLE );
        if ( !pTemp )
        {
            return 0;
        }

        pUser = pTemp;
        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if ( !NT_SUCCESS(status) )
    {
        return 0;
    }

    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if ( !pSid )
    {
        return NULL;
    }

    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pSid);
        pSid = 0;
    }

    return pSid;
}

LPWSTR
GetSidString( HANDLE UserToken )
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;

    //
    // Get the user sid
    //
    UserSid = GetUserSid( UserToken );
    if ( !UserSid )
    {
        return 0;
    }

    //
    // Convert user SID to a string.
    //
    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString,
                                            UserSid,
                                            (BOOLEAN)TRUE ); // Allocate
    LocalFree( UserSid );

    if ( !NT_SUCCESS(NtStatus) )
    {
        return 0;
    }

    return UnicodeString.Buffer ;
}

void
DeleteSidString( LPWSTR SidString )
{
    UNICODE_STRING String;

    RtlInitUnicodeString( &String, SidString );
    RtlFreeUnicodeString( &String );
}

DWORD
SecureRegKey(   HANDLE  hToken,
                HKEY    hKey )
{
    DWORD dwError;
    SECURITY_DESCRIPTOR         sd;
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    PACL                        pAcl = 0;
    PSID                        psidUser = 0,
                                psidSystem = 0,
                                psidAdmin = 0;
    DWORD cbAcl, AceIndex;
    ACE_HEADER* lpAceHeader;

    //
    // Create the security descriptor that will be applied to the key
    //
    if ( hToken )
    {
        //
        // Get the user's sid
        //
        psidUser = GetUserSid( hToken );
        if ( !psidUser )
        {
            return GetLastError();
        }
    }
    else
    {
        //
        // Get the authenticated users sid
        //
        if ( !AllocateAndInitializeSid( &authNT,
                                        1,
                                        SECURITY_AUTHENTICATED_USER_RID,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        &psidUser ) )
        {
            return GetLastError();
        }
    }

    //
    // Get the system sid
    //
    if ( !AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem))
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Get the admin sid
    //
    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin))
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Allocate space for the ACL
    //
    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    pAcl = (PACL) GlobalAlloc( GMEM_FIXED, cbAcl );
    if ( !pAcl )
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !InitializeAcl( pAcl, cbAcl, ACL_REVISION ) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //
    AceIndex = 0;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidUser) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Now the inheritable ACEs
    //
    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !GetAce(pAcl, AceIndex, (void**) &lpAceHeader) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem))
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !GetAce( pAcl, AceIndex, (void**) &lpAceHeader ) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !GetAce(pAcl, AceIndex, (void**) &lpAceHeader) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    //
    // Put together the security descriptor
    //
    if ( !InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // secure the registry key
    //
    dwError = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, &sd );

Exit:
    //
    // LocalFree the sids and acl
    //
    if ( psidUser )
    {
        if ( hToken )
        {
            LocalFree( psidUser );
        }
        else
        {
            FreeSid( psidUser );
        }
    }

    if (psidSystem)
    {
        FreeSid( psidSystem );
    }

    if (psidAdmin)
    {
        FreeSid( psidAdmin );
    }

    if (pAcl)
    {
        GlobalFree( pAcl );
    }

    return dwError;
}

#define GPO_SCRIPTS_KEY L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts"
#define GP_STATE_KEY    L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State"

#define SCRIPT          L"Script"
#define PARAMETERS      L"Parameters"
#define EXECTIME        L"ExecTime"
#define GPOID           L"GPO-ID"
#define SOMID           L"SOM-ID"
#define FILESYSPATH     L"FileSysPath"
#define DISPLAYNAME     L"DisplayName"
#define GPONAME         L"GPOName"

#define SCR_STARTUP     L"Startup"
#define SCR_SHUTDOWN    L"Shutdown"
#define SCR_LOGON       L"Logon"
#define SCR_LOGOFF      L"Logoff"

DWORD
ScrGPOToReg(    LPWSTR  szIni,
                LPWSTR  szScrType,
                LPWSTR  szGPOName,
                LPWSTR  szGPOID,
                LPWSTR  szSOMID,
                LPWSTR  szFileSysPath,
                LPWSTR  szDisplayName,
                HKEY    hKeyPolicy,
                HKEY    hKeyState,
                HANDLE  hToken )
{
    DWORD       dwError = ERROR_SUCCESS;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    HANDLE  hOldToken;

    if ( ImpersonateUser( hToken, &hOldToken ) ) {
        if ( !GetFileAttributesEx( szIni, GetFileExInfoStandard, &fad ) )
        {
            return GetLastError();
        }

        RevertToUser( &hOldToken );
    }
    else
    {
        return GetLastError();
    }


    SYSTEMTIME  execTime;
    ZeroMemory( &execTime, sizeof( execTime ) );

    BOOL bFirst = TRUE;

    for( DWORD dwIndex = 0; ; dwIndex++ )
    {
        WCHAR   szTemp[32];
        WCHAR   szScripts[3*MAX_PATH];
        WCHAR   szParams[3*MAX_PATH];
        XKey    hKeyScr;
        XKey    hKeyScrState;
        DWORD   dwBytes;

        if ( ImpersonateUser( hToken, &hOldToken ) )
        {
            //
            // Get the command line
            //
            szScripts[0] = 0;
            wsprintf( szTemp, L"%dCmdLine", dwIndex );
            GetPrivateProfileString(szScrType,
                                    szTemp,
                                    L"",
                                    szScripts,
                                    ARRAYSIZE(szScripts),
                                    szIni );

            //
            // Get the parameters
            //
            szParams[0] = 0;
            wsprintf( szTemp, L"%dParameters", dwIndex);
            GetPrivateProfileString(szScrType,
                                    szTemp,
                                    L"",
                                    szParams,
                                    ARRAYSIZE(szParams),
                                    szIni );

            RevertToUser( &hOldToken );
        }
        else
        {
            return GetLastError();
        }

        //
        // If the command line is empty, we're finished
        //
        if ( szScripts[0] == 0 )
        {
            if ( bFirst )
            {
                //
                // hack error code to detect no scripts
                //
                return ERROR_INVALID_FUNCTION;
            }
            break;
        }

        bFirst = FALSE;

        //
        // create a subkey for each script in the ini file
        //
        dwError = RegCreateKeyEx(   hKeyPolicy,
                                    _itow( dwIndex, szTemp, 16 ),
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyScr,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // create a subkey for each script in the ini file
        //
        dwError = RegCreateKeyEx(   hKeyState,
                                    szTemp,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyScrState,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // script command line
        //
        dwBytes = sizeof( WCHAR ) * ( wcslen( szScripts ) + 1 );
        dwError = RegSetValueEx(hKeyScr,
                                SCRIPT,
                                0,
                                REG_SZ,
                                (BYTE*) szScripts,
                                dwBytes );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        dwError = RegSetValueEx(hKeyScrState,
                                SCRIPT,
                                0,
                                REG_SZ,
                                (BYTE*) szScripts,
                                dwBytes );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // parameters
        //
        dwBytes = sizeof( WCHAR ) * ( wcslen( szParams ) + 1 );
        dwError = RegSetValueEx(hKeyScr,
                                PARAMETERS,
                                0,
                                REG_SZ,
                                (BYTE*) szParams,
                                dwBytes );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        dwError = RegSetValueEx(hKeyScrState,
                                PARAMETERS,
                                0,
                                REG_SZ,
                                (BYTE*) szParams,
                                dwBytes );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // execution time
        //
        dwError = RegSetValueEx(hKeyScr,
                                EXECTIME,
                                0,
                                REG_QWORD,
                                (BYTE*) &execTime,
                                sizeof( execTime ) );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        dwError = RegSetValueEx(hKeyScrState,
                                EXECTIME,
                                0,
                                REG_QWORD,
                                (BYTE*) &execTime,
                                sizeof( execTime ) );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    DWORD   dwBytes;

    //
    // GPOID
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szGPOID ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            GPOID,
                            0,
                            REG_SZ,
                            (BYTE*) szGPOID,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            GPOID,
                            0,
                            REG_SZ,
                            (BYTE*) szGPOID,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }


    //
    // SOMID
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szSOMID ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            SOMID,
                            0,
                            REG_SZ,
                            (BYTE*) szSOMID,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            SOMID,
                            0,
                            REG_SZ,
                            (BYTE*) szSOMID,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // FILESYSPATH
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szFileSysPath ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            FILESYSPATH,
                            0,
                            REG_SZ,
                            (BYTE*) szFileSysPath,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            FILESYSPATH,
                            0,
                            REG_SZ,
                            (BYTE*) szFileSysPath,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // DISPLAYNAME
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szDisplayName ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            DISPLAYNAME,
                            0,
                            REG_SZ,
                            (BYTE*) szDisplayName,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            DISPLAYNAME,
                            0,
                            REG_SZ,
                            (BYTE*) szDisplayName,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // GPONAME
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szGPOName ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            GPONAME,
                            0,
                            REG_SZ,
                            (BYTE*) szGPOName,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            GPONAME,
                            0,
                            REG_SZ,
                            (BYTE*) szGPOName,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    return dwError;
}

DWORD
ScrGPOListToReg(PGROUP_POLICY_OBJECT    pGPO,
                BOOL                    bMachine,
                HKEY                    hKeyRoot,
                HKEY                    hKeyState,
                HANDLE                  hToken )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szScriptKey[MAX_PATH];
    WCHAR   szStateKey[MAX_PATH];
    WCHAR   szFileSysPath[MAX_PATH];
    WCHAR   szTemp[32];
    DWORD   dwLogon, dwLogoff, dwStartup, dwShutdown;

    dwLogon = dwLogoff = dwStartup = dwShutdown = 0;

    //
    // for each GPO
    //
    for ( ; pGPO ; pGPO = pGPO->pNext )
    {
        XKey    hKeyTypePolicy;
        XKey    hKeyTypeState;
        LPWSTR  szType;

        LPWSTR  szGPOID = wcschr( pGPO->lpDSPath, L',' );
        if ( szGPOID )
        {
            szGPOID++;
        }
        else
        {
            szGPOID = pGPO->lpDSPath;
        }

        LPWSTR szSOMID = StripLinkPrefix( pGPO->lpLink );

        //
        // construct \\<domain-DNS>\SysVol\<domain-DNS>\Policies\{<GPOID>}\Machine\Scripts\Scripts.ini
        //
        wcscpy( szFileSysPath, pGPO->lpFileSysPath );
        wcscat( szFileSysPath, L"\\Scripts\\Scripts.ini");

        //
        // construct "Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\<Type>\\<Index>"
        // hKeyState == "Software\\Microsoft\\Windows\\Group Policy\\State\\Scripts\\<Target>"
        // construct hKeyState:"<Type>\\<Index>"
        //
        wcscpy( szScriptKey, GPO_SCRIPTS_KEY );
        if ( bMachine )
        {
            szType = SCR_STARTUP;
            wcscat( szScriptKey, L"\\" SCR_STARTUP L"\\" );
            wcscat( szScriptKey, _itow( dwStartup, szTemp, 16 ) );
            wcscpy( szStateKey, SCR_STARTUP L"\\" );
            wcscat( szStateKey, szTemp );
        }
        else
        {
            szType = SCR_LOGON;
            wcscat( szScriptKey, L"\\" SCR_LOGON L"\\" );
            wcscat( szScriptKey, _itow( dwLogon, szTemp, 16 ) );
            wcscpy( szStateKey, SCR_LOGON L"\\" );
            wcscat( szStateKey, szTemp );
        }

        //
        // open/create the state key
        // 
        dwError = RegCreateKeyEx(   hKeyState,
                                    szStateKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyTypeState,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // open/create the script key
        // 
        dwError = RegCreateKeyEx(   hKeyRoot,
                                    szScriptKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyTypePolicy,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // dump the scripts to the registry
        //
        dwError = ScrGPOToReg(  szFileSysPath,
                                szType,
                                pGPO->szGPOName,
                                szGPOID,
                                szSOMID,
                                pGPO->lpFileSysPath,
                                pGPO->lpDisplayName,
                                hKeyTypePolicy,
                                hKeyTypeState,
                                hToken );
        if ( dwError == ERROR_INVALID_FUNCTION )
        {
            dwError = ERROR_SUCCESS;
            RegDelnode( hKeyRoot, szScriptKey );
            RegDelnode( hKeyState, szStateKey );
            // continue processing
        }
        else if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        else {
            if ( bMachine )
            {
                dwStartup++;
            }
            else 
            {
                dwLogon++;
            }
        }

        //
        // construct "Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\<Type>\\<Index>"
        // hKeyState == "Software\\Microsoft\\Windows\\Group Policy\\State\\Scripts\\<Target>"
        // construct hKeyState:"<Type>\\<Index>"
        //
        wcscpy( szScriptKey, GPO_SCRIPTS_KEY );
        if ( bMachine )
        {
            szType = SCR_SHUTDOWN;
            wcscat( szScriptKey, L"\\" SCR_SHUTDOWN L"\\" );
            wcscat( szScriptKey, _itow( dwShutdown, szTemp, 16 ) );
            wcscpy( szStateKey, SCR_SHUTDOWN L"\\" );
            wcscat( szStateKey, szTemp );
        }
        else
        {
            szType = SCR_LOGOFF;
            wcscat( szScriptKey, L"\\" SCR_LOGOFF L"\\" );
            wcscat( szScriptKey, _itow( dwLogoff, szTemp, 16 ) );
            wcscpy( szStateKey, SCR_LOGOFF L"\\" );
            wcscat( szStateKey, szTemp );
        }

        //
        // open/create the state key
        // 
        dwError = RegCreateKeyEx(   hKeyState,
                                    szStateKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyTypeState,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // open/create the script key
        // 
        hKeyTypePolicy = 0;
        dwError = RegCreateKeyEx(   hKeyRoot,
                                    szScriptKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyTypePolicy,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // dump the scripts to the registry
        //
        dwError = ScrGPOToReg(  szFileSysPath,
                                szType,
                                pGPO->szGPOName,
                                szGPOID,
                                szSOMID,
                                pGPO->lpFileSysPath,
                                pGPO->lpDisplayName,
                                hKeyTypePolicy,
                                hKeyTypeState,
                                hToken );
        if ( dwError == ERROR_INVALID_FUNCTION )
        {
            dwError = ERROR_SUCCESS;
            RegDelnode( hKeyRoot, szScriptKey );
            RegDelnode( hKeyState, szStateKey );
            // continue processing
        }
        else if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        else {
            if ( bMachine )
            {
                dwShutdown++;
            }
            else 
            {
                dwLogoff++;
            }
        }
    }

    return dwError;
}

class CGPOScriptsLogger
{
public:
    CGPOScriptsLogger( IWbemServices* pServices ) :
        m_bInitialized(FALSE),
        m_cScripts( 0 ),
        m_pServices( pServices )
    {
        XBStr                          xsz;
        XInterface<IWbemClassObject>   xClass;

        //
        // WBEM version of CF for RSOP_ScriptPolicySetting
        // Script Policy Object, RSOP_ScriptPolicySetting in MOF
        //

        xsz = L"RSOP_ScriptPolicySetting";
        if ( !xsz )
            return;

        HRESULT hr = pServices->GetObject(  xsz,
                                            0L,
                                            0,
                                            &xClass,
                                            0 );
        if ( FAILED(hr) )
        {
            return;
        }

        //
        // spawn an instance of RSOP_ScriptPolicySetting
        //

        hr = xClass->SpawnInstance( 0, &m_pInstSetting );
        if ( FAILED (hr) )
        {
            return;
        }

        //
        // WBEM version of CF for RSOP_ScriptCmd
        // individual script commands, RSOP_ScriptCmd in MOF
        //

        xsz = L"RSOP_ScriptCmd";
        if ( !xsz )
        {
            return;
        }
        xClass = 0;
        hr = pServices->GetObject(  xsz,
                                    0L,
                                    0,
                                    &xClass,
                                    0 );
        if ( FAILED(hr) )
        {
            return;
        }

        //
        // spawn an instance of RSOP_ScriptCmd
        //

        hr = xClass->SpawnInstance( 0, &m_pInstCmd );
        if ( FAILED (hr) )
        {
            return;
        }

        m_bInitialized = TRUE;
    }

    BOOL Initialized()
    {
        return m_bInitialized;
    }

    DWORD SetGPOID( LPWSTR sz )
    {
        VARIANT var;
        XBStr x = sz;
        var.vt = VT_BSTR;
        var.bstrVal = x;
        return m_pInstSetting->Put( L"GPOID", 0, &var, 0 );
    }

    DWORD SetID( LPWSTR sz )
    {
        m_szID = (LPWSTR) LocalAlloc( LPTR, sizeof( WCHAR ) * ( wcslen( sz ) + 1 ) );

        if ( !m_szID )
        {
            return GetLastError();
        }

        wcscpy( m_szID, sz );
        return ERROR_SUCCESS;
    }

    DWORD SetSOMID( LPWSTR sz )
    {
        VARIANT var;
        XBStr x = sz;
        var.vt = VT_BSTR;
        var.bstrVal = x;
        return m_pInstSetting->Put( L"SOMID", 0, &var, 0 );
    }

    DWORD SetName( LPWSTR sz )
    {
        VARIANT var;
        XBStr x = sz;
        var.vt = VT_BSTR;
        var.bstrVal = x;
        return m_pInstSetting->Put( L"name", 0, &var, 0 );
    }

    DWORD SetScriptType( LPWSTR sz )
    {
        m_szScriptType = (LPWSTR) LocalAlloc( LPTR, ( wcslen( sz ) + 1 ) * sizeof( WCHAR ) );
        if ( m_szScriptType )
        {
            wcscpy( m_szScriptType, sz );
            return 0;
        }
        else
        {
            return GetLastError();
        }
    }

    DWORD SetScriptOrder( DWORD cOrder )
    {
        VARIANT var;
        
        var.vt = VT_I4;
        var.lVal = cOrder;
        return m_pInstSetting->Put( L"ScriptOrder", 0, &var, 0 );
    }

    DWORD SetScriptCount( DWORD cScripts )
    {
        m_cScripts = 0;
        SAFEARRAYBOUND arrayBound[1];
        arrayBound[0].lLbound = 0;
        arrayBound[0].cElements = cScripts;

        //
        // create a SafeArray of RSOP_ScriptCmd
        //

        m_aScripts = SafeArrayCreate( VT_UNKNOWN, 1, arrayBound );

        if ( !m_aScripts )
        {
            return E_OUTOFMEMORY;
        }

        return 0;
    }

    DWORD AddScript( LPWSTR szScript, LPWSTR szParameters, SYSTEMTIME* pExecTime )
    {
        HRESULT     hr = S_OK;
        IUnknown*   pUnk = 0;
        VARIANT     var;
        XBStr       xsz;
        XInterface<IWbemClassObject> pClone;

        hr = m_pInstCmd->Clone( &pClone );
        if ( FAILED (hr) )
        {
            return hr;
        }

        var.vt = VT_BSTR;
        xsz = szScript;
        var.bstrVal = xsz;
        hr = pClone->Put( L"Script", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        //
        // set the Arguments field for RSOP_ScriptCmd
        //
        xsz = szParameters;
        var.bstrVal = xsz;
        hr = pClone->Put( L"Arguments", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        //
        // set the executionTime field for RSOP_ScriptCmd
        //
        xsz = 0;
        hr = SystemTimeToWbemTime( *pExecTime, xsz );
        if ( FAILED (hr) )
        {
            return hr;
        }
        
        var.bstrVal = xsz;
        hr = pClone->Put( L"executionTime", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        hr = pClone->QueryInterface( IID_IUnknown, (void **)&pUnk );
        if ( FAILED (hr) )
        {
            return hr;
        }

        hr = SafeArrayPutElement( m_aScripts, (LONG*) &m_cScripts, pUnk );
        if ( FAILED (hr) )
        {
            pUnk->Release();
            return hr;
        }

        m_cScripts++;

        return hr;
    }

    DWORD Log()
    {
        HRESULT hr;
        VARIANT var;
        XBStr   x;
        WCHAR   szName[128];

        var.vt = VT_I4;
        var.lVal = 1;
        hr = m_pInstSetting->Put( L"precedence", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        wcscpy( szName, m_szID );
        wcscat( szName, L"-" );
        wcscat( szName, m_szScriptType );

        var.vt = VT_BSTR;
        var.bstrVal = szName;
        hr = m_pInstSetting->Put( L"id", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        DWORD dwType;

        if ( !wcscmp( m_szScriptType, SCR_LOGON ) )
        {
            dwType = 1;
        }
        else if ( !wcscmp( m_szScriptType, SCR_LOGOFF ) )
        {
            dwType = 2;
        }
        else if ( !wcscmp( m_szScriptType, SCR_STARTUP ) )
        {
            dwType = 3;
        }
        else
        {
            dwType = 4;
        }
        
        var.vt = VT_I4;
        var.lVal = dwType;
        hr = m_pInstSetting->Put( L"ScriptType", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        var.vt = VT_ARRAY | VT_UNKNOWN;
        var.parray = m_aScripts;
        hr = m_pInstSetting->Put( L"ScriptList", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        return m_pServices->PutInstance(m_pInstSetting,
                                        WBEM_FLAG_CREATE_OR_UPDATE,
                                        0,
                                        0 );
    }

private:
    BOOL                           m_bInitialized;
    XPtrLF<WCHAR>                  m_szID;
    DWORD                          m_cScripts;
    IWbemServices*                 m_pServices;
    XSafeArray                     m_aScripts;
    XInterface<IWbemClassObject>   m_pInstSetting;
    XInterface<IWbemClassObject>   m_pInstCmd;
    XPtrLF<WCHAR>                  m_szScriptType;
};

DWORD
ScrRegGPOToWbem(HKEY            hKeyGPO,
                LPWSTR          szScrType,
                DWORD           dwScriptOrder,
                CGPOScriptsLogger* pLogger )
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cSubKeys = 0;
    WCHAR   szBuffer[MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize;

    //
    // ID
    //
    dwType = REG_SZ;
    dwSize = sizeof( szBuffer );
    szBuffer[0] = 0;
    dwError = RegQueryValueEx(  hKeyGPO,
                                GPONAME,
                                0,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = pLogger->SetID( szBuffer );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // GPOID
    //
    dwType = REG_SZ;
    dwSize = sizeof( szBuffer );
    szBuffer[0] = 0;
    dwError = RegQueryValueEx(  hKeyGPO,
                                GPOID,
                                0,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = pLogger->SetGPOID( szBuffer );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // SOMID
    //
    dwType = REG_SZ;
    dwSize = sizeof( szBuffer );
    szBuffer[0] = 0;
    dwError = RegQueryValueEx(  hKeyGPO,
                                SOMID,
                                0,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = pLogger->SetSOMID( szBuffer );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // DISPLAYNAME
    //
    dwType = REG_SZ;
    dwSize = sizeof( szBuffer );
    szBuffer[0] = 0;
    dwError = RegQueryValueEx(  hKeyGPO,
                                DISPLAYNAME,
                                0,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = pLogger->SetName( szBuffer );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // script type
    //
    dwError = pLogger->SetScriptType( szScrType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // script order
    //
    dwError = pLogger->SetScriptOrder( dwScriptOrder );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // get the numer of Scripts
    //
    dwError = RegQueryInfoKey(  hKeyGPO,
                                0,
                                0,
                                0,
                                &cSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    pLogger->SetScriptCount( cSubKeys );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // for every Script
    //
    for ( DWORD dwIndex = 0 ; dwIndex < cSubKeys ; dwIndex++ )
    {
        XKey    hKeyScript;
        WCHAR   szTemp[32];
        SYSTEMTIME  execTime;
        WCHAR   szScript[MAX_PATH];
        WCHAR   szParameters[MAX_PATH];

        //
        // open the Script key
        //
        dwError = RegOpenKeyEx( hKeyGPO,
                                _itow( dwIndex, szTemp, 16 ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyScript );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // script
        // 
        dwType = REG_SZ;
        dwSize = sizeof( szScript );
        szScript[0] = 0;
        dwError = RegQueryValueEx(  hKeyScript,
                                    SCRIPT,
                                    0,
                                    &dwType,
                                    (LPBYTE) szScript,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // parameters
        // 
        dwType = REG_SZ;
        dwSize = sizeof( szParameters );
        szParameters[0] = 0;
        dwError = RegQueryValueEx(  hKeyScript,
                                    PARAMETERS,
                                    0,
                                    &dwType,
                                    (LPBYTE) szParameters,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // exec time
        // 
        dwType = REG_QWORD;
        dwSize = sizeof( execTime );
        dwError = RegQueryValueEx(  hKeyScript,
                                    EXECTIME,
                                    0,
                                    &dwType,
                                    (LPBYTE) &execTime,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        dwError = pLogger->AddScript( szScript, szParameters, &execTime );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    if ( !FAILED( dwError ) )
    {
        dwError = pLogger->Log();
    }

    return dwError;
}

DWORD
pScrRegGPOListToWbem(   LPWSTR          szSID,
                        LPWSTR          szType,
                        CGPOScriptsLogger* pLogger )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szBuffer[MAX_PATH] = L"";
    XKey    hKeyType;
    BOOL    bMachine = !szSID;
    
    //
    // open the following key
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Group Policy\State\<Target>\Scripts\Type
    //
    wcscpy( szBuffer, GP_STATE_KEY L"\\" );
    if ( bMachine )
    {
        wcscat( szBuffer, L"Machine\\Scripts\\" );
    }
    else
    {
        wcscat( szBuffer, szSID );
        wcscat( szBuffer, L"\\Scripts\\" );
    }
    wcscat( szBuffer, szType );

    //
    // open the key
    //
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szBuffer,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyType );
    if ( dwError != ERROR_SUCCESS )
    {
        if ( dwError == ERROR_FILE_NOT_FOUND )
        {
            dwError = ERROR_SUCCESS;
        }
        return dwError;
    }
    DWORD   cSubKeys = 0;

    //
    // get the numer of GPOs
    //
    dwError = RegQueryInfoKey(  hKeyType,
                                0,
                                0,
                                0,
                                &cSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    //
    // for every GPO
    //
    for ( DWORD dwIndex = 0 ; dwIndex < cSubKeys ; dwIndex++ )
    {
        XKey hKeyGPO;

        //
        // open the GPO key
        //
        dwError = RegOpenKeyEx( hKeyType,
                                _itow( dwIndex, szBuffer, 16 ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyGPO );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // dump all scripts in the GPO into Wbem
        //
        dwError = ScrRegGPOToWbem( hKeyGPO, szType, dwIndex + 1, pLogger );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    return dwError;
}

extern "C" DWORD
ScrRegGPOListToWbem(LPWSTR          szSID,
                    IWbemServices*  pServices );

DWORD
ScrRegGPOListToWbem(LPWSTR          szSID,
                    IWbemServices*  pServices )
{
    DWORD   dwError = ERROR_SUCCESS;

    CGPOScriptsLogger logger( pServices );
    if ( !logger.Initialized() )
    {
        return GetLastError();
    }

    dwError = pScrRegGPOListToWbem( szSID,
                                    !szSID ? SCR_STARTUP : SCR_LOGON,
                                    &logger );
    if ( dwError == ERROR_SUCCESS )
    {
        dwError = pScrRegGPOListToWbem( szSID,
                                        !szSID ? SCR_SHUTDOWN : SCR_LOGOFF,
                                        &logger );
    }
    return dwError;
}

DWORD
ScrGPOToWbem(   LPWSTR  szIni,
                LPWSTR  szScrType,
                LPWSTR  szGPOName,
                LPWSTR  szGPOID,
                LPWSTR  szSOMID,
                LPWSTR  szFileSysPath,
                LPWSTR  szDisplayName,
                DWORD&  dwScriptOrder,
                HANDLE  hToken,
                CGPOScriptsLogger* pLogger )
{
    DWORD       dwError = ERROR_SUCCESS;
    WIN32_FILE_ATTRIBUTE_DATA fad;

    if ( !GetFileAttributesEx( szIni, GetFileExInfoStandard, &fad ) )
    {
        return GetLastError();
    }

    DWORD dwGrantedAccessMask;
    BOOL bAccess = TRUE;

    //
    // Check if the RsopToken has access to this file.
    //
    dwError = RsopFileAccessCheck(  szIni,
                                    (PRSOPTOKEN) hToken,
                                    GENERIC_READ,
                                    &dwGrantedAccessMask,
                                    &bAccess );

    if ( FAILED( dwError ) )
    {
        return dwError;
    }

    if ( !bAccess )
    {
        return ERROR_SUCCESS;
    }

    //
    // GPONAME
    //
    dwError = pLogger->SetID( szGPOName );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // GPOID
    //
    dwError = pLogger->SetGPOID( szGPOID );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // SOMID
    //
    dwError = pLogger->SetSOMID( szSOMID );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // NAME
    //
    dwError = pLogger->SetName( szDisplayName );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // script type
    //
    dwError = pLogger->SetScriptType( szScrType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // script order
    //
    dwError = pLogger->SetScriptOrder( dwScriptOrder );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // count the number of scripts
    //
    for( DWORD cScripts = 0; ; cScripts++ )
    {
        WCHAR   szTemp[32];
        WCHAR   szBuffer[3*MAX_PATH];

        //
        // Get the command line
        //
        szBuffer[0] = 0;
        wsprintf( szTemp, L"%dCmdLine", cScripts );
        GetPrivateProfileString(szScrType,
                                szTemp,
                                L"",
                                szBuffer,
                                ARRAYSIZE(szBuffer),
                                szIni );
        //
        // If the command line is empty, we're finished
        //
        if ( szBuffer[0] == 0 )
        {
            break;
        }
    }

    if ( !cScripts )
    {
        return S_OK;
    }
    else
    {
        dwScriptOrder++;
    }

    //
    // set script count
    //
    pLogger->SetScriptCount( cScripts );

    SYSTEMTIME  execTime;
    ZeroMemory( &execTime, sizeof( execTime ) );

    for( DWORD dwIndex = 0; dwIndex < cScripts ; dwIndex++ )
    {
        WCHAR   szTemp[32];
        WCHAR   szScript[MAX_PATH];
        WCHAR   szParams[MAX_PATH];

        //
        // Get the command line
        //
        szScript[0] = 0;
        wsprintf( szTemp, L"%dCmdLine", dwIndex );
        GetPrivateProfileString(szScrType,
                                szTemp,
                                L"",
                                szScript,
                                ARRAYSIZE(szScript),
                                szIni );

        //
        // If the command line is empty, we're finished
        //
        if ( szScript[0] == 0 )
        {
            break;
        }

        //
        // Get the parameters
        //
        szParams[0] = 0;
        wsprintf( szTemp, L"%dParameters", dwIndex);
        GetPrivateProfileString(szScrType,
                                szTemp,
                                L"",
                                szParams,
                                ARRAYSIZE(szParams),
                                szIni );

        dwError = pLogger->AddScript( szScript, szParams, &execTime );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    if ( !FAILED( dwError ) )
    {
        dwError = pLogger->Log();
    }

    return dwError;
}

DWORD
ScrGPOListToWbem(   PGROUP_POLICY_OBJECT    pGPO,
                    BOOL                    bMachine,
                    HANDLE                  hToken,
                    IWbemServices*          pServices )
{
    DWORD   dwError = ERROR_SUCCESS;

    CGPOScriptsLogger logger( pServices );
    if ( !logger.Initialized() )
    {
        return GetLastError();
    }

    //
    // for each GPO
    //
    for ( DWORD dwIndex1 = 1, dwIndex2 = 1 ; pGPO ; pGPO = pGPO->pNext )
    {
        WCHAR   szBuffer[MAX_PATH];
        WCHAR   szTemp[32];
        LPWSTR  szType;

        if ( bMachine )
        {
            szType = SCR_STARTUP;
        }
        else
        {
            szType = SCR_LOGON;
        }

        //
        // construct \\<domain-DNS>\SysVol\<domain-DNS>\Policies\{<GPOID>}\Machine\Scripts\Scripts.ini
        //
        wcscpy( szBuffer, pGPO->lpFileSysPath );
        wcscat( szBuffer, L"\\Scripts\\Scripts.ini");

        LPWSTR  szGPOID = wcschr( pGPO->lpDSPath, L',' );
        if ( szGPOID )
        {
            szGPOID++;
        }

        LPWSTR  szSOMID = StripLinkPrefix( pGPO->lpLink );

        //
        // dump the scripts to the registry
        //
        dwError = ScrGPOToWbem( szBuffer,
                                szType,
                                pGPO->szGPOName,
                                szGPOID,
                                szSOMID,
                                pGPO->lpFileSysPath,
                                pGPO->lpDisplayName,
                                dwIndex1,
                                hToken,
                                &logger );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        if ( bMachine )
        {
            szType = SCR_SHUTDOWN;
        }
        else
        {
            szType = SCR_LOGOFF;
        }

        //
        // construct \\<domain-DNS>\SysVol\<domain-DNS>\Policies\{<GPOID>}\User\Scripts\Scripts.ini
        //
        wcscpy( szBuffer, pGPO->lpFileSysPath );
        wcscat( szBuffer, L"\\Scripts\\Scripts.ini");

        //
        // dump the scripts to the registry
        //
        dwError = ScrGPOToWbem( szBuffer,
                                szType,
                                pGPO->szGPOName,
                                szGPOID,
                                szSOMID,
                                pGPO->lpFileSysPath,
                                pGPO->lpDisplayName,
                                dwIndex2,
                                hToken,
                                &logger );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    return dwError;
}

DWORD
ProcessScripts( DWORD                   dwFlags,
                HANDLE                  hToken,
                HKEY                    hKeyRoot,
                PGROUP_POLICY_OBJECT    pDeletedGPOList,
                PGROUP_POLICY_OBJECT    pChangedGPOList,
                BOOL*                   pbAbort,
                BOOL                    bRSoPPlanningMode,
                IWbemServices*          pWbemServices,
                HRESULT*                phrRsopStatus )
{
    HANDLE  hOldToken;
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = ( dwFlags & GPO_INFO_FLAG_MACHINE ) != 0;
    BOOL    bLinkTransition = (dwFlags & GPO_INFO_FLAG_LINKTRANSITION) && (dwFlags & GPO_INFO_FLAG_SLOWLINK);

    if ( bRSoPPlanningMode )
    {
        if ( !bLinkTransition )
        {
            dwError = ScrGPOListToWbem( pChangedGPOList, bMachine, hToken, pWbemServices );
        }
    }
    else
    {
        XKey    hKeyState;
        WCHAR   szBuffer[MAX_PATH];

        //
        // create and secure the following key
        // HKLM\Software\Microsoft\Windows\CurrentVersion\Group Policy\State\<Target>\Scripts
        //
        wcscpy( szBuffer, GP_STATE_KEY L"\\" );
        if ( bMachine )
        {
            wcscat( szBuffer, L"Machine\\Scripts" );
        }
        else
        {
            LPWSTR szSid = GetSidString( hToken );

            if ( !szSid )
            {
                return GetLastError();
            }
            wcscat( szBuffer, szSid );
            wcscat( szBuffer, L"\\Scripts" );
            DeleteSidString( szSid );
        }

        dwError = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                                    szBuffer,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyState,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            return dwError;
        }

        dwError = SecureRegKey( hToken, hKeyState );
        if ( dwError != ERROR_SUCCESS )
        {
            return dwError;
        }

        if ( bMachine )
        {
            //
            // delete the Startup and Shutdown keys
            //
            RegDelnode( hKeyRoot, GPO_SCRIPTS_KEY L"\\" SCR_STARTUP );
            RegDelnode( hKeyRoot, GPO_SCRIPTS_KEY L"\\" SCR_SHUTDOWN );
            RegDelnode( hKeyState, SCR_STARTUP );
            RegDelnode( hKeyState, SCR_SHUTDOWN );
        }
        else
        {
            //
            // delete the Logon and Logoff keys
            //
            RegDelnode( hKeyRoot, GPO_SCRIPTS_KEY L"\\" SCR_LOGON );
            RegDelnode( hKeyRoot, GPO_SCRIPTS_KEY L"\\" SCR_LOGOFF );
            RegDelnode( hKeyState, SCR_LOGON );
            RegDelnode( hKeyState, SCR_LOGOFF );
        }

        dwError = ScrGPOListToReg(  pChangedGPOList,
                                    bMachine,
                                    hKeyRoot,
                                    hKeyState,
                                    hToken );
    }
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\gptext.cpp ===
#include <gptext.h>
#include <initguid.h>
#include <gpedit.h>



//
// Global variables for this DLL
//

LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;
TCHAR g_szSnapInLocation[] = TEXT("%SystemRoot%\\System32\\gptext.dll");
CRITICAL_SECTION  g_ADMCritSec;
TCHAR g_szDisplayProperties[150] = {0};


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       DisableThreadLibraryCalls(hInstance);
       InitScriptsNameSpace();
       InitDebugSupport();
       InitializeCriticalSection (&g_ADMCritSec);

       LoadString (hInstance, IDS_DISPLAYPROPERTIES, g_szDisplayProperties, ARRAYSIZE(g_szDisplayProperties));
    }

    if (dwReason == DLL_PROCESS_DETACH)
    {
        DeleteCriticalSection (&g_ADMCritSec);
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    hr = CreateScriptsComponentDataClassFactory (rclsid, riid, ppv);

    if (hr != CLASS_E_CLASSNOTAVAILABLE)
        return S_OK;


    hr = CreatePolicyComponentDataClassFactory (rclsid, riid, ppv);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    RegisterScripts();
    RegisterPolicy();
    RegisterIPSEC();
    RegisterWireless();
    RegisterPSCHED();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    UnregisterScripts();
    UnregisterPolicy();
    UnregisterIPSEC();
    UnregisterWireless();
    UnregisterPSCHED();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\gptext.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <commdlg.h>
#include <prsht.h>
#include <mmc.h>
#include <activeds.h>
#include <gpedit.h>
#define _USERENV_NO_LINK_APIS_ 1
#include <userenv.h>
#include <userenvp.h>
#include <wbemcli.h>
#include <tchar.h>
#include <winsock2.h>

class CScriptsSnapIn;
class CPolicyComponentData;

#include "debug.h"
#include "util.h"

//
// From comctrlp.h
//
#if (_WIN32_IE >= 0x0501)
#define UDS_UNSIGNED            0x0200
#endif

//
// Resource ids
//

#define IDS_SCRIPTS_NAME                        1
#define IDS_SCRIPTS_NAME_MACHINE                2
#define IDS_SCRIPTS_NAME_USER                   3
#define IDS_NAME                                4
#define IDS_STATE                               5
#define IDS_SETTING                             6
#define IDS_PARAMETERS                          7
#define IDS_ENABLED                             8
#define IDS_DISABLED                            9
#define IDS_NOTCONFIGURED                      10
#define IDS_LOGON                              11
#define IDS_LOGOFF                             12
#define IDS_STARTUP                            13
#define IDS_SHUTDOWN                           14
#define IDS_BROWSEFILTER                       15
#define IDS_BROWSE                             16
#define IDS_SCRIPT_EDIT                        17
#define IDS_SCRIPT_FILTER                      18
#define IDS_POLICY_NAME                        19
#define IDS_POLICY_NAME_MACHINE                20
#define IDS_POLICY_NAME_USER                   21
#define IDS_TEMPLATES                          22
#define IDS_TEMPLATESDESC                      23
#define IDS_SIZE                               24
#define IDS_MODIFIED                           25
#define IDS_POLICYFILTER                       26
#define IDS_POLICYTITLE                        27
#define IDS_DEFAULTTEMPLATES                   28
#define IDS_LISTBOX_SHOW                       29
#define IDS_VALUE                              31
#define IDS_VALUENAME                          32
#define IDS_VALUENAMENOTUNIQUE                 33
#define IDS_EMPTYVALUENAME                     34
#define IDS_VALUEDATANOTUNIQUE                 35
#define IDS_EMPTYVALUEDATA                     36
#define IDS_FILTERING                          37
#define IDS_FILTERINGDESC                      38
#define IDS_ADDITIONALTTEMPLATES               39

#define IDS_GPONAME                            41
#define IDS_MULTIPLEGPOS                       42
#define IDS_DESCTEXT                           43
#define IDS_LASTEXECUTED                       44
#define IDS_SAVEFAILED                         45
#define IDS_DISPLAYPROPERTIES                  46
#define IDS_EXTRAREGSETTINGS                   47
#define IDS_STRINGTOOLONG                      48
#define IDS_WORDTOOLONG                        49
#define IDS_ErrOUTOFMEMORY                     50

#define IDS_ParseErr_UNEXPECTED_KEYWORD        51
#define IDS_ParseErr_UNEXPECTED_EOF            52
#define IDS_ParseErr_DUPLICATE_KEYNAME         53
#define IDS_ParseErr_DUPLICATE_VALUENAME       54
#define IDS_ParseErr_NO_KEYNAME                55
#define IDS_ParseErr_NO_VALUENAME              56
#define IDS_ParseErr_NO_VALUE                  57
#define IDS_ParseErr_NOT_NUMERIC               58
#define IDS_ParseErr_DUPLICATE_ITEMNAME        59
#define IDS_ParseErr_NO_ITEMNAME               60
#define IDS_ParseErr_DUPLICATE_ACTIONLIST      61
#define IDS_ParseErr_STRING_NOT_FOUND          62
#define IDS_ParseErr_UNMATCHED_DIRECTIVE       63
#define IDS_ParseErr_DUPLICATE_HELP            64
#define IDS_ParseErr_DUPLICATE_CLIENTEXT       65
#define IDS_ParseErr_INVALID_CLIENTEXT         66
#define IDS_ParseErr_DUPLICATE_SUPPORTED       67
#define IDS_ParseErr_MISSINGVALUEON_OR_OFF     68

#define IDS_ParseFmt_MSG_FORMAT                90
#define IDS_ParseFmt_FOUND                     91
#define IDS_ParseFmt_EXPECTED                  92
#define IDS_ParseFmt_FATAL                     93

#define IDS_ENTRYREQUIRED                     100
#define IDS_INVALIDNUM                        101
#define IDS_NUMBERTOOLARGE                    102
#define IDS_NUMBERTOOSMALL                    103
#define IDS_POLICYCHANGEDFAILED               104
#define IDS_INVALIDADMFILE                    105

#define IDS_IPSEC_NAME                        200
#define IDS_PSCHED_NAME                       201

#define IDS_LOGON_DESC                        225
#define IDS_LOGOFF_DESC                       226
#define IDS_STARTUP_DESC                      227
#define IDS_SHUTDOWN_DESC                     228
#define IDS_SCRIPTS_DESC                      229
#define IDS_SCRIPTS_USER_DESC                 230
#define IDS_SCRIPTS_COMPUTER_DESC             231
#define IDS_SCRIPTS_LOGON                     232
#define IDS_SCRIPTS_LOGOFF                    233
#define IDS_SCRIPTS_STARTUP                   234
#define IDS_SCRIPTS_SHUTDOWN                  235
#define IDS_POLICY_DESC                       236
#define IDS_NONE                              237
#define IDS_RSOP_ADMFAILED                    238

#define IDS_BINARYDATA                        240
#define IDS_UNKNOWNDATA                       241
#define IDS_EXSETROOT_DESC                    242
#define IDS_EXSET_DESC                        243
#define IDS_PREFERENCE                        246
#define IDS_SUPPORTEDDESC                     247
#define IDS_NOSUPPORTINFO                     248

#define IDS_FAILED_RSOPFMT                    250


//
// Menus
//

#define IDM_TEMPLATES            1
#define IDM_TEMPLATES2           3
#define IDM_FILTERING            4


//
// Icons
//

#define IDI_POLICY               1
#define IDI_POLICY2              2
#define IDI_POLICY3              3
#define IDI_DOCUMENT             4
#define IDI_SCRIPT               5
#define IDI_FILTER               6


//
// Bitmaps
//

#define IDB_16x16                1
#define IDB_32x32                2


//
// Dialogs
//

#define IDD_SCRIPT             100
#define IDC_SCRIPT_TITLE       101
#define IDC_SCRIPT_HEADING     102
#define IDC_SCRIPT_LIST        103
#define IDC_SCRIPT_UP          104
#define IDC_SCRIPT_DOWN        105
#define IDC_SCRIPT_ADD         106
#define IDC_SCRIPT_EDIT        107
#define IDC_SCRIPT_REMOVE      108
#define IDC_SCRIPT_SHOW        109

#define IDD_SCRIPT_EDIT        150
#define IDC_SCRIPT_NAME        151
#define IDC_SCRIPT_ARGS        152
#define IDC_SCRIPT_BROWSE      153


#define IDD_POLICY             200
#define IDC_POLICY             201
#define IDC_POLICY_TITLE       202
#define IDC_POLICY_SETTINGS    203
#define IDC_POLICY_PREVIOUS    204
#define IDC_POLICY_NEXT        205
#define IDC_POLICYICON         206
#define IDC_NOCONFIG           207
#define IDC_ENABLED            208
#define IDC_DISABLED           209
#define IDC_SUPPORTED          210
#define IDC_SUPPORTEDTITLE     211
#define IDD_SETTINGCTRL       1000

#define IDD_POLICY_HELP        225
#define IDC_POLICY_HELP        226

#define IDD_POLICY_PRECEDENCE  275
#define IDC_POLICY_PRECEDENCE  276

#define IDD_TEMPLATES          300
#define IDC_TEMPLATE_TEXT      301
#define IDC_TEMPLATELIST       302
#define IDC_ADDTEMPLATES       303
#define IDC_REMOVETEMPLATES    304

#define IDD_POLICY_LBADD       400
#define IDD_POLICY_LBADD2      401
#define IDC_POLICY_VALUENAME   402
#define IDC_POLICY_VALUEDATA   403

#define IDD_POLICY_SHOWLISTBOX 500
#define IDC_POLICY_LISTBOX     501
#define IDC_POLICY_ADD         502
#define IDC_POLICY_REMOVE      503

#define IDD_POLICY_FILTERING   600
#define IDC_SUPPORTEDOPTION    601
#define IDC_FILTERLIST         602
#define IDC_SELECTALL          603
#define IDC_DESELECTALL        604
#define IDC_SHOWCONFIG         605
#define IDC_SHOWPOLICIES       606
#define IDC_SUPPORTEDONTITLE   607

#define IDC_STATIC             608
#define IDC_FILTERING_ICON     609


//
// Help ids
//

#define IDH_SCRIPT_TITLE         1
#define IDH_SCRIPT_HEADING       2
#define IDH_SCRIPT_LIST          3
#define IDH_SCRIPT_UP            4
#define IDH_SCRIPT_DOWN          5
#define IDH_SCRIPT_ADD           6
#define IDH_SCRIPT_EDIT          7
#define IDH_SCRIPT_REMOVE        8
#define IDH_SCRIPT_SHOW          9

#define IDH_SCRIPT_NAME         10
#define IDH_SCRIPT_ARGS         11
#define IDH_SCRIPT_BROWSE       12


//
// Error dialog defines
//

#define IDD_ERROR_ADMTEMPLATES  800
#define IDC_ERRORTEXT           801
#define IDC_DETAILSBORDER       802
#define IDC_DETAILSTEXT         803
#define IDC_ERROR_ICON          804



//
// Global variables
//

extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;
extern TCHAR g_szSnapInLocation[];
extern CRITICAL_SECTION  g_ADMCritSec;
extern TCHAR g_szDisplayProperties[];


//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#ifndef NORM_STOP_ON_NULL
#define NORM_STOP_ON_NULL         0x10000000
#endif


//
// Help
//

#define HELP_FILE           TEXT("gptext.hlp")
#define IDH_HELPFIRST       5000


//
// Structures
//

#define MAX_DISPLAYNAME_SIZE    100


typedef struct _RESULTITEM
{
    DWORD        dwID;
    DWORD        dwNameSpaceItem;
    INT          iStringID;
    INT          iDescStringID;
    INT          iImage;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
} RESULTITEM, *LPRESULTITEM;


typedef struct _NAMESPACEITEM
{
    DWORD        dwID;
    DWORD        dwParent;
    INT          iStringID;
    INT          iDescStringID;
    INT          cChildren;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
    INT          cResultItems;
    LPRESULTITEM pResultItems;
    const GUID   *pNodeID;
} NAMESPACEITEM, *LPNAMESPACEITEM;



//
// Functions to create class factories
//

HRESULT CreateScriptsComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);
BOOL InitScriptsNameSpace();
HRESULT RegisterScripts(void);
HRESULT UnregisterScripts(void);

HRESULT CreatePolicyComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);
HRESULT RegisterPolicy(void);
HRESULT UnregisterPolicy(void);


HRESULT RegisterIPSEC(void);
HRESULT UnregisterIPSEC(void);
HRESULT RegisterPSCHED(void);
HRESULT UnregisterPSCHED(void);
HRESULT RegisterWireless(void);
HRESULT UnregisterWireless(void);


//
// Private message that refreshes the button status
//

#define WM_REFRESHDISPLAY   (WM_USER + 532)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\ipsecext.h ===
HRESULT
CreateChildPath(
    LPWSTR pszParentPath,
    LPWSTR pszChildComponent,
    BSTR * ppszChildPath
    );

HRESULT
RetrieveIPSECPolicyFromDS(
    PGROUP_POLICY_OBJECT pGPOInfo,
    LPWSTR  pszIPSecPolicy,
    LPWSTR pszIPSecPolicyName,
    LPWSTR pszIPSecPolicyDescription
    );


DWORD
DeleteIPSECPolicyFromRegistry(
    );

DWORD
WriteIPSECPolicyToRegistry(
    LPWSTR pszIPSecPolicyPath,
    LPWSTR pszIPSecPolicyName,
    LPWSTR pszIPSecPolicyDescription
    );


HRESULT
RegisterIPSEC(void);

HRESULT
UnregisterIPSEC(void);

VOID
PingPolicyAgent(
    );


#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) { \
        goto error;  \
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\psched.cpp ===
#include "gptext.h"
#include <initguid.h>
#include <devioctl.h>

#define GPEXT_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{426031c0-0b47-4852-b0ca-ac3d37bfcb39}")

#define DriverName   TEXT("\\\\.\\PSCHED")

#define IOCTL_PSCHED_ZAW_EVENT  CTL_CODE( \
                                        FILE_DEVICE_NETWORK, \
                                        20, \
                                        METHOD_BUFFERED, \
                                        FILE_ANY_ACCESS \
                                        )

HRESULT
RegisterPSCHED(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;
    TCHAR szBuffer[512];


    lResult = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    GPEXT_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp
                    );

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    LoadString (g_hInstance, IDS_PSCHED_NAME, szBuffer, ARRAYSIZE(szBuffer));

    RegSetValueEx (
                hKey,
                NULL,
                0,
                REG_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    RegSetValueEx (
                hKey,
                TEXT("ProcessGroupPolicy"),
                0,
                REG_SZ,
                (LPBYTE)TEXT("ProcessPSCHEDPolicy"),
                (lstrlen(TEXT("ProcessPSCHEDPolicy")) + 1) * sizeof(TCHAR)
                );

    szBuffer[0] = L'\0';
    wcscpy(szBuffer, L"gptext.dll");

    RegSetValueEx (
                hKey,
                TEXT("DllName"),
                0,
                REG_EXPAND_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    dwValue = 1;
    RegSetValueEx (
                hKey,
                TEXT("NoUserPolicy"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegSetValueEx (
                hKey,
                TEXT("NoGPOListChanges"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegCloseKey (hKey);

    return S_OK;
}


HRESULT
UnregisterPSCHED(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);

    return S_OK;
}

VOID
PingPsched()
{
    HANDLE   PschedDriverHandle;
    ULONG    BytesReturned;
    BOOL     IOStatus;

    PschedDriverHandle = CreateFile(
                             DriverName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             NULL
                             );

    if (PschedDriverHandle != INVALID_HANDLE_VALUE) {

        IOStatus = DeviceIoControl(
                       PschedDriverHandle,
                       IOCTL_PSCHED_ZAW_EVENT,
                       NULL,
                       0,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL
                       );

        CloseHandle(PschedDriverHandle);
    }
}

DWORD WINAPI
ProcessPSCHEDPolicy(
    IN DWORD dwFlags,                           // GPO_INFO_FLAGS
    IN HANDLE hToken,                           // User or machine token
    IN HKEY hKeyRoot,                           // Root of registry
    IN PGROUP_POLICY_OBJECT  pDeletedGPOList,   // Linked list of deleted GPOs
    IN PGROUP_POLICY_OBJECT  pChangedGPOList,   // Linked list of changed GPOs
    IN ASYNCCOMPLETIONHANDLE pHandle,           // For asynchronous completion
    IN BOOL *pbAbort,                           // If true, then abort GPO processing
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback // Callback function for displaying status messages
    )

{
    HRESULT hr = S_OK;

    if (pDeletedGPOList || pChangedGPOList) 
    {
        PingPsched();
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\ipsecext.cpp ===
#include "gptext.h"
#include <initguid.h>
#include <iadsp.h>
#include "ipsecext.h"


#define GPEXT_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{e437bc1c-aa7d-11d2-a382-00c04f991e27}")

#define POLICY_PATH   TEXT("Software\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy")

LPWSTR GetAttributes[] = {L"ipsecOwnersReference", L"ipsecName", L"description"};


HRESULT
RegisterIPSEC(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;
    TCHAR szBuffer[512];


    lResult = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    GPEXT_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp
                    );

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    LoadString (g_hInstance, IDS_IPSEC_NAME, szBuffer, ARRAYSIZE(szBuffer));

    RegSetValueEx (
                hKey,
                NULL,
                0,
                REG_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    RegSetValueEx (
                hKey,
                TEXT("ProcessGroupPolicy"),
                0,
                REG_SZ,
                (LPBYTE)TEXT("ProcessIPSECPolicy"),
                (lstrlen(TEXT("ProcessIPSECPolicy")) + 1) * sizeof(TCHAR)
                );

    szBuffer[0] = L'\0';
    wcscpy(szBuffer, L"gptext.dll");

    RegSetValueEx (
                hKey,
                TEXT("DllName"),
                0,
                REG_EXPAND_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    dwValue = 1;
    RegSetValueEx (
                hKey,
                TEXT("NoUserPolicy"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegSetValueEx (
                hKey,
                TEXT("NoGPOListChanges"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegCloseKey (hKey);

    return S_OK;
}


HRESULT
UnregisterIPSEC(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);

    return S_OK;
}


DWORD WINAPI
ProcessIPSECPolicy(
    IN DWORD dwFlags,                           // GPO_INFO_FLAGS
    IN HANDLE hToken,                           // User or machine token
    IN HKEY hKeyRoot,                           // Root of registry
    IN PGROUP_POLICY_OBJECT  pDeletedGPOList,   // Linked list of deleted GPOs
    IN PGROUP_POLICY_OBJECT  pChangedGPOList,   // Linked list of changed GPOs
    IN ASYNCCOMPLETIONHANDLE pHandle,           // For asynchronous completion
    IN BOOL *pbAbort,                           // If true, then abort GPO processing
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback // Callback function for displaying status messages
    )

{

    WCHAR szIPSECPolicy[MAX_PATH];
    WCHAR szIPSECPolicyName[MAX_PATH];
    WCHAR szIPSECPolicyDescription[512];
    HRESULT hr = S_OK;
    PGROUP_POLICY_OBJECT pGPO = NULL;

    //
    // Call CoInitialize for all the COM work we're doing
    //

    hr = CoInitializeEx(NULL,0);
    if (FAILED(hr)) {
        goto error;
    }

    memset(szIPSECPolicy, 0, sizeof(WCHAR)*MAX_PATH);
    memset(szIPSECPolicyName, 0, sizeof(WCHAR)*MAX_PATH);
    memset(szIPSECPolicyDescription, 0, sizeof(WCHAR)*512);


    //
    // First process the Deleted GPO List. If there is a single
    // entry on the GPO list, just delete the entire list.
    // Example Rex->Cassius->Brutus. If the delete List has
    // Cassius to be deleted, then really, we shouldn't be deleting
    // our registry entry because we're interested in Brutus which
    // has not be deleted. But in our case, the pChangedGPOList will
    // have all the information, so Brutus gets written back in the
    // next stage.
    //

    if (pDeletedGPOList) {


       DeleteIPSECPolicyFromRegistry();

    }


    pGPO = pChangedGPOList;

    //
    // Since IPSEC is really interested in the last
    // GPO only, loop through till we hit the last
    // GPO and write that GPO only. In this case, Brutus now
    // gets written back into the registry.
    //

    if (pChangedGPOList) {

        while (pGPO->pNext)
        {

            pGPO = pGPO->pNext;
        }

        //
        // Now write the last GPOs information
        //

        hr = RetrieveIPSECPolicyFromDS(
                     pGPO,
                     szIPSECPolicy,
                     szIPSECPolicyName,
                     szIPSECPolicyDescription
                     );
        if (FAILED(hr)) {

            goto error;
        }


        hr = WriteIPSECPolicyToRegistry(
                    szIPSECPolicy,
                    szIPSECPolicyName,
                    szIPSECPolicyDescription
                    );
        if (FAILED(hr)) {
            goto error;
        }


    }

    PingPolicyAgent();

    CoUninitialize();

    return(ERROR_SUCCESS);

error:

    return(ERROR_POLICY_OBJECT_NOT_FOUND);
}


HRESULT
CreateChildPath(
    LPWSTR pszParentPath,
    LPWSTR pszChildComponent,
    BSTR * ppszChildPath
    )
{
    HRESULT hr = S_OK;
    IADsPathname     *pPathname = NULL;

    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_IADsPathname,
                (void**)&pPathname
                );
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Set(pszParentPath, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->AddLeafElement(pszChildComponent);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Retrieve(ADS_FORMAT_X500, ppszChildPath);
    BAIL_ON_FAILURE(hr);

error:
    if (pPathname) {
        pPathname->Release();
    }

    return(hr);
}



HRESULT
RetrieveIPSECPolicyFromDS(
    PGROUP_POLICY_OBJECT pGPOInfo,
    LPWSTR pszIPSecPolicy,
    LPWSTR pszIPSecPolicyName,
    LPWSTR pszIPSecPolicyDescription
    )
{
    LPWSTR pszMachinePath = NULL;
    BSTR pszMicrosoftPath = NULL;
    BSTR pszWindowsPath = NULL;
    BSTR pszIpsecPath = NULL;
    IDirectoryObject * pDirectoryObject = NULL;
    IDirectoryObject * pIpsecObject = NULL;
    BOOL bFound = FALSE;


    LPWSTR pszOwnersReference = L"ipsecOwnersReference";

    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAttributeEntries = NULL;
    DWORD dwNumAttributesReturned = 0;

    DWORD i = 0;
    PADS_ATTR_INFO pAttributeEntry = NULL;


    pszMachinePath = pGPOInfo->lpDSPath;

    // Build the fully qualified ADsPath for my object

    hr = CreateChildPath(
                pszMachinePath,
                L"cn=Microsoft",
                &pszMicrosoftPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszMicrosoftPath,
                L"cn=Windows",
                &pszWindowsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszWindowsPath,
                L"cn=ipsec",
                &pszIpsecPath
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsGetObject(
            pszIpsecPath,
            IID_IDirectoryObject,
            (void **)&pIpsecObject
            );
    BAIL_ON_FAILURE(hr);

    hr = pIpsecObject->GetObjectAttributes(
                        GetAttributes,
                        3,
                        &pAttributeEntries,
                        &dwNumAttributesReturned
                        );
    BAIL_ON_FAILURE(hr);

    if (dwNumAttributesReturned == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    //
    // Process the PathName
    //

    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"ipsecOwnersReference")) {

            wcscpy(pszIPSecPolicy, L"LDAP://");
            wcscat(pszIPSecPolicy, pAttributeEntry->pADsValues->DNString);
            bFound = TRUE;
            break;
        }
    }

    if (!bFound) {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Process the name
    //

    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"ipsecName")) {
            wcscat(pszIPSecPolicyName, pAttributeEntry->pADsValues->DNString);
            break;
        }
    }

    //
    // Process the description
    //

    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"description")) {
            wcscat(pszIPSecPolicyDescription, pAttributeEntry->pADsValues->DNString);
            break;
        }
    }


error:

    if (pAttributeEntries) {

        FreeADsMem(pAttributeEntries);
    }

    if (pIpsecObject) {
        pIpsecObject->Release();
    }

    if (pszMicrosoftPath) {
        SysFreeString(pszMicrosoftPath);
    }

    if (pszWindowsPath) {
        SysFreeString(pszWindowsPath);
    }

    if (pszIpsecPath) {
        SysFreeString(pszIpsecPath);
    }

    return(hr);

}


DWORD
DeleteIPSECPolicyFromRegistry(
    )
{

    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwDisp = 0;


    dwError = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Policies\\Microsoft\\Windows\\IPSec"),
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp
                    );
    if (dwError) {
        goto error;
    }


    dwError = RegDeleteKey(
                    hKey,
                    L"GPTIPSECPolicy"
                    );

/*
    dwError = RegDeleteValue(
                    hKey,
                    TEXT("DSIPSECPolicyPath")
                    );

    dwError = RegDeleteValue(
                    hKey,
                    TEXT("DSIPSECPolicyName")
                    );*/
error:

    if (hKey) {

        RegCloseKey (hKey);

    }

    return(dwError);
}

DWORD
WriteIPSECPolicyToRegistry(
    LPWSTR pszIPSecPolicyPath,
    LPWSTR pszIPSecPolicyName,
    LPWSTR pszIPSecPolicyDescription
    )
{
    DWORD dwError = 0;
    DWORD dwDisp = 0;
    HKEY hKey = NULL;
    DWORD dwFlags = 1;

    dwError = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    POLICY_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp
                    );
    if (dwError) {
        goto error;
    }


    if (pszIPSecPolicyPath && *pszIPSecPolicyPath) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSIPSECPolicyPath"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszIPSecPolicyPath,
                       (lstrlen(pszIPSecPolicyPath) + 1) * sizeof(TCHAR)
                       );

        dwFlags = 1;

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSIPSECPolicyFlags"),
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwFlags,
                        sizeof(dwFlags)
                       );

    }


    if (pszIPSecPolicyName && *pszIPSecPolicyName) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSIPSECPolicyName"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszIPSecPolicyName,
                       (lstrlen(pszIPSecPolicyName) + 1) * sizeof(TCHAR)
                       );
    }





    if (pszIPSecPolicyDescription && *pszIPSecPolicyDescription) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSIPSECPolicyDescription"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszIPSecPolicyDescription,
                       (lstrlen(pszIPSecPolicyDescription) + 1) * sizeof(TCHAR)
                       );
    }

error:

    if (hKey) {

        RegCloseKey (hKey);

    }

    return(dwError);

}


VOID
PingPolicyAgent(
    )
{
    HANDLE hPolicyChangeEvent = NULL;

    hPolicyChangeEvent = OpenEvent(
                             EVENT_ALL_ACCESS,
                             FALSE,
                             L"IPSEC_POLICY_CHANGE_EVENT"
                             );

    if (hPolicyChangeEvent) {
        SetEvent(hPolicyChangeEvent);
        CloseHandle(hPolicyChangeEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\scriplog.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        ScripLog.cpp
//
// Contents:
//
// History:     9-Aug-99       NishadM    Created
//
//---------------------------------------------------------------------------

#include "gptext.h"
#include "scriplog.h"
#include <wbemtime.h>


//
// macros
//

#define MakeScriptId( wszKey, wszGpoId, wszSomId, wszType ) \
                        wszKey = (LPWSTR) LocalAlloc( LPTR, (wcslen(wszGpoId) + wcslen(wszSomId)  + wcslen(wszType) + 3) * sizeof(WCHAR) ); \
                        if ( wszKey ) \
                        { \
                        wcscpy( wszKey, wszGpoId );wcscat( wszKey, L"-" ); \
                        wcscat( wszKey, wszSomId );wcscat( wszKey, L"-" ); \
                        wcscat( wszKey, wszType ); \
                        }

//*************************************************************
//
//  CScriptsLogger::CScriptsLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CScriptsLogger::CScriptsLogger( IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_pWbemServices(pWbemServices)
{
    //
    // Policy Object, RSOP_PolicySetting in MOF
    //

    m_xbstrPath = L"__PATH";
    if ( !m_xbstrPath )
        return;

    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrName = L"name";
    if ( !m_xbstrName )
        return;

    m_xbstrGPO = L"GPOID";
    if ( !m_xbstrGPO )
        return;

    m_xbstrSOM = L"SOMID";
    if ( !m_xbstrSOM )
        return;

    m_xbstrOrderClass = L"precedence";
    if ( !m_xbstrOrderClass )
        return;

    //
    // Script Policy Object, RSOP_ScriptPolicySetting in MOF
    //

    m_xbstrScriptPolicySetting = L"RSOP_ScriptPolicySetting";
    if ( !m_xbstrScriptPolicySetting )
        return;

    //
    // ScriptType field of RSOP_ScriptPolicySetting in the MOF
    //

    m_xbstrScriptType = L"ScriptType";
    if ( !m_xbstrScriptType )
        return;

    //
    // ScriptList field of RSOP_ScriptPolicySetting in MOF
    //

    m_xbstrScriptList = L"ScriptList";
    if ( !m_xbstrScriptList )
        return;

    //
    // Order field of RSOP_ScriptPolicySetting in MOF
    //

    m_xbstrOrder = L"scriptOrder";
    if ( !m_xbstrOrder )
        return;

    //
    // WBEM version of CF for RSOP_ScriptPolicySetting
    //

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrScriptPolicySetting,
                                             0L,
                                             0,
                                             &m_xScriptPolicySetting,
                                             0 );
    if ( FAILED(hr) )
    {
        return;
    }

    //
    // individual script commands, RSOP_ScriptCmd in MOF
    //

    m_xbstrScriptCommand = L"RSOP_ScriptCmd";
    if ( !m_xbstrScriptCommand )
        return;

    //
    // Script field of RSOP_ScriptCmd
    //

    m_xbstrScript = L"Script";
    if ( !m_xbstrScript )
        return;

    //
    // Arguments field of RSOP_ScriptCmd
    //

    m_xbstrArguments = L"Arguments";
    if ( !m_xbstrArguments )
        return;

    //
    // executionTime field of RSOP_ScriptCmd
    //

    m_xbstrExecutionTime = L"executionTime";
    if ( !m_xbstrExecutionTime )
        return;

    //
    // WBEM version of CF for RSOP_ScriptCmd
    //

    hr = m_pWbemServices->GetObject( m_xbstrScriptCommand,
                                     0L,
                                     0,
                                     &m_xScriptCommand,
                                     0 );
    if ( FAILED(hr) )
    {
        return;
    }

    //
    // spawn an instance of RSOP_ScriptPolicySetting
    //

    hr = m_xScriptPolicySetting->SpawnInstance( 0, &m_pInstance );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: spawn instance failed, %d."), hr ));
        return;
    }

    m_bInitialized = TRUE;
}

//*************************************************************
//
//  CScriptsLogger::Log()
//
//  Purpose:    Logs an instance of registry policy object
//
//
//*************************************************************

HRESULT
CScriptsLogger::Log(PRSOP_ScriptList    pList,
                    LPWSTR              wszGPOID,
                    LPWSTR              wszSOMID,
                    LPWSTR              wszRSOPGPOID,
                    DWORD               cOrder )
{
    HRESULT hr = S_OK;
    VARIANT var;

    //
    // if CScriptsLogger is initialized
    //

    if ( !m_bInitialized )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: object not initialized.")));
        return E_UNEXPECTED;
    }

    //
    // create a SafeArray of commands
    //
    XSafeArray xSafeArray = MakeSafeArrayOfScripts( pList );

    if ( !xSafeArray )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: could not create safe array of scripts.")));
        return hr;
    }

    //
    // set "id" for RSOP_PolicySetting
    //

    LPCWSTR wszType = ScriptTypeString( GetScriptType(pList) );
    XPtrLF<WCHAR> wszId;
    MakeScriptId( wszId, wszGPOID, wszSOMID, wszType );

    if ( wszId )
    {
        XBStr xId( wszId );
        if ( !xId )
        {
            DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: ID is NULL.")));
            return E_OUTOFMEMORY;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xId;
        hr = m_pInstance->Put( m_xbstrId, 0, &var, 0 );
        if ( FAILED (hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: put failed, %d."), hr ));
            return hr;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: memory allocation failed.")));
        return hr;
    }

    //
    // set "name" for RSOP_PolicySetting
    //

    XBStr xName( L"Group Policy Object Scripts" );
    var.vt = VT_BSTR;
    var.bstrVal = xName;
    hr = m_pInstance->Put( m_xbstrName, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: put name failed, %d."), hr ));
        return hr;
    }

    //
    // set "GPOID" for RSOP_PolicySetting
    //

    var.vt = VT_BSTR;
    var.bstrVal = wszRSOPGPOID;
    hr = m_pInstance->Put( m_xbstrGPO, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: put GPOID failed, %d."), hr ));
        return hr;
    }

    //
    // set "SOMID" for RSOP_PolicySetting
    //

    var.vt = VT_BSTR;
    var.bstrVal = wszSOMID;
    hr = m_pInstance->Put( m_xbstrSOM, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: put SOMID failed, %d."), hr ));
        return hr;
    }

    //
    // set "precedence" for RSOP_PolicySetting
    //

    var.vt = VT_I4;
    var.lVal = 1;
    hr = m_pInstance->Put( m_xbstrOrderClass, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: put mergeOrder_Class failed, %d."), hr ));
        return hr;
    }

    //
    // set the "ScriptType" for RSOP_ScriptPolicySetting
    //

    var.vt = VT_I4;
    var.lVal = (LONG) GetScriptType(pList);
    hr = m_pInstance->Put( m_xbstrScriptType, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: put ScriptType failed, %d."), hr ));
        return hr;
    }

    //
    // set the "ScriptList" for RSOP_ScriptPolicySetting
    //

    var.vt = VT_ARRAY | VT_UNKNOWN;
    var.parray = xSafeArray;
    hr = m_pInstance->Put( m_xbstrScriptList, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: put ScriptList failed, %d."), hr ));
        return hr;
    }

    //
    // set the "Order" for RSOP_ScriptPolicySetting
    //

    var.vt = VT_I4;
    var.lVal = cOrder;
    hr = m_pInstance->Put( m_xbstrOrder, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Log: put Order failed, %d."), hr ));
        return hr;
    }

    //
    // commit the instance of RSOP_ScriptPolicySetting
    //

    hr = m_pWbemServices->PutInstance( m_pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

    return hr;
}

HRESULT
CScriptsLogger::Update( PRSOP_ScriptList    pList,
                        LPCWSTR             wszGPOID,
                        LPCWSTR             wszSOMID )
{
    if ( !m_bInitialized )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Update: object not initialized.")));
        return E_UNEXPECTED;
    }

    XInterface<IEnumWbemClassObject> xEnum;

    //
    // create an enumeration of RSOP_ScriptPolicySetting objects
    //

    HRESULT hr = m_pWbemServices->CreateInstanceEnum(   m_xbstrScriptPolicySetting,
                                                        WBEM_FLAG_SHALLOW,
                                                        NULL,
                                                        &xEnum );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Update: CreateInstanceEnum() failed, %d."), hr ));
        return hr;
    }

    ULONG ulReturned = 1;
    LONG TIMEOUT = -1;
    LPWSTR  wszId;
    LPCWSTR wszType = ScriptTypeString( GetScriptType( pList ) );

    MakeScriptId( wszId, wszGPOID, wszSOMID, wszType );

    if ( !wszId )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Update: memory allocation error, %d."), hr ));
        return hr;
    }

    XPtrLF<WCHAR> xId = wszId;

    while ( ulReturned == 1 && SUCCEEDED( hr ) )
    {
        XInterface<IWbemClassObject> xInstance;
        //
        // for every object
        //

        hr = xEnum->Next( TIMEOUT,
                          1,
                          &xInstance,
                          &ulReturned );

        if ( FAILED( hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Update: enumeration failed, %d."), hr ));
        }
        else if ( ulReturned == 1 )
        {
            VARIANT var;

            VariantInit( &var );

            //
            // get the "id" from RSOP_ScriptPolicySetting
            //

            hr = xInstance->Get( m_xbstrId,
                                 0L,
                                 &var,
                                 0,
                                 0 );
            if ( SUCCEEDED(hr) )
            {
                XVariant xVar(&var);
                
                if ( !wcscmp( var.bstrVal, wszId ) )
                {
                    XSafeArray xSafeArray = MakeSafeArrayOfScripts( pList );

                    if ( xSafeArray )
                    {

                        //
                        // set the "ScriptList" for RSOP_ScriptPolicySetting
                        //

                        VARIANT var2;
                        var2.vt = VT_ARRAY | VT_UNKNOWN;
                        var2.parray = xSafeArray;

                        hr = xInstance->Put( m_xbstrScriptList, 0, &var2, 0 );
                        if ( SUCCEEDED (hr) )
                        {
                            //
                            // commit the instance of RSOP_ScriptPolicySetting
                            //

                            hr = m_pWbemServices->PutInstance( xInstance, WBEM_FLAG_UPDATE_ONLY, NULL, NULL );

                            if ( FAILED( hr ) )
                            {
                                DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Update: PutInstance() failed, %d."), hr ));
                            }
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Update: Put ScriptList failed, %d."), hr ));
                        }
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Update: could not create safearray.")));
                    }
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Update: pInstance->Get() failed, %d."), hr ));
            }
        }
    }

    return hr;
}

HRESULT
CScriptsLogger::Delete( PRSOP_ScriptList pList )
{
    if ( !m_bInitialized )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Delete: object not initialized.")));
        return E_UNEXPECTED;
    }

    XInterface<IEnumWbemClassObject> xEnum;

    //
    // create an enumeration of RSOP_ScriptPolicySetting objects
    //

    HRESULT hr = m_pWbemServices->CreateInstanceEnum(   m_xbstrScriptPolicySetting,
                                                        WBEM_FLAG_SHALLOW,
                                                        NULL,
                                                        &xEnum );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Delete: could not enumerate instances.")));
    }

    ULONG ulReturned = 1;
    LONG TIMEOUT = -1;
    ScriptType type = GetScriptType( pList );

    while ( ulReturned == 1 )
    {
        XInterface<IWbemClassObject> xInstance;
        //
        // for every object
        //

        hr = xEnum->Next( TIMEOUT,
                          1,
                          &xInstance,
                          &ulReturned );

        if ( FAILED( hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Delete: could not get next instance, %d."), hr));
        }
        else if ( ulReturned == 1 )
        {
            VARIANT var;
            VariantInit( &var );

            //
            // get the "type" from RSOP_ScriptPolicySetting
            //

            hr = xInstance->Get( m_xbstrScriptType,
                                 0L,
                                 &var,
                                 0,
                                 0 );
            if ( SUCCEEDED(hr) )
            {
                //
                // if type field matches,
                //

                if ( var.lVal == (long) type )
                {
                    hr = xInstance->Get( m_xbstrPath,
                                         0L,
                                         &var,
                                         0,
                                         0 );
                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // delete the instance
                        // we could optimize and return here but,
                        // by not doing so, we cleanup all the objects
                        //

                        hr = m_pWbemServices->DeleteInstance(   var.bstrVal,
                                                                0L,
                                                                0,
                                                                0 );
                        if ( FAILED( hr ) )
                        {
                            DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Delete: could not delete instance, %d."), hr ));
                        }
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Delete: could not get type value, %d."), hr));
                    }

                    VariantClear( &var );
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsLogger::Delete: could not get type, %d."), hr));
            }
        }
    }

    return hr;
}

IUnknown*
CScriptsLogger::PutScriptCommand( LPCWSTR wszCommand, LPCWSTR wszParams, SYSTEMTIME* pExecTime )
{
    IUnknown* pUnk = 0;

    //
    // if CScriptsLogger is initialized
    //

    if ( !m_bInitialized )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::PutScriptCommand: object not initialized.")));
        return pUnk;
    }

    IWbemClassObject*   pInstance = 0;

    //
    // spawn an instance of RSOP_ScriptCmd
    //

    HRESULT hr = m_xScriptCommand->SpawnInstance( 0, &pInstance );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::PutScriptCommand: spawn instance failed, %d."), hr ));
        return pUnk;
    }

    XInterface<IWbemClassObject> xInstance( pInstance );
    VARIANT var;

    //
    // set the Script field for RSOP_ScriptCmd
    //
    XBStr xCommand( ( LPWSTR ) wszCommand );

    var.vt = VT_BSTR;
    var.bstrVal = xCommand;
    hr = pInstance->Put( m_xbstrScript, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::PutScriptCommand: put Script failed, %d."), hr ));
        return pUnk;
    }

    //
    // set the Arguments field for RSOP_ScriptCmd
    //
    XBStr xParams( ( LPWSTR ) wszParams );

    var.vt = VT_BSTR;
    var.bstrVal = xParams;
    hr = pInstance->Put( m_xbstrArguments, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::PutScriptCommand: put Arguments failed, %d."), hr ));
        return pUnk;
    }

    //
    // set the executionTime field for RSOP_ScriptCmd
    //
    XBStr xExecutionTime;

    hr = SystemTimeToWbemTime( *pExecTime, xExecutionTime );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::PutScriptCommand: put SystemTimeToWbemTime failed, %d."), hr ));
        return pUnk;
    }
    
    var.vt = VT_BSTR;
    var.bstrVal = xExecutionTime;
    hr = pInstance->Put( m_xbstrExecutionTime, 0, &var, 0 );
    if ( FAILED (hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsLogger::PutScriptCommand: put executionTime failed, %d."), hr ));
        return pUnk;
    }

    pInstance->QueryInterface( IID_IUnknown, (void **)&pUnk);

    return pUnk;
}

LPSAFEARRAY
CScriptsLogger::MakeSafeArrayOfScripts( PRSOP_ScriptList    pList )
{
    SAFEARRAYBOUND arrayBound[1];

    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = GetScriptCount( pList );

    //
    // create a SafeArray of RSOP_ScriptCmd
    //

    SAFEARRAY *pSafeArray = SafeArrayCreate( VT_UNKNOWN, 1, arrayBound );

    if ( pSafeArray )
    {
        DWORD   nCommand = GetScriptCount( pList );

        if ( nCommand )
        {
            LPCWSTR szCommand = 0, szParams = 0;
            void*   pv;
            long    dwIndex = 0;
            SYSTEMTIME* pExecTime = 0;
            
            //
            // populate the array
            //

            GetFirstScript( pList, &pv, &szCommand, &szParams, &pExecTime );

            do
            {
                IUnknown* pUnk = PutScriptCommand( szCommand, szParams, pExecTime );

                SafeArrayPutElement( pSafeArray, &dwIndex, pUnk );

                nCommand--;
                dwIndex++;

                GetNextScript( pList, &pv, &szCommand, &szParams, &pExecTime );

            } while ( nCommand );
        }
    }

    return pSafeArray;
}

//*************************************************************
//
//  LogScriptsRsopData()
//
//  Purpose:    Logs scripts Rsop data to Cimom database
//
//  Return:     True if successful
//
//*************************************************************

HRESULT
LogScriptsRsopData( RSOPScriptList  pScriptList,
                    IWbemServices*  pWbemServices,
                    LPCWSTR         wszGPOID,
                    LPCWSTR         wszSOMID,
                    LPCWSTR         wszRSOPGPOID,
                    DWORD           cOrder )

{
    PRSOP_ScriptList    pList = (PRSOP_ScriptList) pScriptList;
    HRESULT             hr = E_POINTER;
    void*               pv = 0;

    if ( wszGPOID && wszSOMID && pWbemServices && pScriptList )
    {
        CScriptsLogger scriptsLogger( pWbemServices );

        //
        // RSOP logging for scripts ext
        //

        hr = scriptsLogger.Log( pList, (LPWSTR)wszGPOID, (LPWSTR)wszSOMID, (LPWSTR)wszRSOPGPOID, cOrder );
    }

    return hr;
}

HRESULT
UpdateScriptsRsopData(  RSOPScriptList  pScriptList,
                        IWbemServices*  pWbemServices,
                        LPCWSTR         wszGPOID,
                        LPCWSTR         wszSOMID )
{
    PRSOP_ScriptList        pList = (PRSOP_ScriptList) pScriptList;
    HRESULT                 hr = E_POINTER;
    void*                   pv = 0;

    if ( wszGPOID && pWbemServices && wszSOMID && pScriptList )
    {
        CScriptsLogger scriptsLogger( pWbemServices );

        //
        // RSOP update for scripts
        //

        hr = scriptsLogger.Update( pList, wszGPOID, wszSOMID );
    }

    return hr;
}

//*************************************************************
//
//  DeleteScriptsRsopData()
//
//  Purpose:    Logs scripts Rsop data to Cimom database
//
//  Return:     True if successful
//
//*************************************************************

HRESULT
DeleteScriptsRsopData( RSOPScriptList  pScriptList, IWbemServices*  pWbemServices )
{
    PRSOP_ScriptList        pList = (PRSOP_ScriptList) pScriptList;
    HRESULT                 hr = E_POINTER;
    void*                   pv = 0;

    if ( pWbemServices && pScriptList )
    {
        CScriptsLogger scriptsLogger( pWbemServices );

        //
        // delete all previous instances of RSOP_ScriptPolicySetting
        // with matching type
        //

        hr = scriptsLogger.Delete( pList );
    }

    return hr;
}

LPWSTR
GetNamespace( IWbemServices* pWbemServices )
{
    LPWSTR  szNamespace = 0;

    if ( pWbemServices )
    {
        BSTR bstrClass = SysAllocString( L"RSOP_ScriptPolicySetting" );

        if ( bstrClass )
        {
            IEnumWbemClassObject *pEnum;
            HRESULT hr;

            hr = pWbemServices->CreateInstanceEnum( bstrClass,
                                                    WBEM_FLAG_SHALLOW,
                                                    0,
                                                    &pEnum );
            if ( SUCCEEDED ( hr ) )
            {
                IWbemClassObject *pInstance = 0;
                ULONG ulReturned = 1;

                hr = pEnum->Next(   -1,
                                    1,
                                    &pInstance,
                                    &ulReturned );
                if ( SUCCEEDED( hr ) )
                {
                    BSTR bstrPath = SysAllocString( L"__PATH" );
                    VARIANT var;
                    VariantInit( &var );

                    hr = pInstance->Get( bstrPath,
                                         0L,
                                         &var,
                                         0,
                                         0 );
                    if ( SUCCEEDED( hr ) )
                    {
                        szNamespace = wcschr( var.bstrVal, L':' );

                        if ( szNamespace )
                        {
                            *szNamespace = 0;
                        }
                        
                        szNamespace = (LPWSTR) LocalAlloc( LPTR, ( wcslen( var.bstrVal ) + 1 ) * sizeof(WCHAR) );

                        if ( szNamespace )
                        {
                            wcscpy( szNamespace, var.bstrVal );
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("GetNamespace: failed to allocate memory, %d."), GetLastError() ));
                        }
                        
                        VariantClear(&var);
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("GetNamespace: failed to get __PATH, %d."), hr ));
                    }
                    
                    pInstance->Release();
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("GetNamespace: failed to get instance, %d."), hr ));
                }
                pEnum->Release();
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("GetNamespace: failed to enumerate instances, %d."), hr ));
            }
            
            SysFreeString( bstrClass );
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("GetNamespace: failed to allocate memory, %d."), GetLastError() ));
        }
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("GetNamespace: bad IWbemServices pointer.")));
    }
    
    return szNamespace;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\scriplog.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        ScripLog.h
//
// Contents:
//
// History:     9-Aug-99       NishadM    Created
//
//---------------------------------------------------------------------------

#ifndef _SCRIPLOG_H_
#define _SCRIPLOG_H_

#include <initguid.h>
#include <wbemcli.h>
#include "smartptr.h"
#include "scrpdata.h"

class CScriptsLogger
{
public:
    CScriptsLogger( IWbemServices*  pWbemServices );

    //
    // Creates or Updates RSOP_ScriptPolicySetting
    //

    HRESULT
    Log(PRSOP_ScriptList        pList,
                LPWSTR          wszGPOID,
                LPWSTR          wszSOMID,
                LPWSTR          wszRSOPGPOID,
                DWORD           cOrder );

    //
    // Updates matching RSOP_ScriptPolicySetting
    //

    HRESULT
    Update( PRSOP_ScriptList    pList,
            LPCWSTR             wszGPOID,
            LPCWSTR             wszSOMID );

    //
    // Deletes all RSOP_ScriptPolicySetting of RSOP_ScriptList type
    //

    HRESULT
    Delete( PRSOP_ScriptList    pList );

private:
    LPSAFEARRAY
    MakeSafeArrayOfScripts(PRSOP_ScriptList     pList);

    IUnknown*
    PutScriptCommand( LPCWSTR szCommand, LPCWSTR szParams, SYSTEMTIME* pExecTime );

    //
    // house keeping
    //

    BOOL                           m_bInitialized;
    IWbemServices*                 m_pWbemServices;
    XBStr                          m_xbstrPath;

    //
    // RSOP_PolicySetting
    //

    XBStr                           m_xbstrId;
    XBStr                           m_xbstrName;
    XBStr                           m_xbstrGPO;
    XBStr                           m_xbstrSOM;
    XBStr                           m_xbstrOrderClass;

    //
    // RSOP_ScriptPolicySetting
    //

    XBStr                          m_xbstrScriptPolicySetting;
    XInterface<IWbemClassObject>   m_xScriptPolicySetting;
    XInterface<IWbemClassObject>   m_pInstance;
    XBStr                          m_xbstrScriptType;
    XBStr                          m_xbstrScriptList;
    XBStr                          m_xbstrOrder;

    //
    // RSOP_ScriptCmd
    //

    XBStr                          m_xbstrScriptCommand;
    XInterface<IWbemClassObject>   m_xScriptCommand;

    XBStr                          m_xbstrScript;
    XBStr                          m_xbstrArguments;
    XBStr                          m_xbstrExecutionTime;

};

#endif // !_SCRIPTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\policy.h ===
//
// Current ADM version
//
// Version 1 -> Windows 95
// Version 2 -> Windows NT v4.0
// Version 3 -> Windows 2000
// Version 4 -> Windows Whistler
//

#define CURRENT_ADM_VERSION 4


//
// Add/Remove template entry
//

typedef struct tagTEMPLATEENTRY {
    LPTSTR    lpFileName;
    DWORD     dwSize;
    FILETIME  ftTime;
} TEMPLATEENTRY, *LPTEMPLATEENTRY;


//
// Supported On strings
//

typedef struct tagSUPPORTEDENTRY {
    LPTSTR lpString;
    BOOL   bEnabled;
    BOOL   bNull;
    struct tagSUPPORTEDENTRY * pNext;
} SUPPORTEDENTRY, *LPSUPPORTEDENTRY;


//
// RSOP link list data structures
//

typedef struct tagRSOPREGITEM {
    LPTSTR  lpKeyName;
    LPTSTR  lpValueName;
    LPTSTR  lpGPOName;
    DWORD   dwType;
    DWORD   dwSize;
    LPBYTE  lpData;
    BOOL    bFoundInADM;
    UINT    uiPrecedence;
    BOOL    bDeleted;
    struct tagRSOPREGITEM * pNext;
} RSOPREGITEM, *LPRSOPREGITEM;

typedef struct tagRSOPADMFILE {
    TCHAR    szFileName[100];
    TCHAR    szFullFileName[MAX_PATH];
    FILETIME FileTime;
    DWORD     dwError;
    struct tagRSOPADMFILE * pNext;
} RSOPADMFILE, *LPRSOPADMFILE;


//
// From admincfg.h
//

#define REGBUFLEN                     255
#define MAXSTRLEN                    1024
#define SMALLBUF                       48
#define ERROR_ALREADY_DISPLAYED    0xFFFF

#define GETNAMEPTR(x)         (x->uOffsetName       ? ((TCHAR *)((BYTE *) x + x->uOffsetName)) : NULL)
#define GETKEYNAMEPTR(x)      (x->uOffsetKeyName    ? ((TCHAR *)((BYTE *) x + x->uOffsetKeyName)) : NULL)
#define GETVALUENAMEPTR(x)    (x->uOffsetValueName  ? ((TCHAR *)((BYTE *) x + x->uOffsetValueName)) : NULL)
#define GETOBJECTDATAPTR(x)   (x->uOffsetObjectData ? ((BYTE *) x + x->uOffsetObjectData) : NULL)
#define GETVALUESTRPTR(x)     (x->uOffsetValueStr  ? ((TCHAR *)((BYTE *) x + x->uOffsetValueStr)) : NULL)
#define GETSUPPORTEDPTR(x)    (x->uOffsetSupported  ? ((TCHAR *)((BYTE *) x + x->uOffsetSupported)) : NULL)

//
// From memory.h
//

#define DEFAULT_ENUM_BUF_SIZE 256

//      Entry type ID's
#define ETYPE_CATEGORY          0x0001
#define ETYPE_POLICY            0x0002
#define ETYPE_SETTING           0x0004
#define ETYPE_ROOT              0x0008
#define ETYPE_REGITEM           0x0010

#define ETYPE_MASK              0x001F

//  Setting type ID's
#define STYPE_TEXT              0x0010
#define STYPE_CHECKBOX          0x0020
#define STYPE_ENUM              0x0040
#define STYPE_EDITTEXT          0x0080
#define STYPE_NUMERIC           0x0100
#define STYPE_COMBOBOX          0x0200
#define STYPE_DROPDOWNLIST      0x0400
#define STYPE_LISTBOX           0x0800

#define STYPE_MASK              0xFFF0

//  Flags
#define DF_REQUIRED             0x0001  // text or numeric field required to have entry
#define DF_USEDEFAULT           0x0002  // use specified text or numeric value
#define DF_DEFCHECKED           0x0004  // initialize checkbox or radio button as checked
#define DF_TXTCONVERT           0x0008  // save numeric values as text rather than binary
#define DF_ADDITIVE             0x0010  // listbox is additive, rather than destructive
#define DF_EXPLICITVALNAME      0x0020  // listbox value names need to be specified for each entry
#define DF_NOSORT               0x0040  // listbox is not sorted alphabetically.  Uses order in ADM.
#define DF_EXPANDABLETEXT       0x0080  // write REG_EXPAND_SZ text value
#define VF_ISNUMERIC            0x0100  // value is numeric (rather than text)
#define VF_DELETE               0x0200  // value should be deleted
#define VF_SOFT                 0x0400  // value is soft (only propagated if doesn't exist on destination)

// generic table entry
typedef struct tagTABLEENTRY {
        DWORD   dwSize;
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        // table entry information here
} TABLEENTRY;

typedef struct tagACTION {
        DWORD   dwFlags;                        // can be VF_ISNUMERIC, VF_DELETE, VF_SOFT
        UINT    uOffsetKeyName;
        UINT    uOffsetValueName;
        union {
                UINT    uOffsetValue;   // offset to value, if text
                DWORD   dwValue;                // value, if numeric
        };
        UINT    uOffsetNextAction;
        // key name, value name, value stored here
} ACTION;

typedef struct tagACTIONLIST {
        UINT    nActionItems;
        ACTION  Action[1];
} ACTIONLIST;

typedef struct tagSTATEVALUE {
        DWORD dwFlags;                          // can be VF_ISNUMERIC, VF_DELETE, VF_SOFT
        union {
                TCHAR   szValue[1];              // value, if text
                DWORD   dwValue;                // value, if numeric
        };
} STATEVALUE;

// specialized nodes -- CATEGORY, POLICY, SETTING and REGITEM can all be cast to TABLEENTRY
typedef struct tagCATEGORY {
        DWORD   dwSize;                         // size of this struct (including variable-length name)
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        UINT    uOffsetHelp;                    // offset from beginning of struct to help text
        // category name stored here
        // category registry key name stored here
} CATEGORY;

typedef struct tagPOLICY {
        DWORD   dwSize;                         // size of this struct (including variable-length name)
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        UINT    uOffsetValueName;               // offset from beginning of struct to value name
        UINT    uDataIndex;                     // index into user's data buffer for this setting
        UINT    uOffsetValue_On;                // offset to STATEVALUE for ON state
        UINT    uOffsetValue_Off;               // offset to STATEVALUE for OFF state
        UINT    uOffsetActionList_On;   // offset to ACTIONLIST for ON state
        UINT    uOffsetActionList_Off;  // offset to ACTIONLIST for OFF state
        UINT    uOffsetHelp;                    // offset from beginning of struct to help text
        UINT    uOffsetClientExt;               // offset from beginning of struct to clientext text
        BOOL    bTruePolicy;                    // something located under the Policies key
        UINT    uOffsetSupported;               // list of supported products
        // name stored here
        // policy registry key name stored here
} POLICY;

typedef struct tagSETTINGS {
        DWORD   dwSize;                         // size of this struct (including variable-length data)
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        UINT    uOffsetValueName;               // offset from beginning of struct to value name
        UINT    uDataIndex;                     // index into user's data buffer for this setting
        UINT    uOffsetObjectData;              // offset to object data
        UINT    uOffsetClientExt;               // offset from beginning of struct to clientext text
        DWORD   dwFlags;                                // can be DF_REQUIRED, DF_USEDEFAULT, DF_DEFCHECKED,
                                                                        // VF_SOFT, DF_NO_SORT
        // settings registry value name stored here
        // object-dependent data stored here  (a CHECKBOXINFO,
        // RADIOBTNINFO, EDITTEXTINFO, or NUMERICINFO struct)
} SETTINGS;

typedef struct tagREGITEM {
        DWORD   dwSize;
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        UINT    uOffsetValueStr;                // offset from beginning of struct to the value in string format
        BOOL    bTruePolicy;                    // something located under the Policies key
        LPRSOPREGITEM lpItem;                   // Pointer to a rsop registry item
        // Name and keyname information here
} REGITEM;

typedef struct tagCHECKBOXINFO {
        UINT    uOffsetValue_On;                // offset to STATEVALUE for ON state
        UINT    uOffsetValue_Off;               // offset to STATEVALUE for OFF state
        UINT    uOffsetActionList_On;   // offset to ACTIONLIST for ON state
        UINT    uOffsetActionList_Off;  // offset to ACTIONLIST for OFF state
} CHECKBOXINFO;

typedef struct tagEDITTEXTINFO {
        UINT    uOffsetDefText;
        UINT    nMaxLen;                        // max len of edit field
} EDITTEXTINFO;

typedef struct tagPOLICYCOMBOBOXINFO {
        UINT    uOffsetDefText;
        UINT    nMaxLen;                        // max len of edit field
        UINT    uOffsetSuggestions;
} POLICYCOMBOBOXINFO;

typedef struct tagNUMERICINFO {
        UINT    uDefValue;                      // default value
        UINT    uMaxValue;                      // minimum value
        UINT    uMinValue;                      // maximum value
        UINT    uSpinIncrement;         // if 0, spin box is not displayed.
} NUMERICINFO;

typedef struct tagCLASSLIST {
        TABLEENTRY * pMachineCategoryList;              // per-machine category list
        UINT    nMachineDataItems;
        TABLEENTRY * pUserCategoryList;                 // per-user category table
        UINT    nUserDataItems;
} CLASSLIST;

typedef struct tagDROPDOWNINFO {
        UINT    uOffsetItemName;
        UINT    uDefaultItemIndex;      // only used in 1st DROPDOWNINFO struct in list
        DWORD   dwFlags;
        union {
                UINT uOffsetValue;
                DWORD dwValue;
        };
        UINT    uOffsetActionList;
        UINT    uOffsetNextDropdowninfo;
} DROPDOWNINFO;

typedef struct tagLISTBOXINFO {
        UINT uOffsetPrefix;     // offset to prefix to use for value names (e.g
                                                // "stuff" -> "stuff1", "stuff2", etc

        UINT uOffsetValue;      // offset to STATEVALUE to use for value data for each entry
                                                // (can't have both a data value and a prefix)
} LISTBOXINFO;


//
// From policy.h
//

#define NO_DATA_INDEX   (UINT) -1
#define DEF_CONTROLS    10

typedef struct tagPOLICYCTRLINFO {
        HWND hwnd;
        DWORD dwType;
        UINT uDataIndex;               // index into user's data buffer
        SETTINGS * pSetting;
} POLICYCTRLINFO;

typedef struct tagSTRDATA {
        DWORD dwSize;                  // size of structure incl. variable-len data
        TCHAR  szData[1];              // variable-length data
} STRDATA;

typedef struct tagPOLICYDLGINFO {
        TABLEENTRY * pEntryRoot;       // root template
        SETTINGS * pCurrentSettings;   // template for current settings
        HWND    hwndSettings;
        HWND    hwndApp;
        BOOL    fActive;

        POLICYCTRLINFO * pControlTable;
        DWORD dwControlTableSize;
        UINT nControls;
} POLICYDLGINFO;


//
// From settings.h
//

#define WT_CLIP                 1
#define WT_SETTINGS             2

#define SSTYLE_STATIC           WS_CHILD | WS_VISIBLE
#define SSTYLE_CHECKBOX         WS_CHILD | WS_VISIBLE | BS_CHECKBOX
#define SSTYLE_EDITTEXT         WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | WS_BORDER
#define SSTYLE_UPDOWN           WS_CHILD | WS_VISIBLE | UDS_NOTHOUSANDS
#define SSTYLE_COMBOBOX         WS_CHILD | WS_VISIBLE | CBS_AUTOHSCROLL | CBS_DROPDOWN \
                                | WS_BORDER | CBS_SORT | WS_VSCROLL
#define SSTYLE_DROPDOWNLIST     WS_CHILD | WS_VISIBLE | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST \
                                | WS_BORDER | CBS_SORT | WS_VSCROLL
#define SSTYLE_LISTVIEW         WS_CHILD | WS_VISIBLE | WS_BORDER
#define SSTYLE_LBBUTTON         WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON

#define LISTBOX_BTN_WIDTH    100
#define LISTBOX_BTN_HEIGHT    20

#define SC_XSPACING            5
#define SC_YSPACING            5
#define SC_YPAD                8
#define SC_EDITWIDTH         220
#define SC_UPDOWNWIDTH        60
#define SC_UPDOWNWIDTH2       30
#define SC_XLEADING            5
#define SC_XINDENT             5
#define SC_YTEXTDROP           3
#define SC_YCONTROLWRAP        1


//
// From parse.h
//

#define KYWD_ID_KEYNAME                1
#define KYWD_ID_VALUENAME              2
#define KYWD_ID_CATEGORY               3
#define KYWD_ID_POLICY                 4
#define KYWD_ID_PART                   5
#define KYWD_ID_CHECKBOX               6
#define KYWD_ID_TEXT                   7
#define KYWD_ID_EDITTEXT               8
#define KYWD_ID_NUMERIC                9
#define KYWD_ID_DEFCHECKED            10
#define KYWD_ID_MAXLENGTH             11
#define KYWD_ID_MIN                   12
#define KYWD_ID_MAX                   13
#define KYWD_ID_SPIN                  14
#define KYWD_ID_REQUIRED              15
#define KYWD_ID_EDITTEXT_DEFAULT      16
#define KYWD_ID_COMBOBOX_DEFAULT      17
#define KYWD_ID_NUMERIC_DEFAULT       18
#define KYWD_ID_OEMCONVERT            19
#define KYWD_ID_CLASS                 20
#define KYWD_ID_USER                  21
#define KYWD_ID_MACHINE               22
#define KYWD_ID_TXTCONVERT            23
#define KYWD_ID_VALUE                 24
#define KYWD_ID_VALUEON               25
#define KYWD_ID_VALUEOFF              26
#define KYWD_ID_ACTIONLIST            27
#define KYWD_ID_ACTIONLISTON          28
#define KYWD_ID_ACTIONLISTOFF         29
#define KYWD_ID_DELETE                30
#define KYWD_ID_COMBOBOX              31
#define KYWD_ID_SUGGESTIONS           32
#define KYWD_ID_DROPDOWNLIST          33
#define KYWD_ID_NAME                  34
#define KYWD_ID_ITEMLIST              35
#define KYWD_ID_DEFAULT               36
#define KYWD_ID_SOFT                  37
#define KYWD_ID_STRINGSSECT           38
#define KYWD_ID_LISTBOX               39
#define KYWD_ID_VALUEPREFIX           40
#define KYWD_ID_ADDITIVE              41
#define KYWD_ID_EXPLICITVALUE         42
#define KYWD_ID_VERSION               43
#define KYWD_ID_GT                    44
#define KYWD_ID_GTE                   45
#define KYWD_ID_LT                    46
#define KYWD_ID_LTE                   47
#define KYWD_ID_EQ                    48
#define KYWD_ID_NE                    49
#define KYWD_ID_END                   50
#define KYWD_ID_NOSORT                51
#define KYWD_ID_EXPANDABLETEXT        52
#define KYWD_ID_HELP                  53
#define KYWD_ID_CLIENTEXT             54
#define KYWD_ID_SUPPORTED             55

#define KYWD_DONE                    100


#define DEFAULT_TMP_BUF_SIZE         512
#define STRINGS_BUF_SIZE            8096
#define WORDBUFSIZE                  255
#define FILEBUFSIZE                 8192
#define HELPBUFSIZE                 4096


typedef struct tagKEYWORDINFO {
    LPCTSTR pWord;
    UINT nID;
} KEYWORDINFO;

typedef struct tagENTRYDATA {
    BOOL    fHasKey;
    BOOL    fHasValue;
    BOOL     fParentHasKey;
} ENTRYDATA;

typedef struct tagPARSEPROCSTRUCT {
    HGLOBAL        hTable;              // handle of current table
    TABLEENTRY    *pTableEntry;         // pointer to struct for current entry
    DWORD        *pdwBufSize;           // size of buffer of pTableEntry
    ENTRYDATA    *pData;                // used to maintain state between calls to parseproc
    KEYWORDINFO    *pEntryCmpList;
} PARSEPROCSTRUCT;

typedef UINT (* PARSEPROC) (CPolicyComponentData *, UINT,PARSEPROCSTRUCT *,BOOL *,BOOL *, LPTSTR);

typedef struct tagPARSEENTRYSTRUCT {
    TABLEENTRY * pParent;
    DWORD        dwEntryType;
    KEYWORDINFO    *pEntryCmpList;
    KEYWORDINFO    *pTypeCmpList;
    PARSEPROC    pParseProc;
    DWORD        dwStructSize;
    BOOL        fHasSubtable;
    BOOL        fParentHasKey;
} PARSEENTRYSTRUCT;


//
// From load.c
//

// flags for detected settings
#define FS_PRESENT      0x0001
#define FS_DELETED      0x0002
#define FS_DISABLED     0x0004

#define WM_MYCHANGENOTIFY  (WM_USER + 123)
#define WM_MOVEFOCUS       (WM_USER + 124)
#define WM_UPDATEITEM      (WM_USER + 125)
#define WM_SETPREVNEXT     (WM_USER + 126)
#define WM_MYREFRESH       (WM_USER + 127)


//
// GPE root node ids
//

// {8FC0B739-A0E1-11d1-A7D3-0000F87571E3}
DEFINE_GUID(NODEID_MachineRoot, 0x8fc0b739, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {8FC0B73B-A0E1-11d1-A7D3-0000F87571E3}
DEFINE_GUID(NODEID_UserRoot, 0x8fc0b73b, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// RSOP root node ids
//
// {e753a11a-66cc-4816-8dd8-3cbe46717fd3}
DEFINE_GUID(NODEID_RSOPMachineRoot, 0xe753a11a, 0x66cc, 0x4816, 0x8d, 0xd8, 0x3c, 0xbe, 0x46, 0x71, 0x7f, 0xd3);

//
// {99d5b872-1ad0-4d87-acf1-82125d317653}
DEFINE_GUID(NODEID_RSOPUserRoot, 0x99d5b872, 0x1ad0, 0x4d87, 0xac, 0xf1, 0x82, 0x12, 0x5d, 0x31, 0x76, 0x53);


//
// GPE Policy SnapIn extension GUIDs
//

// {0F6B957D-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(CLSID_PolicySnapInMachine,0xf6b957d, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {0F6B957E-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(CLSID_PolicySnapInUser,0xf6b957e, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// RSOP SnapIn extension GUIDs
//

// {B6F9C8AE-EF3A-41c8-A911-37370C331DD4}
DEFINE_GUID(CLSID_RSOPolicySnapInMachine,0xb6f9c8ae, 0xef3a, 0x41c8, 0xa9, 0x11, 0x37, 0x37, 0xc, 0x33, 0x1d, 0xd4);

// {B6F9C8AF-EF3A-41c8-A911-37370C331DD4}
DEFINE_GUID(CLSID_RSOPolicySnapInUser,0xb6f9c8af, 0xef3a, 0x41c8, 0xa9, 0x11, 0x37, 0x37, 0xc, 0x33, 0x1d, 0xd4);


//
// GPE Policy node ids
//

// {0F6B957F-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(NODEID_PolicyRootMachine,0xf6b957f, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {0F6B9580-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(NODEID_PolicyRootUser,0xf6b9580, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// RSOP node ids
//

// {B6F9C8B0-EF3A-41c8-A911-37370C331DD4}
DEFINE_GUID(NODEID_RSOPolicyRootMachine,0xb6f9c8b0, 0xef3a, 0x41c8, 0xa9, 0x11, 0x37, 0x37, 0xc, 0x33, 0x1d, 0xd4);

// {B6F9C8B1-EF3A-41c8-A911-37370C331DD4}
DEFINE_GUID(NODEID_RSOPolicyRootUser,0xb6f9c8b1, 0xef3a, 0x41c8, 0xa9, 0x11, 0x37, 0x37, 0xc, 0x33, 0x1d, 0xd4);



#define ROOT_NAME_SIZE  50

//
// CPolicyComponentData class
//

class CPolicyComponentData:
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public ISnapinHelp
{
    friend class CPolicyDataObject;
    friend class CPolicySnapIn;

protected:
    ULONG                m_cRef;
    HWND                 m_hwndFrame;
    LPCONSOLENAMESPACE2  m_pScope;
    LPCONSOLE            m_pConsole;
    HSCOPEITEM           m_hRoot;
    HSCOPEITEM           m_hSWPolicies;
    LPGPEINFORMATION     m_pGPTInformation;
    LPRSOPINFORMATION    m_pRSOPInformation;
    LPRSOPREGITEM        m_pRSOPRegistryData;
    LPOLESTR             m_pszNamespace;
    DWORD                m_bTemplatesColumn;
    BOOL                 m_bUserScope;
    BOOL                 m_bRSOP;
    TCHAR                m_szRootName[ROOT_NAME_SIZE];
    HANDLE               m_ADMEvent;
    HANDLE               m_hTemplateThread;
    INT                  m_iSWPoliciesLen;
    INT                  m_iWinPoliciesLen;
    BOOL                 m_bShowConfigPoliciesOnly;
    BOOL                 m_bUseSupportedOnFilter;
    CPolicySnapIn *      m_pSnapin;
    REGITEM *            m_pExtraSettingsRoot;
    BOOL                 m_bExtraSettingsInitialized;

    //
    // Parsing globals (review)
    //

    UINT                 m_nFileLine;

    TABLEENTRY          *m_pMachineCategoryList;  // per-machine category list
    UINT                 m_nMachineDataItems;
    TABLEENTRY          *m_pUserCategoryList;     // per-user category table
    UINT                 m_nUserDataItems;
    LPSUPPORTEDENTRY     m_pSupportedStrings;

    TABLEENTRY          *m_pListCurrent;          // Current category list (either user or machine)
    UINT                *m_pnDataItemCount;
    BOOL                 m_bRetrieveString;

    LPTSTR               m_pszParseFileName;      // Template currently being parsed or NULL

    // buffer to read .INF file into
    TCHAR               *m_pFilePtr;
    TCHAR               *m_pFileEnd;
    TCHAR               *m_pDefaultStrings;
    TCHAR               *m_pLanguageStrings;
    TCHAR               *m_pLocaleStrings;

    BOOL                 m_fInComment;


public:
    CPolicyComponentData(BOOL bUser, BOOL bRSOP);
    ~CPolicyComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);

    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);

    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);

private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
    BOOL CheckForChildCategories (TABLEENTRY *pParent);
#if DBG
    VOID DumpEntry (TABLEENTRY * pEntry, UINT uIndent);
    VOID DumpCurrentTable (void);
#endif
    VOID FreeTemplates (void);
    static DWORD LoadTemplatesThread (CPolicyComponentData * pCD);
    void AddTemplates(LPTSTR lpDest, LPCTSTR lpValueName, UINT idRes);
    void AddDefaultTemplates(LPTSTR lpDest);
    void AddNewADMsToExistingGPO (LPTSTR lpDest);
    void UpdateExistingTemplates(LPTSTR lpDest);
    HRESULT LoadGPOTemplates (void);
    BOOL IsSlowLink (LPTSTR lpFileName);
    HRESULT AddADMFile (LPTSTR lpFileName, LPTSTR lpFullFileName,
                        FILETIME *pFileTime, DWORD dwErr, LPRSOPADMFILE *lpHead);
    HRESULT LoadRSOPTemplates (void);
    HRESULT LoadTemplates (void);
    BOOL ParseTemplate (LPTSTR lpFileName);

    UINT ParseClass(BOOL *pfMore);
    TABLEENTRY * FindCategory(TABLEENTRY *pParent, LPTSTR lpName);
    UINT ParseEntry(PARSEENTRYSTRUCT *ppes,BOOL *pfMore, LPTSTR pKeyName);
    UINT ParseCategory(TABLEENTRY * pParent, BOOL fParentHasKey,BOOL *pfMore,LPTSTR pKeyName);
    static UINT CategoryParseProc(CPolicyComponentData *, UINT nMsg,PARSEPROCSTRUCT * ppps,
                                  BOOL * pfMore,BOOL * pfFoundEnd,LPTSTR pKeyName);

    UINT ParsePolicy(TABLEENTRY * pParent,
                     BOOL fParentHasKey,BOOL *pfMore,LPTSTR pKeyName);
    static UINT PolicyParseProc(CPolicyComponentData *, UINT nMsg,PARSEPROCSTRUCT * ppps,
                                BOOL * pfMore,BOOL * pfFoundEnd,LPTSTR pKeyName);

    UINT ParseSettings(TABLEENTRY * pParent,
                      BOOL fParentHasKey,BOOL *pfMore,LPTSTR pKeyName);
    static UINT SettingsParseProc(CPolicyComponentData *pCD, UINT nMsg,PARSEPROCSTRUCT * ppps,
                           BOOL * pfMore,BOOL * pfFoundEnd,LPTSTR pKeyName);

    UINT InitSettingsParse(PARSEPROCSTRUCT *ppps,DWORD dwType,DWORD dwSize,
                           KEYWORDINFO * pKeyList,SETTINGS ** ppSettings,BYTE **ppObjectData);

    UINT ParseValue_W(PARSEPROCSTRUCT * ppps,TCHAR * pszWordBuf,
                      DWORD cbWordBuf,DWORD * pdwValue,DWORD * pdwFlags,
                      BOOL * pfMore);

    UINT ParseValue(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                      TABLEENTRY ** ppTableEntryNew,BOOL * pfMore);

    UINT ParseSuggestions(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                          TABLEENTRY ** ppTableEntryNew,BOOL * pfMore);

    UINT ParseActionList(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                         TABLEENTRY ** ppTableEntryNew,
                         LPCTSTR pszKeyword,BOOL * pfMore);

    UINT ParseItemList(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                       BOOL * pfMore);

    BOOL AddActionListString(TCHAR * pszData,DWORD cbData,BYTE ** ppBase,UINT * puOffset,
                             DWORD * pdwAlloc,DWORD *pdwUsed);
    BYTE * AddDataToEntry(TABLEENTRY * pTableEntry, BYTE * pData,UINT cbData,
                          UINT * puOffsetData,DWORD * pdwBufSize);
    BOOL CompareKeyword(TCHAR * szWord,KEYWORDINFO *pKeywordList, UINT * pnListIndex);
    TCHAR * GetNextWord(TCHAR * szBuf,UINT cbBuf,BOOL * pfMore,
                        UINT * puErr);
    TCHAR * GetNextSectionWord(TCHAR * szBuf,UINT cbBuf,
                               KEYWORDINFO * pKeywordList, UINT *pnListIndex,
                               BOOL * pfMore,UINT * puErr);
    UINT GetNextSectionNumericWord(UINT * pnVal);

    TCHAR * GetNextChar(BOOL * pfMore,UINT * puErr);
    BOOL GetString (LPTSTR pStringSection, LPTSTR lpStringName,
                    LPTSTR lpResult, DWORD dwSize);
    BOOL IsComment(TCHAR * pBuf);
    BOOL IsQuote(TCHAR * pBuf);
    BOOL IsEndOfLine(TCHAR * pBuf);
    BOOL IsWhitespace(TCHAR * pBuf);
    BOOL IsLocalizedString(TCHAR * pBuf);

    VOID DisplayKeywordError(UINT uErrorID,TCHAR * szFound,KEYWORDINFO * pExpectedList);
    int MsgBox(HWND hWnd,UINT nResource,UINT uIcon,UINT uButtons);
    int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
    int MsgBoxParam(HWND hWnd,UINT nResource,TCHAR * szReplaceText,UINT uIcon,UINT uButtons);
    LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);

    UINT FindMatchingDirective(BOOL *pfMore,BOOL fElseOK);
    UINT ProcessIfdefs(TCHAR * pBuf,UINT cbBuf,BOOL * pfMore);
    BOOL FreeTable(TABLEENTRY * pTableEntry);

    LPTSTR GetStringSection (LPCTSTR lpSection, LPCTSTR lpFileName);
    static INT TemplatesSortCallback (LPARAM lParam1, LPARAM lParam2, LPARAM lColumn);

    BOOL FillADMFiles (HWND hDlg);
    BOOL InitializeTemplatesDlg (HWND hDlg);
    BOOL AddTemplates(HWND hDlg);
    BOOL RemoveTemplates(HWND hDlg);
    static INT_PTR CALLBACK TemplatesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    BOOL AddRSOPRegistryDataNode(LPTSTR lpKeyName, LPTSTR lpValueName, DWORD dwType,
                                 DWORD dwDataSize, LPBYTE lpData, UINT uiPrecedence,
                                 LPTSTR lpGPOName, BOOL bDeleted);
    VOID FreeRSOPRegistryData(VOID);
    HRESULT InitializeRSOPRegistryData(VOID);
    HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                               LPTSTR lpGPOID, BSTR pLanguage,
                               LPTSTR *pGPOName);
    UINT ReadRSOPRegistryValue(HKEY uiPrecedence, TCHAR * pszKeyName,TCHAR * pszValueName,
                               LPBYTE pData, DWORD dwMaxSize, DWORD *dwType,
                               LPTSTR *lpGPOName, LPRSOPREGITEM lpItem);
    UINT EnumRSOPRegistryValues(HKEY uiPrecedence, TCHAR * pszKeyName,
                                TCHAR * pszValueName, DWORD dwMaxSize,
                                LPRSOPREGITEM *lpEnum);
    UINT FindRSOPRegistryEntry(HKEY uiPrecedence, TCHAR * pszKeyName,
                               TCHAR * pszValueName, LPRSOPREGITEM *lpEnum);
    VOID DumpRSOPRegistryData (VOID);
    VOID InitializeExtraSettings (VOID);
    BOOL FindEntryInActionList(POLICY * pPolicy, ACTIONLIST *pActionList, LPTSTR lpKeyName, LPTSTR lpValueName);
    BOOL FindEntryInTable(TABLEENTRY * pTable, LPTSTR lpKeyName, LPTSTR lpValueName);
    VOID AddEntryToList (TABLEENTRY *pItem);

    BOOL DoesNodeExist (LPSUPPORTEDENTRY *pList, LPTSTR lpString);
    BOOL CheckSupportedFilter (POLICY *pPolicy);
    BOOL IsAnyPolicyAllowedPastFilter(TABLEENTRY * pCategory);
    VOID AddSupportedNode (LPSUPPORTEDENTRY *pList, LPTSTR lpString, BOOL bNull);
    VOID FreeSupportedData(LPSUPPORTEDENTRY lpList);
    VOID InitializeSupportInfo(TABLEENTRY * pTable, LPSUPPORTEDENTRY *pList);
};



//
// ComponentData class factory
//


class CPolicyComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;
    BOOL  m_bUser;
    BOOL  m_bRSOP;

public:
    CPolicyComponentDataCF(BOOL bUser, BOOL bRSOP);
    ~CPolicyComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};



//
// SnapIn class
//

class CPolicySnapIn:
    public IComponent,
    public IExtendContextMenu,
    public IExtendPropertySheet
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;           // Console's IFrame interface
    CPolicyComponentData *m_pcd;
    LPRESULTDATA         m_pResult;            // Result pane's interface
    LPHEADERCTRL         m_pHeader;            // Result pane's header control interface
    LPCONSOLEVERB        m_pConsoleVerb;       // pointer the console verb
    LPDISPLAYHELP        m_pDisplayHelp;       // IDisplayHelp interface
    WCHAR                m_pName[40];          // Name text
    WCHAR                m_pState[40];         // State text
    WCHAR                m_pSetting[40];       // Setting text
    WCHAR                m_pGPOName[40];       // GPO Name text
    WCHAR                m_pMultipleGPOs[75];  // Multiple GPOs text
    INT                  m_nColumn1Size;       // Size of column 1
    INT                  m_nColumn2Size;       // Size of column 2
    INT                  m_nColumn3Size;       // Size of column 3
    LONG                 m_lViewMode;          // View mode
    WCHAR                m_pEnabled[30];       // Enabled text
    WCHAR                m_pDisabled[30];      // Disabled text
    WCHAR                m_pNotConfigured[30]; // Not configured text
    BOOL                 m_bPolicyOnly;        // Show policies only
    DWORD                m_dwPolicyOnlyPolicy; // Policy for enforcing Show Policies Only
    HWND                 m_hMsgWindow;         // Hidden message window

    POLICY              *m_pCurrentPolicy;     // Currently selected policy
    HWND                 m_hPropDlg;           // Properties dialog
    HICON                m_hPolicyIcon;        // Policy icon
    HICON                m_hPreferenceIcon;    // Preference icon
    BOOL                 m_bDirty;             // Has something changed in the policy UI
    HHOOK                m_hKbdHook;           // Keyboard hook handle

    static unsigned int  m_cfNodeType;

public:
    UINT                 m_uiRefreshMsg;       // Reload the adm namespace

    CPolicySnapIn(CPolicyComponentData *pComponent);
    ~CPolicySnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);


    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);


    BOOL IsAnyPolicyEnabled(TABLEENTRY * pCategory);

private:
    VOID RefreshSettingsControls(HWND hDlg);
    HRESULT UpdateItemWorker (VOID);
    HRESULT MoveFocusWorker (BOOL bPrevious);
    HRESULT MoveFocus (HWND hDlg, BOOL bPrevious);
    HRESULT SetPrevNextButtonState (HWND hDlg);
    HRESULT SetPrevNextButtonStateWorker (HWND hDlg);
    static INT_PTR CALLBACK PolicyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PolicyHelpDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PolicyPrecedenceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK KeyboardHookProc(int nCode, WPARAM wParam,LPARAM lParam);
    VOID SetKeyboardHook(HWND hDlg);
    VOID RemoveKeyboardHook(VOID);
    INT GetPolicyState (TABLEENTRY *pTableEntry, UINT uiPrecedence, LPTSTR *lpGPOName);
    BOOL CheckActionList (POLICY * pPolicy, HKEY hKeyRoot, BOOL bActionListOn, LPTSTR *lpGPOName);
    UINT LoadSettings(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
                      DWORD * pdwFound, LPTSTR *lpGPOName);
    UINT LoadListboxData(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
                         TCHAR * pszCurrentKeyName,DWORD * pdwFound, HGLOBAL * phGlobal, LPTSTR *lpGPOName);
    BOOL ReadCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                         TCHAR * pszValue,UINT cbValue,DWORD * pdwValue,DWORD * pdwFlags,LPTSTR *lpGPOName);
    BOOL CompareCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                            STATEVALUE * pStateValue,DWORD * pdwFound, LPTSTR *lpGPOName);
    BOOL ReadStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                           TABLEENTRY * pTableEntry,DWORD * pdwData,DWORD * pdwFound, LPTSTR *lpGPOName);
    VOID PrependValueName(TCHAR * pszValueName,DWORD dwFlags,TCHAR * pszNewValueName,
                          UINT cbNewValueName);
    UINT WriteRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName, DWORD dwValue);
    UINT ReadRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                                DWORD * pdwValue, LPTSTR *lpGPOName);
    UINT WriteRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                                  TCHAR * pszValue, BOOL bExpandable);
    UINT ReadRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                                 TCHAR * pszValue,UINT cbValue, LPTSTR *lpGPOName);
    UINT DeleteRegistryValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName);
    UINT WriteCustomValue_W(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                            TCHAR * pszValue,DWORD dwValue,DWORD dwFlags,BOOL fErase);
    UINT WriteCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                          STATEVALUE * pStateValue,BOOL fErase);
    UINT WriteStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                            TABLEENTRY * pTableEntry,DWORD dwData,BOOL fErase,
                            BOOL fWriteZero);
    TCHAR * ResizeBuffer(TCHAR *pBuf,HGLOBAL hBuf,DWORD dwNeeded,DWORD * pdwCurSize);
    static LRESULT CALLBACK MessageWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
    static LRESULT CALLBACK ClipWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
    VOID ProcessCommand(HWND hWnd,WPARAM wParam,HWND hwndCtrl, POLICYDLGINFO * pdi);
    VOID EnsureSettingControlVisible(HWND hDlg,HWND hwndCtrl);
    VOID ProcessScrollBar(HWND hWnd,WPARAM wParam,BOOL bVert);
    VOID FreeSettingsControls(HWND hDlg);
    VOID InsertComboboxItems(HWND hwndControl,TCHAR * pSuggestionList);
    BOOL CreateSettingsControls(HWND hDlg,SETTINGS * pSetting,BOOL fEnable);
    HWND CreateSetting(POLICYDLGINFO * pdi,TCHAR * pszClassName,TCHAR * pszWindowName,
        DWORD dwExStyle,DWORD dwStyle,int x,int y,int cx,int cy,DWORD dwType,UINT uIndex,
        SETTINGS * pSetting, HFONT hFontDlg);
    BOOL SetWindowData(POLICYDLGINFO * pdi,HWND hwndControl,DWORD dwType,
                        UINT uDataIndex,SETTINGS * pSetting);
    int AddControlHwnd(POLICYDLGINFO * pdi,POLICYCTRLINFO * pPolicyCtrlInfo);
    BOOL AdjustWindowToText(HWND hWnd,TCHAR * szText,UINT xStart,UINT yStart,
        UINT yPad,UINT * pnWidth,UINT * pnHeight, HFONT hFontDlg);
    BOOL GetTextSize(HWND hWnd,TCHAR * szText,SIZE * pSize, HFONT hFontDlg);
    HRESULT SaveSettings(HWND hDlg);
    VOID DeleteOldListboxData(SETTINGS * pSetting,HKEY hkeyRoot, TCHAR * pszCurrentKeyName);
    UINT SaveListboxData(HGLOBAL hData,SETTINGS * pSetting,HKEY hkeyRoot,
                         TCHAR * pszCurrentKeyName,BOOL fErase,BOOL fMarkDeleted, BOOL bEnabled, BOOL *bFoundNone);
    UINT ProcessCheckboxActionLists(HKEY hkeyRoot,TABLEENTRY * pTableEntry,
                                    TCHAR * pszCurrentKeyName,DWORD dwData,
                                    BOOL fErase, BOOL fMarkAsDeleted,BOOL bPolicy);
    UINT WriteActionList(HKEY hkeyRoot,ACTIONLIST * pActionList,
           LPTSTR pszCurrentKeyName,BOOL fErase, BOOL fMarkAsDeleted);
    int FindComboboxItemData(HWND hwndControl,UINT nData);
    HRESULT InitializeSettingsControls(HWND hDlg, BOOL fEnable);
    VOID ShowListbox(HWND hParent,SETTINGS * pSettings);
    static INT_PTR CALLBACK ShowListboxDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                            LPARAM lParam);
    BOOL InitShowlistboxDlg(HWND hDlg);
    BOOL ProcessShowlistboxDlg(HWND hDlg);
    VOID EnableShowListboxButtons(HWND hDlg);
    VOID ListboxRemove(HWND hDlg,HWND hwndListbox);
    VOID ListboxAdd(HWND hwndListbox, BOOL fExplicitValName,BOOL fValuePrefix);
    static INT_PTR CALLBACK ListboxAddDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitializeFilterDialog (HWND hDlg);
    static INT_PTR CALLBACK FilterDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CallNextHook(int nCode, WPARAM wParam, LPARAM lParam);
};


//
// Structure passed to Settings / Properties dialog
//

typedef struct tagSETTINGSINFO {
    CPolicySnapIn * pCS;
    POLICYDLGINFO * pdi;
    HFONT hFontDlg;
} SETTINGSINFO, *LPSETTINGSINFO;


//
// From listbox.c
//

typedef struct tagLISTBOXDLGINFO {
    CPolicySnapIn * pCS;
    SETTINGS * pSettings;
    HGLOBAL hData;
} LISTBOXDLGINFO;

typedef struct tagADDITEMINFO {
    CPolicySnapIn * pCS;
    BOOL fExplicitValName;
    BOOL fValPrefix;
    HWND hwndListbox;
    TCHAR szValueName[MAX_PATH+1];  // only used if fExplicitValName is set
    TCHAR szValueData[MAX_PATH+1];
} ADDITEMINFO;


//
// IPolicyDataObject interface id
//

// {0F6B9580-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(IID_IPolicyDataObject,0xf6b9580, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);



//
// This is a private dataobject interface for GPTs.
// When the GPT snapin receives a dataobject and needs to determine
// if it came from the GPT snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IPolicyDataObject
DECLARE_INTERFACE_(IPolicyDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IPolicyDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IPolicyDataObject *LPPOLICYDATAOBJECT;



//
// CPolicyDataObject class
//

class CPolicyDataObject : public IDataObject,
                           public IPolicyDataObject
{
    friend class CPolicySnapIn;

protected:

    ULONG                  m_cRef;
    CPolicyComponentData  *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfDescription;
    static unsigned int    m_cfHTMLDetails;



public:
    CPolicyDataObject(CPolicyComponentData *pComponent);
    ~CPolicyDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IPolicyDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

VOID LoadMessage (DWORD dwID, LPTSTR lpBuffer, DWORD dwSize);
BOOL ReportAdmError (HWND hParent, DWORD dwError, UINT idMsg, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\policy.cpp ===
#include "gptext.h"
#include <initguid.h>
#include "Policy.h"
#include "smartptr.h"
#include "wbemtime.h"

#define RSOP_HELP_FILE TEXT("gpedit.hlp")


//
// ADM directory name
//

const TCHAR g_szADM[] = TEXT("Adm");
const TCHAR g_szNull[]  = TEXT("");
const TCHAR g_szStrings[] = TEXT("strings");

const TCHAR szIFDEF[]           = TEXT("#ifdef");
const TCHAR szIF[]              = TEXT("#if");
const TCHAR szENDIF[]           = TEXT("#endif");
const TCHAR szIFNDEF[]          = TEXT("#ifndef");
const TCHAR szELSE[]            = TEXT("#else");
const TCHAR szVERSION[]         = TEXT("version");
const TCHAR szLT[]              = TEXT("<");
const TCHAR szLTE[]             = TEXT("<=");
const TCHAR szGT[]              = TEXT(">");
const TCHAR szGTE[]             = TEXT(">=");
const TCHAR szEQ[]              = TEXT("==");
const TCHAR szNE[]              = TEXT("!=");

const TCHAR szLISTBOX[]         = TEXT("LISTBOX");
const TCHAR szEDIT[]            = TEXT("EDIT");
const TCHAR szBUTTON[]          = TEXT("BUTTON");
const TCHAR szSTATIC[]          = TEXT("STATIC");

const TCHAR szCLASS[]           = TEXT("CLASS");
const TCHAR szCATEGORY[]        = TEXT("CATEGORY");
const TCHAR szPOLICY[]          = TEXT("POLICY");
const TCHAR szUSER[]            = TEXT("USER");
const TCHAR szMACHINE[]         = TEXT("MACHINE");

const TCHAR szCHECKBOX[]        = TEXT("CHECKBOX");
const TCHAR szTEXT[]            = TEXT("TEXT");
const TCHAR szEDITTEXT[]        = TEXT("EDITTEXT");
const TCHAR szNUMERIC[]         = TEXT("NUMERIC");
const TCHAR szCOMBOBOX[]        = TEXT("COMBOBOX");
const TCHAR szDROPDOWNLIST[]    = TEXT("DROPDOWNLIST");
const TCHAR szUPDOWN[]          = UPDOWN_CLASS;

const TCHAR szKEYNAME[]         = TEXT("KEYNAME");
const TCHAR szVALUENAME[]       = TEXT("VALUENAME");
const TCHAR szNAME[]            = TEXT("NAME");
const TCHAR szEND[]             = TEXT("END");
const TCHAR szPART[]            = TEXT("PART");
const TCHAR szSUGGESTIONS[]     = TEXT("SUGGESTIONS");
const TCHAR szDEFCHECKED[]      = TEXT("DEFCHECKED");
const TCHAR szDEFAULT[]         = TEXT("DEFAULT");
const TCHAR szMAXLENGTH[]       = TEXT("MAXLEN");
const TCHAR szMIN[]             = TEXT("MIN");
const TCHAR szMAX[]             = TEXT("MAX");
const TCHAR szSPIN[]            = TEXT("SPIN");
const TCHAR szREQUIRED[]        = TEXT("REQUIRED");
const TCHAR szOEMCONVERT[]      = TEXT("OEMCONVERT");
const TCHAR szTXTCONVERT[]      = TEXT("TXTCONVERT");
const TCHAR szEXPANDABLETEXT[]  = TEXT("EXPANDABLETEXT");
const TCHAR szVALUEON[]         = TEXT("VALUEON");
const TCHAR szVALUEOFF[]        = TEXT("VALUEOFF");
const TCHAR szVALUE[]           = TEXT("VALUE");
const TCHAR szACTIONLIST[]      = TEXT("ACTIONLIST");
const TCHAR szACTIONLISTON[]    = TEXT("ACTIONLISTON");
const TCHAR szACTIONLISTOFF[]   = TEXT("ACTIONLISTOFF");
const TCHAR szDELETE[]          = TEXT("DELETE");
const TCHAR szITEMLIST[]        = TEXT("ITEMLIST");
const TCHAR szSOFT[]            = TEXT("SOFT");
const TCHAR szVALUEPREFIX[]     = TEXT("VALUEPREFIX");
const TCHAR szADDITIVE[]        = TEXT("ADDITIVE");
const TCHAR szEXPLICITVALUE[]   = TEXT("EXPLICITVALUE");
const TCHAR szNOSORT[]          = TEXT("NOSORT");
const TCHAR szHELP[]            = TEXT("EXPLAIN");
const TCHAR szCLIENTEXT[]       = TEXT("CLIENTEXT");
const TCHAR szSUPPORTED[]       = TEXT("SUPPORTED");
const TCHAR szStringsSect[]     = TEXT("[strings]");
const TCHAR szStrings[]         = TEXT("strings");

const TCHAR szDELETEPREFIX[]    = TEXT("**del.");
const TCHAR szSOFTPREFIX[]      = TEXT("**soft.");
const TCHAR szDELVALS[]         = TEXT("**delvals.");
const TCHAR szNOVALUE[]         = TEXT(" ");

const TCHAR szUserPrefKey[]     = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy Editor");
const TCHAR szPoliciesKey[]     = TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy Editor");
const TCHAR szDefaultTemplates[] = TEXT("DefaultTemplates");
const TCHAR szAdditionalTemplates[] = TEXT("AdditionalTemplates");


// list of legal keyword entries in "CATEGORY" section
KEYWORDINFO pCategoryEntryCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
    {szCATEGORY,KYWD_ID_CATEGORY},{szPOLICY,KYWD_ID_POLICY},
    {szEND,KYWD_ID_END},{szHELP,KYWD_ID_HELP}, {NULL,0} };
KEYWORDINFO pCategoryTypeCmpList[] = { {szCATEGORY,KYWD_ID_CATEGORY},
    {NULL,0} };

// list of legal keyword entries in "POLICY" section
KEYWORDINFO pPolicyEntryCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
    {szVALUENAME,KYWD_ID_VALUENAME}, {szPART,KYWD_ID_PART},
    {szVALUEON,KYWD_ID_VALUEON},{szVALUEOFF,KYWD_ID_VALUEOFF},
    {szACTIONLISTON,KYWD_ID_ACTIONLISTON},{szACTIONLISTOFF,KYWD_ID_ACTIONLISTOFF},
    {szEND,KYWD_ID_END},{szHELP,KYWD_ID_HELP}, {szCLIENTEXT,KYWD_ID_CLIENTEXT},
    {szSUPPORTED,KYWD_ID_SUPPORTED}, {NULL, 0} };
KEYWORDINFO pPolicyTypeCmpList[] = { {szPOLICY,KYWD_ID_POLICY}, {NULL,0} };

// list of legal keyword entries in "PART" section
KEYWORDINFO pSettingsEntryCmpList[] = { {szCHECKBOX,KYWD_ID_CHECKBOX},
    {szTEXT,KYWD_ID_TEXT},{szEDITTEXT,KYWD_ID_EDITTEXT},
    {szNUMERIC,KYWD_ID_NUMERIC},{szCOMBOBOX,KYWD_ID_COMBOBOX},
    {szDROPDOWNLIST,KYWD_ID_DROPDOWNLIST},{szLISTBOX,KYWD_ID_LISTBOX},
    {szEND,KYWD_ID_END}, {szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0}};
KEYWORDINFO pSettingsTypeCmpList[] = {{szPART,KYWD_ID_PART},{NULL,0}};

KEYWORDINFO pCheckboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szVALUEON,KYWD_ID_VALUEON},{szVALUEOFF,KYWD_ID_VALUEOFF},
    {szACTIONLISTON,KYWD_ID_ACTIONLISTON},{szACTIONLISTOFF,KYWD_ID_ACTIONLISTOFF},
    {szDEFCHECKED, KYWD_ID_DEFCHECKED}, {szCLIENTEXT,KYWD_ID_CLIENTEXT},
    {szEND,KYWD_ID_END},{NULL,0} };

KEYWORDINFO pTextCmpList[] = {{szEND,KYWD_ID_END},{NULL,0}};

KEYWORDINFO pEditTextCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szDEFAULT,KYWD_ID_EDITTEXT_DEFAULT},
    {szREQUIRED,KYWD_ID_REQUIRED},{szMAXLENGTH,KYWD_ID_MAXLENGTH},
    {szOEMCONVERT,KYWD_ID_OEMCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END},{szEXPANDABLETEXT,KYWD_ID_EXPANDABLETEXT},
    {szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0} };

KEYWORDINFO pComboboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szDEFAULT,KYWD_ID_COMBOBOX_DEFAULT},{szSUGGESTIONS,KYWD_ID_SUGGESTIONS},
    {szREQUIRED,KYWD_ID_REQUIRED},{szMAXLENGTH,KYWD_ID_MAXLENGTH},
    {szOEMCONVERT,KYWD_ID_OEMCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END},{szNOSORT, KYWD_ID_NOSORT},
    {szEXPANDABLETEXT,KYWD_ID_EXPANDABLETEXT},{szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0} };

KEYWORDINFO pNumericCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szMIN, KYWD_ID_MIN},{szMAX,KYWD_ID_MAX},{szSPIN,KYWD_ID_SPIN},
    {szDEFAULT,KYWD_ID_NUMERIC_DEFAULT},{szREQUIRED,KYWD_ID_REQUIRED},
    {szTXTCONVERT,KYWD_ID_TXTCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END}, {szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0} };

KEYWORDINFO pDropdownlistCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szREQUIRED,KYWD_ID_REQUIRED},{szITEMLIST,KYWD_ID_ITEMLIST},
    {szEND,KYWD_ID_END},{szNOSORT, KYWD_ID_NOSORT},{szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0}};

KEYWORDINFO pListboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUEPREFIX,KYWD_ID_VALUEPREFIX},
    {szADDITIVE,KYWD_ID_ADDITIVE},{szNOSORT, KYWD_ID_NOSORT},
    {szEXPLICITVALUE,KYWD_ID_EXPLICITVALUE},{szEXPANDABLETEXT,KYWD_ID_EXPANDABLETEXT},
    {szEND,KYWD_ID_END},{szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0} };

KEYWORDINFO pClassCmpList[] = { {szCLASS, KYWD_ID_CLASS},
    {szCATEGORY,KYWD_ID_CATEGORY}, {szStringsSect,KYWD_ID_STRINGSSECT},
    {NULL,0} };
KEYWORDINFO pClassTypeCmpList[] = { {szUSER, KYWD_ID_USER},
    {szMACHINE,KYWD_ID_MACHINE}, {NULL,0} };

KEYWORDINFO pVersionCmpList[] = { {szVERSION, KYWD_ID_VERSION}, {NULL,0}};
KEYWORDINFO pOperatorCmpList[] = { {szGT, KYWD_ID_GT}, {szGTE,KYWD_ID_GTE},
    {szLT, KYWD_ID_LT}, {szLTE,KYWD_ID_LTE}, {szEQ,KYWD_ID_EQ},
    {szNE, KYWD_ID_NE}, {NULL,0}};


//
// Help ID's
//

DWORD aADMHelpIds[] = {

    // Templates dialog
    IDC_TEMPLATELIST,             (IDH_HELPFIRST + 0),
    IDC_ADDTEMPLATES,             (IDH_HELPFIRST + 1),
    IDC_REMOVETEMPLATES,          (IDH_HELPFIRST + 2),

    0, 0
};

DWORD aPolicyHelpIds[] = {

    // ADM Policy UI page
    IDC_NOCONFIG,                 (IDH_HELPFIRST + 11),
    IDC_ENABLED,                  (IDH_HELPFIRST + 12),
    IDC_DISABLED,                 (IDH_HELPFIRST + 13),
    IDC_POLICY_PREVIOUS,          (IDH_HELPFIRST + 14),
    IDC_POLICY_NEXT,              (IDH_HELPFIRST + 15),
    0, 0
};

DWORD aExplainHelpIds[] = {

    // Explain page
    IDC_POLICY_PREVIOUS,          (IDH_HELPFIRST + 14),
    IDC_POLICY_NEXT,              (IDH_HELPFIRST + 15),

    0, 0
};

DWORD aPrecedenceHelpIds[] = {

    // Precedence page
    IDC_POLICY_PRECEDENCE,        (IDH_HELPFIRST + 16),
    IDC_POLICY_PREVIOUS,          (IDH_HELPFIRST + 14),
    IDC_POLICY_NEXT,              (IDH_HELPFIRST + 15),

    0, 0
};

DWORD aFilteringHelpIds[] = {

    // Filtering options
    IDC_STATIC,                   (DWORD)         (-1),                 // disabled help
    IDC_FILTERING_ICON,           (DWORD)         (-1),                 // disabled help
    IDC_SUPPORTEDONTITLE,         (DWORD)         (-1),                 // disabled help
    IDC_SUPPORTEDOPTION,          (IDH_HELPFIRST + 20),
    IDC_FILTERLIST,               (IDH_HELPFIRST + 21),
    IDC_SELECTALL,                (IDH_HELPFIRST + 22),
    IDC_DESELECTALL,              (IDH_HELPFIRST + 23),
    IDC_SHOWCONFIG,               (IDH_HELPFIRST + 24),
    IDC_SHOWPOLICIES,             (IDH_HELPFIRST + 25),

    0, 0
};

#define GPE_KEY                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy Editor")
#define GPE_POLICIES_KEY            TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy Editor")
#define POLICYONLY_VALUE            TEXT("ShowPoliciesOnly")
#define DISABLE_AUTOUPDATE_VALUE    TEXT("DisableAutoADMUpdate")
#define SOFTWARE_POLICIES           TEXT("Software\\Policies")
#define WINDOWS_POLICIES            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")


typedef struct _GPOERRORINFO
{
    DWORD   dwError;
    LPTSTR  lpMsg;
    LPTSTR  lpDetails;
} GPOERRORINFO, *LPGPOERRORINFO;

//
// Help ids
//

DWORD aErrorHelpIds[] =
{

    0, 0
};



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CPolicyComponentData::CPolicyComponentData(BOOL bUser, BOOL bRSOP)
{
    TCHAR szEvent[200];

    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_hSWPolicies = NULL;
    m_pGPTInformation = NULL;
    m_pRSOPInformation = NULL;
    m_pRSOPRegistryData = NULL;
    m_pszNamespace = NULL;
    m_bUserScope = bUser;
    m_bRSOP = bRSOP;
    m_pMachineCategoryList = NULL;
    m_nMachineDataItems = 0;
    m_pUserCategoryList = NULL;
    m_nUserDataItems = 0;
    m_pSupportedStrings = 0;
    m_iSWPoliciesLen = lstrlen(SOFTWARE_POLICIES);
    m_iWinPoliciesLen = lstrlen(WINDOWS_POLICIES);
    m_bUseSupportedOnFilter = FALSE;

    if (bRSOP)
    {
        m_bShowConfigPoliciesOnly = TRUE;
    }
    else
    {
        m_bShowConfigPoliciesOnly = FALSE;
    }

    m_pSnapin = NULL;
    m_hTemplateThread = NULL;
    
    wsprintf (szEvent, TEXT("gptext: ADM files ready event, %d:%d"), bUser, GetTickCount());

    m_ADMEvent = CreateEvent (NULL, TRUE, FALSE, szEvent);

    if (!m_ADMEvent)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::CPolicyComponentData: Failed to create ADM event with %d."),
                 GetLastError()));
    }


    LoadString (g_hInstance, IDS_POLICY_NAME, m_szRootName, ROOT_NAME_SIZE);

    m_pExtraSettingsRoot = NULL;
    m_bExtraSettingsInitialized = FALSE;
}

CPolicyComponentData::~CPolicyComponentData()
{

    //
    // Wait for the Template thread to finish before continuing.
    //
    
    if (m_hTemplateThread)
        WaitForSingleObject(m_hTemplateThread, INFINITE);

    FreeTemplates ();

    if (m_pExtraSettingsRoot)
    {
        FreeTable ((TABLEENTRY *)m_pExtraSettingsRoot);
    }

    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation)
    {
        m_pGPTInformation->Release();
    }

    if (m_pRSOPInformation)
    {
        m_pRSOPInformation->Release();
    }

    if (m_pRSOPRegistryData)
    {
        FreeRSOPRegistryData();
    }

    if (m_pszNamespace)
    {
        LocalFree (m_pszNamespace);
    }

    CloseHandle (m_ADMEvent);
    
    if (m_hTemplateThread) 
        CloseHandle (m_hTemplateThread);

    m_hTemplateThread = NULL;

    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (IUnknown)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CPolicyComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CPolicyComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CPolicyComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (IComponentData)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicyComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }

    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                      reinterpret_cast<LONG_PTR *>(bmp16x16),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();


    //
    // Create the root of the Extra Settings node if appropriate
    //

    if (m_bRSOP)
    {
        DWORD dwBufSize;
        REGITEM *pTmp;
        TCHAR szBuffer[100];

        m_pExtraSettingsRoot = (REGITEM *) GlobalAlloc(GPTR, sizeof(REGITEM));

        if (!m_pExtraSettingsRoot)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: GlobalAlloc failed with %d"), GetLastError()));
            return HRESULT_FROM_WIN32(GetLastError());
        }

        m_pExtraSettingsRoot->dwSize = sizeof(REGITEM);
        m_pExtraSettingsRoot->dwType = (ETYPE_ROOT | ETYPE_REGITEM);


        LoadString (g_hInstance, IDS_EXTRAREGSETTINGS, szBuffer, ARRAYSIZE(szBuffer));

        pTmp = (REGITEM *) AddDataToEntry((TABLEENTRY *)m_pExtraSettingsRoot,
            (BYTE *)szBuffer,(lstrlen(szBuffer)+1) * sizeof(TCHAR),&(m_pExtraSettingsRoot->uOffsetName),
            &dwBufSize);

        if (!pTmp)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: AddDataToEntry failed.")));
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        m_pExtraSettingsRoot = pTmp;
    }


    return S_OK;
}

STDMETHODIMP CPolicyComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CPolicyComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CPolicySnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CPolicySnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::CreateComponent: Failed to create CPolicySnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI

    m_pSnapin = pSnapIn;

    return hr;
}

STDMETHODIMP CPolicyComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CPolicyDataObject *pDataObject;
    LPPOLICYDATAOBJECT pPolicyDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CPolicyDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPTDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IPolicyDataObject, (LPVOID *)&pPolicyDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pPolicyDataObject->SetType(type);
    pPolicyDataObject->SetCookie(cookie);
    pPolicyDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CPolicyComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_EXPAND:
            if (arg == TRUE)

                if (m_bRSOP)
                {
                    if (!m_pRSOPInformation)
                    {
                        lpDataObject->QueryInterface(IID_IRSOPInformation, (LPVOID *)&m_pRSOPInformation);

                        if (m_pRSOPInformation)
                        {
                            m_pszNamespace = (LPOLESTR) LocalAlloc (LPTR, 350 * sizeof(TCHAR));

                            if (m_pszNamespace)
                            {
                                if (m_pRSOPInformation->GetNamespace((m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                                                      m_pszNamespace, 350) == S_OK)
                                {
                                    InitializeRSOPRegistryData();
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Notify:  Failed to query for namespace")));
                                    LocalFree (m_pszNamespace);
                                    m_pszNamespace = NULL;
                                }
                            }
                        }
                    }

                    if (m_pszNamespace && m_pRSOPRegistryData)
                    {
                        hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                    }
                }
                else
                {
                    if (!m_pGPTInformation)
                    {
                        lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);
                    }

                    if (m_pGPTInformation)
                    {
                        hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                    }
                }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CPolicyComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    TABLEENTRY * pTableEntry;

    if (pItem == NULL)
        return E_POINTER;


    if (pItem->lParam == 0)
    {
        pItem->displayname = m_szRootName;
    }
    else
    {
        pTableEntry = (TABLEENTRY *)(pItem->lParam);
        pItem->displayname = GETNAMEPTR(pTableEntry);
    }

    return S_OK;
}

STDMETHODIMP CPolicyComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPPOLICYDATAOBJECT pPolicyDataObjectA, pPolicyDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObjectB)))
    {
        pPolicyDataObjectA->Release();
        return S_FALSE;
    }

    pPolicyDataObjectA->GetCookie(&cookie1);
    pPolicyDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pPolicyDataObjectA->Release();
    pPolicyDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (IExtendContextMenu)           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicyComponentData::AddMenuItems(LPDATAOBJECT piDataObject,
                                          LPCONTEXTMENUCALLBACK pCallback,
                                          LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TCHAR szMenuItem[100];
    TCHAR szDescription[250];
    CONTEXTMENUITEM item;
    LPPOLICYDATAOBJECT pPolicyDataObject;
    MMC_COOKIE cookie = -1;
    DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;

    if (!m_bRSOP)
    {
        if (SUCCEEDED(piDataObject->QueryInterface(IID_IPolicyDataObject,
                     (LPVOID *)&pPolicyDataObject)))
        {
            pPolicyDataObject->GetType(&type);
            pPolicyDataObject->GetCookie(&cookie);

            pPolicyDataObject->Release();
        }


        if ((type == CCT_SCOPE) && (cookie == 0))
        {
            LoadString (g_hInstance, IDS_TEMPLATES, szMenuItem, 100);
            LoadString (g_hInstance, IDS_TEMPLATESDESC, szDescription, 250);

            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_TEMPLATES;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            item.fFlags = 0;
            item.fSpecialFlags = 0;

            hr = pCallback->AddItem(&item);

            if (FAILED(hr))
                return (hr);


            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_TEMPLATES2;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
            item.fFlags = 0;
            item.fSpecialFlags = 0;

            hr = pCallback->AddItem(&item);
        }
    }

    return (hr);
}

STDMETHODIMP CPolicyComponentData::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{

    if ((lCommandID == IDM_TEMPLATES) || (lCommandID == IDM_TEMPLATES2))
    {
        m_bTemplatesColumn = 0;
        if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_TEMPLATES),
                        m_hwndFrame, TemplatesDlgProc, (LPARAM) this))
        {
            //
            // Refresh the adm namespace
            //

            PostMessage (HWND_BROADCAST, m_pSnapin->m_uiRefreshMsg, 0, (LPARAM) GetCurrentProcessId());
        }
    }

    return S_OK;

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (IPersistStreamInit)           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicyComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    if (m_bUserScope)
        *pClassID = CLSID_PolicySnapInUser;
    else
        *pClassID = CLSID_PolicySnapInMachine;

    return S_OK;
}

STDMETHODIMP CPolicyComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CPolicyComponentData::Load(IStream *pStm)
{
    return S_OK;
}


STDMETHODIMP CPolicyComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;
}


STDMETHODIMP CPolicyComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (!pcbSize)
    {
        return E_FAIL;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CPolicyComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (ISnapinHelp)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicyComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gptext.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (Internal functions)           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CPolicyComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    TABLEENTRY *pTemp = NULL;
    DWORD dwResult;
    CPolicySnapIn * pSnapin = NULL, *pSnapinTemp;
    BOOL bRootItem = FALSE;
    HANDLE hEvents[1];


    if (!m_hRoot)
    {
        DWORD dwID;

        m_hRoot = hParent;

        m_hTemplateThread = CreateThread (NULL, 0,
                               (LPTHREAD_START_ROUTINE) LoadTemplatesThread,
                               (LPVOID) this, 0, &dwID);

        if (m_hTemplateThread)
        {
            SetThreadPriority(m_hTemplateThread, THREAD_PRIORITY_LOWEST);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::EnumerateScopePane: Failed to create adm thread with %d"),
                      GetLastError()));
            LoadTemplates();
        }
    }


    if (m_hRoot == hParent)
    {
        item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
        item.displayname = MMC_CALLBACK;
        item.nImage = 0;
        item.nOpenImage = 1;
        item.nState = 0;
        item.cChildren = 1;
        item.lParam = 0;
        item.relativeID =  hParent;

        m_pScope->Expand(hParent);

        if (SUCCEEDED(m_pScope->InsertItem (&item)))
        {
            m_hSWPolicies = item.ID;
        }

        return S_OK;
    }

    hEvents[0] = m_ADMEvent;

    if (WaitForSingleObject (m_ADMEvent, 250) != WAIT_OBJECT_0)
    {
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::EnumerateScopePane: Waiting for ADM event to be signaled.")));

        for (;;) {
            SetCursor (LoadCursor(NULL, IDC_WAIT));

            dwResult = MsgWaitForMultipleObjects(1, hEvents, FALSE, INFINITE, QS_ALLINPUT);

            if (dwResult == WAIT_OBJECT_0 ) {
                break;
            }
            else if (dwResult == WAIT_OBJECT_0 + 1 ) {
                MSG msg;
                
                while ( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ) )
                {
                  TranslateMessage(&msg);
                  DispatchMessage(&msg);
                }
            }
            else {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::EnumerateScopePane: MsgWaitForMultipleObjects returned %d ."), dwResult));
                break;
            }

        }
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::EnumerateScopePane: ADM event has been signaled.")));
        SetCursor (LoadCursor(NULL, IDC_ARROW));
    }

    
    item.mask = SDI_PARAM;
    item.ID = hParent;

    hr = m_pScope->GetItem (&item);

    if (FAILED(hr))
        return hr;


    EnterCriticalSection (&g_ADMCritSec);

    if (item.lParam)
    {
        pTemp = ((TABLEENTRY *)item.lParam)->pChild;
    }
    else
    {
        bRootItem = TRUE;

        if (m_bUserScope)
        {
            if (m_pUserCategoryList)
            {
                pTemp = m_pUserCategoryList->pChild;
            }
            else
            {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::EnumerateScopePane: Empty user list.")));
            }
        }
        else
        {
            if (m_pMachineCategoryList)
            {
                pTemp = m_pMachineCategoryList->pChild;
            }
            else
            {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::EnumerateScopePane: Empty machine list.")));
            }
        }
    }

    //
    // If the user has set the focus on a adm node and then saves the console file,
    // the IComponent won't be created yet.  We need to create a temporary IComponent
    // to parse the data and then release it.
    //

    if (m_pSnapin)
    {
        pSnapinTemp = m_pSnapin;
    }
    else
    {
        pSnapinTemp = pSnapin = new CPolicySnapIn(this);
    }

    while (pTemp)
    {
        if (pTemp->dwType == ETYPE_CATEGORY)
        {
            BOOL bAdd = TRUE;

            if (m_bUseSupportedOnFilter)
            {
                bAdd = IsAnyPolicyAllowedPastFilter(pTemp);
            }

            if (bAdd && m_bShowConfigPoliciesOnly)
            {
               if (pSnapinTemp)
               {
                   bAdd = pSnapinTemp->IsAnyPolicyEnabled(pTemp);
               }
            }


            if (bAdd)
            {
                m_pScope->Expand(hParent);
                item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
                item.displayname = MMC_CALLBACK;
                item.nImage = 0;
                item.nOpenImage = 1;
                item.nState = 0;
                item.cChildren = (CheckForChildCategories(pTemp) ? 1 : 0);
                item.lParam = (LPARAM) pTemp;
                item.relativeID =  hParent;

                m_pScope->InsertItem (&item);
            }
        }

        pTemp = pTemp->pNext;
    }

    //
    // Add the Extra Registry Settings node if appropriate
    //

    if (bRootItem && m_pExtraSettingsRoot)
    {
        if (!m_bExtraSettingsInitialized)
        {
            InitializeExtraSettings();
            m_bExtraSettingsInitialized = TRUE;

            if (LOWORD(dwDebugLevel) == DL_VERBOSE)
            {
                DumpRSOPRegistryData();
            }
        }

        if (m_pExtraSettingsRoot->pChild)
        {
            m_pScope->Expand(hParent);
            
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = 0;
            item.nOpenImage = 1;
            item.nState = 0;
            item.cChildren = 0;
            item.lParam = (LPARAM) m_pExtraSettingsRoot;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
        }
    }

    if (pSnapin)
    {
        pSnapin->Release();
    }

    LeaveCriticalSection (&g_ADMCritSec);

    return S_OK;
}

BOOL CPolicyComponentData::CheckForChildCategories (TABLEENTRY *pParent)
{
    TABLEENTRY * pTemp;

    if (pParent->pChild)
    {
        pTemp = pParent->pChild;

        while (pTemp)
        {
            if (pTemp->dwType == ETYPE_CATEGORY)
            {
                return TRUE;
            }

            pTemp = pTemp->pNext;
        }
    }

    return FALSE;
}

#if DBG

//
// These are a couple of debugging helper functions that will dump
// the adm namespace to the debugger.  Call DumpCurrentTable() to
// get the full namespace.
//

VOID CPolicyComponentData::DumpEntry (TABLEENTRY * pEntry, UINT uIndent)
{
    UINT i;
    TCHAR szDebug[50];

    if (!pEntry)
        return;

    if (pEntry == (TABLEENTRY*) ULongToPtr(0xfeeefeee))
    {
        OutputDebugString (TEXT("Invalid memory address found.\r\n"));
        return;
    }

    while (pEntry)
    {
        if ((pEntry->dwType & ETYPE_CATEGORY) || (pEntry->dwType & ETYPE_POLICY))
        {
            for (i=0; i<uIndent; i++)
                OutputDebugString(TEXT(" "));

            OutputDebugString (GETNAMEPTR(pEntry));

            if (pEntry->pNext && pEntry->pChild)
                wsprintf (szDebug, TEXT(" (0x%x, 0x%x)"),pEntry->pNext, pEntry->pChild);

            else if (!pEntry->pNext && pEntry->pChild)
                wsprintf (szDebug, TEXT(" (NULL, 0x%x)"),pEntry->pChild);

            else if (pEntry->pNext && !pEntry->pChild)
                wsprintf (szDebug, TEXT(" (0x%x, NULL)"),pEntry->pNext);

            OutputDebugString (szDebug);
            OutputDebugString (TEXT("\r\n"));
        }

        if (pEntry->pChild)
            DumpEntry(pEntry->pChild, (uIndent + 4));

        pEntry = pEntry->pNext;
    }
}


VOID CPolicyComponentData::DumpCurrentTable (void)
{
    OutputDebugString (TEXT("\r\n"));
    OutputDebugString (TEXT("\r\n"));
    DumpEntry (m_pListCurrent, 4);
    OutputDebugString (TEXT("\r\n"));
    OutputDebugString (TEXT("\r\n"));
}
#endif

VOID CPolicyComponentData::FreeTemplates (void)
{

    EnterCriticalSection (&g_ADMCritSec);

    if (m_pMachineCategoryList)
    {
        FreeTable(m_pMachineCategoryList);
        m_pMachineCategoryList = NULL;
        m_nMachineDataItems = 0;
    }

    if (m_pUserCategoryList)
    {
        FreeTable(m_pUserCategoryList);
        m_pUserCategoryList = NULL;
        m_nUserDataItems = 0;
    }

    if (m_pSupportedStrings)
    {
        FreeSupportedData(m_pSupportedStrings);
        m_pSupportedStrings = NULL;
    }

    LeaveCriticalSection (&g_ADMCritSec);
}

DWORD CPolicyComponentData::LoadTemplatesThread (CPolicyComponentData * pCD)
{
    HRESULT hr;
    HINSTANCE hInstDLL;

    hInstDLL = LoadLibrary (TEXT("gptext.dll"));

    Sleep(0);

    hr = pCD->LoadTemplates();

    if (hInstDLL)
    {
        FreeLibraryAndExitThread (hInstDLL, (DWORD) hr);
    }

    return (DWORD)hr;
}

void CPolicyComponentData::AddTemplates(LPTSTR lpDest, LPCTSTR lpValueName, UINT idRes)
{
    TCHAR szFiles[MAX_PATH];
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    TCHAR szLogFile[MAX_PATH];
    LPTSTR lpTemp, lpFileName, lpSrc, lpEnd;
    HKEY hKey;
    DWORD dwSize, dwType;


    //
    // Add the adm files.  We get this list from 3 possible
    // places.  The resources, user preferences, policy.
    //

    lstrcpy (szDest, lpDest);
    lpEnd = CheckSlash (szDest);

    lstrcpy (szLogFile, lpDest);
    lstrcat (szLogFile, TEXT("\\admfiles.ini"));

    ExpandEnvironmentStrings (TEXT("%SystemRoot%\\Inf"), szSrc, ARRAYSIZE(szSrc));
    lpSrc = CheckSlash (szSrc);
    ZeroMemory (szFiles, sizeof(szFiles));

    LoadString (g_hInstance, idRes, szFiles,
                ARRAYSIZE(szFiles));

    if (RegOpenKeyEx (HKEY_CURRENT_USER, szUserPrefKey, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szFiles);
        RegQueryValueEx (hKey, lpValueName, NULL, &dwType,
                         (LPBYTE) &szFiles, &dwSize);
        RegCloseKey (hKey);
    }

    if (RegOpenKeyEx (HKEY_CURRENT_USER, szPoliciesKey, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szFiles);
        RegQueryValueEx (hKey, lpValueName, NULL, &dwType,
                         (LPBYTE) &szFiles, &dwSize);
        RegCloseKey (hKey);
    }


    //
    // Parse off the filenames
    //

    lpTemp = lpFileName = szFiles;

    while (*lpTemp)
    {

        while (*lpTemp && (*lpTemp != TEXT(';')))
            lpTemp++;

        if (*lpTemp == TEXT(';'))
        {
            *lpTemp = TEXT('\0');
            lpTemp++;
        }

        while (*lpFileName == TEXT(' '))
            lpFileName++;

        lstrcpy (lpEnd, lpFileName);
        lstrcpy (lpSrc, lpFileName);

        //
        // Check if this file is already in the admfile.ini log
        // If so, skip it
        //

        if (!GetPrivateProfileInt (TEXT("FileList"), lpFileName, 0, szLogFile))
        {
            if (CopyFile (szSrc, szDest, FALSE))
            {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::AddTemplates: Successfully copied %s to %s."), szSrc, szDest));
                WritePrivateProfileString (TEXT("FileList"), lpFileName, TEXT("1"), szLogFile);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to copy %s to %s with %d."), szSrc, szDest, GetLastError()));
            }
        }

        lpFileName = lpTemp;
    }

    SetFileAttributes (szLogFile, FILE_ATTRIBUTE_HIDDEN);

}

void CPolicyComponentData::AddDefaultTemplates(LPTSTR lpDest)
{
    AddTemplates (lpDest, szDefaultTemplates, IDS_DEFAULTTEMPLATES);
}

void CPolicyComponentData::AddNewADMsToExistingGPO (LPTSTR lpDest)
{
    TCHAR szLogFile[MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA fad;


    //
    // This method will add any new adm files to a GPO.
    //
    // Note: the admfiles.ini file is new post-W2k, so we have to do a special
    // case when upgrading a GPO created by w2k to create that file and add
    // the default filenames
    //

    lstrcpy (szLogFile, lpDest);
    lstrcat (szLogFile, TEXT("\\admfiles.ini"));

    if (!GetFileAttributesEx (szLogFile, GetFileExInfoStandard, &fad))
    {
        WritePrivateProfileString (TEXT("FileList"), TEXT("system.adm"), TEXT("1"), szLogFile);
        WritePrivateProfileString (TEXT("FileList"), TEXT("inetres.adm"), TEXT("1"), szLogFile);
        WritePrivateProfileString (TEXT("FileList"), TEXT("conf.adm"), TEXT("1"), szLogFile);
    }

    AddTemplates (lpDest, szAdditionalTemplates, IDS_ADDITIONALTTEMPLATES);
}

void CPolicyComponentData::UpdateExistingTemplates(LPTSTR lpDest)
{
    WIN32_FILE_ATTRIBUTE_DATA fadSrc, fadDest;
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    LPTSTR lpSrc, lpEnd;
    WIN32_FIND_DATA fd;
    HANDLE hFindFile;
    BOOL bDisableAutoUpdate = FALSE;
    HKEY hKey;
    DWORD dwSize, dwType;


    //
    // Check if the user wants their ADM files updated automatically
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bDisableAutoUpdate);
        RegQueryValueEx (hKey, DISABLE_AUTOUPDATE_VALUE, NULL, &dwType,
                         (LPBYTE) &bDisableAutoUpdate, &dwSize);

        RegCloseKey (hKey);
    }

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bDisableAutoUpdate);
        RegQueryValueEx (hKey, DISABLE_AUTOUPDATE_VALUE, NULL, &dwType,
                         (LPBYTE) &bDisableAutoUpdate, &dwSize);

        RegCloseKey (hKey);
    }


    if (bDisableAutoUpdate)
    {
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::UpdateExistingTemplates: Automatic update of ADM files is disabled.")));
        return;
    }


    //
    // Add any new adm files shipped with the OS
    //

    AddNewADMsToExistingGPO (lpDest);


    //
    // Build the path to the source directory
    //

    ExpandEnvironmentStrings (TEXT("%SystemRoot%\\Inf"), szSrc, ARRAYSIZE(szSrc));
    lpSrc = CheckSlash (szSrc);


    //
    // Build the path to the destination directory
    //

    lstrcpy (szDest, lpDest);
    lpEnd = CheckSlash (szDest);
    lstrcpy (lpEnd, TEXT("*.adm"));


    //
    // Enumerate the files
    //

    hFindFile = FindFirstFile(szDest, &fd);

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                lstrcpy (lpEnd, fd.cFileName);
                lstrcpy (lpSrc, fd.cFileName);


                //
                // Get the file attributes of the source and destination
                //

                ZeroMemory (&fadSrc, sizeof(fadSrc));
                ZeroMemory (&fadDest, sizeof(fadDest));

                GetFileAttributesEx (szSrc, GetFileExInfoStandard, &fadSrc);
                GetFileAttributesEx (szDest, GetFileExInfoStandard, &fadDest);


                //
                // If the source is a different size and newer than the dest
                // copy the .adm file
                //

                if ((fadSrc.nFileSizeHigh != fadDest.nFileSizeHigh) ||
                    (fadSrc.nFileSizeLow != fadDest.nFileSizeLow))
                {
                    if (CompareFileTime(&fadSrc.ftLastWriteTime, &fadDest.ftLastWriteTime) == 1)
                    {
                        if (CopyFile (szSrc, szDest, FALSE))
                            DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::UpdateExistingTemplates: Successfully copied %s to %s."), szSrc, szDest));
                        else
                            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::UpdateExistingTemplates: Failed to copy %s to %s with %d."), szSrc, szDest, GetLastError()));
                    }
                }
            }

        } while (FindNextFile(hFindFile, &fd));

        FindClose(hFindFile);
    }
}

HRESULT CPolicyComponentData::LoadGPOTemplates (void)
{
    WIN32_FIND_DATA fd;
    TCHAR szPath[MAX_PATH];
    LPTSTR lpEnd;
    HANDLE hFindFile;
    UINT iResult;
    HRESULT hr;

    hr = m_pGPTInformation->GetFileSysPath(GPO_SECTION_ROOT, szPath, MAX_PATH);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadGPOTemplates: Failed to get gpt path.")));
        return hr;
    }

    //
    // Build the path name
    //

    lpEnd = CheckSlash (szPath);
    lstrcpy (lpEnd, g_szADM);

    iResult = CreateNestedDirectory (szPath, NULL);

    //
    // Based upon the return value, we either exit, add
    // the default templates, or upgrade any existing templates
    //

    if (!iResult)
    {
        return E_FAIL;
    }

    if (iResult == 1)
    {
        AddDefaultTemplates(szPath);
    }
    else
    {
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadGPOTemplates: Updating templates")));
        UpdateExistingTemplates(szPath);
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadGPOTemplates: Finished updating templates")));
    }


    //
    // Enumerate the files
    //

    lpEnd = CheckSlash (szPath);
    lstrcpy (lpEnd, TEXT("*.adm"));

    hFindFile = FindFirstFile(szPath, &fd);

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                lstrcpy (lpEnd, fd.cFileName);
                ParseTemplate (szPath);
            }

        } while (FindNextFile(hFindFile, &fd));


        FindClose(hFindFile);
    }

    return S_OK;
}

#define WINLOGON_KEY                 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")
#define SLOW_LINK_TRANSFER_RATE      500  // Kbps

BOOL CPolicyComponentData::IsSlowLink (LPTSTR lpFileName)
{
    LPTSTR lpComputerName = NULL, lpTemp;
    LPSTR lpComputerNameA = NULL;
    BOOL bResult = FALSE;
    DWORD dwSize, dwResult, dwType;
    struct hostent *hostp;
    ULONG inaddr, ulSpeed, ulTransferRate;
    LONG lResult;
    HKEY hKey;


    //
    // Get the slow timeout
    //

    ulTransferRate = SLOW_LINK_TRANSFER_RATE;

    lResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                           WINLOGON_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwSize = sizeof(ulTransferRate);
        RegQueryValueEx (hKey,
                         TEXT("GroupPolicyMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    lResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                           SYSTEM_POLICIES_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwSize = sizeof(ulTransferRate);
        RegQueryValueEx (hKey,
                         TEXT("GroupPolicyMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // If the transfer rate is 0, then always download adm files
    //

    if (!ulTransferRate)
    {
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::IsSlowLink: Slow link transfer rate is 0.  Always download adm files.")));
        goto Exit;
    }


    //
    // Copy the namespace to a buffer we can edit and drop the leading \\ if present
    //

    lpComputerName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpFileName) + 1) * sizeof(TCHAR));

    if (!lpComputerName)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::IsSlowLink:  Failed to allocate memory for computer name with %d"),
                 GetLastError()));
        goto Exit;
    }


    if ((*lpFileName == TEXT('\\')) && (*(lpFileName+1) == TEXT('\\')))
    {
        lstrcpy (lpComputerName, (lpFileName+2));
    }
    else
    {
        lstrcpy (lpComputerName, lpFileName);
    }


    //
    // Find the slash between the computer name and the share name and replace it with null
    //

    lpTemp = lpComputerName;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
    {
        lpTemp++;
    }

    if (!(*lpTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::IsSlowLink:  Didn't find slash between computer name and share name in %s"),
                 lpComputerName));
        goto Exit;
    }


    *lpTemp = TEXT('\0');


    //
    // Allocate a buffer for the ANSI name
    //
    // Note this buffer is allocated twice as large so handle DBCS characters
    //

    dwSize = (lstrlen(lpComputerName) + 1) * 2;

    lpComputerNameA = (LPSTR) LocalAlloc (LPTR, dwSize);

    if (!lpComputerNameA)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::IsSlowLink:  Failed to allocate memory for ansi computer name with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Convert the computer name to ANSI
    //

    if (WideCharToMultiByte (CP_ACP, 0, lpComputerName, -1, lpComputerNameA, dwSize, NULL, NULL))
    {

        //
        // Get the host information for the computer
        //

        hostp = gethostbyname(lpComputerNameA);

        if (hostp)
        {

            //
            // Get the ip address of the computer
            //

            inaddr = *(long *)hostp->h_addr;


            //
            // Get the transfer rate
            //

            dwResult = PingComputer (inaddr, &ulSpeed);

            if (dwResult == ERROR_SUCCESS)
            {

                if (ulSpeed)
                {

                    //
                    // If the delta time is greater that the timeout time, then this
                    // is a slow link.
                    //

                    if (ulSpeed < ulTransferRate)
                    {
                        bResult = TRUE;
                    }
                }
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::IsSlowLink: PingComputer failed with error %d. Treat it as slow link"), dwResult));
                bResult = TRUE;
            }
        }
    }


Exit:
    if (lpComputerName)
    {
        LocalFree (lpComputerName);
    }

    if (lpComputerNameA)
    {
        LocalFree (lpComputerNameA);
    }

    return bResult;

}

HRESULT CPolicyComponentData::AddADMFile (LPTSTR lpFileName, LPTSTR lpFullFileName,
                                          FILETIME *pFileTime, DWORD dwErr, LPRSOPADMFILE *lpHead)
{
    LPRSOPADMFILE lpTemp;

    if ((lstrlen(lpFileName) >= 100) || (lstrlen(lpFullFileName) >= MAX_PATH))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // First, check if this file is already in the link list
    //

    lpTemp = *lpHead;

    while (lpTemp)
    {
        if (!lstrcmpi(lpFileName, lpTemp->szFileName))
        {
            if (CompareFileTime(pFileTime, &lpTemp->FileTime) == 1)
            {
                lstrcpy (lpTemp->szFullFileName, lpFullFileName);
                lpTemp->FileTime.dwLowDateTime = pFileTime->dwLowDateTime;
                lpTemp->FileTime.dwHighDateTime = pFileTime->dwHighDateTime;
            }

            return S_OK;
        }

        lpTemp = lpTemp->pNext;
    }

    //
    // Add a new node
    //

    lpTemp = (LPRSOPADMFILE) LocalAlloc (LPTR, sizeof(RSOPADMFILE));

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddADMFile: Failed to allocate memory for adm file node")));
        return (HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
    }

    lstrcpy (lpTemp->szFileName, lpFileName);
    lstrcpy (lpTemp->szFullFileName, lpFullFileName);
    lpTemp->FileTime.dwLowDateTime = pFileTime->dwLowDateTime;
    lpTemp->FileTime.dwHighDateTime = pFileTime->dwHighDateTime;
    lpTemp->dwError = dwErr;

    lpTemp->pNext = *lpHead;

    *lpHead = lpTemp;

    return S_OK;
}

HRESULT CPolicyComponentData::LoadRSOPTemplates (void)
{
    BSTR pLanguage = NULL, pQuery = NULL;
    BSTR pName = NULL, pLastWriteTime = NULL, pNamespace = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varName, varLastWriteTime;
    IWbemLocator *pIWbemLocator = NULL;
    IWbemServices *pIWbemServices = NULL;
    SYSTEMTIME SysTime;
    FILETIME FileTime;
    LPTSTR lpFileName;
    LPRSOPADMFILE lpADMFiles = NULL, lpTemp, lpDelete, lpFailedAdmFiles = NULL;
    DWORD dwFailedAdm = 0;
    XBStr xbstrWbemTime;
    DWORD dwError;
    TCHAR szPath[MAX_PATH];
    BOOL bSlowLink = FALSE;


    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Entering")));

    CoInitialize(NULL);

    //
    // Allocate BSTRs for the query language and for the query itself
    //

    pLanguage = SysAllocString (TEXT("WQL"));

    if (!pLanguage)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for language")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    pQuery = SysAllocString (TEXT("SELECT name, lastWriteTime FROM RSOP_AdministrativeTemplateFile"));

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pLastWriteTime = SysAllocString (TEXT("lastWriteTime"));

    if (!pLastWriteTime)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for last write time")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Create an instance of the WMI locator service
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Allocate a BSTR for the namespace
    //

    pNamespace = SysAllocString (m_pszNamespace);

    if (!pNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for namespace")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Connect to the server
    //

    hr = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL,
                                      &pIWbemServices);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: ConnectServer failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet) == S_OK)
    {

        //
        // Check for the "data not available case"
        //

        if (ulRet == 0)
        {
            hr = S_OK;
            goto Exit;
        }


        //
        // Get the name
        //

        hr = pObjects[0]->Get (pName, 0, &varName, NULL, NULL);

        if (SUCCEEDED(hr))
        {
            //
            // Get the last write time
            //

            hr = pObjects[0]->Get (pLastWriteTime, 0, &varLastWriteTime, NULL, NULL);

            if (SUCCEEDED(hr))
            {
                xbstrWbemTime = varLastWriteTime.bstrVal;

                hr = WbemTimeToSystemTime(xbstrWbemTime, SysTime);

                if (SUCCEEDED(hr))
                {
                    SystemTimeToFileTime (&SysTime, &FileTime);

                    lpFileName = varName.bstrVal + lstrlen(varName.bstrVal);

                    while ((lpFileName > varName.bstrVal) && (*lpFileName != TEXT('\\')))
                        lpFileName--;

                    if (*lpFileName == TEXT('\\'))
                    {
                        lpFileName++;
                    }

                    AddADMFile (lpFileName, varName.bstrVal, &FileTime, 0, &lpADMFiles);
                }

                VariantClear (&varLastWriteTime);
            }

            VariantClear (&varName);
        }

        pObjects[0]->Release();
    }


    //
    // Parse the adm files
    //

    lpTemp = lpADMFiles;

    while (lpTemp)
    {

        SetLastError(ERROR_SUCCESS);

        if (!bSlowLink)
        {
            bSlowLink = IsSlowLink (lpTemp->szFullFileName);
        }

        if (bSlowLink || !ParseTemplate(lpTemp->szFullFileName))
        {
            //
            // If the adm file failed to parse for any of the reasons listed
            // below, switch over to using the local copy of the ADM file
            //

            dwError = GetLastError();

            if (bSlowLink || ((dwError != ERROR_SUCCESS) && 
                              (dwError != ERROR_ALREADY_DISPLAYED)))
            {
                if (bSlowLink)
                {
                    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Using local copy of %s due to slow link detection."),
                    lpTemp->szFileName));
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Unable to parse template %s due to error %d.  Switching to the local copy of %s."),
                    lpTemp->szFullFileName, dwError, lpTemp->szFileName));
                    AddADMFile (lpTemp->szFileName, lpTemp->szFullFileName, &(lpTemp->FileTime), dwError, &lpFailedAdmFiles);
                    dwFailedAdm++;
                }

                ExpandEnvironmentStrings (TEXT("%SystemRoot%\\inf\\"), szPath, MAX_PATH);
                lstrcat (szPath, lpTemp->szFileName);
                ParseTemplate (szPath);
            }
        }

        lpDelete = lpTemp;
        lpTemp = lpTemp->pNext;
        LocalFree (lpDelete);
    }



    hr = S_OK;

    //
    // Format a error msg for the failed adm files
    // ignore any errors
    //

    if (dwFailedAdm) {
        LPTSTR lpErr = NULL, lpEnd = NULL;
        TCHAR szErrFormat[MAX_PATH];
        TCHAR szError[MAX_PATH];

        szErrFormat[0] = TEXT('\0');
        LoadString (g_hInstance, IDS_FAILED_RSOPFMT, szErrFormat, ARRAYSIZE(szErrFormat));

        lpErr = (LPTSTR)LocalAlloc(LPTR, (600*dwFailedAdm)*sizeof(TCHAR));

        if (!lpErr) {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Couldn't allocate memory for the error buffer."), GetLastError()));
            goto Exit;
        }

        lpTemp = lpFailedAdmFiles;

        lpEnd = lpErr;

        while (lpTemp) {

            szError[0] = TEXT('\0');
            LoadMessage(lpTemp->dwError, szError, ARRAYSIZE(szError));

            wsprintf(lpEnd, szErrFormat, lpTemp->szFileName, lpTemp->szFullFileName, szError);

            lpEnd += lstrlen(lpEnd);

            lpDelete = lpTemp;
            lpTemp = lpTemp->pNext;
            LocalFree (lpDelete);
        }

        // we cannot pass in a owner window handle here, b'cos this
        // is being done in a seperate thread and the main thread can be
        // waiting for the templatethread event

        ReportAdmError(NULL, 0, IDS_RSOP_ADMFAILED, lpErr);
        lpFailedAdmFiles = NULL;

        LocalFree(lpErr);
    }

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pIWbemLocator)
    {
        pIWbemLocator->Release();
    }

    if (pIWbemServices)
    {
        pIWbemServices->Release();
    }

    if (pLanguage)
    {
        SysFreeString (pLanguage);
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    if (pLastWriteTime)
    {
        SysFreeString (pLastWriteTime);
    }

    if (pNamespace)
    {
        SysFreeString (pNamespace);
    }

    lpTemp = lpFailedAdmFiles;

    while (lpTemp) {
        lpDelete = lpTemp;
        lpTemp = lpTemp->pNext;
        LocalFree (lpDelete);
    }
    
    lpFailedAdmFiles = NULL;

    CoUninitialize();

    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Leaving")));

    return hr;
}

HRESULT CPolicyComponentData::LoadTemplates (void)
{
    HRESULT hr = E_FAIL;

    if (m_bUserScope)
    {
       DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadTemplates: Entering for User")));
    }
    else
    {
       DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadTemplates: Entering for Machine")));
    }


    //
    // Reset the ADM event
    //

    ResetEvent (m_ADMEvent);


    //
    // Free any old templates
    //

    FreeTemplates ();



    EnterCriticalSection (&g_ADMCritSec);


    //
    // Prepare to load the templates
    //

    m_nUserDataItems = 0;
    m_nMachineDataItems = 0;

    m_pMachineCategoryList = (TABLEENTRY *) GlobalAlloc(GPTR,sizeof(TABLEENTRY));

    if (!m_pMachineCategoryList)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadTemplates: Failed to alloc memory with %d"),
                 GetLastError()));
        goto Exit;
    }

    m_pUserCategoryList = (TABLEENTRY *) GlobalAlloc(GPTR,sizeof(TABLEENTRY));

    if (!m_pUserCategoryList)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadTemplates: Failed to alloc memory with %d"),
                 GetLastError()));
        GlobalFree (m_pMachineCategoryList);
        goto Exit;
    }


    m_pMachineCategoryList->dwSize = m_pUserCategoryList->dwSize = sizeof(TABLEENTRY);
    m_pMachineCategoryList->dwType = m_pUserCategoryList->dwType = ETYPE_ROOT;



    //
    // Load the appropriate template files
    //

    if (m_bRSOP)
    {
        hr = LoadRSOPTemplates();
    }
    else
    {
        hr = LoadGPOTemplates();

        if (SUCCEEDED(hr))
        {
            TCHAR szUnknown[150];

            LoadString (g_hInstance, IDS_NOSUPPORTINFO, szUnknown, ARRAYSIZE(szUnknown));
            AddSupportedNode (&m_pSupportedStrings, szUnknown, TRUE);

            if (m_bUserScope)
            {
                InitializeSupportInfo(m_pUserCategoryList, &m_pSupportedStrings);
            }
            else
            {
                InitializeSupportInfo(m_pMachineCategoryList, &m_pSupportedStrings);
            }
        }
    }


Exit:

    SetEvent (m_ADMEvent);

    LeaveCriticalSection (&g_ADMCritSec);

    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadTemplates: Leaving")));

    return hr;
}

BOOL CPolicyComponentData::ParseTemplate (LPTSTR lpFileName)
{
    HANDLE hFile;
    BOOL fMore;
    UINT uRet;
    LANGID langid;
    TCHAR szLocalizedSection[20];
    DWORD dwSize, dwRead;
    LPVOID lpFile, lpTemp;
    TCHAR szTempPath[MAX_PATH+1];
    TCHAR szLocalPath[MAX_PATH+1];


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseTemplate: Loading <%s>..."),
             lpFileName));


    //
    // Set defaults
    //

    m_nFileLine = 1;
    m_pListCurrent = m_pMachineCategoryList;
    m_pnDataItemCount = &m_nMachineDataItems;
    m_pszParseFileName = lpFileName;


    //
    //  Make a local copy of the adm file
    //

    if (!GetTempPath(ARRAYSIZE(szTempPath), szTempPath)) {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplate:  Failed to query for temp directory with error %d."), GetLastError()));
        return FALSE;
    }


    if (!GetTempFileName (szTempPath, TEXT("adm"), 0, szLocalPath)) {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplate:  Failed to create temporary filename with error %d."), GetLastError()));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseTemplate: Temp filename is <%s>"),
             szLocalPath));


    //
    // Copy the file
    //

    if (!CopyFile(lpFileName, szLocalPath, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplate:  Failed to copy adm file with error %d."), GetLastError()));
        return FALSE;
    }


    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseTemplate: ADM file copied successfully.")));


    //
    // Read in the adm file
    //

    hFile = CreateFile (szLocalPath, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplate: Failed to load <%s> with %d"),
                 szLocalPath, GetLastError()));
        DeleteFile (szLocalPath);
        return FALSE;
    }


    dwSize = GetFileSize (hFile, NULL);

    if (dwSize == 0xFFFFFFFF)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to get file size with %d."),
                 GetLastError()));
        CloseHandle (hFile);
        DeleteFile (szLocalPath);
        return FALSE;
    }


    if (!(lpFile = GlobalAlloc(GPTR, dwSize)))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to allocate memory for %d bytes with %d."),
                 dwSize, GetLastError()));
        CloseHandle (hFile);
        DeleteFile (szLocalPath);
        return FALSE;
    }


    if (!ReadFile (hFile, lpFile, dwSize, &dwRead, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to read file with %d."),
                 GetLastError()));
        GlobalFree(lpFile);
        CloseHandle (hFile);
        DeleteFile (szLocalPath);
        return FALSE;
    }


    CloseHandle (hFile);



    if (dwRead >= sizeof(WCHAR))
    {
        if (!IsTextUnicode(lpFile, dwRead, NULL))
        {
            if (!(lpTemp = GlobalAlloc(GPTR, dwSize * sizeof(WCHAR))))
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to allocate memory for %d WCHARS with %d."),
                         dwSize, GetLastError()));
                GlobalFree(lpFile);
                DeleteFile (szLocalPath);
                return FALSE;
            }

            if ( !MultiByteToWideChar (CP_ACP, 0, (LPCSTR) lpFile, dwRead, (LPWSTR)lpTemp, dwRead) )
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to convert ANSI adm file to Unicode with %d."),
                         GetLastError()));
                GlobalFree(lpTemp);
                GlobalFree(lpFile);
                DeleteFile (szLocalPath);
                return FALSE;
            }

            GlobalFree (lpFile);
            lpFile = lpTemp;
            dwRead *= sizeof(WCHAR);
        }
    }


    m_pFilePtr = (LPWSTR)lpFile;
    m_pFileEnd = (LPWSTR)((LPBYTE)lpFile + dwRead - 1);


    //
    // Read in the string sections
    //

    langid = GetUserDefaultLangID();
    wsprintf (szLocalizedSection, TEXT("%04x"), langid);
    m_pLocaleStrings = GetStringSection (szLocalizedSection, szLocalPath);

    wsprintf (szLocalizedSection, TEXT("%04x"), PRIMARYLANGID(langid));
    m_pLanguageStrings = GetStringSection (szLocalizedSection, szLocalPath);

    m_pDefaultStrings = GetStringSection (szStrings, szLocalPath);

    DeleteFile (szLocalPath);


    //
    // Parse the file
    //

    m_fInComment = FALSE;

    do {

        uRet=ParseClass(&fMore);

    } while (fMore && uRet == ERROR_SUCCESS);


    //
    // Cleanup
    //

    GlobalFree(lpFile);

    if (m_pLocaleStrings)
    {
        GlobalFree(m_pLocaleStrings);
    }


    if (m_pLanguageStrings)
    {
        GlobalFree(m_pLanguageStrings);
    }


    if (m_pDefaultStrings)
    {
        GlobalFree(m_pDefaultStrings);
    }


    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseTemplate: Finished.")));

    return TRUE;
}


UINT CPolicyComponentData::ParseClass(BOOL *pfMore)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr, nKeywordID, nClassID;


    if (!GetNextWord(szWordBuf,ARRAYSIZE(szWordBuf),pfMore,&uErr))
        return uErr;


    if (!CompareKeyword(szWordBuf,pClassCmpList,&nKeywordID))
        return ERROR_ALREADY_DISPLAYED;

    switch (nKeywordID) {

        case KYWD_ID_CATEGORY:

            return ParseCategory(m_pListCurrent, FALSE,pfMore, NULL);

        case KYWD_ID_CLASS:

            if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                pClassTypeCmpList,&nClassID,pfMore,&uErr))
               return uErr;

            switch (nClassID) {

                case KYWD_ID_USER:
                    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseClass: User section")));
                    m_pListCurrent = m_pUserCategoryList;
                    m_pnDataItemCount = &m_nUserDataItems;
                    m_bRetrieveString = (m_bUserScope ? TRUE : FALSE);
                    break;

                case KYWD_ID_MACHINE:
                    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseClass: Machine section")));
                    m_pListCurrent = m_pMachineCategoryList;
                    m_pnDataItemCount = &m_nMachineDataItems;
                    m_bRetrieveString = (m_bUserScope ? FALSE : TRUE);
                    break;
            }
            break;

        // hack for localization: allow a "strings" section at the bottom, if we
        // encounter that then we're thru with parsing
        case KYWD_ID_STRINGSSECT:
            *pfMore = FALSE;    // that's all, folks
            return ERROR_SUCCESS;
            break;
    }

    return ERROR_SUCCESS;
}

TABLEENTRY * CPolicyComponentData::FindCategory(TABLEENTRY *pParent, LPTSTR lpName)
{
    TABLEENTRY *pEntry = NULL, *pTemp;


    if (m_bRetrieveString && pParent) {

        pTemp = pParent->pChild;

        while (pTemp) {

            if (pTemp->dwType & ETYPE_CATEGORY) {
                if (!lstrcmpi (lpName, GETNAMEPTR(pTemp))) {
                    pEntry = pTemp;
                    break;
                }
            }
            pTemp = pTemp->pNext;
        }
    }

    return pEntry;
}


/*******************************************************************

    NAME:       ParseEntry

    SYNOPSIS:   Main parsing "engine" for category, policy and part
                parsing

    NOTES:      Allocates memory to build a temporary TABLEENTRY struct
                describing the parsed information.  Reads the beginning and end of a
                section and loops through the words in each section, calling
                a caller-defined ParseProc for each keyword to let the
                caller handle appropriately.  Passes the newly-constucted
                TABLEENTRY to AddTableEntry to save it, and frees the temporary
                memory.
                This function is re-entrant.
                The ENTRYDATA struct is declared on ParseEntry's stack
                but used by the ParseProc to maintain state between
                calls-- e.g., whether or not a key name has been found.
                This can't be maintained as a static in the ParseProc because
                the ParseProc may be reentered (for instance, if categories
                have subcategories).
                There are many possible error paths and there is some
                memory dealloc that needs to be done in an error case. Rather
                than do deallocs by hand on every error path or use a "goto
                cleanup" (ick!), items to be freed are added to a "cleanup
                list" and then CleanupAndReturn is called in an error condition,
                which frees items on the list and returns a specified value.

    ENTRY:      ppes-- PARSEENTRYSTRUCT that specifes type of entry, the
                    parent table, a keyword list, a ParseProc callback
                    and other goodies
                pfMore-- set to FALSE if at end of file

    EXIT:       ERROR_SUCCESS if successful, otherwise an error code
                (can be ERROR_ALREADY_DISPLAYED)

********************************************************************/
UINT CPolicyComponentData::ParseEntry(PARSEENTRYSTRUCT *ppes,BOOL *pfMore,
                                      LPTSTR pKeyName)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr,nListIndex;
    BOOL fFoundEnd = FALSE;
    PARSEPROCSTRUCT pps;
    ENTRYDATA EntryData;
    DWORD dwBufSize = DEFAULT_TMP_BUF_SIZE;
    TABLEENTRY *pTmp = NULL;
    BOOL bNewEntry = TRUE;

    memset(&pps,0,sizeof(pps));
    memset(&EntryData,0,sizeof(EntryData));

    pps.pdwBufSize = &dwBufSize;
    pps.pData = &EntryData;
    pps.pData->fParentHasKey = ppes->fParentHasKey;
    pps.pEntryCmpList = ppes->pEntryCmpList;

    // get the entry name
    if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr)) {
        return uErr;
    }

    if (ppes->dwEntryType & ETYPE_CATEGORY) {

        pTmp = FindCategory (ppes->pParent, szWordBuf);
    }

    if (pTmp) {

        bNewEntry = FALSE;

    } else {

        //
        // Create a new table entry
        //

        if (!(pps.pTableEntry = (TABLEENTRY *) GlobalAlloc(GPTR,*pps.pdwBufSize)))
            return ERROR_NOT_ENOUGH_MEMORY;

        // initialize TABLEENTRY struct
        pps.pTableEntry->dwSize = ppes->dwStructSize;
        pps.pTableEntry->dwType = ppes->dwEntryType;

        // store the entry name in pTableEntry
        pTmp = (TABLEENTRY *) AddDataToEntry(pps.pTableEntry,
            (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pps.pTableEntry->uOffsetName),
            pps.pdwBufSize);

        if (!pTmp) {
            GlobalFree ((HGLOBAL)pps.pTableEntry);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    }


    pps.pTableEntry = pTmp;

    // loop through the body of the declaration
    while (!fFoundEnd && GetNextSectionWord(szWordBuf,
        ARRAYSIZE(szWordBuf),pps.pEntryCmpList,&nListIndex,pfMore,&uErr)) {

        if ( (uErr = (*ppes->pParseProc) (this, nListIndex,&pps,pfMore,&fFoundEnd,pKeyName))
            != ERROR_SUCCESS) {
            if (bNewEntry) {
                GlobalFree ((HGLOBAL)pps.pTableEntry);
            }
            return (uErr);
        }

        if (!bNewEntry) {

            if (pTmp != pps.pTableEntry) {

                //
                // We need to fix up the link list of pointers in case the tableentry
                // has moved due to a realloc
                //

                if (pps.pTableEntry->pPrev) {
                    pps.pTableEntry->pPrev->pNext = pps.pTableEntry;
                } else {
                    ppes->pParent->pChild = pps.pTableEntry;
                }

                if (pps.pTableEntry->pNext) {
                    pps.pTableEntry->pNext->pPrev = pps.pTableEntry;
                }

                pTmp = pps.pTableEntry;
            }
        }
    }

    if (uErr != ERROR_SUCCESS) {
        if (bNewEntry) {
            GlobalFree ((HGLOBAL)pps.pTableEntry);
        }
        return (uErr);
    }

    // Last word was "END"

    // get the keyword that goes with "END" ("END CATGORY", "END POLICY", etc.)
    if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
        ppes->pTypeCmpList,&nListIndex,pfMore,&uErr)) {

        if (bNewEntry) {
            GlobalFree ((HGLOBAL)pps.pTableEntry);
        }
        return (uErr);
    }

    // call the object's parse proc one last time to let it object if
    // key name or something like that is missing
    if ( (uErr = (*ppes->pParseProc) (this, KYWD_DONE,&pps,pfMore,&fFoundEnd,pKeyName))
        != ERROR_SUCCESS) {
        if (bNewEntry) {
            GlobalFree ((HGLOBAL)pps.pTableEntry);
        }
        return (uErr);
    }

    if (bNewEntry) {

        // fix up linked list pointers.  If parent has no children yet, make this
        // 1st child; otherwise walk the list of children and insert this at the end
        if (!ppes->pParent->pChild) {
            ppes->pParent->pChild = pps.pTableEntry;
        } else {
            TABLEENTRY * pLastChild = ppes->pParent->pChild;
            while (pLastChild->pNext) {
                pLastChild = pLastChild->pNext;
            }
            pLastChild->pNext = pps.pTableEntry;
            pps.pTableEntry->pPrev = pLastChild;
        }
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

    NAME:       ParseCategory

    SYNOPSIS:   Parses a category

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.

********************************************************************/
UINT CPolicyComponentData::ParseCategory(TABLEENTRY * pParent,
                                         BOOL fParentHasKey,BOOL *pfMore,
                                         LPTSTR pKeyName)
{
    PARSEENTRYSTRUCT pes;

    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_CATEGORY;
    pes.pEntryCmpList = pCategoryEntryCmpList;
    pes.pTypeCmpList = pCategoryTypeCmpList;
    pes.pParseProc = CategoryParseProc;
    pes.dwStructSize = sizeof(CATEGORY);
    pes.fHasSubtable = TRUE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(&pes,pfMore,pKeyName);
}

/*******************************************************************

    NAME:       CategoryParseProc

    SYNOPSIS:   Keyword callback ParseProc for category parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT CPolicyComponentData::CategoryParseProc(CPolicyComponentData * pCD,
                                             UINT nMsg,PARSEPROCSTRUCT * ppps,
                                             BOOL * pfMore,BOOL * pfFoundEnd,
                                             LPTSTR pKeyName)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    CATEGORY * pCategory = (CATEGORY *) ppps->pTableEntry;
    TABLEENTRY * pOld = ppps->pTableEntry, *pTmp;
    LPTSTR lpHelpBuf;
    UINT uErr;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pCategory
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pCategory,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pCategory->uOffsetKeyName),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_POLICY:
        case KYWD_ID_CATEGORY:

            {
                BOOL fHasKey = ppps->pData->fHasKey | ppps->pData->fParentHasKey;
                if (nMsg == KYWD_ID_POLICY)
                    uErr=pCD->ParsePolicy((TABLEENTRY *) pCategory,fHasKey,pfMore,
                                          (ppps->pData->fHasKey ? GETKEYNAMEPTR(pCategory) : pKeyName));
                else
                    uErr=pCD->ParseCategory((TABLEENTRY *) pCategory,fHasKey,pfMore,
                                          (ppps->pData->fHasKey ? GETKEYNAMEPTR(pCategory) : pKeyName));
            }

            return uErr;
            break;

        case KYWD_ID_HELP:

            // have we already found a help string already?
            if (pCategory->uOffsetHelp) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_HELP,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            lpHelpBuf = (LPTSTR) LocalAlloc (LPTR, HELPBUFSIZE * sizeof(TCHAR));

            if (!lpHelpBuf) {
                pCD->DisplayKeywordError(IDS_ErrOUTOFMEMORY,NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the help string
            if (!pCD->GetNextSectionWord(lpHelpBuf,HELPBUFSIZE,
                NULL,NULL,pfMore,&uErr)) {
                LocalFree (lpHelpBuf);
                return uErr;
            }

            // store the help string
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pCategory,
                (BYTE *)lpHelpBuf,(lstrlen(lpHelpBuf)+1) * sizeof(TCHAR),&(pCategory->uOffsetHelp),
                ppps->pdwBufSize);

            LocalFree (lpHelpBuf);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_DONE:
            if (!ppps->pData->fHasKey && pKeyName) {

                // store the key name in pCategory
                pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pCategory,
                    (BYTE *)pKeyName,(lstrlen(pKeyName)+1) * sizeof(TCHAR),&(pCategory->uOffsetKeyName),
                    ppps->pdwBufSize);

                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;

                ppps->pData->fHasKey = TRUE;

            }
            return ERROR_SUCCESS;
            break;

        default:
            return ERROR_SUCCESS;
            break;
    }
}


/*******************************************************************

    NAME:       ParsePolicy

    SYNOPSIS:   Parses a policy

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.
********************************************************************/

UINT CPolicyComponentData::ParsePolicy(TABLEENTRY * pParent,
                                       BOOL fParentHasKey,BOOL *pfMore,
                                       LPTSTR pKeyName)
{
    PARSEENTRYSTRUCT pes;

    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_POLICY;
    pes.pEntryCmpList = pPolicyEntryCmpList;
    pes.pTypeCmpList = pPolicyTypeCmpList;
    pes.pParseProc = PolicyParseProc;
    pes.dwStructSize = sizeof(POLICY);
    pes.fHasSubtable = TRUE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(&pes,pfMore, pKeyName);
}

/*******************************************************************

    NAME:       PolicyParseProc

    SYNOPSIS:   Keyword callback ParseProc for policy parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT CPolicyComponentData::PolicyParseProc(CPolicyComponentData * pCD,
                     UINT nMsg,PARSEPROCSTRUCT * ppps,
                     BOOL * pfMore,BOOL * pfFoundEnd,LPTSTR pKeyName)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    LPTSTR lpHelpBuf, lpKeyName;
    POLICY * pPolicy = (POLICY *) ppps->pTableEntry;
    TABLEENTRY * pOld = ppps->pTableEntry, *pTmp;
    UINT uErr;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pPolicy
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1)*sizeof(TCHAR),&(pPolicy->uOffsetKeyName),ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;
            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;

        case KYWD_ID_VALUENAME:

            // have we already found a key name?
            if (ppps->pData->fHasValue) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_VALUENAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pPolicy->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;

        case KYWD_ID_HELP:

            // have we already found a help string already?
            if (pPolicy->uOffsetHelp) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_HELP,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            lpHelpBuf = (LPTSTR) LocalAlloc (LPTR, HELPBUFSIZE * sizeof(TCHAR));

            if (!lpHelpBuf) {
                pCD->DisplayKeywordError(IDS_ErrOUTOFMEMORY,NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the help string
            if (!pCD->GetNextSectionWord(lpHelpBuf,HELPBUFSIZE,
                NULL,NULL,pfMore,&uErr)) {
                LocalFree (lpHelpBuf);
                return uErr;
            }

            // store the help string
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)lpHelpBuf,(lstrlen(lpHelpBuf)+1) * sizeof(TCHAR),&(pPolicy->uOffsetHelp),
                ppps->pdwBufSize);

            LocalFree (lpHelpBuf);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_ID_CLIENTEXT:

            // have we already found a clientext string already?
            if (pPolicy->uOffsetClientExt) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_CLIENTEXT,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            if (!ValidateGuid(szWordBuf))
            {
                pCD->DisplayKeywordError(IDS_ParseErr_INVALID_CLIENTEXT,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // store the clientext string in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pPolicy->uOffsetClientExt),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_ID_SUPPORTED:

            // have we already found a supported string already?
            if (pPolicy->uOffsetSupported) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_SUPPORTED,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the supported platforms
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the supported string in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pPolicy->uOffsetSupported),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;

        case KYWD_ID_PART:
            {
                BOOL fHasKey = ppps->pData->fHasKey | ppps->pData->fParentHasKey;
                return pCD->ParseSettings((TABLEENTRY *) pPolicy,fHasKey,pfMore,
                                          (ppps->pData->fHasKey ? GETKEYNAMEPTR(pPolicy) : pKeyName));
            }

        case KYWD_ID_VALUEON:
            return pCD->ParseValue(ppps,&pPolicy->uOffsetValue_On,
                &ppps->pTableEntry,pfMore);


        case KYWD_ID_VALUEOFF:
            return pCD->ParseValue(ppps,&pPolicy->uOffsetValue_Off,
                &ppps->pTableEntry,pfMore);


        case KYWD_ID_ACTIONLISTON:
            return pCD->ParseActionList(ppps,&pPolicy->uOffsetActionList_On,
                &ppps->pTableEntry,szACTIONLISTON,pfMore);


        case KYWD_ID_ACTIONLISTOFF:
            return pCD->ParseActionList(ppps,&pPolicy->uOffsetActionList_Off,
                &ppps->pTableEntry,szACTIONLISTOFF,pfMore);


        case KYWD_DONE:

            if (!ppps->pData->fHasKey) {

                if (!ppps->pData->fParentHasKey) {
                    pCD->DisplayKeywordError(IDS_ParseErr_NO_KEYNAME,NULL,NULL);
                    return ERROR_ALREADY_DISPLAYED;
                }

                // store the key name in pPolicy
                pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                    (BYTE *)pKeyName,(lstrlen(pKeyName)+1)*sizeof(TCHAR),&(pPolicy->uOffsetKeyName),ppps->pdwBufSize);

                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;
                pPolicy = (POLICY *) pTmp;

                ppps->pData->fHasKey = TRUE;
            }

            if (!pPolicy->uOffsetValueName && !pPolicy->pChild)
            {
                if ((!pPolicy->uOffsetValue_On && pPolicy->uOffsetValue_Off) ||
                    (pPolicy->uOffsetValue_On && !pPolicy->uOffsetValue_Off))
                {
                    pCD->DisplayKeywordError(IDS_ParseErr_MISSINGVALUEON_OR_OFF,NULL,NULL);
                    return ERROR_ALREADY_DISPLAYED;
                }
            }

            //
            // Check if this is a real policy
            //

            lpKeyName = GETKEYNAMEPTR(ppps->pTableEntry);

            if (!lpKeyName) {
                return ERROR_INVALID_PARAMETER;
            }

            if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                              lpKeyName, pCD->m_iSWPoliciesLen,
                              SOFTWARE_POLICIES, pCD->m_iSWPoliciesLen) == CSTR_EQUAL)
            {
                ((POLICY *) ppps->pTableEntry)->bTruePolicy = TRUE;
            }

            else if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                              lpKeyName, pCD->m_iWinPoliciesLen,
                              WINDOWS_POLICIES, pCD->m_iWinPoliciesLen) == CSTR_EQUAL)
            {
                ((POLICY *) ppps->pTableEntry)->bTruePolicy = TRUE;
            }


            ( (POLICY *) ppps->pTableEntry)->uDataIndex = *pCD->m_pnDataItemCount;
            (*pCD->m_pnDataItemCount) ++;

            return ERROR_SUCCESS;

        default:
            break;
    }

    return ERROR_SUCCESS;
}


/*******************************************************************

    NAME:       ParseSettings

    SYNOPSIS:   Parses a policy setting

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.

********************************************************************/
UINT CPolicyComponentData::ParseSettings(TABLEENTRY * pParent,
                                         BOOL fParentHasKey,BOOL *pfMore,
                                         LPTSTR pKeyName)
{
    PARSEENTRYSTRUCT pes;

    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_SETTING;
    pes.pEntryCmpList = pSettingsEntryCmpList;
    pes.pTypeCmpList = pSettingsTypeCmpList;
    pes.pParseProc = SettingsParseProc;
    pes.dwStructSize = sizeof(SETTINGS);
    pes.fHasSubtable = FALSE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(&pes,pfMore, pKeyName);
}

/*******************************************************************

    NAME:       SettingsParseProc

    SYNOPSIS:   Keyword callback ParseProc for policy settings parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT CPolicyComponentData::SettingsParseProc(CPolicyComponentData *pCD,
                                             UINT nMsg,PARSEPROCSTRUCT * ppps,
                                             BOOL * pfMore,BOOL * pfFoundEnd,
                                             LPTSTR pKeyName)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];

    SETTINGS * pSettings = (SETTINGS *) ppps->pTableEntry;
    BYTE * pObjectData = GETOBJECTDATAPTR(pSettings);
    TABLEENTRY *pTmp;

    UINT uErr;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pSettings->uOffsetKeyName),ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_VALUENAME:

            // have we already found a value name?
            if (ppps->pData->fHasValue) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_VALUENAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the value name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the value name in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pSettings->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;

            ppps->pTableEntry = pTmp;
            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_CLIENTEXT:

            // have we already found a clientext string already?
            if (pSettings->uOffsetClientExt) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_CLIENTEXT,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the clientext name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            if (!ValidateGuid(szWordBuf))
            {
                pCD->DisplayKeywordError(IDS_ParseErr_INVALID_CLIENTEXT,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // store the clientext string in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pSettings->uOffsetClientExt),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_ID_REQUIRED:
            pSettings->dwFlags |= DF_REQUIRED;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_EXPANDABLETEXT:
            pSettings->dwFlags |= DF_EXPANDABLETEXT;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_SUGGESTIONS:

            return pCD->ParseSuggestions(ppps,&((POLICYCOMBOBOXINFO *)
                (GETOBJECTDATAPTR(pSettings)))->uOffsetSuggestions,
                &ppps->pTableEntry,pfMore);

        case KYWD_ID_TXTCONVERT:
            pSettings->dwFlags |= DF_TXTCONVERT;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_SOFT:
            pSettings->dwFlags |= VF_SOFT;
            return ERROR_SUCCESS;
            break;

        case KYWD_DONE:
            if (!ppps->pData->fHasKey) {

                if (!ppps->pData->fParentHasKey) {
                    pCD->DisplayKeywordError(IDS_ParseErr_NO_KEYNAME,NULL,NULL);
                    return ERROR_ALREADY_DISPLAYED;
                }

                // store the key name in pSettings
                pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                    (BYTE *)pKeyName,(lstrlen(pKeyName)+1) * sizeof(TCHAR),&(pSettings->uOffsetKeyName),ppps->pdwBufSize);
                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;

                ppps->pTableEntry = pTmp;

                ppps->pData->fHasKey = TRUE;
            }

            if (!ppps->pData->fHasValue) {
                pCD->DisplayKeywordError(IDS_ParseErr_NO_VALUENAME,NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            ( (SETTINGS *) ppps->pTableEntry)->uDataIndex = *pCD->m_pnDataItemCount;
            (*pCD->m_pnDataItemCount) ++;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_CHECKBOX:
            return (pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_CHECKBOX,
                sizeof(CHECKBOXINFO),pCheckboxCmpList,&pSettings,&pObjectData));
            break;

        case KYWD_ID_TEXT:
            ppps->pData->fHasValue = TRUE;  // no key value for static text items
            return (pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_TEXT,
                0,pTextCmpList,&pSettings,&pObjectData));
            break;

        case KYWD_ID_EDITTEXT:
            uErr=pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_EDITTEXT,
                sizeof(EDITTEXTINFO),pEditTextCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(((SETTINGS *) ppps->pTableEntry)));

                if (!pEditTextInfo) {
                    return ERROR_INVALID_PARAMETER;
                }
                pEditTextInfo->nMaxLen = MAXSTRLEN;

            }
            break;

        case KYWD_ID_COMBOBOX:
            uErr=pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_COMBOBOX,
                sizeof(POLICYCOMBOBOXINFO),pComboboxCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(((SETTINGS *) ppps->pTableEntry)));

                pEditTextInfo->nMaxLen = MAXSTRLEN;

            }
            break;

        case KYWD_ID_NUMERIC:
            uErr=pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_NUMERIC,
                sizeof(NUMERICINFO),pNumericCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;

            if (!pObjectData) return ERROR_INVALID_PARAMETER;

            ( (NUMERICINFO *) pObjectData)->uDefValue = 1;
            ( (NUMERICINFO *) pObjectData)->uMinValue = 1;
            ( (NUMERICINFO *) pObjectData)->uMaxValue = 9999;
            ( (NUMERICINFO *) pObjectData)->uSpinIncrement = 1;

            break;

        case KYWD_ID_DROPDOWNLIST:
            ppps->pEntryCmpList = pDropdownlistCmpList;
            ppps->pTableEntry->dwType = ETYPE_SETTING | STYPE_DROPDOWNLIST;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_LISTBOX:
            uErr=pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_LISTBOX,
                sizeof(LISTBOXINFO),pListboxCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;

            // listboxes have no single value name, set the value name to ""
            pTmp  = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                (BYTE *) g_szNull,(lstrlen(g_szNull)+1) * sizeof(TCHAR),&(pSettings->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_EDITTEXT_DEFAULT:
        case KYWD_ID_COMBOBOX_DEFAULT:
            // get the default text
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the default text in pTableEntry
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *)
                pSettings,(BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),
                &((EDITTEXTINFO *) (GETOBJECTDATAPTR(pSettings)))->uOffsetDefText,
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;

            ppps->pTableEntry = pTmp;

            ((SETTINGS *) ppps->pTableEntry)->dwFlags |= DF_USEDEFAULT;

            break;

        case KYWD_ID_MAXLENGTH:
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(pSettings));

                if ((uErr=pCD->GetNextSectionNumericWord(
                    &pEditTextInfo->nMaxLen)) != ERROR_SUCCESS)
                    return uErr;
            }
            break;

        case KYWD_ID_MAX:
            if ((uErr=pCD->GetNextSectionNumericWord(
                &((NUMERICINFO *)pObjectData)->uMaxValue)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_MIN:
            if ((uErr=pCD->GetNextSectionNumericWord(
                &((NUMERICINFO *)pObjectData)->uMinValue)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_SPIN:
            if ((uErr=pCD->GetNextSectionNumericWord(
                &((NUMERICINFO *)pObjectData)->uSpinIncrement)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_NUMERIC_DEFAULT:
            if ((uErr=pCD->GetNextSectionNumericWord(
                &((NUMERICINFO *)pObjectData)->uDefValue)) != ERROR_SUCCESS)
                return uErr;

            pSettings->dwFlags |= (DF_DEFCHECKED | DF_USEDEFAULT);

        break;

        case KYWD_ID_DEFCHECKED:

            pSettings->dwFlags |= (DF_DEFCHECKED | DF_USEDEFAULT);

            break;

        case KYWD_ID_VALUEON:

            return pCD->ParseValue(ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetValue_On,
                &ppps->pTableEntry,pfMore);
            break;

        case KYWD_ID_VALUEOFF:

            return pCD->ParseValue(ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetValue_Off,
                &ppps->pTableEntry,pfMore);
            break;

        case KYWD_ID_ACTIONLISTON:
            return pCD->ParseActionList(ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetActionList_On,
                &ppps->pTableEntry,szACTIONLISTON,pfMore);
            break;

        case KYWD_ID_ACTIONLISTOFF:
            return pCD->ParseActionList(ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetActionList_Off,
                &ppps->pTableEntry,szACTIONLISTOFF,pfMore);
            break;

        case KYWD_ID_ITEMLIST:
            return pCD->ParseItemList(ppps,&pSettings->uOffsetObjectData,
                pfMore);
            break;

        case KYWD_ID_VALUEPREFIX:
            // get the string to be ised as prefix
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the string pTableEntry
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *)
                pSettings,(BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),
                &((LISTBOXINFO *) (GETOBJECTDATAPTR(pSettings)))->uOffsetPrefix,
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;
            break;

        case KYWD_ID_ADDITIVE:

            pSettings->dwFlags |= DF_ADDITIVE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_EXPLICITVALUE:

            pSettings->dwFlags |= DF_EXPLICITVALNAME;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_NOSORT:

            pSettings->dwFlags |= DF_NOSORT;

            break;

    }

    return ERROR_SUCCESS;
}

UINT CPolicyComponentData::InitSettingsParse(PARSEPROCSTRUCT *ppps,DWORD dwType,DWORD dwSize,
    KEYWORDINFO * pKeyList,SETTINGS ** ppSettings,BYTE **ppObjectData)
{
    TABLEENTRY *pTmp;

    if (dwSize) {
        // increase the buffer to fit object-specific data if specified
        pTmp = (TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
            NULL,dwSize,&( ((SETTINGS * )ppps->pTableEntry)->uOffsetObjectData),
            ppps->pdwBufSize);
        if (!pTmp) return ERROR_NOT_ENOUGH_MEMORY;
        ppps->pTableEntry = pTmp;

    }
    else ( (SETTINGS *) ppps->pTableEntry)->uOffsetObjectData= 0;

    ppps->pEntryCmpList = pKeyList;
    ppps->pTableEntry->dwType = dwType;

    *ppSettings = (SETTINGS *) ppps->pTableEntry;
    *ppObjectData = GETOBJECTDATAPTR((*ppSettings));

    return ERROR_SUCCESS;
}

UINT CPolicyComponentData::ParseValue_W(PARSEPROCSTRUCT * ppps,TCHAR * pszWordBuf,
    DWORD cbWordBuf,DWORD * pdwValue,DWORD * pdwFlags,BOOL * pfMore)
{
    UINT uErr;
    *pdwFlags = 0;
    *pdwValue = 0;

    // get the next word
    if (!GetNextSectionWord(pszWordBuf,cbWordBuf,
        NULL,NULL,pfMore,&uErr))
        return uErr;

    // if this keyword is "SOFT", set the soft flag and get the next word
    if (!lstrcmpi(szSOFT,pszWordBuf)) {
        *pdwFlags |= VF_SOFT;
        if (!GetNextSectionWord(pszWordBuf,cbWordBuf,
            NULL,NULL,pfMore,&uErr))
            return uErr;
    }

    // this word is either the value to use, or the keyword "NUMERIC"
    // followed by a numeric value to use
    if (!lstrcmpi(szNUMERIC,pszWordBuf)) {
        // get the next word
        if (!GetNextSectionWord(pszWordBuf,cbWordBuf,
            NULL,NULL,pfMore,&uErr))
            return uErr;

        if (!StringToNum(pszWordBuf,(UINT *)pdwValue)) {
            DisplayKeywordError(IDS_ParseErr_NOT_NUMERIC,
                pszWordBuf,NULL);
            return ERROR_ALREADY_DISPLAYED;
        }

        *pdwFlags |= VF_ISNUMERIC;
    } else {

        // "DELETE" is a special word
        if (!lstrcmpi(pszWordBuf,szDELETE))
            *pdwFlags |= VF_DELETE;
    }

    return ERROR_SUCCESS;
}

UINT CPolicyComponentData::ParseValue(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,BOOL * pfMore)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    STATEVALUE * pStateValue;
    DWORD dwValue;
    DWORD dwFlags = 0;
    DWORD dwAlloc;
    UINT uErr;
    TABLEENTRY *pTmp;

    // call worker function
    uErr=ParseValue_W(ppps,szWordBuf,ARRAYSIZE(szWordBuf),&dwValue,
        &dwFlags,pfMore);
    if (uErr != ERROR_SUCCESS) return uErr;

    dwAlloc = sizeof(STATEVALUE);
    if (!dwFlags) dwAlloc += (lstrlen(szWordBuf) + 1) * sizeof(TCHAR);

    // allocate temporary buffer to build STATEVALUE struct
    pStateValue = (STATEVALUE *) GlobalAlloc(GPTR,dwAlloc);
    if (!pStateValue)
        return ERROR_NOT_ENOUGH_MEMORY;

    pStateValue->dwFlags = dwFlags;
    if (dwFlags & VF_ISNUMERIC)
        pStateValue->dwValue = dwValue;
    else if (!dwFlags) {
        lstrcpy(pStateValue->szValue,szWordBuf);
    }

    pTmp=(TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
        (BYTE *) pStateValue,dwAlloc,puOffsetData,NULL);

    GlobalFree(pStateValue);

    if (!pTmp)
        return ERROR_NOT_ENOUGH_MEMORY;

    *ppTableEntryNew = pTmp;

    return FALSE;
}

#define DEF_SUGGESTBUF_SIZE     1024
#define SUGGESTBUF_INCREMENT    256
UINT CPolicyComponentData::ParseSuggestions(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,BOOL * pfMore)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    TCHAR *pTmpBuf, *pTmp;
    DWORD dwAlloc=DEF_SUGGESTBUF_SIZE * sizeof(TCHAR);
    DWORD dwUsed = 0;
    BOOL fContinue = TRUE;
    UINT uErr;
    TABLEENTRY *pTmpTblEntry;

    KEYWORDINFO pSuggestionsTypeCmpList[] = { {szSUGGESTIONS,KYWD_ID_SUGGESTIONS},
        {NULL,0} };

    if (!(pTmpBuf = (TCHAR *) GlobalAlloc(GPTR,dwAlloc)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // get the next word
    while (fContinue && GetNextSectionWord(szWordBuf,
        ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr)) {

        // if this word is "END", add the whole list to the setting object data
        if (!lstrcmpi(szEND,szWordBuf)) {
            // get the next word after "END, make sure it's "SUGGESTIONS"
            if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                pSuggestionsTypeCmpList,NULL,pfMore,&uErr)) {
                GlobalFree(pTmpBuf);
                return uErr;
            }

            // doubly-NULL terminate the list
            *(pTmpBuf+dwUsed) = '\0';
            dwUsed++;

            pTmpTblEntry=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                (BYTE *)pTmpBuf,(dwUsed * sizeof(TCHAR)),puOffsetData,NULL);

            if (!pTmpTblEntry) {
                GlobalFree(pTmpBuf);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            *ppTableEntryNew = pTmpTblEntry;
            fContinue = FALSE;

        } else {
            // pack the word into the temporary buffer
            UINT nLength = lstrlen(szWordBuf);
            DWORD dwNeeded = (dwUsed + nLength + 2) * sizeof(TCHAR);

            // resize buffer as necessary
            if (dwNeeded > dwAlloc) {
                while (dwAlloc < dwNeeded)
                    dwAlloc += SUGGESTBUF_INCREMENT;

                if (!(pTmp = (TCHAR *) GlobalReAlloc(pTmpBuf,dwAlloc,
                    GMEM_MOVEABLE | GMEM_ZEROINIT)))
                {
                    GlobalFree (pTmpBuf);
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                pTmpBuf = pTmp;
            }

            lstrcpy(pTmpBuf + dwUsed,szWordBuf);
            dwUsed += lstrlen(szWordBuf) +1;

        }
    }

    GlobalFree(pTmpBuf);

    return uErr;
}

UINT CPolicyComponentData::ParseActionList(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                                           TABLEENTRY ** ppTableEntryNew,
                                           LPCTSTR pszKeyword,BOOL * pfMore)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    ACTIONLIST *pActionList;
    ACTION *pActionCurrent;
    UINT uOffsetActionCurrent;
    DWORD dwAlloc=(DEF_SUGGESTBUF_SIZE * sizeof(TCHAR));
    DWORD dwUsed = sizeof(ACTION) + sizeof(UINT);
    UINT uErr=ERROR_SUCCESS,nIndex;
    BOOL fContinue = TRUE;
    TABLEENTRY *pTmp;
    KEYWORDINFO pActionlistTypeCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
        {szVALUENAME,KYWD_ID_VALUENAME},{szVALUE,KYWD_ID_VALUE},
        {szEND,KYWD_ID_END},{NULL,0} };
    KEYWORDINFO pActionlistCmpList[] = { {pszKeyword,KYWD_ID_ACTIONLIST},
        {NULL,0} };
    BOOL fHasKeyName=FALSE,fHasValueName=FALSE;

    if (!(pActionList = (ACTIONLIST *) GlobalAlloc(GPTR,dwAlloc)))
        return ERROR_NOT_ENOUGH_MEMORY;

    pActionCurrent = pActionList->Action;
    uOffsetActionCurrent = sizeof(UINT);

    // get the next word
    while ((uErr == ERROR_SUCCESS) && fContinue &&
        GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
        pActionlistTypeCmpList,&nIndex,pfMore,&uErr)) {

        switch (nIndex) {

            case KYWD_ID_KEYNAME:

                if (fHasKeyName) {
                    DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the key name
                if (!GetNextSectionWord(szWordBuf,
                    ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // store the key name away
                if (!AddActionListString(szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),
                    (BYTE **)&pActionList,
                    &pActionCurrent->uOffsetKeyName,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                fHasKeyName = TRUE;
                pActionCurrent = (ACTION *) ((BYTE *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_VALUENAME:

                if (fHasValueName) {
                    DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the value name
                if (!GetNextSectionWord(szWordBuf,
                    ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // store the value name away
                if (!AddActionListString(szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),
                    (BYTE **)&pActionList,
                    &pActionCurrent->uOffsetValueName,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                fHasValueName = TRUE;
                pActionCurrent = (ACTION *) ((BYTE *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_VALUE:
                if (!fHasValueName) {
                    DisplayKeywordError(IDS_ParseErr_NO_VALUENAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // call worker function to get value and value type
                uErr=ParseValue_W(ppps,szWordBuf,ARRAYSIZE(szWordBuf),
                    &pActionCurrent->dwValue,&pActionCurrent->dwFlags,pfMore);
                if (uErr != ERROR_SUCCESS)
                    break;

                // if value is string, add it to buffer
                if (!pActionCurrent->dwFlags && !AddActionListString(szWordBuf,
                    (lstrlen(szWordBuf)+1) * sizeof(TCHAR),(BYTE **)&pActionList,
                    &pActionCurrent->uOffsetValue,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                pActionCurrent = (ACTION *) ((BYTE *) pActionList + uOffsetActionCurrent);

                // done with this action in the list, get ready for the next one
                pActionList->nActionItems++;
                fHasValueName = fHasKeyName = FALSE;

                uOffsetActionCurrent = dwUsed;
                // make room for next ACTION struct
                if (!AddActionListString(NULL,sizeof(ACTION),(BYTE **)&pActionList,
                    &pActionCurrent->uOffsetNextAction,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                pActionCurrent = (ACTION *) ((BYTE *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_END:
                if (fHasKeyName || fHasValueName) {
                    DisplayKeywordError(IDS_ParseErr_NO_VALUENAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // make sure word following "END" is "ACTIONLIST"
                if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                    pActionlistCmpList,NULL,pfMore,&uErr)) {
                    break;
                }

                // commit the action list we've built to table entry

                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    (BYTE *)pActionList,dwUsed,puOffsetData,NULL);

                if (!pTmp) {
                    uErr=ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    *ppTableEntryNew = pTmp;
                    uErr = ERROR_SUCCESS;
                    fContinue = FALSE;
                }

                break;
        }
    }

    GlobalFree(pActionList);

    return uErr;
}

UINT CPolicyComponentData::ParseItemList(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    BOOL * pfMore)
{
    // ptr to location to put the offset to next DROPDOWNINFO struct in chain
    UINT * puLastOffsetPtr = puOffsetData;
    TABLEENTRY * pTableEntryOld, *pTmp;
    int nItemIndex=-1;
    BOOL fHasItemName = FALSE,fHasActionList=FALSE,fHasValue=FALSE,fFirst=TRUE;
    DROPDOWNINFO * pddi;
    TCHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr=ERROR_SUCCESS,nIndex;
    KEYWORDINFO pItemlistTypeCmpList[] = { {szNAME,KYWD_ID_NAME},
        {szACTIONLIST,KYWD_ID_ACTIONLIST},{szVALUE,KYWD_ID_VALUE},
        {szEND,KYWD_ID_END},{szDEFAULT,KYWD_ID_DEFAULT},{NULL,0} };
    KEYWORDINFO pItemlistCmpList[] = { {szITEMLIST,KYWD_ID_ITEMLIST},
        {NULL,0} };

    // get the next word
    while ((uErr == ERROR_SUCCESS) &&
        GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
        pItemlistTypeCmpList,&nIndex,pfMore,&uErr)) {

        switch (nIndex) {

            case KYWD_ID_NAME:
                // if this is the first keyword after a prior item
                // (e.g., item and value flags both set) reset for next one
                if (fHasItemName && fHasValue) {
                    fHasValue = fHasActionList= fHasItemName = FALSE;
                    puLastOffsetPtr = &pddi->uOffsetNextDropdowninfo;
                }

                if (fHasItemName) {
                    DisplayKeywordError(IDS_ParseErr_DUPLICATE_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the item name
                if (!GetNextSectionWord(szWordBuf,
                    ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // add room for a DROPDOWNINFO struct at end of buffer
                pTableEntryOld=ppps->pTableEntry;
                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    NULL,sizeof(DROPDOWNINFO),puLastOffsetPtr,NULL);
                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((BYTE *) ppps->pTableEntry + *puLastOffsetPtr);

                // store the key name away
                pTableEntryOld=ppps->pTableEntry;
                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1)*sizeof(TCHAR),&pddi->uOffsetItemName,
                    NULL);
                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((BYTE *) ppps->pTableEntry + *puLastOffsetPtr);

                nItemIndex++;

                fHasItemName = TRUE;

                break;

            case KYWD_ID_DEFAULT:

                if (nItemIndex<0) {
                    DisplayKeywordError(IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                ( (SETTINGS *) ppps->pTableEntry)->dwFlags |= DF_USEDEFAULT;
                ( (DROPDOWNINFO *) GETOBJECTDATAPTR(((SETTINGS *)ppps->pTableEntry)))
                    ->uDefaultItemIndex = nItemIndex;

                break;

            case KYWD_ID_VALUE:

                if (!fHasItemName) {
                    DisplayKeywordError(IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // call worker function to get value and value type
                uErr=ParseValue_W(ppps,szWordBuf,ARRAYSIZE(szWordBuf),
                    &pddi->dwValue,&pddi->dwFlags,pfMore);
                if (uErr != ERROR_SUCCESS)
                    break;

                // if value is string, add it to buffer
                if (!pddi->dwFlags) {
                    // store the key name away
                    TABLEENTRY * pTmp;

                    pTableEntryOld = ppps->pTableEntry;
                    pTmp=(TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
                        (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1)*sizeof(TCHAR),&pddi->uOffsetValue,
                        NULL);
                    if (!pTmp)
                        return ERROR_NOT_ENOUGH_MEMORY;
                    ppps->pTableEntry = pTmp;

                    // adjust pointer to offset, in case table moved
                    puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                        ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                    pddi = (DROPDOWNINFO *)
                        ((BYTE *) ppps->pTableEntry + *puLastOffsetPtr);
                }
                fHasValue = TRUE;

                break;

            case KYWD_ID_ACTIONLIST:

                if (!fHasItemName) {
                    DisplayKeywordError(IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                if (fHasActionList) {
                    DisplayKeywordError(IDS_ParseErr_DUPLICATE_ACTIONLIST,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                pTableEntryOld=ppps->pTableEntry;
                uErr=ParseActionList(ppps,&pddi->uOffsetActionList,
                    &ppps->pTableEntry,szACTIONLIST,pfMore);
                if (uErr != ERROR_SUCCESS)
                    return uErr;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((BYTE *) ppps->pTableEntry + *puLastOffsetPtr);

                fHasActionList = TRUE;

                break;

            case KYWD_ID_END:

                if (!fHasItemName) {
                    DisplayKeywordError(IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }
                if (!fHasValue) {
                    DisplayKeywordError(IDS_ParseErr_NO_VALUE,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // make sure word following "END" is "ITEMLIST"
                if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                    pItemlistCmpList,NULL,pfMore,&uErr)) {
                    break;
                }

                return ERROR_SUCCESS;
                break;
        }
    }

    return uErr;
}

BOOL CPolicyComponentData::AddActionListString(TCHAR * pszData,DWORD cbData,BYTE ** ppBase,UINT * puOffset,
                                               DWORD * pdwAlloc,DWORD *pdwUsed)
{
    DWORD dwNeeded = *pdwUsed + cbData, dwAdd;
    BYTE    *pOldBase;


    dwAdd = dwNeeded % sizeof(DWORD);
    dwNeeded += dwAdd;

    // realloc if necessary
    if (dwNeeded > *pdwAlloc) {
        while (*pdwAlloc < dwNeeded)
            *pdwAlloc += SUGGESTBUF_INCREMENT;
        pOldBase = *ppBase;
        if (!(*ppBase = (BYTE *) GlobalReAlloc(*ppBase,*pdwAlloc,
            GMEM_MOVEABLE | GMEM_ZEROINIT))) {
            *ppBase = pOldBase; // restore the old value
            return FALSE;
        }
        puOffset = (UINT *)(*ppBase + ((BYTE *)puOffset - pOldBase));
    }

    *puOffset = *pdwUsed;

    if (pszData) memcpy(*ppBase + *puOffset,pszData,cbData);
    *pdwUsed = dwNeeded;

    return TRUE;
}

BYTE * CPolicyComponentData::AddDataToEntry(TABLEENTRY * pTableEntry,
                                            BYTE * pData,UINT cbData,
                                            UINT * puOffsetData,DWORD * pdwBufSize)
{
    TABLEENTRY * pTemp;
    DWORD dwNeeded,dwOldSize = pTableEntry->dwSize, dwNewDataSize, dwAdd;

    // puOffsetData points to location that holds the offset to the
    // new data-- size we're adding this to the end of the table, the
    // offset will be the current size of the table.  Set this offset
    // in *puOffsetData.  Also, notice we touch *puOffsetData BEFORE
    // the realloc, in case puOffsetData points into the region being
    // realloced and the block of memory moves.
    //
    *puOffsetData = pTableEntry->dwSize;

    // reallocate entry buffer if necessary
    dwNewDataSize = cbData;

    dwAdd = dwNewDataSize % sizeof(DWORD);

    dwNewDataSize += dwAdd;

    dwNeeded = pTableEntry->dwSize + dwNewDataSize;

    if (!(pTemp = (TABLEENTRY *) GlobalReAlloc(pTableEntry,
        dwNeeded,GMEM_ZEROINIT | GMEM_MOVEABLE)))
        return NULL;

    pTableEntry = pTemp;
    pTableEntry->dwSize = dwNeeded;

    if (pData) memcpy((BYTE *)pTableEntry + dwOldSize,pData,cbData);
    if (pdwBufSize) *pdwBufSize = pTableEntry->dwSize;

    return (BYTE *) pTableEntry;
}

/*******************************************************************

    NAME:       CompareKeyword

    SYNOPSIS:   Compares a specified buffer to a list of valid keywords.
                If it finds a match, the index of the match in the list
                is returned in *pnListIndex.  Otherwise an error message
                is displayed.

    EXIT:       Returns TRUE if a keyword match is found, FALSE otherwise.
                If TRUE, *pnListIndex contains matching index.

********************************************************************/
BOOL CPolicyComponentData::CompareKeyword(TCHAR * szWord,KEYWORDINFO *pKeywordList,
                                          UINT * pnListIndex)
{
    KEYWORDINFO * pKeywordInfo = pKeywordList;

    while (pKeywordInfo->pWord) {
        if (!lstrcmpi(szWord,pKeywordInfo->pWord)) {
            if (pnListIndex)
                *pnListIndex = pKeywordInfo->nID;
            return TRUE;
        }
        pKeywordInfo ++;
    }

    DisplayKeywordError(IDS_ParseErr_UNEXPECTED_KEYWORD,
        szWord,pKeywordList);

    return FALSE;
}


/*******************************************************************

    NAME:       GetNextWord

    SYNOPSIS:   Fills input buffer with next word in file stream

    NOTES:      Calls GetNextChar() to get character stream.  Whitespace
                and comments are skipped.  Quoted strings are returned
                as one word (including whitespace) with the quotes removed.

    EXIT:       If successful, returns a pointer to the input buffer
                (szBuf).  *pfMore indicates if there are more words to
                be read.  If an error occurs, its value is returned in *puErr.

********************************************************************/
TCHAR * CPolicyComponentData::GetNextWord(TCHAR * szBuf,UINT cbBuf,BOOL * pfMore,
                                          UINT * puErr)
{
    TCHAR * pChar;
    BOOL fInWord = FALSE;
    BOOL fInQuote = FALSE;
    BOOL fEmptyString = FALSE;
    TCHAR * pWord = szBuf;
    UINT cbWord = 0;
    LPTSTR lpTemp;

    // clear buffer to start with
    lstrcpy(szBuf,g_szNull);

    while (pChar = GetNextChar(pfMore,puErr)) {

        // keep track of which file line we're on
        if (IsEndOfLine(pChar)) m_nFileLine++;

        // keep track of wheter we are inside quoted string or not
        if (IsQuote(pChar) && !m_fInComment) {
            if (!fInQuote)
                fInQuote = TRUE;  // entering quoted string
            else {
                fInQuote = FALSE; // leaving quoted string
                if (cbWord == 0) {
                    // special case "" to be an empty string
                    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::GetNextWord: Found empty quotes")));
                    fEmptyString = TRUE;
                }
                break;  // end of word
            }

        }

        if (!fInQuote) {

            // skip over lines with comments (';')
            if (!m_fInComment && IsComment(pChar)) m_fInComment = TRUE;
            if (m_fInComment) {
                if (IsEndOfLine(pChar)) {
                    m_fInComment = FALSE;
                }
                continue;
            }

            if (IsWhitespace(pChar)) {

                // if we haven't found word yet, skip over whitespace
                if (!fInWord)
                    continue;

                // otherwise, whitespace signals end of word
                break;
            }
        }

        // found a non-comment, non-whitespace character
        if (!fInWord) fInWord = TRUE;

        if (!IsQuote(pChar)) {
            // add this character to word

            *pWord = *pChar;
            pWord++;
            cbWord++;

            if (cbWord >= cbBuf) {
                *(pWord - 1) = TEXT('\0');
                MsgBoxParam(NULL,IDS_WORDTOOLONG,szBuf,MB_ICONEXCLAMATION,MB_OK);
                *puErr = ERROR_ALREADY_DISPLAYED;
                goto Exit;
            }

    #if 0
            if (IsDBCSLeadByte((BYTE) *pChar)) {
                *pWord = *pChar;
                pWord++;
                cbWord++;
            }
    #endif
        }
    }

    *pWord = '\0';  // null-terminate

    // if found string a la '!!foo', then look for a string in the [strings]
    // section with the key name 'foo' and use that instead.  This is because
    // our localization tools are brainless and require a [strings] section.
    // So although template files are sectionless, we allow a [strings] section
    // at the bottom.
    if (IsLocalizedString(szBuf)) {

        lpTemp = (LPTSTR) GlobalAlloc (GPTR, (cbBuf * sizeof(TCHAR)));

        if (!lpTemp) {
            *puErr = GetLastError();
            return NULL;
        }

        if (GetString (m_pLocaleStrings, szBuf+2, lpTemp, cbBuf) ||
            GetString (m_pLanguageStrings, szBuf+2, lpTemp, cbBuf) ||
            GetString (m_pDefaultStrings, szBuf+2, lpTemp, cbBuf))
        {
            lstrcpy(szBuf, lpTemp);
            GlobalFree (lpTemp);
        }
        else
        {
            DisplayKeywordError(IDS_ParseErr_STRING_NOT_FOUND,
                szBuf,NULL);
            *puErr=ERROR_ALREADY_DISPLAYED;
            GlobalFree (lpTemp);
            return NULL;
        }

    } else {
        *puErr = ProcessIfdefs(szBuf,cbBuf,pfMore);

        if (*puErr == ERROR_SUCCESS)
        {
            if ((szBuf[0] == TEXT('\0')) && (!fEmptyString))
            {
                fInWord = FALSE;
            }
        }
    }

Exit:

    if (*puErr != ERROR_SUCCESS || !fInWord) return NULL;
    return szBuf;
}

/*******************************************************************

    NAME:       GetNextSectionWord

    SYNOPSIS:   Gets next word and warns if end-of-file encountered.
                Optionally checks the keyword against a list of valid
                keywords.

    NOTES:      Calls GetNextWord() to get word.  This is called in
                situations where we expect there to be another word
                (e.g., inside a section) and it's an error if the
                file ends.

********************************************************************/
TCHAR * CPolicyComponentData::GetNextSectionWord(TCHAR * szBuf,UINT cbBuf,
                                                 KEYWORDINFO * pKeywordList,
                                                 UINT *pnListIndex,
                                                 BOOL * pfMore,UINT * puErr)
{
    TCHAR * pch;

    if (!(pch=GetNextWord(szBuf,cbBuf,pfMore,puErr))) {

        if (!*pfMore && *puErr != ERROR_ALREADY_DISPLAYED) {
            DisplayKeywordError(IDS_ParseErr_UNEXPECTED_EOF,
                NULL,pKeywordList);
            *puErr = ERROR_ALREADY_DISPLAYED;
        }

        return NULL;
    }

    if (pKeywordList && !CompareKeyword(szBuf,pKeywordList,pnListIndex)) {
        *puErr = ERROR_ALREADY_DISPLAYED;
        return NULL;
    }

    return pch;
}

/*******************************************************************

    NAME:       GetNextSectionNumericWord

    SYNOPSIS:   Gets next word and converts string to number.  Warns if
                not a numeric value

********************************************************************/
UINT CPolicyComponentData::GetNextSectionNumericWord(UINT * pnVal)
{
    UINT uErr;
    TCHAR szWordBuf[WORDBUFSIZE];
    BOOL fMore;

    if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
        NULL,NULL,&fMore,&uErr))
        return uErr;

    if (!StringToNum(szWordBuf,pnVal)) {
        DisplayKeywordError(IDS_ParseErr_NOT_NUMERIC,szWordBuf,
            NULL);
        return ERROR_ALREADY_DISPLAYED;
    }

    return ERROR_SUCCESS;
}


/*******************************************************************

    NAME:       GetNextChar

    SYNOPSIS:   Returns a pointer to the next character from the
                file stream.

********************************************************************/
TCHAR * CPolicyComponentData::GetNextChar(BOOL * pfMore,UINT * puErr)
{
    TCHAR * pCurrentChar;

    *puErr = ERROR_SUCCESS;


    if (m_pFilePtr > m_pFileEnd) {
        *pfMore = FALSE;
        return NULL;
    }

    pCurrentChar = m_pFilePtr;
    m_pFilePtr = CharNext(m_pFilePtr);
    *pfMore = TRUE;

    return pCurrentChar;
}

/*******************************************************************

    NAME:       GetString

    SYNOPSIS:   Returns the display string

********************************************************************/
BOOL CPolicyComponentData::GetString (LPTSTR pStringSection,
                                     LPTSTR lpStringName,
                                     LPTSTR lpResult, DWORD dwSize)
{
    LPTSTR lpTemp, lpDest;
    DWORD  dwCCH, dwIndex;
    BOOL   bFoundQuote = FALSE;
    TCHAR  cTestChar;


    if (!pStringSection)
    {
        return FALSE;
    }

    if (!m_bRetrieveString)
    {
        lpResult = TEXT('\0');
        return TRUE;
    }


    lpTemp = pStringSection;
    dwCCH = lstrlen (lpStringName);


    while (*lpTemp)
    {
        cTestChar = *(lpTemp + dwCCH);

        if ((cTestChar == TEXT('=')) || (cTestChar == TEXT(' ')))
        {
            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                               lpStringName, dwCCH, lpTemp, dwCCH) == CSTR_EQUAL)
            {
                lpTemp += dwCCH;

                while (*lpTemp == TEXT(' '))
                    lpTemp++;

                if (*lpTemp == TEXT('='))
                {
                    lpTemp++;

                    if (*lpTemp == TEXT('\"'))
                    {
                        lpTemp++;
                        bFoundQuote = TRUE;
                    }

                    lpDest = lpResult;
                    dwIndex = 0;

                    while (*lpTemp && (dwIndex < dwSize))
                    {
                        if ((*lpTemp == TEXT('\\')) && (*(lpTemp+1) == TEXT('\0')))
                        {
                            lpTemp += 2;
                        }
                        else
                        {
                            *lpDest = *lpTemp;

                             lpDest++;
                             lpTemp++;
                             dwIndex++;
                        }
                    }

                    if (dwIndex == dwSize)
                    {
                        lpDest--;
                        *lpDest = TEXT('\0');
                        MsgBoxParam(NULL,IDS_STRINGTOOLONG,lpResult,MB_ICONEXCLAMATION,MB_OK);
                    }
                    else
                    {
                        *lpDest = TEXT('\0');
                    }


                    if (bFoundQuote)
                    {
                        lpTemp = lpResult + lstrlen (lpResult) - 1;

                        if (*lpTemp == TEXT('\"'))
                        {
                            *lpTemp = TEXT('\0');
                        }
                    }

                    //
                    // Replace any \n combinations with a CR LF
                    //

                    lpTemp = lpResult;

                    while (*lpTemp)
                    {
                        if ((*lpTemp == TEXT('\\')) && (*(lpTemp + 1) == TEXT('n')))
                        {
                            *lpTemp = TEXT('\r');
                             lpTemp++;
                            *lpTemp = TEXT('\n');
                        }

                        lpTemp++;
                    }

                    return TRUE;
                }
            }
        }


        lpTemp += lstrlen (lpTemp) + 1;
    }

    return FALSE;
}




BOOL CPolicyComponentData::IsComment(TCHAR * pBuf)
{
    return (*pBuf == TEXT(';'));
}


BOOL CPolicyComponentData::IsQuote(TCHAR * pBuf)
{
    return (*pBuf == TEXT('\"'));
}

BOOL CPolicyComponentData::IsEndOfLine(TCHAR * pBuf)
{
    return (*pBuf == TEXT('\r'));     // CR
}


BOOL CPolicyComponentData::IsWhitespace(TCHAR * pBuf)
{
    return (   *pBuf == TEXT(' ')     // space
            || *pBuf == TEXT('\r')    // CR
            || *pBuf == TEXT('\n')    // LF
            || *pBuf == TEXT('\t')    // tab
            || *pBuf == 0x001A        // EOF
            || *pBuf == 0xFEFF        // Unicode marker
           );
}

BOOL CPolicyComponentData::IsLocalizedString(TCHAR * pBuf)
{
    return (*pBuf == TEXT('!') && *(pBuf+1) == TEXT('!'));
}


#define MSGSIZE 1024
#define FMTSIZE 512
VOID CPolicyComponentData::DisplayKeywordError(UINT uErrorID,TCHAR * szFound,
    KEYWORDINFO * pExpectedList)
{
    TCHAR * pMsg,*pFmt,*pErrTxt,*pTmp;

    pMsg = (TCHAR *) GlobalAlloc(GPTR,(MSGSIZE * sizeof(TCHAR)));
    pFmt = (TCHAR *) GlobalAlloc(GPTR,(FMTSIZE * sizeof(TCHAR)));
    pErrTxt = (TCHAR *) GlobalAlloc(GPTR,(FMTSIZE * sizeof(TCHAR)));
    pTmp = (TCHAR *) GlobalAlloc(GPTR,(FMTSIZE * sizeof(TCHAR)));

    if (!pMsg || !pFmt || !pErrTxt || !pTmp) {
        if (pMsg) GlobalFree(pMsg);
        if (pFmt) GlobalFree(pFmt);
        if (pErrTxt) GlobalFree(pErrTxt);
        if (pTmp) GlobalFree(pTmp);

        MsgBox(NULL,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
        return;
    }

    LoadSz(IDS_ParseFmt_MSG_FORMAT,pFmt,FMTSIZE);
    wsprintf(pMsg,pFmt,m_pszParseFileName,m_nFileLine,uErrorID,LoadSz(uErrorID,
        pErrTxt,FMTSIZE));

    if (szFound) {
        LoadSz(IDS_ParseFmt_FOUND,pFmt,FMTSIZE);
        wsprintf(pTmp,pFmt,szFound);
        lstrcat(pMsg,pTmp);
    }

    if (pExpectedList) {
        UINT nIndex=0;
        LoadSz(IDS_ParseFmt_EXPECTED,pFmt,FMTSIZE);
        lstrcpy(pErrTxt,g_szNull);

        while (pExpectedList[nIndex].pWord) {
            lstrcat(pErrTxt,pExpectedList[nIndex].pWord);
            if (pExpectedList[nIndex+1].pWord) {
                lstrcat(pErrTxt,TEXT(", "));
            }

            nIndex++;
        }

        wsprintf(pTmp,pFmt,pErrTxt);
        lstrcat(pMsg,pTmp);
    }

    lstrcat(pMsg,LoadSz(IDS_ParseFmt_FATAL,pTmp,FMTSIZE));

    DebugMsg((DM_WARNING, TEXT("Keyword error: %s"), pMsg));

    MsgBoxSz(NULL,pMsg,MB_ICONEXCLAMATION,MB_OK);

    GlobalFree(pMsg);
    GlobalFree(pFmt);
    GlobalFree(pErrTxt);
    GlobalFree(pTmp);
}


int CPolicyComponentData::MsgBox(HWND hWnd,UINT nResource,UINT uIcon,UINT uButtons)
{
    TCHAR szMsgBuf[REGBUFLEN];
    TCHAR szSmallBuf[SMALLBUF];

    LoadSz(IDS_POLICY_NAME,szSmallBuf,ARRAYSIZE(szSmallBuf));
    LoadSz(nResource,szMsgBuf,ARRAYSIZE(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

int CPolicyComponentData::MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    TCHAR szSmallBuf[SMALLBUF];

    LoadSz(IDS_POLICY_NAME,szSmallBuf,ARRAYSIZE(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

int CPolicyComponentData::MsgBoxParam(HWND hWnd,UINT nResource,TCHAR * szReplaceText,UINT uIcon,
        UINT uButtons)
{
    TCHAR szFormat[REGBUFLEN];
    LPTSTR lpMsgBuf;
    INT iResult;

    lpMsgBuf = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szReplaceText) + 1 + REGBUFLEN) * sizeof(TCHAR));

    if (!lpMsgBuf)
    {
        return 0;
    }

    LoadSz(nResource,szFormat,ARRAYSIZE(szFormat));

    wsprintf(lpMsgBuf,szFormat,szReplaceText);

    iResult = MsgBoxSz(hWnd,lpMsgBuf,uIcon,uButtons);

    LocalFree (lpMsgBuf);

    return iResult;
}

LPTSTR CPolicyComponentData::LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = TEXT('\0');
        LoadString( g_hInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

BOOL fFilterDirectives = TRUE;
UINT nGlobalNestedLevel = 0;

// reads up through the matching directive #endif in current scope
//and sets file pointer immediately past the directive
UINT CPolicyComponentData::FindMatchingDirective(BOOL *pfMore,BOOL fElseOK)
{
    TCHAR szWordBuf[WORDBUFSIZE];
    UINT uErr=ERROR_SUCCESS,nNestedLevel=1;
    BOOL fContinue = TRUE;

    // set the flag to stop catching '#' directives in low level word-fetching
    // routine
    fFilterDirectives = FALSE;

    // keep reading words.  Keep track of how many layers of #ifdefs deep we
    // are.  Every time we encounter an #ifdef or #ifndef, increment the level
    // count (nNestedLevel) by one.  For every #endif decrement the level count.
    // When the level count hits zero, we've found the matching #endif.
    while (nNestedLevel > 0) {
        if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),NULL,NULL,
            pfMore,&uErr))
            break;

        if (!lstrcmpi(szWordBuf,szIFDEF) || !lstrcmpi(szWordBuf,szIFNDEF) ||
            !lstrcmpi(szWordBuf,szIF))
            nNestedLevel ++;
        else if (!lstrcmpi(szWordBuf,szENDIF)) {
            nNestedLevel --;
        }
        else if (!lstrcmpi(szWordBuf,szELSE) && (nNestedLevel == 1)) {
            if (fElseOK) {
                // ignore "#else" unless it's on the same level as the #ifdef
                // we're finding a match for (nNestedLevel == 1), in which
                // case treat it as the matching directive
                nNestedLevel --;
                // increment global nesting so we expect an #endif to come along
                // later to match this #else
                nGlobalNestedLevel++;
            } else {
                // found a #else where we already had a #else in this level
                DisplayKeywordError(IDS_ParseErr_UNMATCHED_DIRECTIVE,
                    szWordBuf,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }
        }
    }

    fFilterDirectives = TRUE;

    return uErr;
}


// if the word in the word buffer is #ifdef, #if, #ifndef, #else or #endif,
// this function reads ahead an appropriate amount (
UINT CPolicyComponentData::ProcessIfdefs(TCHAR * pBuf,UINT cbBuf,BOOL * pfMore)
{
    UINT uRet;

    if (!fFilterDirectives)
        return ERROR_SUCCESS;

    if (!lstrcmpi(pBuf,szIFDEF)) {
    // we've found an '#ifdef <something or other>, where ISV policy editors
    // can understand particular keywords they make up.  We don't have any
    // #ifdef keywords of our own so always skip this
        uRet = FindMatchingDirective(pfMore,TRUE);
        if (uRet != ERROR_SUCCESS)
            return uRet;
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szIFNDEF)) {
        // this is an #ifndef, and since nothing is ever ifdef'd for our policy
        // editor, this always evaluates to TRUE

        // keep reading this section but increment the nested level count,
        // when we find the matching #endif or #else we'll be able to respond
        // correctly
        nGlobalNestedLevel ++;

        // get next word (e.g. "foo" for #ifndef foo) and throw it away
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        // get next word and return it for real
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        return ERROR_SUCCESS;

    } else if (!lstrcmpi(pBuf,szENDIF)) {
        // if we ever encounter an #endif here, we must have processed
        // the preceeding section.  Just step over the #endif and go on

        if (!nGlobalNestedLevel) {
            // found an endif without a preceeding #if<xx>

            DisplayKeywordError(IDS_ParseErr_UNMATCHED_DIRECTIVE,
                pBuf,NULL);
            return ERROR_ALREADY_DISPLAYED;
        }
        nGlobalNestedLevel--;

        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szIF)) {
        // syntax is "#if VERSION (comparision) (version #)"
        // e.g. "#if VERSION >= 2"
        TCHAR szWordBuf[WORDBUFSIZE];
        UINT nIndex,nVersion,nOperator;
        BOOL fDirectiveTrue = FALSE;

        // get the next word (must be "VERSION")
        if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
            pVersionCmpList,&nIndex,pfMore,&uRet))
            return uRet;

        // get the comparison operator (>, <, ==, >=, <=)
        if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
            pOperatorCmpList,&nOperator,pfMore,&uRet))
            return uRet;

        // get the version number
        uRet=GetNextSectionNumericWord(&nVersion);
        if (uRet != ERROR_SUCCESS)
            return uRet;

        // now evaluate the directive

        switch (nOperator) {
            case KYWD_ID_GT:
                fDirectiveTrue = (CURRENT_ADM_VERSION > nVersion);
                break;

            case KYWD_ID_GTE:
                fDirectiveTrue = (CURRENT_ADM_VERSION >= nVersion);
                break;

            case KYWD_ID_LT:
                fDirectiveTrue = (CURRENT_ADM_VERSION < nVersion);
                break;

            case KYWD_ID_LTE:
                fDirectiveTrue = (CURRENT_ADM_VERSION <= nVersion);
                break;

            case KYWD_ID_EQ:
                fDirectiveTrue = (CURRENT_ADM_VERSION == nVersion);
                break;

            case KYWD_ID_NE:
                fDirectiveTrue = (CURRENT_ADM_VERSION != nVersion);
                break;
        }


        if (fDirectiveTrue) {
            // keep reading this section but increment the nested level count,
            // when we find the matching #endif or #else we'll be able to respond
            // correctly
            nGlobalNestedLevel ++;
        } else {
            // skip over this section
            uRet = FindMatchingDirective(pfMore,TRUE);
            if (uRet != ERROR_SUCCESS)
                return uRet;
        }

        // get next word and return it for real
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szELSE)) {
        // found an #else, which means we took the upper branch, skip over
        // the lower branch
        if (!nGlobalNestedLevel) {
            // found an #else without a preceeding #if<xx>

            DisplayKeywordError(IDS_ParseErr_UNMATCHED_DIRECTIVE,
                pBuf,NULL);
            return ERROR_ALREADY_DISPLAYED;
        }
        nGlobalNestedLevel--;

        uRet = FindMatchingDirective(pfMore,FALSE);
        if (uRet != ERROR_SUCCESS)
            return uRet;
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

        NAME:           FreeTable

        SYNOPSIS:       Frees the specified table and all sub-tables of that
                                table.

        NOTES:          Walks through the table entries and calls itself to
                                recursively free sub-tables.

        EXIT:           Returns TRUE if successful, FALSE if a memory error
                                occurs.

********************************************************************/
BOOL CPolicyComponentData::FreeTable(TABLEENTRY * pTableEntry)
{
        TABLEENTRY * pNext = pTableEntry->pNext;

        // free all children
        if (pTableEntry->pChild)
                FreeTable(pTableEntry->pChild);

        GlobalFree(pTableEntry);

        if (pNext) FreeTable(pNext);

        return TRUE;
}


LPTSTR CPolicyComponentData::GetStringSection (LPCTSTR lpSection, LPCTSTR lpFileName)
{
    DWORD dwSize, dwRead;
    LPTSTR lpStrings;


    //
    // Read in the default strings section
    //

    dwSize = STRINGS_BUF_SIZE;
    lpStrings = (TCHAR *) GlobalAlloc (GPTR, dwSize * sizeof(TCHAR));

    if (!lpStrings)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::GetStringSection: Failed to alloc memory for default strings with %d."),
                 GetLastError()));
        return NULL;
    }


    do {
        dwRead = GetPrivateProfileSection (lpSection,
                                           lpStrings,
                                           dwSize, lpFileName);

        if (dwRead != (dwSize - 2))
        {
            break;
        }

        GlobalFree (lpStrings);

        dwSize *= 2;
        lpStrings = (TCHAR *) GlobalAlloc (GPTR, dwSize * sizeof(TCHAR));

        if (!lpStrings)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::GetStringSection: Failed to alloc memory for Default strings with %d."),
                     GetLastError()));
            return FALSE;
        }

     }  while (TRUE);


    if (dwRead == 0)
    {
        GlobalFree (lpStrings);
        lpStrings = NULL;
    }

    return lpStrings;
}

INT CPolicyComponentData::TemplatesSortCallback (LPARAM lParam1, LPARAM lParam2,
                                                  LPARAM lColumn)
{
    LPTEMPLATEENTRY lpEntry1, lpEntry2;
    INT iResult;

    lpEntry1 = (LPTEMPLATEENTRY) lParam1;
    lpEntry2 = (LPTEMPLATEENTRY) lParam2;


    if (lColumn == 0)
    {
        iResult = lstrcmpi (lpEntry1->lpFileName, lpEntry2->lpFileName);
    }
    else if (lColumn == 1)
    {

        if (lpEntry1->dwSize < lpEntry2->dwSize)
        {
            iResult = -1;
        }
        else if (lpEntry1->dwSize > lpEntry2->dwSize)
        {
            iResult = 1;
        }
        else
        {
            iResult = 0;
        }
    }
    else
    {
        iResult = CompareFileTime (&lpEntry1->ftTime, &lpEntry2->ftTime);
    }

    return iResult;
}

BOOL CPolicyComponentData::FillADMFiles (HWND hDlg)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szDate[20];
    TCHAR szTime[20];
    TCHAR szBuffer[45];
    HWND hLV;
    INT iItem;
    LVITEM item;
    FILETIME filetime;
    SYSTEMTIME systime;
    WIN32_FIND_DATA fd;
    LPTEMPLATEENTRY lpEntry;
    HANDLE hFile;
    LPTSTR lpEnd, lpTemp;


    //
    // Ask for the root of the GPT so we can access the
    // adm files.
    //

    if (m_pGPTInformation->GetFileSysPath(GPO_SECTION_ROOT, szPath,
                                      MAX_PATH) != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillADMFiles: Failed to get gpt path.")));
        return FALSE;
    }


    //
    // Create the directory
    //

    lpEnd = CheckSlash (szPath);
    lstrcpy (lpEnd, g_szADM);

    if (!CreateNestedDirectory(szPath, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillADMFiles: Failed to create adm directory.")));
        return FALSE;
    }


    //
    // Prepare the listview
    //

    hLV = GetDlgItem (hDlg, IDC_TEMPLATELIST);
    SendMessage (hLV, WM_SETREDRAW, FALSE, 0);
    ListView_DeleteAllItems(hLV);


    //
    // Enumerate the files
    //

    lstrcat (szPath, TEXT("\\*.adm"));

    hFile = FindFirstFile(szPath, &fd);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {

                lpEntry = (LPTEMPLATEENTRY) LocalAlloc (LPTR,
                         sizeof(TEMPLATEENTRY) + ((lstrlen(fd.cFileName) + 1) * sizeof(TCHAR)));

                if (lpEntry)
                {

                    lpEntry->lpFileName = (LPTSTR)((LPBYTE)lpEntry + sizeof(TEMPLATEENTRY));
                    lpEntry->dwSize = fd.nFileSizeLow / 1024;

                    if (lpEntry->dwSize == 0)
                    {
                        lpEntry->dwSize = 1;
                    }

                    lpEntry->ftTime.dwLowDateTime = fd.ftLastWriteTime.dwLowDateTime;
                    lpEntry->ftTime.dwHighDateTime = fd.ftLastWriteTime.dwHighDateTime;

                    lstrcpy (lpEntry->lpFileName, fd.cFileName);


                    //
                    // Add the filename
                    //

                    lpTemp = fd.cFileName + lstrlen (fd.cFileName) - 4;

                    if (*lpTemp == TEXT('.'))
                    {
                        *lpTemp = TEXT('\0');
                    }

                    item.mask = LVIF_TEXT | LVIF_IMAGE  | LVIF_STATE | LVIF_PARAM;
                    item.iItem = 0;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                    item.pszText = fd.cFileName;
                    item.iImage = 0;
                    item.lParam = (LPARAM) lpEntry;

                    iItem = (INT)SendMessage (hLV, LVM_INSERTITEM, 0, (LPARAM) &item);


                    if (iItem == -1)
                    {
                        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillADMFiles: Failed to insert item.")));
                        return FALSE;
                    }


                    //
                    // Add the size
                    //

                    wsprintf (szBuffer, TEXT("%dKB"), lpEntry->dwSize);

                    item.mask = LVIF_TEXT;
                    item.iItem = iItem;
                    item.iSubItem = 1;
                    item.pszText = szBuffer;

                    SendMessage (hLV, LVM_SETITEMTEXT, iItem, (LPARAM) &item);


                    //
                    // And the last modified date
                    //

                    FileTimeToLocalFileTime (&fd.ftLastWriteTime, &filetime);
                    FileTimeToSystemTime (&filetime, &systime);

                    GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE,
                                   &systime, NULL, szDate, 20);

                    GetTimeFormat (LOCALE_USER_DEFAULT, TIME_NOSECONDS,
                                   &systime, NULL, szTime, 20);

                    wsprintf (szBuffer, TEXT("%s %s"), szDate, szTime);

                    item.mask = LVIF_TEXT;
                    item.iItem = iItem;
                    item.iSubItem = 2;
                    item.pszText = szBuffer;

                    SendMessage (hLV, LVM_SETITEMTEXT, iItem, (LPARAM) &item);
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillADMFiles: Failed to allocate memory for an entry %d."),
                             GetLastError()));
                }
            }

        } while (FindNextFile(hFile, &fd));


        FindClose(hFile);
    }

    if (SendMessage(hLV, LVM_GETITEMCOUNT, 0, 0) > 0)
    {
        //
        // Sort the listview
        //

        ListView_SortItems (hLV, TemplatesSortCallback, m_bTemplatesColumn);


        //
        // Select the first item
        //

        item.mask = LVIF_STATE;
        item.iItem = 0;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);

        EnableWindow (GetDlgItem (hDlg, IDC_REMOVETEMPLATES), TRUE);
    }
    else
    {
        EnableWindow (GetDlgItem (hDlg, IDC_REMOVETEMPLATES), FALSE);
        SetFocus (GetDlgItem (hDlg, IDC_ADDTEMPLATES));
    }


    SendMessage (hLV, WM_SETREDRAW, TRUE, 0);

    return TRUE;
}


BOOL CPolicyComponentData::InitializeTemplatesDlg (HWND hDlg)
{
    LVCOLUMN lvc;
    LVITEM item;
    TCHAR szTitle[50];
    INT iNameWidth;
    HIMAGELIST hLarge, hSmall;
    HICON hIcon;
    HWND hLV;
    RECT rc;


    hLV = GetDlgItem (hDlg, IDC_TEMPLATELIST);
    GetClientRect (hLV, &rc);


    //
    // Create the imagelists
    //

    hLarge = ImageList_Create (32, 32, ILC_MASK, 1, 1);

    if (!hLarge)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::InitializeTemplatesDlg: Failed to create large imagelist.")));
        return FALSE;
    }

    hSmall = ImageList_Create (16, 16, ILC_MASK, 1, 1);

    if (!hSmall)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::InitializeTemplatesDlg: Failed to create small imagelist.")));
        ImageList_Destroy (hLarge);
        return FALSE;
    }


    //
    // Add the icon
    //

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_DOCUMENT),
                               IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);

    if ( hIcon )
    {
        ImageList_AddIcon (hLarge, hIcon);

        DestroyIcon (hIcon);
    }

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_DOCUMENT),
                               IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

    if ( hIcon )
    {
        ImageList_AddIcon (hSmall, hIcon);

        DestroyIcon (hIcon);
    }


    //
    // Associate the imagelist with the listview.
    // The listview will free this when the
    // control is destroyed.
    //

    SendMessage (hLV, LVM_SETIMAGELIST, LVSIL_NORMAL, (LPARAM) hLarge);
    SendMessage (hLV, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM) hSmall);



    //
    // Set extended LV style for whole line selection
    //

    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);


    //
    // Insert the columns
    //

    LoadString (g_hInstance, IDS_NAME, szTitle, 50);

    lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    iNameWidth = (int)(rc.right * .60);
    lvc.cx = iNameWidth;
    lvc.pszText = szTitle;
    lvc.cchTextMax = 50;
    lvc.iSubItem = 0;

    SendMessage (hLV, LVM_INSERTCOLUMN,  0, (LPARAM) &lvc);


    LoadString (g_hInstance, IDS_SIZE, szTitle, 50);

    lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_RIGHT;
    iNameWidth += (int)(rc.right * .15);
    lvc.cx = (int)(rc.right * .15);
    lvc.pszText = szTitle;
    lvc.cchTextMax = 50;
    lvc.iSubItem = 0;

    SendMessage (hLV, LVM_INSERTCOLUMN,  1, (LPARAM) &lvc);


    LoadString (g_hInstance, IDS_MODIFIED, szTitle, 50);

    lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - iNameWidth;
    lvc.pszText = szTitle;
    lvc.cchTextMax = 50;
    lvc.iSubItem = 1;

    SendMessage (hLV, LVM_INSERTCOLUMN,  2, (LPARAM) &lvc);


    //
    // Fill the list view with the adm files
    //

    FillADMFiles (hDlg);

    return TRUE;
}

BOOL CPolicyComponentData::AddTemplates(HWND hDlg)
{
    OPENFILENAME ofn;
    LVITEM item;
    INT iCount, iResult;
    BOOL bResult = FALSE;
    LPTSTR lpFileName, lpTemp, lpEnd, lpSrcList = NULL;
    DWORD dwListLen, dwTemp, dwNextString;
    TCHAR szFilter[100];
    TCHAR szTitle[100];
    TCHAR szFile[2*MAX_PATH];
    TCHAR szInf[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    TCHAR szSrc[MAX_PATH];
    SHFILEOPSTRUCT fileop;


    //
    // Prompt for new files
    //

    LoadString (g_hInstance, IDS_POLICYFILTER, szFilter, ARRAYSIZE(szFilter));
    LoadString (g_hInstance, IDS_POLICYTITLE, szTitle, ARRAYSIZE(szTitle));
    ExpandEnvironmentStrings (TEXT("%SystemRoot%\\Inf"), szInf, MAX_PATH);


    lpTemp = szFilter;

    while (*lpTemp)
    {
        if (*lpTemp == TEXT('#'))
            *lpTemp = TEXT('\0');

        lpTemp++;
    }

    ZeroMemory (&ofn, sizeof(ofn));
    szFile[0] = TEXT('\0');
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = g_hInstance;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = 2*MAX_PATH;
    ofn.lpstrInitialDir = szInf;
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_ALLOWMULTISELECT | OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_EXPLORER;

    if (!GetOpenFileName (&ofn))
    {
        return FALSE;
    }


    //
    // Setup the destination
    //

    if (m_pGPTInformation->GetFileSysPath(GPO_SECTION_ROOT, szDest,
                                      MAX_PATH) != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to get gpt path.")));
        return FALSE;
    }

    lpEnd = CheckSlash (szDest);
    lstrcpy (lpEnd, g_szADM);


    //
    // Setup up the source
    //

    *(szFile + ofn.nFileOffset - 1) = TEXT('\0');
    lstrcpyn (szSrc, szFile, MAX_PATH);
    lpEnd = CheckSlash (szSrc);

    lpFileName = szFile + lstrlen (szFile) + 1;


    //
    // Loop through the files copying and adding them to the list.
    //

    while (*lpFileName)
    {
        lpTemp = lpFileName + lstrlen (lpFileName) - 4;

        if (!lstrcmpi(lpTemp, TEXT(".adm")))
        {
            lstrcpy (lpEnd, lpFileName);

            if (lpSrcList)
            {
                dwTemp = dwListLen + ((lstrlen (szSrc) + 1) * sizeof(TCHAR));
                lpTemp = (LPTSTR) LocalReAlloc (lpSrcList, dwTemp, LMEM_MOVEABLE | LMEM_ZEROINIT);

                if (lpTemp)
                {
                    lpSrcList = lpTemp;
                    dwListLen = dwTemp;

                    lstrcpy ((lpSrcList + dwNextString), szSrc);
                    dwNextString += lstrlen (szSrc) + 1;
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to realloc memory for Src list. %d"),
                             GetLastError()));
                }
            }
            else
            {
                dwListLen = (lstrlen (szSrc) + 2) * sizeof(TCHAR);

                lpSrcList = (LPTSTR) LocalAlloc (LPTR, dwListLen);

                if (lpSrcList)
                {
                    lstrcpy (lpSrcList, szSrc);
                    dwNextString = lstrlen (lpSrcList) + 1;
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to alloc memory for src list. %d"),
                             GetLastError()));
                }
            }
        }
        else
        {
            MsgBoxParam(hDlg, IDS_INVALIDADMFILE, lpFileName, MB_ICONERROR, MB_OK);
        }

        lpFileName = lpFileName + lstrlen (lpFileName) + 1;
    }


    if (lpSrcList)
    {
        fileop.hwnd = hDlg;
        fileop.wFunc = FO_COPY;
        fileop.pFrom = lpSrcList;
        fileop.pTo = szDest;
        fileop.fFlags = FOF_NOCONFIRMMKDIR;

        iResult = SHFileOperation(&fileop);

        if (!iResult)
        {
            bResult = TRUE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to copy <%s> to <%s> with %d."),
                     szSrc, szDest, iResult));
        }


        LocalFree (lpSrcList);

        if (bResult)
        {
            FillADMFiles (hDlg);
        }
    }


    return bResult;
}

BOOL CPolicyComponentData::RemoveTemplates(HWND hDlg)
{
    HWND hLV;
    LVITEM item;
    BOOL bResult = FALSE;
    INT iResult, iIndex = -1;
    LPTEMPLATEENTRY lpEntry;
    LPTSTR lpEnd, lpTemp, lpDeleteList = NULL;
    TCHAR szPath[MAX_PATH];
    DWORD dwSize, dwListLen, dwTemp, dwNextString;
    SHFILEOPSTRUCT fileop;


    hLV = GetDlgItem (hDlg, IDC_TEMPLATELIST);


    //
    // Get the path to the adm directory
    //

    if (m_pGPTInformation->GetFileSysPath(GPO_SECTION_ROOT, szPath,
                                      MAX_PATH) != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to get gpt path.")));
        return FALSE;
    }

    lpEnd = CheckSlash (szPath);
    lstrcpy (lpEnd, g_szADM);
    lpEnd = CheckSlash (szPath);
    dwSize = MAX_PATH - (DWORD)(lpEnd - szPath);



    //
    // Build a list of selected items
    //

    while ((iIndex = ListView_GetNextItem (hLV, iIndex,
           LVNI_ALL | LVNI_SELECTED)) != -1)
    {

        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hLV, &item))
        {
            continue;
        }

        lpEntry = (LPTEMPLATEENTRY) item.lParam;
        lstrcpyn (lpEnd, lpEntry->lpFileName, dwSize);

        if (lpDeleteList)
        {
            dwTemp = dwListLen + ((lstrlen (szPath) + 1) * sizeof(TCHAR));
            lpTemp = (LPTSTR) LocalReAlloc (lpDeleteList, dwTemp, LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (lpTemp)
            {
                lpDeleteList = lpTemp;
                dwListLen = dwTemp;

                lstrcpy ((lpDeleteList + dwNextString), szPath);
                dwNextString += lstrlen (szPath) + 1;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::RemoveTemplates: Failed to realloc memory for delete list. %d"),
                         GetLastError()));
            }
        }
        else
        {
            dwListLen = (lstrlen (szPath) + 2) * sizeof(TCHAR);

            lpDeleteList = (LPTSTR) LocalAlloc (LPTR, dwListLen);

            if (lpDeleteList)
            {
                lstrcpy (lpDeleteList, szPath);
                dwNextString = lstrlen (lpDeleteList) + 1;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::RemoveTemplates: Failed to alloc memory for delete list. %d"),
                         GetLastError()));
            }
        }
    }


    if (lpDeleteList)
    {
        fileop.hwnd = hDlg;
        fileop.wFunc = FO_DELETE;
        fileop.pFrom = lpDeleteList;
        fileop.pTo = NULL;
        fileop.fFlags = FOF_NOCONFIRMATION | FOF_SILENT;

        iResult = SHFileOperation(&fileop);

        if (!iResult)
        {
            bResult = TRUE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::RemoveTemplates: Failed to delete file <%s> with %d."),
                     szPath, iResult));
        }

        LocalFree (lpDeleteList);

        if (bResult)
        {
            FillADMFiles (hDlg);
        }
    }

    return bResult;
}

INT_PTR CALLBACK CPolicyComponentData::TemplatesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CPolicyComponentData * pCD;
    static BOOL bTemplatesDirty;

    switch (message)
    {
        case WM_INITDIALOG:
            pCD = (CPolicyComponentData*) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

            bTemplatesDirty = FALSE;

            if (!pCD->InitializeTemplatesDlg(hDlg))
            {
                EndDialog (hDlg, FALSE);
            }

            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                case IDCLOSE:
                    EndDialog (hDlg, bTemplatesDirty);
                    break;

                case IDC_ADDTEMPLATES:
                    pCD = (CPolicyComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

                    if (pCD && pCD->AddTemplates(hDlg))
                    {
                        bTemplatesDirty = TRUE;
                    }
                    break;

                case IDC_REMOVETEMPLATES:
                    pCD = (CPolicyComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

                    if (pCD && pCD->RemoveTemplates(hDlg))
                    {
                        bTemplatesDirty = TRUE;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            if (((NMHDR FAR*)lParam)->code == LVN_DELETEITEM)
            {
                LVITEM item;
                LPTEMPLATEENTRY lpEntry;

                item.mask = LVIF_PARAM;
                item.iItem = ((NMLISTVIEW FAR*)lParam)->iItem;
                item.iSubItem = 0;

                if (ListView_GetItem (GetDlgItem (hDlg, IDC_TEMPLATELIST), &item))
                {
                    lpEntry = (LPTEMPLATEENTRY) item.lParam;
                    LocalFree (lpEntry);
                }
            }
            else if (((NMHDR FAR*)lParam)->code == LVN_COLUMNCLICK)
            {
                pCD = (CPolicyComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

                if (pCD)
                {
                    pCD->m_bTemplatesColumn = ((NMLISTVIEW FAR*)lParam)->iSubItem;
                    ListView_SortItems (GetDlgItem (hDlg, IDC_TEMPLATELIST),
                                        TemplatesSortCallback, pCD->m_bTemplatesColumn);
                }
            }
            else
            {
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
            break;

        case WM_REFRESHDISPLAY:
            if (ListView_GetNextItem (GetDlgItem(hDlg, IDC_TEMPLATELIST),
                                      -1, LVNI_ALL | LVNI_SELECTED) == -1)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_REMOVETEMPLATES), FALSE);
            }
            else
            {
                EnableWindow (GetDlgItem(hDlg, IDC_REMOVETEMPLATES), TRUE);
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPDWORD) aADMHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPDWORD) aADMHelpIds);
            return TRUE;

    }

    return FALSE;
}

BOOL CPolicyComponentData::AddRSOPRegistryDataNode(LPTSTR lpKeyName, LPTSTR lpValueName, DWORD dwType,
                             DWORD dwDataSize, LPBYTE lpData, UINT uiPrecedence, LPTSTR lpGPOName, BOOL bDeleted)
{
    DWORD dwSize;
    LPRSOPREGITEM lpItem;
    BOOL bSystemEntry = FALSE;


    //
    // Special case some registry key / values and do not add them to the link list.
    // These registry entries are specific to snapins we write and we know for sure
    // they have rsop UI that will show their values.
    //

    if (lpKeyName)
    {
        const TCHAR szCerts[] = TEXT("Software\\Policies\\Microsoft\\SystemCertificates");
        int iCertLen = lstrlen (szCerts);


        //
        // Remove all system certificates
        //

        if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                          lpKeyName, iCertLen, szCerts, iCertLen) == CSTR_EQUAL)
        {
            bSystemEntry = TRUE;
        }

        if ( ! bSystemEntry )
        {
            const TCHAR szCryptography[] = TEXT("Software\\Policies\\Microsoft\\Cryptography");
            int iCryptographyLen = lstrlen (szCryptography);

            if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                              lpKeyName, iCryptographyLen, szCryptography, iCryptographyLen) == CSTR_EQUAL)
            {
                bSystemEntry = TRUE;
            }
        }

        //
        // Hide the digial signature policies for Software Installation
        //

        if (!lstrcmpi(lpKeyName, TEXT("Software\\Policies\\Microsoft\\Windows\\Installer")))
        {
            if (lpValueName)
            {
                if (!lstrcmpi(lpValueName, TEXT("InstallKnownPackagesOnly")))
                {
                    bSystemEntry = TRUE;
                }

                else if (!lstrcmpi(lpValueName, TEXT("IgnoreSignaturePolicyForAdmins")))
                {
                    bSystemEntry = TRUE;
                }
            }
        }
    }


    if (bSystemEntry)
    {
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::AddRSOPRegistryDataNode: Ignoring %s entry"), lpKeyName));
        return TRUE;
    }


    //
    // Calculate the size of the new registry item
    //

    dwSize = sizeof (RSOPREGITEM);

    if (lpKeyName) {
        dwSize += ((lstrlen(lpKeyName) + 1) * sizeof(TCHAR));
    }

    if (lpValueName) {
        dwSize += ((lstrlen(lpValueName) + 1) * sizeof(TCHAR));
    }

    if (lpGPOName) {
        dwSize += ((lstrlen(lpGPOName) + 1) * sizeof(TCHAR));
    }

    //
    // Allocate space for it
    //

    lpItem = (LPRSOPREGITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddRSOPRegistryDataNode: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    lpItem->dwType = dwType;
    lpItem->dwSize = dwDataSize;
    lpItem->uiPrecedence = uiPrecedence;
    lpItem->bDeleted = bDeleted;

    if (lpKeyName)
    {
        lpItem->lpKeyName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));
        lstrcpy (lpItem->lpKeyName, lpKeyName);
    }

    if (lpValueName)
    {
        if (lpKeyName)
        {
            lpItem->lpValueName = lpItem->lpKeyName + lstrlen (lpItem->lpKeyName) + 1;
        }
        else
        {
            lpItem->lpValueName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));
        }

        lstrcpy (lpItem->lpValueName, lpValueName);
    }

    if (lpGPOName)
    {
        if (lpValueName)
        {
            lpItem->lpGPOName = lpItem->lpValueName + lstrlen (lpItem->lpValueName) + 1;
        }
        else
        {
            if (lpKeyName)
            {
                lpItem->lpGPOName = lpItem->lpKeyName + lstrlen (lpItem->lpKeyName) + 1;
            }
            else
            {
                lpItem->lpGPOName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));
            }
        }

        lstrcpy (lpItem->lpGPOName, lpGPOName);
    }

    if (lpData)
    {

        lpItem->lpData = (LPBYTE) LocalAlloc (LPTR, dwDataSize);

        if (!lpItem->lpData) {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddRSOPRegistryDataNode: Failed to allocate memory for data with %d"),
                     GetLastError()));
            LocalFree (lpItem);
            return FALSE;
        }

        CopyMemory (lpItem->lpData, lpData, dwDataSize);
    }


    //
    // Add item to link list
    //

    lpItem->pNext = m_pRSOPRegistryData;
    m_pRSOPRegistryData = lpItem;

    return TRUE;
}

VOID CPolicyComponentData::FreeRSOPRegistryData(VOID)
{
    LPRSOPREGITEM lpTemp;


    if (!m_pRSOPRegistryData)
    {
        return;
    }


    do {
        lpTemp = m_pRSOPRegistryData->pNext;
        if (m_pRSOPRegistryData->lpData)
        {
            LocalFree (m_pRSOPRegistryData->lpData);
        }
        LocalFree (m_pRSOPRegistryData);
        m_pRSOPRegistryData = lpTemp;

    } while (lpTemp);
}

HRESULT CPolicyComponentData::InitializeRSOPRegistryData(VOID)
{
    BSTR pLanguage = NULL, pQuery = NULL;
    BSTR pRegistryKey = NULL, pValueName = NULL, pValueType = NULL, pValue = NULL, pDeleted = NULL;
    BSTR pPrecedence = NULL, pGPOid = NULL, pNamespace = NULL, pCommand = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varRegistryKey, varValueName, varValueType, varData, varDeleted;
    VARIANT varPrecedence, varGPOid, varCommand;
    SAFEARRAY * pSafeArray;
    IWbemLocator *pIWbemLocator = NULL;
    IWbemServices *pIWbemServices = NULL;
    LPTSTR lpGPOName;
    DWORD dwDataSize;
    LPBYTE lpData;
    BSTR pValueTemp;


    DebugMsg((DM_VERBOSE, TEXT("CPolicySnapIn::InitializeRSOPRegistryData:  Entering")));

    //
    // Allocate BSTRs for the query language and for the query itself
    //

    pLanguage = SysAllocString (TEXT("WQL"));

    if (!pLanguage)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for language")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    pQuery = SysAllocString (TEXT("SELECT registryKey, valueName, valueType, value, deleted, precedence, GPOID, command FROM RSOP_RegistryPolicySetting"));

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pRegistryKey = SysAllocString (TEXT("registryKey"));

    if (!pRegistryKey)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for registryKey")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pValueName = SysAllocString (TEXT("valueName"));

    if (!pValueName)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for valueName")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pValueType = SysAllocString (TEXT("valueType"));

    if (!pValueType)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for valueType")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pValue = SysAllocString (TEXT("value"));

    if (!pValue)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for value")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pDeleted = SysAllocString (TEXT("deleted"));

    if (!pDeleted)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for deleted")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pPrecedence = SysAllocString (TEXT("precedence"));

    if (!pPrecedence)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for precedence")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pGPOid = SysAllocString (TEXT("GPOID"));

    if (!pGPOid)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for GPO id")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pCommand = SysAllocString (TEXT("command"));

    if (!pCommand)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for command")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    //
    // Create an instance of the WMI locator service
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Allocate a BSTR for the namespace
    //

    pNamespace = SysAllocString (m_pszNamespace);

    if (!pNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for namespace")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Connect to the server
    //

    hr = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL,
                                      &pIWbemServices);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: ConnectServer failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet) == S_OK)
    {

        //
        // Check for the "data not available case"
        //

        if (ulRet == 0)
        {
            hr = S_OK;
            goto Exit;
        }


        //
        // Get the deleted flag
        //

        hr = pObjects[0]->Get (pDeleted, 0, &varDeleted, NULL, NULL);

        if (SUCCEEDED(hr))
        {

            //
            // Get the registry key
            //

            hr = pObjects[0]->Get (pRegistryKey, 0, &varRegistryKey, NULL, NULL);

            if (SUCCEEDED(hr))
            {

                //
                // Get the value name
                //

                hr = pObjects[0]->Get (pValueName, 0, &varValueName, NULL, NULL);

                if (SUCCEEDED(hr))
                {

                    //
                    // Get the value type
                    //

                    hr = pObjects[0]->Get (pValueType, 0, &varValueType, NULL, NULL);

                    if (SUCCEEDED(hr))
                    {

                        //
                        // Get the value data
                        //

                        hr = pObjects[0]->Get (pValue, 0, &varData, NULL, NULL);

                        if (SUCCEEDED(hr))
                        {

                            //
                            // Get the precedence
                            //

                            hr = pObjects[0]->Get (pPrecedence, 0, &varPrecedence, NULL, NULL);

                            if (SUCCEEDED(hr))
                            {

                                //
                                // Get the command
                                //

                                hr = pObjects[0]->Get (pCommand, 0, &varCommand, NULL, NULL);

                                if (SUCCEEDED(hr))
                                {

                                    //
                                    // Get the GPO ID
                                    //

                                    hr = pObjects[0]->Get (pGPOid, 0, &varGPOid, NULL, NULL);

                                    if (SUCCEEDED(hr))
                                    {
                                        hr = GetGPOFriendlyName (pIWbemServices, varGPOid.bstrVal,
                                                                 pLanguage, &lpGPOName);

                                        if (SUCCEEDED(hr))
                                        {

                                            if (varValueName.vt != VT_NULL)
                                            {
                                                pValueTemp = varValueName.bstrVal;
                                            }
                                            else
                                            {
                                                pValueTemp = NULL;
                                            }


                                            if (varData.vt != VT_NULL)
                                            {
                                                pSafeArray = varData.parray;
                                                dwDataSize = pSafeArray->rgsabound[0].cElements;
                                                lpData = (LPBYTE) pSafeArray->pvData;
                                            }
                                            else
                                            {
                                                dwDataSize = 0;
                                                lpData = NULL;
                                            }

                                            if ((varValueType.uintVal == REG_NONE) && pValueTemp &&
                                                !lstrcmpi(pValueTemp, TEXT("**command")))
                                            {
                                                pValueTemp = varCommand.bstrVal;
                                                dwDataSize = 0;
                                                lpData = NULL;
                                            }

                                            AddRSOPRegistryDataNode(varRegistryKey.bstrVal, pValueTemp,
                                                                    varValueType.uintVal, dwDataSize, lpData,
                                                                    varPrecedence.uintVal, lpGPOName,
                                                                    (varDeleted.boolVal == 0) ? FALSE : TRUE);

                                            LocalFree (lpGPOName);
                                        }

                                        VariantClear (&varGPOid);
                                    }

                                    VariantClear (&varCommand);
                                }

                                VariantClear (&varPrecedence);
                            }

                            VariantClear (&varData);
                        }

                        VariantClear (&varValueType);
                    }

                    VariantClear (&varValueName);
                }

                VariantClear (&varRegistryKey);
            }

            VariantClear (&varDeleted);
        }

        pObjects[0]->Release();

    }


    hr = S_OK;


Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pIWbemLocator)
    {
        pIWbemLocator->Release();
    }

    if (pIWbemServices)
    {
        pIWbemServices->Release();
    }

    if (pLanguage)
    {
        SysFreeString (pLanguage);
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (pRegistryKey)
    {
        SysFreeString (pRegistryKey);
    }

    if (pValueType)
    {
        SysFreeString (pValueType);
    }

    if (pValueName)
    {
        SysFreeString (pValueName);
    }

    if (pDeleted)
    {
        SysFreeString (pDeleted);
    }


    if (pValue)
    {
        SysFreeString (pValue);
    }

    if (pNamespace)
    {
        SysFreeString (pNamespace);
    }

    if (pPrecedence)
    {
        SysFreeString (pPrecedence);
    }

    if (pGPOid)
    {
        SysFreeString (pGPOid);
    }

    if (pCommand)
    {
        SysFreeString (pCommand);
    }

    DebugMsg((DM_VERBOSE, TEXT("CPolicySnapIn::InitializeRSOPRegistryData:  Leaving")));

    return hr;
}

HRESULT CPolicyComponentData::GetGPOFriendlyName(IWbemServices *pIWbemServices,
                                                LPTSTR lpGPOID, BSTR pLanguage,
                                                LPTSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;


    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //

    lpQuery = (LPTSTR) LocalAlloc (LPTR, ((lstrlen(lpGPOID) + 50) * sizeof(TCHAR)));

    if (!lpQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to allocate memory for unicode query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    wsprintf (lpQuery, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);


    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    pObjects[0]->Release();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Save the name
    //

    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(varGPOName.bstrVal) + 1) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to allocate memory for GPO Name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    lstrcpy (*pGPOName, varGPOName.bstrVal);

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}

//
// Note:  the data in the uiPrecedence argument is really a UINT.  It's declared
// as a HKEY so the hkeyRoot variable that calls this method can be used for both
// GPE and RSOP mode.
//

UINT CPolicyComponentData::ReadRSOPRegistryValue(HKEY uiPrecedence, TCHAR * pszKeyName,
                                                 TCHAR * pszValueName, LPBYTE pData,
                                                 DWORD dwMaxSize, DWORD *dwType,
                                                 LPTSTR *lpGPOName, LPRSOPREGITEM lpItem)
{
    LPRSOPREGITEM lpTemp;
    BOOL bDeleted = FALSE;
    LPTSTR lpValueNameTemp = pszValueName;


    if (!lpItem)
    {
        lpTemp = m_pRSOPRegistryData;

        if (pszValueName)
        {
            INT iDelPrefixLen = lstrlen(szDELETEPREFIX);

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                               pszValueName, iDelPrefixLen,
                               szDELETEPREFIX, iDelPrefixLen) == CSTR_EQUAL)
            {
                lpValueNameTemp = pszValueName+iDelPrefixLen;
                bDeleted = TRUE;
            }
        }


        //
        // Find the item
        //

        while (lpTemp)
        {
            if (pszKeyName && lpValueNameTemp &&
                lpTemp->lpKeyName && lpTemp->lpValueName)
            {
                if (bDeleted == lpTemp->bDeleted)
                {
                    if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                    {
                        if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp) &&
                            !lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                        {
                           break;
                        }
                    }
                }
            }
            else if (!pszKeyName && lpValueNameTemp &&
                     !lpTemp->lpKeyName && lpTemp->lpValueName)
            {
                if (bDeleted == lpTemp->bDeleted)
                {
                    if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                    {
                        if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp))
                        {
                           break;
                        }
                    }
                }
            }
            else if (pszKeyName && !lpValueNameTemp &&
                     lpTemp->lpKeyName && !lpTemp->lpValueName)
            {
                if (bDeleted == lpTemp->bDeleted)
                {
                    if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                    {
                        if (!lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                        {
                           break;
                        }
                    }
                }
            }

            lpTemp = lpTemp->pNext;
        }

    }
    else
    {

        //
        // Read a specific item
        //

        lpTemp = lpItem;
    }


    //
    // Exit now if the item wasn't found
    //

    if (!lpTemp)
    {
        return ERROR_FILE_NOT_FOUND;
    }


    //
    // Check if the data will fit in the buffer passed in
    //

    if (lpTemp->dwSize > dwMaxSize)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ReadRSOPRegistryValue: The returned data size of %d is greater than the buffer size passed in of %d for %s\\%s"),
                  lpTemp->dwSize, dwMaxSize, pszKeyName, pszValueName));
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Copy the data
    //

    if (lpTemp->lpData)
    {
        CopyMemory (pData, lpTemp->lpData, lpTemp->dwSize);
    }

    *dwType = lpTemp->dwType;

    if (lpGPOName)
    {
        *lpGPOName = lpTemp->lpGPOName;
    }

    return ERROR_SUCCESS;
}


//
// Note:  the data in the uiPrecedence argument is really a UINT.  It's declared
// as a HKEY so the hkeyRoot variable that calls this method can be used for both
// GPE and RSOP mode.
//

UINT CPolicyComponentData::EnumRSOPRegistryValues(HKEY uiPrecedence, TCHAR * pszKeyName,
                                                  TCHAR * pszValueName, DWORD dwMaxSize,
                                                  LPRSOPREGITEM *lpEnum)
{
    LPRSOPREGITEM lpTemp;


    if (lpEnum && *lpEnum)
    {
        lpTemp = (*lpEnum)->pNext;
    }
    else
    {
        lpTemp = m_pRSOPRegistryData;
    }


    //
    // Find the next item
    //

    while (lpTemp)
    {
        if (!pszKeyName && !lpTemp->lpKeyName)
        {
            if (!lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    break;
                }
            }
        }
        else if (pszKeyName && lpTemp->lpKeyName)
        {
            if (!lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    if (!lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                    {
                       break;
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }


    //
    // Exit now if an item wasn't found
    //

    if (!lpTemp)
    {
        *lpEnum = NULL;
        return ERROR_NO_MORE_ITEMS;
    }


    if (lpTemp->lpValueName)
    {

        //
        // Check if the value name will fit in the buffer passed in
        //

        if ((DWORD)(lstrlen(lpTemp->lpValueName) + 1) > dwMaxSize)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::EnumRSOPRegistryValues: The valuename buffer size is too small")));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        lstrcpy (pszValueName, lpTemp->lpValueName);
    }
    else
    {
        *pszValueName = TEXT('\0');
    }


    //
    // Save the item pointer
    //

    *lpEnum = lpTemp;

    return ERROR_SUCCESS;
}

//
// Note:  the data in the uiPrecedence argument is really a UINT.  It's declared
// as a HKEY so the hkeyRoot variable that calls this method can be used for both
// GPE and RSOP mode.
//

UINT CPolicyComponentData::FindRSOPRegistryEntry(HKEY uiPrecedence, TCHAR * pszKeyName,
                                                  TCHAR * pszValueName, LPRSOPREGITEM *lpEnum)
{
    LPRSOPREGITEM lpTemp;
    BOOL bDeleted = FALSE;
    LPTSTR lpValueNameTemp = pszValueName;


    if (lpEnum && *lpEnum)
    {
        lpTemp = (*lpEnum)->pNext;
    }
    else
    {
        lpTemp = m_pRSOPRegistryData;
    }


    if (pszValueName)
    {
        INT iDelPrefixLen = lstrlen(szDELETEPREFIX);

        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                           pszValueName, iDelPrefixLen,
                           szDELETEPREFIX, iDelPrefixLen) == CSTR_EQUAL)
        {
            lpValueNameTemp = pszValueName+iDelPrefixLen;
            bDeleted = TRUE;
        }
    }


    //
    // Find the next item
    //

    while (lpTemp)
    {
        if (pszKeyName && lpValueNameTemp &&
            lpTemp->lpKeyName && lpTemp->lpValueName)
        {
            if (bDeleted == lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp) &&
                        !lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                    {
                       break;
                    }
                }
            }
        }
        else if (!pszKeyName && lpValueNameTemp &&
                 !lpTemp->lpKeyName && lpTemp->lpValueName)
        {
            if (bDeleted == lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp))
                    {
                       break;
                    }
                }
            }
        }
        else if (pszKeyName && !lpValueNameTemp &&
                 lpTemp->lpKeyName && !lpTemp->lpValueName)
        {
            if (bDeleted == lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    if (!lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                    {
                       break;
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }


    //
    // Exit now if an item wasn't found
    //

    if (!lpTemp)
    {
        *lpEnum = NULL;
        return ERROR_NO_MORE_ITEMS;
    }


    //
    // Save the item pointer
    //

    *lpEnum = lpTemp;

    return ERROR_SUCCESS;
}


VOID CPolicyComponentData::DumpRSOPRegistryData(void)
{
    LPRSOPREGITEM lpTemp;
    TCHAR szDebug[50];


    lpTemp = m_pRSOPRegistryData;

    if (m_bUserScope)
        OutputDebugString (TEXT("\n\nDump of RSOP user registry data\n"));
    else
        OutputDebugString (TEXT("\n\nDump of RSOP computer registry data\n"));

    while (lpTemp)
    {
        OutputDebugString (TEXT("\n\n"));

        if (lpTemp->lpKeyName)
            OutputDebugString (lpTemp->lpKeyName);
        else
            OutputDebugString (TEXT("NULL Key Name"));

        OutputDebugString (TEXT("\n"));

        if (lpTemp->lpValueName)
            OutputDebugString (lpTemp->lpValueName);
        else
            OutputDebugString (TEXT("NULL Value Name"));

        OutputDebugString (TEXT("\n"));

        if (lpTemp->dwType == REG_DWORD)
        {
            wsprintf (szDebug, TEXT("REG_DWORD\n%d\n"), *((LPDWORD)lpTemp->lpData));
            OutputDebugString (szDebug);
        }

        else if (lpTemp->dwType == REG_SZ)
        {
            OutputDebugString (TEXT("REG_SZ\n"));

            if (lpTemp->lpData)
                OutputDebugString ((LPTSTR)lpTemp->lpData);

            OutputDebugString (TEXT("\n"));
        }

        else if (lpTemp->dwType == REG_EXPAND_SZ)
        {
            OutputDebugString (TEXT("REG_EXPAND_SZ\n"));

            if (lpTemp->lpData)
                OutputDebugString ((LPTSTR)lpTemp->lpData);

            OutputDebugString (TEXT("\n"));
        }

        else if (lpTemp->dwType == REG_BINARY)
        {
            OutputDebugString (TEXT("REG_BINARY\n"));
            OutputDebugString (TEXT("<Binary data not displayed>\n"));
        }

        else if (lpTemp->dwType == REG_NONE)
        {
            OutputDebugString (TEXT("REG_NONE\n"));
        }

        else
        {
            wsprintf (szDebug, TEXT("Unknown type:  %d\n"), lpTemp->dwType);
            OutputDebugString (szDebug);
        }

        wsprintf (szDebug, TEXT("Precedence:  %d\n"), lpTemp->uiPrecedence);
        OutputDebugString(szDebug);

        wsprintf (szDebug, TEXT("Deleted:  %d\n"), lpTemp->bDeleted);
        OutputDebugString(szDebug);

        wsprintf (szDebug, TEXT("bFoundInADM:  %d\n"), lpTemp->bFoundInADM);
        OutputDebugString(szDebug);

        OutputDebugString (TEXT("GPOName:  "));

        if (lpTemp->lpGPOName)
            OutputDebugString (lpTemp->lpGPOName);
        else
            OutputDebugString (TEXT("NULL GPO Name"));

        OutputDebugString (TEXT("\n"));

        lpTemp = lpTemp->pNext;
    }

    OutputDebugString (TEXT("\n\n"));
}

BOOL CPolicyComponentData::FindEntryInActionList(POLICY * pPolicy, ACTIONLIST * pActionList, LPTSTR lpKeyName, LPTSTR lpValueName)
{
    
    UINT uIndex;
    ACTION * pAction;
    TCHAR * pszKeyName;
    TCHAR * pszValueName;


    //
    // Loop through each of the entries to see if they match
    //

    for (uIndex = 0; uIndex < pActionList->nActionItems; uIndex++)
    {

        if (uIndex == 0)
        {
            pAction = &pActionList->Action[0];
        }
        else
        {
            pAction = (ACTION *)(((LPBYTE)pActionList) + pAction->uOffsetNextAction);
        }

        //
        // Get the value and keynames
        //

        pszValueName = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetValueName);
        
        if (pAction->uOffsetKeyName)
        {
            pszKeyName = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetKeyName);
        }
        else
        {
            pszKeyName = (TCHAR *)(((LPBYTE)pPolicy) + pPolicy->uOffsetKeyName);
        }
        
        if (!lstrcmpi(pszKeyName, lpKeyName) && !lstrcmpi(pszValueName, lpValueName))  {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CPolicyComponentData::FindEntryInTable(TABLEENTRY * pTable, LPTSTR lpKeyName, LPTSTR lpValueName)
{
    POLICY * pEntry = (POLICY *) pTable;


    if ((pEntry->dwType & ETYPE_POLICY) || (pEntry->dwType & ETYPE_SETTING))
    {
        if (!lstrcmpi(lpKeyName, GETKEYNAMEPTR(pEntry))) 
        {
            if ( (!(GETVALUENAMEPTR(pEntry)) || (!lstrcmpi(GETVALUENAMEPTR(pEntry), TEXT("")))) ) {
                if (pEntry->dwType & STYPE_LISTBOX) {
                    return TRUE;
                }
            }
            else if (!lstrcmpi(lpValueName, GETVALUENAMEPTR(pEntry)))
            {
                return TRUE;
            }
        }

        // look in the actionlists

        // actionslist can be at 3 places. under policy itself or under the dropdown lists below

        ACTIONLIST * pActionList;

        if (pEntry->dwType & ETYPE_POLICY) {
            if (pEntry->uOffsetActionList_On) {
                pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + pEntry->uOffsetActionList_On);

                if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                    return TRUE;
            }

            if (pEntry->uOffsetActionList_Off) {
                pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + pEntry->uOffsetActionList_Off);

                if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                    return TRUE;
            }
        }

        if (pEntry->dwType & ETYPE_SETTING) {
            SETTINGS * pSettings = (SETTINGS *)pTable;

            if (pSettings) {

                BYTE * pObjectData = GETOBJECTDATAPTR(pSettings);

                if (pObjectData) {

                    if ((pEntry->dwType & STYPE_MASK) == STYPE_CHECKBOX) {
                        if (((CHECKBOXINFO *)pObjectData)->uOffsetActionList_On) {
                            pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + (((CHECKBOXINFO *)pObjectData)->uOffsetActionList_On));

                            if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                                return TRUE;
                        }

                        if (((CHECKBOXINFO *)pObjectData)->uOffsetActionList_Off) {
                            pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + (((CHECKBOXINFO *)pObjectData)->uOffsetActionList_Off));

                            if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                                return TRUE;
                        }
                    }

                    if ((pEntry->dwType & STYPE_MASK) == STYPE_DROPDOWNLIST) {
                        DROPDOWNINFO * pddi;
    
                        pddi = (DROPDOWNINFO *)  pObjectData;
    
                        while (pddi) {
                            if (pddi->uOffsetActionList) {
                                pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + pddi->uOffsetActionList);
                                if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                                    return TRUE;
    
                            }

                            if (pddi->uOffsetNextDropdowninfo) {
                                pddi = (DROPDOWNINFO *) ( (BYTE *) pEntry + pddi->uOffsetNextDropdowninfo);
                            }
                            else {
                                pddi = NULL;
                            }
                        }
                    }
                }
            }

        }
    }

    if (pEntry->pChild)
    {
        if (FindEntryInTable(pEntry->pChild, lpKeyName, lpValueName))
        {
            return TRUE;
        }
    }

    if (pEntry->pNext)
    {
        if (FindEntryInTable(pEntry->pNext, lpKeyName, lpValueName))
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID CPolicyComponentData::AddEntryToList (TABLEENTRY *pItem)
{
    TABLEENTRY *lpTemp;


    lpTemp = m_pExtraSettingsRoot->pChild;


    if (!lpTemp)
    {
        m_pExtraSettingsRoot->pChild = pItem;
        return;
    }


    while (lpTemp->pNext)
    {
        lpTemp = lpTemp->pNext;
    }

    lpTemp->pNext = pItem;
    pItem->pPrev = lpTemp;

}

VOID CPolicyComponentData::InitializeExtraSettings (VOID)
{
    LPRSOPREGITEM lpTemp;
    TCHAR szValueStr[MAX_PATH];


    lpTemp = m_pRSOPRegistryData;

    while (lpTemp)
    {
        //
        // Build REGITEM structures for every registry entry that has a precedence of 1
        // and that is not found in any adm file
        //

        if ((lpTemp->uiPrecedence == 1) && (lpTemp->dwType != REG_NONE) && (!lpTemp->bDeleted))
        {
            DWORD dwBufSize = 0;
            REGITEM *pTmp, *pItem;
            LPTSTR lpName;


            //
            // Check to see if this registry entry is used by any adm policy / part
            //


            if (m_bUserScope)
            {
                if (m_pUserCategoryList)
                {
                    lpTemp->bFoundInADM = FindEntryInTable(m_pUserCategoryList,
                                                           lpTemp->lpKeyName,
                                                           lpTemp->lpValueName);
                }
            }
            else
            {
                if (m_pMachineCategoryList)
                {
                    lpTemp->bFoundInADM = FindEntryInTable(m_pMachineCategoryList,
                                                           lpTemp->lpKeyName,
                                                           lpTemp->lpValueName);
                }
            }


            if (!lpTemp->bFoundInADM)
            {

                //
                // Build regitem entry
                //

                pItem = (REGITEM *) GlobalAlloc(GPTR, sizeof(REGITEM));

                if (pItem)
                {

                    pItem->dwSize = sizeof(REGITEM);
                    pItem->dwType = ETYPE_REGITEM;
                    pItem->lpItem = lpTemp;


                    dwBufSize += lstrlen (lpTemp->lpKeyName) + 1;

                    if (lpTemp->lpValueName && *lpTemp->lpValueName)
                    {
                        dwBufSize += lstrlen (lpTemp->lpValueName) + 1;
                    }

                    lpName = (LPTSTR) LocalAlloc (LPTR, dwBufSize * sizeof(TCHAR));

                    if (lpName)
                    {
                        lstrcpy (lpName, lpTemp->lpKeyName);

                        if (lpTemp->lpValueName && *lpTemp->lpValueName)
                        {
                            lstrcat (lpName, TEXT("\\"));
                            lstrcat (lpName, lpTemp->lpValueName);
                        }

                        //
                        // Add the display name
                        //

                        pTmp = (REGITEM *) AddDataToEntry((TABLEENTRY *)pItem,
                            (BYTE *)lpName,(lstrlen(lpName)+1) * sizeof(TCHAR),&(pItem->uOffsetName),
                            &dwBufSize);

                        if (pTmp)
                        {
                            pItem = pTmp;

                            //
                            // Add the keyname
                            //

                            pTmp = (REGITEM *) AddDataToEntry((TABLEENTRY *)pItem,
                                (BYTE *)lpTemp->lpKeyName,(lstrlen(lpTemp->lpKeyName)+1) * sizeof(TCHAR),&(pItem->uOffsetKeyName),
                                &dwBufSize);

                            if (pTmp)
                            {
                                pItem = pTmp;


                                szValueStr[0] = TEXT('\0');

                                if (lpTemp->dwType == REG_DWORD)
                                {
                                    wsprintf (szValueStr, TEXT("%d"), (DWORD) *((LPDWORD)lpTemp->lpData));
                                }

                                else if (lpTemp->dwType == REG_SZ)
                                {
                                    lstrcpyn (szValueStr, (LPTSTR)lpTemp->lpData, ARRAYSIZE(szValueStr));
                                }

                                else if (lpTemp->dwType == REG_EXPAND_SZ)
                                {
                                    lstrcpyn (szValueStr, (LPTSTR)lpTemp->lpData, ARRAYSIZE(szValueStr));
                                }

                                else if (lpTemp->dwType == REG_BINARY)
                                {
                                    LoadString(g_hInstance, IDS_BINARYDATA, szValueStr, ARRAYSIZE(szValueStr));
                                }

                                else
                                {
                                    LoadString(g_hInstance, IDS_UNKNOWNDATA, szValueStr, ARRAYSIZE(szValueStr));
                                }


                                //
                                // Add the value in string format
                                //

                                pTmp = (REGITEM *) AddDataToEntry((TABLEENTRY *)pItem,
                                    (BYTE *)szValueStr,(lstrlen(szValueStr)+1) * sizeof(TCHAR),&(pItem->uOffsetValueStr),
                                    &dwBufSize);

                                if (pTmp)
                                {
                                    pItem = pTmp;



                                    //
                                    // Check if this is a real policy
                                    //

                                    if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                                      lpTemp->lpKeyName, m_iSWPoliciesLen,
                                                      SOFTWARE_POLICIES, m_iSWPoliciesLen) == CSTR_EQUAL)
                                    {
                                        pItem->bTruePolicy = TRUE;
                                    }

                                    else if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                                      lpTemp->lpKeyName, m_iWinPoliciesLen,
                                                      WINDOWS_POLICIES, m_iWinPoliciesLen) == CSTR_EQUAL)
                                    {
                                        pItem->bTruePolicy = TRUE;
                                    }

                                    AddEntryToList ((TABLEENTRY *)pItem);
                                }
                                else
                                {
                                    GlobalFree (pItem);
                                }
                            }
                            else
                            {
                                GlobalFree (pItem);
                            }
                        }
                        else
                        {
                            GlobalFree (pItem);
                        }

                        LocalFree (lpName);
                    }
                    else
                    {
                         GlobalFree (pItem);
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }
}

BOOL CPolicyComponentData::DoesNodeExist (LPSUPPORTEDENTRY *pList, LPTSTR lpString)
{
    LPSUPPORTEDENTRY lpItem;

    if (!(*pList))
    {
        return FALSE;
    }

    lpItem = *pList;

    while (lpItem)
    {
        if (!lstrcmpi(lpItem->lpString, lpString))
        {
            return TRUE;
        }

        lpItem = lpItem->pNext;
    }

    return FALSE;
}

BOOL CPolicyComponentData::CheckSupportedFilter (POLICY *pPolicy)
{
    LPSUPPORTEDENTRY lpItem = m_pSupportedStrings;
    LPTSTR lpString = GETSUPPORTEDPTR(pPolicy);


    if (!lpItem || !m_bUseSupportedOnFilter)
    {
        return TRUE;
    }

    while (lpItem)
    {
        if (!lpString)
        {
            if (lpItem->bNull)
            {
                return lpItem->bEnabled;
            }
        }
        else
        {
            if (!lstrcmpi(lpItem->lpString, lpString))
            {
                return lpItem->bEnabled;
            }
        }

        lpItem = lpItem->pNext;
    }

    return TRUE;
}

BOOL CPolicyComponentData::IsAnyPolicyAllowedPastFilter(TABLEENTRY * pCategory)
{
    TABLEENTRY * pEntry;
    INT iState;

    if (!pCategory || !pCategory->pChild)
    {
        return FALSE;
    }

    pEntry = pCategory->pChild;

    while (pEntry)
    {
        if (pEntry->dwType & ETYPE_CATEGORY)
        {
            if (IsAnyPolicyAllowedPastFilter(pEntry))
            {
                return TRUE;
            }
        }
        else if (pEntry->dwType & ETYPE_POLICY)
        {
            if (CheckSupportedFilter((POLICY *) pEntry))
            {
                return TRUE;
            }
        }

        pEntry = pEntry->pNext;
    }

    return FALSE;
}


VOID CPolicyComponentData::AddSupportedNode (LPSUPPORTEDENTRY *pList, LPTSTR lpString,
                                             BOOL bNull)
{
    LPSUPPORTEDENTRY lpItem;
    DWORD dwSize;


    //
    // Check if this item is already in the link list first
    //

    if (DoesNodeExist (pList, lpString))
    {
        return;
    }


    //
    // Add it to the list
    //

    dwSize = sizeof(SUPPORTEDENTRY);
    dwSize += ((lstrlen(lpString) + 1) * sizeof(TCHAR));

    lpItem = (LPSUPPORTEDENTRY) LocalAlloc (LPTR, dwSize);

    if (!lpItem)
    {
        return;
    }

    lpItem->lpString = (LPTSTR)(((LPBYTE)lpItem) + sizeof(SUPPORTEDENTRY));
    lstrcpy (lpItem->lpString, lpString);

    lpItem->bEnabled = TRUE;
    lpItem->bNull = bNull;

    lpItem->pNext = *pList;
    *pList = lpItem;
}

VOID CPolicyComponentData::FreeSupportedData(LPSUPPORTEDENTRY lpList)
{
    LPSUPPORTEDENTRY lpTemp;


    do {
        lpTemp = lpList->pNext;
        LocalFree (lpList);
        lpList = lpTemp;

    } while (lpTemp);
}

VOID CPolicyComponentData::InitializeSupportInfo(TABLEENTRY * pTable, LPSUPPORTEDENTRY *pList)
{
    POLICY * pEntry = (POLICY *) pTable;
    LPTSTR lpString;


    if (pEntry->dwType & ETYPE_POLICY)
    {
        lpString = GETSUPPORTEDPTR(pEntry);

        if (lpString)
        {
            AddSupportedNode (pList, lpString, FALSE);
        }
    }

    if (pEntry->pChild)
    {
        InitializeSupportInfo(pEntry->pChild, pList);
    }

    if (pEntry->pNext)
    {
        InitializeSupportInfo(pEntry->pNext, pList);
    }

}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CPolicyComponentDataCF::CPolicyComponentDataCF(BOOL bUser, BOOL bRSOP)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_bUser = bUser;
    m_bRSOP = bRSOP;
}

CPolicyComponentDataCF::~CPolicyComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CPolicyComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CPolicyComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CPolicyComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CPolicyComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CPolicyComponentData *pComponentData = new CPolicyComponentData(m_bUser, m_bRSOP); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CPolicyComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object creation (IClassFactory)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CreatePolicyComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    //
    // Admin Templates in editing mode
    //

    if (IsEqualCLSID (rclsid, CLSID_PolicySnapInMachine)) {

        CPolicyComponentDataCF *pComponentDataCF = new CPolicyComponentDataCF(FALSE, FALSE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_PolicySnapInUser)) {

        CPolicyComponentDataCF *pComponentDataCF = new CPolicyComponentDataCF(TRUE, FALSE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }


    //
    // Admin Templates in RSOP mode
    //

    if (IsEqualCLSID (rclsid, CLSID_RSOPolicySnapInMachine)) {

        CPolicyComponentDataCF *pComponentDataCF = new CPolicyComponentDataCF(FALSE, TRUE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPolicySnapInUser)) {

        CPolicyComponentDataCF *pComponentDataCF = new CPolicyComponentDataCF(TRUE, TRUE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }


    return CLASS_E_CLASSNOTAVAILABLE;
}



unsigned int CPolicySnapIn::m_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CPolicySnapIn::CPolicySnapIn(CPolicyComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumn1Size = 350;
    m_nColumn2Size = 100;
    m_nColumn3Size = 200;
    m_lViewMode = LVS_REPORT;

    if (m_pcd->m_bRSOP)
    {
        m_bPolicyOnly = FALSE;
    }
    else
    {
        m_bPolicyOnly = TRUE;
    }

    m_dwPolicyOnlyPolicy = 2;
    m_hMsgWindow = NULL;
    m_uiRefreshMsg = RegisterWindowMessage (TEXT("ADM Template Reload"));
    m_pCurrentPolicy = NULL;
    m_hPropDlg = NULL;

    LoadString(g_hInstance, IDS_NAME, m_pName, ARRAYSIZE(m_pName));
    LoadString(g_hInstance, IDS_STATE, m_pState, ARRAYSIZE(m_pState));
    LoadString(g_hInstance, IDS_SETTING, m_pSetting, ARRAYSIZE(m_pSetting));
    LoadString(g_hInstance, IDS_GPONAME, m_pGPOName, ARRAYSIZE(m_pGPOName));
    LoadString(g_hInstance, IDS_MULTIPLEGPOS, m_pMultipleGPOs, ARRAYSIZE(m_pMultipleGPOs));

    LoadString(g_hInstance, IDS_ENABLED, m_pEnabled, ARRAYSIZE(m_pEnabled));
    LoadString(g_hInstance, IDS_DISABLED, m_pDisabled, ARRAYSIZE(m_pDisabled));
    LoadString(g_hInstance, IDS_NOTCONFIGURED, m_pNotConfigured, ARRAYSIZE(m_pNotConfigured));
}

CPolicySnapIn::~CPolicySnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CPolicySnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CPolicySnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CPolicySnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation (IComponent)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicySnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT   hr;
    WNDCLASS  wc;
    HKEY hKey;
    DWORD dwSize, dwType;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));


    ZeroMemory (&wc, sizeof(wc));
    wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wc.lpfnWndProc   = (WNDPROC)ClipWndProc;
    wc.cbWndExtra    = sizeof(DWORD);
    wc.hInstance     = (HINSTANCE) g_hInstance;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszClassName = TEXT("ClipClass");

    if (!RegisterClass(&wc))
    {
        if (GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::Initialize: RegisterClass for clipclass failed with %d."),
                     GetLastError()));
            return E_FAIL;
        }
    }


    ZeroMemory (&wc, sizeof(wc));
    wc.lpfnWndProc   = (WNDPROC)MessageWndProc;
    wc.cbWndExtra    = sizeof(LPVOID);
    wc.hInstance     = (HINSTANCE) g_hInstance;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszClassName = TEXT("GPMessageWindowClass");

    if (!RegisterClass(&wc))
    {
        if (GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::Initialize: RegisterClass for message window class failed with %d."),
                     GetLastError()));
            return E_FAIL;
        }
    }

    m_hMsgWindow = CreateWindow (TEXT("GPMessageWindowClass"), TEXT("GP Hidden Message Window"),
                                 WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, 0, 0, NULL, NULL, NULL,
                                 (LPVOID) this);
    if (!m_hMsgWindow)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::Initialize: CreateWindow failed with %d."),
                 GetLastError()));
        return E_FAIL;
    }

    //
    // Load the user's options
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(m_dwPolicyOnlyPolicy);
        RegQueryValueEx (hKey, POLICYONLY_VALUE, NULL, &dwType,
                         (LPBYTE) &m_dwPolicyOnlyPolicy, &dwSize);

        RegCloseKey (hKey);
    }

    if (m_dwPolicyOnlyPolicy == 0)
    {
        m_bPolicyOnly = FALSE;
    }
    else if (m_dwPolicyOnlyPolicy == 1)
    {
        m_bPolicyOnly = TRUE;
    }

    return S_OK;
}

STDMETHODIMP CPolicySnapIn::Destroy(MMC_COOKIE cookie)
{

    DestroyWindow (m_hMsgWindow);

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CPolicySnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;


        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

        if (hbmp16x16)
        {
            hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

            if (hbmp32x32)
            {
                LPIMAGELIST pImageList = (LPIMAGELIST) arg;

                // Set the images
                pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                                  reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                                  0, RGB(255, 0, 255));

                DeleteObject(hbmp32x32);
            }

            DeleteObject(hbmp16x16);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPPOLICYDATAOBJECT pPolicyDataObject;
            TABLEENTRY * pNode, *pTemp = NULL;
            MMC_COOKIE cookie;
            INT i, iState;
            BOOL bAdd;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IPolicyDataObject, (LPVOID *)&pPolicyDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pPolicyDataObject->GetCookie(&cookie);

            pPolicyDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;

            pNode = (TABLEENTRY *)cookie;

            if (pNode)
            {
                pTemp = pNode->pChild;
            }

            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_pSetting, LVCFMT_LEFT, m_nColumn1Size);
            m_pHeader->InsertColumn(1, m_pState, LVCFMT_CENTER, m_nColumn2Size);

            if (m_pcd->m_bRSOP)
            {
                m_pHeader->InsertColumn(2, m_pGPOName, LVCFMT_CENTER, m_nColumn3Size);
            }

            m_pResult->SetViewMode(m_lViewMode);



            //
            // Add the Policies
            //

            while (pTemp)
            {
                if (pTemp->dwType == ETYPE_POLICY)
                {
                    bAdd = TRUE;

                    if (m_pcd->m_bUseSupportedOnFilter)
                    {
                        bAdd = m_pcd->CheckSupportedFilter((POLICY *)pTemp);
                    }

                    if (bAdd && m_pcd->m_bShowConfigPoliciesOnly)
                    {
                        INT iState;

                        iState = GetPolicyState(pTemp, 1, NULL);

                        if (iState == -1)
                        {
                            bAdd = FALSE;
                        }
                    }

                    if (bAdd && m_bPolicyOnly)
                    {
                        if (((POLICY *) pTemp)->bTruePolicy != TRUE)
                        {
                            bAdd = FALSE;
                        }
                    }

                    if (bAdd)
                    {
                        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                        resultItem.str = MMC_CALLBACK;

                        if (((POLICY *) pTemp)->bTruePolicy)
                        {
                            resultItem.nImage = 4;
                        }
                        else
                        {
                            resultItem.nImage = 5;
                        }

                        resultItem.nCol = 0;
                        resultItem.lParam = (LPARAM) pTemp;

                        if (SUCCEEDED(m_pResult->InsertItem(&resultItem)))
                        {
                            resultItem.mask = RDI_STR;
                            resultItem.str = MMC_CALLBACK;
                            resultItem.bScopeItem = FALSE;
                            resultItem.nCol = 1;

                            m_pResult->SetItem(&resultItem);
                        }
                    }
                }

                else if (pTemp->dwType == ETYPE_REGITEM)
                {
                    bAdd = TRUE;

                    if (m_bPolicyOnly)
                    {
                        if (((REGITEM *) pTemp)->bTruePolicy != TRUE)
                        {
                            bAdd = FALSE;
                        }
                    }

                    if (((REGITEM *) pTemp)->lpItem->bFoundInADM == TRUE)
                    {
                        bAdd = FALSE;
                    }


                    if (bAdd)
                    {
                        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                        resultItem.str = MMC_CALLBACK;

                        if (((REGITEM *) pTemp)->bTruePolicy)
                        {
                            resultItem.nImage = 4;
                        }
                        else
                        {
                            resultItem.nImage = 5;
                        }

                        resultItem.nCol = 0;
                        resultItem.lParam = (LPARAM) pTemp;

                        if (SUCCEEDED(m_pResult->InsertItem(&resultItem)))
                        {
                            resultItem.mask = RDI_STR;
                            resultItem.str = MMC_CALLBACK;
                            resultItem.bScopeItem = FALSE;
                            resultItem.nCol = 1;

                            m_pResult->SetItem(&resultItem);
                        }
                    }
                }

                pTemp = pTemp->pNext;
            }

        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumn1Size);
            m_pHeader->GetColumnWidth(1, &m_nColumn2Size);
            if (m_pcd->m_bRSOP)
            {
                m_pHeader->GetColumnWidth(2, &m_nColumn3Size);
            }
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;


    case MMCN_SELECT:
        {
        LPPOLICYDATAOBJECT pPolicyDataObject;
        DATA_OBJECT_TYPES type;
        MMC_COOKIE cookie;
        POLICY * pPolicy;

        //
        // See if this is one of our items.
        //

        hr = lpDataObject->QueryInterface(IID_IPolicyDataObject, (LPVOID *)&pPolicyDataObject);

        if (FAILED(hr))
            break;

        pPolicyDataObject->GetType(&type);
        pPolicyDataObject->GetCookie(&cookie);
        pPolicyDataObject->Release();


        if (m_pConsoleVerb)
        {

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if (type == CCT_RESULT)
            {
                if (HIWORD(arg))
                {
                    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
                }
            }
        }

        if (m_hPropDlg && (type == CCT_RESULT) && HIWORD(arg))
        {
            pPolicy = (POLICY *)cookie;

            if (pPolicy->dwType & ETYPE_POLICY)
            {
                m_pCurrentPolicy = pPolicy;
                SendMessage (GetParent(m_hPropDlg), PSM_QUERYSIBLINGS, 1000, 0);
            }
        }

        }
        break;

    case MMCN_CONTEXTHELP:
        {

        if (m_pDisplayHelp)
        {
            LPPOLICYDATAOBJECT pPolicyDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;
            LPOLESTR pszHelpTopic;


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IPolicyDataObject, (LPVOID *)&pPolicyDataObject);

            if (FAILED(hr))
                break;

            pPolicyDataObject->Release();


            //
            // Display the admin templates help page
            //

            pszHelpTopic = (LPOLESTR) CoTaskMemAlloc (50 * sizeof(WCHAR));

            if (pszHelpTopic)
            {
                lstrcpy (pszHelpTopic, TEXT("gpedit.chm::/adm.htm"));
                m_pDisplayHelp->ShowTopic (pszHelpTopic);
            }
        }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CPolicySnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    if (pResult->lParam == 0)
                    {
                        pResult->str = m_pcd->m_szRootName;
                    }
                    else
                    {
                        TABLEENTRY * pTableEntry;

                        pTableEntry = (TABLEENTRY *)(pResult->lParam);
                        pResult->str = GETNAMEPTR(pTableEntry);
                    }
                }
                else
                {
                    pResult->str = L"";
                }
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = 0;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                TABLEENTRY * pTableEntry;
                INT iState;
                LPTSTR lpGPOName = NULL;

                pTableEntry = (TABLEENTRY *)(pResult->lParam);


                if (pTableEntry->dwType & ETYPE_REGITEM)
                {
                    REGITEM *pItem = (REGITEM*)pTableEntry;

                    if (pResult->nCol == 0)
                    {
                        pResult->str = GETNAMEPTR(pTableEntry);

                        if (pResult->str == NULL)
                        {
                            pResult->str = (LPOLESTR)L"";
                        }
                    }
                    else if (pResult->nCol == 1)
                    {
                        pResult->str = GETVALUESTRPTR(pItem);
                    }
                    else if (pResult->nCol == 2)
                    {
                        pResult->str = pItem->lpItem->lpGPOName;
                    }
                }
                else
                {
                    iState = GetPolicyState (pTableEntry, 1, &lpGPOName);


                    if (pResult->nCol == 0)
                    {
                        pResult->str = GETNAMEPTR(pTableEntry);

                        if (pResult->str == NULL)
                        {
                            pResult->str = (LPOLESTR)L"";
                        }
                    }
                    else if (pResult->nCol == 1)
                    {
                        if (iState == 1)
                        {
                            pResult->str = m_pEnabled;
                        }
                        else if (iState == 0)
                        {
                            pResult->str = m_pDisabled;
                        }
                        else
                        {
                            pResult->str = m_pNotConfigured;
                        }
                    }
                    else if (pResult->nCol == 2)
                    {
                        pResult->str = lpGPOName;
                    }
                }
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CPolicySnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CPolicySnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CPolicySnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPPOLICYDATAOBJECT pPolicyDataObjectA, pPolicyDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObjectB)))
    {
        pPolicyDataObjectA->Release();
        return S_FALSE;
    }

    pPolicyDataObjectA->GetCookie(&cookie1);
    pPolicyDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pPolicyDataObjectA->Release();
    pPolicyDataObjectB->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn:: object implementation (IExtendContextMenu)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicySnapIn::AddMenuItems(LPDATAOBJECT piDataObject,
                                          LPCONTEXTMENUCALLBACK pCallback,
                                          LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TCHAR szMenuItem[100];
    TCHAR szDescription[250];
    CONTEXTMENUITEM item;
    LPPOLICYDATAOBJECT pPolicyDataObject;
    DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;
    MMC_COOKIE cookie;
    POLICY *pPolicy;


    if (SUCCEEDED(piDataObject->QueryInterface(IID_IPolicyDataObject,
                 (LPVOID *)&pPolicyDataObject)))
    {
        pPolicyDataObject->GetType(&type);
        pPolicyDataObject->GetCookie(&cookie);
        pPolicyDataObject->Release();
    }


    if (type == CCT_SCOPE)
    {
        pPolicy = (POLICY *)cookie;

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
        {

            if (!m_pcd->m_bRSOP)
            {
                LoadString (g_hInstance, IDS_FILTERING, szMenuItem, 100);
                LoadString (g_hInstance, IDS_FILTERINGDESC, szDescription, 250);

                item.strName = szMenuItem;
                item.strStatusBarText = szDescription;
                item.lCommandID = IDM_FILTERING;
                item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
                item.fFlags = 0;
                item.fSpecialFlags = 0;

                hr = pCallback->AddItem(&item);
            }
        }
    }

    return (hr);
}

STDMETHODIMP CPolicySnapIn::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{

    if (lCommandID == IDM_FILTERING)
    {
        if (DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_POLICY_FILTERING),
                           m_pcd->m_hwndFrame, FilterDlgProc,(LPARAM) this))
        {
            //
            // Refresh the display
            //

            m_pcd->m_pScope->DeleteItem (m_pcd->m_hSWPolicies, FALSE);
            m_pcd->EnumerateScopePane (NULL, m_pcd->m_hSWPolicies);
        }
    }

    return S_OK;

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation (IExtendPropertySheet)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicySnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage[3];
    LPPOLICYDATAOBJECT pPolicyDataObject;
    MMC_COOKIE cookie;
    LPSETTINGSINFO lpSettingsInfo;


    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObject)))
    {
        return S_OK;
    }


    //
    // Get the cookie
    //

    pPolicyDataObject->GetCookie(&cookie);
    pPolicyDataObject->Release();


    m_pCurrentPolicy = (POLICY *)cookie;


    //
    // Allocate a settings info structure
    //

    lpSettingsInfo = (LPSETTINGSINFO) LocalAlloc(LPTR, sizeof(SETTINGSINFO));

    if (!lpSettingsInfo)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to allocate memory with %d."),
                 GetLastError()));
        return S_OK;
    }

    lpSettingsInfo->pCS = this;


    //
    // Allocate a POLICYDLGINFO structure
    //

    lpSettingsInfo->pdi = (POLICYDLGINFO *) LocalAlloc(LPTR,sizeof(POLICYDLGINFO));

    if (!lpSettingsInfo->pdi)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to allocate memory with %d."),
                 GetLastError()));
        LocalFree (lpSettingsInfo);
        return S_OK;
    }


    //
    // Initialize POLICYDLGINFO
    //

    lpSettingsInfo->pdi->dwControlTableSize = DEF_CONTROLS * sizeof(POLICYCTRLINFO);
    lpSettingsInfo->pdi->nControls = 0;
    lpSettingsInfo->pdi->pEntryRoot = (lpSettingsInfo->pCS->m_pcd->m_bUserScope ?
            lpSettingsInfo->pCS->m_pcd->m_pUserCategoryList :
            lpSettingsInfo->pCS->m_pcd->m_pMachineCategoryList);
    lpSettingsInfo->pdi->hwndApp = lpSettingsInfo->pCS->m_pcd->m_hwndFrame;

    lpSettingsInfo->pdi->pControlTable = (POLICYCTRLINFO *) LocalAlloc(LPTR,
                                          lpSettingsInfo->pdi->dwControlTableSize);

    if (!lpSettingsInfo->pdi->pControlTable) {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to allocate memory with %d."),
                 GetLastError()));
        LocalFree (lpSettingsInfo->pdi);
        LocalFree (lpSettingsInfo);
        return S_OK;
    }


    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.lParam = (LPARAM) lpSettingsInfo;


    //
    // Add the pages
    //

    if (m_pCurrentPolicy->dwType & ETYPE_REGITEM)
    {
        psp.pszTemplate = MAKEINTRESOURCE(IDD_POLICY_PRECEDENCE);
        psp.pfnDlgProc = PolicyPrecedenceDlgProc;


        hPage[0] = CreatePropertySheetPage(&psp);

        if (hPage[0])
        {
            hr = lpProvider->AddPage(hPage[0]);
        }
    }
    else
    {

        psp.pszTemplate = MAKEINTRESOURCE(IDD_POLICY);
        psp.pfnDlgProc = PolicyDlgProc;


        hPage[0] = CreatePropertySheetPage(&psp);

        if (hPage[0])
        {
            hr = lpProvider->AddPage(hPage[0]);

            psp.pszTemplate = MAKEINTRESOURCE(IDD_POLICY_HELP);
            psp.pfnDlgProc = PolicyHelpDlgProc;


            hPage[1] = CreatePropertySheetPage(&psp);

            if (hPage[1])
            {
                hr = lpProvider->AddPage(hPage[1]);

                if (m_pcd->m_bRSOP)
                {
                    psp.pszTemplate = MAKEINTRESOURCE(IDD_POLICY_PRECEDENCE);
                    psp.pfnDlgProc = PolicyPrecedenceDlgProc;


                    hPage[2] = CreatePropertySheetPage(&psp);

                    if (hPage[2])
                    {
                        hr = lpProvider->AddPage(hPage[2]);
                    }
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                     GetLastError()));
            hr = E_FAIL;
        }
    }


    return (hr);
}

STDMETHODIMP CPolicySnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPPOLICYDATAOBJECT pPolicyDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IPolicyDataObject,
                                               (LPVOID *)&pPolicyDataObject)))
    {
        pPolicyDataObject->GetType(&type);
        pPolicyDataObject->Release();

        if (type == CCT_RESULT)
        {
            if (!m_hPropDlg)
                return S_OK;
            // There's already a propety sheet open so we'll bring it to the front.
            BringWindowToTop(GetParent(m_hPropDlg));
        }
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation (Internal functions)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL CPolicySnapIn::IsAnyPolicyEnabled(TABLEENTRY * pCategory)
{
    TABLEENTRY * pEntry;
    INT iState;

    if (!pCategory || !pCategory->pChild)
    {
        return FALSE;
    }

    pEntry = pCategory->pChild;

    while (pEntry)
    {
        if (pEntry->dwType & ETYPE_CATEGORY)
        {
            if (IsAnyPolicyEnabled(pEntry))
            {
                return TRUE;
            }
        }
        else if (pEntry->dwType & ETYPE_POLICY)
        {
            iState = GetPolicyState(pEntry, 1, NULL);

            if ((iState == 1) || (iState == 0))
            {
                return TRUE;
            }
        }

        pEntry = pEntry->pNext;
    }

    return FALSE;
}

VOID CPolicySnapIn::RefreshSettingsControls(HWND hDlg)
{
    BOOL fEnabled = FALSE;
    INT iState;
    LPTSTR lpSupported;
    POLICY *pPolicy = (POLICY *)m_pCurrentPolicy;

    FreeSettingsControls(hDlg);

    SetDlgItemText (hDlg, IDC_POLICY, GETNAMEPTR(m_pCurrentPolicy));

    if (pPolicy->bTruePolicy)
    {
        SendMessage (GetDlgItem(hDlg, IDC_POLICYICON), STM_SETIMAGE, IMAGE_ICON,
                     (LPARAM) (HANDLE) m_hPolicyIcon);
    }
    else
    {
        SendMessage (GetDlgItem(hDlg, IDC_POLICYICON), STM_SETIMAGE, IMAGE_ICON,
                     (LPARAM) (HANDLE) m_hPreferenceIcon);
    }

    lpSupported = GETSUPPORTEDPTR(pPolicy);

    if (lpSupported)
    {
        ShowWindow (GetDlgItem(hDlg, IDC_SUPPORTEDTITLE), SW_SHOW);
        ShowWindow (GetDlgItem(hDlg, IDC_SUPPORTED), SW_SHOW);
        SetDlgItemText (hDlg, IDC_SUPPORTED, lpSupported);
    }
    else
    {
        SetDlgItemText (hDlg, IDC_SUPPORTED, TEXT(""));
        ShowWindow (GetDlgItem(hDlg, IDC_SUPPORTEDTITLE), SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_SUPPORTED), SW_HIDE);
    }

    iState = GetPolicyState((TABLEENTRY *)m_pCurrentPolicy, 1, NULL);

    if (iState == 1)
    {
        CheckRadioButton(hDlg, IDC_NOCONFIG, IDC_DISABLED, IDC_ENABLED);
        fEnabled = TRUE;
    }
    else if (iState == 0)
    {
        CheckRadioButton(hDlg, IDC_NOCONFIG, IDC_DISABLED, IDC_DISABLED);
    }
    else
    {
        CheckRadioButton(hDlg, IDC_NOCONFIG, IDC_DISABLED, IDC_NOCONFIG);
    }

    if (m_pcd->m_bRSOP)
    {
        EnableWindow (GetDlgItem(hDlg, IDC_ENABLED), FALSE);
        EnableWindow (GetDlgItem(hDlg, IDC_DISABLED), FALSE);
        EnableWindow (GetDlgItem(hDlg, IDC_NOCONFIG), FALSE);
    }

    if (m_pCurrentPolicy->pChild) {

        CreateSettingsControls(hDlg, (SETTINGS *) m_pCurrentPolicy->pChild, fEnabled);
        InitializeSettingsControls(hDlg, fEnabled);
    } else {
        ShowScrollBar(GetDlgItem(hDlg,IDC_POLICY_SETTINGS),SB_BOTH, FALSE);
    }

    m_bDirty = FALSE;
    PostMessage (GetParent(hDlg), PSM_UNCHANGED, (WPARAM) hDlg, 0);

    SetPrevNextButtonState(hDlg);
}

HRESULT CPolicySnapIn::UpdateItemWorker (VOID)
{
    HRESULTITEM hItem;

    //
    // Update the display
    //

    if (SUCCEEDED(m_pResult->FindItemByLParam((LPARAM)m_pCurrentPolicy, &hItem)))
    {
        if (m_pcd->m_bShowConfigPoliciesOnly)
            m_pResult->DeleteItem(hItem, 0);
        else
            m_pResult->UpdateItem(hItem);
    }

    return S_OK;
}

HRESULT CPolicySnapIn::MoveFocusWorker (BOOL bPrevious)
{
    HRESULTITEM hItem;
    TABLEENTRY * pTemp;
    HRESULT hr;
    RESULTDATAITEM item;
    INT iIndex = 0;



    //
    // Find the currently selected item's index
    //

    while (TRUE)
    {
        ZeroMemory (&item, sizeof(item));
        item.mask = RDI_INDEX | RDI_PARAM;
        item.nIndex = iIndex;

        hr = m_pResult->GetItem (&item);

        if (FAILED(hr))
        {
            return hr;
        }

        if (item.lParam == (LPARAM) m_pCurrentPolicy)
        {
            break;
        }

        iIndex++;
    }


    //
    // Find the currently selected item's hItem
    //

    hr = m_pResult->FindItemByLParam((LPARAM)m_pCurrentPolicy, &hItem);

    if (FAILED(hr))
    {
        return hr;
    }


    //
    // Remove the focus from the original item
    //

    m_pResult->ModifyItemState(0, hItem, 0, LVIS_FOCUSED | LVIS_SELECTED);
    m_pResult->UpdateItem(hItem);


    //
    // Adjust appropriately
    //

    if (bPrevious)
    {
        if (iIndex > 0)
        {
            iIndex--;
        }
    }
    else
    {
        iIndex++;
    }


    //
    // Get the lParam for the new item
    //

    ZeroMemory (&item, sizeof(item));
    item.mask = RDI_INDEX | RDI_PARAM;
    item.nIndex = iIndex;

    hr = m_pResult->GetItem(&item);

    if (FAILED(hr))
    {
        return hr;
    }


    //
    // Find the hItem for the new item
    //

    hr = m_pResult->FindItemByLParam(item.lParam, &hItem);

    if (FAILED(hr))
    {
        return hr;
    }


    //
    // Save this as the currently selected item
    //

    m_pCurrentPolicy = (POLICY *)item.lParam;



    //
    // Set the focus on the new item
    //

    m_pResult->ModifyItemState(0, hItem, LVIS_FOCUSED | LVIS_SELECTED, 0);
    m_pResult->UpdateItem(hItem);


    return S_OK;
}

HRESULT CPolicySnapIn::MoveFocus (HWND hDlg, BOOL bPrevious)
{

    //
    // Send the move focus message to the hidden window on the main
    // thread so it can use the mmc interfaces
    //

    SendMessage (m_hMsgWindow, WM_MOVEFOCUS, (WPARAM) bPrevious, 0);


    //
    // Update the display
    //

    SendMessage (GetParent(hDlg), PSM_QUERYSIBLINGS, 1000, 0);


    return S_OK;
}


HRESULT CPolicySnapIn::SetPrevNextButtonStateWorker (HWND hDlg)
{

    TABLEENTRY * pTemp;
    HRESULT hr;
    RESULTDATAITEM item;
    INT iIndex = 0;
    BOOL bPrev = FALSE, bNext = FALSE, bFound = FALSE;


    //
    // Loop through the items looking for Policies
    //

    while (TRUE)
    {
        ZeroMemory (&item, sizeof(item));
        item.mask = RDI_INDEX | RDI_PARAM;
        item.nIndex = iIndex;

        hr = m_pResult->GetItem (&item);

        if (FAILED(hr))
        {
            break;
        }

        if (item.lParam == (LPARAM) m_pCurrentPolicy)
        {
            bFound = TRUE;
        }
        else
        {
            pTemp = (TABLEENTRY *) item.lParam;

            if ((pTemp->dwType & ETYPE_POLICY) || (pTemp->dwType & ETYPE_REGITEM))
            {
                if ((m_pcd->m_bShowConfigPoliciesOnly) && (pTemp->dwType & ETYPE_POLICY))
                {
                    INT iState;

                    iState = GetPolicyState(pTemp, 1, NULL);

                    if ((iState == 1) || (iState == 0))
                    {
                        if (bFound)
                        {
                            bNext = TRUE;
                        }
                        else
                        {
                            bPrev = TRUE;
                        }
                    }
                }
                else
                {
                    if (bFound)
                    {
                        bNext = TRUE;
                    }
                    else
                    {
                        bPrev = TRUE;
                    }
                }
            }
        }

        iIndex++;
    }


    if (!bNext && (GetFocus() == GetDlgItem(hDlg,IDC_POLICY_NEXT)))
    {
        SetFocus (GetNextDlgTabItem(hDlg, GetDlgItem(hDlg,IDC_POLICY_NEXT), TRUE));
    }

    EnableWindow (GetDlgItem(hDlg,IDC_POLICY_NEXT), bNext);


    if (!bPrev && (GetFocus() == GetDlgItem(hDlg,IDC_POLICY_PREVIOUS)))
    {
        SetFocus (GetNextDlgTabItem(hDlg, GetDlgItem(hDlg,IDC_POLICY_PREVIOUS), FALSE));
    }

    EnableWindow (GetDlgItem(hDlg,IDC_POLICY_PREVIOUS), bPrev);

    
    return S_OK;
}

HRESULT CPolicySnapIn::SetPrevNextButtonState (HWND hDlg)
{

    //
    // Send the SetPrevNext message to the hidden window on the main
    // thread so it can use the mmc interfaces
    //

    SendMessage (m_hMsgWindow, WM_SETPREVNEXT, (WPARAM) hDlg, 0);

    return S_OK;
}


INT_PTR CALLBACK CPolicySnapIn::PolicyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSETTINGSINFO lpSettingsInfo;

    switch (message)
    {
        case WM_INITDIALOG:

            lpSettingsInfo = (LPSETTINGSINFO) (((LPPROPSHEETPAGE)lParam)->lParam);

            if (!lpSettingsInfo) {
                break;
            }

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpSettingsInfo);

            lpSettingsInfo->pCS->m_hPropDlg = hDlg;

            lpSettingsInfo->pdi->fActive=TRUE;

            lpSettingsInfo->pCS->m_hPolicyIcon = (HICON) LoadImage (g_hInstance,
                                                               MAKEINTRESOURCE(IDI_POLICY2),
                                                               IMAGE_ICON, 16, 16,
                                                               LR_DEFAULTCOLOR);

            lpSettingsInfo->pCS->m_hPreferenceIcon = (HICON) LoadImage (g_hInstance,
                                                               MAKEINTRESOURCE(IDI_POLICY3),
                                                               IMAGE_ICON, 16, 16,
                                                               LR_DEFAULTCOLOR);

            // now that we've stored pointer to POLICYDLGINFO struct in our extra
            // window data, send WM_USER to clip window to tell it to create a
            // child container window (and store the handle in our POLICYDLGINFO)
            SendDlgItemMessage(hDlg,IDC_POLICY_SETTINGS,WM_USER,0,0L);

            lpSettingsInfo->pCS->RefreshSettingsControls(hDlg);

            lpSettingsInfo->pCS->SetKeyboardHook(hDlg);

            break;

        case WM_MYCHANGENOTIFY:
            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (lpSettingsInfo) {
                lpSettingsInfo->pCS->m_bDirty = TRUE;
                SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
            }
            break;

        case PSM_QUERYSIBLINGS:
            if (wParam == 1000) {
                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpSettingsInfo) {
                    break;
                }

                lpSettingsInfo->pCS->RefreshSettingsControls(hDlg);

                SendMessage (GetParent(hDlg), PSM_SETTITLE, PSH_PROPTITLE,
                             (LPARAM)GETNAMEPTR(lpSettingsInfo->pCS->m_pCurrentPolicy));
            }
            break;

        case WM_COMMAND:

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpSettingsInfo) {
                break;
            }


            if ((LOWORD (wParam) == IDC_NOCONFIG) && (HIWORD (wParam) == BN_CLICKED))
            {
                lpSettingsInfo->pCS->InitializeSettingsControls(hDlg, FALSE);
                PostMessage (hDlg, WM_MYCHANGENOTIFY, 0, 0);
            }

            if ((LOWORD (wParam) == IDC_ENABLED) && (HIWORD (wParam) == BN_CLICKED))
            {
                lpSettingsInfo->pCS->InitializeSettingsControls(hDlg, TRUE);
                PostMessage (hDlg, WM_MYCHANGENOTIFY, 0, 0);
            }

            if ((LOWORD (wParam) == IDC_DISABLED) && (HIWORD (wParam) == BN_CLICKED))
            {
                lpSettingsInfo->pCS->InitializeSettingsControls(hDlg, FALSE);
                PostMessage (hDlg, WM_MYCHANGENOTIFY, 0, 0);
            }

            if (LOWORD(wParam) == IDC_POLICY_NEXT)
            {
                if (SUCCEEDED(lpSettingsInfo->pCS->SaveSettings(hDlg)))
                {
                    lpSettingsInfo->pCS->MoveFocus (hDlg, FALSE);
                }
            }

            if (LOWORD(wParam) == IDC_POLICY_PREVIOUS)
            {
                if (SUCCEEDED(lpSettingsInfo->pCS->SaveSettings(hDlg)))
                {
                    lpSettingsInfo->pCS->MoveFocus (hDlg, TRUE);
                }
            }

            break;

        case WM_NOTIFY:

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpSettingsInfo) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                    {
                    LPPSHNOTIFY lpNotify = (LPPSHNOTIFY) lParam;

                    if (FAILED(lpSettingsInfo->pCS->SaveSettings(hDlg)))
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    if (lpNotify->lParam)
                    {
                        lpSettingsInfo->pCS->RemoveKeyboardHook();
                        lpSettingsInfo->pCS->m_hPropDlg = NULL;

                        lpSettingsInfo->pCS->FreeSettingsControls(hDlg);

                        DestroyIcon(lpSettingsInfo->pCS->m_hPolicyIcon);
                        lpSettingsInfo->pCS->m_hPolicyIcon = NULL;
                        DestroyIcon(lpSettingsInfo->pCS->m_hPreferenceIcon);
                        lpSettingsInfo->pCS->m_hPreferenceIcon = NULL;

                        LocalFree (lpSettingsInfo->pdi->pControlTable);
                        LocalFree (lpSettingsInfo->pdi);
                        LocalFree (lpSettingsInfo);
                        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) NULL);
                    }

                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
                    }

                case PSN_RESET:
                    lpSettingsInfo->pCS->RemoveKeyboardHook();
                    lpSettingsInfo->pCS->m_hPropDlg = NULL;
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPDWORD) aPolicyHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPDWORD) aPolicyHelpIds);
            return TRUE;
    }

    return FALSE;
}

INT_PTR CALLBACK CPolicySnapIn::PolicyHelpDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSETTINGSINFO lpSettingsInfo;

    switch (message)
    {
        case WM_INITDIALOG:

            lpSettingsInfo = (LPSETTINGSINFO) (((LPPROPSHEETPAGE)lParam)->lParam);

            if (!lpSettingsInfo) {
                break;
            }

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpSettingsInfo);

            wParam = 1000;

            // fall through...

        case PSM_QUERYSIBLINGS:
        {
            CPolicySnapIn * pCS;
            LPTSTR lpHelpText;

            if (wParam == 1000)
            {
                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpSettingsInfo) {
                    break;
                }


                pCS = lpSettingsInfo->pCS;
                SetDlgItemText (hDlg, IDC_POLICY_TITLE, GETNAMEPTR(pCS->m_pCurrentPolicy));

                if (pCS->m_pCurrentPolicy->uOffsetHelp)
                {
                    lpHelpText = (LPTSTR) ((BYTE *) pCS->m_pCurrentPolicy + pCS->m_pCurrentPolicy->uOffsetHelp);
                    SetDlgItemText (hDlg, IDC_POLICY_HELP, lpHelpText);
                }
                else
                {
                    SetDlgItemText (hDlg, IDC_POLICY_HELP, TEXT(""));
                }
                
                pCS->SetPrevNextButtonState(hDlg);
            }

            PostMessage(hDlg, WM_MYREFRESH, 0, 0);
            break;
        }

        case WM_MYREFRESH:
        {
            CPolicySnapIn * pCS;
            BOOL    bAlone;

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);
            pCS = lpSettingsInfo->pCS;

            SendMessage(GetDlgItem(hDlg, IDC_POLICY_HELP), EM_SETSEL, -1, 0);

            bAlone = !(((pCS->m_pCurrentPolicy)->pNext) ||
                        ((pCS->m_pCurrentPolicy)->pPrev) );
            
            if (bAlone) {
                SetFocus(GetDlgItem(GetParent(hDlg), IDOK));
            }
            break;
        }

        case WM_COMMAND:

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpSettingsInfo) {
                break;
            }

            if (LOWORD(wParam) == IDC_POLICY_NEXT)
            {
                lpSettingsInfo->pCS->MoveFocus (hDlg, FALSE);
            }

            if (LOWORD(wParam) == IDC_POLICY_PREVIOUS)
            {
                lpSettingsInfo->pCS->MoveFocus (hDlg, TRUE);
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                SendMessage(GetParent(hDlg), message, wParam, lParam);
            }

            break;


        case WM_NOTIFY:

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
                case PSN_SETACTIVE:
                    PostMessage(hDlg, WM_MYREFRESH, 0, 0);
                break;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPDWORD) aExplainHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPDWORD) aExplainHelpIds);
            return TRUE;
    }

    return FALSE;
}

INT_PTR CALLBACK CPolicySnapIn::PolicyPrecedenceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSETTINGSINFO lpSettingsInfo;

    switch (message)
    {
        case WM_INITDIALOG:
            {
            RECT rc;
            TCHAR szHeaderName[50];
            INT iTotal = 0, iCurrent;
            HWND hLV = GetDlgItem (hDlg, IDC_POLICY_PRECEDENCE);
            LV_COLUMN col;

            lpSettingsInfo = (LPSETTINGSINFO) (((LPPROPSHEETPAGE)lParam)->lParam);

            if (!lpSettingsInfo) {
                break;
            }

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpSettingsInfo);


            //
            // Add the columns
            //

            GetClientRect (hLV, &rc);
            LoadString(g_hInstance, IDS_GPONAME, szHeaderName, ARRAYSIZE(szHeaderName));
            col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
            col.fmt = LVCFMT_LEFT;
            iCurrent = (int)(rc.right * .70);
            iTotal += iCurrent;
            col.cx = iCurrent;
            col.pszText = szHeaderName;
            col.iSubItem = 0;

            ListView_InsertColumn (hLV, 0, &col);

            LoadString(g_hInstance, IDS_SETTING, szHeaderName, ARRAYSIZE(szHeaderName));
            col.iSubItem = 1;
            col.cx = rc.right - iTotal;
            col.fmt = LVCFMT_CENTER;
            ListView_InsertColumn (hLV, 1, &col);


            //
            // Set extended LV styles
            //

            SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                        LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


            }

            wParam = 1000;

            // fall through...

        case PSM_QUERYSIBLINGS:
        {
            CPolicySnapIn * pCS;
            INT iState;
            LPTSTR lpGPOName;
            UINT uiPrecedence = 1;
            LVITEM item;
            INT iItem, iIndex = 0;
            HWND hLV = GetDlgItem (hDlg, IDC_POLICY_PRECEDENCE);

            if (wParam == 1000)
            {
                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpSettingsInfo) {
                    break;
                }


                pCS = lpSettingsInfo->pCS;
                SetDlgItemText (hDlg, IDC_POLICY_TITLE, GETNAMEPTR(pCS->m_pCurrentPolicy));

                SendMessage (hLV, LVM_DELETEALLITEMS, 0, 0);

                if (pCS->m_pCurrentPolicy->dwType & ETYPE_REGITEM)
                {
                    LPRSOPREGITEM pItem = ((REGITEM*)pCS->m_pCurrentPolicy)->lpItem;
                    LPRSOPREGITEM lpEnum;
                    TCHAR szValueStr[MAX_PATH];


                    while (TRUE)
                    {
                        lpEnum = NULL;

                        if (pCS->m_pcd->FindRSOPRegistryEntry((HKEY) LongToHandle(uiPrecedence), pItem->lpKeyName,
                                                  pItem->lpValueName, &lpEnum) != ERROR_SUCCESS)
                        {
                            break;
                        }


                        //
                        // Add the GPO Name
                        //

                        item.mask = LVIF_TEXT | LVIF_STATE;
                        item.iItem = iIndex;
                        item.iSubItem = 0;
                        item.state = 0;
                        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                        item.pszText = lpEnum->lpGPOName;

                        iItem = (INT)SendMessage (hLV, LVM_INSERTITEM, 0, (LPARAM) &item);


                        if (iItem != -1)
                        {
                            szValueStr[0] = TEXT('\0');

                            if (pItem->dwType == REG_DWORD)
                            {
                                wsprintf (szValueStr, TEXT("%d"), *((LPDWORD)pItem->lpData));
                            }

                            else if (pItem->dwType == REG_SZ)
                            {
                                lstrcpyn (szValueStr, (LPTSTR)pItem->lpData, ARRAYSIZE(szValueStr));
                            }

                            else if (pItem->dwType == REG_EXPAND_SZ)
                            {
                                lstrcpyn (szValueStr, (LPTSTR)pItem->lpData, ARRAYSIZE(szValueStr));
                            }

                            else if (pItem->dwType == REG_BINARY)
                            {
                                LoadString(g_hInstance, IDS_BINARYDATA, szValueStr, ARRAYSIZE(szValueStr));
                            }

                            else
                            {
                                LoadString(g_hInstance, IDS_UNKNOWNDATA, szValueStr, ARRAYSIZE(szValueStr));
                            }


                            //
                            // Add the state
                            //

                            item.mask = LVIF_TEXT;
                            item.iItem = iItem;
                            item.iSubItem = 1;
                            item.pszText = szValueStr;

                            SendMessage (hLV, LVM_SETITEMTEXT, iItem, (LPARAM) &item);
                        }

                        uiPrecedence++;
                        iIndex++;
                    }

                }
                else
                {
                    while (TRUE)
                    {
                        lpGPOName = NULL; // just in case we have missed a case

                        iState = pCS->GetPolicyState ((TABLEENTRY *)pCS->m_pCurrentPolicy, uiPrecedence, &lpGPOName);

                        if (iState == -1)
                        {
                            uiPrecedence++;
                            iState = pCS->GetPolicyState ((TABLEENTRY *)pCS->m_pCurrentPolicy, uiPrecedence, &lpGPOName);

                            if (iState == -1)
                            {
                                break;
                            }
                        }


                        //
                        // Add the GPO Name
                        //

                        item.mask = LVIF_TEXT | LVIF_STATE;
                        item.iItem = iIndex;
                        item.iSubItem = 0;
                        item.state = 0;
                        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                        item.pszText = lpGPOName ? lpGPOName : TEXT("");

                        iItem = (INT)SendMessage (hLV, LVM_INSERTITEM, 0, (LPARAM) &item);


                        if (iItem != -1)
                        {

                            //
                            // Add the state
                            //

                            item.mask = LVIF_TEXT;
                            item.iItem = iItem;
                            item.iSubItem = 1;
                            item.pszText = (iState == 1) ? pCS->m_pEnabled : pCS->m_pDisabled;

                            SendMessage (hLV, LVM_SETITEMTEXT, iItem, (LPARAM) &item);
                        }

                        uiPrecedence++;
                        iIndex++;
                    }
                }

                //
                // Select the first item
                //

                item.mask = LVIF_STATE;
                item.iItem = 0;
                item.iSubItem = 0;
                item.state = LVIS_SELECTED | LVIS_FOCUSED;
                item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);

                pCS->SetPrevNextButtonState(hDlg);

            }

            break;
        }

        case WM_COMMAND:

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpSettingsInfo) {
                break;
            }

            if (LOWORD(wParam) == IDC_POLICY_NEXT)
            {
                lpSettingsInfo->pCS->MoveFocus (hDlg, FALSE);
            }

            if (LOWORD(wParam) == IDC_POLICY_PREVIOUS)
            {
                lpSettingsInfo->pCS->MoveFocus (hDlg, TRUE);
            }

            break;


        case WM_NOTIFY:

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, RSOP_HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPDWORD) aPrecedenceHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, RSOP_HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPDWORD) aPrecedenceHelpIds);
            return TRUE;
    }

    return FALSE;
}


LRESULT CPolicySnapIn::CallNextHook(int nCode, WPARAM wParam,LPARAM lParam)
{ 
    if (m_hKbdHook)
    {
        return CallNextHookEx(
            m_hKbdHook,
            nCode, 
            wParam, 
            lParam);
    }
    else
    {    
        DebugMsg((DM_WARNING, L"CPolicySnapIn::CallNextHook m_hKbdHook is Null"));
        return 0;
    }
}

HWND g_hDlgActive = NULL;


LRESULT CALLBACK CPolicySnapIn::KeyboardHookProc(int nCode, WPARAM wParam,LPARAM lParam)
{
    LPSETTINGSINFO lpSettingsInfo;

    lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(g_hDlgActive, DWLP_USER);

    if (!lpSettingsInfo)
    {
        DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc:GetWindowLongPtr returned NULL"));
        return 0;
    }


    if ( nCode < 0)
    {
        if (lpSettingsInfo->pCS) 
        {
            return lpSettingsInfo->pCS->CallNextHook(nCode, 
                                                    wParam, 
                                                    lParam); 
        }
        else
        {
            DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc NULL CPolicySnapIn Pointer"));
            return 0;
        }
    }

    if (wParam == VK_TAB && !(lParam & 0x80000000)) {       // tab key depressed
        BOOL fShift = (GetKeyState(VK_SHIFT) & 0x80000000);
        HWND hwndFocus = GetFocus();
        HWND hChild;
        POLICYDLGINFO * pdi;
        int iIndex;
        int iDelta;

        pdi = lpSettingsInfo->pdi;

        if (!pdi)
        {    
            if (lpSettingsInfo->pCS) 
            {
                return lpSettingsInfo->pCS->CallNextHook(nCode, 
                                                      wParam, 
                                                      lParam); 
            }
            else
            {
                DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc NULL CPolicySnapIn Pointer"));
                return 0;
            }
        }

        // see if the focus control is one of the setting controls
        for (iIndex=0;iIndex<(int)pdi->nControls;iIndex++) {

            if (pdi->pControlTable[iIndex].hwnd == hwndFocus) {
                goto BreakOut;
            }

            hChild = GetWindow (pdi->pControlTable[iIndex].hwnd, GW_CHILD);

            while (hChild) {

                if (hChild == hwndFocus) {
                    goto BreakOut;
                }

                hChild = GetWindow (hChild, GW_HWNDNEXT);
            }
        }

        BreakOut:
            if (iIndex == (int) pdi->nControls)
            {
                if (lpSettingsInfo->pCS) 
                {
                    return lpSettingsInfo->pCS->CallNextHook(nCode, 
                                                            wParam, 
                                                            lParam); 
                }
                else   // no, we don't care
                {
                    DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc NULL CPolicySnapIn Pointer"));
                    return 0;
                }
            }
            iDelta = (fShift ? -1 : 1);

            // from the current setting control, scan forwards or backwards
            // (depending if on shift state, this can be TAB or shift-TAB)
            // to find the next control to give focus to
            for (iIndex += iDelta;iIndex>=0 && iIndex<(int) pdi->nControls;
                 iIndex += iDelta) {
                if (pdi->pControlTable[iIndex].uDataIndex !=
                    NO_DATA_INDEX &&
                    IsWindowEnabled(pdi->pControlTable[iIndex].hwnd)) {

                    // found it, set the focus on that control and return 1
                    // to eat the keystroke
                    SetFocus(pdi->pControlTable[iIndex].hwnd);
                    lpSettingsInfo->pCS->EnsureSettingControlVisible(g_hDlgActive,
                                                                     pdi->pControlTable[iIndex].hwnd);
                    return 1;
                }
            }

            // at first or last control in settings table, let dlg code
            // handle it and give focus to next (or previous) control in dialog
    }
    else
    {
        if (lpSettingsInfo->pCS) 
        {
            return lpSettingsInfo->pCS->CallNextHook(nCode, 
                                                    wParam, 
                                                    lParam); 
        }
        else
        {
            DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc NULL CPolicySnapIn Pointer"));
            return 0;
        }
    }    

    return 0;
}


VOID CPolicySnapIn::SetKeyboardHook(HWND hDlg)
{
        // hook the keyboard to trap TABs.  If this fails for some reason,
        // fail silently and go on, not critical that tabs work correctly
        // (unless you have no mouse :)  )

        if (m_hKbdHook = SetWindowsHookEx(WH_KEYBOARD,
                                          KeyboardHookProc,
                                          g_hInstance,
                                          GetCurrentThreadId())) 
        {
            g_hDlgActive = hDlg;
        }
}


VOID CPolicySnapIn::RemoveKeyboardHook(VOID)
{
        if (m_hKbdHook) {
            UnhookWindowsHookEx(m_hKbdHook);
            g_hDlgActive = NULL;
            m_hKbdHook = NULL;
        }
}

INT CPolicySnapIn::GetPolicyState (TABLEENTRY *pTableEntry, UINT uiPrecedence, LPTSTR *lpGPOName)
{
    DWORD dwData=0;
    UINT uRet;
    TCHAR * pszValueName;
    TCHAR * pszKeyName;
    DWORD dwFoundSettings=0, dwTemp;
    BOOL fFound=FALSE,fCustomOn=FALSE, fCustomOff=FALSE;
    HKEY hKeyRoot;
    INT  iRetVal = -1;
    TABLEENTRY *pChild;


    if (m_pcd->m_bRSOP)
    {
        hKeyRoot = (HKEY) LongToHandle(uiPrecedence);
    }
    else
    {

        if (m_pcd->m_pGPTInformation->GetRegistryKey(
                     (m_pcd->m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                          &hKeyRoot) != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetPolicyState: Failed to get registry key handle.")));
            return -1;
        }
    }


    //
    // Get the name of the value to read, if any
    //

    if (((POLICY *)pTableEntry)->uOffsetValueName)
    {
        pszKeyName =   GETKEYNAMEPTR(pTableEntry);
        pszValueName = GETVALUENAMEPTR(((POLICY *)pTableEntry));


        //
        // First look for custom on/off values
        //

        if (((POLICY *)pTableEntry)->uOffsetValue_On)
        {
            fCustomOn = TRUE;
            if (CompareCustomValue(hKeyRoot,pszKeyName,pszValueName,
                                   (STATEVALUE *) ((BYTE *) pTableEntry + ((POLICY *)
                                   pTableEntry)->uOffsetValue_On),&dwFoundSettings,lpGPOName)) {
                dwData = 1;
                fFound =TRUE;
            }
        }

        if (!fFound && ((POLICY *)pTableEntry)->uOffsetValue_Off)
        {
            fCustomOff = TRUE;
            if (CompareCustomValue(hKeyRoot,pszKeyName,pszValueName,
                                   (STATEVALUE *) ((BYTE *) pTableEntry + ((POLICY *)
                                   pTableEntry)->uOffsetValue_Off),&dwFoundSettings,lpGPOName)) {
                dwData = 0;
                fFound = TRUE;
            }
        }

        //
        // Look for standard values if custom values have not been specified
        //

        if (!fCustomOn && !fCustomOff && ReadStandardValue(hKeyRoot, pszKeyName, pszValueName,
                                        pTableEntry, &dwData, &dwFoundSettings, lpGPOName))
        {
            fFound = TRUE;
        }


        if (fFound)
        {
            if (dwData)
                iRetVal = 1;
            else
                iRetVal = 0;
        }
    }
    else if ((((POLICY *)pTableEntry)->uOffsetActionList_On) &&
             CheckActionList((POLICY *)pTableEntry, hKeyRoot, TRUE, lpGPOName))
    {
        iRetVal = 1;
    }
    else if ((((POLICY *)pTableEntry)->uOffsetActionList_Off) &&
             CheckActionList((POLICY *)pTableEntry, hKeyRoot, FALSE, lpGPOName))
    {
        iRetVal = 0;
    }
    else
    {
        BOOL bDisabled = TRUE;


        //
        // Process settings underneath this policy (if any)
        //

        if (pTableEntry->pChild) {

            dwFoundSettings = 0;
            pChild = pTableEntry->pChild;

            while (pChild) {

                dwTemp = 0;
                LoadSettings(pChild, hKeyRoot, &dwTemp, lpGPOName);

                dwFoundSettings |= dwTemp;

                if ((dwTemp & FS_PRESENT) && (!(dwTemp & FS_DISABLED))) {
                    bDisabled = FALSE;
                }

                pChild = pChild->pNext;
            }

            if (dwFoundSettings) {
                if (bDisabled)
                    iRetVal = 0;
                else
                    iRetVal = 1;
            }


        }
    }

    if (!m_pcd->m_bRSOP)
    {
        RegCloseKey (hKeyRoot);
    }

    return iRetVal;
}

BOOL CPolicySnapIn::CheckActionList (POLICY * pPolicy, HKEY hKeyRoot, BOOL bActionListOn, LPTSTR *lpGPOName)
{
    UINT uIndex;
    ACTIONLIST * pActionList;
    ACTION * pAction;
    TCHAR szValue[MAXSTRLEN];
    DWORD dwValue;
    TCHAR szNewValueName[MAX_PATH+1];
    TCHAR * pszKeyName;
    TCHAR * pszValueName;
    TCHAR * pszValue;


    //
    // Get the correct action list
    //

    if (bActionListOn)
    {
        pActionList = (ACTIONLIST *)(((LPBYTE)pPolicy) + pPolicy->uOffsetActionList_On);
    }
    else
    {
        pActionList = (ACTIONLIST *)(((LPBYTE)pPolicy) + pPolicy->uOffsetActionList_Off);
    }


    //
    // Loop through each of the entries to see if they match
    //

    for (uIndex = 0; uIndex < pActionList->nActionItems; uIndex++)
    {

        if (uIndex == 0)
        {
            pAction = &pActionList->Action[0];
        }
        else
        {
            pAction = (ACTION *)(((LPBYTE)pActionList) + pAction->uOffsetNextAction);
        }


        //
        // Get the value and keynames
        //

        pszValueName = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetValueName);

        if (pAction->uOffsetKeyName)
        {
            pszKeyName = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetKeyName);
        }
        else
        {
            pszKeyName = (TCHAR *)(((LPBYTE)pPolicy) + pPolicy->uOffsetKeyName);
        }


        //
        // Add prefixes if appropriate
        //

        PrependValueName(pszValueName, pAction->dwFlags,
                         szNewValueName, ARRAYSIZE(szNewValueName));

        if (pAction->dwFlags & VF_ISNUMERIC)
        {
            if (ReadRegistryDWordValue(hKeyRoot, pszKeyName,
                                       szNewValueName, &dwValue, lpGPOName) != ERROR_SUCCESS)
            {
                return FALSE;
            }

            if (dwValue != pAction->dwValue)
            {
                return FALSE;
            }
        }
        else if (pAction->dwFlags & VF_DELETE)
        {
            //
            // See if this is a value that's marked for deletion
            // (valuename is prepended with "**del."
            //

            if ((ReadRegistryStringValue(hKeyRoot, pszKeyName, szNewValueName,
                                         szValue,ARRAYSIZE(szValue),lpGPOName)) != ERROR_SUCCESS) {
                 return FALSE;
            }
        }
        else
        {
            if (ReadRegistryStringValue(hKeyRoot, pszKeyName, szNewValueName,
                                        szValue, ARRAYSIZE(szValue),lpGPOName) != ERROR_SUCCESS)
            {
                return FALSE;
            }

            pszValue = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetValue);

            if (lstrcmpi(szValue,pszValue) != 0)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

UINT CPolicySnapIn::LoadSettings(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
                                 DWORD * pdwFound, LPTSTR *lpGPOName)
{
    UINT uRet = ERROR_SUCCESS;
    TCHAR * pszValueName = NULL;
    TCHAR * pszKeyName = NULL;
    DWORD dwData=0,dwFlags,dwFoundSettings=0;
    TCHAR szData[MAXSTRLEN];
    BOOL fCustomOn=FALSE,fCustomOff=FALSE,fFound=FALSE;
    BYTE * pObjectData = GETOBJECTDATAPTR(((SETTINGS *)pTableEntry));
    TCHAR szNewValueName[MAX_PATH+1];

    // get the name of the key to read
    if (((SETTINGS *) pTableEntry)->uOffsetKeyName) {
            pszKeyName = GETKEYNAMEPTR(((SETTINGS *) pTableEntry));
    }
    else return ERROR_NOT_ENOUGH_MEMORY;

    // get the name of the value to read
    if (((SETTINGS *) pTableEntry)->uOffsetValueName) {
            pszValueName = GETVALUENAMEPTR(((SETTINGS *) pTableEntry));
    }
    else return ERROR_NOT_ENOUGH_MEMORY;

    switch (pTableEntry->dwType & STYPE_MASK) {

            case STYPE_EDITTEXT:
            case STYPE_COMBOBOX:

                    dwFlags = ( (SETTINGS *) pTableEntry)->dwFlags;

                    // add prefixes if appropriate
                    PrependValueName(pszValueName,dwFlags,
                            szNewValueName,ARRAYSIZE(szNewValueName));

                    if ((uRet = ReadRegistryStringValue(hkeyRoot,pszKeyName,
                            szNewValueName,szData,ARRAYSIZE(szData),lpGPOName)) == ERROR_SUCCESS) {

                            // set flag that we found setting in registry/policy file
                            if (pdwFound)
                                    *pdwFound |= FS_PRESENT;
                    } else if (!(dwFlags & VF_DELETE)) {

                            // see if this key is marked as deleted
                            PrependValueName(pszValueName,VF_DELETE,
                                    szNewValueName,ARRAYSIZE(szNewValueName));
                            if ((uRet = ReadRegistryStringValue(hkeyRoot,pszKeyName,
                                    szNewValueName,szData,ARRAYSIZE(szData) * sizeof(TCHAR),lpGPOName)) == ERROR_SUCCESS) {

                                    // set flag that we found setting marked as deleted in
                                    // policy file
                                    if (pdwFound)
                                            *pdwFound |= FS_DELETED;
                            }
                    }

                    return ERROR_SUCCESS;
                    break;

            case STYPE_CHECKBOX:

                    if (!pObjectData) {
                        return ERROR_INVALID_PARAMETER;
                    }

                    // first look for custom on/off values
                    if (((CHECKBOXINFO *) pObjectData)->uOffsetValue_On) {
                            fCustomOn = TRUE;
                            if (CompareCustomValue(hkeyRoot,pszKeyName,pszValueName,
                                    (STATEVALUE *) ((BYTE *) pTableEntry + ((CHECKBOXINFO *)
                                    pObjectData)->uOffsetValue_On),&dwFoundSettings, lpGPOName)) {
                                            dwData = 1;
                                            fFound = TRUE;
                            }
                    }

                    if (!fFound && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_Off) {
                            fCustomOff = TRUE;
                            if (CompareCustomValue(hkeyRoot,pszKeyName,pszValueName,
                                    (STATEVALUE *) ((BYTE *) pTableEntry + ((CHECKBOXINFO *)
                                    pObjectData)->uOffsetValue_Off),&dwFoundSettings, lpGPOName)) {
                                            dwData = 0;
                                            fFound = TRUE;
                            }
                    }

                    // look for standard values if custom values have not been specified
                    if (!fFound &&
                            ReadStandardValue(hkeyRoot,pszKeyName,pszValueName,
                            pTableEntry,&dwData,&dwFoundSettings, lpGPOName)) {
                            fFound = TRUE;
                    }

                    if (fFound) {
                            // set flag that we found setting in registry
                            if (pdwFound) {
                                *pdwFound |= dwFoundSettings;

                                if (dwData == 0) {
                                    *pdwFound |= FS_DISABLED;
                                }
                            }
                    }

                    return ERROR_SUCCESS;
                    break;

            case STYPE_NUMERIC:

                    if (ReadStandardValue(hkeyRoot,pszKeyName,pszValueName,
                            pTableEntry,&dwData,&dwFoundSettings,lpGPOName)) {

                            // set flag that we found setting in registry
                            if (pdwFound)
                                    *pdwFound |= dwFoundSettings;
                    }
                    break;

            case STYPE_DROPDOWNLIST:

                    if (ReadCustomValue(hkeyRoot,pszKeyName,pszValueName,
                            szData,ARRAYSIZE(szData),&dwData,&dwFlags, lpGPOName)) {
                            BOOL fMatch = FALSE;

                            if (dwFlags & VF_DELETE) {
                                    // set flag that we found setting marked as deleted
                                    // in policy file
                                    if (pdwFound)
                                            *pdwFound |= FS_DELETED;
                                    return ERROR_SUCCESS;
                            }

                            // walk the list of DROPDOWNINFO structs (one for each state),
                            // and see if the value we found matches the value for the state

                            if ( ((SETTINGS *) pTableEntry)->uOffsetObjectData) {
                                    DROPDOWNINFO * pddi = (DROPDOWNINFO *)
                                            GETOBJECTDATAPTR( ((SETTINGS *) pTableEntry));
                                    UINT nIndex = 0;

                                    do {
                                            if (dwFlags == pddi->dwFlags) {

                                                    if (pddi->dwFlags & VF_ISNUMERIC) {
                                                            if (dwData == pddi->dwValue)
                                                                    fMatch = TRUE;
                                                    } else if (!pddi->dwFlags) {
                                                            if (!lstrcmpi(szData,(TCHAR *)((BYTE *)pTableEntry +
                                                                    pddi->uOffsetValue)))
                                                                    fMatch = TRUE;
                                                    }
                                            }

                                            if (!pddi->uOffsetNextDropdowninfo || fMatch)
                                                    break;

                                            pddi = (DROPDOWNINFO *) ( (BYTE *) pTableEntry +
                                                    pddi->uOffsetNextDropdowninfo);
                                            nIndex++;

                                    } while (!fMatch);

                                    if (fMatch) {
                                            // set flag that we found setting in registry
                                            if (pdwFound)
                                                    *pdwFound |= FS_PRESENT;
                                    }
                            }
                    }

                    break;

            case STYPE_LISTBOX:

                    return LoadListboxData(pTableEntry,hkeyRoot,
                            pszKeyName,pdwFound, NULL, lpGPOName);

                    break;

    }
    return ERROR_SUCCESS;
}


UINT CPolicySnapIn::LoadListboxData(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
        TCHAR * pszCurrentKeyName,DWORD * pdwFound, HGLOBAL * phGlobal, LPTSTR *lpGPOName)
{
        HKEY hKey;
        UINT nIndex=0,nLen;
        TCHAR szValueName[MAX_PATH+1],szValueData[MAX_PATH+1];
        DWORD cbValueName,cbValueData;
        DWORD dwType,dwAlloc=1024 * sizeof(TCHAR),dwUsed=0;
        HGLOBAL hBuf;
        TCHAR * pBuf;
        SETTINGS * pSettings = (SETTINGS *) pTableEntry;
        LISTBOXINFO * pListboxInfo = (LISTBOXINFO *)
                GETOBJECTDATAPTR(pSettings);
        BOOL fFoundValues=FALSE,fFoundDelvals=FALSE;
        UINT uRet=ERROR_SUCCESS;
        LPRSOPREGITEM lpItem = NULL;
        BOOL bMultiple;

        if (m_pcd->m_bRSOP)
        {
            //
            // If this is an additive listbox, we want to pick up entries from
            // any GPO, not just the GPOs of precedence 1, so set hkeyRoot to 0
            //

            if ((pSettings->dwFlags & DF_ADDITIVE) && (hkeyRoot == (HKEY) 1))
            {
                hkeyRoot = (HKEY) 0;
            }
        }
        else
        {
            if (RegOpenKeyEx(hkeyRoot,pszCurrentKeyName,0,KEY_READ,&hKey) != ERROR_SUCCESS)
                    return ERROR_SUCCESS;   // nothing to do
        }

        // allocate a temp buffer to read entries into
        if (!(hBuf = GlobalAlloc(GHND,dwAlloc)) ||
                !(pBuf = (TCHAR *) GlobalLock(hBuf))) {
                if (hBuf)
                        GlobalFree(hBuf);
                return ERROR_NOT_ENOUGH_MEMORY;
        }

        while (TRUE) {
                cbValueName=ARRAYSIZE(szValueName);
                cbValueData=ARRAYSIZE(szValueData) * sizeof(TCHAR);

                if (m_pcd->m_bRSOP)
                {
                    uRet = m_pcd->EnumRSOPRegistryValues(hkeyRoot, pszCurrentKeyName,
                                                         szValueName, cbValueName,
                                                         &lpItem);

                    if (uRet == ERROR_SUCCESS)
                    {
                        //
                        // Check if the GPO name is changing
                        //

                        bMultiple = FALSE;

                        if (lpGPOName && *lpGPOName && lpItem->lpGPOName && (hkeyRoot == 0))
                        {
                            if (lstrcmpi(*lpGPOName, lpItem->lpGPOName))
                            {
                                bMultiple = TRUE;
                            }
                        }

                        uRet = m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszCurrentKeyName,
                                                            szValueName, (LPBYTE)szValueData,
                                                            cbValueData, &dwType, lpGPOName,
                                                            lpItem);

                        if (bMultiple)
                        {
                            *lpGPOName = m_pMultipleGPOs;
                        }
                    }
                }
                else
                {
                    uRet=RegEnumValue(hKey,nIndex,szValueName,&cbValueName,NULL,
                            &dwType,(LPBYTE)szValueData,&cbValueData);
                }

                // stop if we're out of items
                if (uRet != ERROR_SUCCESS && uRet != ERROR_MORE_DATA)
                        break;
                nIndex++;

                if (szValueName[0] == TEXT('\0')) {
                        // if the value is empty, it is the key creation code
                        continue;
                }

                // if valuename prefixed with '**', it's a control code, ignore it
                if (szValueName[0] == TEXT('*') && szValueName[1] == TEXT('*')) {
                        // if we found **delvals., then some sort of listbox stuff
                        // is going on, remember that we found this code
                        if (!lstrcmpi(szValueName,szDELVALS))
                                fFoundDelvals = TRUE;
                        continue;
                }

                // only process this item if enum was successful
                // (so we'll skip items with weird errors like ERROR_MORE_DATA and
                // but keep going with the enum)
                if (uRet == ERROR_SUCCESS) {
                        TCHAR * pszData;

                        // if there's no value name prefix scheme specified (e.g.
                        // value names are "foo1", "foo2", etc), and the explicit valuename
                        // flag isn't set where we remember the value name as well as
                        // the data for every value, then we need the value name to
                        // be the same as the value data ("thing.exe=thing.exe").
                        if (!(pSettings->dwFlags & DF_EXPLICITVALNAME) &&
                                !(pListboxInfo->uOffsetPrefix) && !(pListboxInfo->uOffsetValue)) {
                                if (dwType != (DWORD)((pSettings->dwFlags & DF_EXPANDABLETEXT) ? REG_EXPAND_SZ : REG_SZ) ||
                                    lstrcmpi(szValueName,szValueData))
                                        continue;       // skip this value if val name != val data
                        }


                        //
                        // If there is a valueprefix, only pick up values that start
                        // with that prefix
                        //

                        if (pListboxInfo->uOffsetPrefix) {
                            LPTSTR lpPrefix = (LPTSTR)((LPBYTE)pTableEntry + pListboxInfo->uOffsetPrefix);
                            INT iPrefixLen = lstrlen(lpPrefix);

                            if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                              lpPrefix, iPrefixLen, szValueName,
                                              iPrefixLen) != CSTR_EQUAL) {
                                continue;
                            }
                        }


                        // if explicit valuenames used, then copy the value name into
                        // buffer
                        if (pSettings->dwFlags & DF_EXPLICITVALNAME) {
                                nLen = lstrlen(szValueName) + 1;
                                if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwUsed+nLen+4) * sizeof(TCHAR),&dwAlloc)))
                                        return ERROR_NOT_ENOUGH_MEMORY;
                                lstrcpy(pBuf+dwUsed,szValueName);
                                dwUsed += nLen;
                        }


                        // for default listbox type, value data is the actual "data"
                        // and value name either will be the same as the data or
                        // some prefix + "1", "2", etc.  If there's a data value to
                        // write for each entry, then the "data" is the value name
                        // (e.g. "Larry = foo", "Dave = foo"), etc.  If explicit value names
                        // are turned on, then both the value name and data are stored
                        // and editable

                        // copy value data into buffer
                        if (pListboxInfo->uOffsetValue) {
                                // data value set, use value name for data
                                pszData = szValueName;
                        } else pszData = szValueData;

                        nLen = lstrlen(pszData) + 1;
                        if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwUsed+nLen+4) * sizeof(TCHAR),&dwAlloc)))
                                return ERROR_NOT_ENOUGH_MEMORY;
                        lstrcpy(pBuf+dwUsed,pszData);
                        dwUsed += nLen;
                        fFoundValues=TRUE;

                        //
                        // Add the GPO name if this is RSOP mode
                        //

                        if (m_pcd->m_bRSOP)
                        {
                            nLen = lstrlen(lpItem->lpGPOName) + 1;
                            if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwUsed+nLen+4) * sizeof(TCHAR),&dwAlloc)))
                                    return ERROR_NOT_ENOUGH_MEMORY;
                            lstrcpy(pBuf+dwUsed,lpItem->lpGPOName);
                            dwUsed += nLen;
                        }
                }
        }

        // doubly null-terminate the buffer... safe to do this because we
        // tacked on the extra "+4" in the ResizeBuffer calls above
        *(pBuf+dwUsed) = TEXT('\0');
        dwUsed++;

        uRet = ERROR_SUCCESS;

        if (fFoundValues) {
                // set flag that we found setting in registry/policy file
                if (pdwFound)
                        *pdwFound |= FS_PRESENT;
        } else {
                if (fFoundDelvals && pdwFound) {
                        *pdwFound |= FS_DELETED;
                }
        }

        GlobalUnlock(hBuf);

        if ((uRet == ERROR_SUCCESS) && phGlobal)
        {
            *phGlobal = hBuf;
        }
        else
        {
            GlobalFree(hBuf);
        }

        if (!m_pcd->m_bRSOP)
        {
            RegCloseKey(hKey);
        }

        return uRet;
}


BOOL CPolicySnapIn::ReadCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TCHAR * pszValue,UINT cbValue,DWORD * pdwValue,DWORD * pdwFlags,LPTSTR *lpGPOName)
{
        HKEY hKey;
        DWORD dwType,dwSize=cbValue * sizeof(TCHAR);
        BOOL fSuccess = FALSE;
        TCHAR szNewValueName[MAX_PATH+1];

        *pdwValue=0;
        *pszValue = TEXT('\0');


        if (m_pcd->m_bRSOP)
        {
            if (m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, pszValueName, (LPBYTE)pszValue,
                                      dwSize, &dwType, lpGPOName, NULL) == ERROR_SUCCESS)
            {
                if (dwType == REG_SZ)
                {
                        // value returned in pszValueName
                        *pdwFlags = 0;
                        fSuccess = TRUE;
                }
                else if (dwType == REG_DWORD || dwType == REG_BINARY)
                {
                        // copy value to *pdwValue
                        memcpy(pdwValue,pszValue,sizeof(DWORD));
                        *pdwFlags = VF_ISNUMERIC;
                        fSuccess = TRUE;
                }
            }
            else
            {
                // see if this is a value that's marked for deletion
                // (valuename is prepended with "**del."
                PrependValueName(pszValueName,VF_DELETE,
                        szNewValueName,ARRAYSIZE(szNewValueName));

                if (m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, szNewValueName, (LPBYTE)pszValue,
                                          dwSize, &dwType, lpGPOName, NULL) == ERROR_SUCCESS)
                {
                    fSuccess=TRUE;
                    *pdwFlags = VF_DELETE;
                }
                else
                {
                    // see if this is a soft value
                    // (valuename is prepended with "**soft."
                    PrependValueName(pszValueName,VF_SOFT,
                            szNewValueName,ARRAYSIZE(szNewValueName));

                    if (m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, szNewValueName, (LPBYTE)pszValue,
                                              dwSize, &dwType, lpGPOName, NULL) == ERROR_SUCCESS)
                    {
                            fSuccess=TRUE;
                            *pdwFlags = VF_SOFT;
                    }
                }
            }
        }
        else
        {
            if (RegOpenKeyEx(hkeyRoot,pszKeyName,0,KEY_READ,&hKey) == ERROR_SUCCESS) {
                    if (RegQueryValueEx(hKey,pszValueName,NULL,&dwType,(LPBYTE) pszValue,
                            &dwSize) == ERROR_SUCCESS) {

                            if (dwType == REG_SZ) {
                                    // value returned in pszValueName
                                    *pdwFlags = 0;
                                    fSuccess = TRUE;
                            } else if (dwType == REG_DWORD || dwType == REG_BINARY) {
                                    // copy value to *pdwValue
                                    memcpy(pdwValue,pszValue,sizeof(DWORD));
                                    *pdwFlags = VF_ISNUMERIC;
                                    fSuccess = TRUE;
                            }

                    } else {
                            // see if this is a value that's marked for deletion
                            // (valuename is prepended with "**del."
                            PrependValueName(pszValueName,VF_DELETE,
                                    szNewValueName,ARRAYSIZE(szNewValueName));

                            if (RegQueryValueEx(hKey,szNewValueName,NULL,&dwType,(LPBYTE) pszValue,
                                    &dwSize) == ERROR_SUCCESS) {
                                    fSuccess=TRUE;
                                    *pdwFlags = VF_DELETE;
                            } else {
                                    // see if this is a soft value
                                    // (valuename is prepended with "**soft."
                                    PrependValueName(pszValueName,VF_SOFT,
                                            szNewValueName,ARRAYSIZE(szNewValueName));

                                    if (RegQueryValueEx(hKey,szNewValueName,NULL,&dwType,(LPBYTE) pszValue,
                                            &dwSize) == ERROR_SUCCESS) {
                                            fSuccess=TRUE;
                                            *pdwFlags = VF_SOFT;
                                    }
                            }
                    }

                    RegCloseKey(hKey);
            }

        }

        return fSuccess;
}


BOOL CPolicySnapIn::CompareCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                                       STATEVALUE * pStateValue,DWORD * pdwFound, LPTSTR *lpGPOName)
{
        TCHAR szValue[MAXSTRLEN];
        DWORD dwValue;
        TCHAR szNewValueName[MAX_PATH+1];

        // add prefixes if appropriate
        PrependValueName(pszValueName,pStateValue->dwFlags,
                szNewValueName,ARRAYSIZE(szNewValueName));

        if (pStateValue->dwFlags & VF_ISNUMERIC) {
                if ((ReadRegistryDWordValue(hkeyRoot,pszKeyName,
                        szNewValueName,&dwValue,lpGPOName) == ERROR_SUCCESS) &&
                        dwValue == pStateValue->dwValue) {
                        *pdwFound = FS_PRESENT;
                        return TRUE;
                }
        } else if (pStateValue->dwFlags & VF_DELETE) {

                // see if this is a value that's marked for deletion
                // (valuename is prepended with "**del."

                if ((ReadRegistryStringValue(hkeyRoot,pszKeyName,
                        szNewValueName,szValue,ARRAYSIZE(szValue),lpGPOName)) == ERROR_SUCCESS) {
                        *pdwFound = FS_DELETED;
                        return TRUE;
                }
        } else {
                if ((ReadRegistryStringValue(hkeyRoot,pszKeyName,
                        szNewValueName,szValue,ARRAYSIZE(szValue),lpGPOName)) == ERROR_SUCCESS &&
                        !lstrcmpi(szValue,pStateValue->szValue)) {
                        *pdwFound = FS_PRESENT;
                        return TRUE;
                }
        }

        return FALSE;
}


BOOL CPolicySnapIn::ReadStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TABLEENTRY * pTableEntry,DWORD * pdwData,DWORD * pdwFound, LPTSTR *lpGPOName)
{
        UINT uRet;
        TCHAR szNewValueName[MAX_PATH+1];

        // add prefixes if appropriate
        PrependValueName(pszValueName,((SETTINGS *) pTableEntry)->dwFlags,
                szNewValueName,ARRAYSIZE(szNewValueName));

        if ( ((SETTINGS *) pTableEntry)->dwFlags & DF_TXTCONVERT) {
                // read numeric value as text if specified
                TCHAR szNum[11];
                uRet = ReadRegistryStringValue(hkeyRoot,pszKeyName,
                        szNewValueName,szNum,ARRAYSIZE(szNum),lpGPOName);
                if (uRet == ERROR_SUCCESS) {
                        StringToNum(szNum, (UINT *)pdwData);
                        *pdwFound = FS_PRESENT;
                        return TRUE;
                }
        } else {
                // read numeric value as binary
                uRet = ReadRegistryDWordValue(hkeyRoot,pszKeyName,
                        szNewValueName,pdwData, lpGPOName);
                if (uRet == ERROR_SUCCESS) {
                        *pdwFound = FS_PRESENT;
                        return TRUE;
                }
        }

        // see if this settings has been marked as 'deleted'
        TCHAR szVal[MAX_PATH+1];
        *pdwData = 0;
        PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                ARRAYSIZE(szNewValueName));
        uRet=ReadRegistryStringValue(hkeyRoot,pszKeyName,
                szNewValueName,szVal,ARRAYSIZE(szVal),lpGPOName);
        if (uRet == ERROR_SUCCESS) {
                *pdwFound = FS_DELETED;
                return TRUE;
        }


        return FALSE;
}

// adds the special prefixes "**del." and "**soft." if writing to a policy file,
// and VF_DELETE/VF_SOFT flags are set
VOID CPolicySnapIn::PrependValueName(TCHAR * pszValueName,DWORD dwFlags,TCHAR * pszNewValueName,
                                     UINT cbNewValueName)
{
        UINT nValueNameLen = lstrlen(pszValueName);

        lstrcpy(pszNewValueName, g_szNull);

        if (cbNewValueName < nValueNameLen)     // check length of buffer, just in case
            return;

        // prepend special prefixes for "delete" or "soft" values
        if ((dwFlags & VF_DELETE) && (cbNewValueName > nValueNameLen +
                ARRAYSIZE(szDELETEPREFIX))) {
                lstrcpy(pszNewValueName,szDELETEPREFIX);
        } else if ((dwFlags & VF_SOFT) && (cbNewValueName > nValueNameLen +
                ARRAYSIZE(szSOFTPREFIX))) {
                lstrcpy(pszNewValueName,szSOFTPREFIX);
        }


        lstrcat(pszNewValueName,pszValueName);
}

UINT CPolicySnapIn::WriteRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        DWORD dwValue)
{
        HKEY hKey;
        UINT uRet;

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;

        // create the key with appropriate name
        if ( (uRet = RegCreateKey(hkeyRoot,pszKeyName,&hKey))
                != ERROR_SUCCESS)
                return uRet;

        uRet = RegSetValueEx(hKey,pszValueName,0,REG_DWORD,
                (LPBYTE) &dwValue,sizeof(dwValue));
        RegCloseKey(hKey);

        return uRet;
}

UINT CPolicySnapIn::ReadRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        DWORD * pdwValue, LPTSTR *lpGPOName)
{
        HKEY hKey;
        UINT uRet;
        DWORD dwType,dwSize = sizeof(DWORD);

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;
        *pdwValue = 0;

        if (m_pcd->m_bRSOP)
        {
            uRet = m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, pszValueName, (LPBYTE) pdwValue, 4,
                                                &dwType, lpGPOName, NULL);
        }
        else
        {
            // open appropriate key
            if ( (uRet = RegOpenKeyEx(hkeyRoot,pszKeyName,0,KEY_READ,&hKey))
                    != ERROR_SUCCESS)
                    return uRet;

            uRet = RegQueryValueEx(hKey,pszValueName,0,&dwType,
                    (LPBYTE) pdwValue,&dwSize);
            RegCloseKey(hKey);
        }

        return uRet;
}

UINT CPolicySnapIn::WriteRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TCHAR * pszValue, BOOL bExpandable)
{
        HKEY hKey;
        UINT uRet;

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;

        // create the key with appropriate name
        if ( (uRet = RegCreateKey(hkeyRoot,pszKeyName,&hKey))
                != ERROR_SUCCESS)
                return uRet;

        uRet = RegSetValueEx(hKey,pszValueName,0,
                bExpandable ?  REG_EXPAND_SZ : REG_SZ,
                (LPBYTE) pszValue,(lstrlen(pszValue)+1) * sizeof(TCHAR));
        RegCloseKey(hKey);

        return uRet;
}

UINT CPolicySnapIn::ReadRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TCHAR * pszValue,UINT cbValue, LPTSTR *lpGPOName)
{
        HKEY hKey;
        UINT uRet;
        DWORD dwType;
        DWORD dwSize = cbValue * sizeof(TCHAR);

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;

        if (m_pcd->m_bRSOP)
        {
            uRet = m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, pszValueName, (LPBYTE) pszValue,
                                        dwSize, &dwType, lpGPOName, NULL);
        }
        else
        {
            // create the key with appropriate name
            if ( (uRet = RegOpenKeyEx(hkeyRoot,pszKeyName,0,KEY_READ,&hKey))
                    != ERROR_SUCCESS)
                    return uRet;

            uRet = RegQueryValueEx(hKey,pszValueName,0,&dwType,
                    (LPBYTE) pszValue,&dwSize);
            RegCloseKey(hKey);
        }

        return uRet;
}

UINT CPolicySnapIn::DeleteRegistryValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName)
{
        HKEY hKey;
        UINT uRet;

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;

        // create the key with appropriate name
        if ( (uRet = RegOpenKeyEx(hkeyRoot,pszKeyName,0,KEY_WRITE,&hKey))
                != ERROR_SUCCESS)
                return uRet;

        uRet = RegDeleteValue(hKey,pszValueName);
        RegCloseKey(hKey);

        return uRet;
}

UINT CPolicySnapIn::WriteCustomValue_W(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TCHAR * pszValue,DWORD dwValue,DWORD dwFlags,BOOL fErase)
{
        UINT uRet=ERROR_SUCCESS;
        TCHAR szNewValueName[MAX_PATH+1];

        // first: "clean house" by deleting both the specified value name,
        // and the value name with the delete (**del.) prefix.
        // Then write the appropriate version back out if need be

        PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                         ARRAYSIZE(szNewValueName));
        DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);


        // add prefixes if appropriate
        PrependValueName(pszValueName,(dwFlags & ~VF_DELETE),szNewValueName,
                         ARRAYSIZE(szNewValueName));
        DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);

        if (fErase) {
                // just need to delete value, done above

                uRet = ERROR_SUCCESS;
                RegCleanUpValue (hkeyRoot, pszKeyName, pszValueName);
        } else if (dwFlags & VF_DELETE) {
                // need to delete value (done above) and mark as deleted if writing
                // to policy file

                uRet = ERROR_SUCCESS;
                PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                                 ARRAYSIZE(szNewValueName));
                uRet=WriteRegistryStringValue(hkeyRoot,pszKeyName,
                        szNewValueName, (TCHAR *)szNOVALUE, FALSE);

        } else {
                if (dwFlags & VF_ISNUMERIC) {
                    uRet=WriteRegistryDWordValue(hkeyRoot,pszKeyName,
                                                 szNewValueName,dwValue);
                } else {
                    uRet = WriteRegistryStringValue(hkeyRoot,pszKeyName,
                            szNewValueName,pszValue,
                            (dwFlags & DF_EXPANDABLETEXT) ? TRUE : FALSE);
                }
        }

        return uRet;
}

UINT CPolicySnapIn::WriteCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        STATEVALUE * pStateValue,BOOL fErase)
{
        // pull info out of STATEVALUE struct and call worker function
        return WriteCustomValue_W(hkeyRoot,pszKeyName,pszValueName,
                pStateValue->szValue,pStateValue->dwValue,pStateValue->dwFlags,
                fErase);
}

// writes a numeric value given root key, key name and value name.  The specified
// value is removed if fErase is TRUE.  Normally if the data (dwData) is zero
// the value will be deleted, but if fWriteZero is TRUE then the value will
// be written as zero if the data is zero.
UINT CPolicySnapIn::WriteStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TABLEENTRY * pTableEntry,DWORD dwData,BOOL fErase,BOOL fWriteZero)
{
        UINT uRet=ERROR_SUCCESS;
        TCHAR szNewValueName[MAX_PATH+1];

        // first: "clean house" by deleting both the specified value name,
        // and the value name with the delete (**del.) prefix (if writing to policy
        // file).  Then write the appropriate version back out if need be

        PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                ARRAYSIZE(szNewValueName));

        DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);
        DeleteRegistryValue(hkeyRoot,pszKeyName,pszValueName);

        if (fErase) {
                // just need to delete value, done above
                uRet = ERROR_SUCCESS;
                RegCleanUpValue (hkeyRoot, pszKeyName, pszValueName);
        } else if ( ((SETTINGS *) pTableEntry)->dwFlags & DF_TXTCONVERT) {
                // if specified, save value as text
                TCHAR szNum[11];
                wsprintf(szNum,TEXT("%lu"),dwData);

                if (!dwData && !fWriteZero) {
                    // if value is 0, delete the value (done above), and mark
                    // it as deleted if writing to policy file

                    PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                            ARRAYSIZE(szNewValueName));
                    uRet=WriteRegistryStringValue(hkeyRoot,pszKeyName,
                            szNewValueName,(TCHAR *)szNOVALUE, FALSE);
                } else {

                    PrependValueName(pszValueName,((SETTINGS *)pTableEntry)->dwFlags,
                            szNewValueName,ARRAYSIZE(szNewValueName));
                    uRet = WriteRegistryStringValue(hkeyRoot,pszKeyName,
                            szNewValueName,szNum, FALSE);
                }
        } else {
                if (!dwData && !fWriteZero) {
                        // if value is 0, delete the value (done above), and mark
                        // it as deleted if writing to policy file

                        PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                                ARRAYSIZE(szNewValueName));
                        uRet=WriteRegistryStringValue(hkeyRoot,pszKeyName,
                                szNewValueName,(TCHAR *)szNOVALUE, FALSE);


                } else {
                        // save value as binary
                        PrependValueName(pszValueName,((SETTINGS *)pTableEntry)->dwFlags,
                                szNewValueName,ARRAYSIZE(szNewValueName));
                        uRet=WriteRegistryDWordValue(hkeyRoot,pszKeyName,
                                szNewValueName,dwData);
                }
        }

        return uRet;
}

TCHAR * CPolicySnapIn::ResizeBuffer(TCHAR * pBuf,HGLOBAL hBuf,DWORD dwNeeded,DWORD * pdwCurSize)
{
    TCHAR * pNew;

    if (dwNeeded <= *pdwCurSize) return pBuf; // nothing to do
    *pdwCurSize = dwNeeded;

    GlobalUnlock(hBuf);

    if (!GlobalReAlloc(hBuf,dwNeeded,GHND))
            return NULL;

    if (!(pNew = (TCHAR *) GlobalLock(hBuf))) return NULL;

    return pNew;
}
/*******************************************************************

        NAME:           MessageWndProc

        SYNOPSIS:       Window proc for GPMessageWndProc window

********************************************************************/
LRESULT CALLBACK CPolicySnapIn::MessageWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{

    switch (message)
    {
        case WM_CREATE:
            SetWindowLongPtr (hWnd, GWLP_USERDATA, (LONG_PTR)((CREATESTRUCT *) lParam)->lpCreateParams);
            break;

        case WM_MOVEFOCUS:
            {
            CPolicySnapIn * pPS;

            pPS = (CPolicySnapIn *) GetWindowLongPtr (hWnd, GWLP_USERDATA);

            if (pPS)
            {
                pPS->MoveFocusWorker ((BOOL)wParam);
            }
            }
            break;

        case WM_UPDATEITEM:
            {
            CPolicySnapIn * pPS;

            pPS = (CPolicySnapIn *) GetWindowLongPtr (hWnd, GWLP_USERDATA);

            if (pPS)
            {
                pPS->UpdateItemWorker ();
            }
            }
            break;

        case WM_SETPREVNEXT:
            {
            CPolicySnapIn * pPS;

            pPS = (CPolicySnapIn *) GetWindowLongPtr (hWnd, GWLP_USERDATA);

            if (pPS)
            {
                pPS->SetPrevNextButtonStateWorker ((HWND) wParam);
            }
            }
            break;

        default:
            {
            CPolicySnapIn * pPS;

            pPS = (CPolicySnapIn *) GetWindowLongPtr (hWnd, GWLP_USERDATA);

            if (pPS)
            {
                if (message == pPS->m_uiRefreshMsg)
                {
                    if ((DWORD) lParam == GetCurrentProcessId())
                    {
                        if (!pPS->m_hPropDlg)
                        {
                            pPS->m_pcd->m_pScope->DeleteItem (pPS->m_pcd->m_hSWPolicies, FALSE);
                            pPS->m_pcd->LoadTemplates();
                            pPS->m_pcd->EnumerateScopePane (NULL, pPS->m_pcd->m_hSWPolicies);
                        }
                    }
                }
            }

            return (DefWindowProc(hWnd, message, wParam, lParam));
            }
    }

    return (0);
}

/*******************************************************************

        NAME:           ClipWndProc

        SYNOPSIS:       Window proc for ClipClass window

********************************************************************/
LRESULT CALLBACK CPolicySnapIn::ClipWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{

        switch (message) {

                case WM_CREATE:

                        if (!((CREATESTRUCT *) lParam)->lpCreateParams) {

                                // this is the clip window in the dialog box.
                                SetScrollRange(hWnd,SB_VERT,0,0,TRUE);
                                SetScrollRange(hWnd,SB_HORZ,0,0,TRUE);
                        } else {
                                // this is the container window

                                // store away the dialog box HWND (the grandparent of this
                                // window) because the pointer to instance data we need lives
                                // in the dialog's window data
                                SetWindowLong(hWnd,0,WT_SETTINGS);
                        }

                        break;

                case WM_USER:
                        {
                                HWND hwndParent = GetParent(hWnd);
                                LPSETTINGSINFO lpSettingsInfo;
                                POLICYDLGINFO * pdi;

                                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hwndParent, DWLP_USER);

                                if (!lpSettingsInfo)
                                    return FALSE;

                                pdi = lpSettingsInfo->pdi;

                                if (!pdi)
                                    return FALSE;

                                if (!lpSettingsInfo->hFontDlg)
                                    lpSettingsInfo->hFontDlg = (HFONT) SendMessage(GetParent(hWnd),WM_GETFONT,0,0L);

                                // make a container window that is clipped by this windows
                                if (!(pdi->hwndSettings=CreateWindow(TEXT("ClipClass"),(TCHAR *) g_szNull,
                                        WS_CHILD | WS_VISIBLE,0,0,400,400,hWnd,NULL,g_hInstance,
                                        (LPVOID) hWnd)))
                                        return FALSE;
                                SetWindowLong(hWnd,0,WT_CLIP);
                                return TRUE;
                        }
                        break;

                case WM_VSCROLL:
                case WM_HSCROLL:

                        if (GetWindowLong(hWnd,0) == WT_CLIP)
                        {
                                LPSETTINGSINFO lpSettingsInfo;

                                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(GetParent(hWnd), DWLP_USER);

                                if (!lpSettingsInfo)
                                    return FALSE;

                                lpSettingsInfo->pCS->ProcessScrollBar(hWnd,wParam,
                                                    (message == WM_VSCROLL) ? TRUE : FALSE);
                        }
                        else goto defproc;

                        return 0;


                case WM_COMMAND:

                        if (GetWindowLong(hWnd,0) == WT_SETTINGS) {
                                LPSETTINGSINFO lpSettingsInfo;

                                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(GetParent(GetParent(hWnd)), DWLP_USER);

                                if (!lpSettingsInfo)
                                    break;

                                lpSettingsInfo->pCS->ProcessCommand(hWnd,wParam,(HWND) lParam, lpSettingsInfo->pdi);
                        }

                        break;

                case WM_GETDLGCODE:

                        if (GetWindowLong(hWnd,0) == WT_CLIP) {
                                SetWindowLongPtr(GetParent(hWnd),DWLP_MSGRESULT,DLGC_WANTTAB |
                                        DLGC_WANTALLKEYS);
                                return DLGC_WANTTAB | DLGC_WANTALLKEYS;
                        }
                        break;

                case WM_SETFOCUS:
                        // if clip window gains keyboard focus, transfer focus to first
                        // control owned by settings window
                        if (GetWindowLong(hWnd,0) == WT_CLIP) {
                                HWND hwndParent = GetParent(hWnd);
                                POLICYDLGINFO * pdi;
                                INT nIndex;
                                BOOL fForward=TRUE;
                                HWND hwndPrev = GetDlgItem(hwndParent,IDC_POLICY_PREVIOUS);
                                HWND hwndNext = GetDlgItem(hwndParent,IDC_POLICY_NEXT);
                                HWND hwndOK = GetDlgItem(GetParent(hwndParent),IDOK);
                                int iDelta;
                                LPSETTINGSINFO lpSettingsInfo;

                                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(GetParent(hWnd), DWLP_USER);

                                if (!lpSettingsInfo)
                                    return FALSE;

                                pdi = lpSettingsInfo->pdi;

                                if (!pdi)
                                    return FALSE;


                                // if Previous Policy button lost focus, then we're going backwards
                                // in tab order; otherwise we're going forwards
                                if ( (HWND) wParam == hwndPrev)
                                        fForward = FALSE;
                                else if ( (HWND) wParam == hwndNext)
                                        fForward = FALSE;
                                else if ( (HWND) wParam == hwndOK)
                                        fForward = FALSE;

                                // find the first control that has a data index (e.g. is
                                // not static text) and give it focus

                                if (pdi->nControls) {
                                        if (fForward) {         // search from start of table forwards
                                                nIndex = 0;
                                                iDelta = 1;
                                        } else {                        // search from end of table backwards
                                                nIndex = pdi->nControls-1;
                                                iDelta = -1;
                                        }

                                        for (;nIndex>=0 && nIndex<(int)pdi->nControls;nIndex += iDelta) {
                                                if (pdi->pControlTable[nIndex].uDataIndex !=
                                                        NO_DATA_INDEX &&
                                                        IsWindowEnabled(pdi->pControlTable[nIndex].hwnd)) {
                                                                SetFocus(pdi->pControlTable[nIndex].hwnd);
                                                        lpSettingsInfo->pCS->EnsureSettingControlVisible(hwndParent,
                                                                pdi->pControlTable[nIndex].hwnd);
                                                        return FALSE;
                                                }
                                        }
                                }

                                // only get here if there are no setting windows that can
                                // receive keyboard focus.  Give keyboard focus to the
                                // next guy in line.  This is the "OK" button, unless we
                                // shift-tabbed to get here from the "OK" button in which
                                // case the tree window is the next guy in line

                                if (fForward) {
                                    if (IsWindowEnabled (hwndPrev))
                                        SetFocus(hwndPrev);
                                    else if (IsWindowEnabled (hwndNext))
                                        SetFocus(hwndNext);
                                    else
                                        SetFocus(hwndOK);
                                } else {
                                    if (IsDlgButtonChecked (hwndParent, IDC_ENABLED) == BST_CHECKED) {
                                        SetFocus (GetDlgItem(hwndParent,IDC_ENABLED));
                                    } else if (IsDlgButtonChecked (hwndParent, IDC_DISABLED) == BST_CHECKED) {
                                        SetFocus (GetDlgItem(hwndParent,IDC_DISABLED));
                                    } else {
                                        SetFocus (GetDlgItem(hwndParent,IDC_NOCONFIG));
                                    }
                                }

                                return FALSE;
                        }
                        break;


                default:
defproc:

                        return (DefWindowProc(hWnd, message, wParam, lParam));

        }

        return (0);
}

/*******************************************************************

        NAME:           ProcessCommand

        SYNOPSIS:       WM_COMMAND handler for ClipClass window

********************************************************************/
VOID CPolicySnapIn::ProcessCommand(HWND hWnd,WPARAM wParam,HWND hwndCtrl, POLICYDLGINFO * pdi)
{
        // get instance-specific struct from dialog
        UINT uID = GetWindowLong(hwndCtrl,GWL_ID);

        if ( (uID >= IDD_SETTINGCTRL) && (uID < IDD_SETTINGCTRL+pdi->nControls)) {
                POLICYCTRLINFO * pPolicyCtrlInfo= &pdi->pControlTable[uID - IDD_SETTINGCTRL];

                switch (pPolicyCtrlInfo->dwType) {

                        case STYPE_CHECKBOX:

                                SendMessage(hwndCtrl,BM_SETCHECK,
                                           !(SendMessage(hwndCtrl,BM_GETCHECK,0,0)),0);

                                break;

                        case STYPE_LISTBOX:
                                ShowListbox(hwndCtrl,pPolicyCtrlInfo->pSetting);
                                break;


                        default:
                                // nothing to do
                                break;
                }

                if ((HIWORD(wParam) == BN_CLICKED) ||
                    (HIWORD(wParam) == EN_CHANGE)  ||
                    (HIWORD(wParam) == CBN_SELCHANGE) ||
                    (HIWORD(wParam) == CBN_EDITCHANGE))
                {
                    PostMessage (GetParent(GetParent(hWnd)), WM_MYCHANGENOTIFY, 0, 0);
                }
        }
}

// scrolls the control window into view if it's not visible
VOID CPolicySnapIn::EnsureSettingControlVisible(HWND hDlg,HWND hwndCtrl)
{
        // get the clip window, which owns the scroll bar
        HWND hwndClip = GetDlgItem(hDlg,IDC_POLICY_SETTINGS);
        POLICYDLGINFO * pdi;
        UINT nPos = GetScrollPos(hwndClip,SB_VERT),ySettingWindowSize,yClipWindowSize;
        UINT nExtra;
        int iMin,iMax=0;
        WINDOWPLACEMENT wp;
        RECT rcCtrl;
        LPSETTINGSINFO lpSettingsInfo;

        lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

        if (!lpSettingsInfo)
            return;

        pdi = lpSettingsInfo->pdi;

        if (!pdi)
            return;

        // find the scroll range
        GetScrollRange(hwndClip,SB_VERT,&iMin,&iMax);
        if (!iMax)      // no scroll bar, nothing to do
                return;

        // find the y size of the settings window that contains the settings controls
        // (this is clipped by the clip window in the dialog, scroll bar moves the
        // setting window up and down behind the clip window)
        wp.length = sizeof(wp);
        if (!GetWindowPlacement(pdi->hwndSettings,&wp))
                return; // unlikely to fail, but just bag out if it does rather than do something wacky
        ySettingWindowSize=wp.rcNormalPosition.bottom-wp.rcNormalPosition.top;

        // find y size of clip window
        if (!GetWindowPlacement(hwndClip,&wp))
                return; // unlikely to fail, but just bag out if it does rather than do something wacky
        yClipWindowSize=wp.rcNormalPosition.bottom-wp.rcNormalPosition.top;
        nExtra = ySettingWindowSize - yClipWindowSize;

        // if setting window is smaller than clip window, there should be no
        // scroll bar so we should never get here.  Check just in case though...
        if (ySettingWindowSize < yClipWindowSize)
                return;

        // get y position of control to be made visible
        if (!GetWindowPlacement(hwndCtrl,&wp))
                return;
        rcCtrl = wp.rcNormalPosition;
        rcCtrl.bottom = min ((int) ySettingWindowSize,rcCtrl.bottom + SC_YPAD);
        rcCtrl.top = max ((int) 0,rcCtrl.top - SC_YPAD);

        // if bottom of control is out of view, scroll the settings window up
        if ((float) rcCtrl.bottom >
                (float) (yClipWindowSize + ( (float) nPos/(float)iMax) * (ySettingWindowSize -
                yClipWindowSize))) {
                UINT nNewPos = (UINT)
                        ( ((float) (nExtra - (ySettingWindowSize - rcCtrl.bottom)) / (float) nExtra) * iMax);

                SetScrollPos(hwndClip,SB_VERT,nNewPos,TRUE);
                ProcessScrollBar(hwndClip,MAKELPARAM(SB_THUMBTRACK,nNewPos), TRUE);
                return;
        }

        // if top of control is out of view, scroll the settings window down
        if ((float) rcCtrl.top <
                (float) ( (float) nPos/(float)iMax) * nExtra) {
                UINT nNewPos = (UINT)
                        ( ((float) rcCtrl.top / (float) nExtra) * iMax);

                SetScrollPos(hwndClip,SB_VERT,nNewPos,TRUE);
                ProcessScrollBar(hwndClip,MAKELPARAM(SB_THUMBTRACK,nNewPos), TRUE);
                return;
        }
}


VOID CPolicySnapIn::ProcessScrollBar(HWND hWnd,WPARAM wParam,BOOL bVert)
{
        UINT nPos = GetScrollPos(hWnd,bVert ? SB_VERT : SB_HORZ);
        RECT rcParent,rcChild;
        POLICYDLGINFO * pdi;
        LPSETTINGSINFO lpSettingsInfo;

        // get instance-specific struct from dialog

        lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(GetParent(hWnd), DWLP_USER);

        if (!lpSettingsInfo)
            return;

        pdi = lpSettingsInfo->pdi;

        if (!pdi)
            return;

        if (LOWORD(wParam) == SB_ENDSCROLL)
            return;

        switch (LOWORD(wParam)) {

                case SB_THUMBPOSITION:
                case SB_THUMBTRACK:
                        nPos = HIWORD(wParam);
                        break;

                case SB_TOP:
                        nPos = 0;
                        break;

                case SB_BOTTOM:
                        nPos = 100;
                        break;

                case SB_LINEUP:
                        if (nPos >= 10)
                            nPos -= 10;
                        else
                            nPos = 0;
                        break;

                case SB_LINEDOWN:
                        if (nPos <= 90)
                            nPos += 10;
                        else
                            nPos = 100;
                        break;

                case SB_PAGEUP:
                        if (nPos >= 30)
                            nPos -= 30;
                        else
                            nPos = 0;
                        break;

                case SB_PAGEDOWN:
                        if (nPos <= 70)
                            nPos += 30;
                        else
                            nPos = 100;
                        break;
        }

        SetScrollPos(hWnd,bVert ? SB_VERT : SB_HORZ,nPos,TRUE);

        GetClientRect(hWnd,&rcParent);
        GetClientRect(pdi->hwndSettings,&rcChild);

        if (bVert)
        {
            SetWindowPos(pdi->hwndSettings,NULL,0,-(int) ((( (float)
                    (rcChild.bottom-rcChild.top)-(rcParent.bottom-rcParent.top))
                    /100.0) * (float) nPos),rcChild.right,rcChild.bottom,SWP_NOZORDER |
                    SWP_NOSIZE);
        }
        else
        {
            SetWindowPos(pdi->hwndSettings,NULL,-(int) ((( (float)
                    (rcChild.right-rcChild.left)-(rcParent.right-rcParent.left))
                    /100.0) * (float) nPos),rcChild.top, rcChild.right,rcChild.bottom,SWP_NOZORDER |
                    SWP_NOSIZE);
        }
}


/*******************************************************************

        NAME:           FreeSettingsControls

        SYNOPSIS:       Frees all settings controls

********************************************************************/
VOID CPolicySnapIn::FreeSettingsControls(HWND hDlg)
{
     UINT nIndex;
     HGLOBAL hData;
     POLICYDLGINFO * pdi;
     LPSETTINGSINFO lpSettingsInfo;

     // get instance-specific struct from dialog

     lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

     if (!lpSettingsInfo)
         return;

     pdi = lpSettingsInfo->pdi;

     if (!pdi)
         return;

     for (nIndex=0;nIndex<pdi->nControls;nIndex++) {

         if (pdi->pControlTable[nIndex].dwType == STYPE_LISTBOX)
         {
            hData = (HGLOBAL) GetWindowLongPtr (pdi->pControlTable[nIndex].hwnd,
                                             GWLP_USERDATA);

            if (hData)
            {
                GlobalFree (hData);
            }
         }

         DestroyWindow(pdi->pControlTable[nIndex].hwnd);
     }

     pdi->pCurrentSettings = NULL;
     pdi->nControls = 0;

     SetScrollRange(pdi->hwndSettings,SB_VERT,0,0,TRUE);
     SetScrollRange(pdi->hwndSettings,SB_HORZ,0,0,TRUE);
}

/*******************************************************************

        NAME:           CreateSettingsControls

        SYNOPSIS:       Creates controls in settings window

        NOTES:          Looks at a table of SETTINGS structs to determine
                                type of control to create and type-specific information.
                                For some types, more than one control can be created
                                (for instance, edit fields get a static control with
                                the title followed by an edit field control).

        ENTRY:          hDlg - owner dialog
                                hTable - table of SETTINGS structs containing setting
                                        control information

********************************************************************/
BOOL CPolicySnapIn::CreateSettingsControls(HWND hDlg,SETTINGS * pSetting,BOOL fEnable)
{
        LPBYTE pObjectData;
        POLICYDLGINFO * pdi;
        UINT xMax=0,yStart=SC_YSPACING,nHeight,nWidth,yMax,xWindowMax;
        HWND hwndControl,hwndBuddy,hwndParent;
        RECT rcParent;
        DWORD dwType, dwStyle;
        UINT uEnable = (fEnable ? 0 : WS_DISABLED);
        WINDOWPLACEMENT wp;
        LPSETTINGSINFO lpSettingsInfo;


        // get instance-specific struct from dialog

        lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

        if (!lpSettingsInfo)
            return FALSE;

        pdi = lpSettingsInfo->pdi;

        if (!pdi)
            return FALSE;

        wp.length = sizeof(wp);
        if (!GetWindowPlacement(GetDlgItem(hDlg,IDC_POLICY_SETTINGS),&wp))
                return FALSE;
        xWindowMax = wp.rcNormalPosition.right - wp.rcNormalPosition.left;

        pdi->pCurrentSettings = pSetting;

        while (pSetting) {

                pObjectData = GETOBJECTDATAPTR(pSetting);

                dwType = pSetting->dwType & STYPE_MASK;
                nWidth = 0;
                nHeight = 0;

                switch (dwType) {

                        case STYPE_TEXT:

                                // create static text control
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        (TCHAR *) (GETNAMEPTR(pSetting)),0,SSTYLE_STATIC | uEnable,0,
                                        yStart,0,15,STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,(TCHAR *) (GETNAMEPTR(pSetting))
                                        ,SC_XSPACING,yStart,0,&nWidth,&nHeight, lpSettingsInfo->hFontDlg);

                                yStart += nHeight + SC_YSPACING;
                                nWidth += SC_XSPACING;

                                break;

                        case STYPE_CHECKBOX:

                                // create checkbox control
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szBUTTON,
                                        (TCHAR *) (GETNAMEPTR(pSetting)),0,SSTYLE_CHECKBOX | uEnable,
                                        0,yStart,200,nHeight,STYPE_CHECKBOX,pSetting->uDataIndex,
                                        pSetting, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                nWidth = 20;
                                AdjustWindowToText(hwndControl,(TCHAR *) (GETNAMEPTR(pSetting))
                                        ,SC_XSPACING,yStart,0,&nWidth,&nHeight, lpSettingsInfo->hFontDlg);
                                yStart += nHeight + SC_YSPACING;
                                nWidth += SC_XSPACING;
                                break;

                        case STYPE_EDITTEXT:
                        case STYPE_COMBOBOX:

                                // create static text with setting name
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        GETNAMEPTR(pSetting),0,SSTYLE_STATIC | uEnable,0,0,0,0,
                                        STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,
                                        GETNAMEPTR(pSetting),SC_XSPACING,yStart,SC_YPAD,
                                        &nWidth,&nHeight, lpSettingsInfo->hFontDlg);

                                nWidth += SC_XSPACING + 5;

                                if (nWidth + SC_EDITWIDTH> xWindowMax) {
                                        // if next control will stick out of settings window,
                                        // put it on the next line
                                        if (nWidth > xMax)
                                                xMax = nWidth;
                                        yStart += nHeight + SC_YCONTROLWRAP;
                                        nWidth = SC_XINDENT;
                                } else {
                                     SetWindowPos(hwndControl,NULL,SC_XSPACING,(yStart + SC_YTEXTDROP),0,0,SWP_NOZORDER | SWP_NOSIZE);
                                }

                                // create edit field or combo box control
                                if (dwType == STYPE_EDITTEXT) {
                                        hwndControl = CreateSetting(pdi,(TCHAR *) szEDIT,(TCHAR *) g_szNull,
                                                WS_EX_CLIENTEDGE,SSTYLE_EDITTEXT | uEnable,nWidth,yStart,SC_EDITWIDTH,nHeight,
                                                STYPE_EDITTEXT,pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg);
                                } else {

                                        dwStyle = SSTYLE_COMBOBOX | uEnable;

                                        if (pSetting->dwFlags & DF_NOSORT) {
                                            dwStyle &= ~CBS_SORT;
                                        }

                                        hwndControl = CreateSetting(pdi,(TCHAR *) szCOMBOBOX,(TCHAR *)g_szNull,
                                                WS_EX_CLIENTEDGE,dwStyle,nWidth,yStart,SC_EDITWIDTH,nHeight*6,
                                                STYPE_COMBOBOX,pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg);
                                }
                                if (!hwndControl) return FALSE;

                                // limit the text length appropriately
                                if (dwType == STYPE_COMBOBOX) {
                                    SendMessage(hwndControl,CB_LIMITTEXT,
                                            (WPARAM) ((POLICYCOMBOBOXINFO *) pObjectData)->nMaxLen,0L);
                                } else {
                                    SendMessage(hwndControl,EM_SETLIMITTEXT,
                                            (WPARAM) ((EDITTEXTINFO *) pObjectData)->nMaxLen,0L);
                                }

                                if (dwType == STYPE_COMBOBOX &&
                                        ((POLICYCOMBOBOXINFO *) pObjectData)->uOffsetSuggestions)
                                        InsertComboboxItems(hwndControl,(TCHAR *) ((LPBYTE)pSetting +
                                                ((POLICYCOMBOBOXINFO *) pObjectData)->uOffsetSuggestions));


                                yStart += (UINT) ((float) nHeight*1.3) + SC_YSPACING;
                                nWidth += SC_EDITWIDTH;

                                break;

                        case STYPE_NUMERIC:
                                // create static text for setting
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        GETNAMEPTR(pSetting),0,
                                        SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,
                                        GETNAMEPTR(pSetting),SC_XSPACING,(yStart + SC_YTEXTDROP),SC_YPAD,
                                        &nWidth,&nHeight, lpSettingsInfo->hFontDlg);

                                nWidth += SC_XSPACING + 5;

                                // create edit field
                                if (!(hwndBuddy = CreateSetting(pdi,(TCHAR *) szEDIT,
                                        (TCHAR *) g_szNull,WS_EX_CLIENTEDGE,SSTYLE_EDITTEXT | uEnable,nWidth,yStart,SC_UPDOWNWIDTH,
                                        nHeight,STYPE_NUMERIC,pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                //SendMessage(hwndBuddy,EM_LIMITTEXT,4,0);

                                nWidth += SC_UPDOWNWIDTH;

                                // create spin (up-down) control if specifed
                                if (((NUMERICINFO *)pObjectData)->uSpinIncrement)  {
                                        UDACCEL udAccel = {0,0};
                                        UINT nMax,nMin;
                                        if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szUPDOWN,
                                                (TCHAR *) g_szNull,WS_EX_CLIENTEDGE,SSTYLE_UPDOWN | UDS_SETBUDDYINT | UDS_ALIGNRIGHT | UDS_UNSIGNED | uEnable,nWidth,yStart,SC_UPDOWNWIDTH2,
                                                nHeight,STYPE_TEXT | STYPE_NUMERIC,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;


                                        nWidth += SC_UPDOWNWIDTH2;

                                        nMax = ((NUMERICINFO *) pObjectData)->uMaxValue;
                                        nMin = ((NUMERICINFO *) pObjectData)->uMinValue;
                                        udAccel.nInc = ((NUMERICINFO *) pObjectData)->uSpinIncrement;

                                        SendMessage(hwndControl,UDM_SETBUDDY,(WPARAM) hwndBuddy,0L);
                                        SendMessage(hwndControl,UDM_SETRANGE32,(WPARAM) nMin,(LPARAM) nMax);
                                        SendMessage(hwndControl,UDM_SETACCEL,1,(LPARAM) &udAccel);
                                }
                                yStart += nHeight + SC_YSPACING;

                                break;

                        case STYPE_DROPDOWNLIST:

                                // create text description
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        GETNAMEPTR(pSetting),0,
                                        SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,
                                        GETNAMEPTR(pSetting),SC_XSPACING,yStart,SC_YPAD,&nWidth,&nHeight, lpSettingsInfo->hFontDlg);
                                nWidth += SC_XLEADING + 5;

                                if (nWidth + SC_EDITWIDTH> xWindowMax) {
                                        // if next control will stick out of settings window,
                                        // put it on the next line
                                        if (nWidth > xMax)
                                                xMax = nWidth;
                                        yStart += nHeight + SC_YCONTROLWRAP;
                                        nWidth = SC_XINDENT;
                                } else {
                                     SetWindowPos(hwndControl,NULL,SC_XSPACING,(yStart + SC_YTEXTDROP),0,0,SWP_NOZORDER | SWP_NOSIZE);
                                }

                                dwStyle = SSTYLE_DROPDOWNLIST | uEnable;

                                    if (pSetting->dwFlags & DF_NOSORT) {
                                    dwStyle &= ~CBS_SORT;
                                }

                                // create drop down listbox
                                hwndControl = CreateSetting(pdi,(TCHAR *) szCOMBOBOX,(TCHAR *) g_szNull,
                                WS_EX_CLIENTEDGE,dwStyle,nWidth,yStart,SC_EDITWIDTH,nHeight*6,
                                                STYPE_DROPDOWNLIST,pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg);
                                if (!hwndControl) return FALSE;
                                nWidth += SC_EDITWIDTH;

                                {
                                        // insert dropdown list items into control
                                        UINT uOffset = pSetting->uOffsetObjectData,nIndex=0;
                                        DROPDOWNINFO * pddi;
                                        int iSel;

                                        while (uOffset) {
                                                pddi = (DROPDOWNINFO *) ( (LPBYTE) pSetting + uOffset);
                                                iSel=(int)SendMessage(hwndControl,CB_ADDSTRING,0,(LPARAM)
                                                        ((LPBYTE) pSetting + pddi->uOffsetItemName));
                                                if (iSel<0) return FALSE;
                                                SendMessage(hwndControl,CB_SETITEMDATA,iSel,nIndex);
                                                nIndex++;
                                                uOffset = pddi->uOffsetNextDropdowninfo;
                                        }
                                }

                                yStart += (UINT) ((float) nHeight*1.3) + 1;
                                break;

                        case STYPE_LISTBOX:
                                {
                                TCHAR szShow[50];

                                // create static text with description
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        GETNAMEPTR(pSetting),0,
                                        SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,GETNAMEPTR(pSetting),SC_XSPACING,yStart,
                                        SC_YPAD,&nWidth,&nHeight, lpSettingsInfo->hFontDlg);
                                nWidth += SC_XLEADING;

                                if (nWidth + LISTBOX_BTN_WIDTH> xWindowMax) {
                                        // if next control will stick out of settings window,
                                        // put it on the next line
                                        if (nWidth > xMax)
                                                xMax = nWidth;
                                        yStart += nHeight + SC_YCONTROLWRAP;
                                        nWidth = SC_XINDENT;
                                } else {
                                     SetWindowPos(hwndControl,NULL,SC_XSPACING,(yStart + SC_YTEXTDROP),0,0,SWP_NOZORDER | SWP_NOSIZE);
                                }

                                // create pushbutton to show listbox contents
                                LoadString(g_hInstance, IDS_LISTBOX_SHOW, szShow, ARRAYSIZE(szShow));
                                hwndControl = CreateSetting(pdi,(TCHAR *) szBUTTON,szShow,0,
                                        SSTYLE_LBBUTTON | uEnable,nWidth+5,yStart,
                                        LISTBOX_BTN_WIDTH,nHeight,STYPE_LISTBOX,
                                        pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg);
                                if (!hwndControl) return FALSE;
                                SetWindowLongPtr(hwndControl,GWLP_USERDATA,0);
                                nWidth += LISTBOX_BTN_WIDTH + SC_XLEADING;

                                yStart += nHeight+1;
                                }
                }

                if (nWidth > xMax)
                        xMax = nWidth;
                pSetting = (SETTINGS *) pSetting->pNext;
        }

        yMax = yStart - 1;

        SetWindowPos(pdi->hwndSettings,NULL,0,0,xMax,yMax,SWP_NOZORDER);
        hwndParent = GetParent(pdi->hwndSettings);
        GetClientRect(hwndParent,&rcParent);

        if (yMax > (UINT) rcParent.bottom-rcParent.top) {
                SetScrollRange(hwndParent,SB_VERT,0,100,TRUE);
                SetScrollPos(hwndParent,SB_VERT,0,TRUE);
                ShowScrollBar(hwndParent,SB_VERT, TRUE);
        } else {
                SetScrollRange(hwndParent,SB_VERT,0,0,TRUE);
                ShowScrollBar(hwndParent,SB_VERT, FALSE);
        }

        if (xMax > (UINT) rcParent.right-rcParent.left) {
                SetScrollRange(hwndParent,SB_HORZ,0,100,TRUE);
                SetScrollPos(hwndParent,SB_HORZ,0,TRUE);
                ShowScrollBar(hwndParent,SB_HORZ, TRUE);
        } else {
                SetScrollRange(hwndParent,SB_HORZ,0,0,TRUE);
                ShowScrollBar(hwndParent,SB_HORZ, FALSE);
        }


        return TRUE;
}

VOID CPolicySnapIn::InsertComboboxItems(HWND hwndControl,TCHAR * pSuggestionList)
{
        while (*pSuggestionList) {
                SendMessage(hwndControl,CB_ADDSTRING,0,(LPARAM) pSuggestionList);
                pSuggestionList += lstrlen(pSuggestionList) + 1;
        }
}


/*******************************************************************

        NAME:           CreateSettings

        SYNOPSIS:       Creates a control and add it to the table of settings
                                controls

********************************************************************/
HWND CPolicySnapIn::CreateSetting(POLICYDLGINFO * pdi,TCHAR * pszClassName,TCHAR * pszWindowName,
        DWORD dwExStyle,DWORD dwStyle,int x,int y,int cx,int cy,DWORD dwType,UINT uIndex,
        SETTINGS * pSetting, HFONT hFontDlg)
{
        HWND hwndControl;

        if (!(hwndControl = CreateWindowEx(WS_EX_NOPARENTNOTIFY | dwExStyle,
                pszClassName,pszWindowName,dwStyle,x,y,cx,cy,pdi->hwndSettings,NULL,
                g_hInstance,NULL))) return NULL;

        if (!SetWindowData(pdi,hwndControl,dwType,uIndex,pSetting)) {
                DestroyWindow(hwndControl);
                return NULL;
        }

        SendMessage(hwndControl,WM_SETFONT,(WPARAM) hFontDlg,MAKELPARAM(TRUE,0));

        return hwndControl;
}

BOOL CPolicySnapIn::SetWindowData(POLICYDLGINFO * pdi,HWND hwndControl,DWORD dwType,
        UINT uDataIndex,SETTINGS * pSetting)
{
        POLICYCTRLINFO PolicyCtrlInfo;
        int iCtrl;

        PolicyCtrlInfo.hwnd = hwndControl;
        PolicyCtrlInfo.dwType = dwType;
        PolicyCtrlInfo.uDataIndex = uDataIndex;
        PolicyCtrlInfo.pSetting = pSetting;

        iCtrl = AddControlHwnd(pdi,&PolicyCtrlInfo);
        if (iCtrl < 0) return FALSE;

        SetWindowLong(hwndControl,GWL_ID,iCtrl + IDD_SETTINGCTRL);

        return TRUE;
}

int CPolicySnapIn::AddControlHwnd(POLICYDLGINFO * pdi,POLICYCTRLINFO * pPolicyCtrlInfo)
{
        int iRet;
        DWORD dwNeeded;
        POLICYCTRLINFO * pTemp;

        // grow table if necessary
        dwNeeded = (pdi->nControls+1) * sizeof(POLICYCTRLINFO);
        if (dwNeeded > pdi->dwControlTableSize) {
                pTemp = (POLICYCTRLINFO *) LocalReAlloc(pdi->pControlTable,
                                     dwNeeded,LMEM_ZEROINIT | LMEM_MOVEABLE);
                if (!pTemp) return (-1);
                pdi->pControlTable = pTemp;
                pdi->dwControlTableSize = dwNeeded;
        }

        pdi->pControlTable[pdi->nControls] = *pPolicyCtrlInfo;

        iRet = (int) pdi->nControls;

        (pdi->nControls)++;

        return iRet;
}

BOOL CPolicySnapIn::AdjustWindowToText(HWND hWnd,TCHAR * szText,UINT xStart,UINT yStart,
        UINT yPad,UINT * pnWidth,UINT * pnHeight, HFONT hFontDlg)
{
        SIZE size;

        if (GetTextSize(hWnd,szText,&size, hFontDlg))
        {
            *pnHeight =size.cy + yPad;
            *pnWidth += size.cx;
            SetWindowPos(hWnd,NULL,xStart,yStart,*pnWidth,*pnHeight,SWP_NOZORDER);
        }

        return FALSE;
}

BOOL CPolicySnapIn::GetTextSize(HWND hWnd,TCHAR * szText,SIZE * pSize, HFONT hFontDlg)
{
        HDC hDC;
        BOOL fRet;

        if (!(hDC = GetDC(hWnd))) return FALSE;

        SelectObject(hDC, hFontDlg);
        fRet=GetTextExtentPoint(hDC,szText,lstrlen(szText),pSize);

        ReleaseDC(hWnd,hDC);

        return fRet;
}


//*************************************************************
//
//  SaveSettings()
//
//  Purpose:    Saves the results of the settings
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HRESULT CPolicySnapIn::SaveSettings(HWND hDlg)
{
     UINT nIndex;
     POLICYDLGINFO * pdi;
     LPSETTINGSINFO lpSettingsInfo;
     SETTINGS * pSetting;
     HKEY hKeyRoot;
     DWORD dwTemp;
     UINT uRet = ERROR_SUCCESS, uPolicyState;
     int iSel, iIndex;
     LPTSTR lpBuffer;
     BOOL fTranslated;
     NUMERICINFO * pNumericInfo;
     HRESULT hr;
     LPBYTE pObjectData;
     BOOL fErase;
     DROPDOWNINFO * pddi;
     GUID guidRegistryExt = REGISTRY_EXTENSION_GUID;
     GUID guidSnapinMach = CLSID_PolicySnapInMachine;
     GUID guidSnapinUser = CLSID_PolicySnapInUser;
     GUID ClientGUID;
     LPTSTR lpClientGUID;
     TCHAR szFormat[100];
     TCHAR szMsg[150];
     BOOL  bFoundNone; // used in the listbox case alone


     //
     // Check for RSOP mode
     //

     if (m_pcd->m_bRSOP)
     {
        DebugMsg((DM_VERBOSE, TEXT("CPolicySnapIn::SaveSettings: Running in RSOP mode, nothing to save.")));
        return S_OK;
     }


     //
     // Check the dirty bit
     //

     if (!m_bDirty)
     {
        DebugMsg((DM_VERBOSE, TEXT("CPolicySnapIn::SaveSettings: No changes detected.  Exiting successfully.")));
        return S_OK;
     }


     // get instance-specific struct from dialog

     lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

     if (!lpSettingsInfo)
         return E_FAIL;

     pdi = lpSettingsInfo->pdi;

     if (!pdi)
         return E_FAIL;

    if (m_pcd->m_pGPTInformation->GetRegistryKey(
                 (m_pcd->m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                      &hKeyRoot) != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to get registry key handle.")));
        return S_FALSE;
    }


    //
    // Get the policy state
    //

    if (IsDlgButtonChecked (hDlg, IDC_NOCONFIG) == BST_CHECKED)
    {
        uPolicyState = BST_INDETERMINATE;
    }
    else if (IsDlgButtonChecked (hDlg, IDC_ENABLED) == BST_CHECKED)
    {
        uPolicyState = BST_CHECKED;
    }
    else
    {
        uPolicyState = BST_UNCHECKED;
    }


    if (uPolicyState == BST_INDETERMINATE)
    {
        fErase = TRUE;
    }
    else
    {
        fErase = FALSE;
    }


    //
    // Save the overall policy state
    //

    if (uPolicyState != BST_INDETERMINATE)
    {
        if (uPolicyState == BST_CHECKED)
            dwTemp = 1;
        else
            dwTemp = 0;


        if (dwTemp && m_pCurrentPolicy->uOffsetValue_On)
        {
            uRet= WriteCustomValue(hKeyRoot,GETKEYNAMEPTR(m_pCurrentPolicy),GETVALUENAMEPTR(m_pCurrentPolicy),
                            (STATEVALUE *) ((LPBYTE) m_pCurrentPolicy + m_pCurrentPolicy->uOffsetValue_On),
                            fErase);
        }
        else if (!dwTemp && m_pCurrentPolicy->uOffsetValue_Off)
        {
                uRet= WriteCustomValue(hKeyRoot,GETKEYNAMEPTR(m_pCurrentPolicy),GETVALUENAMEPTR(m_pCurrentPolicy),
                        (STATEVALUE *) ((LPBYTE) m_pCurrentPolicy + m_pCurrentPolicy->uOffsetValue_Off),
                        fErase);
        }
        else
        {
            if (m_pCurrentPolicy->uOffsetValueName)
            {
                uRet=WriteStandardValue(hKeyRoot,GETKEYNAMEPTR(m_pCurrentPolicy),GETVALUENAMEPTR(m_pCurrentPolicy),
                        (TABLEENTRY *)m_pCurrentPolicy,dwTemp,fErase,FALSE);
            }
            else
            {
                uRet = ERROR_SUCCESS;
            }
        }


        if (uRet == ERROR_SUCCESS)
        {
            uRet = ProcessCheckboxActionLists(hKeyRoot,(TABLEENTRY *)m_pCurrentPolicy,
                    GETKEYNAMEPTR(m_pCurrentPolicy),dwTemp,FALSE, !dwTemp, TRUE);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
        }
    }
    else
    {
        if (m_pCurrentPolicy->uOffsetValueName)
        {
            uRet=WriteStandardValue(hKeyRoot,GETKEYNAMEPTR(m_pCurrentPolicy),GETVALUENAMEPTR(m_pCurrentPolicy),
                    (TABLEENTRY *)m_pCurrentPolicy,0,TRUE,FALSE);
        }

        if (uRet == ERROR_SUCCESS)
        {
            uRet = ProcessCheckboxActionLists(hKeyRoot,(TABLEENTRY *)m_pCurrentPolicy,
                    GETKEYNAMEPTR(m_pCurrentPolicy),0,TRUE,FALSE, TRUE);
        }

    }


    //
    // Save the state of the parts
    //

    for (nIndex=0;nIndex<pdi->nControls;nIndex++)
    {
        pSetting = pdi->pControlTable[nIndex].pSetting;

        if (pdi->pControlTable[nIndex].uDataIndex != NO_DATA_INDEX)
        {

            switch (pdi->pControlTable[nIndex].dwType)
            {

                case STYPE_CHECKBOX:

                    dwTemp = (DWORD)SendMessage(pdi->pControlTable[nIndex].hwnd,BM_GETCHECK,0,0L);

                    pObjectData = GETOBJECTDATAPTR(pSetting);

                    if (!pObjectData) {
                        return E_INVALIDARG;
                    }

                    if (dwTemp && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_On) {
                        uRet= WriteCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                        (STATEVALUE *) ((LPBYTE) pSetting + ((CHECKBOXINFO *)
                                        pObjectData)->uOffsetValue_On),fErase);
                    } else if (!dwTemp && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_Off) {
                            uRet= WriteCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                    (STATEVALUE *) ((LPBYTE) pSetting + ((CHECKBOXINFO *)
                                    pObjectData)->uOffsetValue_Off),fErase);
                    }
                    else uRet=WriteStandardValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                            (TABLEENTRY *)pSetting,dwTemp,fErase,FALSE);


                    if (uRet == ERROR_SUCCESS) {
                        uRet = ProcessCheckboxActionLists(hKeyRoot,(TABLEENTRY *)pSetting,
                                GETKEYNAMEPTR(pSetting),dwTemp,fErase,(uPolicyState == BST_UNCHECKED),FALSE);
                    } else {
                        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
                    }

                    break;

                case STYPE_EDITTEXT:
                case STYPE_COMBOBOX:

                    if (uPolicyState == BST_CHECKED)
                    {
                        dwTemp = (DWORD)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                             WM_GETTEXTLENGTH,0,0);

                        if (!dwTemp)
                        {
                            if (pSetting->dwFlags & DF_REQUIRED)
                            {
                                m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                                   MB_ICONINFORMATION,MB_OK);
                                RegCloseKey (hKeyRoot);
                                return E_FAIL;
                            }
                        }

                        lpBuffer = (LPTSTR) LocalAlloc (LPTR, (dwTemp + 1) * sizeof(TCHAR));

                        if (lpBuffer)
                        {
                            SendMessage(pdi->pControlTable[nIndex].hwnd,WM_GETTEXT,
                                    (dwTemp+1),(LPARAM) lpBuffer);

                            uRet = WriteCustomValue_W(hKeyRoot,
                                                      GETKEYNAMEPTR(pSetting),
                                                      GETVALUENAMEPTR(pSetting),
                                                      lpBuffer, 0, pSetting->dwFlags, FALSE);

                            if (uRet != ERROR_SUCCESS)
                            {
                                DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
                            }

                            LocalFree (lpBuffer);
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to allocate memory with %d."),
                                     GetLastError()));
                        }
                    }
                    else
                    {
                        WriteCustomValue_W(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                           (LPTSTR)g_szNull,0,
                                           (uPolicyState == BST_UNCHECKED) ? VF_DELETE : 0,
                                           fErase);
                    }

                    break;

                case STYPE_NUMERIC:

                    if (uPolicyState == BST_CHECKED)
                    {
                        if (pSetting->dwFlags & DF_REQUIRED)
                        {
                            dwTemp = (DWORD)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                                 WM_GETTEXTLENGTH,0,0);

                            if (!dwTemp)
                            {
                                if (pSetting->dwFlags & DF_REQUIRED)
                                {
                                    m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                                       MB_ICONINFORMATION,MB_OK);
                                    RegCloseKey (hKeyRoot);
                                    return E_FAIL;
                                }
                            }
                        }

                        uRet=GetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
                                           &fTranslated,FALSE);

                        if (!fTranslated)
                        {
                            m_pcd->MsgBoxParam(hDlg,IDS_INVALIDNUM,
                                               GETNAMEPTR(pSetting),MB_ICONINFORMATION,
                                               MB_OK);
                            SetFocus(pdi->pControlTable[nIndex].hwnd);
                            SendMessage(pdi->pControlTable[nIndex].hwnd,
                                    EM_SETSEL,0,-1);
                            RegCloseKey (hKeyRoot);
                            return E_FAIL;
                        }

                        // validate for max and min
                        pNumericInfo = (NUMERICINFO *) GETOBJECTDATAPTR(pSetting);

                        if (pNumericInfo && uRet < pNumericInfo->uMinValue)
                        {
                            LoadString(g_hInstance, IDS_NUMBERTOOSMALL, szFormat, ARRAYSIZE(szFormat));
                            wsprintf (szMsg, szFormat, uRet, pNumericInfo->uMinValue, pNumericInfo->uMinValue, uRet);

                            m_pcd->MsgBoxSz(hDlg,szMsg, MB_ICONINFORMATION, MB_OK);
                            uRet = pNumericInfo->uMinValue;
                        }

                        if (pNumericInfo && uRet > pNumericInfo->uMaxValue)
                        {
                            LoadString(g_hInstance, IDS_NUMBERTOOLARGE, szFormat, ARRAYSIZE(szFormat));
                            wsprintf (szMsg, szFormat, uRet, pNumericInfo->uMaxValue, pNumericInfo->uMaxValue, uRet);

                            m_pcd->MsgBoxSz(hDlg,szMsg, MB_ICONINFORMATION, MB_OK);
                            uRet = pNumericInfo->uMaxValue;
                        }
                    }
                    else
                    {
                        uRet = 0;
                    }

                    uRet=WriteStandardValue(hKeyRoot,GETKEYNAMEPTR(pSetting),
                                            GETVALUENAMEPTR(pSetting),
                                            (TABLEENTRY *)pSetting,uRet,
                                            fErase,(uPolicyState == BST_UNCHECKED) ? FALSE : TRUE);

                    if (uRet != ERROR_SUCCESS)
                    {
                        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
                    }

                    break;

                case STYPE_DROPDOWNLIST:

                    if (uPolicyState == BST_CHECKED)
                    {
                        iSel = (int)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                CB_GETCURSEL,0,0L);
                        iSel = (int)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                CB_GETITEMDATA,iSel,0L);

                        if (iSel < 0)
                        {
                            m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(pdi->pControlTable[nIndex].hwnd);
                            RegCloseKey (hKeyRoot);
                            return E_FAIL;
                        }
                    }
                    else
                    {
                        iSel = 0;
                    }

                    pddi = (DROPDOWNINFO *) GETOBJECTDATAPTR(pSetting);
                    iIndex = 0;

                    // walk the chain of DROPDOWNINFO structs to find the entry that
                    // we want to write.  (for value n, find the nth struct)
                    while (iIndex < iSel) {
                            // selected val is higher than # of structs in chain,
                            // should never happen but check just in case...
                            if (!pddi->uOffsetNextDropdowninfo) {
                                    RegCloseKey (hKeyRoot);
                                    return ERROR_NOT_ENOUGH_MEMORY;
                            }
                            pddi = (DROPDOWNINFO *)
                                    ((LPBYTE) pSetting + pddi->uOffsetNextDropdowninfo);
                            iIndex++;
                    }

                    uRet=WriteCustomValue_W(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                            (LPTSTR) ((LPBYTE)pSetting+pddi->uOffsetValue),pddi->dwValue,
                            pddi->dwFlags | ((uPolicyState == BST_UNCHECKED) ? VF_DELETE : 0),
                            fErase);

                    if (uRet == ERROR_SUCCESS && pddi->uOffsetActionList) {
                            uRet=WriteActionList(hKeyRoot,(ACTIONLIST *) ( (LPBYTE)
                                    pSetting + pddi->uOffsetActionList),GETKEYNAMEPTR(pSetting),
                                    fErase, (uPolicyState == BST_UNCHECKED));
                    }

                    if (uRet != ERROR_SUCCESS)
                    {
                        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
                    }
                    break;

                case STYPE_LISTBOX:

                    bFoundNone = FALSE;

                    SaveListboxData((HGLOBAL)GetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA),
                                    pSetting, hKeyRoot, GETKEYNAMEPTR(pSetting), fErase,
                                    ((uPolicyState == BST_INDETERMINATE) ? FALSE : TRUE), 
                                    (uPolicyState == BST_CHECKED), &bFoundNone);

                    // if the policy is enabled and no values are set
                    if ((uPolicyState == BST_CHECKED) && (bFoundNone)) {
                        m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                           MB_ICONINFORMATION,MB_OK);
                        SetFocus(pdi->pControlTable[nIndex].hwnd);
                        RegCloseKey (hKeyRoot);
                        return E_FAIL;
                    }

                    break;
            }


            if (pSetting->uOffsetClientExt)
            {
                lpClientGUID = (LPTSTR) ((BYTE *) pSetting + pSetting->uOffsetClientExt);

                StringToGuid (lpClientGUID, &ClientGUID);
                m_pcd->m_pGPTInformation->PolicyChanged(!m_pcd->m_bUserScope, TRUE, &ClientGUID,
                                                        m_pcd->m_bUserScope ? &guidSnapinUser
                                                                            : &guidSnapinMach );
            }
        }
    }


    hr = m_pcd->m_pGPTInformation->PolicyChanged(!m_pcd->m_bUserScope, TRUE, &guidRegistryExt,
                                            m_pcd->m_bUserScope ? &guidSnapinUser
                                                                : &guidSnapinMach );

    if (FAILED(hr))
    {
        LPTSTR lpError;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          0, hr, 0, (LPTSTR) &lpError, 0, NULL))
        {
            m_pcd->MsgBoxParam(hDlg,IDS_POLICYCHANGEDFAILED,lpError,
                    MB_ICONERROR, MB_OK);

            LocalFree (lpError);
        }
    }

    if (m_pCurrentPolicy->uOffsetClientExt)
    {
        lpClientGUID = (LPTSTR) ((BYTE *) m_pCurrentPolicy + m_pCurrentPolicy->uOffsetClientExt);

        StringToGuid (lpClientGUID, &ClientGUID);
        m_pcd->m_pGPTInformation->PolicyChanged(!m_pcd->m_bUserScope, TRUE, &ClientGUID,
                                                m_pcd->m_bUserScope ? &guidSnapinUser
                                                                    : &guidSnapinMach );
    }

    RegCloseKey (hKeyRoot);


    SendMessage (m_hMsgWindow, WM_UPDATEITEM, 0, 0);

    if (SUCCEEDED(hr))
    {
        m_bDirty = FALSE;
        PostMessage (GetParent(hDlg), PSM_UNCHANGED, (WPARAM) hDlg, 0);
    }

    return S_OK;
}

VOID CPolicySnapIn::DeleteOldListboxData(SETTINGS * pSetting, HKEY hkeyRoot,
        TCHAR * pszCurrentKeyName)
{
    HGLOBAL hData = NULL;
    LPTSTR lpData;
    HKEY hKey;
    TCHAR szValueName[MAX_PATH+1];
    INT nItem=1;
    LISTBOXINFO * pListboxInfo = (LISTBOXINFO *) GETOBJECTDATAPTR(pSetting);


    //
    // Open the target registry key
    //

    if (RegOpenKeyEx (hkeyRoot, pszCurrentKeyName, 0, KEY_WRITE, &hKey) != ERROR_SUCCESS)
    {
        return;
    }


    //
    // Load the old listbox data
    //

    if (LoadListboxData((TABLEENTRY *) pSetting, hkeyRoot,
                        pszCurrentKeyName, NULL, &hData, NULL) == ERROR_SUCCESS)
    {

        if (hData)
        {
            //
            // Delete the listbox's old data
            //

            if ((lpData = (LPTSTR) GlobalLock(hData)))
            {
                while (*lpData) {

                    if (pSetting->dwFlags & DF_EXPLICITVALNAME)
                    {
                        // if explicit valuename flag set, entries are stored
                        // <value name>\0<value>\0....<value name>\0<value>\0\0
                        // otherwise, entries are stored
                        // <value>\0<value>\0....<value>\0

                        RegDeleteValue (hKey, lpData);
                        lpData += lstrlen(lpData) +1;
                        lpData += lstrlen(lpData) +1;
                    }
                    else
                    {
                        //
                        // Value name is either same as the data, or a prefix
                        // with a number
                        //

                        if (!pListboxInfo->uOffsetPrefix)
                        {
                            // if no prefix set, then name = data
                            RegDeleteValue (hKey, lpData);
                            lpData += lstrlen(lpData) +1;
                        }
                        else
                        {
                            // value name is "<prefix><n>" where n=1,2,etc.
                            wsprintf(szValueName,TEXT("%s%lu"),(TCHAR *) ((LPBYTE)pSetting +
                                    pListboxInfo->uOffsetPrefix),nItem);
                            RegDeleteValue (hKey, szValueName);
                            lpData += lstrlen(lpData) +1;
                            nItem++;
                        }
                    }
                }

                GlobalUnlock(hData);
            }

            GlobalFree (hData);
        }
    }

    RegCloseKey (hKey);
}

UINT CPolicySnapIn::SaveListboxData(HGLOBAL hData,SETTINGS * pSetting,HKEY hkeyRoot,
        TCHAR * pszCurrentKeyName,BOOL fErase,BOOL fMarkDeleted, BOOL bEnabled, BOOL * bFoundNone)
{
    UINT uOffset,uRet,nItem=1;
    HKEY hKey;
    TCHAR * pszData,* pszName;
    TCHAR szValueName[MAX_PATH+1];
    DWORD cbValueName, dwDisp;
    LISTBOXINFO * pListboxInfo = (LISTBOXINFO *) GETOBJECTDATAPTR(pSetting);


    // these checks need to be done first before any other operations are done
    if ((bEnabled) && (!hData)) {
        *bFoundNone = TRUE;
        return ERROR_INVALID_PARAMETER;
    }

    if (bEnabled) {
        pszData = (TCHAR *)GlobalLock (hData);
        // if there are no items at all
        if (!(*pszData)) {
            *bFoundNone = TRUE;
            GlobalUnlock(hData);
            return ERROR_INVALID_PARAMETER;
        }
        
        GlobalUnlock(hData);
        pszData = NULL;
    }

    *bFoundNone = FALSE;

    if (fErase)
    {
        RegDelnode (hkeyRoot, pszCurrentKeyName);
        RegCleanUpValue (hkeyRoot, pszCurrentKeyName, TEXT("some value that won't exist"));
        return ERROR_SUCCESS;
    }

    if (pSetting->dwFlags & DF_ADDITIVE)
    {
        DeleteOldListboxData(pSetting, hkeyRoot, pszCurrentKeyName);
    }
    else
    {
        RegDelnode (hkeyRoot, pszCurrentKeyName);
    }

    uRet = RegCreateKeyEx (hkeyRoot,pszCurrentKeyName,0,NULL,
                           REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                           &hKey, &dwDisp);

    if (uRet != ERROR_SUCCESS)
        return uRet;


    uRet=ERROR_SUCCESS;

    if (fMarkDeleted)
    {
        //
        // Write a control code that will cause
        // all values under that key to be deleted when client downloads from the file.
        // Don't do this if listbox is additive (DF_ADDITIVE), in that case whatever
        // we write here will be dumped in along with existing values
        //

        if (!(pSetting->dwFlags & DF_ADDITIVE))
        {
            uRet=WriteRegistryStringValue(hkeyRoot,pszCurrentKeyName,
                                          (TCHAR *) szDELVALS,
                                          (TCHAR *) szNOVALUE, FALSE);
        }
    }


    if (hData) {
        pszData = (TCHAR *)GlobalLock (hData);

        while (*pszData && (uRet == ERROR_SUCCESS))
        {
            UINT nLen = lstrlen(pszData)+1;

            if (pSetting->dwFlags & DF_EXPLICITVALNAME)
            {
                // value name specified for each item
                pszName = pszData;      // value name
                pszData += nLen;        // now pszData points to value data
                nLen = lstrlen(pszData)+1;
            }
            else
            {
                // value name is either same as the data, or a prefix
                // with a number

                if (!pListboxInfo->uOffsetPrefix) {
                        // if no prefix set, then name = data
                        pszName = pszData;
                } else {
                        // value name is "<prefix><n>" where n=1,2,etc.
                        wsprintf(szValueName,TEXT("%s%lu"),(TCHAR *) ((LPBYTE)pSetting +
                                pListboxInfo->uOffsetPrefix),nItem);
                        pszName = szValueName;
                        nItem++;
                }
            }

            uRet=RegSetValueEx(hKey,pszName,0,
                               (pSetting->dwFlags & DF_EXPANDABLETEXT) ?
                               REG_EXPAND_SZ : REG_SZ, (LPBYTE) pszData,
                               (lstrlen(pszData) + 1) * sizeof(TCHAR));

            pszData += nLen;
        }
        GlobalUnlock (hData);
    }


    RegCloseKey(hKey);

    return uRet;
}

UINT CPolicySnapIn::ProcessCheckboxActionLists(HKEY hkeyRoot,TABLEENTRY * pTableEntry,
                                               TCHAR * pszCurrentKeyName,DWORD dwData,
                                               BOOL fErase, BOOL fMarkAsDeleted,
                                               BOOL bPolicy)
{

    UINT uOffsetActionList_On,uOffsetActionList_Off,uRet=ERROR_SUCCESS;


    if (bPolicy)
    {
        POLICY * pPolicy = (POLICY *) pTableEntry;

        uOffsetActionList_On = pPolicy->uOffsetActionList_On;
        uOffsetActionList_Off = pPolicy->uOffsetActionList_Off;
    }
    else
    {
        LPBYTE pObjectData = GETOBJECTDATAPTR(((SETTINGS *)pTableEntry));

        if (!pObjectData) {
            return ERROR_INVALID_PARAMETER;
        }

        uOffsetActionList_On = ((CHECKBOXINFO *) pObjectData)
                ->uOffsetActionList_On;
        uOffsetActionList_Off = ((CHECKBOXINFO *) pObjectData)
                ->uOffsetActionList_Off;
    }

    if (dwData)
    {
        if (uOffsetActionList_On)
        {
            uRet = WriteActionList(hkeyRoot,(ACTIONLIST *)
                               ((LPBYTE) pTableEntry + uOffsetActionList_On),
                               pszCurrentKeyName,fErase,fMarkAsDeleted);
        }
    }
    else
    {
        if (uOffsetActionList_Off)
        {
            uRet = WriteActionList(hkeyRoot,(ACTIONLIST *)
                               ((LPBYTE) pTableEntry + uOffsetActionList_Off),
                               pszCurrentKeyName,fErase,FALSE);
        }
        else
        {
            if (uOffsetActionList_On)
            {
                uRet = WriteActionList(hkeyRoot,(ACTIONLIST *)
                                   ((LPBYTE) pTableEntry + uOffsetActionList_On),
                                   pszCurrentKeyName,fErase,TRUE);
            }
        }
    }

    return uRet;
}

UINT CPolicySnapIn::WriteActionList(HKEY hkeyRoot,ACTIONLIST * pActionList,
        LPTSTR pszCurrentKeyName,BOOL fErase, BOOL fMarkAsDeleted)
{
    UINT nCount;
    LPTSTR pszValueName;
    LPTSTR pszValue=NULL;
    UINT uRet;

    ACTION * pAction = pActionList->Action;

    for (nCount=0;nCount < pActionList->nActionItems; nCount++)
    {
         //
         // Not every action in the list has to have a key name.  But if one
         // is specified, use it and it becomes the current key name for the
         // list until we encounter another one.
         //

         if (pAction->uOffsetKeyName)
         {
             pszCurrentKeyName = (LPTSTR) ((LPBYTE)pActionList + pAction->uOffsetKeyName);
         }

         //
         // Every action must have a value name, enforced at parse time
         //

         pszValueName = (LPTSTR) ((LPBYTE)pActionList + pAction->uOffsetValueName);

         //
         // String values have a string elsewhere in buffer
         //

         if (!pAction->dwFlags && pAction->uOffsetValue)
         {
             pszValue = (LPTSTR) ((LPBYTE)pActionList + pAction->uOffsetValue);
         }

         //
         // Write the value in list
         //

         uRet=WriteCustomValue_W(hkeyRoot,pszCurrentKeyName,pszValueName,
                 pszValue,pAction->dwValue,
                 pAction->dwFlags | (fMarkAsDeleted ? VF_DELETE : 0),
                 fErase);

         if (uRet != ERROR_SUCCESS)
         {
             return uRet;
         }

         pAction = (ACTION*) ((LPBYTE) pActionList + pAction->uOffsetNextAction);
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

        NAME:           FindComboboxItemData

        SYNOPSIS:       Returns the index of item in combobox whose item data
                                is equal to nData.  Returns -1 if no items have data
                                which matches.

********************************************************************/
int CPolicySnapIn::FindComboboxItemData(HWND hwndControl,UINT nData)
{
    UINT nIndex;

    for (nIndex=0;nIndex<(UINT) SendMessage(hwndControl,CB_GETCOUNT,0,0L);
            nIndex++) {

        if ((UINT) SendMessage(hwndControl,CB_GETITEMDATA,nIndex,0L) == nData)
            return (int) nIndex;
    }

    return -1;
}


//*************************************************************
//
//  InitializeSettingsControls()
//
//  Purpose:    Initializes the settings controls
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HRESULT CPolicySnapIn::InitializeSettingsControls(HWND hDlg, BOOL fEnable)
{
    UINT nIndex;
    POLICYDLGINFO * pdi;
    LPSETTINGSINFO lpSettingsInfo;
    SETTINGS * pSetting;
    HKEY hKeyRoot;
    DWORD dwTemp, dwData, dwFlags, dwFoundSettings;
    UINT uRet;
    int iSel;
    HGLOBAL hData;
    LPTSTR lpBuffer;
    BOOL fTranslated, fFound;
    NUMERICINFO * pNumericInfo;
    TCHAR szBuffer[MAXSTRLEN];
    TCHAR szNewValueName[MAX_PATH+1];
    BOOL bChangeableState;

    // get instance-specific struct from dialog

    lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    if (!lpSettingsInfo)
        return E_FAIL;

    pdi = lpSettingsInfo->pdi;

    if (!pdi)
        return E_FAIL;


    if (m_pcd->m_bRSOP)
    {
        hKeyRoot = (HKEY) 1;
    }
    else
    {
        if (m_pcd->m_pGPTInformation->GetRegistryKey(
                     (m_pcd->m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                          &hKeyRoot) != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeSettingsControls: Failed to get registry key handle.")));
            return S_FALSE;
        }
    }


    for (nIndex=0;nIndex<pdi->nControls;nIndex++)
    {
        pSetting = pdi->pControlTable[nIndex].pSetting;

        if (pdi->pControlTable[nIndex].uDataIndex != NO_DATA_INDEX)
        {

            switch (pdi->pControlTable[nIndex].dwType)
            {

                case STYPE_CHECKBOX:

                    if (fEnable)
                    {
                        CHECKBOXINFO * pcbi = (CHECKBOXINFO *) GETOBJECTDATAPTR(pSetting);

                        //
                        // First look for custom on/off values
                        //

                        dwTemp = 0;
                        fFound = FALSE;
                        dwFoundSettings = 0;

                        if (pcbi->uOffsetValue_On)
                        {
                            if (CompareCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                       (STATEVALUE *) ((BYTE *) pSetting + pcbi->uOffsetValue_On),
                                       &dwFoundSettings, NULL))
                            {
                                dwTemp = 1;
                                fFound = TRUE;
                            }
                        }

                        if (!fFound && pcbi->uOffsetValue_Off)
                        {
                            if (CompareCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                    (STATEVALUE *) ((BYTE *) pSetting+ pcbi->uOffsetValue_Off),
                                    &dwFoundSettings, NULL))
                            {
                                dwTemp = 0;
                                fFound = TRUE;
                            }
                        }


                        //
                        // Look for standard values if custom values have not been specified
                        //

                        if (!fFound &&
                                ReadStandardValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                (TABLEENTRY*)pSetting,&dwTemp,&dwFoundSettings,NULL))
                        {
                                fFound = TRUE;
                        }

                        //
                        // If still not found, check for the def checked flag
                        //

                        if (!fFound)
                        {
                            if (pSetting->dwFlags & DF_USEDEFAULT)
                            {
                                fFound = TRUE;
                                dwTemp = 1;
                            }
                        }

                        if (fFound && dwTemp)
                        {
                            SendMessage(pdi->pControlTable[nIndex].hwnd,BM_SETCHECK,BST_CHECKED,0L);
                        }
                        else
                        {
                            SendMessage(pdi->pControlTable[nIndex].hwnd,BM_SETCHECK,BST_UNCHECKED,0L);
                        }
                    }
                    else
                    {
                        SendMessage(pdi->pControlTable[nIndex].hwnd,BM_SETCHECK,BST_UNCHECKED,0L);
                    }


                    break;

                case STYPE_EDITTEXT:
                case STYPE_COMBOBOX:

                    szBuffer[0] = TEXT('\0');

                    if (fEnable)
                    {
                        uRet = ReadRegistryStringValue(hKeyRoot,
                                                       GETKEYNAMEPTR(pSetting),
                                                       GETVALUENAMEPTR(pSetting),
                                                       szBuffer, ARRAYSIZE(szBuffer),NULL);

                        //
                        // Use default text if it exists
                        //

                        if (uRet != ERROR_SUCCESS)
                        {
                            if (pSetting->dwFlags & DF_USEDEFAULT)
                            {
                                LPTSTR pszDefaultText;
                                EDITTEXTINFO * peti = ((EDITTEXTINFO *) GETOBJECTDATAPTR(pSetting));

                                pszDefaultText = (LPTSTR) ((LPBYTE)pSetting + peti->uOffsetDefText);

                                lstrcpy (szBuffer, pszDefaultText);
                            }
                        }
                    }

                    SendMessage (pdi->pControlTable[nIndex].hwnd, WM_SETTEXT,
                                 0, (LPARAM) szBuffer);
                    break;

                case STYPE_NUMERIC:

                    if (fEnable)
                    {
                        if (ReadStandardValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                              (TABLEENTRY*)pSetting,&dwTemp,&dwFoundSettings,NULL) &&
                                              (!(dwFoundSettings & FS_DELETED)))
                        {
                            SetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
                                          dwTemp,FALSE);
                        }
                        else
                        {
                            if (pSetting->dwFlags & DF_USEDEFAULT)
                            {
                                NUMERICINFO * pni = (NUMERICINFO *)GETOBJECTDATAPTR(pSetting);

                                SetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
                                              pni->uDefValue,FALSE);
                            }
                        }
                    }
                    else
                    {
                        SendMessage(pdi->pControlTable[nIndex].hwnd,WM_SETTEXT,0,(LPARAM) g_szNull);
                    }

                    break;

                case STYPE_DROPDOWNLIST:

                    if (fEnable)
                    {
                        dwData = 0;
                        dwFlags = 0;

                        if (ReadCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),
                                            GETVALUENAMEPTR(pSetting),
                                            szBuffer,ARRAYSIZE(szBuffer),
                                            &dwData,&dwFlags, NULL) && (!(dwFlags & VF_DELETE)))
                        {
                            BOOL fMatch = FALSE;

                            //
                            // Walk the list of DROPDOWNINFO structs (one for each state),
                            // and see if the value we found matches the value for the state
                            //

                            if (pSetting->uOffsetObjectData)
                            {
                                DROPDOWNINFO * pddi = (DROPDOWNINFO *) GETOBJECTDATAPTR(pSetting);
                                iSel = 0;

                                do {
                                    if (dwFlags == pddi->dwFlags)
                                    {
                                        if (pddi->dwFlags & VF_ISNUMERIC)
                                        {
                                            if (dwData == pddi->dwValue)
                                                fMatch = TRUE;
                                        }
                                        else if (!pddi->dwFlags)
                                        {
                                            if (!lstrcmpi(szBuffer,(TCHAR *)((BYTE *)pSetting +
                                                pddi->uOffsetValue)))
                                                fMatch = TRUE;
                                        }
                                    }

                                    if (!pddi->uOffsetNextDropdowninfo || fMatch)
                                        break;

                                    pddi = (DROPDOWNINFO *) ( (BYTE *) pSetting +
                                            pddi->uOffsetNextDropdowninfo);
                                    iSel++;

                                } while (!fMatch);

                                if (fMatch) {
                                    SendMessage (pdi->pControlTable[nIndex].hwnd,
                                                 CB_SETCURSEL,
                                                 FindComboboxItemData(pdi->pControlTable[nIndex].hwnd, iSel),0);
                                }
                            }
                        }
                        else
                        {
                            if (pSetting->dwFlags & DF_USEDEFAULT)
                            {
                                DROPDOWNINFO * pddi = (DROPDOWNINFO *)GETOBJECTDATAPTR(pSetting);

                                SendMessage (pdi->pControlTable[nIndex].hwnd, CB_SETCURSEL,
                                             FindComboboxItemData(pdi->pControlTable[nIndex].hwnd, pddi->uDefaultItemIndex),0);
                            }
                        }
                    }
                    else
                    {
                        SendMessage(pdi->pControlTable[nIndex].hwnd,CB_SETCURSEL,(UINT) -1,0L);
                    }

                    break;

                case STYPE_LISTBOX:

                    hData = (HGLOBAL) GetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA);

                    if (fEnable)
                    {
                        if (!hData)
                        {
                             if (LoadListboxData((TABLEENTRY *) pSetting, hKeyRoot,
                                                 GETKEYNAMEPTR(pSetting),NULL,
                                                 &hData, NULL) == ERROR_SUCCESS)
                             {
                                SetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA, (LONG_PTR)hData);
                             }
                        }
                    }
                    else
                    {
                        if (hData)
                        {
                            GlobalFree (hData);
                            SetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA, 0);
                        }
                    }
                    break;
            }
        }


        //
        // Decide if the part should be enabled or not
        //
        // Special case text, numeric and listbox controls.
        // When the policy is disabled, text controls should still be enabled.
        // Numeric controls are special because they use the NO_DATA_INDEX
        // flag, so we need to check for those. Listbox controls are special
        // in RSOP only.
        //

        bChangeableState = TRUE;

        if (pdi->pControlTable[nIndex].uDataIndex == NO_DATA_INDEX)
        {
            if (pdi->pControlTable[nIndex].dwType != (STYPE_TEXT | STYPE_NUMERIC))
            {
                bChangeableState = FALSE;
            }
        }

        if (pdi->pControlTable[nIndex].dwType == STYPE_LISTBOX)
        {
            if (m_pcd->m_bRSOP)
            {
                bChangeableState = FALSE;
            }
        }


        if (bChangeableState)
            EnableWindow(pdi->pControlTable[nIndex].hwnd, (m_pcd->m_bRSOP ? FALSE : fEnable));
        else
            EnableWindow(pdi->pControlTable[nIndex].hwnd,TRUE);
    }

    if (!m_pcd->m_bRSOP)
    {
        RegCloseKey (hKeyRoot);
    }

    return S_OK;
}

VOID CPolicySnapIn::ShowListbox(HWND hParent,SETTINGS * pSettings)
{
    LISTBOXDLGINFO ListboxDlgInfo;

    ListboxDlgInfo.pCS = this;
    ListboxDlgInfo.pSettings = pSettings;
    ListboxDlgInfo.hData = (HGLOBAL)GetWindowLongPtr (hParent, GWLP_USERDATA);

    if (DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_POLICY_SHOWLISTBOX),hParent,
                       ShowListboxDlgProc,(LPARAM) &ListboxDlgInfo))
    {
        SetWindowLongPtr (hParent, GWLP_USERDATA, (LONG_PTR) ListboxDlgInfo.hData);
    }
}

INT_PTR CALLBACK CPolicySnapIn::ShowListboxDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam)
{
    switch (uMsg) {

        case WM_INITDIALOG:
            {
            LISTBOXDLGINFO * pLBInfo = (LISTBOXDLGINFO *)lParam;

            //
            // Store away pointer to ListboxDlgInfo in window data
            //

            SetWindowLongPtr(hDlg,DWLP_USER,lParam);

            if (!pLBInfo->pCS->InitShowlistboxDlg(hDlg)) {
                pLBInfo->pCS->m_pcd->MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
                EndDialog(hDlg,FALSE);
            }
            }
            return TRUE;

        case WM_COMMAND:

            switch (wParam) {

                case IDOK:
                    {
                    LISTBOXDLGINFO * pListboxDlgInfo =
                            (LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);


                    if (!pListboxDlgInfo->pCS->m_pcd->m_bRSOP)
                    {
                        if (!pListboxDlgInfo->pCS->ProcessShowlistboxDlg(hDlg)) {
                            pListboxDlgInfo->pCS->m_pcd->MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
                            return FALSE;
                        }
                    }
                    EndDialog(hDlg,TRUE);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    break;

                case IDC_POLICY_ADD:
                    {
                    LISTBOXDLGINFO * pListboxDlgInfo =
                            (LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
                    pListboxDlgInfo->pCS->ListboxAdd(GetDlgItem(hDlg,IDC_POLICY_LISTBOX), (BOOL)
                            pListboxDlgInfo->pSettings->dwFlags & DF_EXPLICITVALNAME,
                            (BOOL)( ((LISTBOXINFO *)
                            GETOBJECTDATAPTR(pListboxDlgInfo->pSettings))->
                            uOffsetPrefix));
                    }
                    break;

                case IDC_POLICY_REMOVE:
                    {
                    LISTBOXDLGINFO * pListboxDlgInfo =
                            (LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);

                    pListboxDlgInfo->pCS->ListboxRemove(hDlg,GetDlgItem(hDlg,IDC_POLICY_LISTBOX));
                    }
                    break;
            }
            break;

        case WM_NOTIFY:

            if (wParam == IDC_POLICY_LISTBOX) {
                if (((NMHDR FAR*)lParam)->code == LVN_ITEMCHANGED) {
                    LISTBOXDLGINFO * pListboxDlgInfo =
                            (LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);

                    if (!pListboxDlgInfo->pCS->m_pcd->m_bRSOP)
                    {
                        pListboxDlgInfo->pCS->EnableShowListboxButtons(hDlg);
                    }
                }

            }
            break;
    }

    return FALSE;
}

BOOL CPolicySnapIn::InitShowlistboxDlg(HWND hDlg)
{
    LISTBOXDLGINFO * pListboxDlgInfo;
    SETTINGS * pSettings;
    LV_COLUMN lvc;
    RECT rcListbox;
    UINT uColWidth,uOffsetData;
    HWND hwndListbox;
    BOOL fSuccess=TRUE;
    LONG lStyle;
    TCHAR szBuffer[SMALLBUF];
    LPTSTR lpData;

    pListboxDlgInfo = (LISTBOXDLGINFO *)GetWindowLongPtr (hDlg, DWLP_USER);

    if (!pListboxDlgInfo)
        return FALSE;

    pSettings = pListboxDlgInfo->pSettings;

    hwndListbox = GetDlgItem(hDlg,IDC_POLICY_LISTBOX);

    //
    // Turn off the header if we don't need it
    //

    if (!m_pcd->m_bRSOP)
    {
        if (!(pSettings->dwFlags & DF_EXPLICITVALNAME))
        {
            lStyle = GetWindowLong (hwndListbox, GWL_STYLE);
            lStyle |= LVS_NOCOLUMNHEADER;
            SetWindowLong (hwndListbox, GWL_STYLE, lStyle);
        }
    }

    SendMessage(hwndListbox, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


    //
    // Set the setting title in the dialog
    //

    SetDlgItemText(hDlg,IDC_POLICY_TITLE,GETNAMEPTR(pSettings));

    GetClientRect(hwndListbox,&rcListbox);
    uColWidth = rcListbox.right-rcListbox.left;

    if (m_pcd->m_bRSOP)
    {
        if (pSettings->dwFlags & DF_EXPLICITVALNAME)
        {
            uColWidth /= 3;
        }
        else
        {
            uColWidth /= 2;
        }
    }
    else
    {
        if (pSettings->dwFlags & DF_EXPLICITVALNAME)
        {
            uColWidth /= 2;
        }
    }



    if (pSettings->dwFlags & DF_EXPLICITVALNAME) {

        //
        // add a 2nd column to the listview control
        //

        LoadString(g_hInstance,IDS_VALUENAME,szBuffer,ARRAYSIZE(szBuffer));
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = uColWidth-1;
        lvc.pszText = szBuffer;
        lvc.cchTextMax = lstrlen(lvc.pszText)+1;
        lvc.iSubItem = 0;
        ListView_InsertColumn(hwndListbox,0,&lvc);
    }

    //
    // Add a column to the listview control
    //

    LoadString(g_hInstance,IDS_VALUE,szBuffer,ARRAYSIZE(szBuffer));
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = uColWidth;
    lvc.pszText = szBuffer;
    lvc.cchTextMax = lstrlen(lvc.pszText)+1;
    lvc.iSubItem = (pSettings->dwFlags & DF_EXPLICITVALNAME ? 1 : 0);
    ListView_InsertColumn(hwndListbox,lvc.iSubItem,&lvc);

    if (m_pcd->m_bRSOP)
    {
        //
        // Add the GPO Name column to the listview control
        //

        LoadString(g_hInstance,IDS_GPONAME,szBuffer,ARRAYSIZE(szBuffer));
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = uColWidth;
        lvc.pszText = szBuffer;
        lvc.cchTextMax = lstrlen(lvc.pszText)+1;
        lvc.iSubItem = (pSettings->dwFlags & DF_EXPLICITVALNAME ? 2 : 1);
        ListView_InsertColumn(hwndListbox,lvc.iSubItem,&lvc);
    }


    if (m_pcd->m_bRSOP)
    {
        EnableWindow(GetDlgItem(hDlg,IDC_POLICY_REMOVE), FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_POLICY_ADD), FALSE);
    }
    else
    {
        EnableShowListboxButtons(hDlg);
    }


    if (pListboxDlgInfo->hData)
    {
        //
        // Insert the items from user's data buffer into the listbox
        //

        if ((lpData = (LPTSTR) GlobalLock(pListboxDlgInfo->hData)))
        {
            while (*lpData && fSuccess) {

                LV_ITEM lvi;

                lvi.pszText=lpData;
                lvi.mask = LVIF_TEXT;
                lvi.iItem=-1;
                lvi.iSubItem=0;
                lvi.cchTextMax = lstrlen(lpData)+1;

                fSuccess=((lvi.iItem=ListView_InsertItem(hwndListbox,&lvi)) >= 0);
                lpData += lstrlen(lpData) +1;


                // if explicit valuename flag set, entries are stored
                // <value name>\0<value>\0....<value name>\0<value>\0\0
                // otherwise, entries are stored
                // <value>\0<value>\0....<value>\0

                if (pSettings->dwFlags & DF_EXPLICITVALNAME) {

                    if (fSuccess) {
                        if (*lpData) {
                            lvi.iSubItem=1;
                            lvi.pszText=lpData;
                            lvi.cchTextMax = lstrlen(lpData)+1;
                            fSuccess=(ListView_SetItem(hwndListbox,&lvi) >= 0);
                        }
                        lpData += lstrlen(lpData) +1;
                    }
                }

                if (m_pcd->m_bRSOP) {

                    if (fSuccess) {
                        if (*lpData) {
                            lvi.iSubItem=(pSettings->dwFlags & DF_EXPLICITVALNAME) ? 2 : 1;
                            lvi.pszText=lpData;
                            lvi.cchTextMax = lstrlen(lpData)+1;
                            fSuccess=(ListView_SetItem(hwndListbox,&lvi) >= 0);
                        }
                        lpData += lstrlen(lpData) +1;
                    }
                }
            }

            GlobalUnlock(pListboxDlgInfo->hData);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    return fSuccess;
}

BOOL CPolicySnapIn::ProcessShowlistboxDlg(HWND hDlg)
{
    LISTBOXDLGINFO * pListboxDlgInfo = (LISTBOXDLGINFO *)
            GetWindowLongPtr(hDlg,DWLP_USER);   // get pointer to struct from window data
    DWORD dwAlloc=1024 * sizeof(TCHAR),dwUsed=0;
    HGLOBAL hBuf;
    TCHAR * pBuf;
    HWND hwndListbox = GetDlgItem(hDlg,IDC_POLICY_LISTBOX);
    LV_ITEM lvi;
    UINT nLen;
    int nCount;
    TCHAR pszText[MAX_PATH+1];

    // allocate a temp buffer to read entries into
    if (!(hBuf = GlobalAlloc(GHND,dwAlloc)) ||
            !(pBuf = (TCHAR *) GlobalLock(hBuf))) {
            if (hBuf)
                    GlobalFree(hBuf);
            return FALSE;
    }

    lvi.mask = LVIF_TEXT;
    lvi.iItem=0;
    lvi.pszText = pszText;
    lvi.cchTextMax = ARRAYSIZE(pszText);
    nCount = ListView_GetItemCount(hwndListbox);

    // retrieve the items out of listbox, pack into temp buffer
    for (;lvi.iItem<nCount;lvi.iItem ++) {
            lvi.iSubItem = 0;
            if (ListView_GetItem(hwndListbox,&lvi)) {
                    nLen = lstrlen(lvi.pszText) + 1;
                    if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwUsed+nLen+4) * sizeof(TCHAR),&dwAlloc)))
                            return ERROR_NOT_ENOUGH_MEMORY;
                    lstrcpy(pBuf+dwUsed,lvi.pszText);
                    dwUsed += nLen;
            }

            if (pListboxDlgInfo->pSettings->dwFlags & DF_EXPLICITVALNAME) {
                    lvi.iSubItem = 1;
                    if (ListView_GetItem(hwndListbox,&lvi)) {
                            nLen = lstrlen(lvi.pszText) + 1;
                            if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwUsed+nLen+4) * sizeof(TCHAR),&dwAlloc)))
                                    return ERROR_NOT_ENOUGH_MEMORY;
                            lstrcpy(pBuf+dwUsed,lvi.pszText);
                            dwUsed += nLen;
                    }
            }
    }
    // doubly null-terminate the buffer... safe to do this because we
    // tacked on the extra "+4" in the ResizeBuffer calls above
    *(pBuf+dwUsed) = TEXT('\0');
    dwUsed ++;

    GlobalUnlock(hBuf);

    if (pListboxDlgInfo->hData)
    {
        GlobalFree (pListboxDlgInfo->hData);
    }

    pListboxDlgInfo->hData = hBuf;

    return TRUE;
}


VOID CPolicySnapIn::EnableShowListboxButtons(HWND hDlg)
{
    BOOL fEnable;

    // enable Remove button if there are any items selected
    fEnable = (ListView_GetNextItem(GetDlgItem(hDlg,IDC_POLICY_LISTBOX),
            -1,LVNI_SELECTED) >= 0);

    EnableWindow(GetDlgItem(hDlg,IDC_POLICY_REMOVE),fEnable);
}

VOID CPolicySnapIn::ListboxRemove(HWND hDlg,HWND hwndListbox)
{
    int nItem;

    while ( (nItem=ListView_GetNextItem(hwndListbox,-1,LVNI_SELECTED))
            >= 0) {
            ListView_DeleteItem(hwndListbox,nItem);
    }

    EnableShowListboxButtons(hDlg);
}

VOID CPolicySnapIn::ListboxAdd(HWND hwndListbox, BOOL fExplicitValName,BOOL fValuePrefix)
{
    ADDITEMINFO AddItemInfo;
    LV_ITEM lvi;

    ZeroMemory(&AddItemInfo,sizeof(AddItemInfo));

    AddItemInfo.pCS = this;
    AddItemInfo.fExplicitValName = fExplicitValName;
    AddItemInfo.fValPrefix = fValuePrefix;
    AddItemInfo.hwndListbox = hwndListbox;

    //
    // Bring up the appropriate add dialog-- one edit field ("type the thing
    // to add") normally, two edit fields ("type the name of the thing, type
    // the value of the thing") if the explicit value style is used
    //

    if (!DialogBoxParam(g_hInstance,MAKEINTRESOURCE((fExplicitValName ? IDD_POLICY_LBADD2 :
            IDD_POLICY_LBADD)),hwndListbox,ListboxAddDlgProc,(LPARAM) &AddItemInfo))
            return; // user cancelled

    // add the item to the listbox
    lvi.mask = LVIF_TEXT;
    lvi.iItem=lvi.iSubItem=0;
    lvi.pszText=(fExplicitValName ? AddItemInfo.szValueName :
            AddItemInfo.szValueData);
    lvi.cchTextMax = lstrlen(lvi.pszText)+1;
    if ((lvi.iItem=ListView_InsertItem(hwndListbox,&lvi))<0) {
        // if add fails, display out of memory error
        m_pcd->MsgBox(hwndListbox,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
        return;
    }

    if (fExplicitValName) {
        lvi.iSubItem=1;
        lvi.pszText=AddItemInfo.szValueData;
        lvi.cchTextMax = lstrlen(lvi.pszText)+1;
        if (ListView_SetItem(hwndListbox,&lvi) < 0) {
            m_pcd->MsgBox(hwndListbox,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
            return;
        }
    }
}

INT_PTR CALLBACK CPolicySnapIn::ListboxAddDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                               LPARAM lParam)
{
    switch (uMsg) {

        case WM_INITDIALOG:
            {
            ADDITEMINFO * pAddItemInfo = (ADDITEMINFO *)lParam;

            // store away pointer to additeminfo in window data
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
            SendDlgItemMessage(hDlg,IDC_POLICY_VALUENAME,EM_LIMITTEXT,MAX_PATH,0L);
            SendDlgItemMessage(hDlg,IDC_POLICY_VALUEDATA,EM_LIMITTEXT,MAX_PATH,0L);

            if (!pAddItemInfo->fExplicitValName) {
                ShowWindow (GetDlgItem (hDlg, IDC_POLICY_VALUENAME), SW_HIDE);
            }
            }
            break;

        case WM_COMMAND:

            switch (wParam) {

                case IDOK:
                    {
                    ADDITEMINFO * pAddItemInfo = (ADDITEMINFO *)
                    GetWindowLongPtr(hDlg,DWLP_USER);

                    GetDlgItemText(hDlg,IDC_POLICY_VALUENAME,
                            pAddItemInfo->szValueName,
                            ARRAYSIZE(pAddItemInfo->szValueName));

                    GetDlgItemText(hDlg,IDC_POLICY_VALUEDATA,
                            pAddItemInfo->szValueData,
                            ARRAYSIZE(pAddItemInfo->szValueData));

                    // if explicit value names used, value name must
                    // not be empty, and it must be unique
                    if (pAddItemInfo->fExplicitValName) {
                        LV_FINDINFO lvfi;
                        int iSel;

                        if (!lstrlen(pAddItemInfo->szValueName)) {
                            // can't be empty
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_EMPTYVALUENAME,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUENAME));
                            return FALSE;
                        }

                        lvfi.flags = LVFI_STRING;
                        lvfi.psz = pAddItemInfo->szValueName;

                        iSel=ListView_FindItem(pAddItemInfo->hwndListbox,
                                -1,&lvfi);

                        if (iSel >= 0) {
                            // value name already used
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_VALUENAMENOTUNIQUE,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUENAME));
                            SendDlgItemMessage(hDlg,IDC_POLICY_VALUENAME,
                                    EM_SETSEL,0,-1);
                            return FALSE;
                        }
                    } else if (!pAddItemInfo->fValPrefix) {
                        // if value name == value data, then value data
                        // must be unique

                        LV_FINDINFO lvfi;
                        int iSel;

                        if (!lstrlen(pAddItemInfo->szValueData)) {
                            // can't be empty
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_EMPTYVALUEDATA,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUEDATA));
                            return FALSE;
                        }

                        lvfi.flags = LVFI_STRING;
                        lvfi.psz = pAddItemInfo->szValueData;

                        iSel=ListView_FindItem(pAddItemInfo->hwndListbox,
                                -1,&lvfi);

                        if (iSel >= 0) {
                            // value name already used
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_VALUEDATANOTUNIQUE,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUEDATA));
                            SendDlgItemMessage(hDlg,IDC_POLICY_VALUEDATA,
                                    EM_SETSEL,0,-1);
                            return FALSE;
                        }

                    }
                    else
                    {
                        if (!lstrlen(pAddItemInfo->szValueData)) {
                            // can't be empty
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_EMPTYVALUEDATA,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUEDATA));
                            return FALSE;
                        }
                    }
                    EndDialog(hDlg,TRUE);
                    }

                    break;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    break;
            }

            break;
    }

    return FALSE;
}

void CPolicySnapIn::InitializeFilterDialog (HWND hDlg)
{
    INT iIndex;
    RECT rect;
    LV_COLUMN lvcol;
    LONG lWidth;
    DWORD dwCount = 0;
    HWND hList = GetDlgItem(hDlg, IDC_FILTERLIST);
    LPSUPPORTEDENTRY lpTemp;
    LVITEM item;


    //
    // Count the number of Supported On strings
    //

    lpTemp = m_pcd->m_pSupportedStrings;

    while (lpTemp)
    {
        lpTemp = lpTemp->pNext;
        dwCount++;
    }


    //
    // Decide on the column width
    //

    GetClientRect(hList, &rect);

    if (dwCount > (DWORD)ListView_GetCountPerPage(hList))
    {
        lWidth = (rect.right - rect.left) - GetSystemMetrics(SM_CYHSCROLL);
    }
    else
    {
        lWidth = rect.right - rect.left;
    }


    //
    // Insert the first column
    //

    memset(&lvcol, 0, sizeof(lvcol));

    lvcol.mask = LVCF_FMT | LVCF_WIDTH;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.cx = lWidth;
    ListView_InsertColumn(hList, 0, &lvcol);


    //
    // Turn on some listview features
    //

    SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP | LVS_EX_CHECKBOXES);


    //
    // Insert the Supported On strings
    //

    lpTemp = m_pcd->m_pSupportedStrings;

    while (lpTemp)
    {
        ZeroMemory (&item, sizeof(item));

        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = 0;
        item.pszText = lpTemp->lpString;
        item.lParam = (LPARAM) lpTemp;
        iIndex = ListView_InsertItem (hList, &item);

        if (iIndex > -1)
        {
            ZeroMemory (&item, sizeof(item));
            item.mask = LVIF_STATE;
            item.state = lpTemp->bEnabled ? INDEXTOSTATEIMAGEMASK(2) : INDEXTOSTATEIMAGEMASK(1);
            item.stateMask = LVIS_STATEIMAGEMASK;

            SendMessage (hList, LVM_SETITEMSTATE, (WPARAM)iIndex, (LPARAM)&item);
        }


        lpTemp = lpTemp->pNext;
    }


    //
    // Select the first item
    //

    item.mask = LVIF_STATE;
    item.iItem = 0;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hList, LVM_SETITEMSTATE, 0, (LPARAM) &item);


    //
    // Initialize the checkboxes
    //

    if (m_pcd->m_bUseSupportedOnFilter)
    {
        CheckDlgButton (hDlg, IDC_SUPPORTEDOPTION, BST_CHECKED);
    }
    else
    {
        EnableWindow (GetDlgItem (hDlg, IDC_SUPPORTEDONTITLE), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_FILTERLIST), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_SELECTALL), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_DESELECTALL), FALSE);
    }

    if (m_pcd->m_bShowConfigPoliciesOnly)
    {
        CheckDlgButton (hDlg, IDC_SHOWCONFIG, BST_CHECKED);
    }

    if ((m_dwPolicyOnlyPolicy == 0) || (m_dwPolicyOnlyPolicy == 1))
    {
        if (m_dwPolicyOnlyPolicy == 1)
        {
            CheckDlgButton (hDlg, IDC_SHOWPOLICIES, BST_CHECKED);
        }

        EnableWindow (GetDlgItem (hDlg, IDC_SHOWPOLICIES), FALSE);
    }
    else
    {
        if (m_bPolicyOnly)
        {
            CheckDlgButton (hDlg, IDC_SHOWPOLICIES, BST_CHECKED);
        }
    }
}


INT_PTR CALLBACK CPolicySnapIn::FilterDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                               LPARAM lParam)
{
    CPolicySnapIn * pCS;

    switch (uMsg)
    {

        case WM_INITDIALOG:
            pCS = (CPolicySnapIn *) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCS);

            if (pCS)
            {
                pCS->InitializeFilterDialog(hDlg);
            }
            break;

        case WM_COMMAND:

            switch (wParam)
            {
                case IDC_SUPPORTEDOPTION:
                    if (IsDlgButtonChecked (hDlg, IDC_SUPPORTEDOPTION) == BST_CHECKED)
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_SUPPORTEDONTITLE), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_FILTERLIST), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_SELECTALL), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_DESELECTALL), TRUE);
                    }
                    else
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_SUPPORTEDONTITLE), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_FILTERLIST), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_SELECTALL), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_DESELECTALL), FALSE);
                    }

                    break;

                case IDC_SELECTALL:
                    {
                        LVITEM item;

                        ZeroMemory (&item, sizeof(item));
                        item.mask = LVIF_STATE;
                        item.state = INDEXTOSTATEIMAGEMASK(2);
                        item.stateMask = LVIS_STATEIMAGEMASK;

                        SendMessage (GetDlgItem (hDlg, IDC_FILTERLIST), LVM_SETITEMSTATE, (WPARAM)-1, (LPARAM)&item);
                    }
                    break;

                case IDC_DESELECTALL:
                    {
                        LVITEM item;

                        ZeroMemory (&item, sizeof(item));
                        item.mask = LVIF_STATE;
                        item.state = INDEXTOSTATEIMAGEMASK(1);
                        item.stateMask = LVIS_STATEIMAGEMASK;

                        SendMessage (GetDlgItem (hDlg, IDC_FILTERLIST), LVM_SETITEMSTATE, (WPARAM)-1, (LPARAM)&item);
                    }
                    break;

                case IDOK:
                    {
                    LVITEM item;
                    INT iIndex = 0;
                    LPSUPPORTEDENTRY lpItem;

                    pCS = (CPolicySnapIn *) GetWindowLongPtr(hDlg,DWLP_USER);

                    if (!pCS)
                    {
                        break;
                    }

                    if (IsDlgButtonChecked (hDlg, IDC_SUPPORTEDOPTION) == BST_CHECKED)
                    {
                        pCS->m_pcd->m_bUseSupportedOnFilter = TRUE;
                        while (TRUE)
                        {
                            ZeroMemory (&item, sizeof(item));

                            item.mask = LVIF_PARAM | LVIF_STATE;
                            item.iItem = iIndex;
                            item.stateMask = LVIS_STATEIMAGEMASK;

                            if (!ListView_GetItem (GetDlgItem (hDlg, IDC_FILTERLIST), &item))
                            {
                                break;
                            }

                            lpItem = (LPSUPPORTEDENTRY) item.lParam;

                            if (lpItem)
                            {
                                if (item.state == INDEXTOSTATEIMAGEMASK(2))
                                {
                                    lpItem->bEnabled = TRUE;
                                }
                                else
                                {
                                    lpItem->bEnabled = FALSE;
                                }
                            }

                            iIndex++;
                        }
                    }
                    else
                    {
                        pCS->m_pcd->m_bUseSupportedOnFilter = FALSE;
                    }


                    if (IsDlgButtonChecked (hDlg, IDC_SHOWCONFIG) == BST_CHECKED)
                    {
                        pCS->m_pcd->m_bShowConfigPoliciesOnly = TRUE;
                    }
                    else
                    {
                        pCS->m_pcd->m_bShowConfigPoliciesOnly = FALSE;
                    }


                    if (IsDlgButtonChecked (hDlg, IDC_SHOWPOLICIES) == BST_CHECKED)
                    {
                        pCS->m_bPolicyOnly = TRUE;
                    }
                    else
                    {
                        pCS->m_bPolicyOnly = FALSE;
                    }


                    EndDialog(hDlg,TRUE);
                    }

                    break;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    break;
            }

            break;

        case WM_NOTIFY:

            pCS = (CPolicySnapIn *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCS) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case LVN_ITEMACTIVATE:
                    {
                    LPNMITEMACTIVATE pItem = (LPNMITEMACTIVATE) lParam;
                    LPSUPPORTEDENTRY lpItem;
                    LVITEM item;
                    HWND hLV = GetDlgItem(hDlg, IDC_FILTERLIST);

                    ZeroMemory (&item, sizeof(item));
                    item.mask = LVIF_STATE | LVIF_PARAM;
                    item.iItem = pItem->iItem;
                    item.stateMask = LVIS_STATEIMAGEMASK;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpItem = (LPSUPPORTEDENTRY) item.lParam;

                    if (!lpItem)
                    {
                        break;
                    }


                    if (lpItem)
                    {
                        if (item.state == INDEXTOSTATEIMAGEMASK(2))
                        {
                            item.state = INDEXTOSTATEIMAGEMASK(1);
                        }
                        else
                        {
                            item.state = INDEXTOSTATEIMAGEMASK(2);
                        }

                        item.mask = LVIF_STATE;
                        SendMessage (hLV, LVM_SETITEMSTATE, (WPARAM)pItem->iItem, (LPARAM)&item);
                    }

                    }
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aFilteringHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aFilteringHelpIds);
            return (TRUE);
    }

    return FALSE;
}


unsigned int CPolicyDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CPolicyDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CPolicyDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CPolicyDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CPolicyDataObject::m_cfDescription    = RegisterClipboardFormat(L"CCF_DESCRIPTION");
unsigned int CPolicyDataObject::m_cfHTMLDetails    = RegisterClipboardFormat(L"CCF_HTML_DETAILS");

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyDataObject implementation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CPolicyDataObject::CPolicyDataObject(CPolicyComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_pcd->AddRef();
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CPolicyDataObject::~CPolicyDataObject()
{
    m_pcd->Release();
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyDataObject object implementation (IUnknown)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CPolicyDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IPolicyDataObject))
    {
        *ppv = (LPPOLICYDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CPolicyDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CPolicyDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyDataObject object implementation (IDataObject)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPolicyDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;
    TCHAR szBuffer[300];


    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfDescription)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;

            if (m_cookie)
            {
                TABLEENTRY * pEntry = (TABLEENTRY *) m_cookie;

                if (pEntry->dwType & ETYPE_POLICY)
                {
                    POLICY * pPolicy = (POLICY *) m_cookie;
                    IStream *lpStream = lpMedium->pstm;


                    if (lpStream)
                    {
                        if (pPolicy->uOffsetHelp)
                        {
                            LPTSTR sz = (LPTSTR)((BYTE *)pPolicy + pPolicy->uOffsetHelp);
                            hr = lpStream->Write(sz, lstrlen(sz) * sizeof(TCHAR), &ulWritten);
                        }

                        if (!pPolicy->bTruePolicy)
                        {
                            LoadString (g_hInstance, IDS_PREFERENCE, szBuffer, ARRAYSIZE(szBuffer));
                            hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                        }
                    }
                }
                else if (pEntry->dwType & ETYPE_CATEGORY)
                {
                    CATEGORY * pCat = (CATEGORY *) m_cookie;

                    if (pCat->uOffsetHelp)
                    {
                        LPTSTR sz = (LPTSTR)((BYTE *)pCat + pCat->uOffsetHelp);

                        IStream *lpStream = lpMedium->pstm;

                        if (lpStream)
                        {
                            hr = lpStream->Write(sz, lstrlen(sz) * sizeof(TCHAR), &ulWritten);
                        }
                    }
                }
                else if (pEntry->dwType == (ETYPE_ROOT | ETYPE_REGITEM))
                {
                    IStream *lpStream = lpMedium->pstm;

                    LoadString (g_hInstance, IDS_EXSETROOT_DESC, szBuffer, ARRAYSIZE(szBuffer));

                    if (lpStream)
                    {
                        hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                    }
                }
                else if (pEntry->dwType == ETYPE_REGITEM)
                {
                    IStream *lpStream = lpMedium->pstm;

                    LoadString (g_hInstance, IDS_EXSET_DESC, szBuffer, ARRAYSIZE(szBuffer));

                    if (lpStream)
                    {
                        REGITEM * pItem = (REGITEM *) m_cookie;

                        hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);

                        if (!pItem->bTruePolicy)
                        {
                            LoadString (g_hInstance, IDS_PREFERENCE, szBuffer, ARRAYSIZE(szBuffer));
                            hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                        }
                    }
                }
            }
            else
            {
                LoadString (g_hInstance, IDS_POLICY_DESC, szBuffer, ARRAYSIZE(szBuffer));

                IStream *lpStream = lpMedium->pstm;

                if (lpStream)
                {
                    hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                }
            }
        }
    }
    else if (cf == m_cfHTMLDetails)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;

            if (m_cookie)
            {
                POLICY * pPolicy = (POLICY *) m_cookie;

                if ((pPolicy->dwType & ETYPE_POLICY) || (pPolicy->dwType == ETYPE_REGITEM))
                {
                    IStream *lpStream = lpMedium->pstm;

                    if(lpStream)
                    {
                        LPTSTR sz = GETSUPPORTEDPTR(pPolicy);

                        hr = lpStream->Write(g_szDisplayProperties, lstrlen(g_szDisplayProperties) * sizeof(TCHAR), &ulWritten);

                        if ((pPolicy->dwType & ETYPE_POLICY) && sz)
                        {
                            LoadString (g_hInstance, IDS_SUPPORTEDDESC, szBuffer, ARRAYSIZE(szBuffer));
                            hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                            hr = lpStream->Write(sz, lstrlen(sz) * sizeof(TCHAR), &ulWritten);
                        }
                    }
                }
            }
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyDataObject object implementation (Internal functions)              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CPolicyDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CPolicyDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    // Create the node type object in GUID format
    if (m_pcd->m_bUserScope)
        return Create((LPVOID)&NODEID_PolicyRootUser, sizeof(GUID), lpMedium);
    else
        return Create((LPVOID)&NODEID_PolicyRootMachine, sizeof(GUID), lpMedium);
}

HRESULT CPolicyDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    szNodeType[0] = TEXT('\0');
    if (m_pcd->m_bUserScope)
        StringFromGUID2 (NODEID_PolicyRootUser, szNodeType, 50);
    else
        StringFromGUID2 (NODEID_PolicyRootMachine, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CPolicyDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDisplayName[100] = {0};

    LoadStringW (g_hInstance, IDS_POLICY_NAME, szDisplayName, 100);

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CPolicyDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    if (m_pcd->m_bUserScope)
        return Create((LPVOID)&CLSID_PolicySnapInUser, sizeof(CLSID), lpMedium);
    else
        return Create((LPVOID)&CLSID_PolicySnapInMachine, sizeof(CLSID), lpMedium);
}

const TCHAR szViewDescript [] = TEXT("MMCViewExt 1.0 Object");
const TCHAR szViewGUID [] = TEXT("{B708457E-DB61-4C55-A92F-0D4B5E9B1224}");
const TCHAR szThreadingModel[] = TEXT("Apartment");

HRESULT RegisterPolicyExtension (REFGUID clsid, UINT uiStringId, REFGUID RootNodeID,
                           REFGUID ExtNodeId, LPTSTR lpSnapInNameIndirect)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szGUID[50];
    DWORD dwDisp;
    LONG lResult;
    HKEY hKey;


    //
    // First register the extension
    //

    StringFromGUID2 (clsid, szSnapInKey, 50);


    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    LoadString (g_hInstance, uiStringId, szSnapInName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)g_szSnapInLocation,
                   (lstrlen(g_szSnapInLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register SnapIn with MMC
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)lpSnapInNameIndirect,
                   (lstrlen(lpSnapInNameIndirect) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    StringFromGUID2 (RootNodeID, szGUID, 50);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
              szSnapInKey, szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);



    //
    // Register in the NodeTypes key
    //

    StringFromGUID2 (RootNodeID, szGUID, 50);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);


    //
    // Register for the view extension
    //

    lstrcat (szSubKey, TEXT("\\Extensions\\View"));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szViewGUID, 0, REG_SZ, (LPBYTE)szViewDescript,
                   (lstrlen(szViewDescript) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2 (ExtNodeId, szGUID, 50);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegCloseKey (hKey);

    return S_OK;
}



HRESULT RegisterPolicy(void)
{
    HRESULT hr;


    hr = RegisterPolicyExtension (CLSID_PolicySnapInMachine, IDS_POLICY_NAME_MACHINE,
                            NODEID_PolicyRootMachine, NODEID_MachineRoot, TEXT("@gptext.dll,-20"));

    if (hr == S_OK)
    {
        hr = RegisterPolicyExtension (CLSID_PolicySnapInUser, IDS_POLICY_NAME_USER,
                                NODEID_PolicyRootUser, NODEID_UserRoot, TEXT("@gptext.dll,-21"));
    }


    if (hr == S_OK)
    {
        hr = RegisterPolicyExtension (CLSID_RSOPolicySnapInMachine, IDS_POLICY_NAME_MACHINE,
                                NODEID_RSOPolicyRootMachine, NODEID_RSOPMachineRoot, TEXT("@gptext.dll,-20"));
    }

    if (hr == S_OK)
    {
        hr = RegisterPolicyExtension (CLSID_RSOPolicySnapInUser, IDS_POLICY_NAME_USER,
                                NODEID_RSOPolicyRootUser, NODEID_RSOPUserRoot, TEXT("@gptext.dll,-21"));
    }


    return hr;
}

HRESULT UnregisterPolicyExtension (REFGUID clsid, REFGUID RootNodeID, REFGUID ExtNodeId)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;

    //
    // First unregister the extension
    //

    StringFromGUID2 (clsid, szSnapInKey, 50);

    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (RootNodeID, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);



    StringFromGUID2 (ExtNodeId, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);


    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0,
                              KEY_WRITE, &hKey);


    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }

    return S_OK;
}


HRESULT UnregisterPolicy(void)
{
    HRESULT hr;

    hr = UnregisterPolicyExtension (CLSID_PolicySnapInMachine, NODEID_PolicyRootMachine,
                              NODEID_Machine);

    if (hr == S_OK)
    {
        hr = UnregisterPolicyExtension (CLSID_PolicySnapInUser, NODEID_PolicyRootUser,
                                  NODEID_User);
    }

    if (hr == S_OK)
    {
        hr = UnregisterPolicyExtension (CLSID_RSOPolicySnapInMachine, NODEID_RSOPolicyRootMachine,
                                  NODEID_RSOPMachineRoot);
    }


    if (hr == S_OK)
    {
        hr = UnregisterPolicyExtension (CLSID_RSOPolicySnapInUser, NODEID_RSOPolicyRootUser,
                                  NODEID_RSOPUserRoot);
    }

    return hr;
}



VOID LoadMessage (DWORD dwID, LPTSTR lpBuffer, DWORD dwSize)
{
    HINSTANCE hInstActiveDS;
    HINSTANCE hInstWMI;


    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, dwID,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  lpBuffer, dwSize, NULL))
    {
        hInstActiveDS = LoadLibrary (TEXT("activeds.dll"));

        if (hInstActiveDS)
        {
            if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                          hInstActiveDS, dwID,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                          lpBuffer, dwSize, NULL))
            {
                hInstWMI = LoadLibrary (TEXT("wmiutils.dll"));

                if (hInstWMI)
                {

                    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                                  hInstWMI, dwID,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                  lpBuffer, dwSize, NULL))
                    {
                        DebugMsg((DM_WARNING, TEXT("LoadMessage: Failed to query error message text for %d due to error %d"),
                                 dwID, GetLastError()));
                        wsprintf (lpBuffer, TEXT("%d (0x%x)"), dwID, dwID);
                    }

                    FreeLibrary (hInstWMI);
                }
            }

            FreeLibrary (hInstActiveDS);
        }
    }
}

//*************************************************************
//
//  ErrorDlgProc()
//
//  Purpose:    Dialog box procedure for errors
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

INT_PTR CALLBACK ErrorDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szError[MAX_PATH];
            LPGPOERRORINFO lpEI = (LPGPOERRORINFO) lParam;
            HICON hIcon;

            hIcon = LoadIcon (NULL, IDI_INFORMATION);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDC_ERROR_ICON, STM_SETICON, (WPARAM)hIcon, 0);
            }

            SetDlgItemText (hDlg, IDC_ERRORTEXT, lpEI->lpMsg);

            if (lpEI->lpDetails) {
                // if details is provided use that
                SetDlgItemText (hDlg, IDC_DETAILSTEXT, lpEI->lpDetails);
            }
            else {
                szError[0] = TEXT('\0');
                if (lpEI->dwError)
                {
                    LoadMessage (lpEI->dwError, szError, ARRAYSIZE(szError));
                }

                if (szError[0] == TEXT('\0'))
                {
                    LoadString (g_hInstance, IDS_NONE, szError, ARRAYSIZE(szError));
                }

                SetDlgItemText (hDlg, IDC_DETAILSTEXT, szError);

            }

            // this is the only way I know to remove focus from the details
            PostMessage(hDlg, WM_MYREFRESH, 0, 0);

            return TRUE;
        }


        case WM_MYREFRESH:
        {
            SetFocus(GetDlgItem(hDlg, IDCLOSE));
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCLOSE || LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aErrorHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aErrorHelpIds);
            return (TRUE);
    }

    return FALSE;
}

//*************************************************************
//
//  ReportError()
//
//  Purpose:    Displays an error message to the user
//
//  Parameters: hParent     -   Parent window handle
//              dwError     -   Error number
//              idMsg       -   Error message id
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL ReportAdmError (HWND hParent, DWORD dwError, UINT idMsg, ...)
{
    GPOERRORINFO ei;
    TCHAR szMsg[MAX_PATH];
    TCHAR szErrorMsg[2*MAX_PATH+40];
    va_list marker;


    //
    // Load the error message
    //

    if (!LoadString (g_hInstance, idMsg, szMsg, MAX_PATH))
    {
        return FALSE;
    }


    //
    // Plug in the arguments
    //


    va_start(marker, idMsg);
    if (idMsg == IDS_RSOP_ADMFAILED) {
        ei.lpDetails = va_arg(marker, LPTSTR);
        wcscpy(szErrorMsg, szMsg);
    }
    else {
        va_start(marker, idMsg);
        wvsprintf(szErrorMsg, szMsg, marker);
    }
    va_end(marker);

    //
    // Display the message
    //

    ei.dwError = dwError;
    ei.lpMsg   = szErrorMsg;

    DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_ERROR_ADMTEMPLATES), hParent,
                    ErrorDlgProc, (LPARAM) &ei);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\scripts.cpp ===
#include "gptext.h"
#include <initguid.h>
#include "scripts.h"
#include "smartptr.h"
#include "wbemtime.h"
#include <Psapi.h>

//
// Result pane items for the GPE Scripts node
//

RESULTITEM g_GPEScriptsRoot[] =
{
    { 1, 0, 0, 0, 0, {0} },
};


RESULTITEM g_GPEScriptsUser[] =
{
    { 2, 1, IDS_LOGON, IDS_SCRIPTS_LOGON, 3, {0} },
    { 3, 1, IDS_LOGOFF, IDS_SCRIPTS_LOGOFF, 3, {0} },
};

RESULTITEM g_GPEScriptsMachine[] =
{
    { 4, 2, IDS_STARTUP, IDS_SCRIPTS_STARTUP, 3, {0} },
    { 5, 2, IDS_SHUTDOWN, IDS_SCRIPTS_SHUTDOWN, 3, {0} },
};


//
// Namespace (scope) items
//

NAMESPACEITEM g_GPEScriptsNameSpace[] =
{
    { 0, -1, 0,                        IDS_SCRIPTS_DESC,          1, {0}, 0, g_GPEScriptsRoot, &NODEID_ScriptRoot },           // Scripts Root
    { 1 , 0, IDS_SCRIPTS_NAME_USER,    IDS_SCRIPTS_USER_DESC,     0, {0}, 2, g_GPEScriptsUser, &NODEID_ScriptRootUser },       // Scripts node (user)
    { 2 , 0, IDS_SCRIPTS_NAME_MACHINE, IDS_SCRIPTS_COMPUTER_DESC, 0, {0}, 2, g_GPEScriptsMachine, &NODEID_ScriptRootMachine }  // Scripts node (machine)
};


//
// Result pane items for the RSOP Scripts node
//

RESULTITEM g_RSOPScriptsRoot[] =
{
    { 1, 0, 0, 0, 0, {0} },
};


RESULTITEM g_RSOPScriptsUser[] =
{
    { 2, 1, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsMachine[] =
{
    { 3, 2, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsLogon[] =
{
    { 4, 3, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsLogoff[] =
{
    { 5, 4, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsStartup[] =
{
    { 6, 5, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsShutdown[] =
{
    { 7, 6, 0, 0, 0, {0} },
};


//
// Namespace (scope) items
//

NAMESPACEITEM g_RSOPScriptsNameSpace[] =
{
    { 0, -1, 0,                        IDS_SCRIPTS_DESC,          1, {0}, 0, g_RSOPScriptsRoot, &NODEID_RSOPScriptRoot },           // Scripts Root
    { 1 , 0, IDS_SCRIPTS_NAME_USER,    IDS_SCRIPTS_USER_DESC,     2, {0}, 0, g_RSOPScriptsUser, &NODEID_RSOPScriptRootUser },       // Scripts node (user)
    { 2 , 0, IDS_SCRIPTS_NAME_MACHINE, IDS_SCRIPTS_COMPUTER_DESC, 2, {0}, 0, g_RSOPScriptsMachine, &NODEID_RSOPScriptRootMachine }, // Scripts node (machine)

    { 3 , 1, IDS_LOGON,                IDS_SCRIPTS_LOGON,         0, {0}, 0, g_RSOPScriptsLogon, &NODEID_RSOPLogon },               // Logon node
    { 4 , 1, IDS_LOGOFF,               IDS_SCRIPTS_LOGOFF,        0, {0}, 0, g_RSOPScriptsLogoff, &NODEID_RSOPLogoff },             // Logoff node

    { 5 , 2, IDS_STARTUP,              IDS_SCRIPTS_STARTUP,       0, {0}, 0, g_RSOPScriptsStartup, &NODEID_RSOPStartup },           // Startup node
    { 6 , 2, IDS_SHUTDOWN,             IDS_SCRIPTS_SHUTDOWN,      0, {0}, 0, g_RSOPScriptsShutdown, &NODEID_RSOPShutdown }          // Shutdown node
};




//
// Script types
//

typedef enum _SCRIPTINFOTYPE {
    ScriptType_Logon = 0,
    ScriptType_Logoff,
    ScriptType_Startup,
    ScriptType_Shutdown
} SCRIPTINFOTYPE, *LPSCRIPTINFOTYPE;


//
// Structure passed to a script dialog
//

typedef struct _SCRIPTINFO
{
    CScriptsSnapIn * pCS;
    SCRIPTINFOTYPE   ScriptType;
} SCRIPTINFO, *LPSCRIPTINFO;


//
// Structure passed to a Add / edit script dialog
//

typedef struct _SCRIPTEDITINFO
{
    LPSCRIPTINFO     lpScriptInfo;
    BOOL             bEdit;
    LPTSTR           lpName;
    LPTSTR           lpArgs;
} SCRIPTEDITINFO, *LPSCRIPTEDITINFO;


//
// Structure stored in listview item
//

typedef struct _SCRIPTITEM
{
    LPTSTR  lpName;
    LPTSTR  lpArgs;
} SCRIPTITEM, *LPSCRIPTITEM;


//
// Scripts directory and ini file names in GPO
//

#define SCRIPTS_DIR_NAME    TEXT("Scripts")
#define SCRIPTS_FILE_NAME   TEXT("scripts.ini")


//
// Help ids
//

DWORD aScriptsHelpIds[] =
{
    IDC_SCRIPT_TITLE,             IDH_SCRIPT_TITLE,
    IDC_SCRIPT_HEADING,           IDH_SCRIPT_HEADING,
    IDC_SCRIPT_LIST,              IDH_SCRIPT_LIST,
    IDC_SCRIPT_UP,                IDH_SCRIPT_UP,
    IDC_SCRIPT_DOWN,              IDH_SCRIPT_DOWN,
    IDC_SCRIPT_ADD,               IDH_SCRIPT_ADD,
    IDC_SCRIPT_EDIT,              IDH_SCRIPT_EDIT,
    IDC_SCRIPT_REMOVE,            IDH_SCRIPT_REMOVE,
    IDC_SCRIPT_SHOW,              IDH_SCRIPT_SHOW,

    0, 0
};


DWORD aScriptsEditHelpIds[] =
{
    IDC_SCRIPT_NAME,              IDH_SCRIPT_NAME,
    IDC_SCRIPT_ARGS,              IDH_SCRIPT_ARGS,
    IDC_SCRIPT_BROWSE,            IDH_SCRIPT_BROWSE,

    0, 0
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CScriptsComponentData::CScriptsComponentData(BOOL bUser, BOOL bRSOP)
{
    m_cRef = 1;
    m_bUserScope = bUser;
    m_bRSOP = bRSOP;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_pGPTInformation = NULL;
    m_pRSOPInformation = NULL;
    m_pScriptsDir = NULL;
    m_pszNamespace = NULL;

    if (bRSOP)
    {
        m_pNameSpaceItems = g_RSOPScriptsNameSpace;
        m_dwNameSpaceItemCount = ARRAYSIZE(g_RSOPScriptsNameSpace);
    }
    else
    {
        m_pNameSpaceItems = g_GPEScriptsNameSpace;
        m_dwNameSpaceItemCount = ARRAYSIZE(g_GPEScriptsNameSpace);
    }

    m_pRSOPLogon = NULL;
    m_pRSOPLogoff = NULL;
    m_pRSOPStartup = NULL;
    m_pRSOPShutdown = NULL;

}

CScriptsComponentData::~CScriptsComponentData()
{

    FreeRSOPScriptData();

    if (m_pScriptsDir)
    {
        LocalFree (m_pScriptsDir);
    }

    if (m_pszNamespace)
    {
        LocalFree (m_pszNamespace);
    }

    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation)
    {
        m_pGPTInformation->Release();
    }

    if (m_pRSOPInformation)
    {
        m_pRSOPInformation->Release();
    }

    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (IUnknown)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CScriptsComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENTDATA)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CScriptsComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CScriptsComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (IComponentData)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole2, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                      reinterpret_cast<LONG_PTR *>(bmp16x16),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();

    return S_OK;
}

STDMETHODIMP CScriptsComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CScriptsComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CScriptsSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CScriptsComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CScriptsSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::CreateComponent: Failed to create CScriptsSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CScriptsComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CScriptsDataObject *pDataObject;
    LPSCRIPTDATAOBJECT pScriptDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CScriptsDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPTDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IScriptDataObject, (LPVOID *)&pScriptDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pScriptDataObject->SetType(type);
    pScriptDataObject->SetCookie(cookie);
    pScriptDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CScriptsComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_EXPAND:
            if (arg == TRUE)

                if (m_bRSOP)
                {
                    if (!m_pRSOPInformation)
                    {
                        lpDataObject->QueryInterface(IID_IRSOPInformation, (LPVOID *)&m_pRSOPInformation);

                        if (m_pRSOPInformation)
                        {
                            m_pszNamespace = (LPOLESTR) LocalAlloc (LPTR, 350 * sizeof(TCHAR));

                            if (m_pszNamespace)
                            {
                                if (m_pRSOPInformation->GetNamespace((m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                                                      m_pszNamespace, 350) == S_OK)
                                {
                                    InitializeRSOPScriptsData();

                                    if (LOWORD(dwDebugLevel) == DL_VERBOSE)
                                    {
                                        DumpRSOPScriptsData(m_pRSOPLogon);
                                        DumpRSOPScriptsData(m_pRSOPLogoff);
                                        DumpRSOPScriptsData(m_pRSOPStartup);
                                        DumpRSOPScriptsData(m_pRSOPShutdown);
                                    }
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify:  Failed to query for namespace")));
                                    LocalFree (m_pszNamespace);
                                    m_pszNamespace = NULL;
                                }
                            }
                        }
                    }

                    if (m_pszNamespace)
                    {
                        BOOL bEnum = TRUE;

                        if (m_bUserScope)
                        {
                            if (!m_pRSOPLogon && !m_pRSOPLogoff)
                            {
                                bEnum = FALSE;
                            }
                        }
                        else
                        {
                            if (!m_pRSOPStartup && !m_pRSOPShutdown)
                            {
                                bEnum = FALSE;
                            }
                        }

                        if (bEnum)
                        {
                            hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                        }
                    }
                }
                else
                {
                    if (!m_pGPTInformation)
                    {
                        lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);
                    }

                    if (m_pGPTInformation)
                    {
                        if (!m_pScriptsDir)
                        {
                            m_pScriptsDir = (LPTSTR) LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

                            if (m_pScriptsDir)
                            {
                                if (SUCCEEDED(m_pGPTInformation->GetFileSysPath(m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE,
                                                               m_pScriptsDir, MAX_PATH * sizeof(TCHAR))))
                                {
                                    LPTSTR lpEnd;


                                    //
                                    // Create the Scripts directory
                                    //

                                    lpEnd = CheckSlash (m_pScriptsDir);
                                    lstrcpy (lpEnd, SCRIPTS_DIR_NAME);

                                    if (!CreateNestedDirectory(m_pScriptsDir, NULL))
                                    {
                                        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify: Failed to create scripts sub-directory with %d."),
                                                 GetLastError()));
                                        LocalFree (m_pScriptsDir);
                                        m_pScriptsDir = NULL;
                                        break;
                                    }


                                    //
                                    // Create the appropriate sub directories
                                    //

                                    lpEnd = CheckSlash (m_pScriptsDir);

                                    if (m_bUserScope)
                                        lstrcpy (lpEnd, TEXT("Logon"));
                                    else
                                        lstrcpy (lpEnd, TEXT("Startup"));

                                    if (!CreateNestedDirectory(m_pScriptsDir, NULL))
                                    {
                                        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify: Failed to create scripts sub-directory with %d."),
                                                 GetLastError()));
                                        LocalFree (m_pScriptsDir);
                                        m_pScriptsDir = NULL;
                                        break;
                                    }

                                    if (m_bUserScope)
                                        lstrcpy (lpEnd, TEXT("Logoff"));
                                    else
                                        lstrcpy (lpEnd, TEXT("Shutdown"));

                                    if (!CreateNestedDirectory(m_pScriptsDir, NULL))
                                    {
                                        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify: Failed to create scripts sub-directory with %d."),
                                                 GetLastError()));
                                        LocalFree (m_pScriptsDir);
                                        m_pScriptsDir = NULL;
                                        break;
                                    }

                                    *(lpEnd - 1) = TEXT('\0');
                                }
                                else
                                {
                                   DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify: Failed to get file system path.")));
                                   LocalFree (m_pScriptsDir);
                                   m_pScriptsDir = NULL;
                                }
                            }
                        }

                        if (m_pScriptsDir)
                        {
                            hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                        }
                    }
                }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CScriptsComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < m_dwNameSpaceItemCount; dwIndex++)
    {
        if (m_pNameSpaceItems[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == m_dwNameSpaceItemCount)
        pItem->displayname = NULL;
    else
    {
        pItem->displayname = m_pNameSpaceItems[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CScriptsComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPSCRIPTDATAOBJECT pScriptDataObjectA, pScriptDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObjectB)))
    {
        pScriptDataObjectA->Release();
        return S_FALSE;
    }

    pScriptDataObjectA->GetCookie(&cookie1);
    pScriptDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pScriptDataObjectA->Release();
    pScriptDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (IPersistStreamInit)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    if (m_bUserScope)
        *pClassID = CLSID_ScriptSnapInUser;
    else
        *pClassID = CLSID_ScriptSnapInMachine;

    return S_OK;
}

STDMETHODIMP CScriptsComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CScriptsComponentData::Load(IStream *pStm)
{
    return S_OK;
}


STDMETHODIMP CScriptsComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;
}


STDMETHODIMP CScriptsComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (!pcbSize)
    {
        return E_FAIL;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CScriptsComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (ISnapinHelp)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gptext.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CScriptsComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if (!m_hRoot)
        m_hRoot = hParent;


    if (m_hRoot == hParent)
        dwIndex = 0;
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = (DWORD)item.lParam;
    }

    for (i = 0; i < m_dwNameSpaceItemCount; i++)
    {
        if (m_pNameSpaceItems[i].dwParent == dwIndex)
        {
            BOOL bAdd = TRUE;

            //
            // Need to special case the 2 main root nodes
            //

            if (dwIndex == 0)
            {
                if (m_bUserScope)
                {
                    if (i == 2)
                    {
                        bAdd = FALSE;
                    }
                }
                else
                {
                    if (i == 1)
                    {
                        bAdd = FALSE;
                    }
                }
            }


            //
            // Don't show a node if it has no data
            //

            if ((i == 3) && !m_pRSOPLogon)
            {
                bAdd = FALSE;
            }
            else if ((i == 4) && !m_pRSOPLogoff)
            {
                bAdd = FALSE;
            }
            else if ((i == 5) && !m_pRSOPStartup)
            {
                bAdd = FALSE;
            }
            else if ((i == 6) && !m_pRSOPShutdown)
            {
                bAdd = FALSE;
            }


            if (bAdd)
            {
                item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
                item.displayname = MMC_CALLBACK;
                item.nImage = (i > 2) ? 0 : 3;
                item.nOpenImage = (i > 2) ? 1 : 3;
                item.nState = 0;
                item.cChildren = m_pNameSpaceItems[i].cChildren;
                item.lParam = m_pNameSpaceItems[i].dwID;
                item.relativeID =  hParent;

                m_pScope->InsertItem (&item);

            }
        }
    }


    return S_OK;
}

BOOL CScriptsComponentData::AddRSOPScriptDataNode(LPTSTR lpCommandLine, LPTSTR lpArgs,
                             LPTSTR lpGPOName, LPTSTR lpDate, UINT uiScriptType)
{
    DWORD dwSize;
    LPRSOPSCRIPTITEM lpItem, lpTemp;


    //
    // Calculate the size of the new registry item
    //

    dwSize = sizeof (RSOPSCRIPTITEM);

    if (lpCommandLine) {
        dwSize += ((lstrlen(lpCommandLine) + 1) * sizeof(TCHAR));
    }

    if (lpArgs) {
        dwSize += ((lstrlen(lpArgs) + 1) * sizeof(TCHAR));
    }

    if (lpGPOName) {
        dwSize += ((lstrlen(lpGPOName) + 1) * sizeof(TCHAR));
    }

    if (lpDate) {
        dwSize += ((lstrlen(lpDate) + 1) * sizeof(TCHAR));
    }



    //
    // Allocate space for it
    //

    lpItem = (LPRSOPSCRIPTITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::AddRSOPRegistryDataNode: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    if (lpCommandLine)
    {
        lpItem->lpCommandLine = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPSCRIPTITEM));
        lstrcpy (lpItem->lpCommandLine, lpCommandLine);
    }

    if (lpArgs)
    {
        if (lpCommandLine)
        {
            lpItem->lpArgs = lpItem->lpCommandLine + lstrlen (lpItem->lpCommandLine) + 1;
        }
        else
        {
            lpItem->lpArgs = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPSCRIPTITEM));
        }

        lstrcpy (lpItem->lpArgs, lpArgs);
    }

    if (lpGPOName)
    {
        if (lpArgs)
        {
            lpItem->lpGPOName = lpItem->lpArgs + lstrlen (lpItem->lpArgs) + 1;
        }
        else
        {
            if (lpCommandLine)
            {
                lpItem->lpGPOName = lpItem->lpCommandLine + lstrlen (lpItem->lpCommandLine) + 1;
            }
            else
            {
                lpItem->lpGPOName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPSCRIPTITEM));
            }
        }

        lstrcpy (lpItem->lpGPOName, lpGPOName);
    }

    if (lpDate)
    {
        if (lpGPOName)
        {
            lpItem->lpDate = lpItem->lpGPOName + lstrlen (lpItem->lpGPOName) + 1;
        }
        else
        {
            if (lpArgs)
            {
                lpItem->lpDate = lpItem->lpArgs + lstrlen (lpItem->lpArgs) + 1;
            }
            else
            {
                if (lpCommandLine)
                {
                    lpItem->lpDate = lpItem->lpCommandLine + lstrlen (lpItem->lpCommandLine) + 1;
                }
                else
                {
                    lpItem->lpDate = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPSCRIPTITEM));
                }
            }
        }

        lstrcpy (lpItem->lpDate, lpDate);
    }

    //
    // Add item to the appropriate link list
    //

    switch (uiScriptType)
    {
        case 1:
            if (m_pRSOPLogon)
            {
                lpTemp = m_pRSOPLogon;

                while (lpTemp->pNext)
                {
                    lpTemp = lpTemp->pNext;
                }

                lpTemp->pNext = lpItem;
            }
            else
            {
                m_pRSOPLogon = lpItem;
            }
            break;

        case 2:
            if (m_pRSOPLogoff)
            {
                lpTemp = m_pRSOPLogoff;

                while (lpTemp->pNext)
                {
                    lpTemp = lpTemp->pNext;
                }

                lpTemp->pNext = lpItem;
            }
            else
            {
                m_pRSOPLogoff = lpItem;
            }
            break;

        case 3:
            if (m_pRSOPStartup)
            {
                lpTemp = m_pRSOPStartup;

                while (lpTemp->pNext)
                {
                    lpTemp = lpTemp->pNext;
                }

                lpTemp->pNext = lpItem;
            }
            else
            {
                m_pRSOPStartup = lpItem;
            }
            break;

        case 4:
            if (m_pRSOPShutdown)
            {
                lpTemp = m_pRSOPShutdown;

                while (lpTemp->pNext)
                {
                    lpTemp = lpTemp->pNext;
                }

                lpTemp->pNext = lpItem;
            }
            else
            {
                m_pRSOPShutdown = lpItem;
            }
            break;
    }

    return TRUE;
}


VOID CScriptsComponentData::FreeRSOPScriptData(VOID)
{
    LPRSOPSCRIPTITEM lpTemp;


    if (m_pRSOPLogon)
    {
        do {
            lpTemp = m_pRSOPLogon->pNext;
            LocalFree (m_pRSOPLogon);
            m_pRSOPLogon = lpTemp;

        } while (lpTemp);
    }

    if (m_pRSOPLogoff)
    {
        do {
            lpTemp = m_pRSOPLogoff->pNext;
            LocalFree (m_pRSOPLogoff);
            m_pRSOPLogoff = lpTemp;

        } while (lpTemp);
    }

    if (m_pRSOPStartup)
    {
        do {
            lpTemp = m_pRSOPStartup->pNext;
            LocalFree (m_pRSOPStartup);
            m_pRSOPStartup = lpTemp;

        } while (lpTemp);
    }

    if (m_pRSOPShutdown)
    {
        do {
            lpTemp = m_pRSOPShutdown->pNext;
            LocalFree (m_pRSOPShutdown);
            m_pRSOPShutdown = lpTemp;

        } while (lpTemp);
    }
}

HRESULT CScriptsComponentData::InitializeRSOPScriptsData(VOID)
{
    BSTR pLanguage = NULL, pQuery = NULL;
    BSTR pScriptList = NULL, pScript = NULL, pArgs = NULL, pExecutionTime = NULL;
    BSTR pGPOid = NULL, pNamespace = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2], *pObject;
    HRESULT hr;
    ULONG ulRet;
    VARIANT varScriptList, varScript, varArgs, varExecutionTime;
    VARIANT varGPOid;
    SAFEARRAY * pSafeArray;
    IWbemLocator *pIWbemLocator = NULL;
    IWbemServices *pIWbemServices = NULL;
    LPTSTR lpGPOName;
    TCHAR szQuery[100];
    UINT uiOrder, uiScriptType, uiIndex;
    LONG lIndex;
    IUnknown *pItem;



    DebugMsg((DM_VERBOSE, TEXT("CScriptsComponentData::InitializeRSOPScriptsData:  Entering")));

    //
    // Allocate BSTRs for the query language and for the query itself
    //

    pLanguage = SysAllocString (TEXT("WQL"));

    if (!pLanguage)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for language")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pScriptList = SysAllocString (TEXT("scriptList"));

    if (!pScriptList)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for scriptList")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    pGPOid = SysAllocString (TEXT("GPOID"));

    if (!pGPOid)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for GPO id")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    pScript = SysAllocString (TEXT("script"));

    if (!pScript)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for script")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pArgs = SysAllocString (TEXT("arguments"));

    if (!pArgs)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for arguments")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pExecutionTime = SysAllocString (TEXT("executionTime"));

    if (!pExecutionTime)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for execution time")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Create an instance of the WMI locator service
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Allocate a BSTR for the namespace
    //

    pNamespace = SysAllocString (m_pszNamespace);

    if (!pNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for namespace")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Connect to the server
    //

    hr = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL,
                                      &pIWbemServices);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: ConnectServer failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // We need to read two sets of data.  Either logon & logoff scripts
    // or startup & shutdown scripts.
    //

    for (uiIndex = 0; uiIndex < 2; uiIndex++)
    {

        //
        // Set the uiScriptType to the correct value.  These values are defined
        // in rsop.mof
        //

        if (m_bUserScope)
        {
            if (uiIndex == 0)
            {
                uiScriptType = 1;  //Logon
            }
            else
            {
                uiScriptType = 2;  //Logoff
            }
        }
        else
        {
            if (uiIndex == 0)
            {
                uiScriptType = 3;  //Startup
            }
            else
            {
                uiScriptType = 4;  //Shutdown
            }
        }


        //
        // Loop through the items bumping the order number by 1 each time
        //

        uiOrder = 1;


        while (TRUE)
        {

            //
            // Build the query
            //

            wsprintf (szQuery, TEXT("SELECT * FROM RSOP_ScriptPolicySetting WHERE scriptType=\"%d\" AND scriptOrder=\"%d\""),
                      uiScriptType, uiOrder);

            pQuery = SysAllocString (szQuery);

            if (!pQuery)
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for query")));
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                goto Exit;
            }


            //
            // Execute the query
            //

            hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnum);


            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to query for %s with 0x%x"),
                          pQuery, hr));
                goto Exit;
            }


            //
            // Get the first (and only) item
            //

            hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);


            //
            // Check for the "data not available case"
            //

            if ((hr != S_OK) || (ulRet == 0))
            {
                pEnum->Release();
                pEnum = NULL;
                goto LoopAgain;
            }


            //
            // Get the scriptList
            //

            hr = pObjects[0]->Get (pScriptList, 0, &varScriptList, NULL, NULL);

            if (SUCCEEDED(hr))
            {

                //
                // Get the GPO ID
                //

                hr = pObjects[0]->Get (pGPOid, 0, &varGPOid, NULL, NULL);

                if (SUCCEEDED(hr))
                {

                    //
                    // Get the GPO friendly name from the GPOID
                    //

                    hr = GetGPOFriendlyName (pIWbemServices, varGPOid.bstrVal,
                                             pLanguage, &lpGPOName);

                    if (SUCCEEDED(hr))
                    {

                        //
                        // Loop through the script entries
                        //

                        pSafeArray = varScriptList.parray;

                        for (lIndex=0; lIndex < (LONG)pSafeArray->rgsabound[0].cElements; lIndex++)
                        {
                            SafeArrayGetElement (pSafeArray, &lIndex, &pItem);

                            hr = pItem->QueryInterface (IID_IWbemClassObject, (LPVOID *)&pObject);

                            if (SUCCEEDED(hr))
                            {

                                //
                                // Get the script command line
                                //

                                hr = pObject->Get (pScript, 0, &varScript, NULL, NULL);

                                if (SUCCEEDED(hr))
                                {

                                    //
                                    // Get the arguments
                                    //

                                    hr = pObject->Get (pArgs, 0, &varArgs, NULL, NULL);

                                    if (SUCCEEDED(hr))
                                    {
                                        TCHAR szDate[20];
                                        TCHAR szTime[20];
                                        TCHAR szBuffer[45] = {0};
                                        XBStr xbstrWbemTime;
                                        SYSTEMTIME SysTime;
                                        FILETIME FileTime, LocalFileTime;


                                        //
                                        // Get the execution time
                                        //

                                        hr = pObject->Get (pExecutionTime, 0, &varExecutionTime, NULL, NULL);

                                        if (SUCCEEDED(hr))
                                        {
                                            xbstrWbemTime = varExecutionTime.bstrVal;

                                            hr = WbemTimeToSystemTime(xbstrWbemTime, SysTime);

                                            if (SUCCEEDED(hr))
                                            {
                                                if (SysTime.wMonth != 0)
                                                {
                                                    SystemTimeToFileTime (&SysTime, &FileTime);
                                                    FileTimeToLocalFileTime (&FileTime, &LocalFileTime);
                                                    FileTimeToSystemTime (&LocalFileTime, &SysTime);

                                                    GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE,
                                                                   &SysTime, NULL, szDate, 20);

                                                    GetTimeFormat (LOCALE_USER_DEFAULT, TIME_NOSECONDS,
                                                                   &SysTime, NULL, szTime, 20);

                                                    wsprintf (szBuffer, TEXT("%s %s"), szDate, szTime);
                                                }
                                                else
                                                {
                                                    lstrcpy (szBuffer, TEXT(" "));
                                                }
                                            }

                                            VariantClear (&varExecutionTime);
                                        }


                                        AddRSOPScriptDataNode(varScript.bstrVal,
                                                              (varArgs.vt == VT_NULL) ? NULL : varArgs.bstrVal,
                                                              lpGPOName, szBuffer, uiScriptType);

                                        VariantClear (&varArgs);
                                    }

                                    VariantClear (&varScript);
                                }

                                pObject->Release();
                            }
                        }

                        LocalFree (lpGPOName);
                    }

                    VariantClear (&varGPOid);
                }

                VariantClear (&varScriptList);
            }

            pEnum->Release();
            pEnum = NULL;
            pObjects[0]->Release();
            SysFreeString (pQuery);
            pQuery = NULL;
            uiOrder++;
        }

LoopAgain:
        hr = S_OK;
    }

    hr = S_OK;


Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pIWbemLocator)
    {
        pIWbemLocator->Release();
    }

    if (pIWbemServices)
    {
        pIWbemServices->Release();
    }

    if (pLanguage)
    {
        SysFreeString (pLanguage);
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (pScriptList)
    {
        SysFreeString (pScriptList);
    }

    if (pScript)
    {
        SysFreeString (pScript);
    }

    if (pArgs)
    {
        SysFreeString (pArgs);
    }

    if (pExecutionTime)
    {
        SysFreeString (pExecutionTime);
    }

    if (pGPOid)
    {
        SysFreeString (pGPOid);
    }

    DebugMsg((DM_VERBOSE, TEXT("CScriptsComponentData::InitializeRSOPScriptsData:  Leaving")));

    return hr;
}

HRESULT CScriptsComponentData::GetGPOFriendlyName(IWbemServices *pIWbemServices,
                                                LPTSTR lpGPOID, BSTR pLanguage,
                                                LPTSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;


    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //

    lpQuery = (LPTSTR) LocalAlloc (LPTR, ((lstrlen(lpGPOID) + 50) * sizeof(TCHAR)));

    if (!lpQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to allocate memory for unicode query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    wsprintf (lpQuery, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);


    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    pObjects[0]->Release();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Save the name
    //

    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(varGPOName.bstrVal) + 1) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to allocate memory for GPO Name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    lstrcpy (*pGPOName, varGPOName.bstrVal);

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}

VOID CScriptsComponentData::DumpRSOPScriptsData(LPRSOPSCRIPTITEM lpList)
{
    DebugMsg((DM_VERBOSE, TEXT("CScriptsComponentData::DumpRSOPScriptsData: *** Entering ***")));

    while (lpList)
    {
        if (lpList->lpCommandLine)
        {
            OutputDebugString (TEXT("Script:    "));
            OutputDebugString (lpList->lpCommandLine);

            if (lpList->lpArgs)
            {
                OutputDebugString (TEXT(" "));
                OutputDebugString (lpList->lpArgs);
            }

            OutputDebugString (TEXT("\n"));
        }
        else
           OutputDebugString (TEXT("NULL command line\n"));


        OutputDebugString (TEXT("GPO Name:  "));
        if (lpList->lpGPOName)
            OutputDebugString (lpList->lpGPOName);
        else
            OutputDebugString (TEXT("NULL GPO Name"));

        OutputDebugString (TEXT("\n"));

        OutputDebugString (TEXT("Execution Date:  "));
        if (lpList->lpDate)
            OutputDebugString (lpList->lpDate);
        else
            OutputDebugString (TEXT("NULL Execution Date"));

        OutputDebugString (TEXT("\n\n"));

        lpList = lpList->pNext;
    }

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CScriptsComponentDataCF::CScriptsComponentDataCF(BOOL bUser, BOOL bRSOP)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_bUserScope = bUser;
    m_bRSOP = bRSOP;
}

CScriptsComponentDataCF::~CScriptsComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CScriptsComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CScriptsComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CScriptsComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CScriptsComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CScriptsComponentData *pComponentData = new CScriptsComponentData(m_bUserScope, m_bRSOP); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref
    return hr;
}


STDMETHODIMP
CScriptsComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object creation (IClassFactory)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CreateScriptsComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (IsEqualCLSID (rclsid, CLSID_ScriptSnapInMachine)) {

        CScriptsComponentDataCF *pComponentDataCF = new CScriptsComponentDataCF(FALSE, FALSE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_ScriptSnapInUser)) {

        CScriptsComponentDataCF *pComponentDataCF = new CScriptsComponentDataCF(TRUE, FALSE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPScriptSnapInMachine)) {

        CScriptsComponentDataCF *pComponentDataCF = new CScriptsComponentDataCF(FALSE, TRUE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref
        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPScriptSnapInUser)) {

        CScriptsComponentDataCF *pComponentDataCF = new CScriptsComponentDataCF(TRUE, TRUE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }


    return CLASS_E_CLASSNOTAVAILABLE;
}



unsigned int CScriptsSnapIn::m_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CScriptsSnapIn::CScriptsSnapIn(CScriptsComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumn1Size = 180;
    m_nColumn2Size = 180;
    m_nColumn3Size = 160;
    m_nColumn4Size = 200;
    m_lViewMode = LVS_REPORT;

    LoadString(g_hInstance, IDS_NAME, m_column1, ARRAYSIZE(m_column1));
    LoadString(g_hInstance, IDS_PARAMETERS, m_column2, ARRAYSIZE(m_column2));
    LoadString(g_hInstance, IDS_LASTEXECUTED, m_column3, ARRAYSIZE(m_column3));
    LoadString(g_hInstance, IDS_GPONAME, m_column4, ARRAYSIZE(m_column4));

}

CScriptsSnapIn::~CScriptsSnapIn()
{
    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CScriptsSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CScriptsSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CScriptsSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation (IComponent)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));

    return S_OK;
}

STDMETHODIMP CScriptsSnapIn::Destroy(MMC_COOKIE cookie)
{
    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CScriptsSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;


    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
        if (hbmp16x16)
        {
            hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

            if (hbmp32x32)
            {
                LPIMAGELIST pImageList = (LPIMAGELIST) arg;

                // Set the images
                pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                                  reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                                  0, RGB(255, 0, 255));

                DeleteObject(hbmp32x32);
            }

            DeleteObject(hbmp16x16);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPSCRIPTDATAOBJECT pScriptDataObject;
            MMC_COOKIE cookie;
            INT i, iDescStringID;
            ULONG ulCount = 0;
            LPRSOPSCRIPTITEM lpTemp;
            LPSCRIPTRESULTITEM lpScriptItem;
            TCHAR szDesc[100], szFullDesc[120];

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IScriptDataObject, (LPVOID *)&pScriptDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pScriptDataObject->GetCookie(&cookie);

            pScriptDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumn1Size);

            if (cookie > 2)
            {
                m_pHeader->InsertColumn(1, m_column2, LVCFMT_LEFT, m_nColumn2Size);
                m_pHeader->InsertColumn(2, m_column3, LVCFMT_LEFT, m_nColumn3Size);
                m_pHeader->InsertColumn(3, m_column4, LVCFMT_LEFT, m_nColumn4Size);
            }

            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < m_pcd->m_pNameSpaceItems[cookie].cResultItems; i++)
            {
                lpScriptItem = (LPSCRIPTRESULTITEM) LocalAlloc (LPTR, sizeof(SCRIPTRESULTITEM));

                if (lpScriptItem)
                {
                    lpScriptItem->lpResultItem = &m_pcd->m_pNameSpaceItems[cookie].pResultItems[i];
                    lpScriptItem->iDescStringID = m_pcd->m_pNameSpaceItems[cookie].pResultItems[i].iDescStringID;
                    lpScriptItem->pNodeID = m_pcd->m_pNameSpaceItems[cookie].pNodeID;

                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = m_pcd->m_pNameSpaceItems[cookie].pResultItems[i].iImage;
                    resultItem.lParam = (LPARAM) lpScriptItem;
                    m_pResult->InsertItem(&resultItem);
                }
            }


            if (cookie > 2)
            {
                if (cookie == 3)
                {
                    lpTemp = m_pcd->m_pRSOPLogon;
                    iDescStringID = IDS_LOGON_DESC;
                }
                else if (cookie == 4)
                {
                    lpTemp = m_pcd->m_pRSOPLogoff;
                    iDescStringID = IDS_LOGOFF_DESC;
                }
                else if (cookie == 5)
                {
                    lpTemp = m_pcd->m_pRSOPStartup;
                    iDescStringID = IDS_STARTUP_DESC;
                }
                else
                {
                    lpTemp = m_pcd->m_pRSOPShutdown;
                    iDescStringID = IDS_SHUTDOWN_DESC;
                }


                while (lpTemp)
                {
                    lpScriptItem = (LPSCRIPTRESULTITEM) LocalAlloc (LPTR, sizeof(SCRIPTRESULTITEM));

                    if (lpScriptItem)
                    {
                        lpScriptItem->lpRSOPScriptItem = lpTemp;
                        lpScriptItem->iDescStringID = iDescStringID;
                        lpScriptItem->pNodeID = m_pcd->m_pNameSpaceItems[cookie].pNodeID;

                        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                        resultItem.str = MMC_CALLBACK;
                        resultItem.nImage = 3;
                        resultItem.lParam = (LPARAM) lpScriptItem;

                        if (SUCCEEDED(m_pResult->InsertItem(&resultItem)))
                        {
                            if (lpTemp->lpArgs)
                            {
                                resultItem.mask = RDI_STR | RDI_PARAM;
                                resultItem.str = MMC_CALLBACK;
                                resultItem.bScopeItem = FALSE;
                                resultItem.nCol = 1;
                                resultItem.lParam = (LPARAM) lpScriptItem;

                                m_pResult->SetItem(&resultItem);
                            }

                            if (lpTemp->lpDate)
                            {
                                resultItem.mask = RDI_STR | RDI_PARAM;
                                resultItem.str = MMC_CALLBACK;
                                resultItem.bScopeItem = FALSE;
                                resultItem.nCol = 2;
                                resultItem.lParam = (LPARAM) lpScriptItem;

                                m_pResult->SetItem(&resultItem);
                            }

                            if (lpTemp->lpGPOName)
                            {
                                resultItem.mask = RDI_STR | RDI_PARAM;
                                resultItem.str = MMC_CALLBACK;
                                resultItem.bScopeItem = FALSE;
                                resultItem.nCol = 3;
                                resultItem.lParam = (LPARAM) lpScriptItem;

                                m_pResult->SetItem(&resultItem);
                            }
                        }
                    }

                    lpTemp = lpTemp->pNext;
                    ulCount++;
                }


                LoadString(g_hInstance, IDS_DESCTEXT, szDesc, ARRAYSIZE(szDesc));
                wsprintf (szFullDesc, szDesc, ulCount);
                m_pResult->SetDescBarText(szFullDesc);
            }

        }
        else
        {
            INT i = 0;
            RESULTDATAITEM resultItem;


            while (TRUE)
            {
                ZeroMemory (&resultItem, sizeof(resultItem));
                resultItem.mask = RDI_PARAM;
                resultItem.nIndex = i;
                hr = m_pResult->GetItem(&resultItem);

                if (hr != S_OK)
                {
                    break;
                }

                if (!resultItem.bScopeItem)
                {
                    LocalFree ((LPSCRIPTRESULTITEM)resultItem.lParam);
                }
                i++;
            }

            m_pResult->DeleteAllRsltItems();

            m_pHeader->GetColumnWidth(0, &m_nColumn1Size);
            m_pHeader->GetColumnWidth(0, &m_nColumn2Size);
            m_pHeader->GetColumnWidth(0, &m_nColumn3Size);
            m_pHeader->GetColumnWidth(0, &m_nColumn4Size);
            m_pResult->GetViewMode(&m_lViewMode);

            m_pResult->SetDescBarText(L"");
        }
        break;


    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPSCRIPTDATAOBJECT pScriptDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IScriptDataObject, (LPVOID *)&pScriptDataObject);

            if (FAILED(hr))
                break;

            pScriptDataObject->GetType(&type);
            pScriptDataObject->GetCookie(&cookie);

            pScriptDataObject->Release();


            //
            // If this is a GPE result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if (type == CCT_SCOPE)
            {
                if (cookie == 0)
                {
                    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                }
            }
            else
            {
                if (!m_pcd->m_bRSOP)
                {
                    if (HIWORD(arg))
                    {
                        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
                    }
                }
            }

        }
        break;

    case MMCN_CONTEXTHELP:
        {

        if (m_pDisplayHelp)
        {
            LPSCRIPTDATAOBJECT pScriptDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;
            LPOLESTR pszHelpTopic;


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IScriptDataObject, (LPVOID *)&pScriptDataObject);

            if (FAILED(hr))
                break;

            pScriptDataObject->Release();


            //
            // Display the scripts help page
            //

            pszHelpTopic = (LPOLESTR) CoTaskMemAlloc (50 * sizeof(WCHAR));

            if (pszHelpTopic)
            {
                lstrcpy (pszHelpTopic, TEXT("gpedit.chm::/scripts.htm"));
                m_pDisplayHelp->ShowTopic (pszHelpTopic);
            }
        }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }


    return hr;
}

STDMETHODIMP CScriptsSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                    pResult->str = m_pcd->m_pNameSpaceItems[pResult->lParam].szDisplayName;
                else
                    pResult->str = L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = (pResult->lParam > 2) ? 0 : 3;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    if (m_pcd->m_bRSOP)
                    {
                        LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                        pResult->str = lpItem->lpRSOPScriptItem->lpCommandLine;
                    }
                    else
                    {
                        LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                        if (lpItem->lpResultItem->szDisplayName[0] == TEXT('\0'))
                        {
                            LoadString (g_hInstance, lpItem->lpResultItem->iStringID,
                                        lpItem->lpResultItem->szDisplayName,
                                        MAX_DISPLAYNAME_SIZE);
                        }

                        pResult->str = lpItem->lpResultItem->szDisplayName;
                    }
                }

                if (pResult->nCol == 1)
                {
                    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                    pResult->str = lpItem->lpRSOPScriptItem->lpArgs;
                }

                if (pResult->nCol == 2)
                {
                    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                    pResult->str = lpItem->lpRSOPScriptItem->lpDate;
                }

                if (pResult->nCol == 3)
                {
                    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                    pResult->str = lpItem->lpRSOPScriptItem->lpGPOName;
                }


                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CScriptsSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CScriptsSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CScriptsSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPSCRIPTDATAOBJECT pScriptDataObjectA, pScriptDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObjectB)))
    {
        pScriptDataObjectA->Release();
        return S_FALSE;
    }

    pScriptDataObjectA->GetCookie(&cookie1);
    pScriptDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pScriptDataObjectA->Release();
    pScriptDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation (IExtendPropertySheet)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsSnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage[2];
    LPSCRIPTDATAOBJECT pScriptDataObject;
    LPSCRIPTINFO lpScriptInfo;
    LPSCRIPTRESULTITEM pItem;
    MMC_COOKIE cookie;


    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObject)))
    {
        return S_OK;
    }


    //
    // Get the cookie
    //

    pScriptDataObject->GetCookie(&cookie);
    pScriptDataObject->Release();


    pItem = (LPSCRIPTRESULTITEM)cookie;


    //
    // Allocate a script info struct to pass to the dialog
    //

    lpScriptInfo = (LPSCRIPTINFO) LocalAlloc (LPTR, sizeof(SCRIPTINFO));

    if (!lpScriptInfo)
    {
        return S_OK;
    }


    lpScriptInfo->pCS = this;


    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.lParam = (LPARAM) lpScriptInfo;


    //
    // Do the page specific stuff
    //

    switch (pItem->lpResultItem->dwID)
    {
        case 2:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCRIPT);
            psp.pfnDlgProc = ScriptDlgProc;
            lpScriptInfo->ScriptType = ScriptType_Logon;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

        case 3:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCRIPT);
            psp.pfnDlgProc = ScriptDlgProc;
            lpScriptInfo->ScriptType = ScriptType_Logoff;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

        case 4:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCRIPT);
            psp.pfnDlgProc = ScriptDlgProc;
            lpScriptInfo->ScriptType = ScriptType_Startup;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

        case 5:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCRIPT);
            psp.pfnDlgProc = ScriptDlgProc;
            lpScriptInfo->ScriptType = ScriptType_Shutdown;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

    }


    return (hr);
}

STDMETHODIMP CScriptsSnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPSCRIPTDATAOBJECT pScriptDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IScriptDataObject,
                                               (LPVOID *)&pScriptDataObject)))
    {
        pScriptDataObject->GetType(&type);
        pScriptDataObject->Release();

        if ((type == CCT_RESULT) && (!m_pcd->m_bRSOP))
            return S_OK;
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CScriptsSnapIn::ScriptDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSCRIPTINFO lpScriptInfo;
    HRESULT hr;


    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szType[30];
            TCHAR szSection[30];
            TCHAR szKeyName[30];
            TCHAR szGPOName[256];
            TCHAR szBuffer1[MAX_PATH + 50];
            TCHAR szBuffer2[2 * MAX_PATH];
            TCHAR szBuffer3[MAX_PATH];
            LPTSTR lpEnd;
            LVCOLUMN lvc;
            LV_ITEM item;
            HWND hLV;
            RECT rc;
            INT iIndex;


            //
            // Save the scriptinfo pointer for future use
            //

            lpScriptInfo = (LPSCRIPTINFO) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpScriptInfo);


            //
            // Query for the GPO display name
            //

            hr = lpScriptInfo->pCS->m_pcd->m_pGPTInformation->GetDisplayName(szGPOName, ARRAYSIZE(szGPOName));

            if (FAILED(hr))
                break;


            //
            // Load the type description
            //

            switch (lpScriptInfo->ScriptType)
            {
                case ScriptType_Logon:
                    LoadString (g_hInstance, IDS_LOGON, szType, ARRAYSIZE(szType));
                    lstrcpy (szSection, TEXT("Logon"));
                    break;

                case ScriptType_Logoff:
                    LoadString (g_hInstance, IDS_LOGOFF, szType, ARRAYSIZE(szType));
                    lstrcpy (szSection, TEXT("Logoff"));
                    break;

                case ScriptType_Startup:
                    LoadString (g_hInstance, IDS_STARTUP, szType, ARRAYSIZE(szType));
                    lstrcpy (szSection, TEXT("Startup"));
                    break;

                case ScriptType_Shutdown:
                    LoadString (g_hInstance, IDS_SHUTDOWN, szType, ARRAYSIZE(szType));
                    lstrcpy (szSection, TEXT("Shutdown"));
                    break;

                default:
                    DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::ScriptDlgProc: Unknown script type.")));
                    hr = E_FAIL;
                    break;
            }

            if (FAILED(hr))
                break;

            //
            // Initialize the title and header
            //

            GetDlgItemText (hDlg, IDC_SCRIPT_TITLE, szBuffer1, ARRAYSIZE(szBuffer1));
            wsprintf (szBuffer2, szBuffer1, szType, szGPOName);
            SetDlgItemText (hDlg, IDC_SCRIPT_TITLE, szBuffer2);

            GetDlgItemText (hDlg, IDC_SCRIPT_HEADING, szBuffer1, ARRAYSIZE(szBuffer1));
            wsprintf (szBuffer2, szBuffer1, szType, szGPOName);
            SetDlgItemText (hDlg, IDC_SCRIPT_HEADING, szBuffer2);


            //
            // Set initial state of buttons
            //

            EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_UP),     FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_DOWN),   FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_EDIT),   FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_REMOVE), FALSE);


            //
            // Set extended LV styles
            //

            hLV = GetDlgItem (hDlg, IDC_SCRIPT_LIST);
            SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                        LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


            //
            // Insert the columns into the listview
            //

            GetClientRect (hLV, &rc);
            LoadString (g_hInstance, IDS_NAME, szBuffer1, ARRAYSIZE(szBuffer1));

            lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.cx = (int)(rc.right * .50);
            lvc.pszText = szBuffer1;
            lvc.cchTextMax = ARRAYSIZE(szBuffer1);
            lvc.iSubItem = 0;

            SendMessage (hLV, LVM_INSERTCOLUMN,  0, (LPARAM) &lvc);


            LoadString (g_hInstance, IDS_PARAMETERS, szBuffer1, ARRAYSIZE(szBuffer1));

            lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.cx = rc.right - lvc.cx;
            lvc.pszText = szBuffer1;
            lvc.cchTextMax = ARRAYSIZE(szBuffer1);
            lvc.iSubItem = 0;

            SendMessage (hLV, LVM_INSERTCOLUMN,  1, (LPARAM) &lvc);


            //
            // Insert existing scripts
            //

            lstrcpy (szBuffer1, lpScriptInfo->pCS->m_pcd->m_pScriptsDir);
            lstrcat (szBuffer1, TEXT("\\"));
            lstrcat (szBuffer1, SCRIPTS_FILE_NAME);

            iIndex = 0;

            while (TRUE)
            {

                //
                // Get the command line
                //

                szBuffer3[0] = TEXT('\0');

                _itot (iIndex, szKeyName, 10);
                lpEnd = szKeyName + lstrlen (szKeyName);
                lstrcpy (lpEnd, TEXT("CmdLine"));

                GetPrivateProfileString (szSection, szKeyName, TEXT(""),
                                         szBuffer3, ARRAYSIZE(szBuffer3),
                                         szBuffer1);

                if (szBuffer3[0] == TEXT('\0'))
                    break;


                //
                // Get the parameters
                //

                szBuffer2[0] = TEXT('\0');
                lstrcpy (lpEnd, TEXT("Parameters"));

                GetPrivateProfileString (szSection, szKeyName, TEXT(""),
                                         szBuffer2, ARRAYSIZE(szBuffer2),
                                         szBuffer1);

                //
                // Add script to the list
                //

                lpScriptInfo->pCS->AddScriptToList (hLV, szBuffer3, szBuffer2);


                //
                // Loop again
                //

                iIndex++;
            }

            //
            // Select the first item
            //

            item.mask = LVIF_STATE;
            item.iItem = 0;
            item.iSubItem = 0;
            item.state = LVIS_SELECTED | LVIS_FOCUSED;
            item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

            SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);


            break;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDC_SCRIPT_UP)
            {
                INT iSrc, iDest;
                LPSCRIPTITEM lpSrc, lpDest;
                HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);
                LVITEM item;

                iSrc = ListView_GetNextItem (hLV, -1,
                                             LVNI_ALL | LVNI_SELECTED);

                if (iSrc != -1)
                {
                    iDest = iSrc - 1;

                    //
                    // Get the current lpScriptItem pointers
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iSrc;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpSrc = (LPSCRIPTITEM) item.lParam;

                    item.mask = LVIF_PARAM;
                    item.iItem = iDest;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpDest = (LPSCRIPTITEM) item.lParam;


                    //
                    // Swap them
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpDest;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpSrc;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }


                    //
                    // Select the item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iSrc, (LPARAM) &item);


                    item.mask = LVIF_STATE;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iDest, (LPARAM) &item);


                    //
                    // Update the listview
                    //

                    ListView_RedrawItems (hLV, iDest, iSrc);

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);

                    SetFocus (hLV);
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_DOWN)
            {
                INT iSrc, iDest;
                LPSCRIPTITEM lpSrc, lpDest;
                HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);
                LVITEM item;

                iSrc = ListView_GetNextItem (hLV, -1,
                                             LVNI_ALL | LVNI_SELECTED);

                if (iSrc != -1)
                {
                    iDest = iSrc + 1;

                    //
                    // Get the current lpScriptItem pointers
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iSrc;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpSrc = (LPSCRIPTITEM) item.lParam;

                    item.mask = LVIF_PARAM;
                    item.iItem = iDest;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpDest = (LPSCRIPTITEM) item.lParam;


                    //
                    // Swap them
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpDest;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpSrc;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }


                    //
                    // Select the item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iSrc, (LPARAM) &item);


                    item.mask = LVIF_STATE;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iDest, (LPARAM) &item);


                    //
                    // Update the listview
                    //

                    ListView_RedrawItems (hLV, iSrc, iDest);

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);


                    SetFocus (hLV);
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_ADD)
            {
                SCRIPTEDITINFO info;
                TCHAR szName[MAX_PATH];
                TCHAR szArgs[2 * MAX_PATH];

                lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpScriptInfo) {
                    break;
                }

                szName[0] = TEXT('\0');
                szArgs[0] = TEXT('\0');

                info.lpScriptInfo = lpScriptInfo;
                info.bEdit = FALSE;
                info.lpName = szName;
                info.lpArgs = szArgs;

                if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_SCRIPT_EDIT),
                                    hDlg, ScriptEditDlgProc, (LPARAM) &info))
                {
                    if (lpScriptInfo->pCS->AddScriptToList (GetDlgItem(hDlg, IDC_SCRIPT_LIST),
                                                           szName, szArgs))
                    {
                        SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        SetFocus (GetDlgItem(hDlg, IDC_SCRIPT_LIST));
                    }
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_EDIT)
            {
                SCRIPTEDITINFO info;
                TCHAR szName[MAX_PATH];
                TCHAR szArgs[2 * MAX_PATH];
                HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);
                INT iIndex;
                LPSCRIPTITEM lpItem;
                LVITEM item;
                DWORD dwSize;


                lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpScriptInfo) {
                    break;
                }


                //
                // Get the selected item
                //

                iIndex = ListView_GetNextItem (hLV, -1, LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {

                    //
                    // Get the script item pointer
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpItem = (LPSCRIPTITEM) item.lParam;


                    //
                    // Put up the edit script dialog
                    //

                    lstrcpy (szName, lpItem->lpName);
                    lstrcpy (szArgs, lpItem->lpArgs);

                    info.lpScriptInfo = lpScriptInfo;
                    info.bEdit = TRUE;
                    info.lpName = szName;
                    info.lpArgs = szArgs;

                    if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_SCRIPT_EDIT),
                                        hDlg, ScriptEditDlgProc, (LPARAM) &info))
                    {

                        //
                        // Free old pointer
                        //

                        LocalFree (lpItem);


                        //
                        // Setup new pointer
                        //

                        dwSize = sizeof(SCRIPTITEM);
                        dwSize += ((lstrlen(szName) + 1) * sizeof(TCHAR));
                        dwSize += ((lstrlen(szArgs) + 1) * sizeof(TCHAR));

                        lpItem = (LPSCRIPTITEM) LocalAlloc (LPTR, dwSize);

                        if (!lpItem)
                            break;


                        lpItem->lpName = (LPTSTR) (((LPBYTE)lpItem) + sizeof(SCRIPTITEM));
                        lstrcpy (lpItem->lpName, szName);

                        lpItem->lpArgs = lpItem->lpName + lstrlen (lpItem->lpName) + 1;
                        lstrcpy (lpItem->lpArgs, szArgs);


                        //
                        // Set the new script item pointer
                        //

                        item.mask = LVIF_PARAM;
                        item.iItem = iIndex;
                        item.iSubItem = 0;
                        item.lParam = (LPARAM) lpItem;

                        if (!ListView_SetItem (hLV, &item))
                        {
                            break;
                        }


                        //
                        // Update the display
                        //

                        ListView_Update (hLV, iIndex);
                        SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        SetFocus (GetDlgItem(hDlg, IDC_SCRIPT_LIST));
                    }
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_REMOVE)
            {
                INT iIndex, iNext;
                HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);
                LPSCRIPTITEM lpItem;
                LVITEM item;


                //
                // Get the selected item
                //

                iIndex = ListView_GetNextItem (hLV, -1, LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {

                    //
                    // Get the script item pointer
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpItem = (LPSCRIPTITEM) item.lParam;


                    //
                    // Select the next item
                    //

                    iNext = ListView_GetNextItem (hLV, iIndex, LVNI_ALL);

                    item.mask = LVIF_STATE;
                    item.iItem = iNext;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iNext, (LPARAM) &item);

                    ListView_DeleteItem (hLV, iIndex);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                    SetFocus (hLV);
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_SHOW)
            {
                TCHAR szPath[MAX_PATH];
                LPTSTR lpEnd;

                lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpScriptInfo) {
                    break;
                }

                lstrcpy (szPath, lpScriptInfo->pCS->m_pcd->m_pScriptsDir);
                lpEnd = CheckSlash (szPath);

                switch (lpScriptInfo->ScriptType)
                {
                    case ScriptType_Logon:
                        lstrcpy (lpEnd, TEXT("Logon"));
                        break;

                    case ScriptType_Logoff:
                        lstrcpy (lpEnd, TEXT("Logoff"));
                        break;

                    case ScriptType_Startup:
                        lstrcpy (lpEnd, TEXT("Startup"));
                        break;

                    case ScriptType_Shutdown:
                        lstrcpy (lpEnd, TEXT("Shutdown"));
                        break;
                }


                SetCursor (LoadCursor(NULL, IDC_WAIT));
                ShellExecute (hDlg, TEXT("open"), szPath,
                              NULL, NULL, SW_SHOWNORMAL);
                SetCursor (LoadCursor(NULL, IDC_ARROW));
            }
            break;

        case WM_NOTIFY:

            lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpScriptInfo) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case LVN_GETDISPINFO:
                    {
                        NMLVDISPINFO * lpDispInfo = (NMLVDISPINFO *) lParam;
                        LPSCRIPTITEM lpItem = (LPSCRIPTITEM)lpDispInfo->item.lParam;

                        if (lpDispInfo->item.iSubItem == 0)
                        {
                            lpDispInfo->item.pszText = lpItem->lpName;
                        }
                        else
                        {
                            lpDispInfo->item.pszText = lpItem->lpArgs;
                        }
                    }
                    break;

                case LVN_DELETEITEM:
                    {
                    NMLISTVIEW * pLVInfo = (NMLISTVIEW *) lParam;

                    if (pLVInfo->lParam)
                    {
                        LocalFree ((LPTSTR)pLVInfo->lParam);
                    }

                    }
                    break;

                case LVN_ITEMCHANGED:
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    break;

                case PSN_APPLY:
                    lpScriptInfo->pCS->OnApplyNotify (hDlg);

                    // fall through...

                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_REFRESHDISPLAY:
            {
            INT iIndex, iCount;
            HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);


            lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpScriptInfo) {
                break;
            }

            iIndex = ListView_GetNextItem (hLV, -1,
                                           LVNI_ALL | LVNI_SELECTED);

            if (iIndex != -1)
            {
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_REMOVE), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_EDIT), TRUE);

                iCount = ListView_GetItemCount(hLV);

                if (iIndex > 0)
                    EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_UP), TRUE);
                else
                    EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_UP), FALSE);

                if (iIndex < (iCount - 1))
                    EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_DOWN), TRUE);
                else
                    EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_DOWN), FALSE);
            }
            else
            {
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_REMOVE), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_EDIT), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_UP), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_DOWN), FALSE);
            }

            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aScriptsHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aScriptsHelpIds);
            return (TRUE);
    }

    return FALSE;
}

BOOL CScriptsSnapIn::AddScriptToList (HWND hLV, LPTSTR lpName, LPTSTR lpArgs)
{
    LPSCRIPTITEM lpItem;
    LV_ITEM item;
    INT iItem;
    DWORD dwSize;


    dwSize = sizeof(SCRIPTITEM);
    dwSize += ((lstrlen(lpName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpArgs) + 1) * sizeof(TCHAR));

    lpItem = (LPSCRIPTITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem)
        return FALSE;


    lpItem->lpName = (LPTSTR) (((LPBYTE)lpItem) + sizeof(SCRIPTITEM));
    lstrcpy (lpItem->lpName, lpName);

    lpItem->lpArgs = lpItem->lpName + lstrlen (lpItem->lpName) + 1;
    lstrcpy (lpItem->lpArgs, lpArgs);



    //
    // Add the item
    //

    iItem = ListView_GetItemCount(hLV);
    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    item.iItem = iItem;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    item.pszText = LPSTR_TEXTCALLBACK;
    item.lParam = (LPARAM) lpItem;

    ListView_InsertItem (hLV, &item);

    return TRUE;
}

LPTSTR CScriptsSnapIn::GetSectionNames (LPTSTR lpFileName)
{
    DWORD dwSize, dwRead;
    LPTSTR lpNames;


    //
    // Read in the section names
    //

    dwSize = 256;
    lpNames = (LPTSTR) LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

    if (!lpNames)
    {
        return NULL;
    }


    do {
        dwRead = GetPrivateProfileSectionNames (lpNames, dwSize, lpFileName);

        if (dwRead != (dwSize - 2))
        {
            break;
        }

        LocalFree (lpNames);

        dwSize *= 2;
        lpNames = (LPTSTR) LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

        if (!lpNames)
        {
            return FALSE;
        }

     }  while (TRUE);


    if (dwRead == 0)
    {
        LocalFree (lpNames);
        lpNames = NULL;
    }

    return lpNames;
}

BOOL CScriptsSnapIn::OnApplyNotify (HWND hDlg)
{
    HWND hLV = GetDlgItem (hDlg, IDC_SCRIPT_LIST);
    WIN32_FILE_ATTRIBUTE_DATA fad;
    LVITEM item;
    LPSCRIPTITEM lpItem;
    LPSCRIPTINFO lpScriptInfo;
    INT iIndex = -1;
    TCHAR szSection[30];
    TCHAR szKeyName[30];
    TCHAR szBuffer1[MAX_PATH];
    LPTSTR lpEnd, lpNames;
    BOOL bAdd = TRUE;
    INT i = 0;
    HANDLE hFile;
    DWORD dwWritten;
    GUID guidScriptsExt = { 0x42B5FAAE, 0x6536, 0x11d2, {0xAE, 0x5A, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xE3}};
    GUID guidSnapinMach = CLSID_ScriptSnapInMachine;
    GUID guidSnapinUser = CLSID_ScriptSnapInUser;


    lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

    if (!lpScriptInfo) {
        return FALSE;
    }


    //
    // Get the section name
    //

    switch (lpScriptInfo->ScriptType)
    {
        case ScriptType_Logon:
            lstrcpy (szSection, TEXT("Logon"));
            break;

        case ScriptType_Logoff:
            lstrcpy (szSection, TEXT("Logoff"));
            break;

        case ScriptType_Startup:
            lstrcpy (szSection, TEXT("Startup"));
            break;

        case ScriptType_Shutdown:
            lstrcpy (szSection, TEXT("Shutdown"));
            break;

        default:
            return FALSE;
    }


    //
    // Build pathname to scripts ini file
    //

    lstrcpy (szBuffer1, lpScriptInfo->pCS->m_pcd->m_pScriptsDir);
    lstrcat (szBuffer1, TEXT("\\"));
    lstrcat (szBuffer1, SCRIPTS_FILE_NAME);



    //
    // If the scripts.ini file does not exist, then precreate the file
    // using Unicode text so that the WritePrivateProfile* functions
    // preserve the Unicodeness of the file
    //

    if (!GetFileAttributesEx (szBuffer1, GetFileExInfoStandard, &fad))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            hFile = CreateFile(szBuffer1, GENERIC_WRITE, 0, NULL,
                               CREATE_NEW, FILE_ATTRIBUTE_HIDDEN, NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                WriteFile(hFile, L"\xfeff\r\n", 3 * sizeof(WCHAR), &dwWritten, NULL);
                CloseHandle(hFile);
            }
        }
    }


    //
    // Delete the old information in the section
    //

    if (!WritePrivateProfileSection(szSection, NULL, szBuffer1))
    {
        TCHAR szTitle[50];
        TCHAR szBuffer1[200],szBuffer2[220];

        DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::OnApplyNotify: Failed to delete previous %s section in ini file with %d"),
                 szSection, GetLastError()));

        LoadString (g_hInstance, IDS_SCRIPTS_NAME, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SAVEFAILED, szBuffer1, ARRAYSIZE(szBuffer1));
        wsprintf (szBuffer2, szBuffer1, GetLastError());

        MessageBox (hDlg, szBuffer2, szTitle, MB_OK | MB_ICONERROR);

        return FALSE;
    }


    //
    // Enumerate through the items
    //

    while ((iIndex = ListView_GetNextItem (hLV, iIndex, LVNI_ALL)) != -1)
    {
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hLV, &item))
        {
            continue;
        }

        lpItem = (LPSCRIPTITEM) item.lParam;

        _itot (i, szKeyName, 10);
        lpEnd = szKeyName + lstrlen (szKeyName);
        lstrcpy (lpEnd, TEXT("CmdLine"));

        if (!WritePrivateProfileString (szSection, szKeyName, lpItem->lpName, szBuffer1))
        {
            DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::OnApplyNotify: Failed to save command line in ini file with %d"),
                     GetLastError()));
        }


        lstrcpy (lpEnd, TEXT("Parameters"));
        if (!WritePrivateProfileString (szSection, szKeyName, lpItem->lpArgs, szBuffer1))
        {
            if (lpItem->lpArgs && (*lpItem->lpArgs))
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::OnApplyNotify: Failed to save parameters in ini file with %d"),
                         GetLastError()));
            }
        }

        i++;
    }


    //
    // If we didn't write any command lines to scripts.ini,
    // then check if our counterpart is also empty.  If so,
    // we can remove the scripts extension from the GPO
    //

    if (i == 0)
    {
        BOOL bFound =  FALSE;

        lpNames = GetSectionNames (szBuffer1);

        if (lpNames)
        {

            //
            // Reverse the section name we are looking for
            //

            switch (lpScriptInfo->ScriptType)
            {
                case ScriptType_Logon:
                    lstrcpy (szSection, TEXT("Logoff"));
                    break;

                case ScriptType_Logoff:
                    lstrcpy (szSection, TEXT("Logon"));
                    break;

                case ScriptType_Startup:
                    lstrcpy (szSection, TEXT("Shutdown"));
                    break;

                case ScriptType_Shutdown:
                    lstrcpy (szSection, TEXT("Startup"));
                    break;

                default:
                    return FALSE;
            }


            //
            // See if the opposite name is in the list of names returned
            //

            lpEnd = lpNames;

            while (*lpEnd)
            {
                if (!lstrcmpi (lpEnd, szSection))
                {
                    bFound = TRUE;
                    break;
                }

                lpEnd = lpEnd + lstrlen (lpEnd);
            }

            if (!bFound)
            {
                bAdd = FALSE;
            }

            LocalFree (lpNames);
        }
        else
        {
            bAdd = FALSE;
        }
    }

    SetFileAttributes (szBuffer1, FILE_ATTRIBUTE_HIDDEN);

    m_pcd->m_pGPTInformation->PolicyChanged( !m_pcd->m_bUserScope,
                                             bAdd,
                                             &guidScriptsExt,
                                             m_pcd->m_bUserScope ? &guidSnapinUser
                                                                 : &guidSnapinMach);

    return TRUE;
}


INT_PTR CALLBACK CScriptsSnapIn::ScriptEditDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSCRIPTEDITINFO lpInfo;
    HRESULT hr;


    switch (message)
    {
        case WM_INITDIALOG:
        {
            //
            // Save the ScriptEditInfo pointer for future use
            //

            lpInfo = (LPSCRIPTEDITINFO) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpInfo);
            EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);

            if (lpInfo->bEdit)
            {
                TCHAR szTitle[100];

                LoadString (g_hInstance, IDS_SCRIPT_EDIT, szTitle, ARRAYSIZE(szTitle));
                SetWindowText (hDlg, szTitle);

                SetDlgItemText (hDlg, IDC_SCRIPT_NAME, lpInfo->lpName);
                SetDlgItemText (hDlg, IDC_SCRIPT_ARGS, lpInfo->lpArgs);
            }

            break;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                lpInfo = (LPSCRIPTEDITINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpInfo) {
                    break;
                }

                lpInfo->lpName[0] = TEXT('\0');
                GetDlgItemText (hDlg, IDC_SCRIPT_NAME, lpInfo->lpName, MAX_PATH);

                lpInfo->lpArgs[0] = TEXT('\0');
                GetDlgItemText (hDlg, IDC_SCRIPT_ARGS, lpInfo->lpArgs, 2 * MAX_PATH);

                EndDialog (hDlg, TRUE);
                return TRUE;
            }

            else if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog (hDlg, FALSE);
                return TRUE;
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_BROWSE)
            {
                OPENFILENAME ofn;
                TCHAR szFilter[100];
                TCHAR szTitle[100];
                TCHAR szFile[MAX_PATH];
                TCHAR szPath[MAX_PATH];
                LPTSTR lpTemp, lpEnd;
                DWORD dwStrLen;

                lpInfo = (LPSCRIPTEDITINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpInfo) {
                    break;
                }

                lstrcpy (szPath, lpInfo->lpScriptInfo->pCS->m_pcd->m_pScriptsDir);
                lpEnd = CheckSlash (szPath);

                switch (lpInfo->lpScriptInfo->ScriptType)
                {
                    case ScriptType_Logon:
                        lstrcpy (lpEnd, TEXT("Logon"));
                        break;

                    case ScriptType_Logoff:
                        lstrcpy (lpEnd, TEXT("Logoff"));
                        break;

                    case ScriptType_Startup:
                        lstrcpy (lpEnd, TEXT("Startup"));
                        break;

                    case ScriptType_Shutdown:
                        lstrcpy (lpEnd, TEXT("Shutdown"));
                        break;
                }


                //
                // Prompt for the script file
                //

                LoadString (g_hInstance, IDS_SCRIPT_FILTER, szFilter, ARRAYSIZE(szFilter));
                LoadString (g_hInstance, IDS_BROWSE, szTitle, ARRAYSIZE(szTitle));


                lpTemp = szFilter;

                while (*lpTemp)
                {
                    if (*lpTemp == TEXT('#'))
                        *lpTemp = TEXT('\0');

                    lpTemp++;
                }

                ZeroMemory (&ofn, sizeof(ofn));
                szFile[0] = TEXT('\0');
                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner = hDlg;
                ofn.hInstance = g_hInstance;
                ofn.lpstrFilter = szFilter;
                ofn.nFilterIndex = 2;
                ofn.lpstrFile = szFile;
                ofn.nMaxFile = ARRAYSIZE(szFile);
                ofn.lpstrInitialDir = szPath;
                ofn.lpstrTitle = szTitle;
                ofn.Flags = OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_EXPLORER;

                if (!GetOpenFileName (&ofn))
                {
                    return FALSE;
                }

                dwStrLen = lstrlen (szPath);

                if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                   szPath, dwStrLen, szFile, dwStrLen) == 2)
                    SetDlgItemText (hDlg, IDC_SCRIPT_NAME, (szFile + dwStrLen + 1));
                else
                    SetDlgItemText (hDlg, IDC_SCRIPT_NAME, szFile);
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_NAME)
            {
                if (HIWORD(wParam) == EN_UPDATE)
                {
                    if (GetWindowTextLength (GetDlgItem(hDlg, IDC_SCRIPT_NAME)))
                        EnableWindow (GetDlgItem(hDlg, IDOK), TRUE);
                    else
                        EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                }
            }

            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aScriptsEditHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aScriptsEditHelpIds);
            return (TRUE);
    }

    return FALSE;
}


unsigned int CScriptsDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CScriptsDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CScriptsDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CScriptsDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CScriptsDataObject::m_cfDescription    = RegisterClipboardFormat(L"CCF_DESCRIPTION");
unsigned int CScriptsDataObject::m_cfHTMLDetails    = RegisterClipboardFormat(L"CCF_HTML_DETAILS");


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CScriptsDataObject::CScriptsDataObject(CScriptsComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_pcd->AddRef();
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CScriptsDataObject::~CScriptsDataObject()
{
    m_pcd->Release();
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CScriptsDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IScriptDataObject))
    {
        *ppv = (LPSCRIPTDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CScriptsDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CScriptsDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfDescription)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;
            TCHAR szDesc[200];

            if (m_type == CCT_SCOPE)
            {
                LoadString (g_hInstance, m_pcd->m_pNameSpaceItems[m_cookie].iDescStringID, szDesc, ARRAYSIZE(szDesc));
            }
            else
            {
                LPSCRIPTRESULTITEM lpScriptItem = (LPSCRIPTRESULTITEM) m_cookie;

                LoadString (g_hInstance, lpScriptItem->iDescStringID, szDesc, ARRAYSIZE(szDesc));
            }

            IStream *lpStream = lpMedium->pstm;

            if(lpStream)
            {
                hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);
            }
        }
    }
    else if (cf == m_cfHTMLDetails)
    {
        hr = DV_E_TYMED;

        if ((m_type == CCT_RESULT) && !m_pcd->m_bRSOP)
        {
            if (lpMedium->tymed == TYMED_ISTREAM)
            {
                ULONG ulWritten;

                IStream *lpStream = lpMedium->pstm;

                if(lpStream)
                {
                    hr = lpStream->Write(g_szDisplayProperties, lstrlen(g_szDisplayProperties) * sizeof(TCHAR), &ulWritten);
                }
            }
        }
    }
    return hr;

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CScriptsDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CScriptsDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = lpItem->pNodeID;
    else
        pGUID = m_pcd->m_pNameSpaceItems[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CScriptsDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = lpItem->pNodeID;
    else
        pGUID = m_pcd->m_pNameSpaceItems[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CScriptsDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDisplayName[100] = {0};

    if (m_pcd->m_bUserScope)
        LoadStringW (g_hInstance, IDS_SCRIPTS_NAME_USER, szDisplayName, 100);
    else
        LoadStringW (g_hInstance, IDS_SCRIPTS_NAME_MACHINE, szDisplayName, 100);

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CScriptsDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    if (m_pcd->m_bUserScope)
        return Create((LPVOID)&CLSID_ScriptSnapInUser, sizeof(CLSID), lpMedium);
    else
        return Create((LPVOID)&CLSID_ScriptSnapInMachine, sizeof(CLSID), lpMedium);
}



BOOL InitScriptsNameSpace()
{
    DWORD dwIndex;

    for (dwIndex = 1; dwIndex < ARRAYSIZE(g_GPEScriptsNameSpace); dwIndex++)
    {
        LoadString (g_hInstance, g_GPEScriptsNameSpace[dwIndex].iStringID,
                    g_GPEScriptsNameSpace[dwIndex].szDisplayName,
                    MAX_DISPLAYNAME_SIZE);
    }

    for (dwIndex = 1; dwIndex < ARRAYSIZE(g_RSOPScriptsNameSpace); dwIndex++)
    {
        LoadString (g_hInstance, g_RSOPScriptsNameSpace[dwIndex].iStringID,
                    g_RSOPScriptsNameSpace[dwIndex].szDisplayName,
                    MAX_DISPLAYNAME_SIZE);
    }


    return TRUE;
}

const TCHAR szThreadingModel[] = TEXT("Apartment");

HRESULT RegisterScriptExtension (REFGUID clsid, UINT uiStringId, REFGUID rootID, LPTSTR lpSnapInNameIndirect)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szGUID[50];
    DWORD dwDisp, dwValue;
    LONG lResult;
    HKEY hKey;


    //
    // First register the extension
    //

    StringFromGUID2 (clsid, szSnapInKey, 50);

    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    LoadString (g_hInstance, uiStringId, szSnapInName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)g_szSnapInLocation,
                   (lstrlen(g_szSnapInLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register SnapIn with MMC
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)lpSnapInNameIndirect,
                   (lstrlen(lpSnapInNameIndirect) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2 (rootID, szGUID, 50);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegCloseKey (hKey);


    return S_OK;
}

const TCHAR szViewDescript [] = TEXT("MMCViewExt 1.0 Object");
const TCHAR szViewGUID [] = TEXT("{B708457E-DB61-4C55-A92F-0D4B5E9B1224}");

HRESULT RegisterNodeID (REFGUID clsid, REFGUID nodeid)
{
    TCHAR szSnapInKey[50];
    TCHAR szGUID[50];
    TCHAR szSubKey[200];
    DWORD dwDisp;
    LONG lResult;
    HKEY hKey;


    StringFromGUID2 (clsid, szSnapInKey, 50);
    StringFromGUID2 (nodeid, szGUID, 50);

    //
    // Register the node id
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
              szSnapInKey, szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);


    //
    // Register in the NodeTypes key
    //

    StringFromGUID2 (nodeid, szGUID, 50);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);

    //
    // Register for the view extension
    //

    lstrcat (szSubKey, TEXT("\\Extensions\\View"));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szViewGUID, 0, REG_SZ, (LPBYTE)szViewDescript,
                   (lstrlen(szViewDescript) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    return S_OK;
}

HRESULT RegisterScripts(void)
{
    DWORD dwDisp, dwValue;
    LONG lResult;
    HKEY hKey;
    HRESULT hr;
    TCHAR szSnapInName[100];


    //
    // Register the GPE machine extension and it's root node
    //

    hr = RegisterScriptExtension (CLSID_ScriptSnapInMachine, IDS_SCRIPTS_NAME_MACHINE,
                                  NODEID_Machine, TEXT("@gptext.dll,-2"));

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_ScriptSnapInMachine, NODEID_ScriptRootMachine);

    if (hr != S_OK)
    {
        return hr;
    }


    //
    // Register the GPE user extension and it's root node
    //

    hr = RegisterScriptExtension (CLSID_ScriptSnapInUser, IDS_SCRIPTS_NAME_USER,
                                  NODEID_User, TEXT("@gptext.dll,-3"));

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_ScriptSnapInUser, NODEID_ScriptRootUser);

    if (hr != S_OK)
    {
        return hr;
    }


    //
    // Register the RSOP machine extension and it's nodes
    //

    hr = RegisterScriptExtension (CLSID_RSOPScriptSnapInMachine, IDS_SCRIPTS_NAME_MACHINE,
                                  NODEID_RSOPMachine, TEXT("@gptext.dll,-2"));

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInMachine, NODEID_RSOPScriptRootMachine);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInMachine, NODEID_RSOPStartup);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInMachine, NODEID_RSOPShutdown);

    if (hr != S_OK)
    {
        return hr;
    }


    //
    // Register the RSOP user extension and it's nodes
    //

    hr = RegisterScriptExtension (CLSID_RSOPScriptSnapInUser, IDS_SCRIPTS_NAME_USER,
                                  NODEID_RSOPUser, TEXT("@gptext.dll,-3"));

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInUser, NODEID_RSOPScriptRootUser);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInUser, NODEID_RSOPLogon);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInUser, NODEID_RSOPLogoff);

    if (hr != S_OK)
    {
        return hr;
    }


    //
    // Register the client side extension
    //

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{42B5FAAE-6536-11d2-AE5A-0000F87571E3}"),
                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                              NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return SELFREG_E_CLASS;
    }


    LoadString (g_hInstance, IDS_SCRIPTS_NAME, szSnapInName, 100);
    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegSetValueEx (hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("ProcessScriptsGroupPolicy"),
                   (lstrlen(TEXT("ProcessScriptsGroupPolicy")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ProcessGroupPolicyEx"), 0, REG_SZ, (LPBYTE)TEXT("ProcessScriptsGroupPolicyEx"),
                   (lstrlen(TEXT("ProcessScriptsGroupPolicyEx")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("GenerateGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("GenerateScriptsGroupPolicy"),
                   (lstrlen(TEXT("GenerateScriptsGroupPolicy")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("gptext.dll"),
                   (lstrlen(TEXT("gptext.dll")) + 1) * sizeof(TCHAR));

    dwValue = 1;
    RegSetValueEx (hKey, TEXT("NoSlowLink"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegSetValueEx (hKey, TEXT("NotifyLinkTransition"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegCloseKey (hKey);


    return S_OK;
}

HRESULT UnregisterScriptExtension (REFGUID clsid, REFGUID RootNodeID)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;

    StringFromGUID2 (clsid, szSnapInKey, 50);

    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (RootNodeID, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);


    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0,
                              KEY_WRITE, &hKey);


    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }

    return S_OK;
}

HRESULT UnregisterScripts(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;


    //
    // Unregister the GPE machine extension
    //

    UnregisterScriptExtension (CLSID_ScriptSnapInMachine, NODEID_Machine);

    StringFromGUID2 (NODEID_ScriptRootMachine, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // Unregister the GPE user extension
    //

    UnregisterScriptExtension (CLSID_ScriptSnapInUser, NODEID_User);

    StringFromGUID2 (NODEID_ScriptRootUser, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // Unregister the RSOP machine extension
    //

    UnregisterScriptExtension (CLSID_RSOPScriptSnapInMachine, NODEID_RSOPMachine);

    StringFromGUID2 (NODEID_RSOPScriptRootMachine, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (NODEID_RSOPStartup, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (NODEID_RSOPShutdown, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // Unregister the RSOP user extension
    //

    UnregisterScriptExtension (CLSID_RSOPScriptSnapInUser, NODEID_RSOPUser);

    StringFromGUID2 (NODEID_RSOPScriptRootUser, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (NODEID_RSOPLogon, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (NODEID_RSOPLogoff, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // Unregister the client side extension
    //

    RegDeleteKey (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{42B5FAAE-6536-11d2-AE5A-0000F87571E3}"));


    return S_OK;
}

//=============================================================================
//
//  This is the client side extension for scripts which gathers the
//  working directories and stores them in the registry.
//

DWORD AddPathToList(LPTSTR *lpDirs, LPTSTR lpPath)
{
    LPTSTR lpTemp, lpTemp2;
    DWORD dwSize, dwResult = ERROR_SUCCESS;


    DebugMsg((DM_VERBOSE, TEXT("AddPathToList: Adding <%s> to list."), lpPath));

    lpTemp = *lpDirs;

    if (lpTemp)
    {
        dwSize = lstrlen (lpTemp);      // size of original paths
        dwSize++;                       // space for a semicolon
        dwSize += lstrlen (lpPath);     // size of new path
        dwSize++;                       // space for a null terminator


        lpTemp2 = (LPTSTR) LocalReAlloc (lpTemp, (dwSize * sizeof(TCHAR)), LMEM_MOVEABLE | LMEM_ZEROINIT);

        if (lpTemp2)
        {
            lstrcat (lpTemp2, TEXT(";"));
            lstrcat (lpTemp2, lpPath);

            *lpDirs = lpTemp2;
        }
        else
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AddPathToList: Failed to allocate memory with %d."), dwResult));
        }
    }
    else
    {
        lpTemp = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpPath) + 1) * sizeof(TCHAR));

        if (lpTemp)
        {
            lstrcpy (lpTemp, lpPath);
        }
        else
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AddPathToList: Failed to allocate memory with %d."), dwResult));
        }

        *lpDirs = lpTemp;
    }

    return dwResult;
}

DWORD
ProcessScripts( DWORD dwFlags,
                HANDLE hToken,
                HKEY hKeyRoot,
                PGROUP_POLICY_OBJECT pDeletedGPOList,
                PGROUP_POLICY_OBJECT pChangedGPOList,
                BOOL *pbAbort,
                BOOL bRSoPPlanningMode,
                IWbemServices* pWbemServices,
                HRESULT*       phrRsopStatus );

DWORD ProcessScriptsGroupPolicy (DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
                                PGROUP_POLICY_OBJECT pDeletedGPOList,
                                PGROUP_POLICY_OBJECT pChangedGPOList,
                                ASYNCCOMPLETIONHANDLE pHandle, BOOL *pbAbort,
                                PFNSTATUSMESSAGECALLBACK pStatusCallback)
{
    HRESULT hrRSoPStatus = 0;
    return ProcessScripts(  dwFlags,
                            hToken,
                            hKeyRoot,
                            pDeletedGPOList,
                            pChangedGPOList,
                            pbAbort,
                            FALSE,
                            0,
                            &hrRSoPStatus );
}

DWORD ProcessScriptsGroupPolicyEx(  DWORD                       dwFlags,
                                    HANDLE                      hToken,
                                    HKEY                        hKeyRoot,
                                    PGROUP_POLICY_OBJECT        pDeletedGPOList,
                                    PGROUP_POLICY_OBJECT        pChangedGPOList,
                                    ASYNCCOMPLETIONHANDLE       pHandle,
                                    BOOL*                       pbAbort,
                                    PFNSTATUSMESSAGECALLBACK    pStatusCallback,
                                    IWbemServices*              pWbemServices,
                                    HRESULT*                    phrRsopStatus )
{
    *phrRsopStatus = S_OK;

    return ProcessScripts(  dwFlags,
                            hToken,
                            hKeyRoot,
                            pDeletedGPOList,
                            pChangedGPOList,
                            pbAbort,
                            FALSE,
                            pWbemServices,
                            phrRsopStatus );
}

DWORD GenerateScriptsGroupPolicy(   DWORD dwFlags,
                                    BOOL *pbAbort,
                                    WCHAR *pwszSite,
                                    PRSOP_TARGET pMachTarget,
                                    PRSOP_TARGET pUserTarget )
{
    DWORD dwResult = ERROR_SUCCESS;
    HRESULT hrRSoPStatus = 0;

    if ( pMachTarget )
    {
        //
        // log machine scripts
        //

        dwResult = ProcessScripts(  dwFlags | GPO_INFO_FLAG_MACHINE,
                                    (HANDLE)pMachTarget->pRsopToken,
                                    0,
                                    0,
                                    pMachTarget->pGPOList,
                                    pbAbort,
                                    TRUE,
                                    pMachTarget->pWbemServices,
                                    &hrRSoPStatus );
        if ( dwResult != ERROR_SUCCESS )
        {
            DebugMsg((DM_VERBOSE, L"GenerateScriptPolicy: could not log machine scripts, error %d", dwResult));
        }
    }

    if ( pUserTarget )
    {
        //
        // log user scripts
        //

        dwResult = ProcessScripts(  dwFlags & ~GPO_INFO_FLAG_MACHINE,
                                    (HANDLE)pUserTarget->pRsopToken,
                                    0,
                                    0,
                                    pUserTarget->pGPOList,
                                    pbAbort,
                                    TRUE,
                                    pUserTarget->pWbemServices,
                                    &hrRSoPStatus );
        if ( dwResult != ERROR_SUCCESS )
        {
            DebugMsg((DM_VERBOSE, L"GenerateScriptPolicy: could not log user scripts, error %d", dwResult ));
        }
    }
    
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\scripts.h ===
//
// GPE Script SnapIn extension GUIDs
//

// {40B6664F-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(CLSID_ScriptSnapInMachine,0x40b6664f, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66650-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(CLSID_ScriptSnapInUser,0x40b66650, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// GPE Script node ids
//

// {40B66651-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_ScriptRootMachine,0x40b66651, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66652-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_ScriptRootUser,0x40b66652, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66653-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_ScriptRoot,0x40b66653, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);



//
// RSOP Script SnapIn extension GUIDs
//

// {40B66660-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(CLSID_RSOPScriptSnapInMachine,0x40b66660, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66661-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(CLSID_RSOPScriptSnapInUser,0x40b66661, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// RSOP Script node ids
//

// {40B66662-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPScriptRootMachine,0x40b66662, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66663-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPScriptRootUser,0x40b66663, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66664-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPScriptRoot,0x40b66664, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66665-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPLogon,0x40b66665, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66666-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPLogoff,0x40b66666, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66667-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPStartup,0x40b66667, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66668-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPShutdown,0x40b66668, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

//
// RSOP link list data structures
//

typedef struct tagRSOPSCRIPTITEM {
    LPTSTR  lpCommandLine;
    LPTSTR  lpArgs;
    LPTSTR  lpGPOName;
    LPTSTR  lpDate;
    struct tagRSOPSCRIPTITEM * pNext;
} RSOPSCRIPTITEM, *LPRSOPSCRIPTITEM;

typedef struct tagSCRIPTRESULTITEM {
    LPRESULTITEM      lpResultItem;
    LPRSOPSCRIPTITEM  lpRSOPScriptItem;
    const GUID       *pNodeID;
    INT               iDescStringID;
} SCRIPTRESULTITEM, *LPSCRIPTRESULTITEM;


//
// CScriptsComponentData class
//

class CScriptsComponentData:
    public IComponentData,
    public IPersistStreamInit,
    public ISnapinHelp
{
    friend class CScriptsDataObject;
    friend class CScriptsSnapIn;

protected:
    ULONG                m_cRef;
    BOOL                 m_bUserScope;
    BOOL                 m_bRSOP;
    HWND		 m_hwndFrame;
    LPCONSOLENAMESPACE   m_pScope;
    LPCONSOLE2           m_pConsole;
    HSCOPEITEM           m_hRoot;
    LPGPEINFORMATION     m_pGPTInformation;
    LPRSOPINFORMATION    m_pRSOPInformation;
    LPTSTR               m_pScriptsDir;
    LPOLESTR             m_pszNamespace;
    LPNAMESPACEITEM      m_pNameSpaceItems;
    DWORD                m_dwNameSpaceItemCount;
    LPRSOPSCRIPTITEM     m_pRSOPLogon;
    LPRSOPSCRIPTITEM     m_pRSOPLogoff;
    LPRSOPSCRIPTITEM     m_pRSOPStartup;
    LPRSOPSCRIPTITEM     m_pRSOPShutdown;

public:
    CScriptsComponentData(BOOL bUser, BOOL bRSOP);
    ~CScriptsComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);


    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);


private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
    BOOL AddRSOPScriptDataNode(LPTSTR lpCommandLine, LPTSTR lpArgs,
                               LPTSTR lpGPOName, LPTSTR lpDate, UINT uiScriptType);
    VOID FreeRSOPScriptData(VOID);
    HRESULT InitializeRSOPScriptsData(VOID);
    HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                               LPTSTR lpGPOID, BSTR pLanguage,
                               LPTSTR *pGPOName);
    VOID DumpRSOPScriptsData(LPRSOPSCRIPTITEM lpList);
};



//
// ComponentData class factory
//


class CScriptsComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;
    BOOL  m_bUserScope;
    BOOL  m_bRSOP;

public:
    CScriptsComponentDataCF(BOOL bUser, BOOL bRSOP);
    ~CScriptsComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};



//
// SnapIn class
//

class CScriptsSnapIn:
    public IComponent,
    public IExtendPropertySheet
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CScriptsComponentData *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    LPDISPLAYHELP        m_pDisplayHelp; // IDisplayHelp interface
    WCHAR                m_column1[40];  // Text for column 1
    INT                  m_nColumn1Size; // Size of column 1
    WCHAR                m_column2[40];  // Text for column 2
    INT                  m_nColumn2Size; // Size of column 2
    WCHAR                m_column3[60];  // Text for column 3
    INT                  m_nColumn3Size; // Size of column 3
    WCHAR                m_column4[40];  // Text for column 4
    INT                  m_nColumn4Size; // Size of column 4
    LONG                 m_lViewMode;    // View mode

    static unsigned int  m_cfNodeType;

public:
    CScriptsSnapIn(CScriptsComponentData *pComponent);
    ~CScriptsSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);


private:
    static INT_PTR CALLBACK ScriptDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    BOOL AddScriptToList (HWND hLV, LPTSTR lpName, LPTSTR lpArgs);
    LPTSTR GetSectionNames (LPTSTR lpFileName);
    BOOL OnApplyNotify (HWND hDlg);
    static INT_PTR CALLBACK ScriptEditDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};



//
// IScriptDataobject interface id
//

// {C14C50E2-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(IID_IScriptDataObject,0xc14c50e2, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);


//
// This is a private dataobject interface for GPTs.
// When the GPT snapin receives a dataobject and needs to determine
// if it came from the GPT snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IScriptDataObject
DECLARE_INTERFACE_(IScriptDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IScriptDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IScriptDataObject *LPSCRIPTDATAOBJECT;



//
// CScriptsDataObject class
//

class CScriptsDataObject : public IDataObject,
                           public IScriptDataObject
{
    friend class CScriptsSnapIn;

protected:

    ULONG                  m_cRef;
    CScriptsComponentData  *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfDescription;
    static unsigned int    m_cfHTMLDetails;



public:
    CScriptsDataObject(CScriptsComponentData *pComponent);
    ~CScriptsDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IScriptDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\scrpdata.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        Scrpdata.cpp
//
// Contents:    
//
// History:     9-Aug-99       NishadM    Created
//
//---------------------------------------------------------------------------

#include "gptext.h"
#include "scrpdata.h"

LPCWSTR g_pwszScriptTypes[] =
{
	TEXT("Undefined"),
	LOGON_VALUE,
	LOGOFF_VALUE,
	STARTUP_VALUE,
	SHUTDOWN_VALUE,
};

PRSOP_ScriptList
CreateScriptList( ScriptType type )
{
	PRSOP_ScriptList	pList = (PRSOP_ScriptList) LocalAlloc( LMEM_ZEROINIT, sizeof( RSOP_ScriptList ) );

	if ( pList )
	{
		SetScriptType( pList, type );
	}

	return pList;
}

RSOPScriptList
CreateScriptListOfStr( LPCWSTR szScriptType )
{
	ScriptType 		type = Undefined;
	RSOPScriptList 	pList = 0;
	
	if ( szScriptType )
	{
		if ( !lstrcmpi( szScriptType, LOGON_VALUE ) )
		{
			type = Logon;
		}
		else if ( !lstrcmpi( szScriptType, LOGOFF_VALUE ) )
		{
			type = Logoff;
		}
		else if ( !lstrcmpi( szScriptType, STARTUP_VALUE ) )
		{
			type = Startup;
		}
		else if ( !lstrcmpi( szScriptType, SHUTDOWN_VALUE ) )
		{
			type = Shutdown;
		}
		
		if ( type != Undefined )
		{
			pList = (RSOPScriptList) CreateScriptList( type );
		}
	}

	return pList;
}

void
DestroyScriptList( RSOPScriptList pList )
{
	if ( pList )
	{
		PRSOP_Script pCommand = ((PRSOP_ScriptList)pList)->scriptCommand;

		while ( pCommand )
		{
			PRSOP_Script pTemp = pCommand->pNextCommand;
			//
			// destroy the script command and params
			//
			
			if ( pCommand->szCommand )
			{
				LocalFree( pCommand->szCommand );
			}
			if ( pCommand->szParams )
			{
				LocalFree( pCommand->szParams );
			}

			pCommand = pTemp;
		}

		//
		// destroy the list
		//
		
		LocalFree( pList );
	}
}

BOOL
AddScript( RSOPScriptList pList, LPCWSTR  szCommand, LPCWSTR  szParams, SYSTEMTIME* pExecTime )
{
    PRSOP_Script pCommand = 0;

    if ( pList )
    {
    	//
    	// Alloc the script
    	//
    	
    	pCommand = (PRSOP_Script) LocalAlloc( LMEM_ZEROINIT, sizeof( RSOP_Script ) );

    	if ( pCommand )
    	{
    		//
    		// Alloc the command and params
    		//
    		
    		pCommand->szCommand = (LPTSTR) LocalAlloc( 0, ( wcslen( szCommand ) + 1 ) * sizeof( WCHAR ) );
    		pCommand->szParams  = (LPTSTR) LocalAlloc( 0, ( wcslen( szParams ) + 1 ) * sizeof( WCHAR ) );

    		if ( pCommand->szParams && pCommand->szCommand )
    		{
                //
                // deep copy
                //

                wcscpy( pCommand->szCommand, szCommand );
                wcscpy( pCommand->szParams, szParams );
                memcpy( &pCommand->executionTime, pExecTime, sizeof(SYSTEMTIME));

                //
                // build the list
                //

                if ( ((PRSOP_ScriptList)pList)->listTail )
                {
                	((PRSOP_ScriptList)pList)->listTail->pNextCommand = pCommand;
                }

                if ( !((PRSOP_ScriptList)pList)->scriptCommand )
                {
                	//
                	// first script command
                	//
                	
                	((PRSOP_ScriptList)pList)->scriptCommand = pCommand;
                	((PRSOP_ScriptList)pList)->listTail = pCommand;
                }

                ((PRSOP_ScriptList)pList)->listTail = pCommand;

    		}
    		else
    		{
    			//
    			// cleanup
    			//
    			
    			if ( pCommand->szCommand )
    			{
    				LocalFree( pCommand->szCommand );
    			}
    			if ( pCommand->szParams )
    			{
    				LocalFree( pCommand->szParams );
    			}
    			LocalFree( pCommand );
    			pCommand = 0;
    		}
    	}
    }

    if ( pCommand )
    {
    	//
    	// bump command count
    	//
    	
    	((PRSOP_ScriptList)pList)->nCommand++;
    	return TRUE;
    }
    else
    {
    	return FALSE;;
    }
}

ScriptType
GetScriptType( PRSOP_ScriptList pList )
{
	//
	// accessor
	//
	
	if ( pList )
	{
		return pList->type;
	}

	return Undefined;
}

void
SetScriptType( PRSOP_ScriptList pList, ScriptType type )
{
	//
	// accessor
	//

	if ( pList )
	{
		pList->type = type;
	}
}

ULONG
GetScriptCount( PRSOP_ScriptList pList )
{
	//
	// accessor
	//

	if ( pList )
	{
		return pList->nCommand;
	}
	
	return 0;
}

void
GetFirstScript( PRSOP_ScriptList pList, void** pHandle, LPCWSTR* pszCommand, LPCWSTR* pszParams, SYSTEMTIME** pExecTime )
{
	//
	// sanity check
	//
	
	if ( pList )
	{
		if ( pHandle )
		{
			//
			// first command of the list
			//
			
			*pHandle = ( void* ) pList->scriptCommand;
		}
		if ( pList->scriptCommand )
		{
			//
			// accessor
			// list owns the memory
			//
			
			if ( pszCommand )
			{
				*pszCommand = pList->scriptCommand->szCommand;
			}
			if ( pszParams )
			{
				*pszParams = pList->scriptCommand->szParams;
			}
			if ( pExecTime )
			{
			    *pExecTime = &pList->scriptCommand->executionTime;
			}
		}
	}
}

void
GetNextScript( PRSOP_ScriptList pList, void** pHandle, LPCWSTR* pszCommand, LPCWSTR* pszParams, SYSTEMTIME** pExecTime )
{
	//
	// sanity checks
	//
	
    if ( pList )
    {
    	if ( pHandle && *pHandle )
    	{
    		//
    		// context marker
    		//
    		
    		PRSOP_Script pCommand = ( PRSOP_Script ) *pHandle;

    		pCommand = pCommand->pNextCommand;

    		if ( pCommand )
    		{
    			//
    			// accessor
    			// list owns the memory
    			//
    			
    			if ( pszCommand )
    			{
    				*pszCommand = pCommand->szCommand;
    			}
    			if ( pszParams )
    			{
    				*pszParams = pCommand->szParams;
    			}
    			if ( pExecTime )
    			{
    			    *pExecTime = &pCommand->executionTime;
    			}
    		}

    		*pHandle = pCommand;
    	}
    }
}

//
// extracts {08D5A77B-E6E3-4C2B-A952-A2BA4C3AFE63} from
// \\domain\sysvol\domain-dns-path\Policies\{08D5A77B-E6E3-4C2B-A952-A2BA4C3AFE63}\User\Scripts\Scripts.ini
// allocates and returns string
//

LPWSTR
GPOIDFromPath( LPCWSTR wszPath )
{
	LPWSTR wszGpoId = 0;
	
	while ( *wszPath && *(wszPath+1) )
	{
		if ( *wszPath == L'\\' && *(wszPath+1) == L'{' )
		{
			LPCWSTR wszTemp = ++wszPath;

			while ( *wszTemp && *wszTemp != L'}' )
			{
				wszTemp++;
			}

			if ( *wszTemp && ( wszTemp - wszPath ) == 37 )
			{
				//
				// wcslen("{08D5A77B-E6E3-4C2B-A952-A2BA4C3AFE63}") == 39
				// including terminating character.
				//

				wszGpoId = (LPWSTR) LocalAlloc( 0, 40 * sizeof( WCHAR ) );

				if ( wszGpoId )
				{
					wcsncpy( wszGpoId, wszPath, 38 );
					wszGpoId[38] = 0;
				}
			}
			
			break;
		}
		wszPath++;
	}

        if (!wszGpoId && !(*(wszPath+1)))
        {

            wszGpoId = (LPWSTR) LocalAlloc(LPTR, 19 * sizeof( WCHAR ) );

            if ( wszGpoId )
            {
                 lstrcpyW (wszGpoId, L"Local Group Policy");
            }
        }

	return wszGpoId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\util.h ===
//
// Function proto-types for util.cpp
//

LPTSTR CheckSlash (LPTSTR lpDir);
BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);
BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName);
UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal);
BOOL ImpersonateUser (HANDLE hNewUser, HANDLE *hOldUser);
BOOL RevertToUser (HANDLE *hUser);
void StringToGuid( TCHAR *szValue, GUID *pGuid );
void GuidToString( GUID *pGuid, TCHAR * szValue );
BOOL ValidateGuid( TCHAR *szValue );
INT CompareGuid( GUID *pGuid1, GUID *pGuid2 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\wirelessext.h ===
HRESULT
CreateWirelessChildPath(
    LPWSTR pszParentPath,
    LPWSTR pszChildComponent,
    BSTR * ppszChildPath
    );

HRESULT
RetrieveWirelessPolicyFromDS(
    PGROUP_POLICY_OBJECT pGPOInfo,
    LPWSTR *ppszWirelessPolicy,
    LPWSTR pszWirelessPolicyName,
    LPWSTR pszWirelessPolicyDescription,
    LPWSTR pszWirelessPolicyID
    );


DWORD
DeleteWirelessPolicyFromRegistry(
    );

DWORD
WriteWirelessPolicyToRegistry(
    LPWSTR pszWirelessPolicyPath,
    LPWSTR pszWirelessPolicyName,
    LPWSTR pszWirelessPolicyDescription,
    LPWSTR pszWirelessPolicyID
    );


HRESULT
RegisterWireless(void);

HRESULT
UnregisterWireless(void);

VOID
PingWirelessPolicyAgent(
    );


#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) { \
        goto error;  \
    }

#define BAIL_ON_WIN32_ERROR(dwError)                \
    if (dwError) {                                  \
        goto error;                                 \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\scrpdata.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        Scrpdata.h
//
// Contents:    
//
// History:     9-Aug-99       NishadM    Created
//
//---------------------------------------------------------------------------

#ifndef _SCRPDATA_H_
#define _SCRPDATA_H_

//
// GPO script and its parameters
//

typedef struct tag_RSOP_Script
{
    LPWSTR      szCommand;      // full path to the script file
    LPWSTR      szParams;       // list of parameters
    SYSTEMTIME  executionTime;  // time of execution
    struct tag_RSOP_Script*  pNextCommand;          // next link in the chain   

} RSOP_Script, * PRSOP_Script;

//
// script types
//

typedef enum
{
    Undefined = 0,
    Logon,
    Logoff,
    Startup,
    Shutdown    
} ScriptType;

//
// GPO scripts collection
//

typedef struct tag_RSOP_ScriptList
{
    ScriptType   type;               // type of script
    ULONG        nCommand;           // number of scripts
    PRSOP_Script scriptCommand;      // list of scripts
    PRSOP_Script listTail;           // 
    
} RSOP_ScriptList, *PRSOP_ScriptList;

//
// ScriptType to Strings
//
extern LPCWSTR  g_pwszScriptTypes[];

#define ScriptTypeString(x) ( g_pwszScriptTypes[(ULONG)(x)] )

//
// Housekeeping internal APIs
//

PRSOP_ScriptList
CreateScriptList( ScriptType type );

ScriptType
GetScriptType( PRSOP_ScriptList pList );

void
SetScriptType( PRSOP_ScriptList pList, ScriptType type );

ULONG
GetScriptCount( PRSOP_ScriptList pList );

void
GetFirstScript( PRSOP_ScriptList pList, void** pHandle, LPCWSTR* pszCommand, LPCWSTR* pszParams, SYSTEMTIME** pExecTime );

void
GetNextScript( PRSOP_ScriptList pList, void** pHandle, LPCWSTR* pszCommand, LPCWSTR* pszParams, SYSTEMTIME** pExecTime );

//
// exported APIs and definitions
//

#include "ScrptLog.h"

#endif // _SCRPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\wirelessext.cpp ===
#include "gptext.h"
#include <initguid.h>
#include <iadsp.h>
extern "C"{
#include "wlrsop.h"
}
#include "wirelessext.h"
#include "SmartPtr.h"
#include "wbemtime.h"
#include "xpsp1res.h"


#define GPEXT_PATH  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{0ACDD40C-75AC-47ab-BAA0-BF6DE7E7FE63}")
#define POLICY_PATH   TEXT("Software\\Policies\\Microsoft\\Windows\\Wireless\\GPTWirelessPolicy")

LPWSTR GetWirelessAttributes[] = {L"msieee80211-ID", L"cn", L"description"}; 

HINSTANCE
WirelessGetSPResModule()
{
    static HINSTANCE st_hModule = NULL;

    if (st_hModule == NULL)
    {
        WCHAR wszFullPath[_MAX_PATH];

        if (ExpandEnvironmentStrings(
                L"%systemroot%\\system32\\xpsp1res.dll",
                wszFullPath,
                _MAX_PATH) != 0)
        {
            st_hModule = LoadLibraryEx(
                            wszFullPath,
                            NULL,
                            0);
        }
    }
    return st_hModule;
}


HRESULT
RegisterWireless(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;
    TCHAR szBuffer[512];

    szBuffer[0]=L'\0';


    lResult = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    GPEXT_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp
                    );

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    LoadString(WirelessGetSPResModule(), IDS_PEAP_WIRELESS, szBuffer, ARRAYSIZE(szBuffer));

    RegSetValueEx (
                hKey,
                NULL,
                0,
                REG_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );
  

    RegSetValueEx (
                hKey,
                TEXT("ProcessGroupPolicy"),
                0,
                REG_SZ,
                (LPBYTE)TEXT("ProcessWIRELESSPolicy"),
                (lstrlen(TEXT("ProcessWIRELESSPolicy")) + 1) * sizeof(TCHAR)
                );

    szBuffer[0] = L'\0';
    wcscpy(szBuffer, L"gptext.dll");

    RegSetValueEx (
                hKey,
                TEXT("DllName"),
                0,
                REG_EXPAND_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    dwValue = 1;
    RegSetValueEx (
                hKey,
                TEXT("NoUserPolicy"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegSetValueEx (
                hKey,
                TEXT("NoGPOListChanges"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegCloseKey (hKey);
    return S_OK;
}


HRESULT
UnregisterWireless(void)
{
    DWORD dwError = 0;

    dwError = RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);

    return HRESULT_FROM_WIN32(dwError);
}

DWORD
ProcessWIRELESSPolicy(
    DWORD dwFlags,                           // GPO_INFO_FLAGS
    HANDLE hToken,                           // User or machine token
    HKEY hKeyRoot,                           // Root of registry
    PGROUP_POLICY_OBJECT  pDeletedGPOList,   // Linked list of deleted GPOs
    PGROUP_POLICY_OBJECT  pChangedGPOList,   // Linked list of changed GPOs
    ASYNCCOMPLETIONHANDLE pHandle,           // For asynchronous completion
    BOOL *pbAbort,                           // If true, then abort GPO processing
    PFNSTATUSMESSAGECALLBACK pStatusCallback // Callback function for displaying status messages
    )

{
    
    // Call ProcessWIRELESSPolicy & get path -> polstore funcs
    LPWSTR pszWIRELESSPolicyPath = NULL;
    WCHAR szWIRELESSPolicyName[MAX_PATH];    //policy name
    WCHAR szWIRELESSPolicyDescription[512];  //policy descr
    WCHAR szWIRELESSPolicyID[512];  //policy descr
    HRESULT hr = S_OK;
    PGROUP_POLICY_OBJECT pGPO = NULL;
    GPO_INFO GPOInfo;

    //
    // Call CoInitialize for all the COM work we're doing
    //
    hr = CoInitializeEx(NULL,0);
    if (FAILED(hr)) {
        goto error;
    }

    memset(szWIRELESSPolicyName, 0, sizeof(WCHAR)*MAX_PATH);
    memset(szWIRELESSPolicyDescription, 0, sizeof(WCHAR)*512);
    memset(szWIRELESSPolicyID, 0, sizeof(WCHAR)*512);

    // First process the Deleted GPO List. If there is a single
    // entry on the GPO list, just delete the entire list.
    // Example Rex->Cassius->Brutus. If the delete List has
    // Cassius to be deleted, then really, we shouldn't be deleting
    // our registry entry because we're interested in Brutus which
    // has not be deleted. But in our case, the pChangedGPOList will
    // have all the information, so Brutus gets written back in the
    // next stage.
    //
    if (pDeletedGPOList) {
        DeleteWirelessPolicyFromRegistry();
    }
    
    if(pChangedGPOList) {

        DWORD dwNumGPO = 0;
        for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
            dwNumGPO++;

            //
			// Write only the last, highest precedence policy to registry
			//
            if(pGPO->pNext == NULL) {
	            hr = RetrieveWirelessPolicyFromDS(
	                pGPO,
	                &pszWIRELESSPolicyPath,
	                szWIRELESSPolicyName,
	                szWIRELESSPolicyDescription,
			szWIRELESSPolicyID
	                );
	            if (FAILED(hr)) {
	                goto error; 
	            }

                hr = WriteWirelessPolicyToRegistry(
                    pszWIRELESSPolicyPath,
                    szWIRELESSPolicyName,
                    szWIRELESSPolicyDescription,
                    szWIRELESSPolicyID
                    );

                if (pszWIRELESSPolicyPath) {
                	LocalFree(pszWIRELESSPolicyPath);
                	pszWIRELESSPolicyPath = NULL;
                	}
                if (FAILED(hr)) {
	                goto error; // WMI store still consistent
                }
            }
        }
        DebugMsg( (DM_WARNING, L"wirelessext::ProcessWIRELESSPolicyEx: dwNumGPO: %d", dwNumGPO) );

    }
    
    DebugMsg( (DM_WARNING, L"wirelessext::ProcessWIRELESSPolicyEx completed") );
    
    PingWirelessPolicyAgent();
    CoUninitialize();

    return(ERROR_SUCCESS);
    
error:

    /* Cannot Result in a double delete becuase, 
      whenever we free, we set the pszWirelessPolicyPath to NULL
      so that freeing happens only once 
      */
      
    if (pszWIRELESSPolicyPath) {
                	LocalFree(pszWIRELESSPolicyPath);
                	pszWIRELESSPolicyPath = NULL;
                	}
    
    return(ERROR_POLICY_OBJECT_NOT_FOUND);

}

HRESULT
CreateWirelessChildPath(
    LPWSTR pszParentPath,
    LPWSTR pszChildComponent,
    BSTR * ppszChildPath
    )
{
    HRESULT hr = S_OK;
    IADsPathname     *pPathname = NULL;

    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_IADsPathname,
                (void**)&pPathname
                );
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Set(pszParentPath, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->AddLeafElement(pszChildComponent);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Retrieve(ADS_FORMAT_X500, ppszChildPath);
    BAIL_ON_FAILURE(hr);

error:
    if (pPathname) {
        pPathname->Release();
    }

    return(hr);
}



HRESULT
RetrieveWirelessPolicyFromDS(
    PGROUP_POLICY_OBJECT pGPOInfo,
    LPWSTR *ppszWirelessPolicyPath,
    LPWSTR pszWirelessPolicyName,
    LPWSTR pszWirelessPolicyDescription,
    LPWSTR pszWirelessPolicyID
    )
{
    LPWSTR pszMachinePath = NULL;
    BSTR pszMicrosoftPath = NULL;
    BSTR pszWindowsPath = NULL;
    BSTR pszWirelessPath = NULL;
    BSTR pszLocWirelessPolicy = NULL;
    IDirectoryObject * pDirectoryObject = NULL;
    IDirectoryObject * pWirelessObject = NULL;
    IDirectorySearch * pWirelessSearch = NULL;
    BOOL bFound = FALSE;
    ADS_SEARCH_HANDLE hSearch;
    ADS_SEARCH_COLUMN col;
    WCHAR pszLocName[MAX_PATH+10]; // We need to store only CN=, in additon to the name.
    LPWSTR pszWirelessPolicyPath = NULL;
    DWORD dwWirelessPolicyPathLen = 0;
    DWORD dwError = 0;


    LPWSTR pszOwnersReference = L"wifiOwnersReference";

    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAttributeEntries = NULL;
    DWORD dwNumAttributesReturned = 0;

    DWORD i = 0;
    PADS_ATTR_INFO pAttributeEntry = NULL;



    pszMachinePath = pGPOInfo->lpDSPath;

    // Build the fully qualified ADsPath for my object

    hr = CreateWirelessChildPath(
                pszMachinePath,
                L"cn=Microsoft",
                &pszMicrosoftPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateWirelessChildPath(
                pszMicrosoftPath,
                L"cn=Windows",
                &pszWindowsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateWirelessChildPath(
                pszWindowsPath,
                L"cn=Wireless",
                &pszWirelessPath
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsOpenObject(
    	pszWirelessPath,
    	NULL,
    	NULL,
    	ADS_SECURE_AUTHENTICATION | ADS_USE_SEALING | ADS_USE_SIGNING,
    	IID_IDirectorySearch,
       (void **)&pWirelessSearch
       );
    BAIL_ON_FAILURE(hr);

    hr = pWirelessSearch->ExecuteSearch(
	    L"(&(objectClass=msieee80211-Policy))", GetWirelessAttributes, 3, &hSearch );
    if (!SUCCEEDED(hr)) {
        pWirelessSearch->CloseSearchHandle(hSearch);
	BAIL_ON_FAILURE(hr);
    }

    hr = pWirelessSearch->GetNextRow(hSearch);
    if (!SUCCEEDED(hr)) {
        pWirelessSearch->CloseSearchHandle(hSearch);
	BAIL_ON_FAILURE(hr);
    }

    hr = pWirelessSearch->GetColumn(hSearch, L"cn", &col);    
    if (!SUCCEEDED(hr)) {
	pWirelessSearch->CloseSearchHandle(hSearch);
	BAIL_ON_FAILURE(hr);
    }

    if (col.dwADsType != ADSTYPE_CASE_IGNORE_STRING) {

        DebugMsg((DM_ASSERT, L"wirelessext::RetrievePolicyFromDS: cn NOT adstype_case_ignore_string"));
        pWirelessSearch->FreeColumn(&col);
	pWirelessSearch->CloseSearchHandle(hSearch);
	hr = E_ADS_BAD_PARAMETER;
	BAIL_ON_FAILURE(hr);
    }

    wcscpy(pszWirelessPolicyName, col.pADsValues->CaseIgnoreString);
    pWirelessSearch->FreeColumn(&col);


    pWirelessSearch->CloseSearchHandle(hSearch);

    wcscpy(pszLocName, L"\0");
    wcscpy(pszLocName,L"CN=");
    wcscat(pszLocName,pszWirelessPolicyName);

    hr = CreateWirelessChildPath(
                pszWirelessPath,
                pszLocName,
                &pszLocWirelessPolicy
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsOpenObject(
    	pszLocWirelessPolicy,
    	NULL,
    	NULL,
    	ADS_SECURE_AUTHENTICATION | ADS_USE_SEALING | ADS_USE_SIGNING,
    	IID_IDirectoryObject,
       (void **)&pWirelessObject
       );
    BAIL_ON_FAILURE(hr);

    hr = pWirelessObject->GetObjectAttributes(
                        GetWirelessAttributes,
                        3,
                        &pAttributeEntries,
                        &dwNumAttributesReturned
                        );
    BAIL_ON_FAILURE(hr);

    if (dwNumAttributesReturned == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    //
    // Process the PathName
    //

    
    //
    // Process the ID
    //
    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"msieee80211-ID")) {
            wcscpy(pszWirelessPolicyID, pAttributeEntry->pADsValues->DNString);
            bFound = TRUE;
            break;
        }
    }
    if (!bFound) {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    
    //
    // Process the description
    //
    
    wcscpy(pszWirelessPolicyDescription,L"\0");

    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"description")) {
            wcscpy(pszWirelessPolicyDescription, pAttributeEntry->pADsValues->DNString);
            break;
        }
    }

    dwWirelessPolicyPathLen = wcslen(pszLocWirelessPolicy);
    pszWirelessPolicyPath = (LPWSTR) LocalAlloc(
    	LPTR, 
    	sizeof(WCHAR) * (dwWirelessPolicyPathLen+1)
    	);

    if (!pszWirelessPolicyPath) {
    	dwError = GetLastError();
    	hr = HRESULT_FROM_WIN32(dwError);
    	}
   BAIL_ON_FAILURE(hr);

    memset(pszWirelessPolicyPath, 0, sizeof(WCHAR) * (dwWirelessPolicyPathLen+1));
    wcscpy(pszWirelessPolicyPath, pszLocWirelessPolicy);

    *ppszWirelessPolicyPath = pszWirelessPolicyPath;


error:


    if (pszLocWirelessPolicy) {
        SysFreeString(pszLocWirelessPolicy);
    }

    if (pszWirelessPath) {
        SysFreeString(pszWirelessPath);
    }

    if (pszWindowsPath) {
        SysFreeString(pszWindowsPath);
    }

    if (pszMicrosoftPath) {
        SysFreeString(pszMicrosoftPath);
    }

    return(hr);

}


DWORD
DeleteWirelessPolicyFromRegistry(
    )
{

    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwDisp = 0;


    dwError = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Policies\\Microsoft\\Windows\\Wireless"),
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp
                    );
    if (dwError) {
        goto error;
    }


    dwError = RegDeleteKey(
                    hKey,
                    L"GPTWirelessPolicy"
                    );

/*
    dwError = RegDeleteValue(
                    hKey,
                    TEXT("DSWIRELESSPolicyPath")
                    );

    dwError = RegDeleteValue(
                    hKey,
                    TEXT("DSWIRELESSPolicyName")
                    );*/
error:

    if (hKey) {

        RegCloseKey (hKey);

    }

    return(dwError);
}

DWORD
WriteWirelessPolicyToRegistry(
    LPWSTR pszWirelessPolicyPath,
    LPWSTR pszWirelessPolicyName,
    LPWSTR pszWirelessPolicyDescription,
    LPWSTR pszWirelessPolicyID
    )
{
    DWORD dwError = 0;
    DWORD dwDisp = 0;
    HKEY hKey = NULL;
    DWORD dwFlags = 1;

    dwError = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    POLICY_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp
                    );
    if (dwError) {
        goto error;
    }


    if (pszWirelessPolicyPath && *pszWirelessPolicyPath) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSWirelessPolicyPath"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszWirelessPolicyPath,
                       (lstrlen(pszWirelessPolicyPath) + 1) * sizeof(TCHAR)
                       );

        dwFlags = 1;

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSWirelessPolicyFlags"),
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwFlags,
                        sizeof(dwFlags)
                       );

    }


    if (pszWirelessPolicyName && *pszWirelessPolicyName) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSWirelessPolicyName"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszWirelessPolicyName,
                       (lstrlen(pszWirelessPolicyName) + 1) * sizeof(TCHAR)
                       );
    }

    if (pszWirelessPolicyID && *pszWirelessPolicyID) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("WirelessID"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszWirelessPolicyID,
                       (lstrlen(pszWirelessPolicyID) + 1) * sizeof(TCHAR)
                       );
    }





    if (pszWirelessPolicyDescription && *pszWirelessPolicyDescription) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSWirelessPolicyDescription"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszWirelessPolicyDescription,
                       (lstrlen(pszWirelessPolicyDescription) + 1) * sizeof(TCHAR)
                       );
    }

error:

    if (hKey) {

        RegCloseKey (hKey);

    }

    return(dwError);

}


VOID
PingWirelessPolicyAgent(
    )
{
    HANDLE hPolicyChangeEvent = NULL;

    hPolicyChangeEvent = OpenEvent(
                             EVENT_ALL_ACCESS,
                             FALSE,
                             L"WIRELESS_POLICY_CHANGE_EVENT"
                             );

    if (hPolicyChangeEvent) {
        SetEvent(hPolicyChangeEvent);
        CloseHandle(hPolicyChangeEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\scrptlog.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        ScrptLog.h
//
// Contents:    
//
// History:     9-Aug-99       NishadM    Created
//
//---------------------------------------------------------------------------

#ifndef _SCRPTLOG_H_
#define _SCRPTLOG_H_

#include <wbemcli.h>

#ifdef  __cplusplus
extern "C" {
#endif

//
// handle
//

typedef void* RSOPScriptList;

//
// script type strings
//

#define LOGON_VALUE       L"Logon"
#define LOGOFF_VALUE      L"Logoff"
#define STARTUP_VALUE     L"Startup"
#define SHUTDOWN_VALUE    L"Shutdown"

#define LOGON_SOM_VALUE       L"Logon-SOMIDs"
#define LOGOFF_SOM_VALUE      L"Logoff-SOMIDs"
#define STARTUP_SOM_VALUE     L"Startup-SOMIDs"
#define SHUTDOWN_SOM_VALUE    L"Shutdown-SOMIDs"

#define LOGON_NS_VALUE      L"User-RSoP-NS"
#define LOGOFF_NS_VALUE     L"User-RSoP-NS"
#define STARTUP_NS_VALUE    L"Mach-RSoP-NS"
#define SHUTDOWN_NS_VALUE   L"Mach-RSoP-NS"

#define LOGON_RSOP_LOGGING_VALUE    L"Logon-RSoP-Logging"
#define LOGOFF_RSOP_LOGGING_VALUE   L"Logoff-RSoP-Logging"
#define STARTUP_RSOP_LOGGING_VALUE  L"Startup-RSoP-Logging"
#define SHUTDOWN_RSOP_LOGGING_VALUE L"Shutdown-RSoP-Logging"

//
// Script List creation APIs
//

RSOPScriptList
CreateScriptListOfStr( LPCWSTR szScriptType );

//
// Script list destructor API
//

void
DestroyScriptList( RSOPScriptList pList );

//
// Script list building API
//

BOOL
AddScript( RSOPScriptList pList, LPCWSTR  szCommand, LPCWSTR  szParams, SYSTEMTIME* execTime );

//
// Misc. APIs
//

HRESULT
LogScriptsRsopData( RSOPScriptList	pScriptList,
                    IWbemServices*  pWbemServices,
                    LPCWSTR			wszGPOID,
                    LPCWSTR			wszSOMID,
                    LPCWSTR                     wszRSOPGPOID,
                    DWORD           cOrder );

HRESULT
DeleteScriptsRsopData(  RSOPScriptList  pScriptList,
                        IWbemServices*  pWbemServices );

HRESULT
UpdateScriptsRsopData(  RSOPScriptList	pScriptList,
                        IWbemServices*  pWbemServices,
                        LPCWSTR         wszGPOID,
                        LPCWSTR			wszSOMID );

LPWSTR
GPOIDFromPath( LPCWSTR wszPath );

LPWSTR
GetNamespace( IWbemServices* pWbemServices );

//
// delay load
//

#define RSOP_SCRIPT_LOG_DLL L"gptext.dll"

typedef RSOPScriptList (*PFNCREATESCRIPTLISTOFSTR)( LPCWSTR );
typedef void (*PFNDESTROYSCRIPTLIST)( RSOPScriptList );
typedef BOOL (*PFNADDSCRIPT)( RSOPScriptList, LPCWSTR, LPCWSTR );
typedef BOOL (*PFNRSOPLOGGINGENABLED)();
typedef HRESULT (*PFNLOGSCRIPTSRSOPDATA)( RSOPScriptList, IWbemServices*, LPCWSTR, LPCWSTR, LPCWSTR, DWORD );
typedef HRESULT (*PFNDELETESCRIPTSRSOPDATA)(RSOPScriptList, IWbemServices*);
typedef HRESULT (*PFNUPDATESCRIPTSRSOPDATA)( RSOPScriptList, IWbemServices*, LPCWSTR, LPCWSTR );
typedef LPWSTR (*PFNGPOIDFROMPATH)( LPCWSTR );
typedef LPWSTR (*PFNGETNAMESPACE)( IWbemServices* );

typedef struct _SCRPTLOG_API
{
    HINSTANCE                       hInstance;
    PFNCREATESCRIPTLISTOFSTR        pfnCreateScriptListOfStr;
    PFNDESTROYSCRIPTLIST            pfnDestroyScriptList;
    PFNADDSCRIPT                    pfnAddScript;
    PFNLOGSCRIPTSRSOPDATA           pfnLogScriptsRsopData;
    PFNDELETESCRIPTSRSOPDATA        pfnDeleteScriptsRsopData;
    PFNUPDATESCRIPTSRSOPDATA        pfnUpdateScriptsRsopData;
    PFNGPOIDFROMPATH                pfnGPOIDFromPath;
    PFNGETNAMESPACE                 pfnGetNamespace;
} SCRPTLOG_API, *PSCRPTLOG_API;

//
// API names
//

#define DESTROYSCRIPTLIST               "DestroyScriptList"
#define DELETESCRIPTSRSOPDATA           "DeleteScriptsRsopData"
#define CREATESCRIPTLISTOFSTR           "CreateScriptListOfStr"
#define ADDSCRIPT                       "AddScript"
#define LOGSCRIPTSRSOPDATA              "LogScriptsRsopData"
#define UPDATESCRIPTSRSOPDATA           "UpdateScriptsRsopData"
#define GPOIDFROMPATH                   "GPOIDFromPath"
#define GETNAMESPACE                    "GetNamespace"

#ifdef  __cplusplus
}
#endif

#endif // _SCRPTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gptext\util.cpp ===
#include "gptext.h"

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}


//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    LPTSTR lpEnd;
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }


    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            lstrcpy (lpEnd, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    TCHAR szDelKey[2 * MAX_PATH];


    lstrcpy (szDelKey, lpSubKey);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);

}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName)
{
    TCHAR szDelKey[2 * MAX_PATH];
    LPTSTR lpEnd;
    DWORD dwKeys, dwValues;
    LONG lResult;
    HKEY hKey;


    //
    // Make a copy of the subkey so we can write to it.
    //

    lstrcpy (szDelKey, lpSubKey);


    //
    // First delete the value
    //

    lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegDeleteValue (hKey, lpValueName);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult != ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
                return FALSE;
            }
        }
    }

    //
    // Now loop through each of the parents.  If the parent is empty
    // eg: no values and no other subkeys, then remove the parent and
    // keep working up.
    //

    lpEnd = szDelKey + lstrlen(szDelKey) - 1;

    while (lpEnd >= szDelKey)
    {

        //
        // Find the parent key
        //

        while ((lpEnd > szDelKey) && (*lpEnd != TEXT('\\')))
            lpEnd--;


        //
        // Open the key
        //

        lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_READ, &hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_FILE_NOT_FOUND)
            {
                goto LoopAgain;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
                return FALSE;
            }
        }

        //
        // See if there any any values / keys
        //

        lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL,
                         &dwValues, NULL, NULL, NULL, NULL);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
            return FALSE;
        }


        //
        // Exit now if this key has values or keys
        //

        if ((dwKeys != 0) || (dwValues != 0))
        {
            return TRUE;
        }

        RegDeleteKey (hKeyRoot, szDelKey);

LoopAgain:
        //
        // If we are at the beginning of the subkey, we can leave now.
        //

        if (lpEnd == szDelKey)
        {
            return TRUE;
        }


        //
        // There is a parent key.  Remove the slash and loop again.
        //

        if (*lpEnd == TEXT('\\'))
        {
            *lpEnd = TEXT('\0');
        }
    }

    return TRUE;
}

//*************************************************************
//
//  CreateNestedDirectory()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary.
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//
//*************************************************************

UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;

    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  Received a NULL pointer.")));
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  CreateDirectory failed with %d."), GetLastError()));
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateNestedDirectory:  Failed to create the directory with error %d."), GetLastError()));

    return 0;

}

/*******************************************************************

        NAME:           StringToNum

        SYNOPSIS:       Converts string value to numeric value

        NOTES:          Calls atoi() to do conversion, but first checks
                                for non-numeric characters

        EXIT:           Returns TRUE if successful, FALSE if invalid
                                (non-numeric) characters

********************************************************************/
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal)
{
        TCHAR *pTst = pszStr;

        if (!pszStr) return FALSE;

        // verify that all characters are numbers
        while (*pTst) {
                if (!(*pTst >= TEXT('0') && *pTst <= TEXT('9'))) {
//                   if (*pTst != TEXT('-'))
                       return FALSE;
                }
                pTst = CharNext(pTst);
        }

        *pnVal = _ttoi(pszStr);

        return TRUE;
}

//*************************************************************
//
//  ImpersonateUser()
//
//  Purpose:    Impersonates the specified user
//
//  Parameters: hToken - user to impersonate
//
//  Return:     hToken  if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ImpersonateUser (HANDLE hNewUser, HANDLE *hOldUser)
{

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ,
                          TRUE, hOldUser)) {
        *hOldUser = NULL;
    }

    if (!ImpersonateLoggedOnUser(hNewUser))
    {
        if ( *hOldUser )
        {
            CloseHandle( *hOldUser );
            *hOldUser = NULL;
        }
        DebugMsg((DM_WARNING, TEXT("ImpersonateUser: Failed to impersonate user with %d."), GetLastError()));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  RevertToUser()
//
//  Purpose:    Revert back to original user
//
//  Parameters: hUser  -  original user token
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RevertToUser (HANDLE *hUser)
{

    SetThreadToken(NULL, *hUser);

    if (*hUser) {
        CloseHandle (*hUser);
        *hUser = NULL;
    }

    return TRUE;
}

//*************************************************************
//
//  GuidToString, StringToGuid, ValidateGuid, CompareGuid()
//
//  Purpose:    Guid utility functions
//
//*************************************************************

//
// Length in chars of string form of guid {44cffeec-79d0-11d2-a89d-00c04fbbcfa2}
//

#define GUID_LENGTH 38


void GuidToString( GUID *pGuid, TCHAR * szValue )
{
    wsprintf( szValue,
              TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
              pGuid->Data1,
              pGuid->Data2,
              pGuid->Data3,
              pGuid->Data4[0], pGuid->Data4[1],
              pGuid->Data4[2], pGuid->Data4[3],
              pGuid->Data4[4], pGuid->Data4[5],
              pGuid->Data4[6], pGuid->Data4[7] );
}


void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    WCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == L'{' )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = wcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

BOOL ValidateGuid( TCHAR *szValue )
{
    //
    // Check if szValue is of form {19e02dd6-79d2-11d2-a89d-00c04fbbcfa2}
    //

    if ( lstrlen(szValue) < GUID_LENGTH )
        return FALSE;

    if ( szValue[0] != TEXT('{')
         || szValue[9] != TEXT('-')
         || szValue[14] != TEXT('-')
         || szValue[19] != TEXT('-')
         || szValue[24] != TEXT('-')
         || szValue[37] != TEXT('}') )
    {
        return FALSE;
    }

    return TRUE;
}



INT CompareGuid( GUID * pGuid1, GUID * pGuid2 )
{
    INT i;

    if ( pGuid1->Data1 != pGuid2->Data1 )
        return ( pGuid1->Data1 < pGuid2->Data1 ? -1 : 1 );

    if ( pGuid1->Data2 != pGuid2->Data2 )
        return ( pGuid1->Data2 < pGuid2->Data2 ? -1 : 1 );

    if ( pGuid1->Data3 != pGuid2->Data3 )
        return ( pGuid1->Data3 < pGuid2->Data3 ? -1 : 1 );

    for ( i = 0; i < 8; i++ )
    {
        if ( pGuid1->Data4[i] != pGuid2->Data4[i] )
            return ( pGuid1->Data4[i] < pGuid2->Data4[i] ? -1 : 1 );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\inc\gpedit.h ===
//-----------------------------------------------------------------------------
//
// GPEDIT.H - Definitions and prototypes for Group Policy
//
// Copyright 1997-2000, Microsoft Corporation
//
//-----------------------------------------------------------------------------

//
// Terminology
//
// Group Policy Editor  -  The tool to view a Group Policy Object.
//
// Group Policy Object  -  A collection of administrator defined policies.
//                         Each Group Policy Object (GPO) has both file system
//                         and Active Directory storage available to it.
//
// IGPEInformation      -  The interface MMC Snapin Extensions use to
//                         talk to the Group Policy Editor.
//
// IGroupPolicyObject   -  The interface used to create/edit a GPO directly
//                         without going through the Group Policy Editor
//


//
// Group Policy Editor MMC SnapIn GUID
//
// {8FC0B734-A0E1-11d1-A7D3-0000F87571E3}

DEFINE_GUID(CLSID_GPESnapIn, 0x8fc0b734, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Editor node ids
//

//
// Computer Configuration\Windows Settings
// {8FC0B737-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_Machine, 0x8fc0b737, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Computer Configuration\Software Settings
// {8FC0B73A-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_MachineSWSettings, 0x8fc0b73a, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration\Windows Settings
// {8FC0B738-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_User, 0x8fc0b738, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration\Software Settings
// {8FC0B73C-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_UserSWSettings, 0x8fc0b73c, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// IGPEInformation interface id
//
// {8FC0B735-A0E1-11d1-A7D3-0000F87571E3}

DEFINE_GUID(IID_IGPEInformation, 0x8fc0b735, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Object class id
//
// {EA502722-A23D-11d1-A7D3-0000F87571E3}

DEFINE_GUID(CLSID_GroupPolicyObject, 0xea502722, 0xa23d, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Object interface id
//
// {EA502723-A23D-11d1-A7D3-0000F87571E3}

DEFINE_GUID(IID_IGroupPolicyObject, 0xea502723, 0xa23d, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// GUID that identifies the registry extension
//

#define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }



//========================================================================================
//
// Resultant Set of Policy node ids
//
//========================================================================================

//
// Resultant Set of Policy MMC SnapIn GUID
//
// {6DC3804B-7212-458D-ADB0-9A07E2AE1FA2}

DEFINE_GUID(CLSID_RSOPSnapIn, 0x6dc3804b, 0x7212, 0x458d, 0xad, 0xb0, 0x9a, 0x07, 0xe2, 0xae, 0x1f, 0xa2);


//
// Computer Configuration\Windows Settings
// {BD4C1A2E-0B7A-4A62-A6B0-C0577539C97E}
//

DEFINE_GUID(NODEID_RSOPMachine, 0xbd4c1a2e, 0x0b7a, 0x4a62, 0xa6, 0xb0, 0xc0, 0x57, 0x75, 0x39, 0xc9, 0x7e);


//
// Computer Configuration\Software Settings
// {6A76273E-EB8E-45DB-94C5-25663A5f2C1A}
//

DEFINE_GUID(NODEID_RSOPMachineSWSettings, 0x6a76273e, 0xeb8e, 0x45db, 0x94, 0xc5, 0x25, 0x66, 0x3a, 0x5f, 0x2c, 0x1a);


//
// User Configuration\Windows Settings
// {AB87364F-0CEC-4CD8-9BF8-898F34628FB8}
//

DEFINE_GUID(NODEID_RSOPUser, 0xab87364f, 0x0cec, 0x4cd8, 0x9b, 0xf8, 0x89, 0x8f, 0x34, 0x62, 0x8f, 0xb8);


//
// User Configuration\Software Settings
// {E52C5CE3-FD27-4402-84DE-D9A5F2858910}
//

DEFINE_GUID(NODEID_RSOPUserSWSettings, 0xe52c5ce3, 0xfd27, 0x4402, 0x84, 0xde, 0xd9, 0xa5, 0xf2, 0x85, 0x89, 0x10);


//
// IRSOPInformation interface id
//
// {9A5A81B5-D9C7-49EF-9D11-DDF50968C48D}

DEFINE_GUID(IID_IRSOPInformation, 0x9a5a81b5, 0xd9c7, 0x49ef, 0x9d, 0x11, 0xdd, 0xf5, 0x09, 0x68, 0xc4, 0x8d);


#ifndef _GPEDIT_H_
#define _GPEDIT_H_


//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_GPEDIT_)
#define GPEDITAPI DECLSPEC_IMPORT
#else
#define GPEDITAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif


#include <objbase.h>


//
// Group Policy Object Section flags
//

#define GPO_SECTION_ROOT                 0  // Root
#define GPO_SECTION_USER                 1  // User
#define GPO_SECTION_MACHINE              2  // Machine


//
// Group Policy Object types
//

typedef enum _GROUP_POLICY_OBJECT_TYPE {
    GPOTypeLocal = 0,                       // GPO on the local machine
    GPOTypeRemote,                          // GPO on a remote machine
    GPOTypeDS                               // GPO in the Active Directory
} GROUP_POLICY_OBJECT_TYPE, *PGROUP_POLICY_OBJECT_TYPE;


//
// Group Policy Hint types
//

typedef enum _GROUP_POLICY_HINT_TYPE {
    GPHintUnknown = 0,                      // No link information available
    GPHintMachine,                          // GPO linked to a machine (local or remote)
    GPHintSite,                             // GPO linked to a site
    GPHintDomain,                           // GPO linked to a domain
    GPHintOrganizationalUnit,               // GPO linked to a organizational unit
} GROUP_POLICY_HINT_TYPE, *PGROUP_POLICY_HINT_TYPE;


#undef INTERFACE
#define INTERFACE   IGPEInformation
DECLARE_INTERFACE_(IGPEInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPEInformation methods ***

    //
    // Returns the unique Group Policy Object name (a GUID)
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns the friendly display name for this Group Policy Object
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetDisplayName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns a registry key handle for the requested section.  The returned
    // key is the root of the registry, not the Policies subkey.  To set / read
    // a value in the Policies subkey, you will need to call RegOpenKeyEx to
    // open Software\Policies subkey first.
    //
    // The handle has been opened with ALL ACCESS rights.  Call RegCloseKey
    // on the handle when finished.
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // hKey contains the registry key on return
    //

    STDMETHOD(GetRegistryKey) (THIS_ DWORD dwSection, HKEY *hKey) PURE;


    //
    // Returns the Active Directory path to the root of the request section.
    // The path is in ADSI name format.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetDSPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the UNC path to the root of the requested section.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the number of characters that can be stored in pszPath.
    //

    STDMETHOD(GetFileSysPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the user preferences (options)
    //
    // Currently, there are no options defined.  This is reserved for future use.
    //
    // dwOptions receives a bitmask value
    //

    STDMETHOD(GetOptions) (THIS_ DWORD *dwOptions) PURE;


    //
    // Returns the type of GPO being edited.
    //
    // The three types are:  a GPO in the Active Directory, the GPO on the local machine,
    // and the GPO on a remote machine.
    //
    // Machine GPOs only have file system storage (no Active Directory storage available).
    // If GetDSPath is called for a machine GPO, the function will succeed
    // and the returned buffer will be the empty string ""
    //
    // Active Directory GPOs have both file system and Active Directory storage available to them.
    //
    // gpoType receives one of the type flags listed above.
    //

    STDMETHOD(GetType) (THIS_ GROUP_POLICY_OBJECT_TYPE *gpoType) PURE;


    //
    // Returns the type of Active Directory object (or machine) that could be linked to
    // this GPO
    //
    // This is a hint api only.  The GPE does not know which Active Directory objects are
    // linked to a particular GPO, but it can offer a hint based upon how the
    // user started the GPE.
    //
    // Use this method with great caution.  Some extensions might want to
    // customize their user interface based upon the scoping for this GPO,
    // but it is easy to offer the wrong namespace.  Best advice is to
    // always offer your full user interface, but if you choose to use this
    // method, always offer your full user interface if you recieve the
    // unknown hint back.
    //
    // gpHint receives one of the hint flags listed above.
    //

    STDMETHOD(GetHint) (THIS_ GROUP_POLICY_HINT_TYPE *gpHint) PURE;


    //
    // Informs the Group Policy Editor that policy settings have changed.
    // Extensions MUST call this methold every time a change is made
    // to a Group Policy Object.
    //
    // bMachine specifies if machine or user policy has changed.
    // bAdd specifies whether this is an add or delete.
    // pGuidExtension is the guid or unique name of extension that
    //    will process this GPO.
    // pGuidSnapin is the guid or unique name of snapin that is making
    //    this call
    //

    STDMETHOD(PolicyChanged) (THIS_ BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin ) PURE;
};
typedef IGPEInformation *LPGPEINFORMATION;


//
// Group Policy Object open / creation flags
//

#define GPO_OPEN_LOAD_REGISTRY      0x00000001  // Load the registry files
#define GPO_OPEN_READ_ONLY          0x00000002  // Open the GPO as read only



//
// Group Policy Object option flags
//

#define GPO_OPTION_DISABLE_USER     0x00000001  // The user portion of this GPO is disabled
#define GPO_OPTION_DISABLE_MACHINE  0x00000002  // The machine portion of this GPO is disabled


#undef INTERFACE
#define INTERFACE   IGroupPolicyObject
DECLARE_INTERFACE_(IGroupPolicyObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGroupPolicyObject methods ***

    //
    // Creates a new GPO in the Active Directory with the given friendly name
    // and opens it via OpenDSGPO().  If pszDomainName contains a domain
    // controller name, the GPO will be created on that DC.  If it does not
    // specify a domain controller name, the method will select a DC on
    // the callers behalf.
    //
    // pszDomainName contains the ADSI path of the domain root
    // pszDisplayName contains the friendly display name
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(New) (THIS_ LPOLESTR pszDomainName, LPOLESTR pszDisplayName,
                    DWORD dwFlags) PURE;


    //
    // Opens the specified Group Policy Object in the Active Directory
    // based upon the passed in flags.  If pszPath contains a domain
    // controller name, the GPO will be opened on that DC.  If it does
    // not contain a domain controller name, the method will select a
    // DC on the callers behalf.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // pszPath contains the ADSI path to the GPO to open
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenDSGPO) (THIS_ LPOLESTR pszPath, DWORD dwFlags) PURE;


    //
    // Opens the default Group Policy Object on this machine with the
    // dwFlags options listed above.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenLocalMachineGPO) (THIS_ DWORD dwFlags) PURE;


    //
    // Opens the default Group Policy Object on a remote machine with the
    // dwFlags options listed above.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // pszComputerName contains the machine name in \\machine format
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenRemoteMachineGPO) (THIS_ LPOLESTR pszComputerName, DWORD dwFlags) PURE;


    //
    // Flushes the registry settings to disk and updates the revision
    // number of the GPO.
    //
    // bMachine specifies if machine or user should be saved.
    // bAdd specifies whether this is an add or delete.
    // pGuidExtension is the guid or unique name of extension that
    //    will process this GPO.
    // pGuid is a guid
    //

    STDMETHOD(Save) (THIS_ BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuid ) PURE;


    //
    // Deletes this Group Policy Object.
    //
    // After calling this method, no other methods are valid to call
    // since the data will have been deleted.
    //

    STDMETHOD(Delete) (THIS) PURE;


    //
    // Returns the unique Group Policy Object name
    //
    // For Active Directory policy objects, this is a GUID
    // For the local policy object, it is the string "Local"
    // For remote policy objects, it is the computername
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns the friendly display name for this Group Policy Object
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetDisplayName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Sets the friendly display name for this Group Policy Object
    //
    // pszName is the new display name
    //

    STDMETHOD(SetDisplayName) (THIS_ LPOLESTR pszName) PURE;


    //
    // Returns the path to the Group Policy Object
    //
    //
    // If the GPO is an Active Directory object, the path is in ADSI name format.
    // If the GPO is a machine object, it is a file system path
    //
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetPath) (THIS_ LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the Active Directory path to the root of the request section.
    // The path is in DN name format.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetDSPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the UNC path to the root of the requested section.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the number of characters that can be stored in pszPath.
    //

    STDMETHOD(GetFileSysPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns a registry key handle for the requested section.  The returned
    // key is the root of the registry, not the Policies subkey.  To set / read
    // a value in the Policies subkey, you will need to call RegOpenKeyEx to
    // open Software\Policies subkey first.
    //
    // The handle has been opened with ALL ACCESS rights.  Call RegCloseKey
    // on the handle when finished.
    //
    // If the GPO was loaded / created without the registry being loaded
    // this method will return E_FAIL.
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // hKey contains the registry key on return
    //

    STDMETHOD(GetRegistryKey) (THIS_ DWORD dwSection, HKEY *hKey) PURE;


    //
    // Returns any options for this Group Policy Object
    //
    // dwOptions receives the GPO_OPTION_* flags
    //

    STDMETHOD(GetOptions) (THIS_ DWORD *dwOptions) PURE;


    //
    // Sets any options for this Group Policy Object
    //
    // This method sets any options for this GPO.  To change
    // an option, that flag must be set in the mask field.
    // If the flag is in the mask field, then the dwOptions
    // field is read for the current state.
    //
    // For example:  to disable the GPO, make this call
    //
    //    SetOptions (GPO_OPTION_DISABLED, GPO_OPTION_DISABLED);
    //
    // dwOptions specifies one or more GPO_OPTION_* flags
    // dwMask specificies which of the dwOptions to change
    //

    STDMETHOD(SetOptions) (THIS_ DWORD dwOptions, DWORD dwMask) PURE;


    //
    // Returns the type of GPO being edited.
    //
    // The three types are:  a GPO in the Active Directory, the GPO on the local machine,
    // and the GPO on a remote machine.
    //
    // Machine GPOs only have file system storage (no Active Directory storage available).
    // If GetDSPath is called for a machine GPO, the function will succeed
    // and the returned buffer will be the empty string ""
    //
    // Active Directory GPOs have both file system and Active Directory storage available to them.
    //
    // gpoType receives one of the type flags
    //

    STDMETHOD(GetType) (THIS_ GROUP_POLICY_OBJECT_TYPE *gpoType) PURE;


    //
    // Returns the machine name of the remote GPO
    //
    // This method returns the name passed to OpenRemoteMachineGPO.
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetMachineName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns an array of property sheet pages and the number of pages
    // in the array
    //
    // Note, this method will allocate memory for the array with
    // LocalAlloc.  When finished, the caller should free the array
    // with LocalFree
    //
    // hPages address of the pointer for the array of property sheet pages
    // uPageCount receives the number of pages in the array
    //

    STDMETHOD(GetPropertySheetPages) (THIS_ HPROPSHEETPAGE **hPages, UINT *uPageCount) PURE;
};
typedef IGroupPolicyObject *LPGROUPPOLICYOBJECT;


//
// RSOP flags
//

#define RSOP_INFO_FLAG_DIAGNOSTIC_MODE  0x00000001      // Running in diagnostic mode vs planning mode

#undef INTERFACE
#define INTERFACE   IRSOPInformation
DECLARE_INTERFACE_(IRSOPInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IRSOPInformation methods ***

    //
    // Returns the namespace for the RSOP data
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // pszName contains the namespace on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetNamespace) (THIS_ DWORD dwSection, LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns information about the RSOP session
    //
    // pdwFlags points to a DWORD which contains the flags on return
    //

    STDMETHOD(GetFlags) (THIS_ DWORD * pdwFlags) PURE;


    //
    // Returns the event log text for a specific entry
    //
    // lpEventSource - event log source name
    // lpEventLogName - event log name
    // lpEventTime - event log time in WMI datetime format
    // dwEventID - event ID
    // lpText - Receives a pointer to a buffer containing the text.
    //          The caller should free this buffer with CoTaskMemFree.
    //

    STDMETHOD(GetEventLogEntryText) (THIS_ LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                           LPOLESTR pszEventTime, DWORD dwEventID,  LPOLESTR *ppszText) PURE;

};
typedef IRSOPInformation *LPRSOPINFORMATION;


//=============================================================================
//
// CreateGPOLink
//
// Creates a link to a GPO for the specified Site, Domain, or Organizational Unit
//
// lpGPO         - ADSI path to the GPO
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
// fHighPriority - Create the link as the highest or lowest priority
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
CreateGPOLink(
    LPOLESTR lpGPO,
    LPOLESTR lpContainer,
    BOOL fHighPriority);


//=============================================================================
//
// DeleteGPOLink
//
// Deletes a link to a GPO for the specified Site, Domain, or Organizational Unit
//
// lpGPO         - ADSI path to the GPO
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
DeleteGPOLink(
    LPOLESTR lpGPO,
    LPOLESTR lpContainer);


//=============================================================================
//
// DeleteAllGPOLinks
//
// Deletes all GPO links for the specified Site, Domain, or Organizational Unit
//
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
DeleteAllGPOLinks(
    LPOLESTR lpContainer);


//=============================================================================
//
// BrowseForGPO
//
// Displays the GPO browser dialog
//
// lpBrowseInfo   - Address of a GPOBROWSEINFO structure
//
// Returns:  S_OK if successful
//
//=============================================================================

//
// Flags passed in the dwFlags field of the GPOBROWSEINFO structure
//

#define GPO_BROWSE_DISABLENEW           0x00000001   // Disables the New GPO functionality on all pages except "All"
#define GPO_BROWSE_NOCOMPUTERS          0x00000002   // Removes the Computers tab
#define GPO_BROWSE_NODSGPOS             0x00000004   // Removes the Domain/OU and Sites tabs
#define GPO_BROWSE_OPENBUTTON           0x00000008   // Change the Ok button to say Open
#define GPO_BROWSE_INITTOALL            0x00000010   // Initialize the dialog focused on the All pane

typedef struct tag_GPOBROWSEINFO
{
    DWORD       dwSize;                   // [in] Initialized to the size of this structure
    DWORD       dwFlags;                  // [in] Flags defined above
    HWND        hwndOwner;                // [in] Parent window handle (can be NULL)
    LPOLESTR    lpTitle;                  // [in] Title bar text.  If NULL, "Browse for a Group Policy Object" will be the default text
    LPOLESTR    lpInitialOU;              // [in] Initial Domain/Organizational Unit to open focus on
    LPOLESTR    lpDSPath;                 // [in/out] Pointer to the buffer that receives the Active Directory GPO path
    DWORD       dwDSPathSize;             // [in] Size in characters of buffer given in lpDSPath
    LPOLESTR    lpName;                   // [in/out] Pointer to a buffer that receives either the computer name or
                                          //      the friendly name of the GPO (can be NULL)
    DWORD       dwNameSize;               // [in] Size in characters of buffer given in lpName
    GROUP_POLICY_OBJECT_TYPE    gpoType;  // [out] Specifies the type of GPO
    GROUP_POLICY_HINT_TYPE      gpoHint;  // [out] Specifies a hint of the GPO association
} GPOBROWSEINFO, *LPGPOBROWSEINFO;


GPEDITAPI
HRESULT
WINAPI
BrowseForGPO(
    LPGPOBROWSEINFO lpBrowseInfo);


//=============================================================================
//
// ImportRSoPData
//
// Imports a data file generated by ExportRSoPData
//
// lpNameSpace   - Namespace to place the data in
// lpFileName    - Filename containing the data
//
// Returns:  S_OK if successful
//
// Notes:    The namespace specified in lpNameSpace must exist prior to calling
//           this function.
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
ImportRSoPData(
    LPOLESTR lpNameSpace,
    LPOLESTR lpFileName);


//=============================================================================
//
// ExportRSoPData
//
// Exports a WBEM namespace containing RSoP information to a data file.
// This data file can be imported to a WBEM namespace using ImportRSoPData.
//
// lpNameSpace   - Namespace to read the data from
// lpFileName    - Filename to receive the data
//
// Returns:  S_OK if successful
//
// Notes:    This function should be called twice.  Once for the user data
//           and once for the computer data.
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
ExportRSoPData(
    LPOLESTR lpNameSpace,
    LPOLESTR lpFileName);

#ifdef __cplusplus
}
#endif


#endif  /* _GPEDIT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\dialogs.h ===
#define IDD_VIEW_MPR                100
#define IDD_VIEW_MPR_USERNAME       105
#define IDD_VIEW_MPR_DOMAIN         106
#define IDD_VIEW_MPR_PASSWORD       107
#define IDD_VIEW_MPR_OLD_PASSWORD   108
#define IDD_USERDEF_SAS             200
#define IDD_SAS_USERNAME            201
#define IDD_SAS_VALUE               204
#define IDD_SAS_KEEPAROUND          205
#define IDD_SAS_REMOVE              206
#define IDD_START_APP               300
#define IDD_STARTAPP_CB             302
#define IDD_VIEW_MPR_PROVIDER       110
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created.
//
//----------------------------------------------------------------------------

//
//  For ease of debugging the SPMgr, all the debug support functions have
//  been stuck here.  Basically, we read info from win.ini, since that allows
//  us to configure the debug level via a text file (and DOS, for example).
//
//  Format is:
//
//  win.ini
//
//  [SPMgr]
//      DebugFlags=<Flag>[<,Flag>]*
//      Package=<int>
//      BreakFlags=<BreakFlag>[<,BreakFlags>]*
//
//  WHERE:
//      Flag is one of the following:
//          Error, Warning, Trace, Verbose, BreakOnError, Helpers,
//          RefMon, Locator, WAPI, Init, Audit, Db, Lsa
//
//      Package is the name of the dll implementing the package, e.g.
//          NTLM=3
//
//      BreakFlags will cause SPMgr to break, if BreakOnError is set in
//      DebugFlags:
//          InitBegin, InitEnd, Connect, Exception, Problem, Load
//
//


#include "testgina.h"
#include <stdio.h>
#include <wchar.h>

FILE *  LogFile;



// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.


//+---------------------------------------------------------------------------
//
//  Function:   LogEvent
//
//  Synopsis:   Logs an event to the console and, optionally, a file.
//
//  Effects:
//
//  Arguments:  [Mask]   --
//              [Format] --
//              [Format] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
LogEvent(   long            Mask,
            const char *    Format,
            ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    char    szOutString[256];
    long    OriginalMask = Mask;


    if (1)
    {

        //
        // Make the prefix first:  "Process.Thread> GINA-XXX"
        //

        PrefixSize = sprintf(szOutString, "%d.%d> %s: ",
                GetCurrentProcessId(), GetCurrentThreadId(), "TestGINA");


        va_start(ArgList, Format);

        if (_vsnprintf(&szOutString[PrefixSize], sizeof(szOutString) - PrefixSize,
                            Format, ArgList) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("GINA!LogEvent:  Could not pack string into 256 bytes\n");

        }
        else
        {
            OutputDebugStringA(szOutString);
        }


        if (LogFile)
        {
            SYSTEMTIME  stTime;
            FILETIME    ftTime;
            FILETIME    localtime;

            NtQuerySystemTime((PLARGE_INTEGER) &ftTime);
            FileTimeToLocalFileTime(&ftTime, &localtime);
            FileTimeToSystemTime(&localtime, &stTime);
            fprintf(LogFile, "%02d:%02d:%02d.%03d: %s\n",
                    stTime.wHour, stTime.wMinute, stTime.wSecond,
                    stTime.wMilliseconds, szOutString);

            fflush(LogFile);
        }

    }

}

void
OpenLogFile(LPSTR   pszLogFile)
{
    LogFile = fopen(pszLogFile, "a");
    if (!LogFile)
    {
        OutputDebugStringA("GINA: Could not open logfile for append");
        OutputDebugStringA(pszLogFile);
    }
    LogEvent(0, "Log File Begins\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\menu.h ===
#define TESTGINAMENU        1000
#define IDM_DLL_OPEN        1010
#define IDM_DLL_RESET       1011
#define IDM_DLL_RUN         1012
#define IDM_DLL_EXIT        1013
#define IDM_DLL_LOAD_LAST   1014

#define IDM_WHACK_NEGOTIATE     1020
#define IDM_WHACK_INITIALIZE    1021
#define IDM_WHACK_DISPLAY       1022
#define IDM_WHACK_LOGGEDOUT     1023
#define IDM_WHACK_LOGGEDON      1024
#define IDM_WHACK_DISPLAYLOCKED 1025
#define IDM_WHACK_LOCKED        1026
#define IDM_WHACK_STARTSHELL    1027
#define IDM_WHACK_LOGOFF        1028
#define IDM_WHACK_SHUTDOWN      1029
#define IDM_WHACK_LOGOFFOK      1050
#define IDM_WHACK_LOCKOK        1051
#define IDM_WHACK_SCREENSAVE    1052
#define IDM_WHACK_RESTARTSHELL  1053

#define IDM_OPTIONS_SAS         1030
#define IDM_OPTIONS_TIMEOUT     1031
#define IDM_OPTIONS_LOGOFF      1032
#define IDM_OPTIONS_VIEW_MPR    1033
#define IDM_OPTIONS_SSNOTIFY    1034
#define IDM_OPTIONS_STARTAPP    1035

#define IDM_HELP_HELP   1040
#define IDM_HELP_ABOUT  1041

#define DEBUGGINAMENU           1100
#define IDM_DEBUG_BREAK_NOW     1101
#define IDM_DEBUG_NEGOTIATE     1102
#define IDM_DEBUG_INITIALIZE    1103
#define IDM_DEBUG_DISPLAYSAS    1104
#define IDM_DEBUG_LOGGEDOUT     1105
#define IDM_DEBUG_ACTIVATE      1106
#define IDM_DEBUG_LOGGEDON      1107
#define IDM_DEBUG_DISPLAYLOCKED 1108
#define IDM_DEBUG_LOCKED        1109
#define IDM_DEBUG_LOGOFF        1110
#define IDM_DEBUG_SHUTDOWN      1111
#define IDM_DEBUG_LOGOFFOK      1112
#define IDM_DEBUG_LOCKOK        1113
#define IDM_DEBUG_SCREENSAVE    1114
#define IDM_DEBUG_RESTARTSHELL  1115

#define IDM_SAS_CAD     1051
#define IDM_SAS_TIMEOUT 1052
#define IDM_SAS_SCRNSVR 1053
#define IDM_SAS_USERDEF 1054
#define IDM_SAS_USERDEF1    1055
#define IDM_SAS_USERDEF2    1056
#define IDM_SAS_USERDEF3    1057
#define IDM_SAS_USERDEF4    1058
#define IDM_SAS_SC_INSERT 1060
#define IDM_SAS_SC_REMOVE 1061
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\fsm.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       wlx.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-15-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"


typedef _FSM_Determinant {
    DWORD           Response;
    WinstaState     NextState;
} FSM_Determinant;

typedef struct _FSM_Node {
    WinstaState     State;
    DWORD           Function;
    DWORD           cStates;
    FSM_Determinant Choices[];
} FSM_Node;

#define ANY_RETURN  0xFFFFFFFF

FSM_Node    TestGinaFSM[] = {
                    { Winsta_PreLoad, WLX_NEGOTIATE_API, 1, {{ANY_RETURN, Winsta_Initialize}}},
                    { Winsta_Initialize, WLX_INITIALIZE_API, 1, {{ANY_RETURN, Winsta_NoOne}}},
                    { Winsta_NoOne, WLX_DISPLAYSASNOTICE_API, 1, {{ANY_RETURN, Winsta_NoOne_SAS}}},
                    { Winsta_NoOne_Display, -1, 1, {{ANY_RETURN, Winsta_NoOne_SAS}}},
                    { Winsta_NoOne_SAS, WLX_LOGGEDOUTSAS_API, 5,
                        {WLX_SAS_ACTION_NONE, Winsta_NoOne},
                        {WLX_SAS_ACTION_SHUTDOWN, Winsta_Shutdown},
                        {WLX_SAS_ACTION_SHUTDOWN_REBOOT, Winsta_Shutdown},
                        {WLX_SAS_ACTION_SHUTDOWN_POWER_OFF, Winsta_Shutdown},
                        {WLX_SAS_ACTION_USER_LOGON, Winsta_LoggedOnUser_StartShell}
                        }},
                    { Winsta_LoggedOnUser_StartShell, WLX_ACTIVATEUSERSHELL_API, 1, {{ANY_RETURN, Winsta_LoggedOnUser}}},
                    { Winsta_LoggedOnUser_SAS, WLX_LOGGEDONSAS_API,
                    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\desktops.c ===
//+---------------------------------------------------------------------------
//
//  File:       desktops.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-02-96   RichardW   Created
//
//----------------------------------------------------------------------------


#include "testgina.h"

BOOL
AddDesktop(
    DWORD   Index,
    PWSTR   Name)
{
    PWLX_DESKTOP    pDesk;

    pDesk = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                        sizeof( WLX_DESKTOP ) +
                        ( wcslen(Name) + 1 ) * sizeof(WCHAR) );

    if ( pDesk )
    {
        pDesk->Size = sizeof( WLX_DESKTOP );
        pDesk->Flags = WLX_DESKTOP_NAME;
        pDesk->pszDesktopName = (PWSTR) ( pDesk + 1 );
        wcscpy( pDesk->pszDesktopName, Name );

        Desktops[ Index ] = pDesk;

        return( TRUE );
    }

    return( FALSE );
}

PWLX_DESKTOP
CopyDesktop(
    PWLX_DESKTOP    pOrig)
{
    PWLX_DESKTOP    pDesk;

    if ( pOrig->pszDesktopName )
    {
        pDesk = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                            sizeof( WLX_DESKTOP ) +
                            ( wcslen( pOrig->pszDesktopName ) + 1 ) * 2 );
    }
    else
    {
        pDesk = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                            sizeof( WLX_DESKTOP ) );

    }

    if ( pDesk )
    {
        *pDesk = *pOrig;
        if ( pOrig->pszDesktopName )
        {
            pDesk->pszDesktopName = (PWSTR) (pDesk + 1);
            wcscpy( pDesk->pszDesktopName, pOrig->pszDesktopName );
        }
    }

    return( pDesk );
}

BOOL
InitializeDesktops( VOID )
{
    ZeroMemory( Desktops, sizeof( PWLX_DESKTOP ) * MAX_DESKTOPS );

    AddDesktop( WINLOGON_DESKTOP, TEXT("Winlogon") );
    AddDesktop( DEFAULT_DESKTOP, TEXT("Default") );
    AddDesktop( SCREENSAVER_DESKTOP, TEXT("Screen-Saver") );

    CurrentDesktop = WINLOGON_DESKTOP;
    OtherDesktop = WINLOGON_DESKTOP;
    DesktopCount = 3;

    return( TRUE );
}


int
WINAPI
WlxGetSourceDesktop(
    HANDLE                  hWlx,
    PWLX_DESKTOP *          ppDesktop)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxGetSourceDesktop"));
    }

    *ppDesktop = CopyDesktop( Desktops[ OtherDesktop ] );

    return( 0 );
}

int
WINAPI
WlxSetReturnDesktop(
    HANDLE                  hWlx,
    PWLX_DESKTOP            pDesktop)
{
    DWORD   i;

    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetReturnDesktop"));
    }

    for ( i = 0 ; i < DesktopCount ; i++ )
    {
        if ( _wcsicmp( pDesktop->pszDesktopName, Desktops[ i ]->pszDesktopName ) == 0 )
        {
            break;
        }
    }

    if ( i == WINLOGON_DESKTOP )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetReturnDesktop"));
    }

    if ( i == DesktopCount )
    {
        AddDesktop( DesktopCount, pDesktop->pszDesktopName );
        DesktopCount ++ ;
    }

    OtherDesktop = i;

    return( 0 );
}

int
WINAPI
WlxCreateUserDesktop(
    HANDLE                  hWlx,
    HANDLE                  hToken,
    DWORD                   Flags,
    PWSTR                   pszDesktopName,
    PWLX_DESKTOP *          ppDesktop )
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxCreateUserDesktop"));
    }

    AddDesktop( DesktopCount, pszDesktopName );

    *ppDesktop = CopyDesktop( Desktops[ DesktopCount ] );

    DesktopCount++;

    return( 0 );

}

BOOL
WINAPI
WlxCloseUserDesktop(
    HANDLE hWlx,
    PWLX_DESKTOP Desktop,
    HANDLE Token
    )
{
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\sunlogon\sunlogon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       sunlogon.c
//
//  Contents:   Intermediate startup app for sundown to keep going
//
//  Classes:
//
//  Functions:
//
//  History:    3-03-98   RichardW   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbasep.h>
#include <winuserp.h>
#include <userenv.h>
#include <userenvp.h>

HANDLE WindowStation ;
HANDLE DefaultDesktop ;
HANDLE WinlogonDesktop ;


BOOL
CreatePrimaryTerminal(
    VOID)
{

    //
    // Create the window station
    //

    WindowStation = CreateWindowStationW(
                            TEXT("WinSta0"),
                            0,
                            MAXIMUM_ALLOWED,
                            NULL);

    if ( !WindowStation ) {
        DbgPrint( "Failed to create WindowStation in win32k/user\n" );
        goto failCreateTerminal;
    }

    SetProcessWindowStation( WindowStation );

    //
    // Create the application desktop
    //

    DefaultDesktop = CreateDesktopW(
                                TEXT("Default"),
                                NULL,
                                NULL,
                                0,
                                MAXIMUM_ALLOWED,
                                NULL );

    if ( !DefaultDesktop ) {
        DbgPrint( "Could not create Default desktop\n" );
        goto failCreateTerminal;
    }


    return TRUE ;

failCreateTerminal:

    //
    // Cleanup
    //

    return FALSE;
}

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    STARTUPINFO si ;
    PROCESS_INFORMATION pi ;
    BOOL Result ;
    WCHAR InitialCommand[ MAX_PATH ];
    WCHAR szComputerName[ 18 ];
    DWORD dwComputerNameSize = 18 ;
    DWORD dwSize ;
    LUID luidNone = { 0, 0 };
    NTSTATUS Status ;
    HANDLE Token ;

    //
    // Get a copy of the computer name in *my* environment, so that we
    // can look at it later.
    //

    if (GetComputerName (szComputerName, &dwComputerNameSize)) {

        SetEnvironmentVariable(
            TEXT("COMPUTERNAME"),
            (LPTSTR) szComputerName);
    }


    //
    // Set the default USERPROFILE location
    //


    dwSize = MAX_PATH ;
    if ( GetDefaultUserProfileDirectory( InitialCommand, &dwSize ) )
    {
        SetEnvironmentVariable( TEXT("USERPROFILE" ), InitialCommand );
    }



    if (!RegisterLogonProcess(
            HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
            TRUE)) {

        DbgPrint( "Failed to register with win32/user as the logon process\n" );
        return 0;
    }

    if ( !CreatePrimaryTerminal() )
    {
        DbgPrint( "Failed to create terminal\n" );
        return 0 ;
    }

    SwitchDesktop( DefaultDesktop );

    SetThreadDesktop( DefaultDesktop );


    //
    // Whack system as current user:
    //

    SetWindowStationUser( WindowStation, &luidNone, NULL, 0 );

    Status = NtOpenProcessToken(
                    NtCurrentProcess(),
                    MAXIMUM_ALLOWED,
                    &Token );

    if ( NT_SUCCESS( Status ) )
    {
        UpdatePerUserSystemParameters( Token, UPUSP_USERLOGGEDON );
    }
    //
    // At this stage, we're mostly set.
    //

    wcscpy( InitialCommand, TEXT("cmd.exe") );

    do
    {

        ZeroMemory(&si, sizeof(STARTUPINFO));
        si.cb = sizeof(STARTUPINFO);
        si.lpTitle = InitialCommand ;
        si.dwFlags = 0 ;
        si.wShowWindow = SW_SHOW;   // at least let the guy see it
        si.lpDesktop = TEXT("Winsta0\\Default");

        Result = CreateProcessW(
                        NULL,
                        InitialCommand,
                        NULL,
                        NULL,
                        FALSE,
                        0,
                        NULL,
                        NULL,
                        &si,
                        &pi );

        if ( !Result )
        {
            DbgPrint(" Failed to start initial command\n" );
            return 0;
        }

        CloseHandle( pi.hThread );
        WaitForSingleObjectEx( pi.hProcess, INFINITE, FALSE );


    } while ( 1 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\testgina.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       testgina.h
//
//  Contents:   Main header file for testgina.exe
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#define UNICODE

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <lmsname.h>
#endif


#include <windows.h>
#include <shellapi.h>
#include <commctrl.h>
#include <stdio.h>

#ifndef RC_INVOKED

#include <winwlx.h>

typedef
BOOL (WINAPI * PWLX_NEGOTIATE)(
    DWORD, DWORD *);

typedef
BOOL (WINAPI * PWLX_INITIALIZE)(
    LPWSTR, HANDLE, PVOID, PVOID, PVOID *);

typedef
VOID (WINAPI * PWLX_DISPLAYSASNOTICE)(
    PVOID );

typedef
int (WINAPI * PWLX_LOGGEDOUTSAS)(
    PVOID, DWORD, PLUID, PSID, PDWORD, PHANDLE, PWLX_MPR_NOTIFY_INFO, PVOID);

typedef
VOID (WINAPI * PWLX_ACTIVATEUSERSHELL)(
    PVOID, PWSTR, PWSTR, PVOID);

typedef
int (WINAPI * PWLX_LOGGEDONSAS)(
    PVOID, DWORD, PWLX_MPR_NOTIFY_INFO);

typedef
VOID (WINAPI * PWLX_DISPLAYLOCKEDNOTICE)(
    PVOID );

typedef
int (WINAPI * PWLX_WKSTALOCKEDSAS)(
    PVOID, DWORD );

typedef
VOID (WINAPI * PWLX_LOGOFF)(
    PVOID );

typedef
VOID (WINAPI * PWLX_SHUTDOWN)(
    PVOID );

#define WLX_NEGOTIATE_NAME          "WlxNegotiate"
#define WLX_INITIALIZE_NAME         "WlxInitialize"
#define WLX_DISPLAYSASNOTICE_NAME   "WlxDisplaySASNotice"
#define WLX_LOGGEDOUTSAS_NAME       "WlxLoggedOutSAS"
#define WLX_ACTIVATEUSERSHELL_NAME  "WlxActivateUserShell"
#define WLX_LOGGEDONSAS_NAME        "WlxLoggedOnSAS"
#define WLX_DISPLAYLOCKED_NAME      "WlxDisplayLockedNotice"
#define WLX_WKSTALOCKEDSAS_NAME     "WlxWkstaLockedSAS"
#define WLX_LOGOFF_NAME             "WlxLogoff"
#define WLX_SHUTDOWN_NAME           "WlxShutdown"

#define WLX_NEGOTIATE_API           0
#define WLX_INITIALIZE_API          1
#define WLX_DISPLAYSASNOTICE_API    2
#define WLX_LOGGEDOUTSAS_API        3
#define WLX_ACTIVATEUSERSHELL_API   4
#define WLX_LOGGEDONSAS_API         5
#define WLX_DISPLAYLOCKED_API       6
#define WLX_WKSTALOCKEDSAS_API      7
#define WLX_LOGOFF_API              8
#define WLX_SHUTDOWN_API            9


typedef enum _WinstaState {
    Winsta_PreLoad,
    Winsta_Initialize,
    Winsta_NoOne,
    Winsta_NoOne_Display,
    Winsta_NoOne_SAS,
    Winsta_LoggedOnUser_StartShell,
    Winsta_LoggedOnUser,
    Winsta_LoggedOn_SAS,
    Winsta_Locked,
    Winsta_Locked_SAS,
    Winsta_WaitForShutdown,
    Winsta_Shutdown
} WinstaState;

typedef struct _USER_SAS {
    DWORD       Value;
    WCHAR       Name[128];
} USER_SAS, * PUSER_SAS;
#define MAX_USER_SASES          4


#define UPDATE_INITIALIZE       0
#define UPDATE_DISPLAY_NOTICE   1
#define UPDATE_SAS_RECEIVED     2
#define UPDATE_USER_LOGON       3
#define UPDATE_LOCK_WKSTA       4
#define UPDATE_UNLOCK_WKSTA     5
#define UPDATE_LOGOFF           6
#define UPDATE_SAS_BYPASS       7
#define UPDATE_SAS_COMPLETE     8
#define UDPATE_FORCE_LOGOFF     9
#define UPDATE_SHUTDOWN         10

void
UpdateGinaState(DWORD   Update);


void TestGinaError(DWORD, PWSTR);

#define GINAERR_INVALID_HANDLE      1
#define GINAERR_IMPROPER_CAD        2
#define GINAERR_INVALID_LEVEL       3
#define GINAERR_LOAD_FAILED         4
#define GINAERR_MISSING_FUNCTION    5
#define GINAERR_UNKNOWN_HWND        6
#define GINAERR_NO_WINDOW_FOR_SAS   7
#define GINAERR_INVALID_SAS_CODE    8
#define GINAERR_INVALID_RETURN      9
#define GINAERR_DIALOG_ERROR        10


#define MAX_DESKTOPS                16
#define WINLOGON_DESKTOP            0
#define DEFAULT_DESKTOP             1
#define SCREENSAVER_DESKTOP         2


void LoadParameters(void);
void SaveParameters(void);
void
SaveGinaSpecificParameters(void);
void
LoadGinaSpecificParameters(
    VOID );
VOID
UpdateSasMenu(VOID);
VOID
EnableOptions(BOOL Enable);

VOID WINAPI WlxUseCtrlAltDel(HANDLE);
VOID WINAPI WlxSasNotify(HANDLE, DWORD);
VOID WINAPI WlxSetContextPointer(HANDLE, PVOID);
BOOL WINAPI WlxSetTimeout(HANDLE, DWORD);
int WINAPI  WlxAssignShellProtection(HANDLE, HANDLE, HANDLE, HANDLE);
int WINAPI  WlxMessageBox(HANDLE, HWND, LPWSTR, LPWSTR, UINT);
int WINAPI  WlxDialogBox(HANDLE, HANDLE, LPWSTR, HWND, DLGPROC);
int WINAPI  WlxDialogBoxIndirect(HANDLE, HANDLE, LPCDLGTEMPLATE, HWND, DLGPROC);
int WINAPI  WlxDialogBoxParam(HANDLE, HANDLE, LPWSTR, HWND, DLGPROC, LPARAM);
int WINAPI  WlxDialogBoxIndirectParam(HANDLE, HANDLE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM);
int WINAPI  WlxSwitchDesktopToUser(HANDLE);
int WINAPI  WlxSwitchDesktopToWinlogon(HANDLE);
int WINAPI  WlxChangePasswordNotify(HANDLE, PWLX_MPR_NOTIFY_INFO, DWORD);
BOOL WINAPI WlxGetSourceDesktop(HANDLE, PWLX_DESKTOP *);
BOOL WINAPI WlxSetReturnDesktop(HANDLE, PWLX_DESKTOP);
BOOL WINAPI WlxCreateUserDesktop(HANDLE, HANDLE, DWORD, PWSTR, PWLX_DESKTOP *);
int WINAPI WlxChangePasswordNotifyEx( HANDLE, PWLX_MPR_NOTIFY_INFO, DWORD, PWSTR, PVOID);
BOOL WINAPI WlxCloseUserDesktop( HANDLE, PWLX_DESKTOP, HANDLE );
BOOL WINAPI WlxSetOption( HANDLE, DWORD, ULONG_PTR, ULONG_PTR * );
BOOL WINAPI WlxGetOption( HANDLE, DWORD, ULONG_PTR * );
VOID WINAPI WlxWin31Migrate( HANDLE );
BOOL WINAPI WlxQueryClientCredentials( PWLX_CLIENT_CREDENTIALS_INFO_V1_0 );
BOOL WINAPI WlxQueryICCredentials( PWLX_CLIENT_CREDENTIALS_INFO_V1_0 );
BOOL WINAPI WlxDisconnect( VOID );
int UpdateMenuBar(void);
void UpdateStatusBar(void);
PingSAS(DWORD   SasType);

BOOLEAN LoadGinaDll(void);
BOOLEAN TestNegotiate(void);
BOOLEAN TestInitialize(void);
BOOLEAN TestDisplaySASNotice(void);
int     TestLoggedOutSAS(int    SasType);
int     TestLoggedOnSAS(int SasType);
int     TestActivateUserShell(void);
int     TestWkstaLockedSAS(int SasType);
int     TestDisplayLockedNotice(void);
int     TestLogoff(void);
BOOL
InitializeDesktops( VOID );

BOOLEAN AmIBeingDebugged(void);

void    LogEvent(long Mask, const char * Format, ...);

LRESULT
CALLBACK
WndProc(
    HWND    hWnd,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam);

BOOL    AssociateHandle(HANDLE);
BOOL    VerifyHandle(HANDLE);
BOOL    StashContext(PVOID);
PVOID   GetContext(VOID);
BOOL
ValidResponse(
    DWORD       ApiNum,
    DWORD       Response);




//
// Global Variables

extern  HINSTANCE   hDllInstance;
extern  HINSTANCE   hAppInstance;
extern  DWORD       DllVersion;
extern  HICON       hIcon;
extern  HWND        hMainWindow;
extern  HWND        hStatusWindow;
extern  DWORD       StatusHeight;
extern  DWORD       fTestGina;
extern  DWORD       GinaBreakFlags;
extern  WinstaState GinaState;
extern  DWORD       LastRetCode;
extern  BOOL        LastBoolRet;
extern  WCHAR       szGinaDll[];
extern  WLX_DISPATCH_VERSION_1_3    WlxDispatchTable;
extern  HANDLE      hThread;
extern  DWORD       SizeX, SizeY;
extern  DWORD       PosX, PosY;
extern  DWORD       StatusDeltaX, StatusDeltaY;
extern  DWORD       StatusHeight;
extern  WLX_MPR_NOTIFY_INFO GlobalMprInfo;
extern  HMENU       hDebugMenu;
extern  USER_SAS    UserDefSas[4];
extern  DWORD       UserSases;
extern  PVOID       pWlxContext;
extern  WCHAR       GlobalProviderName[];

extern  DWORD           CurrentDesktop;
extern  PWLX_DESKTOP    Desktops[];
extern  DWORD           OtherDesktop;
extern  DWORD           DesktopCount;


#define WLX_SAS_ACTION_BOOL_RET 12


//
// Function Pointers in DLL:
//

extern  PWLX_NEGOTIATE              pWlxNegotiate;
extern  PWLX_INITIALIZE             pWlxInitialize;
extern  PWLX_DISPLAYSASNOTICE       pWlxDisplaySASNotice;
extern  PWLX_LOGGEDOUTSAS           pWlxLoggedOutSAS;
extern  PWLX_ACTIVATEUSERSHELL      pWlxActivateUserShell;
extern  PWLX_LOGGEDONSAS            pWlxLoggedOnSAS;
extern  PWLX_DISPLAYLOCKEDNOTICE    pWlxDisplayLockedNotice;
extern  PWLX_WKSTALOCKEDSAS         pWlxWkstaLockedSAS;
extern  PWLX_LOGOFF                 pWlxLogoff;
extern  PWLX_SHUTDOWN               pWlxShutdown;

#define GINA_USE_CAD        0x00000001      // DLL requested Use CAD
#define GINA_DLL_KNOWN      0x00000002      // DLL name has been determined
#define GINA_USE_SC         0x00000004

#define GINA_NEGOTIATE_OK   0x80000000      // Ok to call Negotiate
#define GINA_INITIALIZE_OK  0x40000000      // Ok to call Initialize
#define GINA_LOGGEDOUT_OK   0x20000000      // Ok to call LoggedOutSAS
#define GINA_ACTIVATE_OK    0x10000000      // Ok to call Activate
#define GINA_LOGGEDON_OK    0x08000000      // Ok to call LoggedOnSAS
#define GINA_DISPLAYLOCK_OK 0x04000000      // Ok to call DisplayLockedNotice
#define GINA_WKSTALOCK_OK   0x02000000      // Ok to call WkstaLockedSAS
#define GINA_LOGOFF_OK      0x01000000      // Ok to call Logoff
#define GINA_SHUTDOWN_OK    0x00800000      // Ok to call Shutdown
#define GINA_DISPLAY_OK     0x00400000      // Ok to call Display
#define GINA_ISLOCKOK_OK    0x00200000      // Ok to call IsLockOk
#define GINA_ISLOGOFFOK_OK  0x00100000      // Ok to call IsLogoffOk
#define GINA_RESTART_OK     0x00080000      // Ok to call RestartShell
#define GINA_SCREENSAVE_OK  0x00040000      // Ok to call ScreenSaverNotify
#define GINA_DISPLAYLOG_OK  0x00020000

#define BREAK_NEGOTIATE     0x00000001
#define BREAK_INITIALIZE    0x00000002
#define BREAK_DISPLAY       0x00000004
#define BREAK_LOGGEDOUT     0x00000008
#define BREAK_ACTIVATE      0x00000010
#define BREAK_LOGGEDON      0x00000020
#define BREAK_DISPLAYLOCKED 0x00000040
#define BREAK_WKSTALOCKED   0x00000080
#define BREAK_LOGOFF        0x00000100
#define BREAK_SHUTDOWN      0x00000200

#define FLAG_ON(dw, f)      dw |= (f)
#define FLAG_OFF(dw, f)     dw &= (~(f))
#define TEST_FLAG(dw, f)    ((BOOL)(dw & (f)))


#endif // RC_INVOKED

#include "menu.h"
#include "dialogs.h"

#define TESTGINAICON    10
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\testgina.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msgina.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"
#include <stdio.h>
#include <wchar.h>

HINSTANCE                   hDllInstance;   // Dll instance,
DWORD                       DllVersion;     // Dll Version
HINSTANCE                   hAppInstance;   // App instance, for dialogs, etc.
HWND                        hMainWindow;    // Main window
WNDCLASS                    WndClass;       // Window class
HICON                       hIcon;
WNDCLASS                    StatusClass;    // Status Window class
HWND                        hStatusWindow;  // Status Window
HMENU                       hDebugMenu;     // Debug Menu

USER_SAS                    UserDefSas[MAX_USER_SASES];
DWORD                       UserSases;

DWORD                       CurrentDesktop;
PWLX_DESKTOP                Desktops[ MAX_DESKTOPS ];
DWORD                       DesktopCount;
DWORD                       OtherDesktop;

LRESULT StatusProc(HWND, UINT, WPARAM, LPARAM);

WLX_DISPATCH_VERSION_1_3    WlxDispatchTable = {
                                WlxUseCtrlAltDel,
                                WlxSetContextPointer,
                                WlxSasNotify,
                                WlxSetTimeout,
                                WlxAssignShellProtection,
                                WlxMessageBox,
                                WlxDialogBox,
                                WlxDialogBoxParam,
                                WlxDialogBoxIndirect,
                                WlxDialogBoxIndirectParam,
                                WlxSwitchDesktopToUser,
                                WlxSwitchDesktopToWinlogon,
                                WlxChangePasswordNotify,
                                WlxGetSourceDesktop,
                                WlxSetReturnDesktop,
                                WlxCreateUserDesktop,
                                WlxChangePasswordNotifyEx,
                                WlxCloseUserDesktop,
                                WlxSetOption,
                                WlxGetOption,
                                WlxWin31Migrate,
                                WlxQueryClientCredentials,
                                WlxQueryICCredentials,
                                WlxDisconnect };

PWLX_NEGOTIATE              pWlxNegotiate;
PWLX_INITIALIZE             pWlxInitialize;
PWLX_DISPLAYSASNOTICE       pWlxDisplaySASNotice;
PWLX_LOGGEDOUTSAS           pWlxLoggedOutSAS;
PWLX_ACTIVATEUSERSHELL      pWlxActivateUserShell;
PWLX_LOGGEDONSAS            pWlxLoggedOnSAS;
PWLX_DISPLAYLOCKEDNOTICE    pWlxDisplayLockedNotice;
PWLX_WKSTALOCKEDSAS         pWlxWkstaLockedSAS;
PWLX_LOGOFF                 pWlxLogoff;
PWLX_SHUTDOWN               pWlxShutdown;

WinstaState                 GinaState;              // State of the GinaTest
DWORD                       fTestGina;              // Flags
DWORD                       GinaBreakFlags;         // Break points for Gina debugging
WCHAR                       szGinaDll[MAX_PATH];    // Path and name of the DLL
DWORD                       SizeX, SizeY;
DWORD                       PosX, PosY;
DWORD                       StatusHeight = 24;
DWORD                       StatusDeltaX;
DWORD                       StatusDeltaY;
DWORD                       LastRetCode;
BOOL                        LastBoolRet;


PWSTR   szErrorMessages[] = {   TEXT("Internal TestGina Error!"),
                                TEXT("Invalid hWlx Handle Passed"),
                                TEXT("Improper SAS supplied"),
                                TEXT("Invalid Protocol Level"),
                                TEXT("Load of DLL Failed"),
                                TEXT("Missing Function"),
                                TEXT("Unknown HWND"),
                                TEXT("No Window for SAS message"),
                                TEXT("Invalid SAS code in message"),
                                TEXT("Invalid return code from function")
                            };

PWSTR   szStates[]  = { TEXT("Pre Load"),
                        TEXT("Initialize"),
                        TEXT("No One Logged On"),
                        TEXT("No One Logged On -- Display Notice"),
                        TEXT("No One Logged On -- SAS Received"),
                        TEXT("User Logged On -- Start Shell"),
                        TEXT("User Logged On"),
                        TEXT("User Logged On -- SAS Received"),
                        TEXT("Wksta Locked"),
                        TEXT("Wksta Locked -- SAS Received"),
                        TEXT("Waiting to Shutdown"),
                        TEXT("Shutdown")
                      };

PWSTR   szRetcodes[] = {    TEXT("N/A"),
                            TEXT("WLX_SAS_ACTION_USER_LOGON"),
                            TEXT("WLX_SAS_ACTION_NONE"),
                            TEXT("WLX_SAS_ACTION_LOCK_WKSTA"),
                            TEXT("WLX_SAS_ACTION_LOGOFF"),
                            TEXT("WLX_SAS_ACTION_SHUTDOWN"),
                            TEXT("WLX_SAS_ACTION_PWD_CHANGED"),
                            TEXT("WLX_SAS_ACTION_TASKLIST"),
                            TEXT("WLX_SAS_ACTION_UNLOCK_WKSTA"),
                            TEXT("WLX_SAS_ACTION_FORCE_LOGOFF"),
                            TEXT("WLX_SAS_ACTION_SHUTDOWN_POWER_OFF"),
                            TEXT("WLX_SAS_ACTION_SHUTDOWN_REBOOT")
                       };

BOOLEAN
AmIBeingDebugged(void)
{
    HANDLE      DebugPort;
    NTSTATUS    Status;

    DebugPort = (HANDLE) NULL;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDebugPort,
                (PVOID) &DebugPort,
                sizeof(DebugPort),
                NULL );

    if (NT_SUCCESS(Status) && DebugPort)
    {
        return(TRUE);
    }

    return(FALSE);
}

void
TestGinaError(  DWORD   dwError,
                PWSTR   pszFunction)
{
    int mbret;
    BOOLEAN fDbg;
    WCHAR   szBuffer[MAX_PATH];
    WCHAR   szCaption[MAX_PATH];

    if (dwError > (sizeof(szErrorMessages) / sizeof(PWSTR)))
    {
        dwError = 0;
    }

    fDbg = AmIBeingDebugged();

    wsprintf(szCaption, TEXT("%ws:  Error %d"), pszFunction, dwError);
    if (fDbg)
    {
        wsprintf(szBuffer, TEXT("The following error occurred:\n%ws\nPress OK to exit, Cancel to debug"),
                    szErrorMessages[dwError]);
    }
    else
        wsprintf(szBuffer, TEXT("The following error occurred:\n%ws\nPress OK to exit."),
                    szErrorMessages[dwError]);

    mbret = MessageBox( hMainWindow,
                        szBuffer,
                        szCaption,
                        MB_ICONSTOP | (fDbg ? MB_OKCANCEL : MB_OK) );

    if (fDbg && (mbret == IDCANCEL))
    {
        DbgBreakPoint();
        mbret = MessageBox(hMainWindow, TEXT("Continue after error?"),
                            TEXT("TestGina"), MB_OKCANCEL);
        if (mbret == IDOK)
        {
            return;
        }
    }

    ExitProcess(dwError);
}


void
DoClass(void)
{
    WndClass.style = 0;
    WndClass.lpfnWndProc = WndProc;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = hAppInstance;
    WndClass.hIcon = LoadIcon(hAppInstance, MAKEINTRESOURCE(TESTGINAICON));
    hIcon = WndClass.hIcon;
    WndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
    WndClass.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    WndClass.lpszMenuName = MAKEINTRESOURCE(TESTGINAMENU);
    WndClass.lpszClassName = TEXT("TestGina");

    RegisterClass(&WndClass);
}


int
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrev,
    LPSTR       pszCommandLine,
    int         nCmdShow)
{
    MSG msg;
    HMENU   hMenu;

    hAppInstance = hInstance;

    InitCommonControls();

    DoClass();

    SizeX = (DWORD) CW_USEDEFAULT;
    SizeY = (DWORD) CW_USEDEFAULT;
    PosX = (DWORD) CW_USEDEFAULT;
    PosY = (DWORD) CW_USEDEFAULT;

    LoadParameters();

    InitializeDesktops();

    hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(TESTGINAMENU));
    if (szGinaDll[0] == TEXT('\0'))
    {
        DeleteMenu(hMenu, IDM_DLL_LOAD_LAST, MF_BYCOMMAND);
    }
    else
    {
        WCHAR   tmp[32];
        PWSTR   pszName;

        if (wcslen(szGinaDll) > 32)
        {
            pszName = wcsrchr(szGinaDll, TEXT('\\'));
            if (!pszName)
            {
                wcsncpy(tmp, szGinaDll, 31);
            }
            else
            {
                wcsncpy(tmp, szGinaDll, 3);
                wcscpy(tmp + 3, TEXT("..."));
                wcsncpy(tmp+6, pszName, 25);
            }
            ModifyMenu(hMenu, IDM_DLL_LOAD_LAST, MF_BYCOMMAND | MF_STRING,
                        IDM_DLL_LOAD_LAST, (LPCTSTR) tmp);
        }
        else
        {
            ModifyMenu(hMenu, IDM_DLL_LOAD_LAST, MF_BYCOMMAND | MF_STRING,
                        IDM_DLL_LOAD_LAST, szGinaDll);
        }
    }
    if (AmIBeingDebugged())
    {
        hDebugMenu = LoadMenu(hInstance, MAKEINTRESOURCE(DEBUGGINAMENU));

        InsertMenu(hMenu, 3, MF_BYPOSITION | MF_POPUP, (UINT) hDebugMenu, TEXT("&Debug"));
    }

    hMainWindow = CreateWindow(
                    TEXT("TestGina"),
                    TEXT("TestGina"),
                    WS_OVERLAPPEDWINDOW,
                    PosX,
                    PosY,
                    SizeX,
                    SizeY,
                    NULL,
                    hMenu,
                    hInstance,
                    NULL);

    if (!hMainWindow)
    {
        return(0);
    }

    RegisterHotKey(hMainWindow, 0, MOD_CONTROL, VK_DELETE);
    RegisterHotKey(hMainWindow, 1, MOD_CONTROL, VK_ADD);

    ShowWindow(hMainWindow, nCmdShow);

    StatusDeltaX = GetSystemMetrics(SM_CXFRAME);
    StatusDeltaY = GetSystemMetrics(SM_CYFRAME);

    ShowWindow(hMainWindow, nCmdShow);

    SetFocus(hMainWindow);

    UpdateMenuBar();

    EnableOptions(FALSE);



    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0 ;
}



void
UpdateGinaState(DWORD   Update)
{
    LogEvent( 0, "UpdateGinaState(%d):  CurrentDesktop = %d, OtherDesktop = %d\n",
                    Update, CurrentDesktop, OtherDesktop );

    switch (Update)
    {
        case UPDATE_INITIALIZE:
            GinaState = Winsta_NoOne;
            CurrentDesktop = WINLOGON_DESKTOP;
            OtherDesktop = WINLOGON_DESKTOP;
            break;

        case UPDATE_DISPLAY_NOTICE:
            if (GinaState != Winsta_NoOne)
            {
                TestGinaError(0, TEXT("UpdateGinaState_1"));
            }
            GinaState = Winsta_NoOne_Display;
            CurrentDesktop = WINLOGON_DESKTOP;
            OtherDesktop = WINLOGON_DESKTOP;
            break;

        case UPDATE_SAS_BYPASS:
            //
            // The kind of weird state of skipping DISPLAY and invoking the
            //
            if ((GinaState == Winsta_NoOne) || (GinaState == Winsta_NoOne_Display))
            {
                GinaState = Winsta_NoOne_SAS;
            }
            else if ((GinaState == Winsta_LoggedOnUser))
            {
                GinaState = Winsta_LoggedOn_SAS;
            }
            else if (GinaState == Winsta_Locked)
            {
                GinaState = Winsta_Locked_SAS;
            }

            LastRetCode = 0;
            CurrentDesktop = WINLOGON_DESKTOP;
            OtherDesktop = WINLOGON_DESKTOP;
            break;

        case UPDATE_SAS_RECEIVED:
            if ((GinaState == Winsta_NoOne) || (GinaState == Winsta_NoOne_Display))
            {
                GinaState = Winsta_NoOne_SAS;
            }
            else if (GinaState == Winsta_LoggedOnUser)
            {
                GinaState = Winsta_LoggedOn_SAS;
            }
            else if (GinaState == Winsta_Locked)
            {
                GinaState = Winsta_Locked_SAS;
            }

            OtherDesktop = CurrentDesktop;
            CurrentDesktop = WINLOGON_DESKTOP;

            LastRetCode = 0;
            break;

        case UPDATE_USER_LOGON:
            if (GinaState != Winsta_NoOne_SAS)
            {
                TestGinaError(0, TEXT("UpdateGinaState_2"));
            }
            GinaState = Winsta_LoggedOnUser;

            OtherDesktop = WINLOGON_DESKTOP;
            CurrentDesktop = DEFAULT_DESKTOP;

            break;

        case UPDATE_LOCK_WKSTA:
            if (GinaState != Winsta_LoggedOn_SAS)
            {
                TestGinaError(0, TEXT("UpdateGinaState_3"));
            }
            GinaState = Winsta_Locked;
            CurrentDesktop = WINLOGON_DESKTOP;
            break;

        case UPDATE_UNLOCK_WKSTA:
            if (GinaState != Winsta_Locked_SAS)
            {
                TestGinaError(0, TEXT("UpdateGinaState_4"));
            }
            GinaState = Winsta_LoggedOnUser;
            CurrentDesktop = OtherDesktop;
            OtherDesktop = WINLOGON_DESKTOP;

            break;

        case UPDATE_SAS_COMPLETE:
            if (GinaState == Winsta_LoggedOn_SAS)
            {
                GinaState = Winsta_LoggedOnUser;
                CurrentDesktop = OtherDesktop;
                OtherDesktop = WINLOGON_DESKTOP;
            }
            if (GinaState == Winsta_NoOne_SAS)
            {
                GinaState = Winsta_NoOne;
            }
            if (GinaState == Winsta_Locked_SAS)
            {
                GinaState = Winsta_Locked;
            }
            break;

        case UPDATE_LOGOFF:
            LastRetCode = 0;
            GinaState = Winsta_NoOne;
            break;

    }

    LogEvent( 0, "UpdateGinaState:  CurrentDesktop = %d, OtherDesktop = %d\n",
                    CurrentDesktop, OtherDesktop );

    UpdateStatusBar( );
}

void
LoadGinaSpecificParameters(
    VOID )
{
    PWSTR   pszGina;
    HKEY    hKey;
    HKEY    hRealKey;
    int     err;
    DWORD   cbBuffer;
    DWORD   dwType;
    WCHAR   szTemp[512];
    DWORD   i;
    PWSTR   pszWalk;
    DWORD   RealBuf;
    DWORD   disp;

    pszGina = wcsrchr( szGinaDll, TEXT('\\') );
    if (!pszGina)
    {
        pszGina = szGinaDll;
    }
    else
    {
        pszGina++;
    }

    err = RegCreateKey( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\TestGina"), &hKey );
    if (err)
    {
        return;
    }

    err = RegCreateKeyEx(   hKey,
                            pszGina,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &hRealKey,
                            &disp );

    RegCloseKey( hKey );

    if (err)
    {
        return;
    }

    cbBuffer = 512 * sizeof(WCHAR);

    err = RegQueryValueEx(  hRealKey,
                            TEXT("Order"),
                            NULL,
                            &dwType,
                            (LPBYTE) szTemp,
                            &cbBuffer );

    if (err || (dwType != REG_MULTI_SZ))
    {
        RegCloseKey( hRealKey );
        return;
    }

    pszWalk = szTemp;

    for (i = 0; i < 4 ; i++ )
    {

        RealBuf = sizeof(DWORD);

        err = RegQueryValueEx(  hRealKey,
                                pszWalk,
                                NULL,
                                &dwType,
                                (LPBYTE) &UserDefSas[i].Value,
                                &RealBuf );

        if (err || ( dwType != REG_DWORD))
        {
            RegCloseKey( hRealKey );
            return;
        }

        wcsncpy( UserDefSas[i].Name, pszWalk, 128 );

        pszWalk += wcslen(pszWalk) + 1;

        if (*pszWalk == TEXT('\0'))
        {
            break;
        }

    }

    RegCloseKey( hRealKey );

    UserSases = i + 1;

}

void
SaveGinaSpecificParameters(void)
{
    PWSTR   pszGina;
    HKEY    hKey;
    HKEY    hRealKey;
    int     err;
    DWORD   cbBuffer;
    WCHAR   szTemp[512];
    DWORD   i;
    DWORD   disp;

    pszGina = wcsrchr( szGinaDll, TEXT('\\') );
    if (!pszGina)
    {
        pszGina = szGinaDll;
    }
    else
    {
        pszGina++;
    }

    err = RegCreateKey( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\TestGina"), &hKey );
    if (err)
    {
        return;
    }

    err = RegCreateKeyEx(   hKey,
                            pszGina,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &hRealKey,
                            &disp );

    RegCloseKey( hKey );

    if (err)
    {
        return;
    }

    cbBuffer = 0;

    for (i = 0; i < UserSases ; i++ )
    {
        wcscpy( &szTemp[cbBuffer],
                UserDefSas[i].Name );

        cbBuffer += wcslen(UserDefSas[i].Name) + 1;

    }

    szTemp[cbBuffer++] = TEXT('\0');

    RegSetValueEx(  hRealKey,
                    TEXT("Order"),
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE) szTemp,
                    cbBuffer * 2);

    for (i = 0; i < UserSases ; i++ )
    {
        RegSetValueEx(  hRealKey,
                        UserDefSas[i].Name,
                        0,
                        REG_DWORD,
                        (LPBYTE) &UserDefSas[i].Value,
                        sizeof(DWORD) );
    }

    RegCloseKey( hRealKey );

}

void
LoadParameters(void)
{
    HKEY    hKey;
    int     err;
    DWORD   dwX;
    DWORD   cbBuffer;
    DWORD   dwType;

    err = RegCreateKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\TestGina"), &hKey);
    if (err)
    {
        return;
    }

    cbBuffer = sizeof(dwX);

    err = RegQueryValueEx(hKey, TEXT("Size"), NULL, &dwType, (LPBYTE)&dwX, &cbBuffer);
    if (err)
    {
        RegCloseKey(hKey);
        return;
    }

    SizeX = LOWORD(dwX);
    SizeY = HIWORD(dwX);

    err = RegQueryValueEx(hKey, TEXT("Pos"), NULL, &dwType, (LPBYTE)&dwX, &cbBuffer);
    if (err)
    {
        RegCloseKey(hKey);
        return;
    }

    PosX = LOWORD(dwX);
    PosY = HIWORD(dwX);

    cbBuffer = sizeof(szGinaDll);
    err = RegQueryValueEx(hKey, TEXT("Dll"), NULL, &dwType, (LPBYTE)szGinaDll, &cbBuffer);

    RegCloseKey(hKey);

}

void
SaveParameters(void)
{
    HKEY    hKey;
    int     err;
    DWORD   dwX;

    err = RegCreateKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\TestGina"), &hKey);
    if (err)
    {
        return;
    }

    dwX = (SizeY << 16) + (SizeX & 0x0000FFFF);

    err = RegSetValueEx(hKey, TEXT("Size"), 0, REG_DWORD, (LPBYTE)&dwX, sizeof(DWORD));
    if (err)
    {
        RegCloseKey(hKey);
        return;
    }

    dwX = (PosY << 16) + (PosX & 0x0000FFFF);

    err = RegSetValueEx(hKey, TEXT("Pos"), 0, REG_DWORD, (LPBYTE)&dwX, sizeof(DWORD));
    if (err)
    {
        RegCloseKey(hKey);
        return;
    }

    err = RegSetValueEx(hKey, TEXT("Dll"), 0, REG_SZ, (LPBYTE) szGinaDll, (wcslen(szGinaDll) + 1) * sizeof(WCHAR));

    RegCloseKey(hKey);
}


PrintStatus(HWND hWnd)
{
    WCHAR szText[128];
    PWSTR pszRet;

    wsprintf( szText, TEXT("GINA State:  %s"), szStates[ GinaState ] );
    SendMessage( hStatusWindow, SB_SETTEXT, 0, (LPARAM) szText );

    if ( LastRetCode == WLX_SAS_ACTION_BOOL_RET )
    {
        if ( LastBoolRet )
        {
            pszRet = TEXT("TRUE");
        }
        else
        {
            pszRet = TEXT("FALSE");
        }
    }
    else
    {
        pszRet = szRetcodes[ LastRetCode ];
    }

    wsprintf( szText, TEXT("Last Return:  %s"), pszRet );
    SendMessage( hStatusWindow, SB_SETTEXT, 1, (LPARAM) szText );

    wsprintf( szText, TEXT("Desktop:  %s"), Desktops[ CurrentDesktop ]->pszDesktopName );
    SendMessage( hStatusWindow, SB_SETTEXT, 2, (LPARAM) szText );

    return(0);
}

void
UpdateStatusBar(VOID)
{
    RECT    rect;
    int     Widths[4];

    GetClientRect( hStatusWindow, &rect );

    rect.right -= 15;   // Reduce by size grip

    Widths[0] = rect.right / 3;
    Widths[1] = rect.right / 3 + Widths[0] ;
    Widths[2] = rect.right / 3 + Widths[1] ;

    SendMessage( hStatusWindow, SB_SETPARTS, (WPARAM) 3, (LPARAM) Widths );

    PrintStatus( hStatusWindow );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\validate.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       validate.c
//
//  Contents:   Validation stuff
//
//  Classes:
//
//  Functions:
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------


#include "testgina.h"

HANDLE  hWlxHandle;
PVOID   pWlxContext;

#define ACTION_LOGON        ((1) << (WLX_SAS_ACTION_LOGON))
#define ACTION_NONE         ((1) << (WLX_SAS_ACTION_NONE))
#define ACTION_LOCK_WKSTA   ((1) << (WLX_SAS_ACTION_LOCK_WKSTA))
#define ACTION_LOGOFF       ((1) << (WLX_SAS_ACTION_LOGOFF))
#define ACTION_SHUTDOWN     ((1) << (WLX_SAS_ACTION_SHUTDOWN))
#define ACTION_PWD_CHANGED  ((1) << (WLX_SAS_ACTION_PWD_CHANGED))
#define ACTION_TASKLIST     ((1) << (WLX_SAS_ACTION_TASKLIST))
#define ACTION_UNLOCK_WKSTA ((1) << (WLX_SAS_ACTION_UNLOCK_WKSTA))
#define ACTION_FORCE_LOGOFF ((1) << (WLX_SAS_ACTION_FORCE_LOGOFF))
#define ACTION_SHUTDOWN_POW ((1) << (WLX_SAS_ACTION_SHUTDOWN_POWER_OFF))
#define ACTION_SHUTDOWN_REB ((1) << (WLX_SAS_ACTION_SHUTDOWN_REBOOT))


DWORD   ValidReturnCodes[] = {
        0,                                              // Negotiate
        0,                                              // Initialize
        0,                                              // DisplaySAS
        ACTION_LOGON | ACTION_NONE | ACTION_SHUTDOWN |
        ACTION_SHUTDOWN_POW | ACTION_SHUTDOWN_REB,      // LoggedOutSAS
        0,                                              // ActivateUserShell
        ACTION_LOCK_WKSTA | ACTION_LOGOFF | ACTION_FORCE_LOGOFF |
        ACTION_SHUTDOWN | ACTION_PWD_CHANGED |
        ACTION_TASKLIST | ACTION_SHUTDOWN_POW |
        ACTION_SHUTDOWN_REB | ACTION_NONE,              // LoggedOnSAS
        0,                                              // DisplayLockedNotice
        ACTION_NONE | ACTION_UNLOCK_WKSTA |
        ACTION_FORCE_LOGOFF,                            // WkstaLockedSAS
        0,                                              // Logoff
        0 };                                            // Shutdown


BOOL
AssociateHandle(HANDLE   hWlx)
{
    hWlxHandle = hWlx;
    return(TRUE);
}

BOOL
VerifyHandle(HANDLE hWlx)
{
    return(hWlx == hWlxHandle);
}

BOOL
StashContext(PVOID  pvContext)
{
    pWlxContext = pvContext;
    return(TRUE);
}

PVOID
GetContext(VOID)
{
    return(pWlxContext);
}

BOOL
ValidResponse(
    DWORD       ApiNum,
    DWORD       Response)
{
    DWORD   Test = (1) << Response;

    if (Response > 11)
    {
        LastRetCode = 0;
    }
    else
    {
        LastRetCode = Response;
    }

    UpdateStatusBar( );

    if (ValidReturnCodes[ApiNum] & Test)
    {
        return(TRUE);
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\windproc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       windproc.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"
#include <commdlg.h>

WCHAR szFilter[] = TEXT("DLLs (*.dll)\0*.dll\0\0");

DoLoadDll(void)
{
    if (LoadGinaDll())
    {
        WCHAR   szCaption[MAX_PATH];

        fTestGina |= GINA_DLL_KNOWN;
        SaveParameters();
        wcscpy(szCaption, TEXT("TestGina - "));
        wcscat(szCaption, szGinaDll);
        SetWindowText(hMainWindow, szCaption);
        GinaState = Winsta_PreLoad;
        UpdateStatusBar();
        LoadGinaSpecificParameters();
        UpdateSasMenu();
    }

    UpdateMenuBar();
    return(0);
}


int
GetFile()
{
    OPENFILENAME    ofn;

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hMainWindow;
    ofn.hInstance = hAppInstance;
    ofn.lpstrFilter =  szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szGinaDll;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = TEXT("Load A DLL");
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_NONETWORKBUTTON | OFN_NOTESTFILECREATE |
                OFN_PATHMUSTEXIST ;
    ofn.lpstrDefExt = TEXT("DLL");

    if (GetOpenFileName(&ofn))
    {
        DoLoadDll();
    }

    return(0);
}

LRESULT
MprDialogProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    if (Message == WM_INITDIALOG)
    {
        SetDlgItemText(hDlg, IDD_VIEW_MPR_USERNAME,
                    (GlobalMprInfo.pszUserName ? GlobalMprInfo.pszUserName : TEXT("<Null>")));
        SetDlgItemText(hDlg, IDD_VIEW_MPR_DOMAIN,
                    (GlobalMprInfo.pszDomain ? GlobalMprInfo.pszDomain : TEXT("<Null>")));
        SetDlgItemText(hDlg, IDD_VIEW_MPR_PASSWORD,
                    (GlobalMprInfo.pszPassword ? GlobalMprInfo.pszPassword : TEXT("<Null>")));
        SetDlgItemText(hDlg, IDD_VIEW_MPR_OLD_PASSWORD,
                    (GlobalMprInfo.pszOldPassword ? GlobalMprInfo.pszOldPassword : TEXT("<Null>")));
        SetDlgItemText(hDlg, IDD_VIEW_MPR_PROVIDER,
                    GlobalProviderName);

        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_USERNAME ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_DOMAIN ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_PASSWORD ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_OLD_PASSWORD ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_PROVIDER ), FALSE );

        return(TRUE);
    }
    if (Message == WM_COMMAND)
    {
        if (LOWORD(wParam) == IDOK)
        {
            EndDialog(hDlg, IDOK);
            return(TRUE);
        }
    }
    return(FALSE);
}

void
DoViewMPR(void)
{
    DialogBox(  hAppInstance,
                MAKEINTRESOURCE(IDD_VIEW_MPR),
                hMainWindow,
                MprDialogProc );
}

SasBoxProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    USER_SAS    Sas;

    switch (Message)
    {
        case WM_INITDIALOG:
            SetDlgItemText( hDlg, IDD_SAS_USERNAME, TEXT("User Defined") );
            SetDlgItemText( hDlg, IDD_SAS_VALUE, TEXT("128") );
            if (UserSases == MAX_USER_SASES)
            {
                EnableWindow( GetDlgItem(hDlg, IDD_SAS_KEEPAROUND), FALSE );
            }
            EnableWindow( GetDlgItem( hDlg, IDD_SAS_REMOVE ), FALSE );
            return( TRUE );

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog( hDlg, IDCANCEL );
            }
            if ((LOWORD(wParam) == IDOK) ||
                (LOWORD(wParam) == IDD_SAS_REMOVE) )
            {
                GetDlgItemText(hDlg, IDD_SAS_USERNAME, Sas.Name, 128);
                Sas.Value = GetDlgItemInt(hDlg, IDD_SAS_VALUE, NULL, FALSE );

                if (Sas.Value <= WLX_SAS_TYPE_MAX_MSFT_VALUE)
                {
                    MessageBox( hDlg, TEXT("Invalid SAS Value!"), TEXT("Error"),
                                MB_OK | MB_ICONERROR);

                }
                else
                {

                    if (IsDlgButtonChecked(hDlg, IDD_SAS_KEEPAROUND) == BST_CHECKED)
                    {
                        //
                        // Ok, big update time:
                        //

                        UserDefSas[UserSases ++ ] = Sas;
                        SaveGinaSpecificParameters();
                        UpdateSasMenu();
                    }

                    EndDialog( hDlg, Sas.Value );
                }

            }
            return( TRUE );


    }
    return( FALSE );
}

ToggleDebugItem(DWORD   MenuId,
                DWORD   FlagId)
{
    DWORD   fuFlags;

    if (TEST_FLAG(GinaBreakFlags, FlagId))
    {
        FLAG_OFF(GinaBreakFlags, FlagId);
        fuFlags = MF_UNCHECKED;
    }
    else
    {
        FLAG_ON(GinaBreakFlags, FlagId);
        fuFlags = MF_CHECKED;
    }

    fuFlags |= MF_BYCOMMAND;
    CheckMenuItem(hDebugMenu, MenuId, fuFlags);
    DrawMenuBar(hMainWindow);
    return(0);
}


void
ShowDialogUnits(HWND    hWnd)
{
    CHAR    Buff[256];
    LONG    l;
    LONG    DlgX;
    LONG    DlgY;

    l = GetDialogBaseUnits();
    DlgX = LOWORD(l);
    DlgY = HIWORD(l);

    sprintf(Buff, "BaseUnits are\nX = %d\nY = %d", DlgX, DlgY);
    MessageBoxA( hWnd, Buff, "Hello!", MB_OK);


}

VOID
DoSendSS( VOID )
{

}

VOID
DoSendLogoff( VOID )
{

}


LRESULT
DoCommand(  HWND    hWnd,
            UINT    Message,
            WPARAM  wParam,
            LPARAM  lParam)
{
    DWORD   res;

    switch (wParam)
    {
        case IDM_DLL_EXIT:
            PostQuitMessage(0);
            return(0);

        case IDM_DLL_OPEN:
            GetFile();
            return(0);


        case IDM_DLL_LOAD_LAST:
            DoLoadDll();
            return(0);

        case IDM_WHACK_NEGOTIATE:
            TestNegotiate();
            return(0);

        case IDM_WHACK_INITIALIZE:
            TestInitialize();
            return(0);

        case IDM_WHACK_DISPLAY:
            TestDisplaySASNotice();
            return(0);

        case IDM_WHACK_LOGGEDOUT:
            UpdateGinaState(UPDATE_SAS_BYPASS);
            TestLoggedOutSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
            return(0);

        case IDM_WHACK_STARTSHELL:
            TestActivateUserShell();
            return(0);

        case IDM_WHACK_LOGGEDON:
            UpdateGinaState(UPDATE_SAS_RECEIVED);
            TestLoggedOnSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
            return(0);

        case IDM_WHACK_DISPLAYLOCKED:
            TestDisplayLockedNotice();
            return(0);

        case IDM_WHACK_LOCKED:
            UpdateGinaState(UPDATE_SAS_RECEIVED);
            TestWkstaLockedSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
            return(0);

        case IDM_SAS_CAD:
            PingSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
            return(0);

        case IDM_SAS_TIMEOUT:
            PingSAS(WLX_SAS_TYPE_TIMEOUT);
            return(0);

        case IDM_SAS_SCRNSVR:
            PingSAS(WLX_SAS_TYPE_SCRNSVR_TIMEOUT);
            return(0);

        case IDM_SAS_SC_INSERT:
            PingSAS(WLX_SAS_TYPE_SC_INSERT );
            return(0);

        case IDM_SAS_SC_REMOVE:
            PingSAS( WLX_SAS_TYPE_SC_REMOVE );
            return(0);

        case IDM_SAS_USERDEF1:
            PingSAS(UserDefSas[0].Value);
            return(0);

        case IDM_SAS_USERDEF2:
            PingSAS(UserDefSas[1].Value);
            return(0);

        case IDM_SAS_USERDEF3:
            PingSAS(UserDefSas[2].Value);
            return(0);

        case IDM_SAS_USERDEF4:
            PingSAS(UserDefSas[3].Value);
            return(0);

        case IDM_SAS_USERDEF:
            res = DialogBox(  hAppInstance,
                        MAKEINTRESOURCE(IDD_USERDEF_SAS),
                        hMainWindow,
                        SasBoxProc );
            if (res != IDCANCEL)
            {
                PingSAS( res );
            }
            return( 0 );

        case IDM_OPTIONS_SSNOTIFY:
            DoSendSS();
            return( 0 );

        case IDM_OPTIONS_LOGOFF:
            DoSendLogoff();
            return( 0 );

        case IDM_OPTIONS_VIEW_MPR:
            DoViewMPR();
            return(0);

        case IDM_HELP_ABOUT:
            ShellAbout(hWnd, TEXT("TestGina"), TEXT("Graphical Logon Tester"), hIcon);
            return(0);

        case IDM_DEBUG_BREAK_NOW:
            if (AmIBeingDebugged())
            {
                DebugBreak();
            }
            return(0);

        case IDM_DEBUG_NEGOTIATE:
            ToggleDebugItem(IDM_DEBUG_NEGOTIATE, BREAK_NEGOTIATE);
            return(0);

        case IDM_DEBUG_INITIALIZE:
            ToggleDebugItem(IDM_DEBUG_INITIALIZE, BREAK_INITIALIZE);
            return(0);

        case IDM_DEBUG_DISPLAYSAS:
            ToggleDebugItem(IDM_DEBUG_DISPLAYSAS, BREAK_DISPLAY);
            return(0);

        case IDM_DEBUG_LOGGEDOUT:
            ToggleDebugItem(IDM_DEBUG_LOGGEDOUT, BREAK_LOGGEDOUT);
            return(0);

        case IDM_DEBUG_ACTIVATE:
            ToggleDebugItem(IDM_DEBUG_ACTIVATE, BREAK_ACTIVATE);
            return(0);

        case IDM_DEBUG_LOGGEDON:
            ToggleDebugItem(IDM_DEBUG_LOGGEDON, BREAK_LOGGEDON);
            return(0);

        case IDM_DEBUG_DISPLAYLOCKED:
            ToggleDebugItem(IDM_DEBUG_DISPLAYLOCKED, BREAK_DISPLAYLOCKED);
            return(0);

        case IDM_DEBUG_LOCKED:
            ToggleDebugItem(IDM_DEBUG_LOCKED, BREAK_WKSTALOCKED);
            return(0);

        case IDM_DEBUG_LOGOFF:
            ToggleDebugItem(IDM_DEBUG_LOGOFF, BREAK_LOGOFF);
            return(0);

        case IDM_DEBUG_SHUTDOWN:
            ToggleDebugItem(IDM_DEBUG_SHUTDOWN, BREAK_SHUTDOWN);
            return(0);
    }
    return 0;
}

LRESULT
CreateMainWindow(
    HWND    hWnd,
    WPARAM  wParam,
    LPARAM  lParam )
{


    hStatusWindow = CreateStatusWindow(
                        WS_CHILD | WS_BORDER | WS_VISIBLE | SBARS_SIZEGRIP,
                        TEXT("Initializing"),
                        hWnd,
                        10 );

    if (hStatusWindow == NULL)
    {
        return( FALSE );
    }

    UpdateStatusBar();

    return( TRUE );

}


LRESULT
CALLBACK
WndProc(
    HWND    hWnd,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    RECT    rect;

    switch (Message)
    {
        case WM_CREATE:
            return( CreateMainWindow( hWnd, wParam, lParam ) );
        case WM_CLOSE:
            PostQuitMessage(0);
            return(0);

        case WM_SIZE:
        case WM_MOVE:
            if ((Message == WM_SIZE) && (wParam != SIZE_RESTORED))
            {
                break;
            }

            GetWindowRect(hWnd, &rect);
            PosX = rect.left;
            PosY = rect.top;
            SizeX = rect.right - rect.left;
            SizeY = rect.bottom - rect.top;
            SaveParameters();
            SendMessage( hStatusWindow, Message, wParam, lParam );
            UpdateStatusBar();
            return(0);

        case WM_HOTKEY:
            if (wParam == 0)
            {
                if (TEST_FLAG(fTestGina, GINA_USE_CAD))
                {
                    PingSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
                }
            }
            OutputDebugStringA("Got a hotkey!\n");
            return(0);

        case WM_COMMAND:
            return DoCommand(hWnd, Message, wParam, lParam);
    }
    return(DefWindowProc(hWnd, Message, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testnp\testnp.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msgina.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <npapi.h>
#include <ntsecapi.h>
#include <stdio.h>
#include <stdlib.h>

BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls ( hInstance );

        case DLL_PROCESS_DETACH:
        default:
            return(TRUE);
    }
}

VOID
DebugOut(
    PSTR Format,
    ...
    )
{
    va_list ArgList;
    CHAR Buffer[ 256 ];

    va_start( ArgList, Format );
    _vsnprintf( Buffer, 256, Format, ArgList );
    OutputDebugString( Buffer );
}

DWORD
WINAPI
NPGetCaps(
         DWORD nIndex
         )
{
   DWORD dwRes;

   switch (nIndex)
   {

   case WNNC_NET_TYPE:
      dwRes = 0xffff0000; // credential manager
      break;

   case WNNC_SPEC_VERSION:
      dwRes = WNNC_SPEC_VERSION51;  // We are using version 5.1 of the spec.
      break;

   case WNNC_DRIVER_VERSION:
      dwRes = 1;  // This driver is version 1.
      break;

   case WNNC_START:
      dwRes = 1;  // We are already "started"
      break;

   default:
      dwRes = 0;  // We don't support anything else
      break;
   }

   return dwRes;

}


/****************************************************************************
   FUNCTION: NPLogonNotify

   PURPOSE:  This entry point is called when a user logs on.  If the user
             authentication fails here, the user will still be logged on
             to the local machine.

*******************************************************************************/
DWORD
WINAPI
NPLogonNotify (
              PLUID               lpLogonId,
              LPCWSTR             lpAuthentInfoType,
              LPVOID              lpAuthentInfo,
              LPCWSTR             lpPreviousAuthentInfoType,
              LPVOID              lpPreviousAuthentInfo,
              LPWSTR              lpStationName,
              LPVOID              StationHandle,
              LPWSTR              *lpLogonScript
              )
{
    PMSV1_0_INTERACTIVE_LOGON pAuthInfo;


    //
    // Write out some information about the logon attempt
    //

    DebugOut( "NPLogonNotify\n" );

    DebugOut( "lpAuthentInfoType=%ws lpStationName=%ws\r\n",
            lpAuthentInfoType, lpStationName);



    // Do something with the authentication information
    //
    pAuthInfo = (PMSV1_0_INTERACTIVE_LOGON) lpAuthentInfo;

    DebugOut( "LogonDomain=%ws User=%ws\r\n",
            pAuthInfo->LogonDomainName.Buffer,
             pAuthInfo->UserName.Buffer);
      

    return NO_ERROR;
}


/****************************************************************************
   FUNCTION: NPPasswordChangeNotify

   PURPOSE:  This function is used to notify a credential manager provider
             of a password change (or, more accurately, an authentication
             information change) for an account.

*******************************************************************************/
DWORD
WINAPI
NPPasswordChangeNotify (
                       LPCWSTR             lpAuthentInfoType,
                       LPVOID              lpAuthentInfo,
                       LPCWSTR             lpPreviousAuthentInfoType,
                       LPVOID              lpPreviousAuthentInfo,
                       LPWSTR              lpStationName,
                       LPVOID              StationHandle,
                       DWORD               dwChangeInfo
                       )
{
    DebugOut( "NPPasswordChangeNotify\n" );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\winutil.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       winutil.c
//
//  Contents:   General Utilities to test ginas
//
//  Classes:
//
//  Functions:
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"

DWORD DummySCData = sizeof( DWORD ) ;

typedef struct _WindowMapper {
    DWORD                   fMapper;
    HWND                    hWnd;
    DLGPROC                 DlgProc;
    struct _WindowMapper *  pPrev;
    LPARAM                  InitialParameter;
} WindowMapper, * PWindowMapper;
#define MAPPERFLAG_ACTIVE   1
#define MAPPERFLAG_DIALOG   2
#define MAPPERFLAG_SAS      4

#define MAX_WINDOW_MAPPERS  32

WindowMapper    Mappers[MAX_WINDOW_MAPPERS];
DWORD           cActiveWindow;

void
InitWindowMappers()
{
    ZeroMemory(Mappers, sizeof(WindowMapper) * MAX_WINDOW_MAPPERS);
    cActiveWindow = 0;
}

PWindowMapper
LocateTopMappedWindow(void)
{
    int i;
    for (i = 0; i < MAX_WINDOW_MAPPERS ; i++ )
    {
        if (Mappers[i].fMapper & MAPPERFLAG_SAS)
        {
            return(&Mappers[i]);
        }
    }

    return(NULL);

}

PWindowMapper
AllocWindowMapper(void)
{
    int i;
    PWindowMapper   pMap;

    for (i = 0 ; i < MAX_WINDOW_MAPPERS ; i++ )
    {
        if ((Mappers[i].fMapper & MAPPERFLAG_ACTIVE) == 0)
        {
            cActiveWindow ++;
            pMap = LocateTopMappedWindow();
            if (pMap)
            {
                FLAG_OFF(pMap->fMapper, MAPPERFLAG_SAS);
            }

            FLAG_ON(Mappers[i].fMapper, MAPPERFLAG_ACTIVE | MAPPERFLAG_SAS);
            Mappers[i].pPrev = pMap;

            return(&Mappers[i]);
        }
    }
    return(NULL);
}

PWindowMapper
LocateWindowMapper(HWND hWnd)
{
    int i;

    for (i = 0; i < MAX_WINDOW_MAPPERS ; i++ )
    {
        if (Mappers[i].hWnd == hWnd)
        {
            return(&Mappers[i]);
        }
    }

    return(NULL);
}

void
FreeWindowMapper(PWindowMapper  pMap)
{
    pMap->hWnd = NULL;
    pMap->DlgProc = NULL;
    if (pMap->fMapper & MAPPERFLAG_SAS)
    {
        if (pMap->pPrev)
        {
            FLAG_ON(pMap->pPrev->fMapper, MAPPERFLAG_SAS);
        }
    }
    pMap->fMapper = 0;
    pMap->pPrev = NULL;
    cActiveWindow--;
}


#define CALAIS_PATH         TEXT("Software\\Microsoft\\Cryptography\\Calais")
BOOL
IsSmartCardReaderPresent(
    VOID
    )
{
    HKEY hKey ;
    int err ;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        CALAIS_PATH,
                        0,
                        KEY_READ,
                        &hKey );

    if ( err == 0 )
    {
        RegCloseKey( hKey );

        return TRUE ;
    }
    else
    {
        return FALSE ;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   RootWndProc
//
//  Synopsis:   This is the base window proc for all testgina windows.
//
//  Arguments:  [hWnd]    --
//              [Message] --
//              [wParam]  --
//              [lParam]  --
//
//  History:    7-18-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CALLBACK
RootDlgProc(
    HWND    hWnd,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    PWindowMapper   pMap;
    int res;
    BOOL bRet;

    //
    // If this is a WM_INITDIALOG message, then the parameter is the mapping,
    // which needs to have a hwnd associated with it.  Otherwise, do the normal
    // preprocessing.
    //
    if (Message == WM_INITDIALOG)
    {
        pMap = (PWindowMapper) lParam;
        pMap->hWnd = hWnd;
        lParam = pMap->InitialParameter;
    }
    else
    {
        pMap = LocateWindowMapper(hWnd);
        if (!pMap)
        {
            return(FALSE);
        }
    }

    bRet = pMap->DlgProc(hWnd, Message, wParam, lParam);
    if (!bRet)
    {
        if (Message == WM_INITDIALOG)
        {
            return(bRet);
        }
        if (Message == WLX_WM_SAS)
        {
            switch (wParam)
            {
                case WLX_SAS_TYPE_CTRL_ALT_DEL:
                default:
                    res = WLX_DLG_SAS;
                    break;

                case WLX_SAS_TYPE_TIMEOUT:
                    res = WLX_DLG_INPUT_TIMEOUT;
                    break;
                case WLX_SAS_TYPE_SCRNSVR_TIMEOUT:
                    res = WLX_DLG_SCREEN_SAVER_TIMEOUT;
                    break;
                case WLX_SAS_TYPE_USER_LOGOFF:
                    res = WLX_DLG_USER_LOGOFF;
                    break;
            }
            if (res)
            {
                EndDialog(hWnd, res);
                bRet = TRUE;
            }
            else
            {
                TestGinaError(GINAERR_INVALID_SAS_CODE, TEXT("RootDlgProc"));
            }
        }
    }

    return(bRet);

}

PingSAS(DWORD   SasType)
{
    PWindowMapper   pMap;

    if (cActiveWindow)
    {
        pMap = LocateTopMappedWindow();

        if (!pMap)
        {
            TestGinaError(GINAERR_NO_WINDOW_FOR_SAS, TEXT("PingSAS"));
        }

        PostMessage(pMap->hWnd, WLX_WM_SAS, (WPARAM) SasType, 0);
    }

    UpdateGinaState(UPDATE_SAS_RECEIVED);

    switch (GinaState)
    {
        case Winsta_NoOne_SAS:
            TestLoggedOutSAS(SasType);
            break;
        case Winsta_LoggedOn_SAS:
            TestLoggedOnSAS(SasType);
            break;
        case Winsta_Locked_SAS:
            TestWkstaLockedSAS(SasType);
            break;
        default:
            TestGinaError(0, TEXT("PingSAS"));

    }
    return(0);
}


VOID WINAPI
WlxUseCtrlAltDel(HANDLE hWlx)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxUserCtrlAltDel"));
    }

    fTestGina |= GINA_USE_CAD;

}

VOID
WINAPI
WlxSetContextPointer(
    HANDLE  hWlx,
    PVOID   pvContext)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxSetContextPointer"));
    }

    StashContext(pvContext);
}


VOID WINAPI
WlxSasNotify(HANDLE     hWlx,
             DWORD      dwSasType)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxSasNotify"));
    }

    if (fTestGina & GINA_USE_CAD)
    {
        if (dwSasType == WLX_SAS_TYPE_CTRL_ALT_DEL)
        {
            TestGinaError(GINAERR_IMPROPER_CAD, TEXT("WlxSasNotify"));
        }
    }

    PingSAS(dwSasType);
}


BOOL WINAPI
WlxSetTimeout(
    HANDLE      hWlx,
    DWORD       dwTimeout)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxSetTimeout"));
    }

    if (dwTimeout < 300)
    {
        return(TRUE);
    }
    return(FALSE);

}

int WINAPI
WlxAssignShellProtection(
    HANDLE      hWlx,
    HANDLE      hToken,
    HANDLE      hProcess,
    HANDLE      hThread)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxAssignShellProtection"));
    }

    return(0);
}


int WINAPI
WlxMessageBox(
    HANDLE      hWlx,
    HWND        hWnd,
    LPWSTR      lpsz1,
    LPWSTR      lpsz2,
    UINT        fmb)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxMessageBox"));
    }
    return MessageBoxW(hWnd, lpsz1, lpsz2, fmb);
}

int WINAPI
WlxDialogBox(
    HANDLE      hWlx,
    HANDLE      hInstance,
    LPWSTR      lpsz1,
    HWND        hWnd,
    DLGPROC     dlgproc)
{
    return(WlxDialogBoxParam(hWlx, hInstance, lpsz1, hWnd, dlgproc, 0));
}

int WINAPI
WlxDialogBoxIndirect(
    HANDLE          hWlx,
    HANDLE          hInstance,
    LPCDLGTEMPLATE  lpTemplate,
    HWND            hWnd,
    DLGPROC         dlgproc)
{
    return(WlxDialogBoxIndirectParam(hWlx, hInstance, lpTemplate, hWnd, dlgproc, 0));
}



int WINAPI
WlxDialogBoxParam(
    HANDLE          hWlx,
    HANDLE          hInstance,
    LPWSTR          lpsz1,
    HWND            hWnd,
    DLGPROC         dlgproc,
    LPARAM          lParam)
{
    PWindowMapper   pMap;
    int res;
    char    buf[256];

    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxDialogBoxParam"));
    }

    pMap = AllocWindowMapper();

    pMap->InitialParameter = lParam;
    pMap->DlgProc = dlgproc;
    pMap->fMapper |= MAPPERFLAG_DIALOG;

    res = DialogBoxParam(hInstance, lpsz1, hWnd, RootDlgProc, (LPARAM) pMap);
    if (res == -1)
    {
            if ((DWORD) lpsz1 > 0x00010000)
            {
                sprintf( buf, "DialogBoxParam(%#x, %ws, %#x, %#x, %#x) failed, error %d\n",
                            hInstance, lpsz1, hWnd, dlgproc,
                            lParam, GetLastError() );
            }
            else
            {
                sprintf( buf, "DialogBoxParam(%#x, %#x, %#x, %#x, %#x) failed, error %d\n",
                            hInstance, lpsz1, hWnd, dlgproc,
                            lParam, GetLastError() );

            }

            MessageBoxA( hMainWindow, buf, "Dialog Error", MB_ICONSTOP | MB_OK );
    }

    FreeWindowMapper(pMap);

    return(res);
}

int WINAPI
WlxDialogBoxIndirectParam(
    HANDLE          hWlx,
    HANDLE  hInstance,
    LPCDLGTEMPLATE  lpTemplate,
    HWND    hWnd,
    DLGPROC dlgproc,
    LPARAM  lParam)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxUserCtrlAltDel"));
    }
    return(DialogBoxIndirectParam(hInstance, lpTemplate, hWnd, dlgproc, lParam));
}

int
WINAPI
WlxSwitchDesktopToUser(
    HANDLE      hWlx)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSwitchDesktopToUser"));
    }

    return( 0 );
}

int
WINAPI
WlxSwitchDesktopToWinlogon(
    HANDLE      hWlx)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSwitchDesktopToWinlogon"));
    }

    return( 0 );
}

int
WINAPI
WlxChangePasswordNotify(
    HANDLE                  hWlx,
    PWLX_MPR_NOTIFY_INFO    pMprInfo,
    DWORD                   dwChangeInfo)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxChangePasswordNotify"));
    }

    GlobalMprInfo = *pMprInfo;
    wcscpy( GlobalProviderName, TEXT("All") );

    return( 0 );

}

int
WINAPI
WlxChangePasswordNotifyEx(
    HANDLE                  hWlx,
    PWLX_MPR_NOTIFY_INFO    pMprInfo,
    DWORD                   dwChangeInfo,
    PWSTR                   ProviderName,
    PVOID                   Reserved)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxChangePasswordNotifyEx"));
    }

    GlobalMprInfo = *pMprInfo;
    wcscpy( GlobalProviderName, ProviderName );

    return( 0 );

}


BOOL
WINAPI
WlxSetOption(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR Value,
    ULONG_PTR * OldValue)
{
    ULONG_PTR * Item ;
    ULONG_PTR Dummy ;

    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetOption") );
    }

    Item = &Dummy ;

    switch ( Option )
    {
        case WLX_OPTION_USE_CTRL_ALT_DEL:
            Dummy = (BOOL) ((fTestGina & GINA_USE_CAD) != 0);
            fTestGina |= GINA_USE_CAD;
            break;

        case WLX_OPTION_CONTEXT_POINTER:
            Item = (PDWORD) &pWlxContext ;
            break;

        case WLX_OPTION_USE_SMART_CARD:
            Dummy = (BOOL) ((fTestGina & GINA_USE_SC) != 0);
            fTestGina |= GINA_USE_SC ;
            break;

        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE ;
    }

    if ( Item )
    {
        if ( OldValue )
        {
            *OldValue = *Item ;
        }

        *Item = Value ;
    }

    return TRUE ;
}

BOOL
WINAPI
WlxGetOption(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR * Value)
{
    ULONG_PTR * Item ;
    ULONG_PTR Dummy ;

    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetOption") );
    }

    Item = &Dummy ;

    switch ( Option )
    {
        case WLX_OPTION_USE_CTRL_ALT_DEL:
            Dummy = (BOOL) ((fTestGina & GINA_USE_CAD) != 0);
            break;

        case WLX_OPTION_CONTEXT_POINTER:
            Item = (ULONG_PTR *) &pWlxContext ;
            break;

        case WLX_OPTION_USE_SMART_CARD:
            Dummy = (BOOL) ((fTestGina & GINA_USE_SC) != 0);
            break;

        case WLX_OPTION_SMART_CARD_PRESENT :
            Dummy = IsSmartCardReaderPresent() ;
            break;

        case WLX_OPTION_SMART_CARD_INFO :
            Dummy = (ULONG_PTR)& DummySCData ;
            Item = (ULONG_PTR *) &Dummy ;
            break;

        case WLX_OPTION_DISPATCH_TABLE_SIZE:
            Dummy = sizeof( WlxDispatchTable );
            Item = (ULONG_PTR *) &Dummy ;
            break;

        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE ;
    }

    if ( Item )
    {
        if ( Value )
        {
            *Value = *Item ;
            return TRUE ;
        }

    }

    return FALSE ;
}

VOID
WINAPI
WlxWin31Migrate(
    HANDLE hWlx
    )
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetOption") );
    }
}

BOOL
WINAPI
WlxQueryClientCredentials(
    PWLX_CLIENT_CREDENTIALS_INFO_V1_0 pCred
    )
{
    return FALSE ;
}

BOOL
WINAPI
WlxQueryICCredentials(
    PWLX_CLIENT_CREDENTIALS_INFO_V1_0 pCred
    )
{
    return FALSE ;
}

BOOL
WINAPI
WlxDisconnect(
    VOID
    )
{
    return FALSE ;
}



struct _BitsToMenu {
    DWORD   Bits;
    DWORD   Menu;
} MenuBarControl[] = {
    {   GINA_DLL_KNOWN, IDM_DLL_RUN },
    {   GINA_NEGOTIATE_OK, IDM_WHACK_NEGOTIATE },
    {   GINA_INITIALIZE_OK, IDM_WHACK_INITIALIZE },
    {   GINA_DISPLAY_OK, IDM_WHACK_DISPLAY },
    {   GINA_LOGGEDOUT_OK, IDM_WHACK_LOGGEDOUT },
    {   GINA_ACTIVATE_OK, IDM_WHACK_STARTSHELL },
    {   GINA_LOGGEDON_OK, IDM_WHACK_LOGGEDON },
    {   GINA_DISPLAYLOCK_OK, IDM_WHACK_DISPLAYLOCKED},
    {   GINA_WKSTALOCK_OK, IDM_WHACK_LOCKED },
    {   GINA_LOGOFF_OK, IDM_WHACK_LOGOFF },
    {   GINA_SHUTDOWN_OK, IDM_WHACK_SHUTDOWN },
    {   GINA_ISLOCKOK_OK, IDM_WHACK_LOCKOK },
    {   GINA_ISLOGOFFOK_OK, IDM_WHACK_LOGOFFOK },
    {   GINA_RESTART_OK, IDM_WHACK_RESTARTSHELL },
    {   GINA_SCREENSAVE_OK, IDM_WHACK_SCREENSAVE },

    };


int
UpdateMenuBar(void)
{
    HMENU   hMenu;
    int i;

    hMenu = GetMenu(hMainWindow);

    for (i = 0; i < (sizeof(MenuBarControl) / sizeof(struct _BitsToMenu))  ; i++ )
    {
        if (TEST_FLAG(fTestGina, MenuBarControl[i].Bits))
        {
            EnableMenuItem(hMenu, MenuBarControl[i].Menu, MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, MenuBarControl[i].Menu, MF_BYCOMMAND | MF_GRAYED);
        }
    }

    return(0);
}

VOID
EnableOptions(BOOL  Enable)
{
    HMENU   hMenu;
    HMENU   hOptions;
    UINT    uenable;

    hMenu = GetMenu( hMainWindow );

    hOptions = GetSubMenu( hMenu, 2 );

    if (Enable)
    {
        uenable = MF_ENABLED | MF_BYCOMMAND;
    }
    else
    {
        uenable = MF_GRAYED | MF_BYCOMMAND;
    }

    EnableMenuItem( hMenu, (UINT) hOptions, uenable);

    DrawMenuBar( hMainWindow );
}

VOID
UpdateSasMenu(VOID)
{
    HMENU   hMenu;
    HMENU   hOptions;
    HMENU   hSas;
    DWORD   i;
    DWORD   MenuItem;

    hMenu = GetMenu( hMainWindow );

    hOptions = GetSubMenu( hMenu, 2 );

    hSas = GetSubMenu( hOptions, 0 );

    //
    // Clean out existing ones
    //

    DeleteMenu( hSas, IDM_SAS_USERDEF1, MF_BYCOMMAND );
    DeleteMenu( hSas, IDM_SAS_USERDEF2, MF_BYCOMMAND );
    DeleteMenu( hSas, IDM_SAS_USERDEF3, MF_BYCOMMAND );
    DeleteMenu( hSas, IDM_SAS_USERDEF4, MF_BYCOMMAND );

    //
    // Add in current ones:
    //

    for (i = 0, MenuItem = IDM_SAS_USERDEF1; i < UserSases ; i++, MenuItem++ )
    {
        AppendMenu( hSas, MF_STRING, MenuItem, UserDefSas[i].Name );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testshim\testshim.c ===
/*++

Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    ginastub.c

Abstract:


--*/

#include <windows.h>
#include <stdio.h>
#include <winwlx.h>

#include "testshim.h"

//
// Location of the real msgina.
//

#define REALGINA_PATH   TEXT("MSGINA.DLL")


//
// winlogon function dispatch table
//

WLX_DISPATCH_VERSION_1_3 WinlogonTable;
PWLX_DISPATCH_VERSION_1_3 pTable ;

//
// Functions pointers to the real msgina which we will call.
//

PGWLXNEGOTIATE GWlxNegotiate;
PGWLXINITIALIZE GWlxInitialize;
PGWLXDISPLAYSASNOTICE GWlxDisplaySASNotice;
PGWLXLOGGEDOUTSAS GWlxLoggedOutSAS;
PGWLXACTIVATEUSERSHELL GWlxActivateUserShell;
PGWLXLOGGEDONSAS GWlxLoggedOnSAS;
PGWLXDISPLAYLOCKEDNOTICE GWlxDisplayLockedNotice;
PGWLXWKSTALOCKEDSAS GWlxWkstaLockedSAS;
PGWLXISLOCKOK GWlxIsLockOk;
PGWLXISLOGOFFOK GWlxIsLogoffOk;
PGWLXLOGOFF GWlxLogoff;
PGWLXSHUTDOWN GWlxShutdown;

//
// NEW for version 1.1
//

PGWLXSTARTAPPLICATION GWlxStartApplication;
PGWLXSCREENSAVERNOTIFY GWlxScreenSaverNotify;

//
// Scum Level
//

ULONG ScumLevel = 0 ;

#define SCUM_CLEAN  2 
#define SCUM_DIRTY  1 
#define SCUM_RANCID 0 

//
// hook into the real GINA.
//

BOOL
MyInitialize( void )
{
    HINSTANCE hDll;

    //
    // Load MSGINA.DLL.
    //
    if( !(hDll = LoadLibrary( REALGINA_PATH )) ) {
        return FALSE;
    }

    ScumLevel = GetProfileInt( TEXT("Winlogon"), 
                               TEXT("ShimScum"),
                               0 );

    //
    // Get pointers to all of the WLX functions in the real MSGINA.
    //
    GWlxNegotiate = (PGWLXNEGOTIATE)GetProcAddress( hDll, "WlxNegotiate" );
    if( !GWlxNegotiate ) {
        return FALSE;
    }

    GWlxInitialize = (PGWLXINITIALIZE)GetProcAddress( hDll, "WlxInitialize" );
    if( !GWlxInitialize ) {
        return FALSE;
    }

    GWlxDisplaySASNotice =
        (PGWLXDISPLAYSASNOTICE)GetProcAddress( hDll, "WlxDisplaySASNotice" );
    if( !GWlxDisplaySASNotice ) {
        return FALSE;
    }

    GWlxLoggedOutSAS =
        (PGWLXLOGGEDOUTSAS)GetProcAddress( hDll, "WlxLoggedOutSAS" );
    if( !GWlxLoggedOutSAS ) {
        return FALSE;
    }

    GWlxActivateUserShell =
        (PGWLXACTIVATEUSERSHELL)GetProcAddress( hDll, "WlxActivateUserShell" );
    if( !GWlxActivateUserShell ) {
        return FALSE;
    }

    GWlxLoggedOnSAS =
        (PGWLXLOGGEDONSAS)GetProcAddress( hDll, "WlxLoggedOnSAS" );
    if( !GWlxLoggedOnSAS ) {
        return FALSE;
    }

    GWlxDisplayLockedNotice =
        (PGWLXDISPLAYLOCKEDNOTICE)GetProcAddress(
                                        hDll,
                                        "WlxDisplayLockedNotice" );
    if( !GWlxDisplayLockedNotice ) {
        return FALSE;
    }

    GWlxIsLockOk = (PGWLXISLOCKOK)GetProcAddress( hDll, "WlxIsLockOk" );
    if( !GWlxIsLockOk ) {     
        return FALSE;
    }

    GWlxWkstaLockedSAS =
        (PGWLXWKSTALOCKEDSAS)GetProcAddress( hDll, "WlxWkstaLockedSAS" );
    if( !GWlxWkstaLockedSAS ) {
        return FALSE;
    }

    GWlxIsLogoffOk = (PGWLXISLOGOFFOK)GetProcAddress( hDll, "WlxIsLogoffOk" );
    if( !GWlxIsLogoffOk ) {
        return FALSE;
    }

    GWlxLogoff = (PGWLXLOGOFF)GetProcAddress( hDll, "WlxLogoff" );
    if( !GWlxLogoff ) {
        return FALSE;
    }

    GWlxShutdown = (PGWLXSHUTDOWN)GetProcAddress( hDll, "WlxShutdown" );
    if( !GWlxShutdown ) {
        return FALSE;
    }

    //
    // we don't check for failure here because these don't exist for
    // gina's implemented prior to Windows NT 4.0
    //

    GWlxStartApplication = (PGWLXSTARTAPPLICATION) GetProcAddress( hDll, "WlxStartApplication" );
    GWlxScreenSaverNotify = (PGWLXSCREENSAVERNOTIFY) GetProcAddress( hDll, "WlxScreenSaverNotify" );

    //
    // Everything loaded ok.  Return success.
    //
    return TRUE;
}


BOOL
WINAPI
WlxNegotiate(
    DWORD       dwWinlogonVersion,
    DWORD       *pdwDllVersion)
{
    BOOL NegRet ;

    if( !MyInitialize() )
        return FALSE;

    NegRet = GWlxNegotiate(
                ( (ScumLevel == SCUM_RANCID) ? dwWinlogonVersion :
                  (ScumLevel == SCUM_DIRTY) ? WLX_VERSION_1_2 :
                    dwWinlogonVersion ),
                pdwDllVersion );

    return NegRet ;


}


BOOL
WINAPI
WlxInitialize(
    LPWSTR      lpWinsta,
    HANDLE      hWlx,
    PVOID       pvReserved,
    PVOID       pWinlogonFunctions,
    PVOID       *pWlxContext)
{
    switch ( ScumLevel )
    {
        case SCUM_RANCID:
        case SCUM_DIRTY:
            CopyMemory( &WinlogonTable,
                        pWinlogonFunctions,
                        sizeof( WLX_DISPATCH_VERSION_1_2 ) );
            pTable = &WinlogonTable ;
            break;

        case SCUM_CLEAN:
            pTable = pWinlogonFunctions ;
            break;
            
    }
    return GWlxInitialize(
                lpWinsta,
                hWlx,
                pvReserved,
                pTable,
                pWlxContext
                );
}


VOID
WINAPI
WlxDisplaySASNotice(
    PVOID   pWlxContext)
{
    GWlxDisplaySASNotice( pWlxContext );
}


int
WINAPI
WlxLoggedOutSAS(
    PVOID           pWlxContext,
    DWORD           dwSasType,
    PLUID           pAuthenticationId,
    PSID            pLogonSid,
    PDWORD          pdwOptions,
    PHANDLE         phToken,
    PWLX_MPR_NOTIFY_INFO    pMprNotifyInfo,
    PVOID           *pProfile)
{
    int iRet;

    iRet = GWlxLoggedOutSAS(
                pWlxContext,
                dwSasType,
                pAuthenticationId,
                pLogonSid,
                pdwOptions,
                phToken,
                pMprNotifyInfo,
                pProfile
                );

    if(iRet == WLX_SAS_ACTION_LOGON) {
        //
        // copy pMprNotifyInfo and pLogonSid for later use
        //

        // pMprNotifyInfo->pszUserName
        // pMprNotifyInfo->pszDomain
        // pMprNotifyInfo->pszPassword
        // pMprNotifyInfo->pszOldPassword

    }

    return iRet;
}


BOOL
WINAPI
WlxActivateUserShell(
    PVOID           pWlxContext,
    PWSTR           pszDesktopName,
    PWSTR           pszMprLogonScript,
    PVOID           pEnvironment)
{
    return GWlxActivateUserShell(
                pWlxContext,
                pszDesktopName,
                pszMprLogonScript,
                pEnvironment
                );
}


int
WINAPI
WlxLoggedOnSAS(
    PVOID           pWlxContext,
    DWORD           dwSasType,
    PVOID           pReserved)
{
    return GWlxLoggedOnSAS( pWlxContext, dwSasType, pReserved );
}

VOID
WINAPI
WlxDisplayLockedNotice(
    PVOID           pWlxContext )
{
    GWlxDisplayLockedNotice( pWlxContext );
}


BOOL
WINAPI
WlxIsLockOk(
    PVOID           pWlxContext)
{
    return GWlxIsLockOk( pWlxContext );
}


int
WINAPI
WlxWkstaLockedSAS(
    PVOID           pWlxContext,
    DWORD           dwSasType )
{
    return GWlxWkstaLockedSAS( pWlxContext, dwSasType );
}

BOOL
WINAPI
WlxIsLogoffOk(
    PVOID pWlxContext
    )
{
    BOOL bSuccess;

    bSuccess = GWlxIsLogoffOk( pWlxContext );

    if(bSuccess) {

        //
        // if it's ok to logoff, finish with the stored credentials
        // and scrub the buffers
        //

    }

    return bSuccess;
}


VOID
WINAPI
WlxLogoff(
    PVOID pWlxContext
    )
{
    GWlxLogoff( pWlxContext );
}


VOID
WINAPI
WlxShutdown(
    PVOID pWlxContext,
    DWORD ShutdownType
    )
{
    GWlxShutdown( pWlxContext, ShutdownType );
}


//
// NEW for version 1.1
//

BOOL
WINAPI
WlxScreenSaverNotify(
    PVOID                   pWlxContext,
    BOOL *                  pSecure
    )
{
    if(GWlxScreenSaverNotify != NULL)
        return GWlxScreenSaverNotify( pWlxContext, pSecure );

    //
    // if not exported, return something intelligent
    //

    *pSecure = TRUE;

    return TRUE;
}

BOOL
WINAPI
WlxStartApplication(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktopName,
    PVOID                   pEnvironment,
    PWSTR                   pszCmdLine
    )
{
    if(GWlxStartApplication != NULL)
        return GWlxStartApplication(
            pWlxContext,
            pszDesktopName,
            pEnvironment,
            pszCmdLine
            );

    //
    // if not exported, return something intelligent
    //

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testgina\wlx.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       wlx.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-15-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"
HANDLE  hThread;
SID_IDENTIFIER_AUTHORITY gSystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY gLocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
WLX_MPR_NOTIFY_INFO GlobalMprInfo;
WCHAR GlobalProviderName[128];

HANDLE  hToken;


void
LockTestGina(void)
{
    FLAG_OFF(fTestGina, GINA_LOGGEDON_OK);
    FLAG_ON(fTestGina, GINA_DISPLAYLOCK_OK);
    FLAG_ON(fTestGina, GINA_WKSTALOCK_OK);
    UpdateGinaState(UPDATE_LOCK_WKSTA);
    UpdateMenuBar();

}

void
UnlockTestGina(void)
{
    FLAG_OFF(fTestGina, GINA_DISPLAYLOCK_OK);
    FLAG_OFF(fTestGina, GINA_WKSTALOCK_OK);
    FLAG_ON(fTestGina, GINA_LOGGEDON_OK);
    UpdateGinaState(UPDATE_UNLOCK_WKSTA);
    UpdateMenuBar();
}

LogoffUser(void)
{
    CloseHandle(hToken);
    FLAG_OFF(fTestGina, GINA_LOGGEDON_OK);
    FLAG_OFF(fTestGina, GINA_DISPLAYLOCK_OK);
    FLAG_OFF(fTestGina, GINA_WKSTALOCK_OK);
    FLAG_ON(fTestGina, GINA_LOGGEDOUT_OK);
    FLAG_ON(fTestGina, GINA_DISPLAY_OK);
    UpdateGinaState(UPDATE_LOGOFF);
    UpdateMenuBar();
    return(0);
}



BOOLEAN
LoadGinaDll(void)
{
    hDllInstance = LoadLibrary(szGinaDll);

    if (!hDllInstance)
    {
        TestGinaError(GINAERR_LOAD_FAILED, TEXT("LoadGinaDll"));
    }
    pWlxNegotiate = (PWLX_NEGOTIATE) GetProcAddress(hDllInstance, WLX_NEGOTIATE_NAME);
    if (!pWlxNegotiate)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_NEGOTIATE_NAME));
    }

    pWlxInitialize = (PWLX_INITIALIZE) GetProcAddress(hDllInstance, WLX_INITIALIZE_NAME);
    if (!pWlxInitialize)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_INITIALIZE_NAME));
    }

    pWlxDisplaySASNotice = (PWLX_DISPLAYSASNOTICE) GetProcAddress(hDllInstance, WLX_DISPLAYSASNOTICE_NAME);
    if (!pWlxDisplaySASNotice)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_DISPLAYSASNOTICE_NAME));
    }

    pWlxLoggedOutSAS = (PWLX_LOGGEDOUTSAS) GetProcAddress(hDllInstance, WLX_LOGGEDOUTSAS_NAME);
    if (!pWlxLoggedOutSAS)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_LOGGEDOUTSAS_NAME));
    }

    pWlxActivateUserShell = (PWLX_ACTIVATEUSERSHELL) GetProcAddress(hDllInstance, WLX_ACTIVATEUSERSHELL_NAME);
    if (!pWlxActivateUserShell)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_ACTIVATEUSERSHELL_NAME));
    }

    pWlxLoggedOnSAS = (PWLX_LOGGEDONSAS) GetProcAddress(hDllInstance, WLX_LOGGEDONSAS_NAME);
    if (!pWlxLoggedOnSAS)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_LOGGEDONSAS_NAME));
    }

    pWlxDisplayLockedNotice = (PWLX_DISPLAYLOCKEDNOTICE) GetProcAddress(hDllInstance, WLX_DISPLAYLOCKED_NAME);
    if (!pWlxDisplayLockedNotice)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_DISPLAYLOCKED_NAME));
    }

    pWlxWkstaLockedSAS = (PWLX_WKSTALOCKEDSAS) GetProcAddress(hDllInstance, WLX_WKSTALOCKEDSAS_NAME);
    if (!pWlxWkstaLockedSAS)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_WKSTALOCKEDSAS_NAME));
    }

    pWlxLogoff = (PWLX_LOGOFF) GetProcAddress(hDllInstance, WLX_LOGOFF_NAME);
    if (!pWlxLogoff)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_LOGOFF_NAME));
    }

    pWlxShutdown = (PWLX_SHUTDOWN) GetProcAddress(hDllInstance, WLX_SHUTDOWN_NAME);
    if (!pWlxShutdown)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_SHUTDOWN_NAME));
    }

    FLAG_ON(fTestGina, GINA_NEGOTIATE_OK);

    UpdateMenuBar();

    return(TRUE);
}


BOOLEAN
TestNegotiate(void)
{
    BOOL ret;

    if (!TEST_FLAG(fTestGina, GINA_NEGOTIATE_OK) ||
        !TEST_FLAG(fTestGina, GINA_DLL_KNOWN))
    {
        TestGinaError(0, TEXT("TestNegotiate"));
    }

    if (TEST_FLAG(GinaBreakFlags, BREAK_NEGOTIATE))
    {
        LogEvent(0, "About to call WlxNegotiate(%d, @%#x):\n",
            WLX_CURRENT_VERSION, & DllVersion);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }

    ret = pWlxNegotiate(WLX_CURRENT_VERSION, & DllVersion );

    if (TEST_FLAG(GinaBreakFlags, BREAK_NEGOTIATE))
    {
        LogEvent(0, "Back from WlxNegotiate() @%#x = %d \n",
            & DllVersion, DllVersion);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }

    if (DllVersion > WLX_CURRENT_VERSION)
    {
        TestGinaError(GINAERR_INVALID_LEVEL, TEXT("TestNegotiate"));
    }

    FLAG_OFF(fTestGina, GINA_NEGOTIATE_OK);
    FLAG_ON(fTestGina, GINA_INITIALIZE_OK);

    UpdateMenuBar();

    GinaState = Winsta_Initialize;
    LastRetCode = WLX_SAS_ACTION_BOOL_RET;
    LastBoolRet = ret;

    UpdateStatusBar();

    return(TRUE);

}


BOOLEAN
TestInitialize(void)
{
    PVOID   pContext = NULL;
    BOOL ret;

    if (!TEST_FLAG(fTestGina, GINA_INITIALIZE_OK))
    {
        TestGinaError(0, TEXT("TestInitialize"));
    }

    AssociateHandle((HANDLE) 1);

    UpdateGinaState(UPDATE_INITIALIZE);

    FLAG_OFF(fTestGina, GINA_INITIALIZE_OK);
    FLAG_ON(fTestGina, GINA_LOGGEDOUT_OK);
    FLAG_ON(fTestGina, GINA_SHUTDOWN_OK);
    FLAG_ON(fTestGina, GINA_DISPLAY_OK);

    UpdateMenuBar();

    if (TEST_FLAG(GinaBreakFlags, BREAK_INITIALIZE))
    {
        LogEvent(0, "About to call WlxInitialize(%ws, 1, @%#x, @%#x)\n",
                    TEXT("winsta0"), &WlxDispatchTable, &pContext);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    ret = pWlxInitialize( TEXT("winsta0"),
                    (HANDLE) 1,
                    NULL,
                    &WlxDispatchTable,
                    &pContext );

    StashContext(pContext);

    GinaState = Winsta_NoOne;
    LastRetCode = WLX_SAS_ACTION_BOOL_RET;
    LastBoolRet = ret;

    UpdateStatusBar();
    EnableOptions( TRUE );

    return(TRUE);
}

DWORD
TestDisplaySASNoticeWorker(PVOID    pvIgnored)
{
    PVOID   pContext = NULL;
    DWORD   err;

    if (!TEST_FLAG(fTestGina, GINA_DISPLAY_OK))
    {
        TestGinaError(0, TEXT("TestDisplaySASNotice"));
    }

    pContext = GetContext();

    if (TEST_FLAG(GinaBreakFlags, BREAK_DISPLAY))
    {
        LogEvent(0, "About to call WlxDisplaySASNotice(%#x) \n", pContext);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    pWlxDisplaySASNotice(pContext);

    err = GetLastError();


    return(err == 0 ? TRUE : FALSE);

}

BOOLEAN
TestDisplaySASNotice(void)
{
    DWORD   tid;

    UpdateGinaState(UPDATE_DISPLAY_NOTICE);

    hThread = CreateThread( NULL, 0, TestDisplaySASNoticeWorker,
                            NULL, 0, &tid);

    CloseHandle(hThread);

    return(TRUE);
}


/***************************************************************************\
* CreateLogonSid
*
* Creates a logon sid for a new logon.
*
* If LogonId is non NULL, on return the LUID that is part of the logon
* sid is returned here.
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PSID
CreateLogonSid(
    PLUID LogonId OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG   Length;
    PSID    Sid;
    LUID    Luid;

    //
    // Generate a locally unique id to include in the logon sid
    //

    Status = NtAllocateLocallyUniqueId(&Luid);
    if (!NT_SUCCESS(Status)) {
        TestGinaError(0, TEXT("CreateLogonSid"));
        return(NULL);
    }


    //
    // Allocate space for the sid and fill it in.
    //

    Length = RtlLengthRequiredSid(SECURITY_LOGON_IDS_RID_COUNT);

    Sid = (PSID)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Length);
    ASSERTMSG("Winlogon failed to allocate memory for logonsid", Sid != NULL);

    if (Sid != NULL) {

        RtlInitializeSid(Sid, &gSystemSidAuthority, SECURITY_LOGON_IDS_RID_COUNT);

        ASSERT(SECURITY_LOGON_IDS_RID_COUNT == 3);

        *(RtlSubAuthoritySid(Sid, 0)) = SECURITY_LOGON_IDS_RID;
        *(RtlSubAuthoritySid(Sid, 1 )) = Luid.HighPart;
        *(RtlSubAuthoritySid(Sid, 2 )) = Luid.LowPart;
    }


    //
    // Return the logon LUID if required.
    //

    if (LogonId != NULL) {
        *LogonId = Luid;
    }

    return(Sid);
}

DWORD
TestLoggedOutSASWorker(PVOID    pvIgnored)
{
    PVOID   pContext = NULL;
    DWORD   res;
    LUID    LogonId;
    PSID    pSid;
    WLX_MPR_NOTIFY_INFO MprInfo;
    PWLX_PROFILE_V2_0   pProfile;
    DWORD   Options;

    if (!TEST_FLAG(fTestGina, GINA_LOGGEDOUT_OK))
    {
        TestGinaError(0, TEXT("TestLoggedOutSASWorker"));
    }

    pContext = GetContext();

    pSid = CreateLogonSid(NULL);

    if (TEST_FLAG(GinaBreakFlags, BREAK_LOGGEDOUT))
    {
        LogEvent(0, "About to call WlxLoggedOutSAS()\n");
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }

    res = pWlxLoggedOutSAS( pContext,
                            (DWORD) pvIgnored,
                            &LogonId,
                            pSid,
                            &Options,
                            &hToken,
                            &MprInfo,
                            &pProfile );

    if (!ValidResponse(WLX_LOGGEDOUTSAS_API, res))
    {
        TestGinaError(GINAERR_INVALID_RETURN, TEXT("WlxLoggedOutSAS"));
    }

    if (res == WLX_SAS_ACTION_LOGON)
    {
        UpdateGinaState(UPDATE_USER_LOGON);
        FLAG_OFF(fTestGina, GINA_LOGGEDOUT_OK);
        FLAG_OFF(fTestGina, GINA_DISPLAY_OK);
        FLAG_ON(fTestGina, GINA_ACTIVATE_OK);
        UpdateMenuBar();
        if (MprInfo.pszUserName || MprInfo.pszDomain || MprInfo.pszPassword ||
            MprInfo.pszOldPassword)
        {
//          FLAG_ON(fTestGina, GINA_MPRINFO_RECV);
            GlobalMprInfo = MprInfo;
            wcscpy( GlobalProviderName, TEXT("All") );
        }
    }
    if (res == WLX_SAS_ACTION_NONE)
    {
        UpdateGinaState(UPDATE_SAS_COMPLETE);
    }


    return(res);

}

int
TestLoggedOutSAS(int    SasType)
{
    DWORD   tid;

    hThread = CreateThread( NULL, 0, TestLoggedOutSASWorker,
                            (PVOID) SasType, 0, &tid);

    CloseHandle(hThread);

    return(TRUE);

}

int
TestActivateUserShell(void)
{
    PVOID   pContext = NULL;
    PVOID   pEnvironment = NULL;

    if (!TEST_FLAG(fTestGina, GINA_ACTIVATE_OK) )
    {
        TestGinaError(0, TEXT("TestActivateUserShell"));
    }

    pContext = GetContext();

    pEnvironment = GetEnvironmentStrings();

    pWlxActivateUserShell(  pContext,
                            TEXT("Winsta0\\Default"),
                            NULL,
                            pEnvironment );

    FLAG_OFF(fTestGina, GINA_ACTIVATE_OK);
    FLAG_ON(fTestGina, GINA_LOGGEDON_OK);
    UpdateMenuBar();

    return(0);
}

int
TestLoggedOnSAS(int SasType)
{
    PVOID                   pContext = NULL;
    WLX_MPR_NOTIFY_INFO     MprInfo;
    DWORD                   Result;

    if (!TEST_FLAG(fTestGina, GINA_LOGGEDON_OK))
    {
        TestGinaError(0, TEXT("TestLoggedOnSAS"));
    }

    pContext = GetContext();

    if (TEST_FLAG(GinaBreakFlags, BREAK_LOGGEDON))
    {
        LogEvent(0, "About to call WlxLoggedOnSAS\n");
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    Result = pWlxLoggedOnSAS(   pContext,
                                SasType,
                                &MprInfo );

    if (!ValidResponse(WLX_LOGGEDONSAS_API, Result))
    {
        TestGinaError(GINAERR_INVALID_RETURN, TEXT("WlxLoggedOnSAS"));
    }

    switch (Result)
    {
        case WLX_SAS_ACTION_NONE:
            UpdateGinaState(UPDATE_SAS_COMPLETE);
            break;

        case WLX_SAS_ACTION_TASKLIST:
            UpdateGinaState(UPDATE_SAS_COMPLETE);
            break;

        case WLX_SAS_ACTION_LOCK_WKSTA:
            LockTestGina();
            break;

        case WLX_SAS_ACTION_LOGOFF:
            LogoffUser();
            break;

        case WLX_SAS_ACTION_SHUTDOWN:
        case WLX_SAS_ACTION_SHUTDOWN_REBOOT:
        case WLX_SAS_ACTION_SHUTDOWN_POWER_OFF:
            LogoffUser();
            UpdateGinaState(UPDATE_SHUTDOWN);
            break;

        default:
            TestGinaError(0, TEXT("TestLoggedOnSAS_2"));

    }

    return(0);
}

DWORD
TestDisplayLockedWorker(PVOID    pvIgnored)
{
    PVOID   pContext = NULL;
    DWORD   err;

    if (!TEST_FLAG(fTestGina, GINA_DISPLAYLOCK_OK))
    {
        TestGinaError(0, TEXT("TestDisplayLocked"));
    }

    pContext = GetContext();

    if (TEST_FLAG(GinaBreakFlags, BREAK_DISPLAYLOCKED))
    {
        LogEvent(0, "About to call WlxDisplayLockedNotice(%#x) \n", pContext);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    pWlxDisplayLockedNotice(pContext);

    err = GetLastError();


    return(err == 0 ? TRUE : FALSE);

}
int
TestDisplayLockedNotice(void)
{
    DWORD   tid;

    hThread = CreateThread( NULL, 0, TestDisplayLockedWorker,
                            NULL, 0, &tid);

    CloseHandle(hThread);

    return(0);
}


int
TestWkstaLockedSAS(int  SasType)
{
    PVOID   pContext;
    DWORD   Result;

    pContext = GetContext();

    if (!TEST_FLAG(fTestGina, GINA_WKSTALOCK_OK))
    {
        TestGinaError(0, TEXT("TestWkstaLockedSAS"));
    }

    if (TEST_FLAG(GinaBreakFlags, BREAK_WKSTALOCKED))
    {
        LogEvent(0, "About to call WlxWkstaLockedSAS\n");
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    Result = pWlxWkstaLockedSAS(pContext,
                                SasType);

    if (!ValidResponse(WLX_WKSTALOCKEDSAS_API, Result))
    {
        TestGinaError(GINAERR_INVALID_RETURN, TEXT("WlxWkstaLockedSAS"));
    }

    switch (Result)
    {
        case WLX_SAS_ACTION_NONE:
            UpdateGinaState(UPDATE_SAS_COMPLETE);
            return(0);

        case WLX_SAS_ACTION_UNLOCK_WKSTA:
            UnlockTestGina();
            return(0);

        case WLX_SAS_ACTION_FORCE_LOGOFF:
            LogoffUser();
            UpdateGinaState(UPDATE_SAS_COMPLETE);
            return(0);

        default:
            TestGinaError(0, TEXT("TestWkstaLockedSAS_2"));
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\uenvext\uenvext.cpp ===
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<stdio.h>
#include<string.h>
#include<memory.h>
#include<malloc.h>
#include<stdlib.h>

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <dbghelp.h>
#include <ntsdexts.h>
#include <wdbgexts.h>
#include <ntverp.h>

#define private public
#define protected public

#include "uenv.h"
#include "reghash.h"

//
// forwards
//

BOOL
ReadMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead );

BOOL
ReadMemoryKernelMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead );

BOOL
WriteMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead );

BOOL
WriteMemoryKernelMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead );

//
// types
//

typedef BOOL (*UEnvReadMemory)( HANDLE, const void*, void*, DWORD, DWORD* );
typedef BOOL (*UEnvWriteMemory)( HANDLE, void*, void*, DWORD, DWORD* );

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion = 0;
USHORT                  SavedMinorVersion = 0;
BOOL                    fKernelDebug = FALSE;
UEnvReadMemory          ReadMemoryExt = ReadMemoryUserMode;
UEnvReadMemory          WriteMemoryExt = ReadMemoryUserMode;

//
// macros
//
#define ExtensionRoutinePrologue()  if (!fKernelDebug) \
                                    { \
                                        ExtensionApis = *lpExtensionApis; \
                                        ReadMemoryExt = ReadMemoryUserMode; \
                                        WriteMemoryExt = WriteMemoryUserMode; \
                                    } \
                                    ULONG_PTR dwAddr = GetExpression(lpArgumentString); \

#define PRINT_SIZE(_x_) {dprintf(#_x_" - 0x%X\n", sizeof(_x_));}

#define Boolean( x )    ( x ) ? "True" : "False"

//
// routines
//

BOOL
DllInit(HANDLE hModule,
        DWORD  dwReason,
        DWORD  dwReserved  )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    fKernelDebug = TRUE;
    ReadMemoryExt = ReadMemoryKernelMode;
    WriteMemoryExt = WriteMemoryKernelMode;
    
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

//
// define our own operators new and delete, so that we do not have to include the crt
//
void* __cdecl
::operator new(size_t dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void __cdecl
::operator delete (void* p)
{
    HeapFree(GetProcessHeap(), 0, p);
}

BOOL
ReadMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return ReadProcessMemory( hProcess, pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
ReadMemoryKernelMode( HANDLE, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return ReadMemory( (ULONG) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
WriteMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return WriteProcessMemory( hProcess, (void*) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
WriteMemoryKernelMode( HANDLE, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return WriteMemory( (ULONG) pAddress, pBuffer, dwSize, pdwRead );
}

void
PrintUuid( UUID x )
{
    dprintf("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                x.Data1, x.Data2, x.Data3, x.Data4[0], x.Data4[1],
                x.Data4[2], x.Data4[3], x.Data4[4], x.Data4[5],
                x.Data4[6], x.Data4[7] );
}

void
version(HANDLE  hCurrentProcess,
        HANDLE  hCurrentThread,
        DWORD   dwCurrentPc,
        PWINDBG_EXTENSION_APIS lpExtensionApis,
        LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    if ( fKernelDebug )
    {
        dprintf( "%s UserEnv Extension dll for Build %d debugging %s kernel for Build %d\n",
                 DebuggerType,
                 VER_PRODUCTBUILD,
                 SavedMajorVersion == 0x0c ? "Checked" : "Free",
                 SavedMinorVersion
               );
    }
    else
    {
        dprintf(
                "%s UserEnv Extension dll for Build %d\n",
                DebuggerType,
                VER_PRODUCTBUILD
                );
    }
}

LPEXT_API_VERSION
ExtensionApiVersion( void )
{
    return &ApiVersion;
}

void help(  HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )

{
    ExtensionRoutinePrologue();
    dprintf("!version\n");
    dprintf("!gpo           <address>\n");
    dprintf("!gpext         <address>\n");
    dprintf("!container     <address>\n");
    dprintf("!som           <address>\n");
    dprintf("!profile       <address>\n");
    dprintf("!debuglevel    <address>\n");
    dprintf("!dmpregtable   <address>\n");
    
    // dprintf("!globals\n");
    dprintf("!sizes\n");
}

void gpo(   HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )

{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(GPOINFO)];
    LPGPOINFO       lpGPOInfo = (LPGPOINFO) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(GPOINFO), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(GPOINFO) )
    {
        dprintf("dwFlags                 - 0x%08X\n", lpGPOInfo->dwFlags );
        dprintf("iMachineRole            - %d\n",   lpGPOInfo->iMachineRole );
        dprintf("hToken                  - 0x%08X\n", lpGPOInfo->hToken );
        dprintf("pRsopToken              - 0x%08X\n", lpGPOInfo->pRsopToken );

        WCHAR sz[128];
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPOInfo->lpDNName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;

        dprintf("lpDNName                - 0x%08X\t: \"%S\"\n", lpGPOInfo->lpDNName, bOk ? sz : L"" );
        dprintf("hEvent                  - 0x%08X\n", lpGPOInfo->hEvent );
        dprintf("hKeyRoot                - 0x%08X\n", lpGPOInfo->hKeyRoot );
        dprintf("bXferToExtList          - %s\n",   Boolean( lpGPOInfo->bXferToExtList ) );
        dprintf("lpExtFilterList         - 0x%08X\n", lpGPOInfo->lpExtFilterList );
        dprintf("lpGPOList               - 0x%08X\n", lpGPOInfo->lpGPOList );
        
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPOInfo->lpwszSidUser, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;

        dprintf("lpwszSidUser            - 0x%08X\t: \"%S\"\n", lpGPOInfo->lpwszSidUser, bOk ? sz : L""  );
        dprintf("hTriggerEvent           - 0x%08X\n", lpGPOInfo->hTriggerEvent );
        dprintf("hNotifyEvent            - 0x%08X\n", lpGPOInfo->hNotifyEvent );
        dprintf("hCritSection            - 0x%08X\n", lpGPOInfo->hCritSection );
        dprintf("lpExtensions            - 0x%08X\n", lpGPOInfo->lpExtensions );
        dprintf("bMemChanged             - %s\n", Boolean( lpGPOInfo->bMemChanged ) );
        dprintf("bUserLocalMemChanged    - %s\n", Boolean( lpGPOInfo->bUserLocalMemChanged ) );
        dprintf("pStatusCallback         - 0x%08X\n", lpGPOInfo->pStatusCallback );
        dprintf("lpSOMList               - 0x%08X\n", lpGPOInfo->lpSOMList );
        dprintf("lpGpContainerList       - 0x%08X\n", lpGPOInfo->lpGpContainerList );
        dprintf("lpLoopbackSOMList       - 0x%08X\n", lpGPOInfo->lpLoopbackSOMList );
        dprintf("lpLoopbackGpContainer   - 0x%08X\n", lpGPOInfo->lpLoopbackGpContainerList );
    }
}

void gpext( HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(GPEXT)];
    LPGPEXT         lpGPExt = (LPGPEXT) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(GPEXT), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(GPEXT) )
    {
        WCHAR sz[256];
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpDisplayName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpDisplayName           - 0x%08X\t: \"%S\"\n", lpGPExt->lpDisplayName, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpKeyName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpKeyName               - 0x%08X\t: \"%S\"\n", lpGPExt->lpKeyName, bOk ? sz : L""  );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpDllName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpDllName               - 0x%08X\t: \"%S\"\n", lpGPExt->lpDllName, bOk ? sz : L""  );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpFunctionName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpFunctionName          - 0x%08X\t: \"%S\"\n", lpGPExt->lpFunctionName, bOk ? sz : L""  );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpRsopFunctionName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpRsopFunctionName      - 0x%08X\t: \"%S\"\n", lpGPExt->lpRsopFunctionName, bOk ? sz : L""  );
        
        dprintf("hInstance               - 0x%08X\n", lpGPExt->hInstance );

        DWORD dwDisplacement = 0;
        GetSymbol((void*)lpGPExt->pEntryPoint, (UCHAR *)sz, &dwDisplacement);
        sz[64] = 0;
        dprintf("pEntryPoint             - 0x%08X\t: %s\n", lpGPExt->pEntryPoint, sz );
        GetSymbol((void*)lpGPExt->pRsopEntryPoint, (UCHAR *)sz, &dwDisplacement);
        sz[64] = 0;
        dprintf("pRsopEntryPoint         - 0x%08X\t: %s\n", lpGPExt->pRsopEntryPoint, sz );
        
        dprintf("dwNoMachPolicy          - 0x%08X\n", lpGPExt->dwNoMachPolicy );
        dprintf("dwNoUserPolicy          - 0x%08X\n", lpGPExt->dwNoUserPolicy );
        dprintf("dwNoSlowLink            - 0x%08X\n", lpGPExt->dwNoSlowLink );
        dprintf("dwNoBackgroundPolicy    - 0x%08X\n", lpGPExt->dwNoBackgroundPolicy );
        dprintf("dwNoGPOChanges          - 0x%08X\n", lpGPExt->dwNoGPOChanges );
        dprintf("dwUserLocalSetting      - 0x%08X\n", lpGPExt->dwUserLocalSetting );
        dprintf("dwRequireRegistry       - 0x%08X\n", lpGPExt->dwRequireRegistry );
        dprintf("dwEnableAsynch          - 0x%08X\n", lpGPExt->dwEnableAsynch );
        dprintf("dwLinkTransition        - 0x%08X\n", lpGPExt->dwLinkTransition );
        dprintf("dwMaxChangesInterval    - 0x%08X\n", lpGPExt->dwMaxChangesInterval );
        
        dprintf("bRegistryExt            - %s\n", Boolean( lpGPExt->bRegistryExt ) );
        dprintf("bSkipped                - %s\n", Boolean( lpGPExt->bSkipped ) );
        dprintf("bHistoryProcessing      - %s\n", Boolean( lpGPExt->bHistoryProcessing ) );
        
//        dprintf("dwSlowLinkPrev          - 0x%08X\n", lpGPExt->dwSlowLinkPrev );

        dprintf("guid                    - " );
        PrintUuid( lpGPExt->guid );
        dprintf("\n" );

        dprintf("pNext                   - 0x%08X\n", lpGPExt->pNext );
    }
}

void container(HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(GPCONTAINER)];
    LPGPCONTAINER   lpGPCont = (LPGPCONTAINER) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(GPCONTAINER), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(GPCONTAINER) )
    {
        WCHAR sz[256];
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPCont->pwszDSPath, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszDSPath              - 0x%08X\t: \"%S\"\n", lpGPCont->pwszDSPath, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPCont->pwszGPOName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszGPONa               - 0x%08X\t: \"%S\"\n", lpGPCont->pwszGPOName, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPCont->pwszDisplayName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszDisplayName         - 0x%08X\t: \"%S\"\n", lpGPCont->pwszDisplayName, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPCont->pwszFileSysPath, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszFileSysPath         - 0x%08X\t: \"%S\"\n", lpGPCont->pwszFileSysPath, bOk ? sz : L"" );

        dprintf("bFound                  - %s\n", Boolean( lpGPCont->bFound ) );
        dprintf("bAccessDenied           - %s\n", Boolean( lpGPCont->bAccessDenied ) );
        dprintf("bUserDisabled           - %s\n", Boolean( lpGPCont->bUserDisabled ) );
        dprintf("bMachDisabled           - %s\n", Boolean( lpGPCont->bMachDisabled ) );

        dprintf("dwUserVersion           - 0x%08X\n", lpGPCont->dwUserVersion );
        dprintf("dwMachVersion           - 0x%08X\n", lpGPCont->dwMachVersion );
        dprintf("pSD                     - 0x%08X\n", lpGPCont->pSD );
        dprintf("cbSDLen                 - 0x%08X\n", lpGPCont->cbSDLen );
        dprintf("pNext                   - 0x%08X\n", lpGPCont->pNext );
    }
}

void som(   HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(SCOPEOFMGMT)];
    LPSCOPEOFMGMT   lpSOM = (LPSCOPEOFMGMT) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(SCOPEOFMGMT), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(SCOPEOFMGMT) )
    {
        WCHAR sz[128];
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpSOM->pwszSOMId, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszSOMId               - 0x%08X\t: \"%S\"\n", lpSOM->pwszSOMId, bOk ? sz : L"" );
        dprintf("dwType                  - 0x%08X\n", lpSOM->dwType );
        dprintf("bBlocking               - %s\n", Boolean( lpSOM->bBlocking ) );
        dprintf("pGpLinkList             - 0x%08X\n", lpSOM->pGpLinkList );
    }
}

void profile(   HANDLE  hCurrentProcess,
                HANDLE  hCurrentThread,
                DWORD   dwCurrentPc,
                PWINDBG_EXTENSION_APIS lpExtensionApis,
                LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(USERPROFILE)];
    LPPROFILE       lpProf = (LPPROFILE) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(USERPROFILE), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(USERPROFILE) )
    {
        WCHAR sz[128];
        
        dprintf("dwFlags                 - 0x%08X\n", lpProf->dwFlags );
        dprintf("dwInternalFlags         - 0x%08X\n", lpProf->dwInternalFlags );
        dprintf("dwUserPreference        - 0x%08X\n", lpProf->dwUserPreference );
        dprintf("hToken                  - 0x%08X\n", lpProf->hToken );
        
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpUserName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpUserName              - 0x%08X\t: \"%S\"\n", lpProf->lpUserName, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpProfilePath, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpProfilePath           - 0x%08X\t: \"%S\"\n", lpProf->lpProfilePath, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpRoamingProfile, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpRoamingProfile        - 0x%08X\t: \"%S\"\n", lpProf->lpRoamingProfile, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpDefaultProfile, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpDefaultProfile        - 0x%08X\t: \"%S\"\n", lpProf->lpDefaultProfile, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpLocalProfile, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpLocalProfile          - 0x%08X\t: \"%S\"\n", lpProf->lpLocalProfile, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpPolicyPath, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpPolicyPath            - 0x%08X\t: \"%S\"\n", lpProf->lpPolicyPath, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpServerName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpServerName            - 0x%08X\t: \"%S\"\n", lpProf->lpServerName, bOk ? sz : L"" );

        dprintf("hKeyCurrentUser         - 0x%08X\n", lpProf->hKeyCurrentUser );
        
        dprintf("ftProfileLoad           - 0x%08X:0x%08X\n", lpProf->ftProfileLoad.dwLowDateTime, lpProf->ftProfileLoad.dwHighDateTime );
        dprintf("ftProfileUnload         - 0x%08X:0x%08X\n", lpProf->ftProfileUnload.dwLowDateTime, lpProf->ftProfileUnload.dwHighDateTime );
        
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpExclusionList, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpExclusionList         - 0x%08X\t: \"%S\"\n", lpProf->lpExclusionList, bOk ? sz : L"" );
    }
}

void
debuglevel( HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();

    DWORD   dwDebugLevelPtr = 0;

    dwDebugLevelPtr = GetExpression( "userenv!dwDebugLevel" );

    if ( dwDebugLevelPtr )
    {
        unsigned char   buffer[sizeof(DWORD)];
        LPDWORD         lpdw = (LPDWORD) buffer;
        DWORD           dwBytesRead = 0;
        
        BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwDebugLevelPtr, buffer, sizeof(DWORD), &dwBytesRead );

        if ( bOk && dwBytesRead == sizeof(DWORD) )
        {
            dprintf("0x%08X\n", *lpdw );
        }

        /*
        if ( lpArgumentString && isxdigit( *lpArgumentString ) )
        {
            DWORD dwValue = GetExpression(lpArgumentString);
            dprintf("%x, Writing 0x%X at 0x%X\n", ExtensionApis.lpWriteProcessMemoryRoutine, dwValue, dwDebugLevelPtr );
            WriteMemoryExt( hCurrentProcess, (void*) dwDebugLevelPtr, (void*) dwValue, sizeof( DWORD ), 0 );
        }
        */
    }
    else
    {
        dprintf("Could not resolve symbol dwDebugLevel in module userenv!\n" );
    }
}

void
globals(    HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
}

void sizes( HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    PRINT_SIZE(GPEXT);
    PRINT_SIZE(GPLINK);
    PRINT_SIZE(SCOPEOFMGMT);
    PRINT_SIZE(GPCONTAINER);
    PRINT_SIZE(GPOINFO);
    PRINT_SIZE(USERPROFILE);
}


void dmpregtable(   HANDLE  hCurrentProcess,
                    HANDLE  hCurrentThread,
                    DWORD   dwCurrentPc,
                    PWINDBG_EXTENSION_APIS lpExtensionApis,
                    LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(REGHASHTABLE)];
    LPREGHASHTABLE  pHashTable = (LPREGHASHTABLE) buffer;
    DWORD           dwBytesRead = 0;
    int             i;
    BOOL            bError=FALSE;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(REGHASHTABLE), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(REGHASHTABLE) )
    {
        WCHAR sz[128];

        dprintf("Dumping Registry HashTable at Location 0x%08X\n", dwAddr );
        for ( i=0; i<HASH_TABLE_SIZE; i++ ) {
            
            REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
            REGKEYENTRY  KeyEntry;

            if (pKeyEntry) 
                dprintf("Hash Bucket 0x%X\n", i);
            
            while ( pKeyEntry ) {

                bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pKeyEntry, &KeyEntry, sizeof(REGKEYENTRY), &dwBytesRead );
                if (!bOk || dwBytesRead != sizeof(REGKEYENTRY) ) {
                    dprintf("    !!Couldn't read keyEntry at 0x%08X. quitting..\n", pKeyEntry);
                    bError = TRUE;
                    break;
                }
                dprintf("    KeyEntry at 0x%08X\n", pKeyEntry);
                
                pKeyEntry = &KeyEntry;
                bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pKeyEntry->pwszKeyName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                sz[127] = 0;
                dprintf("    pwszKeyName              - 0x%08X\t: \"%S\"\n", pKeyEntry->pwszKeyName, pKeyEntry->pwszKeyName?sz:L"<NULL>");


                REGVALUEENTRY *pValueList=pKeyEntry->pValueList;
                REGVALUEENTRY ValueList;
                
                while ( pValueList ) {
                    bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pValueList, &ValueList, sizeof(REGVALUEENTRY), &dwBytesRead );
                    if (!bOk || dwBytesRead != sizeof(REGVALUEENTRY) ) {
                        dprintf("        !!Couldn't read ValueEntry at 0x%08X. quitting..\n", pValueList);
                        bError = TRUE;
                        break;
                    }
                    dprintf("        ValueEntry at 0x%08X\n", pValueList);

                    pValueList = &ValueList;
                    bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pValueList->pwszValueName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                    sz[127] = 0;
                    dprintf("        pwszValueName              - 0x%08X\t: \"%S\"\n", pValueList->pwszValueName, pValueList->pwszValueName?sz:L"<NULL>");


                    REGDATAENTRY *pDataList = pValueList->pDataList;
                    REGDATAENTRY DataList;

                    while ( pDataList ) {
                        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pDataList, &DataList, sizeof(REGDATAENTRY), &dwBytesRead );
                        if (!bOk || dwBytesRead != sizeof(REGDATAENTRY) ) {
                            dprintf("            !!Couldn't read DataEntry at 0x%08X. quitting..\n", pDataList);
                            bError = TRUE;
                            break;
                        }
                        dprintf("            **DataEntry** at 0x%08X\n", pDataList);

                        pDataList = &DataList;

                        
                        dprintf("            bDeleted              - %s\n", pDataList->bDeleted?"TRUE":"FALSE");
                        dprintf("            bAdmPolicy            - %s\n", pDataList->bAdmPolicy?"TRUE":"FALSE");
                        dprintf("            dwValueType           - 0x%X\n", pDataList->dwValueType);
                        dprintf("            dwDataLen             - 0x%X\n", pDataList->dwDataLen);
                        dprintf("            pData                 - 0x%08X\n", pDataList->pData);

                        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pDataList->pwszGPO, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                        sz[127] = 0;
                        dprintf("            pwszGPO               - 0x%08X\t: \"%S\"\n", pDataList->pwszGPO, pDataList->pwszGPO?sz:L"<NULL>");
                        
                        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pDataList->pwszSOM, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                        sz[127] = 0;
                        dprintf("            pwszSOM               - 0x%08X\t: \"%S\"\n", pDataList->pwszSOM, pDataList->pwszSOM?sz:L"<NULL>");

                        
                        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pDataList->pwszCommand, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                        sz[127] = 0;
                        dprintf("            pwszCommand           - 0x%08X\t: \"%S\"\n", pDataList->pwszCommand, pDataList->pwszCommand?sz:L"<NULL>");

                        if (bError)
                            break;
                            
                        pDataList = pDataList->pNext;
                        
                    } // While pDataList

                    if (bError)
                        break;
                        
                    pValueList = pValueList->pNext;
                } // While pValue
                
                if (bError)
                    break;
                    
                pKeyEntry = pKeyEntry->pNext;
                dprintf("\n");

            }   // while pKey
            
            if (bError)
                break;            
        }            

    }   // for

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\uenv.h ===
//*************************************************************
//
//  Main header file for UserEnv project
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <ole2.h>
#include <lm.h>
#include <lmdfs.h>
#include <ntregapi.h>
#define SECURITY_WIN32
#include <security.h>
#include <shlobj.h>

//
// Turn off shell debugging stuff so that it does not conflict
// with our debugging stuff.
//

#define DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include "wbemcli.h"
#include <userenv.h>
#include <userenvp.h>
#include <ntdsapi.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <dsrole.h>
#include <accctrl.h>
#include <ntldap.h>
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <iphlpapi.h>
#include <icmpapi.h>
#include <dfsfsctl.h>
#include <winuserp.h>
#include "globals.h"

#if defined(__cplusplus)
extern "C"{
#endif
#include "debug.h"
#include "dllload.h"
#include "util.h"
#include "sid.h"
#if defined(__cplusplus)
}
#endif

#include "profile.h"
#include "events.h"
#include "copydir.h"
#include "resource.h"
#include "userdiff.h"
#include "policy.h"
#include "gpt.h"
#if defined(__cplusplus)
extern "C"{
#endif

#include "gpnotif.h"

#if defined(__cplusplus)
}
#endif

#include "winbasep.h"

//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\testshim\testshim.h ===
//
// function prototypes for the gina interface
//

typedef BOOL (WINAPI *PGWLXNEGOTIATE)( DWORD, DWORD* );
typedef BOOL (WINAPI *PGWLXINITIALIZE)( LPWSTR, HANDLE, PVOID, PVOID, PVOID* );
typedef VOID (WINAPI *PGWLXDISPLAYSASNOTICE)( PVOID );
typedef int  (WINAPI *PGWLXLOGGEDOUTSAS)( PVOID, DWORD, PLUID, PSID, PDWORD,
                                        PHANDLE, PWLX_MPR_NOTIFY_INFO, PVOID *);
typedef BOOL (WINAPI *PGWLXACTIVATEUSERSHELL)(  PVOID, PWSTR, PWSTR, PVOID );
typedef int  (WINAPI *PGWLXLOGGEDONSAS)( PVOID, DWORD, PVOID );
typedef VOID (WINAPI *PGWLXDISPLAYLOCKEDNOTICE)( PVOID );
typedef int  (WINAPI *PGWLXWKSTALOCKEDSAS)( PVOID, DWORD );
typedef BOOL (WINAPI *PGWLXISLOCKOK)( PVOID );
typedef BOOL (WINAPI *PGWLXISLOGOFFOK)( PVOID );
typedef VOID (WINAPI *PGWLXLOGOFF)( PVOID );
typedef VOID (WINAPI *PGWLXSHUTDOWN)( PVOID, DWORD );

//
// NEW for version 1.1
//
typedef BOOL (WINAPI *PGWLXSCREENSAVERNOTIFY)( PVOID, BOOL * );
typedef BOOL (WINAPI *PGWLXSTARTAPPLICATION)( PVOID, PWSTR, PVOID, PWSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\main\globals.c ===
//*************************************************************
//
//  Global Variables
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include <winfoldr.h>


HINSTANCE        g_hDllInstance;
DWORD            g_dwBuildNumber;
NTPRODUCTTYPE    g_ProductType;
HANDLE           g_hProfileSetup = NULL;
DWORD            g_dwNumShellFolders;
DWORD            g_dwNumCommonShellFolders;


HANDLE           g_hPolicyCritMutexMach = NULL;
HANDLE           g_hPolicyCritMutexUser = NULL;

HANDLE           g_hPolicyNotifyEventMach = NULL;
HANDLE           g_hPolicyNotifyEventUser = NULL;

HANDLE           g_hPolicyNeedFGEventMach = NULL;
HANDLE           g_hPolicyNeedFGEventUser = NULL;

HANDLE           g_hPolicyDoneEventMach = NULL;
HANDLE           g_hPolicyDoneEventUser = NULL;

HANDLE           g_hPolicyForegroundDoneEventMach = 0;
HANDLE           g_hPolicyForegroundDoneEventUser = 0;

const TCHAR c_szStarDotStar[] = TEXT("*.*");
const TCHAR c_szSlash[] = TEXT("\\");
const TCHAR c_szDot[] = TEXT(".");
const TCHAR c_szDotDot[] = TEXT("..");
const TCHAR c_szMAN[] = TEXT(".man");
const TCHAR c_szUSR[] = TEXT(".usr");
const TCHAR c_szLog[] = TEXT(".log");
const TCHAR c_szPDS[] = TEXT(".pds");
const TCHAR c_szPDM[] = TEXT(".pdm");
const TCHAR c_szLNK[] = TEXT(".lnk");
const TCHAR c_szBAK[] = TEXT(".bak");
const TCHAR c_szNTUserTmp[] = TEXT("ntuser.tmp");
const TCHAR c_szNTUserMan[] = TEXT("ntuser.man");
const TCHAR c_szNTUserDat[] = TEXT("ntuser.dat");
const TCHAR c_szNTUserIni[] = TEXT("ntuser.ini");
const TCHAR c_szRegistryPol[] = TEXT("registry.pol");
const TCHAR c_szNTUserStar[] = TEXT("ntuser.*");
const TCHAR c_szUserStar[] = TEXT("user.*");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szDotPif[] = TEXT(".pif");
const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szCommonGroupsLocation[] = TEXT("Software\\Program Groups");
TCHAR c_szRegistryExtName[64];

//
// Registry Extension guid
//

GUID guidRegistryExt = REGISTRY_EXTENSION_GUID;

//
// Special folders
//

FOLDER_INFO c_ShellFolders[] =
{
//Hidden   Local    Add    New    Within    Folder                 Folder                    Folder    Folder                Folder
// Dir?     Dir    CSIDl?  NT5?   Local     Resource ID            Name                      Location  Resource              Resource
//                                Settings                                                             DLL                   ID

  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_APPDATA,       TEXT("AppData"),           {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_APP_DATA}, // AppData
  {TRUE,   FALSE,  TRUE,  TRUE,   FALSE,    IDS_SH_COOKIES,       TEXT("Cookies"),           {0},      TEXT("shell32.dll"),  0}, // Cookies
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_DESKTOP,       TEXT("Desktop"),           {0},      TEXT("shell32.dll"),  0}, // Desktop
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_FAVORITES,     TEXT("Favorites"),         {0},      TEXT("shell32.dll"),  0}, // Favorites
  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_NETHOOD,       TEXT("NetHood"),           {0},      TEXT("shell32.dll"),  0}, // NetHood
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_PERSONAL,      TEXT("Personal"),          {0},      TEXT("shell32.dll"),  0}, // My Documents
  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_PRINTHOOD,     TEXT("PrintHood"),         {0},      TEXT("shell32.dll"),  0}, // PrintHood
  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_RECENT,        TEXT("Recent"),            {0},      TEXT("shell32.dll"),  0}, // Recent
  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_SENDTO,        TEXT("SendTo"),            {0},      TEXT("shell32.dll"),  0}, // SendTo
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_STARTMENU,     TEXT("Start Menu"),        {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_START_MENU}, // Start Menu
  {TRUE,   FALSE,  TRUE,  TRUE,   FALSE,    IDS_SH_TEMPLATES,     TEXT("Templates"),         {0},      TEXT("shell32.dll"),  0}, // Templates
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_PROGRAMS,      TEXT("Programs"),          {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_PROGRAMS}, // Programs
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_STARTUP,       TEXT("Startup"),           {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_STARTUP}, // Startup

  {TRUE,   TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_LOCALSETTINGS, TEXT("Local Settings"),    {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_LOCALSETTINGS}, // Local Settings
  {TRUE,   TRUE,   TRUE,  TRUE,   TRUE,     IDS_SH_LOCALAPPDATA,  TEXT("Local AppData"),     {0},      TEXT("shell32.dll"),  0}, // Local AppData
  {TRUE,   TRUE,   TRUE,  TRUE,   TRUE,     IDS_SH_CACHE,         TEXT("Cache"),             {0},      TEXT("shell32.dll"),  0}, // Temporary Internet Files
  {TRUE,   TRUE,   TRUE,  TRUE,   TRUE,     IDS_SH_HISTORY,       TEXT("History"),           {0},      TEXT("shell32.dll"),  0}, // History
  {FALSE,  TRUE,   FALSE, TRUE,   TRUE,     IDS_SH_TEMP,          TEXT("Temp"),              {0},      TEXT("shell32.dll"),  0}, // Temp
};


FOLDER_INFO c_CommonShellFolders[] =
{
  {FALSE,  TRUE,   TRUE,  FALSE,  FALSE,    IDS_SH_DESKTOP,       TEXT("Common Desktop"),    {0},      TEXT("shell32.dll"),  0}, // Common Desktop
  {FALSE,  TRUE,   TRUE,  FALSE,  FALSE,    IDS_SH_STARTMENU,     TEXT("Common Start Menu"), {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_START_MENU}, // Common Start Menu
  {FALSE,  TRUE,   TRUE,  FALSE,  FALSE,    IDS_SH_PROGRAMS,      TEXT("Common Programs"),   {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_PROGRAMS}, // Common Programs
  {FALSE,  TRUE,   TRUE,  FALSE,  FALSE,    IDS_SH_STARTUP,       TEXT("Common Startup"),    {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_STARTUP}, // Common Startup
  {TRUE,   TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_APPDATA,       TEXT("Common AppData"),    {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_APP_DATA}, // Common Application Data
  {TRUE,   TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_TEMPLATES,     TEXT("Common Templates"),  {0},      TEXT("shell32.dll"),  0}, // Common Templates
  {FALSE,  TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_FAVORITES,     TEXT("Common Favorites"),  {0},      TEXT("shell32.dll"),  0}, // Common Favorites
  {FALSE,  TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_SHAREDDOCS,    TEXT("Common Documents"),  {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_SHARED_DOC}, // Common Documents
};


//
// Function proto-types
//

void InitializeProductType (void);
BOOL DetermineLocalSettingsLocation(LPTSTR szLocalSettings);


//*************************************************************
//
//  PatchLocalSettings()
//
//  Purpose:    Initializes the LocalSettingsFolder correctly
//
//  Parameters: hInstance   -   DLL instance handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/13/95    ushaji     Created
//
//
// Comments:
//      Should remove this post NT5 and restructure to take care of the
// NT4 Localisation Problems
//
//*************************************************************

void PatchLocalAppData(HANDLE hToken)
{
    TCHAR szLocalSettingsPath[MAX_PATH];
    TCHAR szLocalAppData[MAX_PATH];
    LPTSTR lpEnd = NULL, lpLocalAppDataFolder;
    HANDLE hTokenOld=NULL;
    HKEY hKeyRoot, hKey;
    DWORD dwIndex;


    if (!ImpersonateUser (hToken, &hTokenOld))
        return;


    if (RegOpenCurrentUser(KEY_READ, &hKeyRoot) == ERROR_SUCCESS) {

        if (RegOpenKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            if (RegQueryValueEx (hKey, TEXT("Local AppData"), NULL, NULL,
                                 NULL, NULL) == ERROR_SUCCESS) {

                RegCloseKey(hKey);
                RegCloseKey(hKeyRoot);
                RevertToUser(&hTokenOld);
                return;
            }

            RegCloseKey(hKey);
        }

        RegCloseKey(hKeyRoot);
    }


    //
    // Impersonate and determine the user's localsettings
    //

    DetermineLocalSettingsLocation(szLocalSettingsPath);

    RevertToUser(&hTokenOld);

    lstrcpy(szLocalAppData, TEXT("%userprofile%"));


    //
    // Set the Local AppData Folder after %userprofile% so that we
    // we can update the global variable below.
    //

    lpEnd = lpLocalAppDataFolder = CheckSlash(szLocalAppData);

    lstrcat(szLocalAppData, szLocalSettingsPath);

    lpEnd = CheckSlash(szLocalAppData);

    LoadString(g_hDllInstance, IDS_SH_LOCALAPPDATA, lpEnd, MAX_FOLDER_SIZE);


    //
    // Construct the path and let it be set.
    //

    SetFolderPath(CSIDL_LOCAL_APPDATA | CSIDL_FLAG_DONT_UNEXPAND, hToken, szLocalAppData);


    //
    // the global variable should be reset by the time it gets used.
    // No Need to reset it here, but let us be safer.
    //


    for (dwIndex = 0; dwIndex < g_dwNumShellFolders; dwIndex++)
        if (c_ShellFolders[dwIndex].iFolderID == IDS_SH_LOCALAPPDATA)
            lstrcpy(c_ShellFolders[dwIndex].szFolderLocation, lpLocalAppDataFolder);

}


//*************************************************************
//
//  InitializeGlobals()
//
//  Purpose:    Initializes all the globals variables
//              at DLL load time.
//
//  Parameters: hInstance   -   DLL instance handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/13/95    ericflo    Created
//
//*************************************************************

void InitializeGlobals (HINSTANCE hInstance)
{
    OSVERSIONINFO ver;
    DWORD dwIndex, dwSize, dwType;
    HKEY hKey, hKeyRoot;
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    TCHAR szTemp3[MAX_PATH];
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    LPTSTR lpEnd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  pSidAdmin = NULL, pSidSystem = NULL;
    DWORD cbAcl;
    BOOL  bDefaultSecurity = FALSE;

    //
    // Save the instance handle
    //

    g_hDllInstance = hInstance;


    //
    // Save the number of shell folders
    //

    g_dwNumShellFolders = ARRAYSIZE(c_ShellFolders);
    g_dwNumCommonShellFolders = ARRAYSIZE(c_CommonShellFolders);


    //
    // Query the build number
    //

    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    g_dwBuildNumber = (DWORD) LOWORD(ver.dwBuildNumber);


    //
    // Initialize the product type
    //

    InitializeProductType ();


    //
    // Open the user profile setup event.  This event is set to non-signalled
    // anytime the default user profile is being updated.  This blocks
    // LoadUserProfile until the update is finished.
    //

    if (!g_hProfileSetup) {

        //
        // Get the system sid
        //

        if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                      0, 0, 0, 0, 0, 0, 0, &pSidSystem)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to initialize system sid.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }

        //
        // Get the Admin sid
        //

        if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                      DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                      0, 0, 0, 0, &pSidAdmin)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to initialize admin sid.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }

        cbAcl = (GetLengthSid (pSidSystem)) +
                (GetLengthSid (pSidAdmin))  +
                sizeof(ACL) +
                (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
 
 
        pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
        if (!pAcl) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }
 
        if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to initialize acl.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }
 
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, pSidSystem)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to add system ace.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, pSidAdmin)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }

        //
        // Put together the security descriptor
        //

        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

        SetSecurityDescriptorDacl (
                        &sd,
                        TRUE,                           // Dacl present
                        pAcl,                           // Dacl
                        FALSE                           // Not defaulted
                        );

DefaultSecurity:

        sa.nLength = sizeof(sa);
        sa.bInheritHandle = FALSE;
        if (bDefaultSecurity) {
            sa.lpSecurityDescriptor = NULL;
        }
        else {
            sa.lpSecurityDescriptor = &sd;
        }

        g_hProfileSetup = CreateEvent (&sa, TRUE, TRUE, USER_PROFILE_SETUP_EVENT);

        if (!g_hProfileSetup) {
            DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: Failed to create profile setup event with %d"), GetLastError()));
        }

        if (pAcl) {
            GlobalFree (pAcl);
        }        

        if (pSidSystem) {
            FreeSid(pSidSystem);
        }

        if (pSidAdmin) {
            FreeSid(pSidAdmin);
        }    
    }


    //
    // Now load the directory names that match
    // the special folders
    //

    for (dwIndex = 0; dwIndex < g_dwNumShellFolders; dwIndex++) {
        LoadString(hInstance, c_ShellFolders[dwIndex].iFolderID,
                   c_ShellFolders[dwIndex].szFolderLocation, MAX_FOLDER_SIZE);
    }

    for (dwIndex = 0; dwIndex < g_dwNumCommonShellFolders; dwIndex++) {
        LoadString(hInstance, c_CommonShellFolders[dwIndex].iFolderID,
                   c_CommonShellFolders[dwIndex].szFolderLocation, MAX_FOLDER_SIZE);
    }


    //
    // Special case for the Personal / My Documents folder.  NT4 used a folder
    // called "Personal" for document storage.  NT5 renamed this folder to
    // My Documents.  In the upgrade case from NT4 to NT5, if the user already
    // had information in "Personal", that name was preserved (for compatibility
    // reasons) and the My Pictures folder is created inside of Personal.
    // We need to make sure and fix up the My Documents and My Pictures entries
    // in the global array so they have the correct directory names.
    //


    if (RegOpenCurrentUser(KEY_READ, &hKeyRoot) == ERROR_SUCCESS) {

        if (RegOpenKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(szTemp3);
            szTemp3[0] = TEXT('\0');
            if (RegQueryValueEx (hKey, TEXT("Personal"), NULL, &dwType,
                                 (LPBYTE) szTemp3, &dwSize) == ERROR_SUCCESS) {

                LoadString (g_hDllInstance, IDS_SH_PERSONAL2, szTemp2, ARRAYSIZE(szTemp2));
                lstrcpy (szTemp, TEXT("%USERPROFILE%\\"));
                lstrcat (szTemp, szTemp2);

                if (lstrcmpi(szTemp, szTemp3) == 0) {
                    LoadString(hInstance, IDS_SH_PERSONAL2,
                               c_ShellFolders[5].szFolderLocation, MAX_FOLDER_SIZE);
                }
            }


            //
            // Special Case for Local Settings.
            // Due to localisations LocalSettings can be pointing to different places in nt4 and rc might
            // not be in sync with the current value. Read the LocalSettings value first and then
            // update everything else afterwards.
            //

            dwSize = sizeof(szTemp2);
            *szTemp = *szTemp2 = TEXT('\0');


            //
            // Read the value from the registry if it is available
            //

            if (RegQueryValueEx (hKey, TEXT("Local Settings"), NULL, &dwType,
                                 (LPBYTE) szTemp2, &dwSize) != ERROR_SUCCESS) {

                //
                // if the value is not present load it from the rc file
                //

                LoadString(hInstance, IDS_SH_LOCALSETTINGS, szTemp, MAX_FOLDER_SIZE);
                DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: local settings folder from the rc is %s"), szTemp));
            }
            else {

                //
                // The registry value read from the registry is the full unexpanded path.
                //


                if (lstrlen(szTemp2) > lstrlen(TEXT("%userprofile%"))) {

                    lstrcpy(szTemp, szTemp2+(lstrlen(TEXT("%userprofile%"))+1));

                    DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: local settings folder from the reigtry is %s"), szTemp));
                }
                else {
                    LoadString(hInstance, IDS_SH_LOCALSETTINGS, szTemp, MAX_FOLDER_SIZE);
                    DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: local settings folder(2) from the rc is %s"), szTemp));
                }
            }


            lpEnd = CheckSlash(szTemp);

            for (dwIndex = 0; dwIndex < g_dwNumShellFolders; dwIndex++) {


                //
                // Fix up all LocalSettings related shfolders
                //


                if (lstrcmpi(c_ShellFolders[dwIndex].lpFolderName, TEXT("Local Settings")) == 0) {
                    *lpEnd = TEXT('\0');

                    //
                    // Don't copy the final slash
                    //

                    lstrcpyn(c_ShellFolders[dwIndex].szFolderLocation, szTemp, lstrlen(szTemp));
                }


                if (c_ShellFolders[dwIndex].bLocalSettings) {
                    LoadString(hInstance, c_ShellFolders[dwIndex].iFolderID,
                               szTemp3, MAX_FOLDER_SIZE);

                    //
                    // Append localsetting value read above to the end of %userprofile%
                    // before putting on the shell folder itself
                    //

                    lstrcpy(lpEnd, szTemp3);
                    lstrcpy(c_ShellFolders[dwIndex].szFolderLocation, szTemp);

                    DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: Shell folder %s is  %s"), c_ShellFolders[dwIndex].lpFolderName,
                                                                                             c_ShellFolders[dwIndex].szFolderLocation));

                }
            }


            RegCloseKey (hKey);
        }

        RegCloseKey (hKeyRoot);
    }


    //
    // Get string version of registry extension guid
    //

    GuidToString( &guidRegistryExt, c_szRegistryExtName );
}

//*************************************************************
//
//  InitializeProductType()
//
//  Purpose:    Determines the current product type and
//              sets the g_ProductType global variable.
//
//  Parameters: void
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              4/08/96     ericflo    Created
//
//*************************************************************

void InitializeProductType (void)
{

#ifdef WINNT

    HKEY hkey;
    LONG lResult;
    TCHAR szProductType[50];
    DWORD dwType, dwSize;


    //
    // Default product type is workstation.
    //

    g_ProductType = PT_WORKSTATION;


    //
    // Query the registry for the product type.
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                            0,
                            KEY_READ,
                            &hkey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("InitializeProductType: Failed to open registry (%d)"), lResult));
        goto Exit;
    }


    dwSize = 50;
    szProductType[0] = TEXT('\0');

    lResult = RegQueryValueEx (hkey,
                               TEXT("ProductType"),
                               NULL,
                               &dwType,
                               (LPBYTE) szProductType,
                               &dwSize);

    RegCloseKey (hkey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("InitializeProductType: Failed to query product type (%d)"), lResult));
        goto Exit;
    }


    //
    // Map the product type string to the enumeration value.
    //

    if (!lstrcmpi (szProductType, TEXT("WinNT"))) {
        g_ProductType = PT_WORKSTATION;

    } else if (!lstrcmpi (szProductType, TEXT("ServerNT"))) {
        g_ProductType = PT_SERVER;

    } else if (!lstrcmpi (szProductType, TEXT("LanmanNT"))) {
        g_ProductType = PT_DC;

    } else {
        DebugMsg((DM_WARNING, TEXT("InitializeProductType: Unknown product type! <%s>"), szProductType));
    }



Exit:
    DebugMsg((DM_VERBOSE, TEXT("InitializeProductType: Product Type: %d"), g_ProductType));


#else   // WINNT

    //
    // Windows only has 1 product type
    //

    g_ProductType = PT_WINDOWS;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\main\resource.h ===
//*************************************************************
//
//  Resource.h      -   Header file for userenv.rc
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uevents.h"

// Error codes that were used by profile and
// policy event logging (rc strings) have been removed
//
// Don't reuse the codes 0 - 28 because it might confuse localisers
//

#define IDS_COMMON                    15
#define IDS_PROFILES_ROOT             25

#define IDS_SH_APPDATA                30
#define IDS_SH_DESKTOP                31
#define IDS_SH_FAVORITES              32
#define IDS_SH_NETHOOD                33
#define IDS_SH_PRINTHOOD              34
#define IDS_SH_RECENT                 35
#define IDS_SH_SENDTO                 36
#define IDS_SH_STARTMENU              37
#define IDS_SH_TEMPLATES              38
#define IDS_SH_PERSONAL               39
#define IDS_SH_PROGRAMS               40
#define IDS_SH_STARTUP                41
#define IDS_SH_TEMP                   42
#define IDS_SH_LOCALSETTINGS          43
#define IDS_SH_LOCALAPPDATA           44
#define IDS_SH_CACHE                  45
#define IDS_SH_COOKIES                46
#define IDS_SH_HISTORY                47
#define IDS_SH_MYPICTURES             48
#define IDS_SH_SHAREDDOCS             49

#define IDS_SH_PERSONAL2              70
#define IDS_SH_MYPICTURES2            71
#define IDS_SH_TEMPLATES2             72

#define IDS_PROFILE_FORMAT            75
#define IDS_PROFILEDOMAINNAME_FORMAT  76

#define IDS_NT_AUTHORITY              80
#define IDS_BUILTIN                   81

#define IDS_COPYING                  100
#define IDS_CREATING                 101

#define IDS_LOCALGPONAME             103
#define IDS_TEMPINTERNETFILES        104
#define IDS_HISTORY                  105
#define IDS_EXCLUSIONLIST            106
#define IDS_REGISTRYNAME             107
#define IDS_CALLEXTENSION            108
#define IDS_USER_SETTINGS            109
#define IDS_COMPUTER_SETTINGS        110
#define IDS_GPCORE_NAME              111

//
// Profile icon
//

#define IDI_PROFILE                  1


//
// Slow link test data
//

#define IDB_SLOWLINK                 1


//
// Slow link dialog
//

#define IDD_LOGIN_SLOW_LINK       1000
#define IDC_DOWNLOAD              1001
#define IDC_LOCAL                 1002
#define IDC_TIMEOUT               1004
#define IDC_TIMETITLE             1005
#define IDD_LOGOFF_SLOW_LINK      1006
#define IDC_UPLOAD                1007
#define IDC_NOUPLOAD              1008

//
// Error dialog
//

#define IDD_ERROR                 3000
#define IDC_ERRORTEXT             3001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\main\import.h ===
/********************************************************************/
/**               Copyright(c) 1991 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	import.h
//
// Description: This file allows us to include standard system header files 
//		in the .idl file.  The main .idl file imports a file called 
//		import.idl. This allows the .idl file to use the types defined 
//		in these header files. It also causes the following line to 
//		be added in the MIDL generated header file:
//
//    		#include "import.h"
//
//   		Thus these types are available to the RPC stub routines as well.
//
//


#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#define HANDLE      DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gpfilter.cpp ===
//*************************************************************
//
//  Group Policy filtering Support
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"

extern "C" DWORD WINAPI PingComputerEx( ULONG ipaddr, ULONG *ulSpeed, DWORD* pdwAdapterIndex );

//*************************************************************
//
//  SetupGPOFilter()
//
//  Purpose:    Setup up GPO Filter info
//
//  Parameters: lpGPOInfo   - GPO info
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SetupGPOFilter( LPGPOINFO lpGPOInfo )
{
    //
    // Format is [{ext guid1}{snapin guid1}..{snapin guidn}][{ext guid2}...]...\0
    // Both extension and snapin guids are in ascending order.
    //
    // Note: If the format is corrupt then take the conservative
    //       position and assume that it means that all
    //       extensions need to be applied to the GPO.
    //

    LPEXTFILTERLIST pExtFilterListTail = 0;
    PGROUP_POLICY_OBJECT lpGPO = 0;
    LPEXTFILTERLIST pExtFilterElem = NULL;

    lpGPOInfo->bXferToExtList = FALSE;

    lpGPO = lpGPOInfo->lpGPOList;
    while ( lpGPO ) {

        TCHAR *pchCur = lpGPO->lpExtensions;
        LPEXTLIST pExtListHead = 0;
        LPEXTLIST pExtListTail = 0;

        if ( pchCur ) {

            while ( *pchCur ) {

                GUID guidExt;
                LPEXTLIST pExtElem;

                if ( *pchCur == TEXT('[') )
                    pchCur++;
                else {

                    DebugMsg((DM_WARNING, TEXT("SetupGPOFilter: Corrupt extension name format.")));
                    FreeExtList( pExtListHead );
                    pExtListHead = 0;
                    break;

                }

                if ( ValidateGuid( pchCur ) )
                    StringToGuid( pchCur, &guidExt );
                else {

                    DebugMsg((DM_WARNING, TEXT("SetupGPOFilter: Corrupt extension name format.")));
                    FreeExtList( pExtListHead );
                    pExtListHead = 0;
                    break;

                }

                pExtElem = ( LPEXTLIST ) LocalAlloc( LPTR, sizeof(EXTLIST) );
                if ( pExtElem == 0 ) {

                    DebugMsg((DM_WARNING, TEXT("SetupGPOFilter: Unable to allocate memory.")));
                    FreeExtList( pExtListHead );
                    SetLastError(ERROR_OUTOFMEMORY);
                    return FALSE;

                }

                pExtElem->guid = guidExt;
                pExtElem->pNext = 0;

                if ( pExtListTail )
                    pExtListTail->pNext = pExtElem;
                else
                    pExtListHead = pExtElem;

                pExtListTail = pExtElem;

                while ( *pchCur && *pchCur != TEXT('[') )
                    pchCur++;

            } // while *pchcur

        } // if pchcur

        //
        // Append to lpExtFilterList
        //

        pExtFilterElem = (LPEXTFILTERLIST)LocalAlloc( LPTR, sizeof(EXTFILTERLIST) );
        if ( pExtFilterElem == NULL ) {

             DebugMsg((DM_WARNING, TEXT("SetupGPOFilter: Unable to allocate memory.")));
             FreeExtList( pExtListHead );
             SetLastError(ERROR_OUTOFMEMORY);
             return FALSE;
        }

        pExtFilterElem->lpExtList = pExtListHead;
        pExtFilterElem->lpGPO = lpGPO;
        pExtFilterElem->pNext = NULL;

        if ( pExtFilterListTail == 0 )
            lpGPOInfo->lpExtFilterList = pExtFilterElem;
        else
            pExtFilterListTail->pNext = pExtFilterElem;

        pExtFilterListTail = pExtFilterElem;

        //
        // Advance to next GPO
        //

        lpGPO = lpGPO->pNext;

    } // while lpgpo

    //
    // Transfer ownership from lpGPOList to lpExtFilterList
    //

    lpGPOInfo->bXferToExtList = TRUE;

    return TRUE;
}



//*************************************************************
//
//  FilterGPOs()
//
//  Purpose:    Filter GPOs not relevant to this extension
//
//  Parameters: lpExt        -  Extension
//              lpGPOInfo    -  GPO info
//
//*************************************************************

void FilterGPOs( LPGPEXT lpExt, LPGPOINFO lpGPOInfo )
{


    //
    // lpGPOInfo->lpGPOList will have the filtered list of GPOs
    //

    PGROUP_POLICY_OBJECT pGPOTail = 0;
    LPEXTFILTERLIST pExtFilterList = lpGPOInfo->lpExtFilterList;

    lpGPOInfo->lpGPOList = 0;

    while ( pExtFilterList ) {

        BOOL bFound = FALSE;
        LPEXTLIST pExtList = pExtFilterList->lpExtList;

        if ( pExtList == NULL ) {

            //
            // A null pExtlist means no extensions apply to this GPO
            //

            bFound = FALSE;

        } else {

            while (pExtList) {

                INT iComp = CompareGuid( &lpExt->guid, &pExtList->guid );

                if ( iComp == 0 ) {
                    bFound = TRUE;
                    break;
                } else if ( iComp < 0 ) {
                    //
                    // Guids in pExtList are in ascending order, so we are done
                    //
                    break;
                } else
                    pExtList = pExtList->pNext;

            } // while pextlist

        } // else

        if ( bFound ) {

            //
            // Append pExtFilterList->lpGPO to the filtered GPO list
            //

            pExtFilterList->lpGPO->pNext = 0;
            pExtFilterList->lpGPO->pPrev = pGPOTail;

            if ( pGPOTail == 0 )
                lpGPOInfo->lpGPOList = pExtFilterList->lpGPO;
            else
                pGPOTail->pNext = pExtFilterList->lpGPO;

            pGPOTail = pExtFilterList->lpGPO;

        }  // bFound

        pExtFilterList = pExtFilterList->pNext;

    }  // while pextfilterlist
}



//*************************************************************
//
//  CheckForGPOsToRemove()
//
//  Purpose:    Compares the GPOs in list1 with list 2 to determine
//              if any GPOs need to be removed.
//
//  Parameters: lpGPOList1  -   GPO link list 1
//              lpGPOList2  -   GPO link list 2
//
//  Return:     TRUE if one or more GPOs need to be removed
//              FALSE if not
//
//*************************************************************

BOOL CheckForGPOsToRemove (PGROUP_POLICY_OBJECT lpGPOList1, PGROUP_POLICY_OBJECT lpGPOList2)
{
    PGROUP_POLICY_OBJECT lpGPOSrc, lpGPODest;
    BOOL bFound;
    BOOL bResult = FALSE;


    //
    // First check to see if they are both NULL
    //

    if (!lpGPOList1 && !lpGPOList2) {
        return FALSE;
    }


    //
    // Go through every GPO in list 1, and see if it is still in list 2
    //

    lpGPOSrc = lpGPOList1;

    while (lpGPOSrc) {

        lpGPODest = lpGPOList2;
        bFound = FALSE;

        while (lpGPODest) {

            if (!lstrcmpi (lpGPOSrc->szGPOName, lpGPODest->szGPOName)) {
                bFound = TRUE;
                break;
            }

            lpGPODest = lpGPODest->pNext;
        }

        if (!bFound) {
            DebugMsg((DM_VERBOSE, TEXT("CheckForGPOsToRemove: GPO <%s> needs to be removed"), lpGPOSrc->lpDisplayName));
            lpGPOSrc->lParam |= GPO_LPARAM_FLAG_DELETE;
            bResult = TRUE;
        }

        lpGPOSrc = lpGPOSrc->pNext;
    }


    return bResult;
}

//*************************************************************
//
//  CompareGPOLists()
//
//  Purpose:    Compares one list of GPOs to another
//
//  Parameters: lpGPOList1  -   GPO link list 1
//              lpGPOList2  -   GPO link list 2
//
//  Return:     TRUE if the lists are the same
//              FALSE if not
//
//*************************************************************

BOOL CompareGPOLists (PGROUP_POLICY_OBJECT lpGPOList1, PGROUP_POLICY_OBJECT lpGPOList2)
{

    //
    // Check if one list is empty
    //

    if ((lpGPOList1 && !lpGPOList2) || (!lpGPOList1 && lpGPOList2)) {
        DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  One list is empty")));
        return FALSE;
    }


    //
    // Loop through the GPOs
    //

    while (lpGPOList1 && lpGPOList2) {

        //
        // Compare GPO names
        //

        if (lstrcmpi (lpGPOList1->szGPOName, lpGPOList2->szGPOName) != 0) {
            DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  Different entries found.")));
            return FALSE;
        }


        //
        // Compare the version numbers
        //

        if (lpGPOList1->dwVersion != lpGPOList2->dwVersion) {
            DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  Different version numbers found")));
            return FALSE;
        }


        //
        // Move to the next node
        //

        lpGPOList1 = lpGPOList1->pNext;
        lpGPOList2 = lpGPOList2->pNext;


        //
        // Check if one list has more entries than the other
        //

        if ((lpGPOList1 && !lpGPOList2) || (!lpGPOList1 && lpGPOList2)) {
            DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  One list has more entries than the other")));
            return FALSE;
        }
    }


    DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  The lists are the same.")));

    return TRUE;
}


//*************************************************************
//
//  CheckForSkippedExtensions()
//
//  Purpose:    Checks to the current list of extensions to see
//              if any of them have been skipped
//
//  Parameters: lpGPOInfo         -   GPOInfo
//              bRsopPlanningMode -   Is this being called during Rsop
//                                    planning mode ?
//
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL CheckForSkippedExtensions (LPGPOINFO lpGPOInfo, BOOL bRsopPlanningMode )
{
    BOOL bUsePerUserLocalSetting = FALSE;

    BOOL dwFlags = lpGPOInfo->dwFlags;

    LPGPEXT lpExt = lpGPOInfo->lpExtensions;


    while ( lpExt )
    {
        if ( bRsopPlanningMode )
        {
            //
            // In planning mode, check only for user, machine preferences and slow link
            //
            lpExt->bSkipped = lpExt->dwNoMachPolicy && dwFlags & GP_MACHINE        // mach policy
                                     || lpExt->dwNoUserPolicy && !(dwFlags & GP_MACHINE)
                                     || lpExt->dwNoSlowLink && (dwFlags & GP_SLOW_LINK);
            lpExt = lpExt->pNext;
            continue;
        }

        if ( // Check background preference. 
             lpExt->dwNoBackgroundPolicy && dwFlags & GP_BACKGROUND_THREAD ) {

            // in forced refresh don't skip the extension here but only after
            // we do a quick check to see whether extension is enabled and
            // after we set the appropriate registry key
            
            if (!(dwFlags & GP_FORCED_REFRESH)) 
                lpExt->bSkipped = TRUE;
            else {
                lpExt->bSkipped = FALSE;
                lpExt->bForcedRefreshNextFG = TRUE;
            } 
            
        } else
            lpExt->bSkipped = FALSE;


        if ( (!(lpExt->bSkipped)) && (lpExt->dwNoSlowLink && dwFlags & GP_SLOW_LINK)) {

            //
            // Slow link preference can be overridden by link transition preference
            //

            DWORD dwSlowLinkCur = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;

            if ( lpExt->dwLinkTransition && ( dwSlowLinkCur != lpExt->lpPrevStatus->dwSlowLink ) )
                lpExt->bSkipped = FALSE;
            else
                lpExt->bSkipped = TRUE;

        } else if (!(lpExt->bSkipped)) {

            //
            // If cached history is present but policy is turned off then still call
            // extension one more time so that cached policies can be passed to extension
            // to do delete processing. If there is no cached history then extension can be skipped.
            //

            BOOL bPolicySkippedPreference = lpExt->dwNoMachPolicy && dwFlags & GP_MACHINE        // mach policy
                                            || lpExt->dwNoUserPolicy && !(dwFlags & GP_MACHINE); // user policy

            if ( bPolicySkippedPreference ) {

                BOOL bHistoryPresent = HistoryPresent( lpGPOInfo, lpExt );
                if ( bHistoryPresent )
                    lpExt->bHistoryProcessing = TRUE;
                else
                    lpExt->bSkipped = TRUE;

            }

        }

        lpExt = lpExt->pNext;

    }

    return TRUE;
}

//*************************************************************
//
//  CheckGPOs()
//
//  Purpose:    Checks to the current list of GPOs with
//              the list stored in the registry to see
//              if policy needs to be flushed.
//
//  Parameters: lpExt            - GP extension
//              lpGPOInfo        - GPOInfo
//              dwTime           - Current time in minutes
//              pbProcessGPOs    - On return set TRUE if GPOs have to be processed
//              pbNoChanges      - On return set to TRUE if no changes, but extension
//                                    has asked for GPOs to be still processed
//              ppDeletedGPOList - On return set to deleted GPO list, if any
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Notes:      For extensions that have PerUserLocalSetting specified, history data is
//              stored under both hkcu and hklm\{sid-user}. For such extensions there are two
//              deleted lists. First deleted list is obtained by comparing hklm\{sid-user} data
//              with current GPO data. Second deleted list is obtained by comparing
//              hkcu data with current GPO data. The final deleted list is obtained by appending
//              one deleted list to the other after removing duplicate GPOs.
//
//*************************************************************

BOOL CheckGPOs (LPGPEXT lpExt,
                LPGPOINFO lpGPOInfo,
                DWORD dwCurrentTime,
                BOOL *pbProcessGPOs,
                BOOL *pbNoChanges,
                PGROUP_POLICY_OBJECT *ppDeletedGPOList)
{
    PGROUP_POLICY_OBJECT lpOldGPOList = NULL, lpOldGPOList2 = NULL, lpGPO, lpGPOTemp;
    BOOL bTemp, bTemp2;

    BOOL bUsePerUserLocalSetting = lpExt->dwUserLocalSetting && !(lpGPOInfo->dwFlags & GP_MACHINE);

    *pbProcessGPOs = TRUE;
    *pbNoChanges = FALSE;
    *ppDeletedGPOList = NULL;

    DmAssert( !bUsePerUserLocalSetting || lpGPOInfo->lpwszSidUser != 0 );

    //
    // Read in the old GPO list
    //

    bTemp = ReadGPOList (lpExt->lpKeyName, lpGPOInfo->hKeyRoot,
                         HKEY_LOCAL_MACHINE,
                         NULL,
                         FALSE, &lpOldGPOList);

    if (!bTemp) {
        DebugMsg((DM_WARNING, TEXT("CheckGPOs: ReadGPOList failed.")));
        CEvents ev(TRUE, EVENT_FAILED_READ_GPO_LIST); ev.Report();

        lpOldGPOList = NULL;
    }

    if ( bUsePerUserLocalSetting ) {
        bTemp2 = ReadGPOList (lpExt->lpKeyName, lpGPOInfo->hKeyRoot,
                              HKEY_LOCAL_MACHINE,
                              lpGPOInfo->lpwszSidUser,
                              FALSE, &lpOldGPOList2);
        if (!bTemp2) {
            DebugMsg((DM_WARNING, TEXT("CheckGPOs: ReadGPOList for user local settings failed.")));
            CEvents ev(TRUE, EVENT_FAILED_READ_GPO_LIST); ev.Report();

            lpOldGPOList2 = NULL;
        }
    }


    //
    // Compare with the new GPO list to determine if any GPOs have been
    // removed.
    //

    bTemp = CheckForGPOsToRemove (lpOldGPOList, lpGPOInfo->lpGPOList);

    if ( bUsePerUserLocalSetting ) {
        bTemp2 = CheckForGPOsToRemove (lpOldGPOList2, lpGPOInfo->lpGPOList);
    }


    if (bTemp || bUsePerUserLocalSetting && bTemp2 ) {

        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
            CEvents ev(FALSE, EVENT_GPO_LIST_CHANGED); ev.Report();
        }

        if ( !GetDeletedGPOList (lpOldGPOList, ppDeletedGPOList)) {

            DebugMsg((DM_WARNING, TEXT("CheckGPOs: GetDeletedList failed for %s."), lpExt->lpDisplayName));
            CEvents ev(TRUE, EVENT_FAILED_GETDELETED_LIST);
            ev.AddArg(lpExt->lpDisplayName); ev.Report();

        }

        if ( bUsePerUserLocalSetting ) {

            if ( !GetDeletedGPOList (lpOldGPOList2, ppDeletedGPOList)) {
                DebugMsg((DM_WARNING, TEXT("CheckGPOs: GetDeletedList failed for %s."), lpExt->lpDisplayName));
                CEvents ev(TRUE, EVENT_FAILED_GETDELETED_LIST);
                ev.AddArg(lpExt->lpDisplayName); ev.Report();
            }

        }

        return TRUE;
    }

    //
    // Both the saved history GPO lists are the same and there are no deletions.
    // So, we need to compare the version numbers of the GPOs to see if any have been updated.
    //

    BOOL bMembershipChanged = bUsePerUserLocalSetting && lpGPOInfo->bUserLocalMemChanged
                              || !bUsePerUserLocalSetting && lpGPOInfo->bMemChanged;

    BOOL bPolicyUnchanged = CompareGPOLists (lpOldGPOList, lpGPOInfo->lpGPOList);
    BOOL bPerUserPolicyUnchanged = !bUsePerUserLocalSetting ? TRUE : CompareGPOLists (lpOldGPOList2, lpGPOInfo->lpGPOList);

    if ( bPolicyUnchanged && bPerUserPolicyUnchanged && !bMembershipChanged && (!(lpGPOInfo->bSidChanged)))
    {
        //
        // The list of GPOs hasn't changed or been updated, and the security group
        // membership has not changed. The default is to not call the extension if
        // it has NoGPOListChanges set. However this can be overridden based on other
        // extension preferences. These are hacks for performance.
        //
        // Exception: Even if nothing has changed but the user's sid changes we need to
        // call the extensions so that they can update their settings
        //

        BOOL bSkip = TRUE;      // Start with the default case
        BOOL bNoChanges = TRUE;
        DWORD dwSlowLinkCur = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;
        DWORD dwRsopLoggingCur = lpGPOInfo->bRsopLogging;


        if ( !(lpExt->lpPrevStatus->bStatus) ) {

            //
            // Couldn't read the previous status or time, so the conservative solution is to call
            // extension.
            //

            bSkip = FALSE;
            DebugMsg((DM_VERBOSE,
                          TEXT("CheckGPOs: No GPO changes but couldn't read extension %s's status or policy time."),
                          lpExt->lpDisplayName));

        } else {
            if ( ( (lpGPOInfo->dwFlags & GP_FORCED_REFRESH) || 
                  ((!(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)) && (lpExt->lpPrevStatus->bForceRefresh)))) {

                //
                // Forced refresh has been called or the extension doesn't support running in the background
                // and is running for the first time in the foreground since a force refresh has been called.
                //
                // Pass in changes too
                //

                bSkip = FALSE;
                bNoChanges = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but called in force refresh flag or extension %s needs to run force refresh in foreground processing"),
                              lpExt->lpDisplayName));

            } else if ( lpExt->lpPrevStatus->dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED && 
                            !(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ) {
                //
                // When the previous call completed the status code has explicitly asked the framework
                // to call the CSE in foreground.
                //
                bSkip = FALSE;
                bNoChanges = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s had returned ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED for previous policy processing call."),
                              lpExt->lpDisplayName));

            } else if ( ((lpExt->lpPrevStatus->dwStatus) == ERROR_OVERRIDE_NOCHANGES) ) {

                //
                // When the previous call completed the status code has explicitly asked the framework
                // to disregard the NoGPOListChanges setting.
                //

                bSkip = FALSE;
                bNoChanges = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s had returned ERROR_OVERRIDE_NOCHANGES for previous policy processing call."),
                              lpExt->lpDisplayName));

            } else if ( ((lpExt->lpPrevStatus->dwStatus) != ERROR_SUCCESS) ) {

                //
                // Extension returned error code, so call the extension again with changes.
                //

                bSkip = FALSE;
                bNoChanges = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's returned error status %d earlier."),
                              lpExt->lpDisplayName, (lpExt->lpPrevStatus->dwStatus) ));


            } else if ( lpExt->dwLinkTransition
                        && ( lpExt->lpPrevStatus->dwSlowLink != dwSlowLinkCur ) ) {

                //
                // If there has been a link speed transition then no changes is overridden.
                //

                bSkip = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's has a link speed transition from %d to %d."),
                              lpExt->lpDisplayName, lpExt->lpPrevStatus->dwSlowLink, dwSlowLinkCur ));


            } else if ( lpExt->bNewInterface
                        && ( lpExt->lpPrevStatus->dwRsopLogging != dwRsopLoggingCur ) ) {

                //
                // If there has been a Rsop logging transition then no changes is overridden.
                //

                bSkip = FALSE;
                lpExt->bRsopTransition = TRUE;           
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's has a Rsop Logging transition from %d to %d."),
                              lpExt->lpDisplayName, lpExt->lpPrevStatus->dwRsopLogging, dwRsopLoggingCur ));


            } else if ( lpExt->bNewInterface
                        && ( lpExt->lpPrevStatus->dwRsopLogging)
                        && ( FAILED(lpExt->lpPrevStatus->dwRsopStatus) ) ) {

                //
                // If rsop logging failed last time for this CSE
                //

                bSkip = FALSE;
                lpExt->bRsopTransition = TRUE;           
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but rsop is on and extension <%s> failed to log rsop wih error 0x%x."),
                              lpExt->lpDisplayName, lpExt->lpPrevStatus->dwRsopStatus ));


            } else if ( lpExt->bNewInterface && dwRsopLoggingCur
                        && (lpGPOInfo->bRsopCreated)) {

                //
                // If Rsop logging is turned on and the RSOP Name Space was created just now.
                //

                bSkip = FALSE;
                lpExt->bRsopTransition = TRUE;           
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's has a Rsop Logging transition because name space was created now."),
                              lpExt->lpDisplayName));
            } else if ( (lpExt->lpPrevStatus->dwStatus) == ERROR_SUCCESS
                        && lpExt->dwNoGPOChanges
                        && lpExt->dwMaxChangesInterval != 0 ) {

                if ( dwCurrentTime == 0
                     || (lpExt->lpPrevStatus->dwTime) == 0
                     || dwCurrentTime < (lpExt->lpPrevStatus->dwTime) ) {

                    //
                    // Handle clock overflow case by assuming that interval has been exceeded
                    //

                    bSkip = FALSE;
                    DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's MaxNoGPOListChangesInterval has been exceeded due to clock overflow."),
                              lpExt->lpDisplayName));

                } else if ( (dwCurrentTime - (lpExt->lpPrevStatus->dwTime)) > lpExt->dwMaxChangesInterval ) {

                    //
                    // Extension has specified a time interval for which NoGPOListChanges is valid and the time
                    // interval has been exceeded.
                    //

                    bSkip = FALSE;
                    DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's MaxNoGPOListChangesInterval has been exceeded."),
                              lpExt->lpDisplayName));
                }
            }
        }

        if ( bSkip && lpExt->dwNoGPOChanges ) {

            //
            // Case of skipping extension when there are *really* no changes and extension
            // set NoGPOListChanges to true.
            //

            DebugMsg((DM_VERBOSE,
                      TEXT("CheckGPOs: No GPO changes and no security group membership change and extension %s has NoGPOChanges set."),
                      lpExt->lpDisplayName));
            if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                CEvents ev(FALSE, EVENT_NO_CHANGES);
                ev.AddArg(lpExt->lpDisplayName); ev.Report();
            }

            *pbProcessGPOs = FALSE;

        } else
            *pbNoChanges = bNoChanges;

    } // if CompareGpoLists

    FreeGPOList( lpOldGPOList );
    FreeGPOList( lpOldGPOList2 );

    return TRUE;
}



//*************************************************************
//
//  CheckGroupMembership()
//
//  Purpose:    Checks if the security groups has changed,
//              and if so saves the new security groups.
//
//  Parameters: lpGPOInfo - LPGPOINFO struct
//              pbMemChanged          - Change status returned here
//              pbUserLocalMemChanged - PerUserLocal change status returned here
//
//*************************************************************

void CheckGroupMembership( LPGPOINFO lpGPOInfo, HANDLE hToken, BOOL *pbMemChanged, BOOL *pbUserLocalMemChanged, 
                           PTOKEN_GROUPS *ppRetGroups )
{
    PTOKEN_GROUPS pGroups = 0;
    DWORD dwTokenGrpSize = 0;

    *ppRetGroups = NULL;

    DWORD dwStatus = NtQueryInformationToken( hToken,
                                              TokenGroups,
                                              pGroups,
                                              dwTokenGrpSize,
                                              &dwTokenGrpSize );

    if ( dwStatus ==  STATUS_BUFFER_TOO_SMALL ) {

        pGroups = (PTOKEN_GROUPS) LocalAlloc( LPTR, dwTokenGrpSize );

        if ( pGroups == 0 ) {
            *pbMemChanged = TRUE;
            *pbUserLocalMemChanged = TRUE;

            goto Exit;
        }

        dwStatus = NtQueryInformationToken( hToken,
                                            TokenGroups,
                                            pGroups,
                                            dwTokenGrpSize,
                                            &dwTokenGrpSize );
    }

    if ( dwStatus != STATUS_SUCCESS ) {
        *pbMemChanged = TRUE;
        *pbUserLocalMemChanged = TRUE;

        goto Exit;
    }

    //
    // First do the machine and roaming user case
    //

    *pbMemChanged = ReadMembershipList( lpGPOInfo, NULL, pGroups );
    if ( *pbMemChanged )
        SaveMembershipList( lpGPOInfo, NULL, pGroups );

    //
    // Now the per user local settings case
    //

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {

        *pbUserLocalMemChanged = *pbMemChanged;

    } else {

        DmAssert( lpGPOInfo->lpwszSidUser != 0 );

        *pbUserLocalMemChanged = ReadMembershipList( lpGPOInfo, lpGPOInfo->lpwszSidUser, pGroups );
        if ( *pbUserLocalMemChanged )
            SaveMembershipList( lpGPOInfo, lpGPOInfo->lpwszSidUser, pGroups );
    }


    //
    // filter out the logon sids in the returned token groups
    //

    *ppRetGroups = (PTOKEN_GROUPS) LocalAlloc( LPTR, sizeof(TOKEN_GROUPS) + 
                                                    (pGroups->GroupCount)*sizeof(SID_AND_ATTRIBUTES) +
                                                    (pGroups->GroupCount)*(SECURITY_MAX_SID_SIZE));

    if (*ppRetGroups) {
        DWORD i=0, dwCount=0, cbSid;
        PSID pSidPtr;

        pSidPtr = (PSID)( ((LPBYTE)(*ppRetGroups)) + 
                        sizeof(TOKEN_GROUPS) + (pGroups->GroupCount)*sizeof(SID_AND_ATTRIBUTES));

        for ( ; i < pGroups->GroupCount; i++ ) {

            if ( (SE_GROUP_LOGON_ID & pGroups->Groups[i].Attributes) == 0 ) {
                //
                // copy the sid first
                //

                cbSid =  RtlLengthSid(pGroups->Groups[i].Sid);
                dwStatus = RtlCopySid(cbSid, pSidPtr, pGroups->Groups[i].Sid);
                
                //
                // copy the attributes and make sid point correctly
                //
                (*ppRetGroups)->Groups[dwCount].Attributes = pGroups->Groups[i].Attributes;
                (*ppRetGroups)->Groups[dwCount].Sid = pSidPtr;

                pSidPtr = (PSID)( ((LPBYTE)pSidPtr) + cbSid);
                dwCount++;
            }
        }

        (*ppRetGroups)->GroupCount = dwCount;
    }

Exit:

    if ( pGroups != 0 )
        LocalFree( pGroups );

}



//*************************************************************
//
//  GroupInList()
//
//  Purpose:    Checks if sid in is list of security groups.
//
//  Parameters: lpSid   - Sid to check
//              pGroups - List of token groups
//
//  Return:     TRUE if sid is in list
//              FALSE otherwise
//
//*************************************************************

BOOL GroupInList( LPTSTR lpSid, PTOKEN_GROUPS pGroups )
{
    PSID    pSid = 0;
    DWORD   dwStatus, i;
    BOOL    bInList = FALSE;

    //
    // Optimize the basic case where the user is an earthling
    //

    if ( 0 == lstrcmpi (lpSid, L"s-1-1-0") )
        return TRUE;

    dwStatus = AllocateAndInitSidFromString (lpSid, &pSid);

    if (ERROR_SUCCESS != dwStatus)
        return FALSE;

    //
    // Cannot match up cached groups with current groups one-by-one because
    // current pGroups can have groups with  SE_GROUP_LOGON_ID attribute
    // set which are different for each logon session.
    //

    for ( i=0; i < pGroups->GroupCount; i++ ) {

        bInList = RtlEqualSid (pSid, pGroups->Groups[i].Sid);
        if ( bInList )
            break;

    }

    RtlFreeSid (pSid);

    return bInList;
}


//*************************************************************
//
//  IsSlowLink()
//
//  Purpose:    Determines if the connection to the specified
//              server is a slow link or not
//
//  Parameters: hKeyRoot     -  Registry hive root
//              lpDCAddress  -  Server address in string form
//              bSlow        -  Receives slow link status
//
//  Return:     TRUE if slow link
//              FALSE if not
//
//*************************************************************

DWORD IsSlowLink (HKEY hKeyRoot, LPTSTR lpDCAddress, BOOL *bSlow, DWORD* pdwAdaptexIndex )
{
    DWORD dwSize, dwType, dwResult;
    HKEY hKey;
    LONG lResult;
    ULONG ulSpeed, ulTransferRate;
    IPAddr ipaddr;
    LPSTR lpDCAddressA, lpTemp;
    PWSOCK32_API pWSock32;


    //
    // Set default
    //

    *bSlow = TRUE;


    //
    // Get the slow link detection flag, and slow link timeout.
    //

    ulTransferRate = SLOW_LINK_TRANSFER_RATE;

    lResult = RegOpenKeyEx(hKeyRoot,
                           WINLOGON_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(ulTransferRate);
        RegQueryValueEx (hKey,
                         TEXT("GroupPolicyMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    lResult = RegOpenKeyEx(hKeyRoot,
                           SYSTEM_POLICIES_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(ulTransferRate);
        RegQueryValueEx (hKey,
                         TEXT("GroupPolicyMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // If the transfer rate is 0, then always download policy
    //

    if (!ulTransferRate) {
        DebugMsg((DM_VERBOSE, TEXT("IsSlowLink: Slow link transfer rate is 0.  Always download policy.")));
        *bSlow = FALSE;
        return ERROR_SUCCESS;
    }


    //
    // Convert the ipaddress from string form to ulong format
    //

    dwSize = lstrlen (lpDCAddress) + 1;

    lpDCAddressA = (LPSTR)LocalAlloc (LPTR, dwSize);

    if (!lpDCAddressA) {
        DebugMsg((DM_WARNING, TEXT("IsSlowLink: Failed to allocate memory.")));
        return GetLastError();
    }

#ifdef UNICODE

    if (!WideCharToMultiByte(CP_ACP, 0, lpDCAddress, -1, lpDCAddressA, dwSize, NULL, NULL)) {
        LocalFree(lpDCAddressA);
        DebugMsg((DM_WARNING, TEXT("IsSlowLink: WideCharToMultiByte failed with %d"), GetLastError()));
        //treat it as slow link
        return GetLastError();
    }

#else

    lstrcpy (lpDCAddressA, lpDCAddress);

#endif

    pWSock32 = LoadWSock32();

    if ( !pWSock32 ) {
        LocalFree(lpDCAddressA);
        DebugMsg((DM_WARNING, TEXT("IsSlowLink: Failed to load wsock32.dll with %d"), GetLastError()));
        //treat it as slow link
        return GetLastError();
    }


    if ((*lpDCAddressA == TEXT('\\')) && (*(lpDCAddressA+1) == TEXT('\\'))) {
        lpTemp = lpDCAddressA+2;
    } else {
        lpTemp = lpDCAddressA;
    }

    ipaddr = pWSock32->pfninet_addr (lpTemp);


    //
    // Ping the computer
    //

    dwResult = PingComputerEx( ipaddr, &ulSpeed, pdwAdaptexIndex );


    if (dwResult == ERROR_SUCCESS) {

        if (ulSpeed) {

            //
            // If the delta time is greater that the timeout time, then this
            // is a slow link.
            //

            if (ulSpeed < ulTransferRate) {
                *bSlow = TRUE;
            }
            else
                *bSlow = FALSE;
        }
        else
            *bSlow = FALSE;
    }

    LocalFree (lpDCAddressA);

    return dwResult;
}


//*************************************************************
//
//  CheckGPOAccess()
//
//  Purpose:    Determines if the user / machine has read access to
//              the GPO and if so, checks the Apply Group Policy
//              extended right to see if the GPO should be applied.
//              Also retrieves GPO attributes.
//
//  Parameters: pld             -  LDAP connection
//              pLDAP           -  LDAP function table pointer
//              pMessage        -  LDAP message
//              lpSDProperty    -  Security descriptor property name
//              dwFlags         -  GetGPOList flags
//              hToken          -  User / machine token
//              pSD             -  Security descriptor returned here
//              pcbSDLen        -  Length of security descriptor returned here
//              pbAccessGranted -  Receives the final yes / no status
//
//  Return:     TRUE if successful
//              FALSE if an error occurs.
//
//*************************************************************

BOOL CheckGPOAccess (PLDAP pld, PLDAP_API pLDAP, HANDLE hToken, PLDAPMessage pMessage,
                     LPTSTR lpSDProperty, DWORD dwFlags,
                     PSECURITY_DESCRIPTOR *ppSD, DWORD *pcbSDLen,
                     BOOL *pbAccessGranted,
                     PRSOPTOKEN pRsopToken )
{
    BOOL bResult = FALSE;
    PWSTR *ppwszValues = NULL;
    PLDAP_BERVAL *pSize = NULL;
    OBJECT_TYPE_LIST ObjType[2];
    PRIVILEGE_SET PrivSet;
    DWORD PrivSetLength = sizeof(PRIVILEGE_SET);
    DWORD dwGrantedAccess;
    BOOL bAccessStatus = TRUE;
    GUID GroupPolicyContainer = {0x31B2F340, 0x016D, 0x11D2,
                                 0x94, 0x5F, 0x00, 0xC0, 0x4F, 0xB9, 0x84, 0xF9};
    // edacfd8f-ffb3-11d1-b41d-00a0c968f939
    GUID ApplyGroupPolicy = {0xedacfd8f, 0xffb3, 0x11d1,
                             0xb4, 0x1d, 0x00, 0xa0, 0xc9, 0x68, 0xf9, 0x39};
    GENERIC_MAPPING DS_GENERIC_MAPPING = { DS_GENERIC_READ, DS_GENERIC_WRITE,
                                           DS_GENERIC_EXECUTE, DS_GENERIC_ALL };

    XLastError xe;

    //
    // Set the default return value
    //

    *pbAccessGranted = FALSE;


    //
    // Get the security descriptor value
    //

    ppwszValues = pLDAP->pfnldap_get_values(pld, pMessage, lpSDProperty);


    if (!ppwszValues) {
        if (pld->ld_errno == LDAP_NO_SUCH_ATTRIBUTE) {
            DebugMsg((DM_VERBOSE, TEXT("CheckGPOAccess:  Object can not be accessed.")));
            bResult = TRUE;
        }
        else {
            DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  ldap_get_values failed with 0x%x"),
                 pld->ld_errno));
            xe = pLDAP->pfnLdapMapErrorToWin32(pld->ld_errno);
        }

        goto Exit;
    }


    //
    // Get the length of the security descriptor
    //

    pSize = pLDAP->pfnldap_get_values_len(pld, pMessage, lpSDProperty);

    if (!pSize || !*pSize) {
        DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  ldap_get_values_len failed with 0x%x"),
                 pld->ld_errno));
        xe = pLDAP->pfnLdapMapErrorToWin32(pld->ld_errno);
        goto Exit;
    }


    //
    // Allocate the memory for the security descriptor
    //

    *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, (*pSize)->bv_len);

    if ( *ppSD == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  Failed to allocate memory for SD with  %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Copy the security descriptor
    //

    CopyMemory( *ppSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);
    *pcbSDLen = (*pSize)->bv_len;


    //
    // Now we use AccessCheckByType to determine if the user / machine
    // should have this GPO applied to them
    //
    //
    // Prepare the object type array
    //

    ObjType[0].Level = ACCESS_OBJECT_GUID;
    ObjType[0].Sbz = 0;
    ObjType[0].ObjectType = &GroupPolicyContainer;

    ObjType[1].Level = ACCESS_PROPERTY_SET_GUID;
    ObjType[1].Sbz = 0;
    ObjType[1].ObjectType = &ApplyGroupPolicy;


    //
    // Check access
    //

    if  ( pRsopToken )
    {
        HRESULT hr = RsopAccessCheckByType( *ppSD, NULL, pRsopToken, MAXIMUM_ALLOWED, ObjType, 2,
                            &DS_GENERIC_MAPPING, &PrivSet, &PrivSetLength,
                            &dwGrantedAccess, &bAccessStatus);
        if (FAILED(hr)) {
            xe = HRESULT_CODE(hr);
            DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  RsopAccessCheckByType failed with  0x%08X"), hr));
            goto Exit;
        }

        //
        // Check for the control bit
        //


        DWORD dwReqdRights = ACTRL_DS_CONTROL_ACCESS | 
                             STANDARD_RIGHTS_READ    | 
                             ACTRL_DS_LIST           | 
                             ACTRL_DS_READ_PROP;

                            // DS_GENERIC_READ without ACTRL_DS_LIST_OBJECT


        if (bAccessStatus && ( ( dwGrantedAccess & dwReqdRights  ) == dwReqdRights ) )
        {
            *pbAccessGranted = TRUE;
        }
        
        if (!(*pbAccessGranted)) {
            DebugMsg((DM_VERBOSE, TEXT("CheckGPOAccess:  AccessMask 0x%x, Looking for 0x%x"), 
                      dwGrantedAccess, dwReqdRights));
        }
    }
    else
    {
        if (!AccessCheckByType ( *ppSD, NULL, hToken, MAXIMUM_ALLOWED, ObjType, 2,
                            &DS_GENERIC_MAPPING, &PrivSet, &PrivSetLength,
                            &dwGrantedAccess, &bAccessStatus)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  AccessCheckByType failed with  %d"), GetLastError()));
            goto Exit;
        }
        //
        // Check for the control bit
        //

        if (bAccessStatus && ( dwGrantedAccess & ACTRL_DS_CONTROL_ACCESS ) )
        {
            *pbAccessGranted = TRUE;
        }
    }

    bResult = TRUE;

Exit:

    if (pSize) {
        pLDAP->pfnldap_value_free_len(pSize);
    }

    if (ppwszValues) {
        pLDAP->pfnldap_value_free(ppwszValues);
    }

    return bResult;
}


//*************************************************************
//
//  FilterCheck()
//
//  Purpose:    Determines if the GPO passes the WQL filter check
//
//  Parameters: pRsopToken      - Rsop security token
//              pGpoFilter      - Gpo filter class
//              pbFilterAllowed - True if GPO passes the filter check
//              pwszFilterId    - Filter id that can be used for
//                                Rsop logging. Needs to be freed by caller
//
//  Return:     TRUE if successful
//              FALSE if an error occurs.
//
// Notes:
//		Even though the code can handle multiple filters, we are not logging
// it or returning it till we make up our minds whether this is actually supported.
//
//*************************************************************

BOOL PrintToString( XPtrST<WCHAR>& xwszValue, WCHAR *wszString,
                    WCHAR *pwszParam1, WCHAR *pwszParam2, DWORD dwParam3 );

BOOL FilterCheck( PLDAP pld, PLDAP_API pLDAP, 
                  PLDAPMessage pMessage,
                  PRSOPTOKEN pRsopToken,
                  LPTSTR szWmiFilter,
                  CGpoFilter *pGpoFilter,
                  CLocator *pLocator,
                  BOOL *pbFilterAllowed,
                  WCHAR **ppwszFilterId
				  )
{
    *pbFilterAllowed = FALSE;
    *ppwszFilterId = NULL;
    XPtrLF<WCHAR> xWmiFilter;
    HRESULT hr;
    LPTSTR *lpValues;
    XLastError xe;


    //
    // Use a static filter id for testing. When UI is ready obtain the
    // id dynamically from GPO object in DS.
    //
    // WCHAR wszStaticId[] = L"foo";
    // xWmiFilter = wszStaticId;
    //


    //
    // In the results, get the values that match the gPCFilterObject 
    //


    lpValues = pLDAP->pfnldap_get_values (pld, pMessage, szWmiFilter);

    if (lpValues) {

        xWmiFilter = (LPWSTR) LocalAlloc( LPTR, (lstrlen(*lpValues)+1) * sizeof(TCHAR) );
        if ( xWmiFilter == 0) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("FilterCheck:  Unable to allocate memory")));
            pLDAP->pfnldap_value_free (lpValues);
            return FALSE;
        }

        lstrcpy (xWmiFilter, *lpValues);
        DebugMsg((DM_VERBOSE, TEXT("FilterCheck:  Found WMI Filter id of:  <%s>"), (LPWSTR)xWmiFilter));
        pLDAP->pfnldap_value_free (lpValues);
    }

    

    if ( xWmiFilter == NULL ) {

        //
        // For backwards compatibility, assume that a null filter id implies that
        // GPO passes filter check.
        //

        *pbFilterAllowed = TRUE;
        return TRUE;
    }

    if (*xWmiFilter == TEXT(' ')) {

       if (*(xWmiFilter+1) == TEXT('\0')) {

          //
          // The UI will reset a GPO's filter to a single space character
          // when the admin sets the filter option to None.
          //

          *pbFilterAllowed = TRUE;
          return TRUE;
       }
    }

    //
    // The value we get back to split the
    // DS path and the id before calling evaluate..
    //
    // The query is assumed to be of the format..
    // [Dspath;id;flags] [Dspath;id;flags]
    //
    

    LPWSTR lpPtr = xWmiFilter;
    LPWSTR lpDsPath=NULL;
    LPWSTR lpId=NULL;
    LPWSTR dwFlags = 0;
    WCHAR wszNS[] = L"MSFT_SomFilter.ID=\"%ws\",Domain=\"%ws\"";

	XPtrLF<WCHAR> xwszNS;
    
    *pbFilterAllowed = TRUE;

    while (*lpPtr) {

        while ((*lpPtr) && (*lpPtr != L'[')) {
            lpPtr++;
        }

        if (!(*lpPtr)) {
            xe = ERROR_INVALID_PARAMETER;
            return FALSE;
        }

        lpPtr++;
        lpDsPath = lpPtr;

        while ((*lpPtr) && (*lpPtr != L';')) 
            lpPtr++;
        
        if (!(*lpPtr)) {
            xe = ERROR_INVALID_PARAMETER;
            return FALSE;
        }

        *lpPtr = L'\0';
        lpPtr++;
        lpId = lpPtr;

        while ((*lpPtr) && (*lpPtr != L';')) 
            lpPtr++;
        
        if (!(*lpPtr)) {
            xe = ERROR_INVALID_PARAMETER;
            return FALSE;
        }

        *lpPtr = L'\0';
        lpPtr++;

        while ((*lpPtr) && (*lpPtr != L']')) 
            lpPtr++;

        if (!(*lpPtr)) {
            xe = ERROR_INVALID_PARAMETER;
            return FALSE;
        }
		
		lpPtr++;


		xwszNS = (LPWSTR)LocalAlloc(LPTR, (lstrlen(wszNS)+lstrlen(lpId)+lstrlen(lpDsPath))*sizeof(WCHAR));

		if (!xwszNS) {
            xe = GetLastError();
			DebugMsg((DM_WARNING, TEXT("FilterCheck: Couldn't allocate memory for filter. error - %d" ), GetLastError() ));
			return FALSE;
		}

		wsprintf(xwszNS, wszNS, lpId, lpDsPath);


        if ( pRsopToken ) {

            //
            // Planning mode
            //

            *pbFilterAllowed = pGpoFilter->FilterCheck( xwszNS );

        } else {

            //
            // Normal mode
            //

            IWbemServices *pWbemServices = pLocator->GetPolicyConnection();
            if( pWbemServices == NULL ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("FilterCheck: ConnectServer failed. hr = 0x%x" ), xe));
                return FALSE;
            }


            XBStr xbstrMethod = L"Evaluate";
            XBStr xbstrObject = xwszNS;

            XInterface<IWbemClassObject> xpOutParam = NULL;

            hr = pWbemServices->ExecMethod( xbstrObject,
                                            xbstrMethod,
                                            0,
                                            NULL,
                                            NULL,
                                            &xpOutParam,
                                            NULL );
            if(FAILED(hr)) {
                if (hr != WBEM_E_NOT_FOUND) {
                    // only full WMI error makes sense.
                    xe = hr;
                    DebugMsg((DM_WARNING, TEXT("FilterCheck: ExecMethod failed. hr=0x%x" ), hr ));
                    return FALSE;
                }
                else {
                    // treat it as if the filter doesn't exist
                    // only full WMI error makes sense.
                    xe = hr;
                    DebugMsg((DM_VERBOSE, TEXT("FilterCheck: Filter doesn't exist. Evaluating to false" )));
                    *pbFilterAllowed = FALSE;
                    *ppwszFilterId = xwszNS.Acquire();
                    return FALSE;
                }
            }

            XBStr xbstrRetVal = L"ReturnValue";
            VARIANT var;

            hr = xpOutParam->Get( xbstrRetVal, 0, &var, 0, 0);
            if(FAILED(hr)) {
                xe = hr;
                DebugMsg((DM_WARNING, TEXT("FilterCheck: Get failed. hr=0x%x" ), hr ));
                return FALSE;
            }

            XVariant xVar( &var );
            if (FAILED(var.lVal)) {
                xe = hr;
                DebugMsg((DM_WARNING, TEXT("FilterCheck: Evaluate returned error. hr=0x%x" ), var.lVal ));
                *pbFilterAllowed = FALSE;
            }

            if (var.lVal == S_FALSE) {
                *pbFilterAllowed = FALSE;
            }
        }
    }

    //
    // Acquire it and return to the caller
    //


    *ppwszFilterId = xwszNS.Acquire();
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\main\globals.h ===
//*************************************************************
//
//  Global Variable Extern's
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#define WINLOGON_KEY                 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define WINDOWS_POLICIES_KEY         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")
#define ROOT_POLICIES_KEY            TEXT("Software\\Policies")
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")
#define DIAGNOSTICS_KEY              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Diagnostics")
#define DIAGNOSTICS_GLOBAL_VALUE     TEXT("RunDiagnosticLoggingGlobal")
#define DIAGNOSTICS_POLICY_VALUE     TEXT("RunDiagnosticLoggingGroupPolicy")
#define LOCAL_GPO_DIRECTORY          TEXT("%SystemRoot%\\System32\\GroupPolicy")
#define LONG_UNC_PATH_PREFIX         TEXT("\\\\?\\UNC")

//ds
//
// When the time to change the profiles directory to the root,
// these things need to be done / checked:
//
// 1)  Search for //ds everywhere in this directory
// 2)  Change the default profiles directory in
//     windows\setup\inf\win4\inf\usa\hivesft.txt
//     note:  the new name is "Documents and Settings"
// 3)  In hivedef.inx, remove the TEMP and TMP environment variable entries
// 4)  Remove all of the special folder entries
// 5)  In usa\hivedef.txt, remove TEMP, TMP, and special folder entries
// 6)  Review MoveUserProfile() function to make sure it will handle
//     name collision (dual boot) case for All Users and Default User
//

#define NT4_PROFILES_DIRECTORY       TEXT("%SystemRoot%\\Profiles")
#define DEFAULT_USER                 TEXT("Default User")
#define DEFAULT_USER_NETWORK         TEXT("Default User (Network)")
#define ALL_USERS                    TEXT("All Users")

#define GUIMODE_SETUP_MUTEX          TEXT("Global\\userenv: GUI mode setup running")
#define USER_POLICY_MUTEX            TEXT("userenv: user policy mutex")
#define MACHINE_POLICY_MUTEX         TEXT("Global\\userenv: machine policy mutex")
#define USER_POLICY_REFRESH_EVENT    TEXT("userenv: user policy refresh event")
#define MACHINE_POLICY_REFRESH_EVENT TEXT("Global\\userenv: machine policy refresh event")
#define USER_POLICY_APPLIED_EVENT    TEXT("userenv: User Group Policy has been applied")
#define MACHINE_POLICY_APPLIED_EVENT TEXT("Global\\userenv: Machine Group Policy has been applied")
#define USER_POLICY_DONE_EVENT       TEXT("userenv: User Group Policy Processing is done")
#define MACHINE_POLICY_DONE_EVENT    TEXT("Global\\userenv: Machine Group Policy Processing is done")

#define MACH_POLICY_FOREGROUND_DONE_EVENT   TEXT("Global\\userenv: Machine Policy Foreground Done Event")
#define USER_POLICY_FOREGROUND_DONE_EVENT   TEXT("userenv: User Policy Foreground Done Event")

//
// This event needs to be set for user or machine forced refresh
//

#define USER_POLICY_FORCE_REFRESH_EVENT     TEXT("userenv: user policy force refresh event")
#define MACHINE_POLICY_FORCE_REFRESH_EVENT  TEXT("Global\\userenv: machine policy force refresh event")


//
// This event is set by the core if a reboot is needed for the forced refresh to complete.
//

#define USER_POLICY_REFRESH_NEEDFG_EVENT    TEXT("userenv: User Group Policy ForcedRefresh Needs Foreground Processing")
#define MACHINE_POLICY_REFRESH_NEEDFG_EVENT TEXT("Global\\userenv: Machine Group Policy ForcedRefresh Needs Foreground Processing")


#define USER_SHELL_FOLDERS           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#if defined(_WIN64)
#define USER_SHELL_FOLDERS32         TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#endif
#define SHELL_FOLDERS                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define PROFILE_LIST_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define PROFILE_GUID_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileGuid")
#define PROFILES_DIRECTORY           TEXT("ProfilesDirectory")
#define ALL_USERS_PROFILE            TEXT("AllUsersProfile")
#define DEFAULT_USER_PROFILE         TEXT("DefaultUserProfile")
#define PROFILE_FLAGS                TEXT("Flags")
#define PROFILE_GUID                 TEXT("Guid")
#define PROFILE_STATE                TEXT("State")
#define PROFILE_IMAGE_VALUE_NAME     TEXT("ProfileImagePath")
#define PROFILE_CENTRAL_PROFILE      TEXT("CentralProfile")
#define PROFILE_REF_COUNT            TEXT("RefCount")
#define USER_PREFERENCE              TEXT("UserPreference")
#define PROFILE_LOAD_TIME_LOW        TEXT("ProfileLoadTimeLow")
#define PROFILE_LOAD_TIME_HIGH       TEXT("ProfileLoadTimeHigh")
#define PROFILE_UNLOAD_TIME_LOW      TEXT("ProfileUnloadTimeLow")
#define PROFILE_UNLOAD_TIME_HIGH     TEXT("ProfileUnloadTimeHigh")
#define PROFILE_GENERAL_SECTION      TEXT("General")
#define PROFILE_EXCLUSION_LIST       TEXT("ExclusionList")
#define PROFILE_LOAD_TYPE            TEXT("ProfileLoadType")
#define PROFILE_LAST_UPLOAD_STATE    TEXT("LastUploadState")
#define COMPLETE_PROFILE             TEXT("Complete")
#define PARTIAL_PROFILE              TEXT("Partial")
#define PROFILE_BUILD_NUMBER         TEXT("BuildNumber")
#define PROFILE_SID_STRING           TEXT("SidString")
#define TEMP_PROFILE_NAME_BASE       TEXT("TEMP")
#define PROFILE_UNLOAD_TIMEOUT       TEXT("ProfileUnloadTimeout")
#define DISABLE_PROFILE_UNLOAD_MSG   TEXT("DisableProfileUnloadMsg")
#define DELETE_ROAMING_CACHE         TEXT("DeleteRoamingCache")
#define ADD_ADMIN_GROUP_TO_RUP       TEXT("AddAdminGroupToRUP")
#define READONLY_RUP                 TEXT("ReadOnlyProfile")
#define PROFILE_LOCALONLY            TEXT("LocalProfile")
#define USER_PROFILE_SETUP_EVENT     TEXT("Global\\userenv:  User Profile setup event")
#define USER_PROFILE_MUTEX           TEXT("Global\\userenv:  User Profile Mutex for ")

#define SYSTEM_PROFILE_LOCATION      TEXT("%systemroot%\\system32\\config\\systemprofile")


//
// Appmgmt stuff to nuke
//

#define APPMGMT_DIR_ROOT             TEXT("%systemroot%\\system32\\appmgmt")
#define APPMGMT_REG_MANAGED          TEXT("Software\\Microsoft\\Windows\\Currentversion\\Installer\\Managed")

//
// IE cache key
//

#define IE4_CACHE_KEY                TEXT("Software\\Microsoft\\Windows\\Currentversion\\Internet Settings\\Cache\\Extensible Cache")
#define IE5_CACHE_KEY                TEXT("Software\\Microsoft\\Windows\\Currentversion\\Internet Settings\\5.0\\Cache\\Extensible Cache")
#define IE_CACHEKEY_PREFIX           TEXT("MsHist")

#ifdef  __cplusplus
extern "C" {
#endif

extern HINSTANCE    g_hDllInstance;
extern TCHAR        c_szRegistryExtName[];
extern const TCHAR  c_szRegistryPol[];


//
// Group policy handles
//

extern HANDLE           g_hPolicyCritMutexMach;
extern HANDLE           g_hPolicyCritMutexUser;

extern HANDLE           g_hPolicyNotifyEventMach;
extern HANDLE           g_hPolicyNotifyEventUser;

extern HANDLE           g_hPolicyNeedFGEventMach;
extern HANDLE           g_hPolicyNeedFGEventUser;

extern HANDLE           g_hPolicyDoneEventMach;
extern HANDLE           g_hPolicyDoneEventUser;

extern DWORD            g_dwBuildNumber;
extern HANDLE           g_hProfileSetup;

extern HANDLE           g_hPolicyForegroundDoneEventMach;
extern HANDLE           g_hPolicyForegroundDoneEventUser;

extern const TCHAR c_szStarDotStar[];
extern const TCHAR c_szSlash[];
extern const TCHAR c_szDot[];
extern const TCHAR c_szDotDot[];
extern const TCHAR c_szMAN[];
extern const TCHAR c_szUSR[];
extern const TCHAR c_szLog[];
extern const TCHAR c_szPDS[];
extern const TCHAR c_szPDM[];
extern const TCHAR c_szLNK[];
extern const TCHAR c_szBAK[];
extern const TCHAR c_szNTUserTmp[];
extern const TCHAR c_szNTUserMan[];
extern const TCHAR c_szNTUserDat[];
extern const TCHAR c_szNTUserIni[];
extern const TCHAR c_szNTUserStar[];
extern const TCHAR c_szUserStar[];
extern const TCHAR c_szSpace[];
extern const TCHAR c_szDotPif[];
extern const TCHAR c_szNULL[];
extern const TCHAR c_szCommonGroupsLocation[];
#if defined(__cplusplus)
}
#endif

//
// Timeouts
//

#define SLOW_LINK_TIMEOUT        120  // ticks
#define SLOW_LINK_TRANSFER_RATE  500  // Kbps
#define PROFILE_DLG_TIMEOUT       30  // seconds

//
// Folder sizes
//

#define MAX_FOLDER_SIZE                80
#define MAX_COMMON_LEN                 30
#define MAX_DLL_NAME_LEN               13

//
// Personal / common profile folders
//

#if defined(__cplusplus)
extern "C" {
#endif
extern DWORD g_dwNumShellFolders;
extern DWORD g_dwNumCommonShellFolders;
#if defined(__cplusplus)
}
#endif


typedef struct _FOLDER_INFO {
    BOOL   bHidden;
    BOOL   bLocal;
    BOOL   bAddCSIDL;
    BOOL   bNewNT5;
    BOOL   bLocalSettings;
    INT    iFolderID;
    LPTSTR lpFolderName;
    TCHAR  szFolderLocation[MAX_FOLDER_SIZE]; // must be at end of structure
    LPTSTR lpFolderResourceDLL;
    INT    iFolderResourceID;
} FOLDER_INFO;

#if defined(__cplusplus)
extern "C" {
#endif
extern FOLDER_INFO c_ShellFolders[];
extern FOLDER_INFO c_CommonShellFolders[];
#if defined(__cplusplus)
}
#endif


//
// Product type
//

typedef enum {
   PT_WORKSTATION           = 0x0001,   // Workstation
   PT_SERVER                = 0x0002,   // Server
   PT_DC                    = 0x0004,   // Domain controller
   PT_WINDOWS               = 0x0008    // Windows
} NTPRODUCTTYPE;

#if defined(__cplusplus)
extern "C" {
#endif
extern NTPRODUCTTYPE g_ProductType;
#if defined(__cplusplus)
}
#endif


//
// Function proto-types
//

#if defined(__cplusplus)
extern "C" {
#endif
void InitializeGlobals (HINSTANCE hInstance);
void PatchLocalAppData(HANDLE hToken);
void InitializeSnapProv();
#if defined(__cplusplus)
}
#endif

//
// Type of message
//

#define DLGTYPE_ERROR        0
#define DLGTYPE_SLOWLINK     1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\main\userenv.c ===
//*************************************************************
//
//  Main entry point
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

extern DWORD    g_dwLoadFlags;

//*************************************************************
//
//  DllMain()
//
//  Purpose:    Main entry point
//
//  Parameters:     hInstance   -   Module instance
//                  dwReason    -   Way this function is being called
//                  lpReseved   -   Reserved
//
//
//  Return:     (BOOL) TRUE if successfully initialized
//                     FALSE if an error occurs
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {

            DisableThreadLibraryCalls (hInstance);
            InitializeGlobals (hInstance);
            InitializeAPIs();
            InitializeNotifySupport();
            InitializeGPOCriticalSection();
            InitializeSnapProv();
            {
                TCHAR szProcessName[MAX_PATH];
                DWORD dwLoadFlags = FALSE;
                DWORD WINLOGON_LEN = 12;  // Length of string "winlogon.exe"
                DWORD SETUP_LEN = 9;      // Length of string "setup.exe"

                DWORD dwRet = GetModuleFileName (NULL, szProcessName, ARRAYSIZE(szProcessName));
                if ( dwRet > WINLOGON_LEN ) {

                    if ( CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                         &szProcessName[dwRet-WINLOGON_LEN], -1, L"winlogon.exe", -1 ) == CSTR_EQUAL ) {
                        g_dwLoadFlags = dwLoadFlags = WINLOGON_LOAD;
                    }
                }
#if 0
                if ( dwRet > SETUP_LEN ) {

                    if ( CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                         &szProcessName[dwRet-SETUP_LEN], -1, L"setup.exe", -1 ) == CSTR_EQUAL ) {
                        g_dwLoadFlags = dwLoadFlags = SETUP_LOAD;
                    }
                }
#endif

                InitDebugSupport( dwLoadFlags );

                if (dwLoadFlags == WINLOGON_LOAD) {
                    InitializePolicyProcessing(TRUE);
                    InitializePolicyProcessing(FALSE);
                }

                DebugMsg((DM_VERBOSE, TEXT("LibMain: Process Name:  %s"), szProcessName));
            }

            }
            break;


        case DLL_PROCESS_DETACH:

            if (g_hProfileSetup) {
                CloseHandle (g_hProfileSetup);
                g_hProfileSetup = NULL;
            }

            
            if (g_hPolicyCritMutexMach) {
                CloseHandle (g_hPolicyCritMutexMach);
                g_hPolicyCritMutexMach = NULL;
            }

            if (g_hPolicyCritMutexUser) {
                CloseHandle (g_hPolicyCritMutexUser);
                g_hPolicyCritMutexUser = NULL;
            }

            
            if (g_hPolicyNotifyEventMach) {
                CloseHandle (g_hPolicyNotifyEventMach);
                g_hPolicyNotifyEventMach = NULL;
            }

            if (g_hPolicyNotifyEventUser) {
                CloseHandle (g_hPolicyNotifyEventUser);
                g_hPolicyNotifyEventUser = NULL;
            }

            
            if (g_hPolicyNeedFGEventMach) {
                CloseHandle (g_hPolicyNeedFGEventMach);
                g_hPolicyNeedFGEventMach = NULL;
            }

            if (g_hPolicyNeedFGEventUser) {
                CloseHandle (g_hPolicyNeedFGEventUser);
                g_hPolicyNeedFGEventUser = NULL;
            }

            
            if (g_hPolicyDoneEventMach) {
                CloseHandle (g_hPolicyDoneEventMach);
                g_hPolicyDoneEventMach = NULL;
            }

            if (g_hPolicyDoneEventUser) {
                CloseHandle (g_hPolicyDoneEventUser);
                g_hPolicyDoneEventUser = NULL;
            }

            if ( g_hPolicyForegroundDoneEventUser )
            {
                CloseHandle( g_hPolicyForegroundDoneEventUser );
                g_hPolicyForegroundDoneEventUser = 0;
            }

            if ( g_hPolicyForegroundDoneEventMach )
            {
                CloseHandle( g_hPolicyForegroundDoneEventMach );
                g_hPolicyForegroundDoneEventMach = 0;
            }

            CloseApiDLLsCritSec();
            ShutdownEvents ();
            ShutdownNotifySupport();
            CloseGPOCriticalSection();
            ClosePingCritSec();
            break;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gpnotif.cpp ===
//*************************************************************
//
//  Group Policy Notification
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//  Notes:      There is a small window where notifications
//              can be lost. If while processing an eMonitor workitem
//              a policy event is Pulsed then that notification will
//              be lost. This window can be closed by using two threads.
//
//  History:    28-Sep-98   SitaramR    Created
//
//*************************************************************

#include "gphdr.h"

//
// Work items for notification thread
//
enum EWorkType { eMonitor,              // Monitor events
                 eTerminate };          // Stop monitoring

//
// Entry in list of registered events
//
typedef struct _GPNOTIFINFO
{
    HANDLE                 hEvent;      // Event to be signaled
    BOOL                   bMachine;    // Machine policy notifcation ?
    struct _GPNOTIFINFO *  pNext;       // Singly linked list ptr
} GPNOTIFINFO;


typedef struct _GPNOTIFICATION
{
    HANDLE            hThread;           // Notification thread
    HANDLE            hThreadEvent;      // For signaling notification thread (Ordering of fields is important)
    HANDLE            hMachEvent;        // Event signaled by machine policy change
    HANDLE            hUserEvent;        // Event signaled by user policy change
    enum EWorkType    eWorkType;         // Work descrpition for notification thread
    GPNOTIFINFO *     pNotifList;        // List of registered events
} GPNOTIFICATION;

GPNOTIFICATION g_Notif = { NULL,
                           NULL,
                           NULL,
                           NULL,
                           eMonitor,
                           NULL };

CRITICAL_SECTION g_NotifyCS;             // Lock


//
// Forward decls
//
DWORD WINAPI NotificationThread();
void NotifyEvents( BOOL bMachine );



//*************************************************************
//
//  InitNotifSupport, ShutdownNotifSupport
//
//  Purpose:    Initialization and cleanup routines
//
//*************************************************************

void InitializeNotifySupport()
{
    InitializeCriticalSection( &g_NotifyCS );
}

void ShutdownNotifySupport()
{
    BOOL fWait = FALSE;
    DWORD dwResult;

    {
        EnterCriticalSection( &g_NotifyCS );

        if ( g_Notif.hThread != NULL )
        {
            //
            // Set up terminate workitem and then signal thread
            //

            fWait = TRUE;
            g_Notif.eWorkType = eTerminate;
            SetEvent( g_Notif.hThreadEvent );
        }

        LeaveCriticalSection( &g_NotifyCS );
    }

    if ( fWait )
        WaitForSingleObject( g_Notif.hThread, INFINITE );

    {
        EnterCriticalSection( &g_NotifyCS );

        //
        // Close all opened handles
        //

        if ( g_Notif.hThread != NULL )
            CloseHandle( g_Notif.hThread );

        if ( g_Notif.hThreadEvent != NULL )
            CloseHandle( g_Notif.hThreadEvent );

        if ( g_Notif.hUserEvent != NULL )
            CloseHandle( g_Notif.hUserEvent );

        if ( g_Notif.hMachEvent != NULL )
            CloseHandle( g_Notif.hMachEvent );

        LeaveCriticalSection( &g_NotifyCS );
    }

    DeleteCriticalSection( &g_NotifyCS );
}


//*************************************************************
//
//  RegisterGPNotification
//
//  Purpose:    Registers for a group policy change notification
//
//  Parameters: hEvent   -   Event to be notified
//              bMachine -   If true, then register for
//                                 machine policy notification, else
//                                 user policy notification
//
//  Returns:    True if successful
//              False if error occurs
//
//*************************************************************

BOOL WINAPI RegisterGPNotification( IN HANDLE hEvent, IN BOOL bMachine )
{
    BOOL bResult = FALSE;
    BOOL bNotifyThread = FALSE;
    GPNOTIFINFO *pNotifInfo = NULL;

    EnterCriticalSection( &g_NotifyCS );

    //
    // Create events and thread as needed
    //

    if ( g_Notif.hThreadEvent == NULL )
    {
        g_Notif.hThreadEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( g_Notif.hThreadEvent == NULL )
            goto Exit;
    }

    if ( g_Notif.hMachEvent == NULL )
    {
        g_Notif.hMachEvent = OpenEvent (SYNCHRONIZE, FALSE, MACHINE_POLICY_APPLIED_EVENT);

        if ( g_Notif.hMachEvent == NULL ) {
            DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: CreateEvent failed with %d"),
                     GetLastError()));

            goto Exit;
        }

        bNotifyThread = TRUE;
    }

    if ( !bMachine && g_Notif.hUserEvent == NULL )
    {
        g_Notif.hUserEvent = OpenEvent (SYNCHRONIZE, FALSE, USER_POLICY_APPLIED_EVENT);

        if ( g_Notif.hUserEvent == NULL ) {
            DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: CreateEvent failed with %d"),
                     GetLastError()));

            goto Exit;
        }

        bNotifyThread = TRUE;
    }

    if ( g_Notif.hThread == NULL )
    {
        DWORD dwThreadId;
        g_Notif.hThread = CreateThread( NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) NotificationThread,
                                        0,
                                        0,
                                        &dwThreadId );
        if ( g_Notif.hThread == NULL ) {
            DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: CreateThread failed with %d"),
                     GetLastError()));
            goto Exit;
        }

        bNotifyThread = TRUE;
    }

    if ( bNotifyThread )
    {
        //
        // Notify thread that there is a new workitem, possibly
        // user event has been added.
        //

        g_Notif.eWorkType = eMonitor;
        SetEvent( g_Notif.hThreadEvent );
    }

    //
    // Add event to beginning of list
    //

    pNotifInfo = (GPNOTIFINFO *) LocalAlloc( LPTR, sizeof(GPNOTIFINFO) );
    if ( pNotifInfo == NULL ) {
        DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: LocalAlloc failed with %d"),
                 GetLastError()));
        goto Exit;
    }

    pNotifInfo->hEvent = hEvent;
    pNotifInfo->bMachine = bMachine;
    pNotifInfo->pNext = g_Notif.pNotifList;
    g_Notif.pNotifList = pNotifInfo;

    bResult = TRUE;

Exit:

    LeaveCriticalSection( &g_NotifyCS );
    return bResult;
}


//*************************************************************
//
//  UnregisterGPNotification
//
//  Purpose:    Removes registration for a group policy change notification
//
//  Parameters: hEvent  -   Event to be removed
//
//  Return:     True if successful
//              False if error occurs
//
//*************************************************************

BOOL WINAPI UnregisterGPNotification( IN HANDLE hEvent )
{
    BOOL bFound = FALSE;
    GPNOTIFINFO *pTrailPtr = NULL;
    GPNOTIFINFO *pCurPtr = NULL;

    EnterCriticalSection( &g_NotifyCS );

    pCurPtr = g_Notif.pNotifList;

    while ( pCurPtr != NULL )
    {
        if ( pCurPtr->hEvent == hEvent )
        {
            //
            // Found match, so delete entry
            //
            if ( pTrailPtr == NULL )
            {
                //
                // First elem of list matched
                //
                g_Notif.pNotifList = pCurPtr->pNext;
            }
            else
                pTrailPtr->pNext = pCurPtr->pNext;

            LocalFree( pCurPtr );
            bFound = TRUE;
            break;
        }

        //
        // Advance down the list
        //

        pTrailPtr = pCurPtr;
        pCurPtr = pCurPtr->pNext;
    }

    LeaveCriticalSection( &g_NotifyCS );
    return bFound;
}


//*************************************************************
//
//  CGPNotification::NotificationThread
//
//  Purpose:    Separate thread for notifications
//
//  Returns:    0
//
//*************************************************************

DWORD WINAPI NotificationThread()
{
    DWORD cEvents = 2;
    BOOL fShutdown = FALSE;

    HINSTANCE hInst = LoadLibrary (TEXT("userenv.dll"));

    {
        EnterCriticalSection( &g_NotifyCS );

        //
        // The event fields in g_Notif are ordered as hThreadEvent,
        // hMachEvent and finally hUserEvent. The first two events have
        // to be successfully created in order for this thread to run
        // (see asserts). If the user event has been successfully created
        // then that too is monitored.
        //

        DmAssert( g_Notif.hThreadEvent != NULL && g_Notif.hMachEvent != NULL );

        if ( g_Notif.hUserEvent != NULL )
            cEvents = 3;

        LeaveCriticalSection( &g_NotifyCS );
    }

    while ( !fShutdown )
    {
        DWORD dwResult = WaitForMultipleObjects( cEvents,
                                                 &g_Notif.hThreadEvent,
                                                 FALSE,
                                                 INFINITE );

        EnterCriticalSection( &g_NotifyCS );

        if ( dwResult == WAIT_FAILED )
        {
            DebugMsg((DM_WARNING, TEXT("GPNotification: WaitforMultipleObjects failed")));
            fShutdown = TRUE;
        }
        else if ( dwResult == WAIT_OBJECT_0 )
        {
            ResetEvent( g_Notif.hThreadEvent );

            if ( g_Notif.eWorkType == eMonitor )
            {
                //
                // Start monitoring user events too
                //
                if ( g_Notif.hUserEvent != NULL )
                    cEvents = 3;
            }
            else
                fShutdown = TRUE;
        }
        else if ( dwResult == WAIT_OBJECT_0 + 1 || dwResult == WAIT_OBJECT_0 + 2 )
        {
            BOOL bMachine = (dwResult == WAIT_OBJECT_0 + 1);
            NotifyEvents( bMachine );

            if ( g_Notif.pNotifList == NULL )
                fShutdown = TRUE;
        }
        else
        {
            if ( dwResult == WAIT_ABANDONED_0 || dwResult == WAIT_ABANDONED_0 + 1 )
                fShutdown = TRUE;
            else
            {
                CloseHandle( g_Notif.hUserEvent );
                g_Notif.hUserEvent = NULL;

                cEvents = 2;
            }
        }

        if ( fShutdown )
        {
            //
            // Close all handles and thread
            //
            CloseHandle( g_Notif.hThreadEvent );
            g_Notif.hThreadEvent = NULL;

            if ( g_Notif.hMachEvent != NULL )
            {
                CloseHandle( g_Notif.hMachEvent );
                g_Notif.hMachEvent = NULL;
            }

            if ( g_Notif.hUserEvent != NULL )
            {
                CloseHandle( g_Notif.hUserEvent );
                g_Notif.hUserEvent = NULL;
            }

            CloseHandle( g_Notif.hThread );
            g_Notif.hThread = NULL;
        }

        LeaveCriticalSection( &g_NotifyCS );
    }

    if ( hInst != NULL )
        FreeLibraryAndExitThread (hInst, 0);

    return 0;
}


//*************************************************************
//
//  NotifyEvents
//
//  Purpose:    Notifies registered events
//
//  Parameters: bMachine  -   Is this a machine policy change ?
//
//*************************************************************

void NotifyEvents( BOOL bMachine )
{
    GPNOTIFINFO *pNotifInfo = NULL;

    pNotifInfo = g_Notif.pNotifList;
    while ( pNotifInfo != NULL )
    {
        if ( pNotifInfo->bMachine == bMachine )
        {
            SetEvent( pNotifInfo->hEvent );
        }

        pNotifInfo = pNotifInfo->pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gphdr.h ===
//*************************************************************
//
//  Policy specific headers
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "reghash.h"
#include "rsop.h"
#include "chkacc.h"
#include "collect.h"
#include "Indicate.h"
#include "rsopsec.h"
#include "gpfilter.h"
#include "locator.h"
#include "rsopinc.h"

#define GPO_LPARAM_FLAG_DELETE         0x00000001


//
// Structures
//

typedef struct _GPINFOHANDLE
{
    LPGPOINFO pGPOInfo;
} GPINFOHANDLE, *LPGPINFOHANDLE;


typedef struct _DNENTRY {
    LPTSTR                pwszDN;            // Distinguished name
    union {
        PGROUP_POLICY_OBJECT  pDeferredGPO;  // GPO corresponding to this DN
        struct _DNENTRY *     pDeferredOU;   // OU correspdonding to this DN
    };
    PLDAPMessage          pOUMsg;            // Message for evaluating deferred OU
    GPO_LINK              gpoLink;           // Type of GPO
    struct _DNENTRY *     pNext;             // Singly linked list pointer
} DNENTRY;


typedef struct _LDAPQUERY {
    LPTSTR              pwszDomain;          // Domain of subtree search
    LPTSTR              pwszFilter;          // Ldap filter for search
    DWORD               cbAllocLen;          // Allocated size of pwszFilter in bytes
    DWORD               cbLen;               // Size of pwszFilter currently used in bytes
    PLDAP               pLdapHandle;         // Ldap bind handle
    BOOL                bOwnLdapHandle;      // Does this struct own pLdapHandle ?
    PLDAPMessage        pMessage;            // Ldap message handle
    DNENTRY *           pDnEntry;            // Distinguished name entry
    struct _LDAPQUERY * pNext;               // Singly linked list pointer
} LDAPQUERY;

typedef struct _POLICYCHANGEDINFO {
    HANDLE  hToken;
    BOOL    bMachine;
} POLICYCHANGEDINFO, *LPPOLICYCHANGEDINFO;



//
// Verison number for the registry file format
//

#define REGISTRY_FILE_VERSION       1


//
// File signature
//

#define REGFILE_SIGNATURE  0x67655250


//
// Default refresh rate (minutes)
//
// Client machines will refresh every 90 minutes
// Domain controllers will refresh every 5 minutes
//

#define GP_DEFAULT_REFRESH_RATE      90
#define GP_DEFAULT_REFRESH_RATE_DC    5


//
// Default refresh rate max offset
//
// To prevent many clients from querying policy at the exact same
// time, a random amount is added to the refresh rate.  In the
// default case, a number between 0 and 30 will be added to
// 180 to determine when the next background refresh will occur
//

#define GP_DEFAULT_REFRESH_RATE_OFFSET    30
#define GP_DEFAULT_REFRESH_RATE_OFFSET_DC  0


//
// Max keyname size
//

#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512


//
// Max time to wait for the network to start (in ms)
//

#define MAX_WAIT_TIME            120000


//
// Extension registry path
//

#define GP_EXTENSIONS   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions")

//
// Path for extension preference policies
//

#define GP_EXTENSIONS_POLICIES   TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy\\%s")

//
// Group Policy Object option flags
//
// Note, this was taken from sdk\inc\gpedit.h
//

#define GPO_OPTION_DISABLE_USER     0x00000001  // The user portion of this GPO is disabled
#define GPO_OPTION_DISABLE_MACHINE  0x00000002  // The machine portion of this GPO is disabled

//
// DS Object class types
//

extern TCHAR szDSClassAny[];
extern TCHAR szDSClassGPO[];
extern TCHAR szDSClassSite[];
extern TCHAR szDSClassDomain[];
extern TCHAR szDSClassOU[];
extern TCHAR szObjectClass[];

//
// Extension name properties
//
#define GPO_MACHEXTENSION_NAMES   L"gPCMachineExtensionNames"
#define GPO_USEREXTENSION_NAMES   L"gPCUserExtensionNames"
#define GPO_FUNCTIONALITY_VERSION L"gPCFunctionalityVersion"
#define MACHPOLICY_DENY_USERS     L"DenyUsersFromMachGP"

extern TCHAR wszKerberos[];

#define POLICY_GUID_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PolicyGuid")

//
// Global flags for Gpo shutdown processing. These are accessed outside
// the lock because its value is either 0 or 1. Even if there is a race,
// all it means is that shutdown will start one iteration later.
//

extern BOOL g_bStopMachGPOProcessing;
extern BOOL g_bStopUserGPOProcessing;

//
// Critical section for handling concurrent, asynchronous completion
//

extern CRITICAL_SECTION g_GPOCS;

//
// Global pointers for maintaining asynchronous completion context
//

extern LPGPINFOHANDLE g_pMachGPInfo;
extern LPGPINFOHANDLE g_pUserGPInfo;


//
// Status UI critical section, callback, and proto-types
//

extern CRITICAL_SECTION g_StatusCallbackCS;
extern PFNSTATUSMESSAGECALLBACK g_pStatusMessageCallback;
DWORD UserPolicyCallback (BOOL bVerbose, LPWSTR lpMessage);
DWORD MachinePolicyCallback (BOOL bVerbose, LPWSTR lpMessage);


//
// Function proto-types
//

DWORD WINAPI GPOThread (LPGPOINFO lpGPOInfo);
extern "C" BOOL ProcessGPOs (LPGPOINFO lpGPOInfo);
DWORD WINAPI PolicyChangedThread (LPPOLICYCHANGEDINFO lpPolicyChangedInfo);
BOOL ResetPolicies (LPGPOINFO lpGPOInfo, LPTSTR lpArchive);
BOOL SetupGPOFilter (LPGPOINFO lpGPOInfo );
void FilterGPOs( LPGPEXT lpExt, LPGPOINFO lpGPOInfo );
void FreeLists( LPGPOINFO lpGPOInfo );
void FreeExtList(LPEXTLIST pExtList );
BOOL CheckGPOs (LPGPEXT lpExt, LPGPOINFO lpGPOInfo, DWORD dwTime, BOOL *pbProcessGPOs,
                BOOL *pbNoChanges, PGROUP_POLICY_OBJECT *ppDeletedGPOList);
BOOL CheckForChangedSid( LPGPOINFO lpGPOInfo, CLocator *plocator );
BOOL CheckForSkippedExtensions( LPGPOINFO lpGPOInfo, BOOL bRsopPlanningMode );
BOOL ReadGPExtensions( LPGPOINFO lpGPOInfo );
BOOL LoadGPExtension (LPGPEXT lpExt, BOOL bRsopPlanningMode );
BOOL UnloadGPExtensions (LPGPOINFO lpGPOInfo);
BOOL WriteStatus( TCHAR *lpExtName, LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser,  LPGPEXTSTATUS lpExtStatus );
void ReadStatus ( TCHAR *lpExtName, LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser,  LPGPEXTSTATUS lpExtStatus );
DWORD ProcessGPOList (LPGPEXT lpExt, LPGPOINFO lpGPOInfo, PGROUP_POLICY_OBJECT pDeletedGPOList,
                     PGROUP_POLICY_OBJECT pChangedGPOList, BOOL bNoChanges,
                     ASYNCCOMPLETIONHANDLE pAsyncHandle, HRESULT *phrCSERsopStatus );
BOOL ProcessGPORegistryPolicy (LPGPOINFO lpGPOInfo, PGROUP_POLICY_OBJECT pChangedGPOList, HRESULT *phrRsopLogging);
BOOL SaveGPOList (TCHAR *pszExtName, LPGPOINFO lpGPOInfo,
                  HKEY hKeyRootMach, LPTSTR lpwszSidUser, BOOL bShadow, PGROUP_POLICY_OBJECT lpGPOList);

BOOL AddGPO (PGROUP_POLICY_OBJECT * lpGPOList,
             DWORD dwFlags, BOOL bFound, BOOL bAccessGranted, BOOL bDisabled, DWORD dwOptions,
             DWORD dwVersion, LPTSTR lpDSPath, LPTSTR lpFileSysPath,
             LPTSTR lpDisplayName, LPTSTR lpGPOName, LPTSTR lpExtensions,
             PSECURITY_DESCRIPTOR pSD, DWORD cbSDLen,
             GPO_LINK GPOLink, LPTSTR lpLink,
             LPARAM lParam, BOOL bFront, BOOL bBlock, BOOL bVerbose, BOOL bProcessGPO);
BOOL RefreshDisplay (LPGPOINFO lpGPOInfo);
extern "C" DWORD IsSlowLink (HKEY hKeyRoot, LPTSTR lpDCAddress, BOOL *bSlow, DWORD* pdwAdapterIndex );
BOOL GetGPOInfo (DWORD dwFlags, LPTSTR lpHostName, LPTSTR lpDNName,
                 LPCTSTR lpComputerName, PGROUP_POLICY_OBJECT *lpGPOList,
                 LPSCOPEOFMGMT *ppSOMList, LPGPCONTAINER *ppGpContainerList,
                 PNETAPI32_API pNetAPI32, BOOL bMachineTokenOk, PRSOPTOKEN pRsopToken, WCHAR *pwszSiteName,
                 CGpoFilter *pGpoFilter, CLocator *pLocator );
void WINAPI ShutdownGPOProcessing( BOOL bMachine );
void DebugPrintGPOList( LPGPOINFO lpGPOInfo );

typedef BOOL (*PFNREGFILECALLBACK)(LPGPOINFO lpGPOInfo, LPTSTR lpKeyName,
                                   LPTSTR lpValueName, DWORD dwType,
                                   DWORD dwDataLength, LPBYTE lpData,
                                   WCHAR *pwszGPO,
                                   WCHAR *pwszSOM, REGHASHTABLE *pHashTable);
BOOL ParseRegistryFile (LPGPOINFO lpGPOInfo, LPTSTR lpRegistry,
                        PFNREGFILECALLBACK pfnRegFileCallback,
                        HANDLE hArchive, WCHAR *pwszGPO,
                        WCHAR *pwszSOM, REGHASHTABLE *pHashTable,
                        BOOL bRsopPlanningMode);
BOOL ExtensionHasPerUserLocalSetting( LPTSTR pszExtension, HKEY hKeyRoot );
void CheckGroupMembership( LPGPOINFO lpGPOInfo, HANDLE hToken, BOOL *pbMemChanged, BOOL *pbUserLocalMemChanged, PTOKEN_GROUPS *pTokenGroups );
BOOL ReadMembershipList( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, PTOKEN_GROUPS pGroups );
void SaveMembershipList( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, PTOKEN_GROUPS pGroups );
BOOL GroupInList( LPTSTR lpSid, PTOKEN_GROUPS pGroups );
DWORD GetCurTime();
extern "C" DWORD GetDomainControllerInfo(  PNETAPI32_API pNetAPI32, LPTSTR szDomainName,
                                ULONG ulFlags, HKEY hKeyRoot, PDOMAIN_CONTROLLER_INFO* ppInfo,
                                BOOL* pfSlow,
                                DWORD* pdwAdapterIndex );
PLDAP GetMachineDomainDS( PNETAPI32_API pNetApi32, PLDAP_API pLdapApi );
extern "C" HANDLE GetMachineToken();
NTSTATUS CallDFS(LPWSTR lpDomainName, LPWSTR lpDCName);
BOOL AddLocalGPO( LPSCOPEOFMGMT *ppSOMList );
BOOL AddGPOToRsopList( LPGPCONTAINER *ppGpContainerList,
                       DWORD dwFlags,
                       BOOL bFound,
                       BOOL bAccessGranted,
                       BOOL bDisabled,
                       DWORD dwVersion,
                       LPTSTR lpDSPath,
                       LPTSTR lpFileSysPath,
                       LPTSTR lpDisplayName,
                       LPTSTR lpGPOName,
                       PSECURITY_DESCRIPTOR pSD, 
                       DWORD cbSDLen,
                       BOOL bFilterAllowed, 
                       WCHAR *pwszFilterId, 
                       LPWSTR szSOM,
                       DWORD dwGPOOptions );
SCOPEOFMGMT *AllocSOM( LPWSTR pwszSOMId );
void FreeSOM( SCOPEOFMGMT *pSOM );
GPLINK *AllocGpLink( LPWSTR pwszGPO, DWORD dwOptions );
void FreeGpLink( GPLINK *pGpLink );
GPCONTAINER *AllocGpContainer(  DWORD dwFlags,
                                BOOL bFound,
                                BOOL bAccessGranted,
                                BOOL bDisabled,
                                DWORD dwVersion,
                                LPTSTR lpDSPath,
                                LPTSTR lpFileSysPath,
                                LPTSTR lpDisplayName,
                                LPTSTR lpGpoName,
                                PSECURITY_DESCRIPTOR pSD,
                                DWORD cbSDLen,
                                BOOL bFilterAllowed,
                                WCHAR *pwszFilterId,
                                LPWSTR szSOM,
                                DWORD dwOptions );
void FreeGpContainer( GPCONTAINER *pGpContainer );
void FreeSOMList( SCOPEOFMGMT *pSOMList );
void FreeGpContainerList( GPCONTAINER *pGpContainerList );
LONG GPOExceptionFilter( PEXCEPTION_POINTERS pExceptionPtrs );
BOOL FreeGpoInfo( LPGPOINFO pGpoInfo );

BOOL ReadExtStatus(LPGPOINFO lpGPOInfo);

BOOL ReadGPOList ( TCHAR * pszExtName, HKEY hKeyRoot,
                   HKEY hKeyRootMach, LPTSTR lpwszSidUser, BOOL bShadow,
                   PGROUP_POLICY_OBJECT * lpGPOList);

BOOL GetDeletedGPOList (PGROUP_POLICY_OBJECT lpGPOList,
                        PGROUP_POLICY_OBJECT *ppDeletedGPOList);

BOOL HistoryPresent( LPGPOINFO lpGPOInfo, LPGPEXT lpExt );


extern "C" BOOL InitializePolicyProcessing(BOOL bMachine);

BOOL FilterCheck( PLDAP pld, PLDAP_API pLDAP, 
                  PLDAPMessage pMessage,
                  PRSOPTOKEN pRsopToken,
                  LPTSTR szWmiFilter,
                  CGpoFilter *pGpoFilter,
                  CLocator *pLocator,
                  BOOL *pbFilterAllowed,
                  WCHAR **ppwszFilterId );

BOOL CheckGPOAccess (PLDAP pld, PLDAP_API pLDAP, HANDLE hToken, PLDAPMessage pMessage,
                     LPTSTR lpSDProperty, DWORD dwFlags,
                     PSECURITY_DESCRIPTOR *ppSD, DWORD *pcbSDLen,
                     BOOL *pbAccessGranted,
                     PRSOPTOKEN pRsopToken );


BOOL AddOU( DNENTRY **ppOUList, LPTSTR pwszOU, GPO_LINK gpoLink );
BOOL EvaluateDeferredGPOs (PLDAP pldBound,
                           PLDAP_API pLDAP,
                           LPTSTR pwszDomainBound,
                           DWORD dwFlags,
                           HANDLE hToken,
                           BOOL bVerbose,
                           PGROUP_POLICY_OBJECT pDeferredForcedList,
                           PGROUP_POLICY_OBJECT pDeferredNonForcedList,
                           PGROUP_POLICY_OBJECT *ppForcedList,
                           PGROUP_POLICY_OBJECT *ppNonForcedList,
                           LPGPCONTAINER *ppGpContainerList,
                           PRSOPTOKEN pRsopToken,
                           CGpoFilter *pGpoFilter,
                           CLocator *pLocator );

BOOL SearchDSObject (LPTSTR lpDSObject, DWORD dwFlags, HANDLE hToken, PGROUP_POLICY_OBJECT *pGPOForcedList,
                     PGROUP_POLICY_OBJECT *pGPONonForcedList,
                     LPSCOPEOFMGMT *ppSOMList, LPGPCONTAINER *ppGpContainerList,
                     BOOL bVerbose,
                     GPO_LINK GPOLink, PLDAP  pld, PLDAP_API pLDAP, PLDAPMessage pLDAPMsg,BOOL *bBlock, PRSOPTOKEN pRsopToken );

BOOL EvaluateDeferredOUs(   DNENTRY *pOUList,
                            DWORD dwFlags,
                            HANDLE hToken,
                            PGROUP_POLICY_OBJECT *ppDeferredForcedList,
                            PGROUP_POLICY_OBJECT *ppDeferredNonForcedList,
                            LPSCOPEOFMGMT *ppSOMList,
                            LPGPCONTAINER *ppGpContainerList,
                            BOOL bVerbose,
                            PLDAP  pld,
                            PLDAP_API pLDAP,
                            BOOL *pbBlock,
                            PRSOPTOKEN pRsopToken);

void FreeDnEntry( DNENTRY *pDnEntry );

BOOL CheckOUAccess( PLDAP_API pLDAP,
                    PLDAP pld,
                    PLDAPMessage    pMessage,
                    PRSOPTOKEN pRsopToken,
                    BOOL *pbAccessGranted );

BOOL AddAdmFile( WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite, LPTSTR szComputer, ADMFILEINFO **ppAdmFileCache );
void FreeAdmFileCache( ADMFILEINFO *pAdmFileCache );

ADMFILEINFO * AllocAdmFileInfo( WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite );
void FreeAdmFileInfo( ADMFILEINFO *pAdmFileInfo );

DWORD
SavePolicyState( LPGPOINFO pInfo );

DWORD
SaveLinkState( LPGPOINFO pInfo );

DWORD
ComparePolicyState( LPGPOINFO pInfo, BOOL* pbLinkChanged, BOOL* pbStateChanged, BOOL *pbNoState );

DWORD
DeletePolicyState( LPCWSTR szSid );

LPTSTR GetSomPath( LPTSTR szContainer );
HRESULT RsopSidsFromToken(PRSOPTOKEN     pRsopToken,
                          PTOKEN_GROUPS* ppGroups);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gplist.cpp ===
//*************************************************************
//
//  Group Policy Support - Getting the list of gpos
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"

//*************************************************************
//
//  DsQuoteSearchFilter()
//
// 
//  Comment:  This function takes a DN and returns a version
//            of the DN escaped according to RFC's 2253 and 2254
//
//  Return:   A pointer to the quoted string, which must be
//            freed by the caller.  If the function fails, the
//            return value is 0.
//
//*************************************************************
LPWSTR
DsQuoteSearchFilter( LPCWSTR szUDN )
{
    DWORD   cUDN = wcslen( szUDN );
    LPWSTR  szQDN = 0, szTemp = 0;;

    //
    // Note that the maximum length of the quoted string would result
    // if every single character in the DN needed to be escaped.  Since
    // the escaped characters are of the form '\nn', the escaped string 
    // could be at most 3 times the size of the original string
    //
    if ( cUDN )
    {
        szTemp = szQDN = (LPWSTR) LocalAlloc( LPTR, ( cUDN * 3 + 1 ) * sizeof( WCHAR ) );
    }

    if ( !szQDN )
    {
        return 0;
    }
    
    while ( *szUDN )
    {
        WCHAR   szBuffer[16];
        
        if ( *szUDN == L'*' || *szUDN == L'(' || *szUDN == L')' || !*szUDN )
        {
            //
            // convert special characters to \NN
            //
            *szQDN++ = L'\\';
            wcscat( szQDN, _itow( *szUDN++, szBuffer, 16 ) );
            szQDN += 2;
        }
        else
        {
            *szQDN++ = *szUDN++;
        }
    }
    *szQDN = 0;

    return szTemp;
}

//*************************************************************
//
//  GetGPOInfo()
//
//  Purpose:    Gets the GPO info for this threads token.
//
//  Parameters: dwFlags         -   GPO_LIST_FLAG_* from userenv.h
//              lpHostName      -   Domain DN name or DC server name
//              lpDNName        -   User or Machine DN name
//              lpComputerName  -   Computer name used for site look up
//              lpGPOList       -   Receives the list of GROUP_POLICY_OBJECTs
//              ppSOMList       -   List of LSDOUs returned here
//              ppGpContainerList - List of Gp containers returned here
//              pNetAPI32       -   Netapi32 function table
//              bMachineTokenOK -   Ok to query for the machine token
//              pRsopToken      -   Rsop security token
//              pGpoFilter      -   Gpo filter
//              pLocator        -   WMI interfaces
//
//  Comment:    This is a link list of GROUP_POLICY_OBJECTs.  Each can be
//              free'ed with LocalFree() or calling FreeGPOList()
//
//              The processing sequence is:
//
//              Local Forest Site Domain OrganizationalUnit
//
//              Note that we process this list backwards to get the
//              correct sequencing for the force flag.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetGPOInfo(DWORD dwFlags,
                LPTSTR lpHostName,
                LPTSTR lpDNName,
                LPCTSTR lpComputerName,
                PGROUP_POLICY_OBJECT *lpGPOList,
                LPSCOPEOFMGMT *ppSOMList,
                LPGPCONTAINER *ppGpContainerList,
                PNETAPI32_API pNetAPI32,
                BOOL bMachineTokenOk,
                PRSOPTOKEN pRsopToken,
                LPWSTR pwszSiteName,
                CGpoFilter *pGpoFilter,
                CLocator *pLocator )
{
    PGROUP_POLICY_OBJECT pGPOForcedList = NULL, pGPONonForcedList = NULL;
    PLDAP  pld = NULL;
    ULONG ulResult;
    BOOL bResult = FALSE;
    BOOL bBlock = FALSE;
    LPTSTR lpDSObject, lpTemp;
    PLDAPMessage pLDAPMsg = NULL;
    TCHAR szGPOPath[MAX_PATH];
    TCHAR szGPOName[50];
    BOOL bVerbose, bDisabled;
    DWORD dwVersion, dwOptions;
    TCHAR szNamingContext[] = TEXT("configurationNamingContext");
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor"); // this is unused currently
    LPTSTR lpAttr[] = { szNamingContext,
                        szSDProperty,
                        0 };

    PGROUP_POLICY_OBJECT lpGPO, lpGPOTemp;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    PLDAP_API pldap_api;
    HANDLE hToken = NULL, hTempToken;
    DWORD dwFunctionalityVersion;
    PGROUP_POLICY_OBJECT pDeferredForcedList = NULL, pDeferredNonForcedList = NULL;
    DNENTRY *pDeferredOUList = NULL;    // List of deferred OUs
    TCHAR*  szDN;
    PSECUR32_API pSecur32Api;
    BOOL    bAddedOU = FALSE;
    PLDAP   pldMachine = 0;
    VOID *pData;
    BOOL bOwnSiteName = FALSE;
    BOOL bRsopLogging = (ppSOMList != 0);
    BOOL bRsopPlanningMode = (pRsopToken != 0);
    XLastError xe;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  ********************************")));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Entering...")));


    //
    // Start with lpGPOList being a pointer to null
    //

    *lpGPOList = NULL;

    DmAssert( *ppSOMList == NULL );
    DmAssert( *ppGpContainerList == NULL );

    //
    // Check if we should be verbose to the event log
    //

    bVerbose = CheckForVerbosePolicy();


    //
    // Load the secur32 api
    //

    pSecur32Api = LoadSecur32();

    if (!pSecur32Api) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to load secur32 api.")));
        goto Exit;
    }

    //
    // Load the ldap api
    //

    pldap_api = LoadLDAP();

    if (!pldap_api) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to load ldap api.")));
        goto Exit;
    }

    //=========================================================================
    //
    // If we don't have a DS server or user / machine name, we can
    // skip the DS stuff and only check for a local GPO
    //
    //=========================================================================

    if (!lpHostName || !lpDNName) {
        DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  lpHostName or lpDNName is NULL.  Skipping DS stuff.")));
        goto CheckLocal;
    }


    //
    // Get the user or machine's token
    //

    if (bMachineTokenOk && (dwFlags & GPO_LIST_FLAG_MACHINE)) {

        hToken = GetMachineToken();

        if (!hToken) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to get the machine token with  %d"),
                     GetLastError()));

            CEvents ev(TRUE, EVENT_FAILED_MACHINE_TOKEN);
            ev.AddArgWin32Error(xe); ev.Report();
            goto Exit;
        }

    } else {

        if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                              TRUE, &hTempToken)) {
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                                  &hTempToken)) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to get a token with  %d"),
                         GetLastError()));
                goto Exit;
            }
        }


        //
        // Duplicate it so it can be used for impersonation
        //

        if (!DuplicateTokenEx(hTempToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                              NULL, SecurityImpersonation, TokenImpersonation,
                              &hToken))
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to duplicate the token with  %d"),
                     GetLastError()));
            CloseHandle (hTempToken);
            goto Exit;
        }

        CloseHandle (hTempToken);
    }


    //
    // Get a connection to the DS
    //

    if ((lpHostName[0] == TEXT('\\')) && (lpHostName[1] == TEXT('\\')))  {
        lpHostName = lpHostName + 2;
    }

    pld = pldap_api->pfnldap_init( lpHostName, LDAP_PORT);

    if (!pld) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  ldap_open for <%s> failed with = 0x%x or %d"),
                 lpHostName, pldap_api->pfnLdapGetLastError(), GetLastError()));

        CEvents ev(TRUE, EVENT_FAILED_DS_CONNECT);
        ev.AddArg(lpHostName); ev.AddArgLdapError(pldap_api->pfnLdapGetLastError()); ev.Report();

        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Server connection established.")));

    //
    // Turn on Packet integrity flag
    //

    pData = (VOID *) LDAP_OPT_ON;
    ulResult = pldap_api->pfnldap_set_option(pld, LDAP_OPT_SIGN, &pData);

    if (ulResult != LDAP_SUCCESS) {
        xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to turn on LDAP_OPT_SIGN with %d"), ulResult));
        goto Exit;
    }

    ulResult = pldap_api->pfnldap_connect(pld, 0);

    if (ulResult != LDAP_SUCCESS) {
        xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to connect with %d"), ulResult));
        pldap_api->pfnldap_unbind(pld);
        pld = 0;
        goto Exit;
    }

    //
    // Bind to the DS.
    //

    if ( !bRsopPlanningMode && (dwFlags & GPO_LIST_FLAG_MACHINE) ) {

        //
        // For machine policies specifically ask for Kerberos as the only authentication
        // mechanism. Otherwise if Kerberos were to fail for some reason, then NTLM is used
        // and localsystem context has no real credentials, which means that we won't get
        // any GPOs back.
        //

        SEC_WINNT_AUTH_IDENTITY_EXW secIdentity;

        secIdentity.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        secIdentity.Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
        secIdentity.User = 0;
        secIdentity.UserLength = 0;
        secIdentity.Domain = 0;
        secIdentity.DomainLength = 0;
        secIdentity.Password = 0;
        secIdentity.PasswordLength = 0;
        secIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        secIdentity.PackageList = wszKerberos;
        secIdentity.PackageListLength = lstrlen( wszKerberos );

        ulResult = pldap_api->pfnldap_bind_s (pld, NULL, (WCHAR *)&secIdentity, LDAP_AUTH_SSPI);

    } else
        ulResult = pldap_api->pfnldap_bind_s (pld, NULL, NULL, LDAP_AUTH_SSPI);

    if (ulResult != LDAP_SUCCESS) {
       xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
       DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  ldap_bind_s failed with = <%d>"),
                ulResult));
       CEvents ev(TRUE, EVENT_FAILED_DS_BIND);
       ev.AddArg(lpHostName); ev.AddArgLdapError(ulResult); ev.Report();
       goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Bound successfully.")));


    //=========================================================================
    //
    // Check the organizational units and domain for policy
    //
    //=========================================================================


    if (!(dwFlags & GPO_LIST_FLAG_SITEONLY)) {

        //
        // Loop through the DN Name to find each OU or the domain
        //

        lpDSObject = lpDNName;

        while (*lpDSObject) {

            //
            // See if the DN name starts with OU=
            //

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                               lpDSObject, 3, TEXT("OU="), 3) == CSTR_EQUAL) {
                if ( !AddOU( &pDeferredOUList, lpDSObject, GPLinkOrganizationalUnit ) ) {
                    xe = GetLastError();
                    goto Exit;
                }
            }

            //
            // See if the DN name starts with DC=
            //

            else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                    lpDSObject, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
                if ( !AddOU( &pDeferredOUList, lpDSObject, GPLinkDomain ) ) {
                    xe = GetLastError();
                    goto Exit;
                }


                //
                // Now that we've found a DN name that starts with DC=
                // we exit the loop now.
                //

                break;
            }


            //
            // Move to the next chunk of the DN name
            //

            while (*lpDSObject && (*lpDSObject != TEXT(','))) {
                lpDSObject++;
            }

            if (*lpDSObject == TEXT(',')) {
                lpDSObject++;
            }
        }

        //
        // Evaluate deferred OUs with single Ldap query
        //

        if ( !EvaluateDeferredOUs(  pDeferredOUList,
                                    dwFlags,
                                    hToken,
                                    &pDeferredForcedList,
                                    &pDeferredNonForcedList,
                                    ppSOMList,
                                    ppGpContainerList,
                                    bVerbose,
                                    pld,
                                    pldap_api,
                                    &bBlock,
                                    pRsopToken ) )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  EvaluateDeferredOUs failed. Exiting") ));
            goto Exit;
        }
    }


    //=========================================================================
    //
    // Check the site object for policy
    //
    //=========================================================================

    //
    // Now we need to query for the domain name.
    //

    //
    // Now we need to query for the domain name.  This is done by
    // reading the operational attribute configurationNamingContext
    //

    if (pwszSiteName) {
        pldMachine = GetMachineDomainDS( pNetAPI32, pldap_api );

        if ( pldMachine )
        {
            pLDAPMsg = 0;

            ulResult = pldap_api->pfnldap_search_s( pldMachine,
                                                    TEXT(""),
                                                    LDAP_SCOPE_BASE,
                                                    TEXT("(objectClass=*)"),
                                                    lpAttr,
                                                    FALSE,
                                                    &pLDAPMsg);


            if ( ulResult == LDAP_SUCCESS )
            {
                LPTSTR* pszValues = pldap_api->pfnldap_get_values( pldMachine, pLDAPMsg, szNamingContext );

                if ( pszValues )
                {
                    TCHAR   szSite[512];
                    //
                    // Combine the domain name + site name to get the full
                    // DS object path
                    //

                    wsprintf( szSite, TEXT("CN=%s,CN=Sites,%s"), pwszSiteName, *pszValues );


                    if (SearchDSObject (szSite, dwFlags, hToken, &pDeferredForcedList, &pDeferredNonForcedList,
                                        ppSOMList, ppGpContainerList,
                                        bVerbose, GPLinkSite, pldMachine,
                                        pldap_api, NULL, &bBlock, pRsopToken )) {

                        bAddedOU = TRUE;

                    } else {
                        xe = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  SearchDSObject failed.  Exiting.")));
                    }

                    pldap_api->pfnldap_value_free( pszValues );
                }
                else
                {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to get values.")));
                }

                pldap_api->pfnldap_msgfree( pLDAPMsg );
            }
            else
            {
                xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  ldap_search_s failed with = <%d>"), ulResult) );
                CEvents ev(TRUE, EVENT_FAILED_ROOT_SEARCH);
                ev.AddArgLdapError(ulResult); ev.Report();
            }
        }
        
        if ( !bAddedOU )
        {
            goto Exit;
        }
    }

#ifdef FGPO_SUPPORTED


    //=========================================================================
    //
    // Now query for the forest GPO
    //
    //=========================================================================

    pLDAPMsg = 0;

    ulResult = pldap_api->pfnldap_search_s( pld,
                                            TEXT(""),
                                            LDAP_SCOPE_BASE,
                                            TEXT("(objectClass=*)"),
                                            lpAttr,
                                            FALSE,
                                            &pLDAPMsg);


    if ( ulResult == LDAP_SUCCESS )
    {
        LPTSTR* pszValues = pldap_api->pfnldap_get_values( pld, pLDAPMsg, szNamingContext );

        if (pszValues) {
            if (SearchDSObject (*pszValues, dwFlags, hToken, &pDeferredForcedList, &pDeferredNonForcedList,
                                ppSOMList, ppGpContainerList,
                                bVerbose, GPLinkForest, pld,
                                pldap_api, NULL, &bBlock, pRsopToken )) {

                bAddedOU = TRUE;
            }
            else {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  SearchDSObject failed for forest GPOs.  Exiting.")));
            }
            
            pldap_api->pfnldap_value_free( pszValues );
        }
        else
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to get values for user config container.")));
        }
        
        pldap_api->pfnldap_msgfree( pLDAPMsg );
    }
    else
    {
        xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  ldap_search_s failed with = <%d>"), ulResult) );
        CEvents ev(TRUE, EVENT_FAILED_ROOT_SEARCH);
        ev.AddArgLdapError(ulResult); ev.Report();
    }

    
    if ( !bAddedOU )
    {
        goto Exit;
    }

#endif

CheckLocal:

    //
    // Evaluate all GPOs deferred so far with single Ldap query
    //

    if ( !EvaluateDeferredGPOs( pld,
                                pldap_api,
                                lpHostName,
                                dwFlags,
                                hToken,
                                bVerbose,
                                pDeferredForcedList,
                                pDeferredNonForcedList,
                                &pGPOForcedList,
                                &pGPONonForcedList,
                                ppGpContainerList,
                                pRsopToken,
                                pGpoFilter, pLocator ) )
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  EvaluateDeferredGPOs failed. Exiting") ));
        goto Exit;
    }


    //=========================================================================
    //
    // Check if we have a local GPO. If so, add it to the list. In planning mode
    // local Gpo processing is omitted because planning mode is generated on a DC
    // and local Gpo should refer to Gpo on the target computer.
    //
    //=========================================================================

    if (!bRsopPlanningMode && !(dwFlags & GPO_LIST_FLAG_SITEONLY)) {

        BOOL bDisabled = FALSE;
        BOOL bOldGpoVersion = FALSE;
        BOOL bNoGpoData = FALSE;
        DWORD dwSize = MAX_PATH;
        DWORD dwCount = 0;
        BOOL bOk = FALSE;
        TCHAR *pszExtensions = 0;
        BOOL bGptIniExists = FALSE;

        //
        // If the gpt.ini doesn't exist because this is a clean installed machine,
        // we manufacture default state for it here -- these values must be
        // initialized since they normally require the gpt.ini
        //

        dwFunctionalityVersion = 2;
        dwOptions = 0;
        bDisabled = FALSE;
        dwVersion = 0;
        bNoGpoData = TRUE;

        //
        // Retrieve the gpo path
        //

        ExpandEnvironmentStrings (LOCAL_GPO_DIRECTORY, szGPOPath, ARRAYSIZE(szGPOPath));

        //
        // We check for the existence of gpt.ini -- note that if it does not exist,
        // we will use the default state initialized earlier to represent this gpo --
        // this mimics the behavior of the gp engine, which does not distinguish between
        // different types of failures to access gpt.ini -- if access fails for any reason,
        // it is treated as the local gpo in the default (clean installed) case
        //
        if (GetFileAttributesEx (szGPOPath, GetFileExInfoStandard, &fad) &&
            (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            bGptIniExists = TRUE;
        } else {

            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Local GPO's gpt.ini is not accessible, assuming default state.") ));
        }

        //
        // Retrieve the gpo name
        //

        LoadString (g_hDllInstance, IDS_LOCALGPONAME, szGPOName, ARRAYSIZE(szGPOName));

        DmAssert( lstrlen(szGPOPath) + lstrlen(TEXT("gpt.ini")) + 1 < MAX_PATH );

        lpTemp = CheckSlash (szGPOPath);
        lstrcpy (lpTemp, TEXT("gpt.ini"));

        //
        // Read the gpt.ini file if it exists -- otherwise the default values will be used
        //

        if ( bGptIniExists ) {

            bNoGpoData = FALSE;

            //
            // Check the functionalty version number
            //

            dwFunctionalityVersion = GetPrivateProfileInt(TEXT("General"), GPO_FUNCTIONALITY_VERSION, 2, szGPOPath);
            if (dwFunctionalityVersion < 2) {

                bOldGpoVersion = TRUE;

                DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  GPO %s was created by an old version of the Group Policy Editor.  It will be skipped."), szGPOName));
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_GPO_TOO_OLD);
                    ev.AddArg(szGPOName); ev.Report();
                }

            }

            //
            // Check if this GPO is enabled
            //

            dwOptions = GetPrivateProfileInt(TEXT("General"), TEXT("Options"), 0, szGPOPath);

            if (((dwFlags & GPO_LIST_FLAG_MACHINE) &&
                 (dwOptions & GPO_OPTION_DISABLE_MACHINE)) ||
                 (!(dwFlags & GPO_LIST_FLAG_MACHINE) &&
                 (dwOptions & GPO_OPTION_DISABLE_USER))) {
                 bDisabled = TRUE;
            }

            //
            // Check if the version number is 0, if so there isn't any data
            // in the GPO and we can skip it
            //

            dwVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, szGPOPath);

            if (dwFlags & GPO_LIST_FLAG_MACHINE) {
                dwVersion = MAKELONG (LOWORD(dwVersion), LOWORD(dwVersion));
            } else {
                dwVersion = MAKELONG (HIWORD(dwVersion), HIWORD(dwVersion));
            }

            if (dwVersion == 0) {

                bNoGpoData = TRUE;
                DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  GPO %s doesn't contain any data since the version number is 0.  It will be skipped."), szGPOName));
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_GPO_NO_DATA);
                    ev.AddArg(szGPOName); ev.Report();
                }

            }

            //
            // Read list of extension guids
            //

            pszExtensions = (LPWSTR) LocalAlloc( LPTR, dwSize * sizeof(TCHAR) );
            if ( pszExtensions == 0 ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to allocate memory.")));
                goto Exit;
            }

            dwCount = GetPrivateProfileString( TEXT("General"),
                                               dwFlags & GPO_LIST_FLAG_MACHINE ? GPO_MACHEXTENSION_NAMES
                                                                               : GPO_USEREXTENSION_NAMES,
                                               TEXT(""),
                                               pszExtensions,
                                               dwSize,
                                               szGPOPath );

            while ( dwCount == dwSize - 1 )
            {
                //
                // Value has been truncated, so retry with larger buffer
                //

                LocalFree( pszExtensions );

                dwSize *= 2;
                pszExtensions = (LPWSTR) LocalAlloc( LPTR, dwSize * sizeof(TCHAR) );
                if ( pszExtensions == 0 ) {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to allocate memory.")));
                    goto Exit;
                }

                dwCount = GetPrivateProfileString( TEXT("General"),
                                                   dwFlags & GPO_LIST_FLAG_MACHINE ? GPO_MACHEXTENSION_NAMES
                                                                                   : GPO_USEREXTENSION_NAMES,
                                                   TEXT(""),
                                                   pszExtensions,
                                                   dwSize,
                                                   szGPOPath );
            }

            if ( lstrcmpi( pszExtensions, TEXT("")) == 0 || lstrcmpi( pszExtensions, TEXT(" ")) == 0 ) {
                //
                // Extensions property was not found
                //


                LocalFree( pszExtensions );
                pszExtensions = 0;
            }
        }

        //
        // Tack on the correct subdirectory name
        //

        DmAssert( lstrlen(szGPOPath) + lstrlen(TEXT("Machine")) + 1 < MAX_PATH );

        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            lstrcpy (lpTemp, TEXT("Machine"));
        } else {
            lstrcpy (lpTemp, TEXT("User"));
        }


        //
        // Add this to the list of paths
        //

        if ( bRsopLogging ) {

            bOk = AddLocalGPO( ppSOMList );
            if ( !bOk ) {
                xe = GetLastError();
                if ( pszExtensions )
                    LocalFree( pszExtensions );
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to log Rsop data.")));
                goto Exit;
            }

            bOk = AddGPOToRsopList( ppGpContainerList,
                                    dwFlags,
                                    TRUE,
                                    TRUE,
                                    bDisabled, 
                                    dwVersion,
                                    L"LocalGPO",
                                    szGPOPath,
                                    szGPOName,
                                    szGPOName, 
                                    0,
                                    0,
                                    TRUE,
                                    0,
                                    L"Local",
                                    0 );
            if ( !bOk ) {
                xe = GetLastError();
                if ( pszExtensions )
                    LocalFree( pszExtensions );
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to log Rsop data.")));
                goto Exit;
            }

        }

        if ( !bDisabled && !bOldGpoVersion && !bNoGpoData )
        {

            bOk = AddGPO (&pGPONonForcedList, dwFlags, TRUE, TRUE, bDisabled, 0, dwVersion,
                          L"LocalGPO", szGPOPath,
                          szGPOName, szGPOName, pszExtensions, 0, 0, GPLinkMachine, L"Local", 0, TRUE,
                          FALSE, bVerbose, TRUE);
        }

        if ( pszExtensions )
            LocalFree( pszExtensions );

        if ( bOk ) {
            if ( bVerbose ) {
                if ( bDisabled || bOldGpoVersion || bNoGpoData ) {
                    CEvents ev(FALSE, EVENT_NO_LOCAL_GPO);
                    ev.Report();
                }
                else {
                    CEvents ev(FALSE, EVENT_FOUND_LOCAL_GPO);
                    ev.Report();
                }
            }
        } else {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to add local group policy object to the list.")));
            goto Exit;
        }
    }

    //
    // Merge the forced and nonforced lists together
    //

    if (pGPOForcedList && !pGPONonForcedList) {

        *lpGPOList = pGPOForcedList;

    } else if (!pGPOForcedList && pGPONonForcedList) {

        *lpGPOList = pGPONonForcedList;

    } else if (pGPOForcedList && pGPONonForcedList) {

        lpGPO = pGPONonForcedList;

        while (lpGPO->pNext) {
            lpGPO = lpGPO->pNext;
        }

        lpGPO->pNext = pGPOForcedList;
        pGPOForcedList->pPrev = lpGPO;

        *lpGPOList = pGPONonForcedList;
    }


    //
    // Success
    //

    bResult = TRUE;

Exit:

    //
    // Free any GPOs we found
    //

    if (!bResult) {
        FreeGPOList( pGPOForcedList );
        FreeGPOList( pGPONonForcedList );
    }

    //
    // Free temporary OU list
    //

    while ( pDeferredOUList ) {
        DNENTRY *pTemp = pDeferredOUList->pNext;
        FreeDnEntry( pDeferredOUList );
        pDeferredOUList = pTemp;
    }

    //
    // Free temporary deferred GPO lists
    //

    FreeGPOList( pDeferredForcedList );
    FreeGPOList( pDeferredNonForcedList );

    if (pld) {
        pldap_api->pfnldap_unbind (pld);
    }

    if ( pldMachine )
    {
        pldap_api->pfnldap_unbind( pldMachine );
    }

    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Leaving with %d"), bResult));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  ********************************")));

    if ( hToken )
    {
        CloseHandle( hToken );
    }

    return bResult;
}

//*************************************************************
//
//  GetGPOList()
//
//  Purpose:    Retreives the list of GPOs for the specified
//              user or machine
//
//  Parameters:  hToken     - User or machine token, if NULL,
//                            lpName and lpDCName must be supplied
//               lpName     - User or machine name in DN format,
//                            if hToken is supplied, this must be NULL
//               lpHostName - Host name.  This should be a domain's
//                            dn name for best performance.  Otherwise
//                            it can also be a DC name.  If hToken is supplied,
//                            this must be NULL
//               lpComputerName - Computer named used to determine site
//                                information.  Can be NULL which means
//                                use the local machine
//               dwFlags  - Flags field
//               pGPOList - Address of a pointer which receives
//                          the link list of GPOs
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI GetGPOList (HANDLE hToken, LPCTSTR lpName, LPCTSTR lpHostName,
                        LPCTSTR lpComputerName, DWORD dwFlags,
                        PGROUP_POLICY_OBJECT *pGPOList)
{
    PDOMAIN_CONTROLLER_INFO pDCI = NULL;
    TCHAR szDomainDN[200];
    BOOL bResult = FALSE;
    LPTSTR lpDomainDN, lpDNName, lpTemp, lpDomain = NULL, lpUserName = NULL;
    DWORD dwResult;
    HANDLE hOldToken = 0;
    PNETAPI32_API pNetAPI32;
    LPSCOPEOFMGMT lpSOMList = 0;         // LSDOU list
    LPGPCONTAINER lpGpContainerList = 0; // GP container list
    HRESULT hr;
    OLE32_API *pOle32Api = NULL;
    XLastError xe;
    LPWSTR szSiteName = NULL;


    //
    // mask off the flags that are used internally.
    //
    dwFlags &= FLAG_INTERNAL_MASK;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("GetGPOList: Entering.")));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  hToken = 0x%x"), (hToken ? hToken : 0)));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  lpName = <%s>"), (lpName ? lpName : TEXT("NULL"))));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  lpHostName = <%s>"), (lpHostName ? lpHostName : TEXT("NULL"))));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  dwFlags = 0x%x"), dwFlags));


    //
    // Check parameters
    //

    if (hToken) {
        if (lpName || lpHostName) {
            xe = ERROR_INVALID_PARAMETER;
            DebugMsg((DM_WARNING, TEXT("GetGPOList: lpName and lpHostName must be NULL")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    } else {
        if (!lpName || !lpHostName) {
            xe = ERROR_INVALID_PARAMETER;
            DebugMsg((DM_WARNING, TEXT("GetGPOList: lpName and lpHostName must be valid")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    if (!pGPOList) {
        xe = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("GetGPOList: pGPOList is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Load netapi32
    //

    pNetAPI32 = LoadNetAPI32();

    if (!pNetAPI32) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOList:  Failed to load netapi32 with %d."),
                 GetLastError()));
        goto Exit;
    }


    //
    // If an hToken was offered, then we need to get the name and
    // domain DN name
    //

    if (hToken) {

        //
        // Impersonate the user / machine
        //

        if (!ImpersonateUser(hToken, &hOldToken)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOList: Failed to impersonate user")));
            return FALSE;
        }


        //
        // Get the username in DN format
        //

        lpUserName = MyGetUserName (NameFullyQualifiedDN);

        if (!lpUserName) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  MyGetUserName failed for DN style name with %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_USERNAME);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }

        lpDNName = lpUserName;
        DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  Queried lpDNName = <%s>"), lpDNName));


        //
        // Get the username in NT4 format
        //

        lpDomain = MyGetUserName (NameSamCompatible);

        if (!lpDomain) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  MyGetUserName failed for NT4 style name with %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_USERNAME);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }


        //
        // Look for the \ between the domain and username and replace
        // it with a NULL
        //

        lpTemp = lpDomain;

        while (*lpTemp && ((*lpTemp) != TEXT('\\')))
            lpTemp++;


        if (*lpTemp != TEXT('\\')) {
            xe = ERROR_INVALID_PARAMETER;
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  Failed to find slash in NT4 style name:  <%s>"),
                     lpDomain));
            goto Exit;
        }

        *lpTemp = TEXT('\0');


        //
        // Check this domain for a DC
        //

        dwResult = pNetAPI32->pfnDsGetDcName (NULL, lpDomain, NULL, NULL,
                                   DS_DIRECTORY_SERVICE_PREFERRED |
                                   DS_IS_FLAT_NAME |
                                   DS_RETURN_DNS_NAME,
                                   &pDCI);

        if (dwResult != ERROR_SUCCESS) {
            xe = dwResult;
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  DSGetDCName failed with %d for <%s>"),
                     dwResult, lpDomain));
            goto Exit;
        }


        //
        // Found a DC, does it have a DS ?
        //

        if (!(pDCI->Flags & DS_DS_FLAG)) {
            xe = ERROR_DS_DS_REQUIRED;
            pNetAPI32->pfnNetApiBufferFree(pDCI);
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  The domain <%s> does not have a DS"),
                     lpDomain));
            goto Exit;
        }

        lstrcpyn (szDomainDN, pDCI->DomainName, ARRAYSIZE(szDomainDN));
        lpDomainDN = szDomainDN;
        DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  lpDomainDN = <%s>"), lpDomainDN));

        pNetAPI32->pfnNetApiBufferFree(pDCI);

    } else {

        //
        // Use the server and DN name passed in
        //

        lpDomainDN = (LPTSTR)lpHostName;
        lpDNName = (LPTSTR)lpName;
    }

    pOle32Api = LoadOle32Api();
    if ( pOle32Api == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOList: Failed to load ole32.dll.") ));
        goto Exit;
    }

    hr = pOle32Api->pfnCoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

    if ( FAILED(hr) ) {
        xe = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("GetGPOList: CoInitializeEx failed with 0x%x."), hr ));
        goto Exit;
    }


    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, 
                     RPC_C_AUTHN_LEVEL_DEFAULT, /* this should be the current value */
                     RPC_C_IMP_LEVEL_IMPERSONATE,
                     NULL, EOAC_NONE, NULL);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("GetGPOList: CoInitializeSecurity failed with 0x%x"), hr ));
    }

    //
    // Call to get the list of GPOs
    //
    dwResult = pNetAPI32->pfnDsGetSiteName(lpComputerName,  &szSiteName);

    if ( dwResult != ERROR_SUCCESS )
    {
        if ( dwResult != ERROR_NO_SITENAME )
        {
            xe = dwResult;
            DebugMsg((DM_WARNING, TEXT("GetGPOList: DSGetSiteName failed, exiting. 0x%x"), dwResult ));
            goto Exit;
        }
        szSiteName = 0;
    }

    {
        CLocator locator;
        // Clocator has a bunch of OLE interfaces.
        // It should be released before CoUninit gets called
        bResult = GetGPOInfo(   dwFlags,
                                lpDomainDN,
                                lpDNName,
                                lpComputerName,
                                pGPOList,
                                &lpSOMList,
                                &lpGpContainerList,
                                pNetAPI32,
                                FALSE,
                                0,
                                szSiteName,
                                0,
                                &locator );

        if (!bResult) {
            xe = GetLastError();
        }
    }
    pOle32Api->pfnCoUnInitialize();


Exit:

    //
    // Stop impersonating if a hToken was given
    //

    if ( hOldToken ) {
        RevertToUser(&hOldToken);
    }

    if (lpDomain) {
        LocalFree (lpDomain);
    }

    if (lpUserName) {
        LocalFree (lpUserName);
    }

    if ( szSiteName )
    {
        pNetAPI32->pfnNetApiBufferFree( szSiteName );
    }

    FreeSOMList( lpSOMList );
    FreeGpContainerList( lpGpContainerList );

    DebugMsg((DM_VERBOSE, TEXT("GetGPOList: Leaving with %d"), bResult));

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gpnotif.h ===
//*************************************************************
//
//  Group Policy Notification
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//  History:    28-Sep-98   SitaramR    Created
//
//*************************************************************


void InitializeNotifySupport();
void ShutdownNotifySupport();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gpqry.cpp ===
//*************************************************************
//
//  Group Policy Support - Queries about the Policies
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"

//*************************************************************
//
//  AddGPO()
//
//  Purpose:    Adds a GPO to the list
//
//  Parameters: lpGPOList        - list of GPOs
//              dwFlags          - Flags
//              bFound           - Was Gpo found ?
//              bAccessGranted   - Was access granted ?
//              bDisabled        - Is this Gpo disabled ?
//              dwOptions        - Options
//              dwVersion        - Version number
//              lpDSPath         - DS path
//              lpFileSysPath    - File system path
//              lpDisplayName    - Friendly display name
//              lpGPOName        - GPO name
//              lpExtensions     - Extensions relevant to this GPO
//              lpDSObject       - LSDOU
//              pSD              - Ptr to security descriptor
//              cbSDLen          - Length of security descriptor in bytes
//              GPOLink          - GPO link type
//              lpLink       - SDOU this GPO is linked to
//              lParam           - lParam
//              bFront           - Head or end of list
//              bBlock           - Block from above flag
//              bVerbose         - Verbose output flag
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddGPO (PGROUP_POLICY_OBJECT * lpGPOList,
             DWORD dwFlags, BOOL bFound, BOOL bAccessGranted, BOOL bDisabled, DWORD dwOptions,
             DWORD dwVersion, LPTSTR lpDSPath, LPTSTR lpFileSysPath,
             LPTSTR lpDisplayName, LPTSTR lpGPOName, LPTSTR lpExtensions,
             PSECURITY_DESCRIPTOR pSD, DWORD cbSDLen,
             GPO_LINK GPOLink, LPTSTR lpLink,
             LPARAM lParam, BOOL bFront, BOOL bBlock, BOOL bVerbose, BOOL bProcessGPO)
{
    PGROUP_POLICY_OBJECT lpNew, lpTemp;
    DWORD dwSize;

    //
    // Check if this item should be excluded from the list
    //

    if (bBlock) {
        if (!(dwOptions & GPO_FLAG_FORCE)) {
            DebugMsg((DM_VERBOSE, TEXT("AddGPO:  GPO %s will not be added to the list since the Block flag is set and this GPO is not in enforce mode."),
                     lpDisplayName));
            if (bVerbose) {
                CEvents ev(FALSE, EVENT_SKIP_GPO);
                ev.AddArg(lpDisplayName); ev.Report();
            }

            if (dwFlags & GP_PLANMODE) {
                DebugMsg((DM_VERBOSE, TEXT("AddGPO:  GPO %s will will still be queried for since this is planning mode."),
                         lpDisplayName));
                bProcessGPO = FALSE;
            }
            else 
                return TRUE;
        }
    }


    //
    // Calculate the size of the new GPO item
    //

    dwSize = sizeof (GROUP_POLICY_OBJECT);

    if (lpDSPath) {
        dwSize += ((lstrlen(lpDSPath) + 1) * sizeof(TCHAR));
    }

    if (lpFileSysPath) {
        dwSize += ((lstrlen(lpFileSysPath) + 1) * sizeof(TCHAR));
    }

    if (lpDisplayName) {
        dwSize += ((lstrlen(lpDisplayName) + 1) * sizeof(TCHAR));
    }

    if (lpExtensions) {
        dwSize += ((lstrlen(lpExtensions) + 1) * sizeof(TCHAR));
    }

    if (lpLink) {
        dwSize += ((lstrlen(lpLink) + 1) * sizeof(TCHAR));
    }

    dwSize += sizeof(GPOPROCDATA);

    //
    // Allocate space for it
    //

    lpNew = (PGROUP_POLICY_OBJECT) LocalAlloc (LPTR, dwSize);

    if (!lpNew) {
        DebugMsg((DM_WARNING, TEXT("AddGPO: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }

    //
    // Fill in item
    //

    LPGPOPROCDATA lpGpoProcData;

    lpNew->lParam2 = (LPARAM)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT));
    lpGpoProcData = (LPGPOPROCDATA)lpNew->lParam2;
    lpGpoProcData->bProcessGPO = bProcessGPO;



    lpNew->dwOptions = dwOptions;
    lpNew->dwVersion = dwVersion;

    if (lpDSPath) {
        lpNew->lpDSPath = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
        lstrcpy (lpNew->lpDSPath, lpDSPath);
    }

    if (lpFileSysPath) {
        if (lpDSPath) {
            lpNew->lpFileSysPath = lpNew->lpDSPath + lstrlen (lpNew->lpDSPath) + 1;
        } else {
            lpNew->lpFileSysPath = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
        }

        lstrcpy (lpNew->lpFileSysPath, lpFileSysPath);
    }


    if (lpDisplayName) {
        if (lpFileSysPath) {
            lpNew->lpDisplayName = lpNew->lpFileSysPath + lstrlen (lpNew->lpFileSysPath) + 1;
        } else {

            if (lpDSPath)
            {
                lpNew->lpDisplayName = lpNew->lpDSPath + lstrlen (lpNew->lpDSPath) + 1;
            }
            else
            {
                lpNew->lpDisplayName = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
            }
        }

        lstrcpy (lpNew->lpDisplayName, lpDisplayName);
    }


    if (lpGPOName) {
        DmAssert( lstrlen(lpGPOName) < 50 );
        lstrcpy (lpNew->szGPOName, lpGPOName);
    }

    if (lpExtensions) {
        if (lpDisplayName) {
            lpNew->lpExtensions = lpNew->lpDisplayName + lstrlen(lpNew->lpDisplayName) + 1;
        } else {

            if (lpFileSysPath) {
                lpNew->lpExtensions = lpNew->lpFileSysPath + lstrlen(lpNew->lpFileSysPath) + 1;
            } else {

                if (lpDSPath) {
                    lpNew->lpExtensions = lpNew->lpDSPath + lstrlen(lpNew->lpDSPath) + 1;
                } else {
                    lpNew->lpExtensions = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
                }

            }
        }

        lstrcpy (lpNew->lpExtensions, lpExtensions);
    }

    if (lpLink) {
        if (lpExtensions) {
            lpNew->lpLink = lpNew->lpExtensions + lstrlen(lpNew->lpExtensions) + 1;
        } else {
            if (lpDisplayName) {
                lpNew->lpLink = lpNew->lpDisplayName + lstrlen(lpNew->lpDisplayName) + 1;
            } else {

                if (lpFileSysPath) {
                    lpNew->lpLink = lpNew->lpFileSysPath + lstrlen(lpNew->lpFileSysPath) + 1;
                } else {

                    if (lpDSPath) {
                        lpNew->lpLink = lpNew->lpDSPath + lstrlen(lpNew->lpDSPath) + 1;
                    } else {
                        lpNew->lpLink = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
                    }
                }
            }
        }

        lstrcpy (lpNew->lpLink, lpLink);
    }

    lpNew->GPOLink = GPOLink;
    lpNew->lParam = lParam;

    //
    // Add item to link list
    //

    if (*lpGPOList) {

        if (bFront) {

            (*lpGPOList)->pPrev = lpNew;
            lpNew->pNext = *lpGPOList;
            *lpGPOList = lpNew;

        } else {

            lpTemp = *lpGPOList;

            while (lpTemp->pNext != NULL) {
                lpTemp = lpTemp->pNext;
            }

            lpTemp->pNext = lpNew;
            lpNew->pPrev = lpTemp;
        }

    } else {

        //
        // First item in the list
        //

        *lpGPOList = lpNew;
    }

    return TRUE;
}


//*************************************************************
//
//  AddGPOToRsopList
//
//  Purpose:    Adds GPO to list of GPOs being logged by Rsop
//
//  Parameters: ppGpContainerList - List of Gp Containers
//              dwFlags           - Flags
//              bFound            - Was Gpo found ?
//              bAccessGranted    - Was access granted ?
//              bDisabled         - Is this Gpo disabled ?
//              dwOptions         - Options
//              dwVersion         - Version number
//              lpDSPath          - DS path
//              lpFileSysPath     - File system path
//              lpDisplayName     - Friendly display name
//              lpGPOName         - GPO name
//              pSD               - Pointer to security descriptor
//              cbSDLen           - Length of security descriptor in bytes
//              bFilterAllowed    - Does GPO pass filter check
//              pwszFilterId      - WQL filter id
//              szSOM             - SOM
//              dwGPOOptions      - GPO options
//
//*************************************************************

BOOL AddGPOToRsopList(  LPGPCONTAINER *ppGpContainerList,
                        DWORD dwFlags,
                        BOOL bFound,
                        BOOL bAccessGranted,
                        BOOL bDisabled,
                        DWORD dwVersion,
                        LPTSTR lpDSPath,
                        LPTSTR lpFileSysPath,
                        LPTSTR lpDisplayName,
                        LPTSTR lpGPOName,
                        PSECURITY_DESCRIPTOR pSD,
                        DWORD cbSDLen,
                        BOOL bFilterAllowed,
                        WCHAR *pwszFilterId,
                        LPWSTR szSOM,
                        DWORD  dwOptions)
{
    GPCONTAINER *pGpContainer = AllocGpContainer( dwFlags,
                                                  bFound,
                                                  bAccessGranted,
                                                  bDisabled,
                                                  dwVersion,
                                                  lpDSPath,
                                                  lpFileSysPath,
                                                  lpDisplayName,
                                                  lpGPOName,
                                                  pSD,
                                                  cbSDLen,
                                                  bFilterAllowed,
                                                  pwszFilterId,
                                                  szSOM,
                                                  dwOptions );
    if ( pGpContainer == NULL ) {
        DebugMsg((DM_VERBOSE, TEXT("AddGPO: Failed to allocate memory for Gp Container.")));
        return FALSE;
    }

    //
    // Prepend to GpContainer list
    //

    pGpContainer->pNext = *ppGpContainerList;
    *ppGpContainerList = pGpContainer;

    return TRUE;
}


//*************************************************************
//
//  AddLocalGPO()
//
//  Purpose:    Adds a local Gpo to the list of SOMs
//
//  Parameters: ppSOMList - List of SOMs
//
//*************************************************************

BOOL AddLocalGPO( LPSCOPEOFMGMT *ppSOMList )
{
    GPLINK *pGpLink = NULL;
    XLastError xe;
    SCOPEOFMGMT *pSOM = AllocSOM( L"Local" );

    if ( pSOM == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AddLocalGPO: Unable to allocate memory for SOM object")));
        return FALSE;
    }

    pSOM->dwType = GPLinkMachine;
    // Local GPO cannot be blocked from above


    pGpLink = AllocGpLink( L"LocalGPO", 0 );
    if ( pGpLink == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AddLocalGPO: Unable to allocate memory for GpLink object")));
        FreeSOM( pSOM );
        return FALSE;
    }

    pSOM->pGpLinkList  = pGpLink;
    pSOM->pNext = *ppSOMList;
    *ppSOMList = pSOM;

    return TRUE;
}



//*************************************************************
//
//  ProcessGPO()
//
//  Purpose:    Processes a specific GPO
//
//  Parameters: lpGPOPath     - Path to the GPO
//              lpDSPath      - DS object
//              dwFlags       - GetGPOList flags
//              HANDLE        - user or machine aceess token
//              lpGPOList     - List of GPOs
//              ppGpContainerList - List of Gp containers
//              dwGPOOptions  - Link options
//              bDeferred     - Should ldap query be deferred ?
//              bVerbose      - Verbose output
//              GPOLink       - GPO link type
//              lpDSObject    - SDOU this gpo is linked to
//              pld           - LDAP info
//              pLDAP         - LDAP api
//              pLdapMsg      - LDAP message
//              bBlock        - Block flag
//              bRsopToken    - Rsop security token
//              pGpoFilter    - Gpo filter
//              pLocator      - WMI interface class
//              bAddGPO       - In planning mode we want to get the gpodata even if
//                              the GPO is not going to be applied
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ProcessGPO(LPTSTR lpGPOPath,
                DWORD dwFlags,
                HANDLE hToken,
                PGROUP_POLICY_OBJECT *lpGPOList,
                LPGPCONTAINER *ppGpContainerList,
                DWORD dwGPOOptions,
                BOOL bDeferred,
                BOOL bVerbose,
                GPO_LINK GPOLink,
                LPTSTR lpDSObject,
                PLDAP  pld,
                PLDAP_API pLDAP,
                PLDAPMessage pMessage,
                BOOL bBlock,
                PRSOPTOKEN pRsopToken,
                CGpoFilter *pGpoFilter,
                CLocator *pLocator,
                BOOL bProcessGPO )
{
    ULONG ulResult, i;
    BOOL bResult = FALSE;
    BOOL bFound = FALSE;
    BOOL bOwnLdapMsg = FALSE;  // LDAP message owned by us (if true) or caller (if false)
    BOOL bAccessGranted;
    DWORD dwFunctionalityVersion = 2;
    DWORD dwVersion = 0;
    DWORD dwGPOFlags = 0;
    DWORD dwGPTVersion = 0;
    TCHAR szGPOName[80];
    TCHAR *pszGPTPath = 0;
    TCHAR *pszFriendlyName = 0;
    LPTSTR lpPath, lpEnd, lpTemp;
    TCHAR *pszExtensions = 0;
    TCHAR szLDAP[] = TEXT("LDAP://");
    INT iStrLen = lstrlen(szLDAP);
    BYTE berValue[8];
    LDAPControl SeInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W, { 5, (PCHAR)berValue }, TRUE };
    LDAPControl referralControl = { LDAP_SERVER_DOMAIN_SCOPE_OID_W, { 0, NULL}, TRUE };
    PLDAPControl ServerControls[] = { &SeInfoControl, &referralControl, NULL };
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    TCHAR szCommonName[] = TEXT("cn");
    TCHAR szDisplayName[] = TEXT("displayName");
    TCHAR szFileSysPath[] = TEXT("gPCFileSysPath");
    TCHAR szVersion[] = TEXT("versionNumber");
    TCHAR szFunctionalityVersion[] = GPO_FUNCTIONALITY_VERSION;
    TCHAR szFlags[] = TEXT("flags");
    TCHAR szWmiFilter[] = TEXT("gPCWQLFilter");

    PWSTR rgAttribs[12] = {szSDProperty,
                           szFileSysPath,
                           szCommonName,
                           szDisplayName,
                           szVersion,
                           szFunctionalityVersion,
                           szFlags,
                           GPO_MACHEXTENSION_NAMES,
                           GPO_USEREXTENSION_NAMES,
                           szObjectClass,
                           szWmiFilter,
                           NULL };
    LPTSTR *lpValues;
    PSECURITY_DESCRIPTOR pSD = NULL;     // Security Descriptor
    DWORD cbSDLen = 0;                   // Length of security descriptor in bytes
    BOOL bRsopLogging = (ppGpContainerList != NULL);
    BOOL bOldGpoVersion = FALSE;
    BOOL bDisabled = FALSE;
    BOOL bNoGpoData = FALSE;
    BOOL bFilterAllowed = FALSE;
    WCHAR *pwszFilterId = NULL;
    XLastError xe;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  ==============================")));

    //
    // Skip the starting LDAP provider if found
    //

    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       lpGPOPath, iStrLen, szLDAP, iStrLen) == CSTR_EQUAL)
    {
        lpPath = lpGPOPath + iStrLen;
    }
    else
    {
        lpPath = lpGPOPath;
    }

    if ( bDeferred )
    {
        bResult = AddGPO (lpGPOList, dwFlags, TRUE, TRUE, FALSE, dwGPOOptions, 0, lpPath,
                          0, 0, 0, 0, 0, 0, GPOLink, lpDSObject, 0,
                          FALSE, bBlock, bVerbose, bProcessGPO);
        if (!bResult)
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Failed to add GPO <%s> to the list."), lpPath));

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Deferring search for <%s>"), lpGPOPath));

        return bResult;
    }

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Searching <%s>"), lpGPOPath));

    //
    // Check if this user or machine has access to the GPO, and if so,
    // should that GPO be applied to them.
    //

    if (!CheckGPOAccess (pld, pLDAP, hToken, pMessage, szSDProperty, dwFlags, &pSD, &cbSDLen, &bAccessGranted, pRsopToken)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  CheckGPOAccess failed for <%s>"), lpGPOPath));
        CEvents ev(TRUE, EVENT_FAILED_ACCESS_CHECK);
        ev.AddArg(lpGPOPath); ev.AddArgWin32Error(GetLastError()); ev.Report();

        goto Exit;
    }

    if (!bAccessGranted) {
        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine does not have access to the GPO and so will not be applied.")));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User does not have access to the GPO and so will not be applied.")));
        }
        if (bVerbose) {
            CEvents ev(FALSE, EVENT_NO_ACCESS);
            ev.AddArg(lpGPOPath); ev.Report();
        }

        bResult = TRUE; // GPO is not getting applied
        if ( !bRsopLogging ) {
            goto Exit;
        }
    } else {

        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine has access to this GPO.")));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User has access to this GPO.")));
        }

    }

    
    // only if access is granted will we eval WQL filters
    if ( bAccessGranted ) {

        if (!FilterCheck(pld, pLDAP, pMessage, pRsopToken, szWmiFilter, pGpoFilter, pLocator, &bFilterAllowed, &pwszFilterId ) ) {
            xe = GetLastError();

            if (xe == WBEM_E_NOT_FOUND) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  CheckFilterAcess failed for <%s>. Filter not found"), lpGPOPath));
                CEvents ev(TRUE, EVENT_WMIFILTER_NOTFOUND);
                ev.AddArg(lpGPOPath); ev.Report();
                bFilterAllowed = FALSE;
            }
            else if (xe == HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED)) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  CheckFilterAcess failed for <%s>. WMI service is disabled"), lpGPOPath));
                CEvents ev(TRUE, EVENT_WMIFILTER_NOTFOUND);
                ev.AddArg(lpGPOPath); ev.Report();
                bFilterAllowed = FALSE;
            }
            else {
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  CheckFilterAcess failed for <%s>"), lpGPOPath));
                CEvents ev(TRUE, EVENT_FAILED_FILTER_CHECK);
                ev.AddArg(lpGPOPath); ev.Report();
                goto Exit;
            }
        }

        
        if ( (dwFlags & GP_PLANMODE) && (dwFlags & GPO_LIST_FLAG_MACHINE) && (dwFlags & FLAG_ASSUME_COMP_WQLFILTER_TRUE) ) {
            bFilterAllowed = TRUE;
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine WQL filter is assumed to be true.")));
        }
        else if ( (dwFlags & GP_PLANMODE) && ((dwFlags & GPO_LIST_FLAG_MACHINE) == 0) && (dwFlags & FLAG_ASSUME_USER_WQLFILTER_TRUE) ) {
            bFilterAllowed = TRUE;
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User WQL filter is assumed to be true.")));
        }

        if (!bFilterAllowed)
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  The GPO does not pass the filter check and so will not be applied.")));

            if (bVerbose) {
                CEvents ev(FALSE, EVENT_NO_FILTER_ALLOWED);
                ev.AddArg(lpGPOPath); ev.Report();
            }

            bResult = TRUE; // GPO is not getting applied
            if ( !bRsopLogging ) {
                goto Exit;
            }

        } else {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  GPO passes the filter check.")));
        }

    }
    else {
        bFilterAllowed = FALSE; 
    }

    //
    // Either user has access to this GPO, or Rsop logging is enabled so retrieve remaining GPO attributes
    //

    //
    // Check if this object is a GPO
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szObjectClass);

    if (lpValues) {

        bFound = FALSE;
        for ( i=0; lpValues[i] != NULL; i++) {
            if ( lstrcmp( lpValues[i], szDSClassGPO ) == 0 ) {
                bFound = TRUE;
                break;
            }
        }

        pLDAP->pfnldap_value_free (lpValues);

        if ( !bFound ) {
            xe = ERROR_DS_MISSING_REQUIRED_ATT;
            // seems like objectclass=dsgpo is required attr
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Object <%s> is not a GPO"), lpGPOPath ));
            CEvents ev(TRUE, EVENT_INCORRECT_CLASS);
            ev.AddArg(lpGPOPath); ev.AddArg(szDSClassGPO); ev.Report();

            goto Exit;
        }

    }

    //
    // In the results, get the values that match the gPCFunctionalityVersion attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szFunctionalityVersion);

    if (lpValues) {

        dwFunctionalityVersion = StringToInt (*lpValues);
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found functionality version of:  %d"),
                 dwFunctionalityVersion));
        pLDAP->pfnldap_value_free (lpValues);

    } else {

        ulResult = pLDAP->pfnLdapGetLastError();

        if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {
            if (dwFlags & GPO_LIST_FLAG_MACHINE) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine does not have access to <%s>"), lpGPOPath));
            } else {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User does not have access to <%s>"), lpGPOPath));
            }
            if (bVerbose) {
                CEvents ev(FALSE, EVENT_NO_ACCESS);
                ev.AddArg(lpGPOPath); ev.Report();
            }
            bResult = TRUE;

        } else {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  GPO %s does not have a functionality version number, error = 0x%x."), lpGPOPath, ulResult));
            CEvents ev(TRUE, EVENT_CORRUPT_GPO_FUNCVERSION);
            ev.AddArg(lpGPOPath); ev.Report();
        }
        goto Exit;
    }


    //
    // In the results, get the values that match the gPCFileSystemPath attribute
    //

    lpValues = pLDAP->pfnldap_get_values (pld, pMessage, szFileSysPath);

    if (lpValues) {

        pszGPTPath = (LPWSTR) LocalAlloc( LPTR, (lstrlen(*lpValues) +lstrlen(TEXT("\\Machine")) +1) * sizeof(TCHAR) );
        if ( pszGPTPath == 0) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Unable to allocate memory")));
            pLDAP->pfnldap_value_free (lpValues);
            goto Exit;
        }

        lstrcpy (pszGPTPath, *lpValues);
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found file system path of:  <%s>"), pszGPTPath));
        pLDAP->pfnldap_value_free (lpValues);

        lpEnd = CheckSlash (pszGPTPath);

        //
        // Get the GPT version number
        //

        lstrcpy (lpEnd, TEXT("gpt.ini"));

        //
        // Skip access to sysvol if AGP or filtercheck fails
        //

        if (bAccessGranted && bFilterAllowed) {
            WIN32_FILE_ATTRIBUTE_DATA fad;
    
            //
            // Check for the existence of the gpt.ini file.
            //
    
            if (GetFileAttributesEx(pszGPTPath, GetFileExInfoStandard, &fad)) {
                dwGPTVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, pszGPTPath);
            }
            else {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Couldn't find the group policy template file <%s>, error = 0x%x."), pszGPTPath, GetLastError()));
                CEvents ev(TRUE, EVENT_GPT_NOTACCESSIBLE);
                ev.AddArg(lpGPOPath); ev.AddArg(pszGPTPath); ev.AddArgWin32Error(GetLastError()); ev.Report();
                goto Exit;
            }
    
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Sysvol access skipped because GPO is not getting applied.")));
            dwGPTVersion = 0xffffffff;
        }
    
        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            lstrcpy (lpEnd, TEXT("Machine"));
        } else {
            lstrcpy (lpEnd, TEXT("User"));
        }

    } else {
        ulResult = pLDAP->pfnLdapGetLastError();

        if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {
            if (dwFlags & GPO_LIST_FLAG_MACHINE) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine does not have access to <%s>"), lpGPOPath));
            } else {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User does not have access to <%s>"), lpGPOPath));
            }
            if (bVerbose) {
                CEvents ev(FALSE, EVENT_NO_ACCESS);
                ev.AddArg(lpGPOPath); ev.Report();
            }
            bResult = TRUE;

        } else {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  GPO %s does not have a file system path, error = 0x%x."), lpGPOPath, ulResult));
            CEvents ev(TRUE, EVENT_CORRUPT_GPO_FSPATH);
            ev.AddArg(lpGPOPath); ev.Report();
        }
        goto Exit;
    }


    //
    // In the results, get the values that match the common name attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szCommonName);

    if (lpValues) {

        DmAssert( lstrlen(*lpValues) < 80 );

        lstrcpy (szGPOName, *lpValues);
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found common name of:  <%s>"), szGPOName));
        pLDAP->pfnldap_value_free (lpValues);

    } else {
        ulResult = pLDAP->pfnLdapGetLastError();
        xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  GPO %s does not have a common name (a GUID)."), lpGPOPath));
        CEvents ev(TRUE, EVENT_CORRUPT_GPO_COMMONNAME);
        ev.AddArg(lpGPOPath); ev.Report();
        goto Exit;
    }


    //
    // In the results, get the values that match the display name attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szDisplayName);


    if (lpValues) {

        pszFriendlyName = (LPWSTR) LocalAlloc( LPTR, (lstrlen(*lpValues)+1) * sizeof(TCHAR) );
        if ( pszFriendlyName == 0) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Unable to allocate memory")));
            pLDAP->pfnldap_value_free (lpValues);
            goto Exit;
        }

        lstrcpy (pszFriendlyName, *lpValues);
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found display name of:  <%s>"), pszFriendlyName));
        pLDAP->pfnldap_value_free (lpValues);


    } else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  No display name for this object.")));

        pszFriendlyName = (LPWSTR) LocalAlloc( LPTR, 2 * sizeof(TCHAR) );
        if ( pszFriendlyName == 0) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Unable to allocate memory")));
            goto Exit;
        }

        pszFriendlyName[0] = TEXT('\0');
    }


    //
    // In the results, get the values that match the version attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szVersion);

    if (lpValues) {

        dwVersion = StringToInt (*lpValues);

        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            dwVersion = MAKELONG(LOWORD(dwVersion), LOWORD(dwGPTVersion));
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found machine version of:  GPC is %d, GPT is %d"), LOWORD(dwVersion), HIWORD(dwVersion)));

        } else {
            dwVersion = MAKELONG(HIWORD(dwVersion), HIWORD(dwGPTVersion));
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found user version of:  GPC is %d, GPT is %d"), LOWORD(dwVersion), HIWORD(dwVersion)));
        }

        pLDAP->pfnldap_value_free (lpValues);

    } else {
        // start treating this as an error.
        xe = pLDAP->pfnLdapMapErrorToWin32(pLDAP->pfnLdapGetLastError());
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  GPO %s does not have a version number."), lpGPOPath));
        CEvents ev(TRUE, EVENT_NODSVERSION);
        ev.AddArg(lpGPOPath); ev.AddArgLdapError(pLDAP->pfnLdapGetLastError()); ev.Report();
        goto Exit;
    }


    //
    // In the results, get the values that match the flags attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szFlags);

    if (lpValues) {

        dwGPOFlags = StringToInt (*lpValues);
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found flags of:  %d"), dwGPOFlags));
        pLDAP->pfnldap_value_free (lpValues);


    } else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  No flags for this object.")));
    }


    //
    // In the results, get the values that match the extension names attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage,
                                         (dwFlags & GPO_LIST_FLAG_MACHINE) ? GPO_MACHEXTENSION_NAMES
                                                                           : GPO_USEREXTENSION_NAMES );
    if (lpValues) {

        if ( lstrcmpi( *lpValues, TEXT(" ") ) == 0 ) {

            //
            // A blank char is also a null property case, because Adsi doesn't commit null strings
            //
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  No client-side extensions for this object.")));

        } else {

            pszExtensions = (LPWSTR) LocalAlloc( LPTR, (lstrlen(*lpValues)+1) * sizeof(TCHAR) );
            if ( pszExtensions == 0 ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Unable to allocate memory")));
                pLDAP->pfnldap_value_free (lpValues);
                goto Exit;

            }

            lstrcpy( pszExtensions, *lpValues );

            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found extensions:  %s"), pszExtensions));
        }

        pLDAP->pfnldap_value_free (lpValues);

    } else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  No client-side extensions for this object.")));
    }


    //
    // Log which GPO we found
    //

    if (bVerbose) {
        CEvents ev(FALSE, EVENT_FOUND_GPO);
        ev.AddArg(pszFriendlyName); ev.AddArg(szGPOName); ev.Report();
    }


    //
    // Check the functionalty version number
    //

    if (dwFunctionalityVersion < 2) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  GPO %s was created by an old version of the Group Policy Editor.  It will be skipped."), pszFriendlyName));
        if (bVerbose) {
            CEvents ev(FALSE, EVENT_GPO_TOO_OLD);
            ev.AddArg(pszFriendlyName); ev.Report();
        }
        bOldGpoVersion = TRUE;
    }


    //
    // Check if the GPO is disabled
    //

    if (((dwFlags & GPO_LIST_FLAG_MACHINE) &&
         (dwGPOFlags & GPO_OPTION_DISABLE_MACHINE)) ||
         (!(dwFlags & GPO_LIST_FLAG_MACHINE) &&
         (dwGPOFlags & GPO_OPTION_DISABLE_USER))) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  GPO %s is disabled.  It will be skipped."), pszFriendlyName));
        if (bVerbose) {
            CEvents ev(FALSE, EVENT_GPO_DISABLED);
            ev.AddArg(pszFriendlyName); ev.Report();
        }
        bDisabled = TRUE;
    }

    //
    // Check if the version number is 0, if so there isn't any data
    // in the GPO and we can skip it
    //

    if (dwVersion == 0) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  GPO %s doesn't contain any data since the version number is 0.  It will be skipped."), pszFriendlyName));
        if (bVerbose) {
            CEvents ev(FALSE, EVENT_GPO_NO_DATA);
            ev.AddArg(pszFriendlyName); ev.Report();
        }
        bNoGpoData = TRUE;
    }

    //
    // Put the correct container name on the front of the LDAP path
    //

    lpTemp = (LPWSTR) LocalAlloc (LPTR, (lstrlen(lpGPOPath) + 20) * sizeof(TCHAR));

    if (!lpTemp) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Failed to allocate memory with %d"), GetLastError()));
        CEvents ev(TRUE, EVENT_OUT_OF_MEMORY);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    if (dwFlags & GPO_LIST_FLAG_MACHINE) {
        lstrcpy (lpTemp, TEXT("LDAP://CN=Machine,"));
    } else {
        lstrcpy (lpTemp, TEXT("LDAP://CN=User,"));
    }

    DmAssert( lstrlen(TEXT("LDAP://CN=Machine,")) + lstrlen(lpPath) < (lstrlen(lpGPOPath) + 20) );

    lstrcat (lpTemp, lpPath);


    //
    // Add this GPO to the list
    //

    if ( bRsopLogging ) {
        bResult = AddGPOToRsopList( ppGpContainerList,
                                    dwFlags,
                                    TRUE,
                                    bAccessGranted,
                                    bDisabled,
                                    dwVersion,
                                    lpTemp,
                                    pszGPTPath,
                                    pszFriendlyName,
                                    szGPOName,
                                    pSD,
                                    cbSDLen,
                                    bFilterAllowed,
                                    pwszFilterId,
                                    lpDSObject,
                                    dwGPOOptions );
        if (!bResult) {
            xe = GetLastError();
            LocalFree(lpTemp);
            goto Exit;
        }
    }

    if (  bProcessGPO && bAccessGranted && !bOldGpoVersion && !bDisabled && !bNoGpoData && bFilterAllowed)
    {
        bResult = AddGPO (lpGPOList, dwFlags, TRUE, bAccessGranted, bDisabled,
                          dwGPOOptions, dwVersion, lpTemp,
                          pszGPTPath, pszFriendlyName, szGPOName, pszExtensions, pSD, cbSDLen, GPOLink, lpDSObject, 0,
                          FALSE, bBlock, bVerbose, bProcessGPO);
    }

    if (!bResult) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Failed to add GPO <%s> to the list."), pszFriendlyName));
    }

    LocalFree (lpTemp);

Exit:

    if ( pSD )
        LocalFree( pSD );

    if ( pszGPTPath )
        LocalFree( pszGPTPath );

    if ( pszFriendlyName )
        LocalFree( pszFriendlyName );

    if ( pszExtensions )
        LocalFree( pszExtensions );

    if ( pwszFilterId )
        LocalFree( pwszFilterId );

    if (pMessage && bOwnLdapMsg ) {
        pLDAP->pfnldap_msgfree (pMessage);
    }

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  ==============================")));

    return bResult;
}


//*************************************************************
//
//  SearchDSObject()
//
//  Purpose:    Searches the specified DS object for GPOs and
//              if found, adds them to the list.
//
//  Parameters: lpDSObject          - DS object to search
//              dwFlags             - GetGPOList & GP_PLANMODE flags
//              pGPOForcedList      - List of forced GPOs
//              pGPONonForcedList   - List of non-forced GPOs
//              ppSOMList           - List of LSDOUs
//              ppGpContainerList   - List of Gp Containers
//              bVerbose            - Verbose output
//              GPOLink             - GPO link type
//              pld                 - LDAP info
//              pLDAP               - LDAP api
//              bBlock              - Pointer to the block flag
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SearchDSObject (LPTSTR lpDSObject, DWORD dwFlags, HANDLE hToken, PGROUP_POLICY_OBJECT *pGPOForcedList,
                     PGROUP_POLICY_OBJECT *pGPONonForcedList,
                     LPSCOPEOFMGMT *ppSOMList, LPGPCONTAINER *ppGpContainerList,
                     BOOL bVerbose,
                     GPO_LINK GPOLink, PLDAP  pld, PLDAP_API pLDAP, PLDAPMessage pLDAPMsg,BOOL *bBlock, PRSOPTOKEN pRsopToken )
{
    PGROUP_POLICY_OBJECT pForced = NULL, pNonForced = NULL, lpGPO;
    LPTSTR *lpValues;
    ULONG ulResult;
    BOOL bResult = FALSE;
    BOOL bOwnLdapMsg = FALSE;  // LDAP message owned by us (if true) or caller (if false)
    DWORD dwGPOOptions, dwOptions = 0;
    LPTSTR lpTemp, lpList, lpDSClass;
    BYTE berValue[8];
    LDAPControl SeInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W, { 5, (PCHAR)berValue }, TRUE };
    PLDAPControl ServerControls[] = { &SeInfoControl, NULL };
    
    TCHAR szGPLink[] = TEXT("gPLink");
    TCHAR szGPOPath[512];
    TCHAR szGPOOptions[12];
    TCHAR szGPOptions[] = TEXT("gPOptions");
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    ULONG i = 0;
    LPTSTR lpFullDSObject = NULL;
    BOOL bFound = FALSE;
    LPTSTR lpAttr[] = { szGPLink,
                        szGPOptions,
//                        szObjectClass, not needed
                        szSDProperty,
                        NULL
                       };
    SCOPEOFMGMT *pSOM = NULL;
    BOOL bRsopLogging = (ppSOMList != NULL);
    BOOL bAllGPOs = (dwFlags & FLAG_NO_GPO_FILTER) && (dwFlags & GP_PLANMODE);
    XLastError xe;

    
    //
    // Setup the BER encoding for the SD
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02; // denotes an integer
    berValue[3] = 0x01; // denotes size
    berValue[4] = (BYTE)((DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION) & 0xF);


    if ( !pRsopToken )
    {
        //
        // if it is not planning mode, don't get the SD
        // 

        lpAttr[2] = NULL;
        ServerControls[0] = NULL;
    }

    
    //
    // Search for the object
    //

    DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  Searching <%s>"), lpDSObject));
    if (bVerbose) {
        CEvents ev(FALSE, EVENT_SEARCHING);
        ev.AddArg(lpDSObject); ev.Report();
    }

    if ( bRsopLogging )
    {
        pSOM = AllocSOM( lpDSObject );
        if ( !pSOM ) {
             xe = GetLastError();
             DebugMsg((DM_WARNING, TEXT("SearchDSObject:  Unable to allocate memory for SOM object.  Leaving. ")));
             goto Exit;
        }
        pSOM->dwType = GPOLink;
        pSOM->bBlocked = *bBlock;

    }

    if ( pLDAPMsg == NULL ) {

        bOwnLdapMsg = TRUE;

        ulResult = pLDAP->pfnldap_search_ext_s(pld, lpDSObject, LDAP_SCOPE_BASE,
                                               szDSClassAny, lpAttr, FALSE,
                                               (PLDAPControl*)ServerControls,
                                               NULL, NULL, 0, &pLDAPMsg);

        if (ulResult != LDAP_SUCCESS) {

            if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {

                DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  No GPO(s) for this object.")));
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_NO_GPOS); ev.AddArg(lpDSObject); ev.Report();
                }
                bResult = TRUE;

            } else if (ulResult == LDAP_NO_SUCH_OBJECT) {

                DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  Object not found in DS (this is ok).  Leaving. ")));
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_NO_DS_OBJECT);
                    ev.AddArg(lpDSObject); ev.Report();
                }
                bResult = TRUE;

            } else if (ulResult == LDAP_SIZELIMIT_EXCEEDED) {
               xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
               DebugMsg((DM_WARNING, TEXT("SearchDSObject:  Too many linked GPOs in search.") ));
               CEvents ev(TRUE, EVENT_TOO_MANY_GPOS); ev.Report();

            } else {
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
                DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  Failed to find DS object <%s> due to error %d."),
                         lpDSObject, ulResult));
                CEvents ev(TRUE, EVENT_GPLINK_NOT_FOUND);
                ev.AddArg(lpDSObject); ev.AddArgLdapError(ulResult); ev.Report();
            }

            goto Exit;

        }
    }

    if ( bRsopLogging && pRsopToken && !bAllGPOs )
    {
        //
        // In Rsop planning mode, check access to OU
        //

        BOOL bAccessGranted = FALSE;
        BOOL bOk;

        bOk = CheckOUAccess(pLDAP,
                            pld,
                            pLDAPMsg,
                            pRsopToken,
                            &bAccessGranted );

        if ( !bOk )
        {
            xe = GetLastError();
            goto Exit;
        }

        if ( !bAccessGranted )
        {
            //
            // no access for the user on the OU. Exit
            //

            DebugMsg((DM_VERBOSE, TEXT("SearchDSObject: Access denied in planning mode to SOM <%s>"), lpDSObject));

            if (pLDAPMsg && bOwnLdapMsg )
            {
                pLDAP->pfnldap_msgfree (pLDAPMsg);
                pLDAPMsg = 0;
            }

            CEvents ev(TRUE, EVENT_OU_ACCESSDENIED);
            ev.AddArg(lpDSObject); ev.Report();

            goto Exit;
        }
    }

    //
    // In the results, get the values that match the gPOptions attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pLDAPMsg, szGPOptions);

    if (lpValues && *lpValues) {
        dwOptions = StringToInt (*lpValues);
        pLDAP->pfnldap_value_free (lpValues);
    }


    //
    // In the results, get the values that match the gPLink attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pLDAPMsg, szGPLink);


    if (lpValues && *lpValues) {

        lpList = *lpValues;

        DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  Found GPO(s):  <%s>"), lpList));

        lpFullDSObject = (LPWSTR) LocalAlloc (LPTR, (lstrlen(lpDSObject) + 8) * sizeof(TCHAR));

        if (!lpFullDSObject) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("SearchDSObject:  Failed to allocate memory for full DS Object path name with %d"),
                     GetLastError()));
            pLDAP->pfnldap_value_free (lpValues);
            goto Exit;
        }

        lstrcpy (lpFullDSObject, TEXT("LDAP://"));
        lstrcat (lpFullDSObject, lpDSObject);


        while (*lpList) {


            //
            // Pull off the GPO ldap path
            //

            lpTemp = szGPOPath;
            dwGPOOptions = 0;

            while (*lpList && (*lpList != TEXT('['))) {
                lpList++;
            }

            if (!(*lpList)) {
                break;
            }

            lpList++;

            while (*lpList && (*lpList != TEXT(';'))) {
                *lpTemp++ = *lpList++;
            }

            if (!(*lpList)) {
                break;
            }

            *lpTemp = TEXT('\0');


            lpList++;

            lpTemp = szGPOOptions;
            *lpTemp = TEXT('\0');

            while (*lpList && (*lpList != TEXT(']'))) {
                *lpTemp++ = *lpList++;
            }

            if (!(*lpList)) {
                break;
            }

            *lpTemp = TEXT('\0');
            lpList++;

            dwGPOOptions = StringToInt (szGPOOptions);

            if ( bRsopLogging ) {

                GPLINK *pGpLink = AllocGpLink( szGPOPath, dwGPOOptions );
                if ( pGpLink == NULL ) {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("SearchDSObject:  Unable to allocate memory for GpLink object.  Leaving. ")));
                    goto Exit;
                }

                //
                // Append GpLink to end of SOM list
                //

                if ( pSOM->pGpLinkList == NULL ) {
                    pSOM->pGpLinkList = pGpLink;
                } else {

                    GPLINK *pTrailPtr = NULL;
                    GPLINK *pCurPtr = pSOM->pGpLinkList;

                    while ( pCurPtr != NULL ) {
                        pTrailPtr = pCurPtr;
                        pCurPtr = pCurPtr->pNext;
                    }

                    pTrailPtr->pNext = pGpLink;
                }

            }


            //
            // Check if this link is disabled
            //

            BOOL    bProcessGPO = TRUE;

            if ( ( dwGPOOptions & GPO_FLAG_DISABLE ) && !bAllGPOs )
            {

                DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  The link to GPO %s is disabled.  It will be skipped for processing."), szGPOPath));
                if (bVerbose)
                {
                    CEvents ev(FALSE, EVENT_GPO_LINK_DISABLED);
                    ev.AddArg(szGPOPath); ev.Report();
                }

                bProcessGPO = FALSE;
            }
                
            if (bProcessGPO || (dwFlags & GP_PLANMODE)) {

                if (!bProcessGPO) {
                    DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  The link to GPO %s is disabled. GPO is still being queried. Planning mode."), szGPOPath));
                }

                if ( !ProcessGPO(   szGPOPath,
                                        dwFlags,
                                        hToken,
                                        (dwGPOOptions & GPO_FLAG_FORCE) ? &pForced : &pNonForced,
                                        ppGpContainerList,
                                        dwGPOOptions,
                                        TRUE,
                                        bVerbose,
                                        GPOLink,
                                        lpFullDSObject,
                                        pld,
                                        pLDAP,
                                        0,
                                        *bBlock,
                                        pRsopToken,
                                        0,
                                        0,
                                        bProcessGPO ) )
                    {
                        xe = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("SearchDSObject:  ProcessGPO failed.")));
                        pLDAP->pfnldap_value_free (lpValues);
                        goto Exit;
                    }
            }
        }

        pLDAP->pfnldap_value_free (lpValues);


        //
        // Set the block flag now if requested.  This way OU's, domains, etc
        // higher in the namespace will have GPOs removed if appropriate
        //

        if (dwOptions & GPC_BLOCK_POLICY) {
            *bBlock = TRUE;

            if ( bRsopLogging )
                pSOM->bBlocking = TRUE;

            DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  <%s> has the Block From Above attribute set"), lpDSObject));
            if (bVerbose) {
                CEvents ev(FALSE, EVENT_BLOCK_ENABLED);
                ev.AddArg(lpDSObject); ev.Report();
            }
        }


    } else {
        DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  No GPO(s) for this object.")));
        if (bVerbose) {
             CEvents ev(FALSE, EVENT_NO_GPOS); ev.AddArg(lpDSObject); ev.Report();
        }
    }

    //
    // Merge the temp and real lists together
    // First the non-forced lists
    //

    if (pNonForced) {

        lpGPO = pNonForced;

        while (lpGPO->pNext) {
            lpGPO = lpGPO->pNext;
        }

        lpGPO->pNext = *pGPONonForcedList;
        if (*pGPONonForcedList) {
            (*pGPONonForcedList)->pPrev = lpGPO;
        }

        *pGPONonForcedList = pNonForced;
    }

    //
    // Now the forced lists
    //

    if (pForced) {

        lpGPO = *pGPOForcedList;

        if (lpGPO) {
            while (lpGPO->pNext) {
                lpGPO = lpGPO->pNext;
            }

            lpGPO->pNext = pForced;
            pForced->pPrev = lpGPO;

        } else {
            *pGPOForcedList = pForced;
        }
    }

    bResult = TRUE;
    
Exit:
    if ( !bResult && pSOM != NULL ) {
        FreeSOM( pSOM );
    }
    else {
        if ( bResult && bRsopLogging ) {

            //
            // Insert SOM at the beginning
            //

            pSOM->pNext = *ppSOMList;
            *ppSOMList = pSOM;
        }
    }

    if (lpFullDSObject) {
        LocalFree (lpFullDSObject);
    }

    if (pLDAPMsg && bOwnLdapMsg ) {
        pLDAP->pfnldap_msgfree (pLDAPMsg);
    }

    return bResult;
}

//*************************************************************
//
//  AllocDnEntry()
//
//  Purpose:    Allocates a new struct for dn entry
//
//
//  Parameters: pwszDN  - Distinguished name
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

DNENTRY * AllocDnEntry( LPTSTR pwszDN )
{
    DNENTRY *pDnEntry = (DNENTRY *) LocalAlloc (LPTR, sizeof(DNENTRY));
    XLastError xe;

    if ( pDnEntry == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocDnEntry: Failed to alloc pDnEntry with 0x%x."),
                  GetLastError()));
        return NULL;
    }

    pDnEntry->pwszDN = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pwszDN) + 1) * sizeof(TCHAR) );

    if ( pDnEntry->pwszDN == NULL ) {
        xe = GetLastError();
       DebugMsg((DM_WARNING, TEXT("AllocDnEntry: Failed to alloc pwszDN with 0x%x."),
                 GetLastError()));
       LocalFree( pDnEntry );
       return NULL;
    }

    lstrcpy( pDnEntry->pwszDN, pwszDN );

    return pDnEntry;
}


//*************************************************************
//
//  FreeDnEntry()
//
//  Purpose:    Frees dn entry struct
//
//*************************************************************

void FreeDnEntry( DNENTRY *pDnEntry )
{
    if ( pDnEntry ) {
        if ( pDnEntry->pwszDN )
            LocalFree( pDnEntry->pwszDN );

        LocalFree( pDnEntry );
    }
}

//*************************************************************
//
//  AllocLdapQuery()
//
//  Purpose:    Allocates a new struct for ldap query
//
//
//  Parameters: pwszDomain  - Domain of Gpo
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

LDAPQUERY * AllocLdapQuery( LPTSTR pwszDomain )
{
    const INIT_ALLOC_SIZE = 1000;
    LDAPQUERY *pQuery = (LDAPQUERY *) LocalAlloc (LPTR, sizeof(LDAPQUERY));
    XLastError xe;

    if ( pQuery == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocLdapQuery: Failed to alloc pQuery with 0x%x."),
                  GetLastError()));
        return NULL;
    }

    pQuery->pwszDomain = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pwszDomain) + 1) * sizeof(TCHAR) );

    if ( pQuery->pwszDomain == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocLdapQuery: Failed to alloc pwszDomain with 0x%x."),
                  GetLastError()));
        LocalFree( pQuery );
        return NULL;
    }

    pQuery->pwszFilter = (LPTSTR) LocalAlloc (LPTR, INIT_ALLOC_SIZE );

    if ( pQuery->pwszFilter == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocLdapQuery: Failed to alloc pwszFilter with 0x%x."),
                  GetLastError()));
        LocalFree( pQuery->pwszDomain );
        LocalFree( pQuery );
        return NULL;
    }

    lstrcpy( pQuery->pwszDomain, pwszDomain );
    lstrcpy( pQuery->pwszFilter, L"(|)" );
    pQuery->cbLen = 8;           // 8 = (lstrlen(L"(|)") + 1) * sizeof(TCHAR)
    pQuery->cbAllocLen = INIT_ALLOC_SIZE;

    return pQuery;
}


//*************************************************************
//
//  FreeLdapQuery()
//
//  Purpose:    Frees ldap query struct
//
//*************************************************************

void FreeLdapQuery( PLDAP_API pLDAP, LDAPQUERY *pQuery )
{
    DNENTRY *pDnEntry = NULL;

    if ( pQuery ) {

        if ( pQuery->pwszDomain )
            LocalFree( pQuery->pwszDomain );

        if ( pQuery->pwszFilter )
            LocalFree( pQuery->pwszFilter );

        if ( pQuery->pMessage )
            pLDAP->pfnldap_msgfree( pQuery->pMessage );

        if ( pQuery->pLdapHandle && pQuery->bOwnLdapHandle )
            pLDAP->pfnldap_unbind( pQuery->pLdapHandle );

        pDnEntry = pQuery->pDnEntry;

        while ( pDnEntry ) {
            DNENTRY *pTemp = pDnEntry->pNext;
            FreeDnEntry( pDnEntry );
            pDnEntry = pTemp;
        }

        LocalFree( pQuery );

    }
}


//*************************************************************
//
//  MatchDnWithDeferredItems()
//
//  Purpose:    Matches the dns from ldap query with the deferred items
//
//  Parameters: pLDAP         - LDAP function table pointer
//              ppLdapQuery   - LDAP query list
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL MatchDnWithDeferredItems( PLDAP_API pLDAP, LDAPQUERY *pLdapQuery, BOOL bOUProcessing )
{
    PLDAPMessage pMsg = pLDAP->pfnldap_first_entry( pLdapQuery->pLdapHandle, pLdapQuery->pMessage );

    while ( pMsg ) {

        WCHAR *pwszDN = pLDAP->pfnldap_get_dn( pLdapQuery->pLdapHandle, pMsg );

        DNENTRY *pCurPtr = pLdapQuery->pDnEntry;

        while ( pCurPtr ) {

            INT iResult = CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                          pwszDN, -1, pCurPtr->pwszDN, -1 );
            if ( iResult == CSTR_EQUAL ) {

                //
                // Store the pointer to ldap message so that it can be used
                // later to retrieve necessary attributes.
                //
                if ( bOUProcessing )
                    pCurPtr->pDeferredOU->pOUMsg = pMsg;
                else {
                    LPGPOPROCDATA lpGpoProcData = (LPGPOPROCDATA)pCurPtr->pDeferredGPO->lParam2;

                    pCurPtr->pDeferredGPO->lParam = (LPARAM) pMsg;
                    lpGpoProcData->pLdapHandle = pLdapQuery->pLdapHandle;
                }

                pCurPtr = pCurPtr->pNext;

            } else if ( iResult == CSTR_LESS_THAN ) {

                //
                // Since dns are in ascending order,
                // we are done.
                //

                break;

            } else {

                //
                // Advance down the list
                //

                pCurPtr = pCurPtr->pNext;

            } // final else

        }   // while pcurptr

        pLDAP->pfnldap_memfree( pwszDN );

        pMsg = pLDAP->pfnldap_next_entry( pLdapQuery->pLdapHandle, pMsg );

    }   // while pmsg

    return TRUE;
}

LPWSTR DsQuoteSearchFilter( LPCWSTR );

//*************************************************************
//
//  AddDnToFilter()
//
//  Purpose:    ORs in the new dn to the ldap filter
//
//  Parameters: ppLdapQuery       - LDAP query list
//              pGPO              - Deferred GPO
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddDnToFilter( LDAPQUERY *pLdapQuery, LPTSTR pwszDN )
{
    const  DN_SIZE = 20;      // 20 = # chars in "(dis..=)"
    BOOL   bSuccess = FALSE;
    LPWSTR szQuotedDN;

    szQuotedDN = DsQuoteSearchFilter( pwszDN );

    if ( ! szQuotedDN )
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo: DsQuoteSearchFilter failed with = <%d>"), GetLastError() ));
        goto AddDnToFilter_ExitAndCleanup;
    }

    DWORD cbNew = (lstrlen(szQuotedDN) + DN_SIZE) * sizeof(TCHAR); // + 1 is not needed because \0 is already part of filter string

    DWORD cbSizeRequired = pLdapQuery->cbLen + cbNew;

    if ( cbSizeRequired >= pLdapQuery->cbAllocLen ) {

        //
        // Need to grow buffer because of overflow
        //

        LPTSTR pwszNewFilter = (LPTSTR) LocalAlloc (LPTR, cbSizeRequired * 2);

        if ( pwszNewFilter == NULL ) {
            DebugMsg((DM_WARNING, TEXT("AddDnToFilter: Unable to allocate new filter string") ));
            goto AddDnToFilter_ExitAndCleanup;
        }

        lstrcpy( pwszNewFilter, pLdapQuery->pwszFilter );

        LocalFree( pLdapQuery->pwszFilter );
        pLdapQuery->pwszFilter = pwszNewFilter;

        pLdapQuery->cbAllocLen = cbSizeRequired * 2;
    }

    DmAssert( cbSizeRequired < pLdapQuery->cbAllocLen );

    //
    // Overwrite last ")" and then append the new dn name term
    //

    lstrcpy( &pLdapQuery->pwszFilter[pLdapQuery->cbLen/2 - 2], L"(distinguishedName=" );

    lstrcat( pLdapQuery->pwszFilter, szQuotedDN );

    lstrcat( pLdapQuery->pwszFilter, L"))" );

    pLdapQuery->cbLen += cbNew;

    bSuccess = TRUE;

 AddDnToFilter_ExitAndCleanup:

    if ( szQuotedDN )
    {
        LocalFree( szQuotedDN );
    }

    return bSuccess;
}

//*************************************************************
//
//  InsertDN()
//
//  Purpose:    Adds a distinguished name entry to ldap query's
//              names linked list
//
//  Parameters: ppLdapQuery       - LDAP query list
//              pwszDN            - DN
//              pDeferredOU       - Deferred OU
//              pDeferredGPO      - Deferred GPO
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL InsertDN( LDAPQUERY *pLdapQuery, LPTSTR pwszDN,
               DNENTRY *pDeferredOU, PGROUP_POLICY_OBJECT pDeferredGPO )
{
    DNENTRY *pNewEntry = NULL;
    DNENTRY *pTrailPtr = NULL;
    DNENTRY *pCurPtr = pLdapQuery->pDnEntry;
    XLastError xe;

    DmAssert( !( pDeferredOU && pDeferredGPO ) );

    while ( pCurPtr != NULL ) {

         INT iResult = CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                       pwszDN, -1, pCurPtr->pwszDN, -1 );

         if ( iResult == CSTR_EQUAL || iResult == CSTR_LESS_THAN ) {

             //
             // Duplicate or since dn's are in ascending order, add new entry
             //

             DNENTRY *pNewEntry = AllocDnEntry( pwszDN );
             if ( pNewEntry == NULL )
                 return FALSE;

             if ( !AddDnToFilter( pLdapQuery, pwszDN ) ) {
                 xe = GetLastError();
                 FreeDnEntry( pNewEntry );
                 return FALSE;
             }

             if ( pDeferredOU )
                 pNewEntry->pDeferredOU = pDeferredOU;
             else
                 pNewEntry->pDeferredGPO = pDeferredGPO;

             pNewEntry->pNext = pCurPtr;
             if ( pTrailPtr == NULL )
                 pLdapQuery->pDnEntry = pNewEntry;
             else
                 pTrailPtr->pNext = pNewEntry;

             return TRUE;

         } else {

             //
             // Advance down the list
             //

             pTrailPtr = pCurPtr;
             pCurPtr = pCurPtr->pNext;

         }

    }    // while

    //
    // Null list or end of list case.
    //

    pNewEntry = AllocDnEntry( pwszDN );
    if ( pNewEntry == NULL ) {
        xe = GetLastError();
        return FALSE;
    }

    if ( !AddDnToFilter( pLdapQuery, pwszDN ) ) {
        xe = GetLastError();
        FreeDnEntry( pNewEntry );
        return FALSE;
    }

    if ( pDeferredOU )
        pNewEntry->pDeferredOU = pDeferredOU;
    else
        pNewEntry->pDeferredGPO = pDeferredGPO;

    pNewEntry->pNext = pCurPtr;
    if ( pTrailPtr == NULL )
         pLdapQuery->pDnEntry = pNewEntry;
    else
        pTrailPtr->pNext = pNewEntry;

    return TRUE;
}



//*************************************************************
//
//  AddDN()
//
//  Purpose:    Adds a distinguished name entry to ldap query
//
//  Parameters: ppLdapQuery       - LDAP query list
//              pwszDN            - DN name
//              pDeferredOU       - Deferred OU
//              pDeferredGPO      - Deferred GPO
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddDN( PLDAP_API pLDAP, LDAPQUERY **ppLdapQuery,
            LPTSTR pwszDN, DNENTRY *pDeferredOU, PGROUP_POLICY_OBJECT pDeferredGPO )
{
    LPTSTR pwszDomain = NULL;
    LPTSTR pwszTemp = pwszDN;
    LDAPQUERY *pNewQuery = NULL;
    LDAPQUERY *pTrailPtr = NULL;
    LDAPQUERY *pCurPtr = *ppLdapQuery;
    XLastError xe;

    DmAssert( !( pDeferredOU && pDeferredGPO ) );

    //
    // Find the domain to which the GPO belongs
    //

    if ( pwszTemp == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AddDN: Null pwszDN. Exiting.") ));
        return FALSE;
    }

    while ( *pwszTemp ) {

        //
        // The check below needs to be more sophisticated to take care
        // of spaces in names etc.
        //

        if (CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                            pwszTemp, 16, TEXT("cn=configuration"), 16) == CSTR_EQUAL ) {
            DebugMsg((DM_VERBOSE, TEXT("AddDN: DN %s is under cn=configuration container. queueing for rebinding"), pwszDN ));
            pwszDomain = pwszTemp;
            break;
        }

        if (CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                            pwszTemp, 3, TEXT("DC="), 3) == CSTR_EQUAL ) {
            pwszDomain = pwszTemp;
            break;
        }

        //
        // Move to the next chunk of the DN name
        //

        while ( *pwszTemp && (*pwszTemp != TEXT(',')))
            pwszTemp++;

        if ( *pwszTemp == TEXT(','))
            pwszTemp++;

    }

    if ( pwszDomain == NULL ) {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("AddDN: Domain not found for <%s>. Exiting."), pwszDN ));
        return FALSE;
    }

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                      pwszDomain, -1, pCurPtr->pwszDomain, -1 );
        if ( iResult == CSTR_EQUAL ) {

            BOOL bOk = InsertDN( pCurPtr, pwszDN, pDeferredOU, pDeferredGPO );
            return bOk;

        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Since domains are in ascending order,
            // pwszDomain is not in list, so add.
            //

            pNewQuery = AllocLdapQuery( pwszDomain );
            if ( pNewQuery == NULL ) {
                xe = GetLastError();
                return FALSE;
            }

            if ( !InsertDN( pNewQuery, pwszDN, pDeferredOU, pDeferredGPO ) ) {
                xe = GetLastError();
                FreeLdapQuery( pLDAP, pNewQuery );
                return FALSE;
            }

            pNewQuery->pNext = pCurPtr;
            if ( pTrailPtr == NULL )
                *ppLdapQuery = pNewQuery;
            else
                pTrailPtr->pNext = pNewQuery;

            return TRUE;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }   // while

    //
    // Null list or end of list case.
    //

    pNewQuery = AllocLdapQuery( pwszDomain );

    if ( pNewQuery == NULL ) {
        xe = GetLastError();
        return FALSE;
    }

    if ( !InsertDN( pNewQuery, pwszDN, pDeferredOU, pDeferredGPO ) ) {
        xe = GetLastError();
        FreeLdapQuery( pLDAP, pNewQuery );
        return FALSE;
    }

    pNewQuery->pNext = pCurPtr;

    if ( pTrailPtr == NULL )
        *ppLdapQuery = pNewQuery;
    else
        pTrailPtr->pNext = pNewQuery;

    return TRUE;
}



//*************************************************************
//
//  EvalList()
//
//  Purpose:    Encapsulates common processing functionality for
//              forced and nonforced lists
//
//  Parameters: pLDAP                  - LDAP api
//              dwFlags                - GetGPOList flags
//              bVerbose               - Verbose flag
//              hToken                 - User or machine token
//              pDeferredList          - List of deferred GPOs
//              ppGPOList              - List of evaluated GPOs
//              ppGpContainerList      - List of Gp Containers
//              pGpoFilter             - Gpo filter
//              pLocator               - WMI interfaces
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL EvalList(  PLDAP_API pLDAP,
                DWORD dwFlags,
                HANDLE hToken,
                BOOL bVerbose,
                PGROUP_POLICY_OBJECT pDeferredList,
                PGROUP_POLICY_OBJECT *ppGPOList,
                LPGPCONTAINER *ppGpContainerList,
                PRSOPTOKEN pRsopToken,
                CGpoFilter *pGpoFilter,
                CLocator *pLocator  )
{
    PGROUP_POLICY_OBJECT pGPOTemp = pDeferredList;

    while ( pGPOTemp ) {

        PLDAPMessage pGPOMsg = (PLDAPMessage) pGPOTemp->lParam;

        if ( pGPOMsg == NULL ) {
            DebugMsg((DM_VERBOSE, TEXT("EvalList: Object <%s> cannot be accessed"),
                      pGPOTemp->lpDSPath ));

            if (dwFlags & GP_PLANMODE) {
                CEvents ev(TRUE, EVENT_OBJECT_NOT_FOUND_PLANNING);
                ev.AddArg(pGPOTemp->lpDSPath); ev.Report();
            }
            else {
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_OBJECT_NOT_FOUND);
                    ev.AddArg(pGPOTemp->lpDSPath); ev.AddArg((DWORD)0); ev.Report();
                }
            }

        } else {

            DmAssert( pGPOTemp->lParam2 != NULL );
            DmAssert( ((LPGPOPROCDATA)(pGPOTemp->lParam2))->pLdapHandle != NULL );

            if ( !ProcessGPO(   pGPOTemp->lpDSPath,
                                dwFlags,
                                hToken,
                                ppGPOList,
                                ppGpContainerList,
                                pGPOTemp->dwOptions,
                                FALSE,
                                bVerbose,
                                pGPOTemp->GPOLink,
                                pGPOTemp->lpLink,
                                ((LPGPOPROCDATA)(pGPOTemp->lParam2))->pLdapHandle,
                                pLDAP,
                                pGPOMsg,
                                FALSE,
                                pRsopToken,
                                pGpoFilter,
                                pLocator,
                                ((LPGPOPROCDATA)(pGPOTemp->lParam2))->bProcessGPO ) )
            {
                DebugMsg((DM_WARNING, TEXT("EvalList:  ProcessGPO failed") ));
                return FALSE;
            }

        }

        pGPOTemp = pGPOTemp->pNext;

    }

    return TRUE;
}

//*************************************************************
//
//  EvaluateDeferredGPOs()
//
//  Purpose:    Uses a single ldap query to evaluate deferred
//              GPO lists.
//
//  Parameters: pldBound               - Bound LDAP handle
//              pLDAP                  - LDAP api
//              pwszDomainBound        - Domain already bound to
//              dwFlags                - GetGPOList flags
//              hToken                 - User or machine token
//              pDeferredForcedList    - List of deferred forced GPOs
//              pDeferredNonForcedList - List of deferred non-forced GPOs
//              pGPOForcedList         - List of forced GPOs
//              pGPONonForcedList      - List of non-forced GPOs
//              ppGpContainerList      - List of Gp Containers
//              pGpoFilter             - Gpo filter
//              pLocator               - WMI interfaces
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL EvaluateDeferredGPOs (PLDAP pldBound,
                           PLDAP_API pLDAP,
                           LPTSTR pwszDomainBound,
                           DWORD dwFlags,
                           HANDLE hToken,
                           BOOL bVerbose,
                           PGROUP_POLICY_OBJECT pDeferredForcedList,
                           PGROUP_POLICY_OBJECT pDeferredNonForcedList,
                           PGROUP_POLICY_OBJECT *ppForcedList,
                           PGROUP_POLICY_OBJECT *ppNonForcedList,
                           LPGPCONTAINER *ppGpContainerList,
                           PRSOPTOKEN pRsopToken,
                           CGpoFilter *pGpoFilter,
                           CLocator *pLocator )
{
    ULONG ulResult;
    BOOL bResult = FALSE;
    BYTE berValue[8];
    LDAPControl SeInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W, { 5, (PCHAR)berValue }, TRUE };
    LDAPControl referralControl = { LDAP_SERVER_DOMAIN_SCOPE_OID_W, { 0, NULL}, TRUE };
    PLDAPControl ServerControls[] = { &SeInfoControl, &referralControl, NULL };
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    TCHAR szCommonName[] = TEXT("cn");
    TCHAR szDisplayName[] = TEXT("displayName");
    TCHAR szFileSysPath[] = TEXT("gPCFileSysPath");
    TCHAR szVersion[] = TEXT("versionNumber");
    TCHAR szFunctionalityVersion[] = GPO_FUNCTIONALITY_VERSION;
    TCHAR szFlags[] = TEXT("flags");
    TCHAR szWmiFilter[] = TEXT("gPCWQLFilter");

    PWSTR rgAttribs[12] = {szSDProperty,
                           szFileSysPath,
                           szCommonName,
                           szDisplayName,
                           szVersion,
                           szFunctionalityVersion,
                           szFlags,
                           GPO_MACHEXTENSION_NAMES,
                           GPO_USEREXTENSION_NAMES,
                           szObjectClass,
                           szWmiFilter,
                           NULL };
    PGROUP_POLICY_OBJECT pGPOTemp = pDeferredForcedList;
    LDAPQUERY *pLdapQuery = NULL, *pQuery = NULL;
    VOID *pData;
    PDS_API pdsApi;
    BOOL bRsopPlanningMode = (pRsopToken != 0);
    BOOL bConfigContainer = FALSE;

    *ppForcedList = NULL;
    *ppNonForcedList = NULL;
    XLastError xe;

    if ( pDeferredForcedList == NULL && pDeferredNonForcedList == NULL )
        return TRUE;

    //
    // Demand load ntdsapi.dll
    //

    pdsApi = LoadDSApi();

    if ( pdsApi == 0 ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGpos: Failed to load ntdsapi.dll")));
        goto Exit;
    }

    while ( pGPOTemp ) {

        if ( !AddDN( pLDAP, &pLdapQuery, pGPOTemp->lpDSPath, NULL, pGPOTemp ) ) {
            xe = GetLastError();
            goto Exit;
        }
        
        pGPOTemp = pGPOTemp->pNext;

    }

    pGPOTemp = pDeferredNonForcedList;
    while ( pGPOTemp ) {

        if ( !AddDN( pLDAP, &pLdapQuery, pGPOTemp->lpDSPath, NULL, pGPOTemp ) ) {
             xe = GetLastError();
             goto Exit;
        }
        pGPOTemp = pGPOTemp->pNext;

    }

    //
    // Setup the BER encoding
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02; // denotes an integer
    berValue[3] = 0x01; // denotes size
    berValue[4] = (BYTE)((DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION) & 0xF);

    pQuery  = pLdapQuery;
    while ( pQuery ) {

        //
        // The check below needs to be more sophisticated to take care
        // of spaces in names etc. 
        // 
        // It is assumed that the configuration
        // container would be common across the whole forest and will
        // not need a new bind..
        //

        if (CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                            pQuery->pwszDomain, 16, TEXT("cn=configuration"), 16) == CSTR_EQUAL ) {
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs: DN %s is under cn=configuration container"), pQuery->pwszDomain ));
            bConfigContainer = TRUE;
        }
        else 
            bConfigContainer = FALSE;


        //
        // Check if this is a cross-domain Gpo and hence needs a new bind
        //

        WCHAR *pDomainString[1];
        PDS_NAME_RESULT pNameResult = NULL;
        PLDAP pLdapHandle = NULL;
    
        if (!bConfigContainer) 
            pDomainString[0] = pQuery->pwszDomain;
        else {
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs: The GPO is under the config container. Querying seperately\n")));
            
            //
            // This is a configuration container and we have to figure
            // out the domain name still..
            //

            LPTSTR pwszTemp = pQuery->pwszDomain;

            pDomainString[0] = NULL;

            while ( *pwszTemp ) {
                
                if (CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                    pwszTemp, 3, TEXT("DC="), 3) == CSTR_EQUAL ) {
                    pDomainString[0] = pwszTemp;
                    break;
                }

                //
                // Move to the next chunk of the DN name
                //

                while ( *pwszTemp && (*pwszTemp != TEXT(',')))
                    pwszTemp++;

                if ( *pwszTemp == TEXT(','))
                    pwszTemp++;

            }

            if ( pDomainString[0] == NULL ) {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs: Domain not found for <%s>. Exiting."), pQuery->pwszDomain ));
                goto Exit;
            }
        }
    
        ulResult = pdsApi->pfnDsCrackNames( (HANDLE) -1,
                                          DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                          DS_FQDN_1779_NAME,
                                          DS_CANONICAL_NAME,
                                          1,
                                          pDomainString,
                                          &pNameResult );
    
        if ( ulResult != ERROR_SUCCESS
             || pNameResult->cItems == 0
             || pNameResult->rItems[0].status != ERROR_SUCCESS
             || pNameResult->rItems[0].pDomain == NULL ) {
    
            xe = ulResult;
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs:  DsCrackNames failed with 0x%x."), ulResult ));
            goto Exit;
        }
    
        //
        // Optimize same domain Gpo queries by not doing an unnecessary bind
        //
    
        pQuery->pLdapHandle = pldBound;
    
        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                           pwszDomainBound, -1, pNameResult->rItems[0].pDomain, -1) != CSTR_EQUAL) {
    
            //
            // Cross-domain Gpo query and so need to bind to new domain
            //
    
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs: Doing an ldap bind to cross-domain <%s>"),
                      pNameResult->rItems[0].pDomain));
    
            pLdapHandle = pLDAP->pfnldap_init( pNameResult->rItems[0].pDomain, LDAP_PORT);
    
            if (!pLdapHandle) {
                xe = pLDAP->pfnLdapMapErrorToWin32(pLDAP->pfnLdapGetLastError());

                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  ldap_init for <%s> failed with = 0x%x or %d"),
                          pNameResult->rItems[0].pDomain, pLDAP->pfnLdapGetLastError(), GetLastError()));
                CEvents ev(TRUE, EVENT_FAILED_DS_INIT);
                ev.AddArg(pNameResult->rItems[0].pDomain); ev.AddArgLdapError(pLDAP->pfnLdapGetLastError()); ev.Report();
    
                pdsApi->pfnDsFreeNameResult( pNameResult );
    
                goto Exit;
            }
    
            //
            // Turn on Packet integrity flag
            //

            pData = (VOID *) LDAP_OPT_ON;
            ulResult = pLDAP->pfnldap_set_option(pLdapHandle, LDAP_OPT_SIGN, &pData);
    
            if (ulResult != LDAP_SUCCESS) {
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  Failed to turn on LDAP_OPT_SIGN with %d"), ulResult));
                pdsApi->pfnDsFreeNameResult( pNameResult );
                pLDAP->pfnldap_unbind(pLdapHandle);
                pLdapHandle = 0;
                goto Exit;
            }

            ulResult = pLDAP->pfnldap_connect(pLdapHandle, 0);

            if (ulResult != LDAP_SUCCESS) {
                CEvents ev(TRUE, EVENT_FAILED_DS_CONNECT);
                ev.AddArg(pNameResult->rItems[0].pDomain); ev.AddArgLdapError(ulResult); ev.Report();

                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  Failed to connect with %d"), ulResult));
                pdsApi->pfnDsFreeNameResult( pNameResult );
                pLDAP->pfnldap_unbind(pLdapHandle);
                pLdapHandle = 0;
                goto Exit;
            }

            //
            // Transfer ownerhip of ldap handle to pQuery struct
            //
    
            pQuery->pLdapHandle = pLdapHandle;
            pQuery->bOwnLdapHandle = TRUE;
    
            if ( !bRsopPlanningMode && (dwFlags & GPO_LIST_FLAG_MACHINE) ) {
    
                //
                // For machine policies specifically ask for Kerberos as the only authentication
                // mechanism. Otherwise if Kerberos were to fail for some reason, then NTLM is used
                // and localsystem context has no real credentials, which means that we won't get
                // any GPOs back.
                //
    
                SEC_WINNT_AUTH_IDENTITY_EXW secIdentity;
    
                secIdentity.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
                secIdentity.Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
                secIdentity.User = 0;
                secIdentity.UserLength = 0;
                secIdentity.Domain = 0;
                secIdentity.DomainLength = 0;
                secIdentity.Password = 0;
                secIdentity.PasswordLength = 0;
                secIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
                secIdentity.PackageList = wszKerberos;
                secIdentity.PackageListLength = lstrlen( wszKerberos );
    
                ulResult = pLDAP->pfnldap_bind_s (pLdapHandle, NULL, (WCHAR *)&secIdentity, LDAP_AUTH_SSPI);
    
            } else
                ulResult = pLDAP->pfnldap_bind_s (pLdapHandle, NULL, NULL, LDAP_AUTH_SSPI);
    
            if (ulResult != LDAP_SUCCESS) {
    
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  ldap_bind_s failed with = <%d>"),
                          ulResult));
                CEvents ev(TRUE, EVENT_FAILED_DS_BIND);
                ev.AddArg(pNameResult->rItems[0].pDomain); ev.AddArgLdapError(ulResult); ev.Report();
    
                pdsApi->pfnDsFreeNameResult( pNameResult );
    
                goto Exit;
            }
    
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs: Bind sucessful")));
    
        }

        pdsApi->pfnDsFreeNameResult( pNameResult );

        //
        // Turn referrals off because this is a single domain call
        //

        pData = (VOID *) LDAP_OPT_OFF;
        ulResult = pLDAP->pfnldap_set_option( pQuery->pLdapHandle,  LDAP_OPT_REFERRALS, &pData );
        if ( ulResult != LDAP_SUCCESS )
        {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
            DebugMsg((DM_WARNING, TEXT("EvalauteDeferredGPOs:  Failed to turn off referrals with error %d"), ulResult));
            goto Exit;
        }

        //
        // Search for GPOs
        //

        DmAssert( pQuery->pwszDomain != NULL && pQuery->pwszFilter != NULL );

        ulResult = pLDAP->pfnldap_search_ext_s(pQuery->pLdapHandle, pQuery->pwszDomain, LDAP_SCOPE_SUBTREE,
                                               pQuery->pwszFilter, rgAttribs, 0,
                                               (PLDAPControl*)ServerControls,
                                               NULL, NULL, 0x10000, &pQuery->pMessage);

        //
        // If the search fails, store the error code and return
        //

        if (ulResult != LDAP_SUCCESS) {

            if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {
                DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs:  All objects can not be accessed.")));

                if (dwFlags & GP_PLANMODE) { 
                    CEvents ev(TRUE, EVENT_NO_GPOS2_PLANNING); ev.Report();
                }
                else {
                    if (bVerbose) {
                        CEvents ev(FALSE, EVENT_NO_GPOS2); ev.Report();
                    }
                }
                bResult = TRUE;

            } else if (ulResult == LDAP_NO_SUCH_OBJECT) {
                DebugMsg((DM_VERBOSE, TEXT("EvalateDeferredGPOs:  Objects do not exist.") ));
                
                if (dwFlags & GP_PLANMODE) { 
                    // Same error or different
                    CEvents ev(TRUE, EVENT_NO_GPOS2_PLANNING); ev.Report();
                }
                else {
                    if (bVerbose) {
                        CEvents ev(FALSE, EVENT_NO_GPOS2); ev.Report();
                    }
                }

                bResult = TRUE;

            } else if (ulResult == LDAP_SIZELIMIT_EXCEEDED) {
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvalateDeferredGPOs:  Too many GPOs in search.") ));
                CEvents ev(TRUE, EVENT_TOO_MANY_GPOS); ev.Report();

            } else {
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvaluteDeferredGPOs:  Failed to search with error 0x%x"), ulResult));
                CEvents ev(TRUE, EVENT_FAILED_GPO_SEARCH);
                ev.AddArgLdapError(ulResult); ev.Report();
            }

            goto Exit;
        }

        //
        // If the search succeeds, but the message is empty,
        // store the error code and return
        //

        if ( pQuery->pMessage == NULL ) {
            xe = pLDAP->pfnLdapMapErrorToWin32(pQuery->pLdapHandle->ld_errno);                
            DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  Search returned an empty message structure.  Error = 0x%x"),
                     pQuery->pLdapHandle->ld_errno));
            goto Exit;
        }

        if ( !MatchDnWithDeferredItems( pLDAP, pQuery, FALSE ) ) {
            xe = GetLastError();
            goto Exit;
        }

        pQuery = pQuery->pNext;

    }   // while

    if ( !EvalList( pLDAP, dwFlags, hToken, bVerbose,
                    pDeferredForcedList, ppForcedList, ppGpContainerList, pRsopToken, pGpoFilter, pLocator ) ) {
        xe = GetLastError();
        goto Exit;
    }

    if ( !EvalList( pLDAP, dwFlags, hToken, bVerbose,
                    pDeferredNonForcedList, ppNonForcedList, ppGpContainerList, pRsopToken, pGpoFilter, pLocator ) ) {
        xe = GetLastError();
        goto Exit;
    }

    bResult = TRUE;

Exit:

    //
    // Free all resources except for ppForcedList, ppNonForcedList
    // which are owned by caller.
    //

    while ( pLdapQuery ) {
        pQuery = pLdapQuery->pNext;
        FreeLdapQuery( pLDAP, pLdapQuery );
        pLdapQuery = pQuery;
    }

    return bResult;
}


//*************************************************************
//
//  AddOU()
//
//  Purpose:    Appends an OU or domain to deferred list.
//
//  Parameters: ppOUList    - OU list to append to
//              pwszOU      - OU name
//              gpoLink     - Type of Gpo
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddOU( DNENTRY **ppOUList, LPTSTR pwszOU, GPO_LINK gpoLink )
{
    DNENTRY *pOUTemp = *ppOUList;
    DNENTRY *pOULast = NULL;

    DNENTRY *pOUNew = AllocDnEntry( pwszOU );
    if ( pOUNew == NULL ) {
        return FALSE;
    }

    pOUNew->gpoLink = gpoLink;

    while ( pOUTemp ) {
        pOULast = pOUTemp;
        pOUTemp = pOUTemp->pNext;
    }

    if ( pOULast )
        pOULast->pNext = pOUNew;
    else
        *ppOUList = pOUNew;

    return TRUE;
}


//*************************************************************
//
//  EvaluateDeferredOUs()
//
//  Purpose:    Uses a single Ldap query to evaluate all OUs
//
//  Parameters: ppOUList            - OU list to append to
//              dwFlags             - GetGPOList flags
//              pGPOForcedList      - List of forced GPOs
//              pGPONonForcedList   - List of non-forced GPOs
//              ppSOMList           - List of LSDOUs
//              ppGpContainerList   - List of Gp Containers
//              bVerbose            - Verbose output
//              pld                 - LDAP info
//              pLDAP               - LDAP api
//              pLDAPMsg            - LDAP message
//              bBlock              - Pointer to the block flag
//              hToken              - User / machine token
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL EvaluateDeferredOUs(   DNENTRY *pOUList,
                            DWORD dwFlags,
                            HANDLE hToken,
                            PGROUP_POLICY_OBJECT *ppDeferredForcedList,
                            PGROUP_POLICY_OBJECT *ppDeferredNonForcedList,
                            LPSCOPEOFMGMT *ppSOMList,
                            LPGPCONTAINER *ppGpContainerList,
                            BOOL bVerbose,
                            PLDAP  pld,
                            PLDAP_API pLDAP,
                            BOOL *pbBlock,
                            PRSOPTOKEN pRsopToken)
{
    ULONG ulResult;
    BOOL bResult = FALSE;
    LDAPQUERY   *pLdapQuery = NULL;
    BYTE         berValue[8];
    LDAPControl  SeInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W, { 5, (PCHAR)berValue }, TRUE };
    PLDAPControl ServerControls[] = { &SeInfoControl, NULL };

    TCHAR szGPLink[] = TEXT("gPLink");
    TCHAR szGPOptions[] = TEXT("gPOptions");
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    LPTSTR lpAttr[] = { szGPLink,
                        szGPOptions,
                        szSDProperty,
                        NULL
                      };
    DNENTRY *pOUTemp = pOUList;
    VOID *pData;
    XLastError xe;


    //
    // Setup the BER encoding for the SD
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02; // denotes an integer
    berValue[3] = 0x01; // denotes size
    berValue[4] = (BYTE)((DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION) & 0xF);


    if ( !pRsopToken )
    {
        //
        // if it is not planning mode, don't get the SD
        // 

        lpAttr[2] = NULL;
        ServerControls[0] = NULL;
    }


    if ( pOUTemp == NULL )
        return TRUE;

    while ( pOUTemp ) {
        if ( !AddDN( pLDAP, &pLdapQuery, pOUTemp->pwszDN, pOUTemp, NULL ) ) {
            xe = GetLastError();
            goto Exit;
        }
        pOUTemp = pOUTemp->pNext;
    }

    pLdapQuery->pLdapHandle = pld;

    //
    // Turn referrals off because this is a single domain call
    //

    if ( !pRsopToken )
    {
        pData = (VOID *) LDAP_OPT_OFF;
        ulResult = pLDAP->pfnldap_set_option( pLdapQuery->pLdapHandle,  LDAP_OPT_REFERRALS, &pData );
        if ( ulResult != LDAP_SUCCESS ) {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("EvaluteDeferredOUs:  Failed to turn off referrals with error %d"), ulResult));
            goto Exit;
        }
    }
    

    ulResult = pLDAP->pfnldap_search_ext_s(pld, pLdapQuery->pwszDomain, LDAP_SCOPE_SUBTREE,
                                           pLdapQuery->pwszFilter, lpAttr, FALSE,
                                           (PLDAPControl*)ServerControls,
                                           NULL, NULL, 0, &pLdapQuery->pMessage);


    //
    // If the search fails, store the error code and return
    //

    if (ulResult != LDAP_SUCCESS) {

        if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredOUs:  All objects can not be accessed.")));
            bResult = TRUE;

        } else if (ulResult == LDAP_NO_SUCH_OBJECT) {
            DebugMsg((DM_VERBOSE, TEXT("EvalateDeferredOUs:  Objects do not exist.") ));
            bResult = TRUE;

        } else if (ulResult == LDAP_SIZELIMIT_EXCEEDED) {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("EvalateDeferredOUs:  Too many linked GPOs in search.") ));
            CEvents ev(TRUE, EVENT_TOO_MANY_GPOS); ev.Report();

        } else {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("EvaluateDeferredOUs:  Failed to search with error %d"), ulResult));
            CEvents ev(TRUE, EVENT_FAILED_OU_SEARCH);
            ev.AddArg(ulResult); ev.Report();
        }

        goto Exit;
    }

    //
    // If the search succeeds, but the message is empty,
    // store the error code and return
    //

    if ( pLdapQuery->pMessage == NULL ) {
        xe = pLDAP->pfnLdapMapErrorToWin32(pld->ld_errno);
        DebugMsg((DM_WARNING, TEXT("EvaluateDeferredOUs:  Search returned an empty message structure.  Error = %d"),
                  pld->ld_errno));
        goto Exit;
    }

    if ( !MatchDnWithDeferredItems( pLDAP, pLdapQuery, TRUE ) ) {
        xe = GetLastError();
        goto Exit;
    }

    //
    // Evaluate the OU list
    //

    pOUTemp = pOUList;

    while ( pOUTemp ) {

        PLDAPMessage pOUMsg = pOUTemp->pOUMsg;

        if ( pOUMsg == NULL ) {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("EvaluateDeferredOUs: Object <%s> cannot be accessed"),
                      pOUTemp->pwszDN ));
            
            CEvents ev(TRUE, EVENT_OU_NOTFOUND);
            ev.AddArg(pOUTemp->pwszDN); ev.Report();

            goto Exit;

        } else {
               if ( !SearchDSObject( pOUTemp->pwszDN, dwFlags, hToken, ppDeferredForcedList, ppDeferredNonForcedList,
                                     ppSOMList, ppGpContainerList,
                                     bVerbose, pOUTemp->gpoLink, pld, pLDAP, pOUMsg, pbBlock, pRsopToken)) {
                   xe = GetLastError();
                   DebugMsg((DM_WARNING, TEXT("EvaluateDeferredOUs:  SearchDSObject failed") ));
                   goto Exit;
               }
        }

        pOUTemp = pOUTemp->pNext;

    }

    bResult = TRUE;

Exit:

    while ( pLdapQuery ) {
        LDAPQUERY *pQuery = pLdapQuery->pNext;
        FreeLdapQuery( pLDAP, pLdapQuery );
        pLdapQuery = pQuery;
    }

    return bResult;
}



//*************************************************************
//
//  GetMachineDomainDS()
//
//  Purpose:    Obtain the machine domain DS
//
//  Parameters: pNetApi32       - netapi32.dll
//              pLdapApi        - wldap32.dll
//
//  Return:     valid PLDAP if successful
//              0 if an error occurs
//
//*************************************************************
PLDAP
GetMachineDomainDS( PNETAPI32_API pNetApi32, PLDAP_API pLdapApi )
{
    PLDAP       pld = 0;

    DWORD       dwResult = 0;
    PDOMAIN_CONTROLLER_INFO pDCI = 0;
    ULONG ulResult;
    VOID *pData;
    XLastError xe;

    //
    // get the machine domain name
    //

    dwResult = pNetApi32->pfnDsGetDcName(   0,
                                            0,
                                            0,
                                            0,
                                            DS_DIRECTORY_SERVICE_REQUIRED,
                                            &pDCI);
    if ( dwResult == ERROR_SUCCESS )
    {
        SEC_WINNT_AUTH_IDENTITY_EXW secIdentity;

        pld = pLdapApi->pfnldap_init( pDCI->DomainName, LDAP_PORT );


        if (!pld) {
            xe = pLdapApi->pfnLdapMapErrorToWin32(pLdapApi->pfnLdapGetLastError());
            DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS:  ldap_open for <%s> failed with = 0x%x or %d"),
                                 pDCI->DomainName, pLdapApi->pfnLdapGetLastError(), GetLastError()));
            return pld;
        }

        //
        // Turn on Packet integrity flag
        //

        pData = (VOID *) LDAP_OPT_ON;
        ulResult = pLdapApi->pfnldap_set_option(pld, LDAP_OPT_SIGN, &pData);

        if (ulResult != LDAP_SUCCESS) {

            xe = pLdapApi->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS:  Failed to turn on LDAP_OPT_SIGN with %d"), ulResult));
            pLdapApi->pfnldap_unbind(pld);
            pld = 0;
            return pld;
        }

        ulResult = pLdapApi->pfnldap_connect(pld, 0);

        if (ulResult != LDAP_SUCCESS) {

            xe = pLdapApi->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS:  Failed to connect with %d"), ulResult));
            pLdapApi->pfnldap_unbind(pld);
            pld = 0;
            return pld;
        }

        //
        // For machine policies specifically ask for Kerberos as the only authentication
        // mechanism. Otherwise if Kerberos were to fail for some reason, then NTLM is used
        // and localsystem context has no real credentials, which means that we won't get
        // any GPOs back.
        //

        secIdentity.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        secIdentity.Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
        secIdentity.User = 0;
        secIdentity.UserLength = 0;
        secIdentity.Domain = 0;
        secIdentity.DomainLength = 0;
        secIdentity.Password = 0;
        secIdentity.PasswordLength = 0;
        secIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        secIdentity.PackageList = wszKerberos;
        secIdentity.PackageListLength = lstrlen( wszKerberos );

        if ( (ulResult = pLdapApi->pfnldap_bind_s (pld, 0, (WCHAR *)&secIdentity, LDAP_AUTH_SSPI)) != LDAP_SUCCESS )
        {
            xe = pLdapApi->pfnLdapMapErrorToWin32(ulResult);
            pLdapApi->pfnldap_unbind(pld);
            pld = 0;
        }

        pNetApi32->pfnNetApiBufferFree(pDCI);
    }
    else
    {
        xe = dwResult;
        DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS:  The domain does not have a DS")));
    }


    return pld;
}



//*************************************************************
//
//  AllocSOM()
//
//  Purpose:    Allocates a new struct for SOM
//
//
//  Parameters: pwszSOMId  - Name of SOM
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

SCOPEOFMGMT *AllocSOM( LPWSTR pwszSOMId )
{
    XLastError xe;
    SCOPEOFMGMT *pSOM = (SCOPEOFMGMT *) LocalAlloc( LPTR, sizeof(SCOPEOFMGMT) );

    if ( pSOM == NULL ) {
        xe = GetLastError();
        return NULL;
    }

    pSOM->pwszSOMId = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszSOMId) + 1) * sizeof(WCHAR) );
    if ( pSOM->pwszSOMId == NULL ) {
        xe = GetLastError();
        LocalFree( pSOM );
        return NULL;
    }

    lstrcpy( pSOM->pwszSOMId, pwszSOMId );
    
    return pSOM;
}


//*************************************************************
//
//  FreeSOM()
//
//  Purpose:    Frees SOM struct
//
//  Parameters: pSOM - SOM to free
//
//*************************************************************

void FreeSOM( SCOPEOFMGMT *pSOM )
{
    GPLINK *pGpLink = NULL;

    if ( pSOM ) {

        LocalFree( pSOM->pwszSOMId );

        pGpLink = pSOM->pGpLinkList;
        while ( pGpLink ) {
            GPLINK *pTemp = pGpLink->pNext;
            FreeGpLink( pGpLink );
            pGpLink = pTemp;
        }

        LocalFree( pSOM );

    }
}



//*************************************************************
//
//  AllocGpLink()
//
//  Purpose:    Allocates a new struct for GpLink
//
//
//  Parameters: pwszGPO  - Name of GPO
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

GPLINK *AllocGpLink( LPWSTR pwszGPO, DWORD dwOptions )
{
    //
    // Strip out "LDAP://" prefix to get canonical Gpo path
    //

    WCHAR wszPrefix[] = TEXT("LDAP://");
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPath = pwszGPO;
    GPLINK *pGpLink = NULL;
    XLastError xe;

    if ( (lstrlen(pwszGPO) > iPrefixLen)
         && CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                           pwszGPO, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
       pwszPath = pwszGPO + iPrefixLen;
    }

    pGpLink = (GPLINK *) LocalAlloc( LPTR, sizeof(GPLINK) );

    if ( pGpLink == NULL ) {
        xe = GetLastError();
        return NULL;
    }

    pGpLink->pwszGPO = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszPath) + 1) * sizeof(WCHAR) );
    if ( pGpLink->pwszGPO == NULL ) {
        xe = GetLastError();
        LocalFree( pGpLink );
        return NULL;
    }

    lstrcpy( pGpLink->pwszGPO, pwszPath );

    pGpLink->bEnabled = (dwOptions & GPO_FLAG_DISABLE) ? FALSE : TRUE;

    if ( dwOptions & GPO_FLAG_FORCE )
        pGpLink->bNoOverride = TRUE;

    return pGpLink;
}



//*************************************************************
//
//  FreeGpLink()
//
//  Purpose:    Frees GpLink struct
//
//  Parameters: pGpLink - GpLink to free
//
//*************************************************************

void FreeGpLink( GPLINK *pGpLink )
{
    if ( pGpLink ) {
        LocalFree( pGpLink->pwszGPO );
        LocalFree( pGpLink );
    }
}


//*************************************************************
//
//  AllocGpContainer()
//
//  Purpose:    Allocates a new struct for GpContainer
//
//
//  Parameters: dwFlags        - Flags
//              bFound         - Was Gpo found ?
//              bAccessGranted - Was access granted ?
//              bDisabled      - Is Gp Container disabled ?
//              dwVersion      - Version #
//              lpDSPath       - DS path to Gpo
//              lpFileSysPath  - Sysvol path to Gpo
//              lpDisplayName  - Friendly name
//              lpGpoName      - Guid name
//              pSD            - Security descriptor
//              cbSDLen        - Length of security descriptor
//              bFilterAllowed    - Does GPO pass filter check
//              pwszFilterId      - WQL filter id
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

GPCONTAINER *AllocGpContainer(  DWORD dwFlags,
                                BOOL bFound,
                                BOOL bAccessGranted,
                                BOOL bDisabled,
                                DWORD dwVersion,
                                LPTSTR lpDSPath,
                                LPTSTR lpFileSysPath,
                                LPTSTR lpDisplayName,
                                LPTSTR lpGpoName,
                                PSECURITY_DESCRIPTOR pSD,
                                DWORD cbSDLen,
                                BOOL bFilterAllowed,
                                WCHAR *pwszFilterId,
                                LPWSTR szSOM,
                                DWORD  dwOptions )
{
    WCHAR wszMachPrefix[] = TEXT("LDAP://CN=Machine,");
    INT iMachPrefixLen = lstrlen( wszMachPrefix );
    WCHAR wszUserPrefix[] = TEXT("LDAP://CN=User,");
    INT iUserPrefixLen = lstrlen( wszUserPrefix );
    WCHAR *pwszPath = lpDSPath;
    BOOL bResult = FALSE;
    GPCONTAINER *pGpContainer = NULL;
    XLastError xe;

    //
    // Strip out prefix, if any, to get the canonical path to Gpo
    //

    if ( (lstrlen(lpDSPath) > iUserPrefixLen)
         && CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                           lpDSPath, iUserPrefixLen, wszUserPrefix, iUserPrefixLen ) == CSTR_EQUAL ) {
        pwszPath = lpDSPath + iUserPrefixLen;
    } else if ( (lstrlen(lpDSPath) > iMachPrefixLen)
                && CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                  lpDSPath, iMachPrefixLen, wszMachPrefix, iMachPrefixLen ) == CSTR_EQUAL ) {
        pwszPath = lpDSPath + iMachPrefixLen;
    }

    pGpContainer = (GPCONTAINER *) LocalAlloc( LPTR, sizeof(GPCONTAINER) );

    if ( pGpContainer == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
        return NULL;
    }

    pGpContainer->bAccessDenied = !bAccessGranted;
    pGpContainer->bFound = bFound;

    if ( dwFlags & GP_MACHINE ) {
        pGpContainer->bMachDisabled = bDisabled;
        pGpContainer->dwMachVersion = dwVersion;
    } else {
        pGpContainer->bUserDisabled  = bDisabled;
        pGpContainer->dwUserVersion  = dwVersion;
    }

    if ( pwszPath ) {

        pGpContainer->pwszDSPath = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszPath) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszDSPath == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        lstrcpy( pGpContainer->pwszDSPath, pwszPath );

    }

    if ( lpGpoName ) {

        pGpContainer->pwszGPOName = (LPWSTR) LocalAlloc( LPTR, (lstrlen(lpGpoName) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszGPOName == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        lstrcpy( pGpContainer->pwszGPOName, lpGpoName );

    }

    if ( lpDisplayName ) {

        pGpContainer->pwszDisplayName = (LPWSTR) LocalAlloc( LPTR, (lstrlen(lpDisplayName) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszDisplayName == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        lstrcpy( pGpContainer->pwszDisplayName, lpDisplayName );

    }

    if ( lpFileSysPath ) {

        pGpContainer->pwszFileSysPath = (LPWSTR) LocalAlloc( LPTR, (lstrlen(lpFileSysPath) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszFileSysPath == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        lstrcpy( pGpContainer->pwszFileSysPath, lpFileSysPath );

    }

    if ( cbSDLen != 0 ) {

        pGpContainer->pSD = (PSECURITY_DESCRIPTOR) LocalAlloc( LPTR, cbSDLen );
        if ( pGpContainer->pSD == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        CopyMemory( pGpContainer->pSD, pSD, cbSDLen );

    }

    pGpContainer->cbSDLen = cbSDLen;

    pGpContainer->bFilterAllowed = bFilterAllowed;

    if ( pwszFilterId ) {

        pGpContainer->pwszFilterId = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszFilterId) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszFilterId == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        lstrcpy( pGpContainer->pwszFilterId, pwszFilterId );

    }

    if ( szSOM )
    {
        pGpContainer->szSOM = (LPWSTR) LocalAlloc( LPTR, (lstrlen(szSOM) + 1) * sizeof(WCHAR) );
        if ( !pGpContainer->szSOM )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }
        wcscpy( pGpContainer->szSOM, szSOM );
    }

    pGpContainer->dwOptions = dwOptions;

    bResult = TRUE;

Exit:

    if ( !bResult )
    {
        LocalFree( pGpContainer->pwszDSPath );
        LocalFree( pGpContainer->pwszGPOName );
        LocalFree( pGpContainer->pwszDisplayName );
        LocalFree( pGpContainer->pwszFileSysPath );
        LocalFree( pGpContainer->pSD );
        LocalFree( pGpContainer->pwszFilterId );
        LocalFree( pGpContainer->szSOM );

        LocalFree( pGpContainer );

        return 0;
    }

    return pGpContainer;
}



//*************************************************************
//
//  FreeGpContainer()
//
//  Purpose:    Frees GpContainer struct
//
//  Parameters: pGpContainer - Gp Container to free
//
//*************************************************************

void FreeGpContainer( GPCONTAINER *pGpContainer )
{
    if ( pGpContainer ) {

        LocalFree( pGpContainer->pwszDSPath );
        LocalFree( pGpContainer->pwszGPOName );
        LocalFree( pGpContainer->pwszDisplayName );
        LocalFree( pGpContainer->pwszFileSysPath );
        LocalFree( pGpContainer->pSD );
        LocalFree( pGpContainer->pwszFilterId );
        LocalFree( pGpContainer->szSOM );
        LocalFree( pGpContainer );

    }
}


//*************************************************************
//
//  FreeSOMList()
//
//  Purpose:    Frees list of SOMs
//
//  Parameters: pSOMList - SOM list to free
//
//*************************************************************

void FreeSOMList( SCOPEOFMGMT *pSOMList )
{
    if ( pSOMList == NULL )
        return;

    while ( pSOMList ) {
        SCOPEOFMGMT *pTemp = pSOMList->pNext;
        FreeSOM( pSOMList );
        pSOMList = pTemp;
    }
}


//*************************************************************
//
//  FreeGpContainerList()
//
//  Purpose:    Frees list of Gp Containers
//
//  Parameters: pGpContainerList - Gp Container list to free
//
//*************************************************************

void FreeGpContainerList( GPCONTAINER *pGpContainerList )
{
    if ( pGpContainerList == NULL )
        return;

    while ( pGpContainerList ) {
        GPCONTAINER *pTemp = pGpContainerList->pNext;
        FreeGpContainer( pGpContainerList );
        pGpContainerList = pTemp;
    }
}

LPTSTR GetSomPath( LPTSTR szContainer )
{
    while (*szContainer) {

        //
        // See if the DN name starts with OU=
        //

        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                           szContainer, 3, TEXT("OU="), 3) == CSTR_EQUAL) {
            break;
        }

        //
        // See if the DN name starts with DC=
        //

        else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                szContainer, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
            break;
        }


        //
        // Move to the next chunk of the DN name
        //

        while (*szContainer && (*szContainer != TEXT(','))) {
            szContainer++;
        }

        if (*szContainer == TEXT(',')) {
            szContainer++;
        }
    }

    if (!*szContainer) {
        return NULL;
    }

    return szContainer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gpstate.cpp ===
//*************************************************************
//
//  Group Policy Support - State functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"

//*************************************************************
//
//  GetDeletedGPOList()
//
//  Purpose:    Get the list of deleted GPOs
//
//  Parameters: lpGPOList        -  List of old GPOs
//              ppDeletedGPOList -  Deleted list returned here
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetDeletedGPOList (PGROUP_POLICY_OBJECT lpGPOList,
                        PGROUP_POLICY_OBJECT *ppDeletedGPOList)
{
     //
     // It's possible that lpGPOList could be NULL.  This is ok.
     //

    if (!lpGPOList) {
        DebugMsg((DM_VERBOSE, TEXT("GetDeletedList: No old GPOs.  Leaving.")));
        return TRUE;
    }

    //
    // We need to do any delete operations in reverse order
    // of the way there were applied. Also, check that duplicates
    // of same GPO are not being added.
    //

    while ( lpGPOList ) {

        PGROUP_POLICY_OBJECT pCurGPO = lpGPOList;
        lpGPOList = lpGPOList->pNext;

        if ( pCurGPO->lParam & GPO_LPARAM_FLAG_DELETE ) {

            PGROUP_POLICY_OBJECT lpGPODest = *ppDeletedGPOList;
            BOOL bDup = FALSE;

            while (lpGPODest) {

                if (!lstrcmpi (pCurGPO->szGPOName, lpGPODest->szGPOName)) {
                    bDup = TRUE;
                    break;
                }

                lpGPODest = lpGPODest->pNext;
            }

            if (!bDup) {

                //
                // Not a duplicate, so prepend to deleted list
                //

                pCurGPO->pNext = *ppDeletedGPOList;
                pCurGPO->pPrev = NULL;

                if ( *ppDeletedGPOList )
                    (*ppDeletedGPOList)->pPrev = pCurGPO;

                *ppDeletedGPOList = pCurGPO;
            } else
                LocalFree( pCurGPO );

        } else
            LocalFree( pCurGPO );

    }

    DebugMsg((DM_VERBOSE, TEXT("GetDeletedGPOList: Finished.")));

    return TRUE;
}


//*************************************************************
//
//  ReadGPOList()
//
//  Purpose:    Reads the list of Group Policy Objects from
//              the registry
//
//  Parameters: pszExtName -  GP extension
//              hKeyRoot   -  Registry handle
//              hKeyRootMach - Registry handle to hklm
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//              bShadow    -  Read from shadow or from history list
//              lpGPOList  -  pointer to the array of GPOs
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ReadGPOList ( TCHAR * pszExtName, HKEY hKeyRoot,
                   HKEY hKeyRootMach, LPTSTR lpwszSidUser, BOOL bShadow,
                   PGROUP_POLICY_OBJECT * lpGPOList)
{
    INT iIndex = 0;
    LONG lResult;
    HKEY hKey, hSubKey = NULL;
    BOOL bResult = FALSE;
    TCHAR szSubKey[10];
    DWORD dwOptions, dwVersion;
    GPO_LINK GPOLink;
    LPARAM lParam;
    TCHAR szGPOName[50];
    LPTSTR lpDSPath = NULL, lpFileSysPath = NULL, lpDisplayName = NULL, lpExtensions = NULL, lpLink = NULL;
    DWORD dwDisp, dwSize, dwType, dwTemp, dwMaxSize;
    PGROUP_POLICY_OBJECT lpGPO, lpGPOTemp;
    TCHAR szKey[400];
    XLastError xe;


    //
    // Set default
    //

    *lpGPOList = NULL;


    //
    // Open the key that holds the GPO list
    //

    if ( lpwszSidUser == 0 ) {
        wsprintf (szKey,
                  bShadow ? GP_SHADOW_KEY
                            : GP_HISTORY_KEY,
                  pszExtName );

    } else {
        wsprintf (szKey,
                  bShadow ? GP_SHADOW_SID_KEY
                          : GP_HISTORY_SID_KEY,
                          lpwszSidUser, pszExtName );
    }

    lResult = RegOpenKeyEx ( lpwszSidUser ? hKeyRootMach : hKeyRoot,
                            szKey,
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {

        if (lResult == ERROR_FILE_NOT_FOUND) {
            return TRUE;

        } else {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to open reg key with %d."), lResult));
            return FALSE;
        }
    }


    while (TRUE) {

        //
        // Enumerate through the subkeys.  The keys are named by index number
        // eg:  0, 1, 2, 3, etc...
        //

        IntToString (iIndex, szSubKey);

        lResult = RegOpenKeyEx (hKey, szSubKey, 0, KEY_READ, &hSubKey);

        if (lResult != ERROR_SUCCESS) {

            if (lResult == ERROR_FILE_NOT_FOUND) {
                bResult = TRUE;
                goto Exit;

            } else {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to open reg key <%s> with %d."), szSubKey, lResult));
                goto Exit;
            }
        }


        //
        // Read the size of the largest value in this key
        //

        lResult = RegQueryInfoKey (hSubKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                                   &dwMaxSize, NULL, NULL);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query max size with %d."), lResult));
            goto Exit;
        }


        //
        // RegQueryInfoKey does not account for trailing 0 in strings
        //

        dwMaxSize += sizeof( WCHAR );

        
        //
        // Allocate buffers based upon the value above
        //

        lpDSPath = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpDSPath) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        lpFileSysPath = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpFileSysPath) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        lpDisplayName = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpDisplayName) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        lpExtensions = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpExtensions) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        lpLink = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpLink) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        //
        // Read in the GPO
        //

        dwOptions = 0;
        dwSize = sizeof(dwOptions);
        lResult = RegQueryValueEx (hSubKey, TEXT("Options"), NULL, &dwType,
                                  (LPBYTE) &dwOptions, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query options reg value with %d."), lResult));
        }


        dwVersion = 0;
        dwSize = sizeof(dwVersion);
        lResult = RegQueryValueEx (hSubKey, TEXT("Version"), NULL, &dwType,
                                  (LPBYTE) &dwVersion, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query Version reg value with %d."), lResult));
        }


        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("DSPath"), NULL, &dwType,
                                  (LPBYTE) lpDSPath, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            if (lResult != ERROR_FILE_NOT_FOUND) {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query DS reg value with %d."), lResult));
                goto Exit;
            }
            LocalFree (lpDSPath);
            lpDSPath = NULL;
        }

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("FileSysPath"), NULL, &dwType,
                                  (LPBYTE) lpFileSysPath, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query file sys path reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("DisplayName"), NULL, &dwType,
                                  (LPBYTE) lpDisplayName, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query display name reg value with %d."), lResult));
            goto Exit;
        }

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("Extensions"), NULL, &dwType,
                                  (LPBYTE) lpExtensions, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query extension names reg value with %d."), lResult));

            LocalFree(lpExtensions);
            lpExtensions = NULL;
        }

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("Link"), NULL, &dwType,
                                  (LPBYTE) lpLink, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            if (lResult != ERROR_FILE_NOT_FOUND) {
                DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query DS Object reg value with %d."), lResult));
            }
            LocalFree(lpLink);
            lpLink = NULL;
        }

        dwSize = sizeof(szGPOName);
        lResult = RegQueryValueEx (hSubKey, TEXT("GPOName"), NULL, &dwType,
                                  (LPBYTE) szGPOName, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query GPO name reg value with %d."), lResult));
            goto Exit;
        }


        GPOLink = GPLinkUnknown;
        dwSize = sizeof(GPOLink);
        lResult = RegQueryValueEx (hSubKey, TEXT("GPOLink"), NULL, &dwType,
                                  (LPBYTE) &GPOLink, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query reserved reg value with %d."), lResult));
        }


        lParam = 0;
        dwSize = sizeof(lParam);
        lResult = RegQueryValueEx (hSubKey, TEXT("lParam"), NULL, &dwType,
                                  (LPBYTE) &lParam, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query lParam reg value with %d."), lResult));
        }


        //
        // Add the GPO to the list
        //

        if (!AddGPO (lpGPOList, 0, TRUE, TRUE, FALSE, dwOptions, dwVersion, lpDSPath, lpFileSysPath,
                     lpDisplayName, szGPOName, lpExtensions, 0, 0, GPOLink, lpLink, lParam, FALSE,
                     FALSE, FALSE, TRUE)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to add GPO to list.")));
            goto Exit;
        }


        //
        // Free the buffers allocated above
        //

        if (lpDSPath) {
            LocalFree (lpDSPath);
            lpDSPath = NULL;
        }

        LocalFree (lpFileSysPath);
        lpFileSysPath = NULL;

        LocalFree (lpDisplayName);
        lpDisplayName = NULL;

        if (lpExtensions) {
            LocalFree(lpExtensions);
            lpExtensions = NULL;
        }

        if (lpLink) {
            LocalFree(lpLink);
            lpLink = NULL;
        }

        //
        // Close the subkey handle
        //

        RegCloseKey (hSubKey);
        hSubKey = NULL;

        iIndex++;
    }

Exit:

    if (lpDSPath) {
        LocalFree (lpDSPath);
    }

    if (lpFileSysPath) {
        LocalFree (lpFileSysPath);
    }

    if (lpDisplayName) {
        LocalFree (lpDisplayName);
    }

    if (lpExtensions) {
        LocalFree(lpExtensions);
    }

    if (lpLink) {
        LocalFree(lpLink);
    }


    if (hSubKey) {
        RegCloseKey (hSubKey);
    }

    RegCloseKey (hKey);

    if (!bResult) {

        //
        // Free any entries in the list
        //

        lpGPO = *lpGPOList;

        while (lpGPO) {
            lpGPOTemp = lpGPO->pNext;
            LocalFree (lpGPO);
            lpGPO = lpGPOTemp;
        }

        *lpGPOList = NULL;
    }


    return bResult;
}

//*************************************************************
//
//  SaveGPOList()
//
//  Purpose:    Saves the list of Group Policy Objects in
//              the registry
//
//  Parameters: pszExtName -  GP extension
//              lpGPOInfo  -  Group policy info
//              hKeyRootMach - Registry handle to hklm
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//              bShadow    -  Save to shadow or to history list
//              lpGPOList  -  Array of GPOs
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SaveGPOList (TCHAR *pszExtName, LPGPOINFO lpGPOInfo,
                  HKEY hKeyRootMach, LPTSTR lpwszSidUser, BOOL bShadow,
                  PGROUP_POLICY_OBJECT lpGPOList)
{
    INT iIndex = 0;
    LONG lResult;
    HKEY hKey = NULL;
    BOOL bResult = FALSE;
    TCHAR szSubKey[400];
    DWORD dwDisp, dwSize;
    XLastError xe;


    //
    // Start off with an empty key
    //
    if ( lpwszSidUser == 0 ) {
        wsprintf (szSubKey,
                  bShadow ? GP_SHADOW_KEY
                          : GP_HISTORY_KEY,
                  pszExtName);
    } else {
        wsprintf (szSubKey,
                  bShadow ? GP_SHADOW_SID_KEY
                          : GP_HISTORY_SID_KEY,
                  lpwszSidUser, pszExtName);
    }

    if (!RegDelnode (lpwszSidUser ? hKeyRootMach : lpGPOInfo->hKeyRoot,
                     szSubKey)) {
        DebugMsg((DM_VERBOSE, TEXT("SaveGPOList: RegDelnode failed.")));
    }


    //
    // Check if we have any GPOs to store.  It's ok for this to be NULL.
    //

    if (!lpGPOList) {
        return TRUE;
    }

    //
    // Set the proper security on the registry key
    //

    if ( !MakeRegKeySecure( (lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : lpGPOInfo->hToken,
                            lpwszSidUser ? hKeyRootMach : lpGPOInfo->hKeyRoot,
                            szSubKey ) ) {
        DebugMsg((DM_WARNING, TEXT("SaveGpoList: Failed to secure reg key.")));
    }

    //
    // Loop through the GPOs saving them in the registry
    //

    while (lpGPOList) {

        if ( lpwszSidUser == 0 ) {
            wsprintf (szSubKey,
                      bShadow ? TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Shadow\\%ws\\%d")
                              : TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History\\%ws\\%d"),
                      pszExtName,
                      iIndex);
        } else {
            wsprintf (szSubKey,
                      bShadow ? TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\Shadow\\%ws\\%d")
                              : TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\History\\%ws\\%d"),
                      lpwszSidUser, pszExtName, iIndex);
        }

        lResult = RegCreateKeyEx (lpwszSidUser ? hKeyRootMach : lpGPOInfo->hKeyRoot,
                                  szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to create reg key with %d."), lResult));
            goto Exit;
        }


        //
        // Save the GPO
        //

        dwSize = sizeof(lpGPOList->dwOptions);
        lResult = RegSetValueEx (hKey, TEXT("Options"), 0, REG_DWORD,
                                 (LPBYTE) &lpGPOList->dwOptions, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set options reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = sizeof(lpGPOList->dwVersion);
        lResult = RegSetValueEx (hKey, TEXT("Version"), 0, REG_DWORD,
                                 (LPBYTE) &lpGPOList->dwVersion, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set Version reg value with %d."), lResult));
            goto Exit;
        }


        if (lpGPOList->lpDSPath) {

            dwSize = (lstrlen (lpGPOList->lpDSPath) + 1) * sizeof(TCHAR);
            lResult = RegSetValueEx (hKey, TEXT("DSPath"), 0, REG_SZ,
                                     (LPBYTE) lpGPOList->lpDSPath, dwSize);

            if (lResult != ERROR_SUCCESS) {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set DS reg value with %d."), lResult));
                goto Exit;
            }
        }

        dwSize = (lstrlen (lpGPOList->lpFileSysPath) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKey, TEXT("FileSysPath"), 0, REG_SZ,
                                  (LPBYTE) lpGPOList->lpFileSysPath, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set file sys path reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = (lstrlen (lpGPOList->lpDisplayName) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKey, TEXT("DisplayName"), 0, REG_SZ,
                                (LPBYTE) lpGPOList->lpDisplayName, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set display name reg value with %d."), lResult));
            goto Exit;
        }

        if (lpGPOList->lpExtensions) {

            dwSize = (lstrlen (lpGPOList->lpExtensions) + 1) * sizeof(TCHAR);
            lResult = RegSetValueEx (hKey, TEXT("Extensions"), 0, REG_SZ,
                                    (LPBYTE) lpGPOList->lpExtensions, dwSize);

            if (lResult != ERROR_SUCCESS) {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set extension names reg value with %d."), lResult));
                goto Exit;
            }

        }

        if (lpGPOList->lpLink) {

            dwSize = (lstrlen (lpGPOList->lpLink) + 1) * sizeof(TCHAR);
            lResult = RegSetValueEx (hKey, TEXT("Link"), 0, REG_SZ,
                                    (LPBYTE) lpGPOList->lpLink, dwSize);

            if (lResult != ERROR_SUCCESS) {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set DSObject reg value with %d."), lResult));
                goto Exit;
            }

        }

        dwSize = (lstrlen (lpGPOList->szGPOName) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKey, TEXT("GPOName"), 0, REG_SZ,
                                  (LPBYTE) lpGPOList->szGPOName, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set GPO name reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = sizeof(lpGPOList->GPOLink);
        lResult = RegSetValueEx (hKey, TEXT("GPOLink"), 0, REG_DWORD,
                                 (LPBYTE) &lpGPOList->GPOLink, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set GPOLink reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = sizeof(lpGPOList->lParam);
        lResult = RegSetValueEx (hKey, TEXT("lParam"), 0, REG_DWORD,
                                 (LPBYTE) &lpGPOList->lParam, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set lParam reg value with %d."), lResult));
            goto Exit;
        }

        //
        // Close the handle
        //

        RegCloseKey (hKey);
        hKey = NULL;


        //
        // Prep for the next loop
        //

        iIndex++;
        lpGPOList = lpGPOList->pNext;
    }


    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (hKey) {
        RegCloseKey (hKey);
    }

    return bResult;
}


//*************************************************************
//
//  WriteStatus()
//
//  Purpose:    Saves status in the registry
//
//  Parameters: lpGPOInfo  -  GPO info
//              lpExtName  -  GP extension name
//              dwStatus   -  Status to write
//              dwTime     -  Policy time to write
//              dwSlowLink -  Link speed to write
//              dwRsopLogging - Rsop Logging to Write
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WriteStatus( TCHAR *lpExtName, LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, LPGPEXTSTATUS lpExtStatus )
{
    HKEY hKey = NULL, hKeyExt = NULL;
    DWORD dwDisp, dwSize;
    LONG lResult;
    BOOL bResult = FALSE;
    TCHAR szKey[400];
    XLastError xe;

    if ( lpwszSidUser == 0 ) {
        wsprintf (szKey,
                  GP_EXTENSIONS_KEY,
                  lpExtName);
    } else {
        wsprintf (szKey,
                  GP_EXTENSIONS_SID_KEY,
                  lpwszSidUser, lpExtName);
    }

    lResult = RegCreateKeyEx (lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot,
                            szKey, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to create reg key with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwStatus);
    lResult = RegSetValueEx (hKey, TEXT("Status"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwStatus), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set status reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwRsopStatus);
    lResult = RegSetValueEx (hKey, TEXT("RsopStatus"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwRsopStatus), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set rsop status reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwTime);
    lResult = RegSetValueEx (hKey, TEXT("LastPolicyTime"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwTime), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set time reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwSlowLink);
    lResult = RegSetValueEx (hKey, TEXT("PrevSlowLink"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwSlowLink), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set slowlink reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwRsopLogging);
    lResult = RegSetValueEx (hKey, TEXT("PrevRsopLogging"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwRsopLogging), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set RsopLogging reg value with %d."), lResult));
        goto Exit;
    }


    dwSize = sizeof(lpExtStatus->bForceRefresh);
    lResult = RegSetValueEx (hKey, TEXT("ForceRefreshFG"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->bForceRefresh), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set ForceRefresh reg value with %d."), lResult));
        goto Exit;
    }
    

    bResult = TRUE;

Exit:
    if ( hKey != NULL )
        RegCloseKey( hKey );

    if ( hKeyExt != NULL )
        RegCloseKey( hKeyExt );
        
    return bResult;
}



//*************************************************************
//
//  ReadStatus()
//
//  Purpose:    Reads status from the registry
//
//  Parameters: lpKeyName   -  Extension name
//              lpGPOInfo   -  GPO info
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//        (out) lpExtStatus -  The extension status returned.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

void ReadStatus ( TCHAR *lpKeyName, LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser,  LPGPEXTSTATUS lpExtStatus )
{
    HKEY hKey = NULL, hKeyExt = NULL;
    DWORD dwType, dwSize;
    LONG lResult;
    BOOL bResult = FALSE;
    TCHAR szKey[400];
    XLastError xe;

    memset(lpExtStatus, 0, sizeof(GPEXTSTATUS));

    if ( lpwszSidUser == 0 ) {
        wsprintf (szKey,
                  GP_EXTENSIONS_KEY,
                  lpKeyName);
    } else {
        wsprintf (szKey,
                  GP_EXTENSIONS_SID_KEY,
                  lpwszSidUser, lpKeyName);
    }

    lResult = RegOpenKeyEx (lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot,
                            szKey,
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        if (lResult != ERROR_FILE_NOT_FOUND) {
            DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to open reg key with %d."), lResult));
        }
        xe = lResult;
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("Status"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwStatus),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        if (lResult != ERROR_FILE_NOT_FOUND) {
            DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read status reg value with %d."), lResult));
        }
        xe = lResult;
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("RsopStatus"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwRsopStatus),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        if (lResult != ERROR_FILE_NOT_FOUND) {
            DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read rsop status reg value with %d."), lResult));
        }

        // rsop status was not found. treat it as a legacy cse not supporting rsop
        lpExtStatus->dwRsopStatus = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        xe = lResult;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("LastPolicyTime"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwTime),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read time reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("PrevSlowLink"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwSlowLink),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read slowlink reg value with %d."), lResult));
        goto Exit;
    }


    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("PrevRsopLogging"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwRsopLogging),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read rsop logging reg value with %d."), lResult));

        //
        // This can fail currently (first time or run first time after upgrade) with File not found.
        // we will treat it as if logging was not turned on.
    }


    lpExtStatus->bForceRefresh = FALSE;
    dwSize = sizeof(lpExtStatus->bForceRefresh);
    lResult = RegQueryValueEx( hKey, TEXT("ForceRefreshFG"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->bForceRefresh),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read ForceRefreshFG value with %d."), lResult));

    }

    
    DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Read Extension's Previous status successfully.")));
    bResult = TRUE;

Exit:
    if ( hKey != NULL )
        RegCloseKey( hKey );

    if ( hKeyExt != NULL )
        RegCloseKey( hKeyExt );
        
    lpExtStatus->bStatus = bResult;
}



//*************************************************************
//
//  ReadExtStatus()
//
//  Purpose:    Reads all the extensions status
//
//  Parameters: lpGPOInfo       -  GPOInfo structure
//
//  Return:     TRUE if successful
//              FALSE otherwise
//
//*************************************************************

BOOL ReadExtStatus(LPGPOINFO lpGPOInfo)
{
    LPGPEXT lpExt = lpGPOInfo->lpExtensions;

    while ( lpExt ) {

        BOOL bUsePerUserLocalSetting = lpExt->dwUserLocalSetting && !(lpGPOInfo->dwFlags & GP_MACHINE);

        lpExt->lpPrevStatus = (LPGPEXTSTATUS) LocalAlloc(LPTR, sizeof(GPEXTSTATUS));

        if (!(lpExt->lpPrevStatus)) {
            DebugMsg((DM_WARNING, TEXT("ReadExtStatus: Couldn't allocate memory")));
            CEvents ev(TRUE, EVENT_OUT_OF_MEMORY);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            return FALSE;
            // Things that are already allocated will be freed by the caller
        }


        DmAssert( !bUsePerUserLocalSetting || lpGPOInfo->lpwszSidUser != 0 );

        DebugMsg((DM_VERBOSE, TEXT("ReadExtStatus: Reading Previous Status for extension %s"), lpExt->lpKeyName));

        ReadStatus( lpExt->lpKeyName, lpGPOInfo,
                         bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL,
                         lpExt->lpPrevStatus );

        lpExt = lpExt->pNext;
    }

    return TRUE;
}




//*************************************************************
//
//  HistoryPresent()
//
//  Purpose:    Checks if the current extension has any cached
//              GPOs
//
//  Parameters: lpGPOInfo   -   GPOInfo
//              lpExt       -   Extension
//
//
//  Return:     TRUE if cached GPOs present
//              FALSE otherwise
//
//*************************************************************

BOOL HistoryPresent( LPGPOINFO lpGPOInfo, LPGPEXT lpExt )
{
    TCHAR szKey[400];
    LONG lResult;
    HKEY hKey;

    wsprintf( szKey, GP_HISTORY_KEY, lpExt->lpKeyName );

    lResult = RegOpenKeyEx ( lpGPOInfo->hKeyRoot,
                             szKey,
                             0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {

        RegCloseKey( hKey );
        return TRUE;

    }

    //
    // Check if history is cached on per user per machine basis
    //

    BOOL bUsePerUserLocalSetting = lpExt->dwUserLocalSetting && !(lpGPOInfo->dwFlags & GP_MACHINE);

    DmAssert( !bUsePerUserLocalSetting || lpGPOInfo->lpwszSidUser != 0 );

    if ( bUsePerUserLocalSetting ) {

        wsprintf( szKey, GP_HISTORY_SID_KEY, lpGPOInfo->lpwszSidUser, lpExt->lpKeyName );
        lResult = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                                 szKey,
                                 0, KEY_READ, &hKey);

        if (lResult == ERROR_SUCCESS) {
            RegCloseKey( hKey );
            return TRUE;
        } else
            return FALSE;

    }

    return FALSE;
}


//*************************************************************
//
//  MigrateMembershipData()
//
//  Purpose:    Moves group membership data from old sid to new
//              sid.
//
//  Parameters: lpwszSidUserNew - New sid
//              lpwszSidUserOld - Old sid
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL MigrateMembershipData( LPTSTR lpwszSidUserNew, LPTSTR lpwszSidUserOld )
{
    DWORD dwCount = 0;
    DWORD dwSize, dwType, dwMaxSize, dwDisp;
    DWORD i= 0;
    LONG lResult;
    HKEY hKeyRead = NULL, hKeyWrite = NULL;
    BOOL bResult = TRUE;
    LPTSTR lpSid = NULL;
    TCHAR szKeyRead[250];
    TCHAR szKeyWrite[250];
    TCHAR szGroup[30];
    XLastError xe;

    wsprintf( szKeyRead, GP_MEMBERSHIP_KEY, lpwszSidUserOld );

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKeyRead, 0, KEY_READ, &hKeyRead);

    if (lResult != ERROR_SUCCESS)
        return TRUE;

    wsprintf( szKeyWrite, GP_MEMBERSHIP_KEY, lpwszSidUserNew );

    if ( !RegDelnode( HKEY_LOCAL_MACHINE, szKeyWrite ) ) {
        xe = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("MigrateMembershipData: RegDelnode failed.")));
        bResult = FALSE;
        goto Exit;
    }

    lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKeyWrite, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyWrite, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to create key with %d."), lResult));
        bResult = FALSE;
        goto Exit;
    }

    dwSize = sizeof(dwCount);
    lResult = RegQueryValueEx (hKeyRead, TEXT("Count"), NULL, &dwType,
                               (LPBYTE) &dwCount, &dwSize);
    if ( lResult != ERROR_SUCCESS ) {
        xe = lResult;
        DebugMsg((DM_VERBOSE, TEXT("MigrateMembershipData: Failed to read membership count")));
        goto Exit;
    }


    lResult = RegQueryInfoKey (hKeyRead, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               &dwMaxSize, NULL, NULL);
    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to query max size with %d."), lResult));
        goto Exit;
    }

    //
    // RegQueryInfoKey does not account for trailing 0 in strings
    //

    dwMaxSize += sizeof( WCHAR );

    
    //
    // Allocate buffer based upon the largest value
    //

    lpSid = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

    if (!lpSid) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to allocate memory with %d."), lResult));
        bResult = FALSE;
        goto Exit;
    }

    for ( i=0; i<dwCount; i++ ) {

        wsprintf( szGroup, TEXT("Group%d"), i );

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hKeyRead, szGroup, NULL, &dwType, (LPBYTE) lpSid, &dwSize);
        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to read value %ws"), szGroup ));
            goto Exit;
        }

        dwSize = (lstrlen(lpSid) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKeyWrite, szGroup, 0, REG_SZ, (LPBYTE) lpSid, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            bResult = FALSE;
            DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to write value %ws"), szGroup ));
            goto Exit;
        }

    }

    dwSize = sizeof(dwCount);
    lResult = RegSetValueEx (hKeyWrite, TEXT("Count"), 0, REG_DWORD, (LPBYTE) &dwCount, dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        bResult = FALSE;
        DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to write count value") ));
        goto Exit;
    }


Exit:

    if ( lpSid )
        LocalFree( lpSid );

    if ( hKeyRead )
        RegCloseKey (hKeyRead);

    if ( hKeyWrite )
        RegCloseKey (hKeyWrite);

    return bResult;
}


//*************************************************************
//
//  MigrateGPOData()
//
//  Purpose:    Moves cached GPOs from old sid to new
//              sid.
//
//  Parameters: lpGPOInfo       -   GPOInfo
//              lpwszSidUserNew - New sid
//              lpwszSidUserOld - Old sid
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL MigrateGPOData( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUserNew, LPTSTR lpwszSidUserOld )
{
    TCHAR szKey[250];
    LONG lResult;
    HKEY hKey = NULL;
    DWORD dwIndex = 0;
    TCHAR szExtension[50];
    DWORD dwSize = 50;
    FILETIME ftWrite;
    PGROUP_POLICY_OBJECT pGPOList, lpGPO, lpGPOTemp;
    BOOL bResult;
    XLastError xe;

    wsprintf( szKey, GP_HISTORY_SID_ROOT_KEY, lpwszSidUserOld );

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey);
    if ( lResult != ERROR_SUCCESS )
        return TRUE;

    while (RegEnumKeyEx (hKey, dwIndex, szExtension, &dwSize,
                         NULL, NULL, NULL, &ftWrite) == ERROR_SUCCESS ) {

        if ( ReadGPOList( szExtension, NULL, HKEY_LOCAL_MACHINE,
                         lpwszSidUserOld, FALSE, &pGPOList) ) {

            bResult = SaveGPOList( szExtension, lpGPOInfo, HKEY_LOCAL_MACHINE,
                                   lpwszSidUserNew, FALSE, pGPOList );
            lpGPO = pGPOList;

            while (lpGPO) {
                lpGPOTemp = lpGPO->pNext;
                LocalFree (lpGPO);
                lpGPO = lpGPOTemp;
            }

            if ( !bResult ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("MigrateGPOData: Failed to save GPO list") ));
                RegCloseKey( hKey );
                return FALSE;
            }

        }

        dwSize = ARRAYSIZE(szExtension);
        dwIndex++;
    }

    RegCloseKey( hKey );
    return TRUE;
}


//*************************************************************
//
//  MigrateStatusData()
//
//  Purpose:    Moves extension status data from old sid to new
//              sid.
//
//  Parameters: lpGPOInfo       -   GPOInfo
//              lpwszSidUserNew - New sid
//              lpwszSidUserOld - Old sid
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL MigrateStatusData( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUserNew, LPTSTR lpwszSidUserOld )
{
    TCHAR szKey[250];
    LONG lResult;
    HKEY hKey = NULL;
    DWORD dwIndex = 0;
    TCHAR szExtension[50];
    DWORD dwSize = 50;
    FILETIME ftWrite;
    BOOL bTemp;
    XLastError xe;

    wsprintf( szKey, GP_EXTENSIONS_SID_ROOT_KEY, lpwszSidUserOld );

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey);
    if ( lResult != ERROR_SUCCESS )
        return TRUE;

    while (RegEnumKeyEx (hKey, dwIndex, szExtension, &dwSize,
                         NULL, NULL, NULL, &ftWrite) == ERROR_SUCCESS ) {

        GPEXTSTATUS gpExtStatus;

        ReadStatus( szExtension, lpGPOInfo, lpwszSidUserOld, &gpExtStatus);

        if (gpExtStatus.bStatus) {
            bTemp = WriteStatus( szExtension, lpGPOInfo, lpwszSidUserNew, &gpExtStatus );

            if ( !bTemp ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("MigrateStatusData: Failed to save status") ));
                RegCloseKey( hKey );
                return FALSE;
            }
        }

        dwSize = ARRAYSIZE(szExtension);
        dwIndex++;
    }

    RegCloseKey( hKey );
    return TRUE;

}



//*************************************************************
//
//  CheckForChangedSid()
//
//  Purpose:    Checks if the user's sid has changed and if so,
//              moves history data from old sid to new sid.
//
//  Parameters: lpGPOInfo   -   GPOInfo
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL CheckForChangedSid (LPGPOINFO lpGPOInfo, CLocator *locator)
{
    TCHAR szKey[400];
    LONG lResult;
    HKEY hKey = NULL;
    LPTSTR lpwszSidUserOld = NULL;
    DWORD dwDisp;
    BOOL bCommit = FALSE;      // True, if move of history data should be committed
    XLastError xe;

    //
    // initialize it to FALSE at the beginning and if the Sid has
    // changed we will set it to true later on..
    //

    lpGPOInfo->bSidChanged = FALSE;

    if ( lpGPOInfo->dwFlags & GP_MACHINE )
        return TRUE;


    if ( lpGPOInfo->lpwszSidUser == 0 ) {

        lpGPOInfo->lpwszSidUser = GetSidString( lpGPOInfo->hToken );
        if ( lpGPOInfo->lpwszSidUser == 0 ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: GetSidString failed.")));
            CEvents ev(TRUE, EVENT_FAILED_GET_SID); ev.Report();
            return FALSE;
        }
    }

    if (!(lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY))
        return TRUE;

    //
    // Check if the key where history is cached exists
    //

    wsprintf( szKey, GP_POLICY_SID_KEY, lpGPOInfo->lpwszSidUser );

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey);

    if ( lResult == ERROR_SUCCESS ) {
        RegCloseKey( hKey );
        return TRUE;
    }

    if ( lResult != ERROR_FILE_NOT_FOUND ) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: Failed to open registry key with %d."),
                  lResult ));
        return FALSE;
    }

    //
    // This is the first time that we are seeing this sid, it can either be a brand new sid or
    // an old sid that has been renamed.
    //

    lpwszSidUserOld =  GetOldSidString( lpGPOInfo->hToken, POLICY_GUID_PATH );

    if ( !lpwszSidUserOld )
    {
        //
        // Brand new sid
        //

        if ( !SetOldSidString(lpGPOInfo->hToken, lpGPOInfo->lpwszSidUser, POLICY_GUID_PATH) ) {
             xe = GetLastError();
             DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: WriteSidMapping failed.") ));

             CEvents ev(TRUE, EVENT_FAILED_WRITE_SID_MAPPING); ev.Report();
             return FALSE;
        }

        lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: RegCreateKey failed.") ));
            return TRUE;
        }

        RegCloseKey( hKey );

        return TRUE;
    }
    else
    {
        DeletePolicyState( lpwszSidUserOld );
    }

    //
    // Need to migrate history data from old sid to new sid
    //

    if ( !MigrateMembershipData( lpGPOInfo->lpwszSidUser, lpwszSidUserOld ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: MigrateMembershipData failed.") ));
        CEvents ev(TRUE, EVENT_FAILED_MIGRATION); ev.Report();
        goto Exit;
    }

    if ( !MigrateGPOData( lpGPOInfo, lpGPOInfo->lpwszSidUser, lpwszSidUserOld ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: MigrateGPOData failed.") ));
        CEvents ev(TRUE, EVENT_FAILED_MIGRATION); ev.Report();
        goto Exit;
    }

    if ( !MigrateStatusData( lpGPOInfo, lpGPOInfo->lpwszSidUser, lpwszSidUserOld ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: MigrateStatusData failed.") ));
        CEvents ev(TRUE, EVENT_FAILED_MIGRATION); ev.Report();
        goto Exit;
    }


    //
    // Migrate Rsop Data, ignore failures
    //
    
    if (locator->GetWbemLocator()) {
        XPtrLF<WCHAR> xszRsopNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*
                                            (lstrlen(RSOP_NS_DIAG_USER_FMT)+
                                            lstrlen(lpwszSidUserOld)+10));

        // convert the Sids to WMI Names
        XPtrLF<WCHAR> xszWmiNameOld = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpwszSidUserOld)+1));
        XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpGPOInfo->lpwszSidUser)+1));


        if ((xszRsopNameSpace) && (xszWmiNameOld) && (xszWmiName)) {

            ConvertSidToWMIName(lpwszSidUserOld, xszWmiNameOld);
            ConvertSidToWMIName(lpGPOInfo->lpwszSidUser, xszWmiName);
        
            wsprintf(xszRsopNameSpace, RSOP_NS_DIAG_USER_FMT, xszWmiNameOld);
            
            CreateAndCopyNameSpace(locator->GetWbemLocator(), xszRsopNameSpace, RSOP_NS_DIAG_USERROOT, 
                                   xszWmiName, NEW_NS_FLAGS_COPY_CLASSES | NEW_NS_FLAGS_COPY_INSTS, 
                                   NULL, NULL);

        } else {
            DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: couldn't allocate memory.") ));
        }
            
    } else {
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: couldn't get WMI locator.") ));
    }

    bCommit = TRUE;

Exit:

    if ( bCommit ) {

        if ( !SetOldSidString(lpGPOInfo->hToken, lpGPOInfo->lpwszSidUser, POLICY_GUID_PATH) )
             DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: SetOldString failed.") ));

        lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult == ERROR_SUCCESS)
            RegCloseKey( hKey );
        else
            DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: RegCreateKey failed.") ));

        wsprintf( szKey, GP_POLICY_SID_KEY, lpwszSidUserOld );
        RegDelnode( HKEY_LOCAL_MACHINE, szKey );

        wsprintf( szKey, GP_LOGON_SID_KEY, lpwszSidUserOld );
        RegDelnode( HKEY_LOCAL_MACHINE, szKey );


        //
        // if we managed to successfully migrate everything
        //

        lpGPOInfo->bSidChanged = TRUE;


    } else {

        wsprintf( szKey, GP_POLICY_SID_KEY, lpGPOInfo->lpwszSidUser );
        RegDelnode( HKEY_LOCAL_MACHINE, szKey );

        wsprintf( szKey, GP_LOGON_SID_KEY, lpGPOInfo->lpwszSidUser );
        RegDelnode( HKEY_LOCAL_MACHINE, szKey );

    }

    if ( lpwszSidUserOld )
        LocalFree( lpwszSidUserOld );

    return bCommit;
}


//*************************************************************
//
//  ReadGPExtensions()
//
//  Purpose:    Reads the group policy extenions from registry.
//              The actual loading of extension is deferred.
//
//  Parameters: lpGPOInfo   -   GP Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ReadGPExtensions (LPGPOINFO lpGPOInfo)
{
    TCHAR szSubKey[MAX_PATH];
    DWORD dwType;
    HKEY hKey, hKeyOverride;
    DWORD dwIndex = 0;
    DWORD dwSize = 50;
    TCHAR szDisplayName[50];
    TCHAR szKeyName[50];
    TCHAR szDllName[MAX_PATH+1];
    TCHAR szExpDllName[MAX_PATH+1];
    CHAR  szFunctionName[100];
    CHAR  szRsopFunctionName[100];
    FILETIME ftWrite;
    HKEY hKeyExt;
    HINSTANCE hInstDLL;
    LPGPEXT lpExt, lpTemp;
    //
    // Check if any extensions are registered
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      GP_EXTENSIONS,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {


        //
        // Enumerate the keys (each extension has its own key)
        //

        while (RegEnumKeyEx (hKey, dwIndex, szKeyName, &dwSize,
                                NULL, NULL, NULL, &ftWrite) == ERROR_SUCCESS) {


            //
            // Open the extension's key.
            //

            if (RegOpenKeyEx (hKey, szKeyName,
                              0, KEY_READ, &hKeyExt) == ERROR_SUCCESS) {

                if ( ValidateGuid( szKeyName ) ) {

                    if ( lstrcmpi(szKeyName, c_szRegistryExtName) != 0 ) {

                        //
                        // Every extension, other than RegistryExtension is required to have a value called
                        // DllName.  This value can be REG_SZ or REG_EXPAND_SZ type.
                        //

                        dwSize = sizeof(szDllName);
                        if (RegQueryValueEx (hKeyExt, TEXT("DllName"), NULL,
                                             &dwType, (LPBYTE) szDllName,
                                             &dwSize) == ERROR_SUCCESS) {

                            BOOL bFuncFound = FALSE;
                            BOOL bNewInterface = FALSE;

                            DWORD dwNoMachPolicy = FALSE;
                            DWORD dwNoUserPolicy = FALSE;
                            DWORD dwNoSlowLink   = FALSE;
                            DWORD dwNoBackgroundPolicy = FALSE;
                            DWORD dwNoGPOChanges = FALSE;
                            DWORD dwUserLocalSetting = FALSE;
                            DWORD dwRequireRegistry = FALSE;
                            DWORD dwEnableAsynch = FALSE;
                            DWORD dwMaxChangesInterval = 0;
                            DWORD dwLinkTransition = FALSE;
                            WCHAR szEventLogSources[MAX_PATH+1];
                            DWORD dwSizeEventLogSources = MAX_PATH+1;


                            ExpandEnvironmentStrings (szDllName, szExpDllName, MAX_PATH);

                            //
                            // Read new interface name, if failed read old interface name
                            //

                            dwSize = sizeof(szFunctionName);

                            if ( RegQueryValueExA (hKeyExt, "ProcessGroupPolicyEx", NULL,
                                                   &dwType, (LPBYTE) szFunctionName,
                                                   &dwSize) == ERROR_SUCCESS ) {
                                 bFuncFound = TRUE;
                                 bNewInterface = TRUE;

                            } else if ( RegQueryValueExA (hKeyExt, "ProcessGroupPolicy", NULL,
                                                         &dwType, (LPBYTE) szFunctionName,
                                                         &dwSize) == ERROR_SUCCESS ) {
                                bFuncFound = TRUE;
                            }

                            if (  bFuncFound) {

                                //
                                // Read preferences
                                //

                                dwSize = sizeof(szDisplayName);
                                if (RegQueryValueEx (hKeyExt, NULL, NULL,
                                                     &dwType, (LPBYTE) szDisplayName,
                                                     &dwSize) != ERROR_SUCCESS) {
                                    lstrcpyn (szDisplayName, szKeyName, ARRAYSIZE(szDisplayName));
                                }

                                dwSize = sizeof(szRsopFunctionName);
                                if (RegQueryValueExA (hKeyExt, "GenerateGroupPolicy", NULL,
                                                      &dwType, (LPBYTE) szRsopFunctionName,
                                                      &dwSize) != ERROR_SUCCESS) {
                                    szRsopFunctionName[0] = 0;
                                    DebugMsg((DM_VERBOSE, TEXT("ReadGPExtensions: Rsop entry point not found for %s."),
                                                szExpDllName));

#if 0
                                    if ((!(lpGPOInfo->dwFlags & GP_PLANMODE)) &&
                                        (lpGPOInfo->dwFlags & GP_MACHINE) && 
                                        (!(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)) &&
                                        (lpGPOInfo->iMachineRole == 3)) {

                                        //
                                        // Not in planning mode and foreground machine policy processing 
                                        // (only on DC)
                                        //

                                        CEvents ev(TRUE, EVENT_PLANMODE_NOTSUPPORTED);
                                        ev.AddArg(szDisplayName); 
                                        ev.Report();
                                    }
#endif
                                }

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("NoMachinePolicy"), NULL,
                                                 &dwType, (LPBYTE) &dwNoMachPolicy,
                                                 &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("NoUserPolicy"), NULL,
                                                 &dwType, (LPBYTE) &dwNoUserPolicy,
                                                 &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("NoSlowLink"), NULL,
                                                     &dwType, (LPBYTE) &dwNoSlowLink,
                                                     &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("NoGPOListChanges"), NULL,
                                                     &dwType, (LPBYTE) &dwNoGPOChanges,
                                                     &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("NoBackgroundPolicy"), NULL,
                                                     &dwType, (LPBYTE) &dwNoBackgroundPolicy,
                                                     &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("PerUserLocalSettings"), NULL,
                                                 &dwType, (LPBYTE) &dwUserLocalSetting,
                                                 &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("RequiresSuccessfulRegistry"), NULL,
                                                 &dwType, (LPBYTE) &dwRequireRegistry,
                                                 &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("EnableAsynchronousProcessing"), NULL,
                                                 &dwType, (LPBYTE) &dwEnableAsynch,
                                                 &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("MaxNoGPOListChangesInterval"), NULL,
                                                 &dwType, (LPBYTE) &dwMaxChangesInterval,
                                                 &dwSize );

                                RegQueryValueEx( hKeyExt, TEXT("NotifyLinkTransition"), NULL,
                                                 &dwType, (LPBYTE) &dwLinkTransition,
                                                 &dwSize );

                                if (RegQueryValueEx( hKeyExt, TEXT("EventSources"), 0,
                                                 &dwType, (LPBYTE) &szEventLogSources,
                                                 &dwSizeEventLogSources ) != ERROR_SUCCESS) {
                                    dwSizeEventLogSources = 0;
                                    szEventLogSources[0] = TEXT('\0');
                                }

                                //
                                // Read override policy values, if any
                                //

                                wsprintf (szSubKey, GP_EXTENSIONS_POLICIES, szKeyName );

                                if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                                  szSubKey,
                                                  0, KEY_READ, &hKeyOverride ) == ERROR_SUCCESS) {

                                    dwSize = sizeof(DWORD);
                                    RegQueryValueEx( hKeyOverride, TEXT("NoSlowLink"), NULL,
                                                     &dwType, (LPBYTE) &dwNoSlowLink,
                                                     &dwSize );

                                    RegQueryValueEx( hKeyOverride, TEXT("NoGPOListChanges"), NULL,
                                                     &dwType, (LPBYTE) &dwNoGPOChanges,
                                                     &dwSize );

                                    RegQueryValueEx( hKeyOverride, TEXT("NoBackgroundPolicy"), NULL,
                                                     &dwType, (LPBYTE) &dwNoBackgroundPolicy,
                                                     &dwSize );

                                    RegCloseKey( hKeyOverride );
                                }

                            }

                            if ( bFuncFound ) {

                                lpExt = (LPGPEXT) LocalAlloc (LPTR, sizeof(GPEXT)
                                                          + ((lstrlen(szDisplayName) + 1) * sizeof(TCHAR))
                                                          + ((lstrlen(szKeyName) + 1) * sizeof(TCHAR))
                                                          + ((lstrlen(szExpDllName) + 1) * sizeof(TCHAR))
                                                          + lstrlenA(szFunctionName) + 1
                                                          + lstrlenA(szRsopFunctionName) + 1 );
                                if (lpExt) {

                                    //
                                    // Set up all fields
                                    //

                                    lpExt->lpDisplayName = (LPTSTR)((LPBYTE)lpExt + sizeof(GPEXT));
                                    lstrcpy( lpExt->lpDisplayName, szDisplayName );

                                    lpExt->lpKeyName = lpExt->lpDisplayName + lstrlen(lpExt->lpDisplayName) + 1;
                                    lstrcpy( lpExt->lpKeyName, szKeyName );

                                    StringToGuid( szKeyName, &lpExt->guid );

                                    lpExt->lpDllName = lpExt->lpKeyName + lstrlen(lpExt->lpKeyName) + 1;
                                    lstrcpy (lpExt->lpDllName, szExpDllName);

                                    lpExt->lpFunctionName = (LPSTR)( (LPBYTE)lpExt->lpDllName + (lstrlen(lpExt->lpDllName) + 1) * sizeof(TCHAR) );
                                    lstrcpyA( lpExt->lpFunctionName, szFunctionName );

                                    if ( szRsopFunctionName[0] == 0 ) {
                                        lpExt->lpRsopFunctionName = 0;
                                    } else {
                                        lpExt->lpRsopFunctionName = (LPSTR)( (LPBYTE)lpExt->lpDllName + (lstrlen(lpExt->lpDllName) + 1) * sizeof(TCHAR)
                                                                             + lstrlenA(szFunctionName) + 1);
                                        lstrcpyA( lpExt->lpRsopFunctionName, szRsopFunctionName );
                                    }

                                    lpExt->hInstance = NULL;
                                    lpExt->pEntryPoint = NULL;
                                    lpExt->pEntryPointEx = NULL;
                                    lpExt->bNewInterface = bNewInterface;

                                    lpExt->dwNoMachPolicy = dwNoMachPolicy;
                                    lpExt->dwNoUserPolicy = dwNoUserPolicy;
                                    lpExt->dwNoSlowLink = dwNoSlowLink;
                                    lpExt->dwNoBackgroundPolicy = dwNoBackgroundPolicy;
                                    lpExt->dwNoGPOChanges = dwNoGPOChanges;
                                    lpExt->dwUserLocalSetting = dwUserLocalSetting;
                                    lpExt->dwRequireRegistry = dwRequireRegistry;
                                    lpExt->dwEnableAsynch = dwEnableAsynch;
                                    lpExt->dwMaxChangesInterval = dwMaxChangesInterval;
                                    lpExt->dwLinkTransition = dwLinkTransition;

                                    if ( dwSizeEventLogSources )
                                    {
                                        lpExt->szEventLogSources = (LPWSTR) LocalAlloc( LPTR, dwSizeEventLogSources+2 );
                                        if ( lpExt->szEventLogSources )
                                        {
                                            memcpy( lpExt->szEventLogSources, szEventLogSources, dwSizeEventLogSources );
                                        }
                                    }

                                    lpExt->bRegistryExt = FALSE;
                                    lpExt->bSkipped = FALSE;
                                    lpExt->pNext = NULL;

                                    //
                                    // Append to end of extension list
                                    //

                                    if (lpGPOInfo->lpExtensions) {

                                        lpTemp = lpGPOInfo->lpExtensions;

                                        while (TRUE) {
                                            if (lpTemp->pNext) {
                                                lpTemp = lpTemp->pNext;
                                            } else {
                                                break;
                                            }
                                        }

                                        lpTemp->pNext = lpExt;

                                    } else {
                                        lpGPOInfo->lpExtensions = lpExt;
                                    }

                                } else {   // if lpExt
                                    DebugMsg((DM_WARNING, TEXT("ReadGPExtensions: Failed to allocate memory with %d"),
                                              GetLastError()));
                                }
                            } else {       // if bFuncFound
                                DebugMsg((DM_WARNING, TEXT("ReadGPExtensions: Failed to query for the function name.")));
                                CEvents ev(TRUE, EVENT_EXT_MISSING_FUNC);
                                ev.AddArg(szExpDllName); ev.Report();
                            }
                        } else {           // if RegQueryValueEx DllName
                            DebugMsg((DM_WARNING, TEXT("ReadGPExtensions: Failed to query DllName value.")));
                            CEvents ev(TRUE, EVENT_EXT_MISSING_DLLNAME);
                            ev.AddArg(szKeyName); ev.Report();
                        }

                        
#if 0
                        if (!lpExt->bNewInterface) {
                            if ((!(lpGPOInfo->dwFlags & GP_PLANMODE)) && 
                                (lpGPOInfo->dwFlags & GP_MACHINE) &&
                                (!(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD))) {

                                //
                                // Not in planning mode and foreground machine policy processing
                                //
                                
                                CEvents ev(TRUE, EVENT_DIAGMODE_NOTSUPPORTED);
                                ev.AddArg(lpExt->lpDisplayName); 
                                ev.Report();
                            }
                        }
#endif

                    } // if lstrcmpi(szKeyName, c_szRegistryExtName)

                }  // if validateguid

                RegCloseKey (hKeyExt);
            }     // if RegOpenKey hKeyExt

            dwSize = ARRAYSIZE(szKeyName);
            dwIndex++;
        }         // while RegEnumKeyEx

        RegCloseKey (hKey);
    }             // if RegOpenKey gpext

    //
    // Add the registry psuedo extension at the beginning
    //

    if ( LoadString (g_hDllInstance, IDS_REGISTRYNAME, szDisplayName, ARRAYSIZE(szDisplayName)) ) {

        lpExt = (LPGPEXT) LocalAlloc (LPTR, sizeof(GPEXT)
                            + ((lstrlen(szDisplayName) + 1) * sizeof(TCHAR))
                            + ((lstrlen(c_szRegistryExtName) + 1) * sizeof(TCHAR)) );
    } else {

        lpExt = 0;
    }

    if (lpExt) {

        DWORD dwNoSlowLink = FALSE;
        DWORD dwNoGPOChanges = TRUE;
        DWORD dwNoBackgroundPolicy = FALSE;

        lpExt->lpDisplayName = (LPTSTR)((LPBYTE)lpExt + sizeof(GPEXT));
        lstrcpy( lpExt->lpDisplayName, szDisplayName );

        lpExt->lpKeyName = lpExt->lpDisplayName + lstrlen(lpExt->lpDisplayName) + 1;
        lstrcpy( lpExt->lpKeyName, c_szRegistryExtName );

        StringToGuid( lpExt->lpKeyName, &lpExt->guid );

        lpExt->lpDllName = L"userenv.dll";
        lpExt->lpFunctionName = NULL;
        lpExt->hInstance = NULL;
        lpExt->pEntryPoint = NULL;

        //
        // Read override policy values, if any
        //

        wsprintf (szSubKey, GP_EXTENSIONS_POLICIES, lpExt->lpKeyName );

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                          szSubKey,
                          0, KEY_READ, &hKeyOverride ) == ERROR_SUCCESS) {

            RegQueryValueEx( hKeyOverride, TEXT("NoGPOListChanges"), NULL,
                             &dwType, (LPBYTE) &dwNoGPOChanges,
                             &dwSize );

            RegQueryValueEx( hKeyOverride, TEXT("NoBackgroundPolicy"), NULL,
                             &dwType, (LPBYTE) &dwNoBackgroundPolicy,
                             &dwSize );
            RegCloseKey( hKeyOverride );

        }

        lpExt->dwNoMachPolicy = FALSE;
        lpExt->dwNoUserPolicy = FALSE;
        lpExt->dwNoSlowLink = dwNoSlowLink;
        lpExt->dwNoBackgroundPolicy = dwNoBackgroundPolicy;
        lpExt->dwNoGPOChanges = dwNoGPOChanges;
        lpExt->dwUserLocalSetting = FALSE;
        lpExt->dwRequireRegistry = FALSE;
        lpExt->dwEnableAsynch = FALSE;
        lpExt->dwLinkTransition = FALSE;

        lpExt->bRegistryExt = TRUE;
        lpExt->bSkipped = FALSE;
        lpExt->bNewInterface = TRUE;

        lpExt->pNext = lpGPOInfo->lpExtensions;
        lpGPOInfo->lpExtensions = lpExt;

    } else {
        DebugMsg((DM_WARNING, TEXT("ReadGPExtensions: Failed to allocate memory with %d"),
                  GetLastError()));

        return FALSE;

    }

    return TRUE;
}




//*************************************************************
//
//  ReadMembershipList()
//
//  Purpose:    Reads cached memberhip list and checks if the
//              security groups has changed.
//
//  Parameters: lpGPOInfo - LPGPOINFO struct
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//              pGroups   - List of token groups
//
//  Return:     TRUE if changed
//              FALSE otherwise
//
//*************************************************************

BOOL ReadMembershipList( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, PTOKEN_GROUPS pGroupsCur )
{
    DWORD i= 0;
    LONG lResult;
    TCHAR szGroup[30];
    TCHAR szKey[250];
    HKEY hKey = NULL;
    BOOL bDiff = TRUE;
    DWORD dwCountOld = 0;
    DWORD dwSize, dwType, dwMaxSize;
    LPTSTR lpSid = NULL;

    DWORD dwCountCur = 0;

    //
    // Get current count of groups ignoring groups that have
    // the SE_GROUP_LOGON_ID attribute set as this sid will be different
    // for each logon session.
    //

    for ( i=0; i < pGroupsCur->GroupCount; i++) {
        if ( (SE_GROUP_LOGON_ID & pGroupsCur->Groups[i].Attributes) == 0 )
            dwCountCur++;
    }

    //
    // Read from cached group membership list
    //

    if ( lpwszSidUser == 0 )
        wsprintf( szKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\GroupMembership") );
    else
        wsprintf( szKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\GroupMembership"),
                  lpwszSidUser );


    lResult = RegOpenKeyEx ( lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot,
                             szKey,
     